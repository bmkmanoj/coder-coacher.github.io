<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Node.JS: The Good Parts? A Skeptic's View | Coder Coacher - Coaching Coders</title><meta content="Node.JS: The Good Parts? A Skeptic's View - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Node.JS: The Good Parts? A Skeptic's View</b></h2><h5 class="post__date">2013-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CN0jTnSROsk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so if you like me then you're a Java
developer who has never really liked
JavaScript it was just that weird quirky
language that you had to use in order to
get stuff done in the browser I remember
a few years ago probably 2005 like
learning about prototype and script
oculus and using a little bit of that
inside my um webpages and then back in
2008 2009 when I was building the
original Cloud Foundry comm we actually
used dojo as the toolkit to build the
front end I think it was pretty much you
know be fair to say that whenever we
said the words dojo or I'm JavaScript
they were preceded by up by words that I
can't actually use today we really
didn't have much fun using them so it
was all of this Java think the
JavaScript thing was this sort of weird
language that we kind of my colleagues
and myself we never really got into but
then over the past year you know I
started playing around with this
server-side JavaScript technology nodejs
and even with that I thought server-side
JavaScript was kind of a silly idea
given that there's so many good choices
available on the server but strangely
over the past year I've developed
somewhat of an appreciation for the
technology it definitely has its pros it
also has quite a few cons as well and so
my goal over the course of the next hour
is just to share with you my experiences
not as someone who's at no js' expert
because I'm I'm really just a beginner
with this technology but really as
someone who's coming from the jvm world
he's really into scarlet but has also
started to develop an appreciation for
nodejs
so before I get into that a little bit
about me so I actually grew up in
England and then moved to the San
Francisco Bay Area 23 years ago I got my
start program
in Lisp back in the late 80s Lisp of
course being one of those very early
dynamic functional and object-oriented
languages which you know the mainstream
well took quite had features that took
quite a while to become mainstream and
then eventually I ended up programming
in Java and back in 2005 I wrote the
book pojos in action which is all about
how to build applications with spring
and hibernate which back then were those
radically new technologies that were
prettier changing the Java world today
we pretty much take them for granted and
then back in 2007 I started playing
around with his obscure little thing
called Amazon ec2 no one had really had
ever heard of it just an evangelist came
and spoke at my local java users group
and blew my mind this notion that you
could rent servers by the hour and just
pay tenth back then ten cents an hour
per server and that got me interested in
cloud computing and led to my startup
Cloud Foundry which was then acquired by
SpringSource shortly before spring sauce
was acquired by VMware and so today I'm
sort of part of all of that I'm a
developer advocate and I just sort of
travel around give talks on architecture
give talks on cloud computing and so on
so here's the agenda going to spend a
whole chunk of time giving an overview
of nodejs
look at the three main components of
nodejs
and look at the good parts and look at
the bad part and then I'm going to talk
about what I think is a really
interesting use case for nodejs
using it as a front-end server sort of
as a mediator between the browser world
and between the nice enterprise-e world
that's written in languages that I much
prefer like Java and Scala and so on and
then I'm going to finish up by talking
about promises which is the JavaScript
community's term for futures which are
really nice a concurrency abstraction
for simplifying the asynchronous code
that you have to write when you when
you're programming
with JavaScript and with node okay so
diving in so sort of first question is
well what is node so node is a platform
it's built on the Google Chrome v8
JavaScript engine and its whole goal is
to let you write network applications
sort of these so-called dirty apps data
intensive real time applications which
are really applications that don't
actually do anything other than just
push bytes around on the network or on
the file system and the distinguishing
characteristic of it is that you write
your code in this asynchronous
non-blocking style which has the benefit
of being super scalable so node gets a
lot of buzz no but it turns out that the
community is actually quite small when
you compare it with a moment you're more
mature communities such as the Spring
Framework so you can see that node the
line at the bottom is kind of growing
but it's a lot smaller than than the
Spring Framework community though
interestingly the community is very very
big you can see that like the number of
downloads from the equivalent of the
maven repo is like 2 million a day
there's notes not exactly as sort of
apples to apples comparison but there's
like a lot of a lot of activity within
that community so here's an example node
program that I just copied off the
node.js website so it's a simple hello
world server so it sets up an HTTP
server that responds to every request
with the words hello world so you know
step one you can see that it's loading
the HTTP module so we need to do H we
need an HTTP server so we then go and
create one and the argument to the
create server function is a is that is
the request handler that takes the
recruit that gets the request and the
response as arguments and then just
writes 200 and the content-type and
writes hello world and we're done and
then you call dot listen on that saying
telling it to listen on port 1337 so you
know there's a really simple piece of
code sort of you know no ceremony
you just kind of could you edit that
create that with VI put in a file and
you just run it and you have this mini
app server which you know if you were to
do that in Java it would sort of take
kind of a lot more code to do that so
that's just the basic hello world so if
you actually look at node it's really
comprised at least in my opinion of
three main parts there's JavaScript the
language there's the reactor pattern
that's the asynchronous event-driven
programming model that it provides and
then there's this really really
interesting module system and there's
just thousands tens of thousands of
publicly available modules so I just
kind of want to talk about each one of
these components in turn kind of looking
at the good parts and looking at the bad
part so I want to start off by talking
about JavaScript so first off you hear
users JavaScript on a regular basis
anyone anyone like it yeah okay so I
apologize for any you know anything I
say that might cause offence
okay so JavaScript so you know the first
thing to note JavaScript is a dynamic
language so dynamic in the sense the
types are associated with values and not
variables and you can do things like
define new program elements at runtime
so you know it's in the same vein as
Ruby or groovy or Lisp or so on but
where it where it ends up being quite
different in my opinion is that it's
weakly typed you know you can do things
in JavaScript that you really can't do
in other languages not least normally
like leave out arguments when you cool
methods or access non-existent object
properties so it's all kind of loose you
know you don't get you don't get no such
property exceptions thrown when you try
and access a non-existent non-existent
property and you also have these weird
implicit conversions that mean that 99
is actually equal to the string 99 and
it's notion of what's true and false in
terms of a boolean value is quite quite
weak as well so it's this sort of
strange weakly tie
language it's also object-oriented in an
interesting way so an object is a
collection of key-value pairs or
properties so we can we can create one
here you know we can access we you know
we create an object we assign it to Fred
we can go Fred name which just gives us
back the name we can also go Fred Dodge
and that just comes back as undefined
once again that's because it's weakly
typed we can then give Fred a value that
actually just adds a new property to
that object we didn't have to define it
upfront or anything like that and then
if we want we can delete a property so
it's sort of very flexible very kind of
loose JavaScript kinda sorta has the
notion of classes as well so if you look
at this code well this is how you define
a class so you have a foot you have a
constructor function with a capitalized
first name and then you can go you know
which is kind of weird right and then
you can define a method by going the
function name dot prototype method name
which is sort of kind of this really
weird thing but then it gets familiar
you can create an instance of an object
by going new person name of the
constructor function and then passing in
some arguments and then you can invoke a
method in its sort of usual kind of way
but what's really interesting about this
is that the reason it looks weird is
because it was trying to appear to be
like Java when in fact it actually isn't
anything like Java under the covers
because Jarvis javascript is not a prote
is not a class-based language it
actually does not have classes in the
same in the sense that Java does you
know if you go back to the beginning of
time there's sort of two main
object-oriented paradigms you have the
class based approach which is kind of
what we know and love but there's this
alternative model so known as the
prototypal approach so whereas in the
class based approach you have classes
that define the structure and behave
a view of objects in a prototypical
model you don't have any distinction
between classes and objects you just
have objects and one object can inherit
from another object which is known as
its prototype so it's sort of a kind of
this very flat model and the proponents
of it say that it actually has some
advantages even though I mean I think
it's a very hasn't really been X even
though it's a very old model I remember
reading papers about this back 20 plus
years ago it's never actually sort of
caught on or been fully embraced so in
this example we've got two objects X and
y and X has properties a and B and then
Y actually inherits from X and it had
and it overrides the product of the
property a so it actually inherits B
from from its prototype but then defines
its own value for property a and that's
actually what's happening when you
define an object when you define sort of
these class like things is this and
instantiate objects with new this is
what's happening under under the covers
so if you to access it sort of look at
it kind of in the you know and it end
it's sort of a pure prototype away you
know first off we're going to define
this prototype person object so we
create a an empty object and assign it
to the variable person we can then
define a method called say hello which
just prints out hello and their name so
that you can notice that name is not
actually defined here it actually has to
be defined by one of the objects that
inherits from this prototype and then we
can go and create some objects so we to
do that we use the object create methods
so we're not actually using new we're
sort of doing it in the more pure
prototype or fashion an object dot
create takes two arguments the first is
the prototype that we want this new
object to inherit from and in this case
it's person and then we can differ then
we then we can supply values for some
properties so in this case we have a one
object whose name is Chris and another
object whose name is Sarah and then we
go object dot say hello and the right
thing gets printed out so it's sort of
you know so it's actually you know this
is more sort of quite you know the kind
of the right way of using JavaScript
rather than pretending that we actually
have classes and then we can if we want
because this is a dynamic language we
can actually at runtime just override
the kind of give kress its own say hello
method with totally different behavior
and that actually overrides what would
otherwise be in it be inherited from the
prototype so it's quite different from
java despite any kind of syntactic sugar
that tries to make it familiar and kind
of fails badly so javascript is also a
functional language so you can with you
can have function literals you can
return them from methods and you can
pass them as method arguments as well so
on this slide is an example of a make
generator function that returns a
function that's also a closure by the
way that then you can cool repeatedly to
generate a sequence of values so the
returned closure just repeatedly applies
this next function which is passed in
and in this case just as one and keeps
track of this of the current value in a
sort of local variable so it's
functional and it also actually supports
partial function / partial function
application as well so in this case join
is a is from a module that's really for
constructing joining elements of
together a file to make a file system
part so you can think of it as taking a
directory name and a file name and
giving you the absolute path and it's so
it takes at least two arguments and but
what we can do because JavaScript
supports partial function application is
partially apply it to just one argument
so we're just applying it passing in X
and that gives us a new function that's
cooled within X that we can then apply
to other arguments and that's kind of a
nice trick and you see the
same kind of thing in other layer in
other functional languages as well so
you can sort of just partially apply
arguments and then supply the rest of
them later okay so it's this dynamic
object-oriented prototype or functional
language so in a way that's kind of nice
that if you really dig into it
javascript was this language that was
created in a hurry and it tried to look
like Java I mean it's even sort of named
after Java but fails very badly and
behaving like Java because it really
isn't
you know we've got sort of fake classes
in that plus there's some truly horrible
features like there's just a global
namespace so there's no module system
and then a lower-level there's just one
confusing feature after another like the
scope of variables is confusing if you
leave out even though it's a functional
language you still have to have a return
statement there's no implicit return
value which can you just get undefined
if you don't have a return statement the
way you define function literals is
actually really verbose I mean function
is a really long word if you if you
compare it with how you do the same
thing in Scala it's pretty messy and
there's a whole ton of confusing things
about how this that this keyword behaves
it's actually dynamically scoped rather
than lexically scoped so if you have a
method that tries to use a an inner
function the value of this when the
inner function is invoked is actually
different than when the outer method is
invoked and it causes no source of
program errors so it's really kind of a
hideous language and it's got a few good
parts but then it's just a whole bunch
of really nasty parts that you know you
could spend a whole talk going over so
the problem we sort of have is that
really because there's you know
JavaScript has been the only way of
getting things done in the browser
because though if for whatever reason
those sort of viable alternative really
appeared right you know sort of flex
came and went
son tried to do something and failed ja
you know Java didn't really catch on in
the browser so because of a whole bunch
not because of the MER
it's of JavaScript beeper because no one
else really succeeded was sort of stuck
with this very weird language in the
browser you know which on the one hand
okay well we can just sort of a deal
with that but then on the other hand I
mean it's sort of people have started to
accept the weirdness of Java as sort of
being kind of normal so I like to think
you know maybe this is a little rude but
I kind of think of it as the Stockholm
Syndrome which came about when a bunch
of people were held hostage in a bank in
and Stockholm for a number of days and
they were kind of you know they ended up
identifying with their captors and
actually defending them and I think they
ended up not wanting to be rescued and I
kind of feel that there's a large
element of that going on within the
JavaScript community apologies to anyone
who is offended by that but it but I
think you know the human brain is very
adaptable very very malleable and as a
result you can start to take JavaScript
too seriously so you know so what what
can one do about it I think Martin
Fowler kind of I think it was a year ago
put it really well you know he despairs
that today in the 21st century after all
the thought and all the effort that's
gone into designing computer languages
we're stuck with this with this
JavaScript language and so you know we
really have to work hard to actually do
some kind of damage control and just try
and sort of you know minimize the impact
and one strategy of course is just to
use the good part so you know Donald
Crockford wrote that quite interesting
book javascript the good parts on
defining a subset of the language that's
quite good he's also created jslint that
basically enforces a lot of those rules
so I think that's a very good strategy
another approach isn't to actually use a
better language that then compiles to
JavaScript so that it can run in the
browser and there's quite a few of them
right so there's types type script
there's dart there's also CoffeeScript
and you can see you know here's a
CoffeeScript example so it actually
defines classes and there's real classes
there with real methods and it's
actually quite a lot more concise as
well and this generally kind of sort of
cleaned up this back seat so why not and
there are actually other languages too
compiled down to JavaScript as well so
there's a few different things that we
can do to make sure that we sort of
limit that you know we're stuck with
JavaScript so you know what can we do to
the few things we can do to minimize the
damage so anyway so that that's mostly I
think that's the most negative part of
my talk is just sort of bashing the
language so I want to move on and talk
about the reactor pattern which is the
asynchronous non-blocking model that the
node uses for i/o so the reactor pattern
is actually very old it was defined by
Doug Schmidt back in 1995 back in the
early days of the design pattern
movement and it's a pattern for writing
scalable network servers and the big
idea here is is rather than using the
traditional model of having a thread per
request so like if you look at say
Tomcat request comes in it gets a
located to a thread and the thread pool
you know which on the one hand is simple
but then there's the over the overhead
of context switching between all of
these different threads that seriously
limit scalability so instead what the
reactor pattern is about is that you
just have a single threaded event loop
so in other words one thread that waits
for it for an event to occur on a socket
or a file descriptor and then dispatches
that event to all of the handlers that
are interested in that event so when a
socket becomes ready for reading or
becomes ready for writing you will cool
that the the interested event handler
which can then process that that event
you know this is the structure so you
know this is how the original pattern
was defined so there's an initiation
dispatcher
so that defines an interface for
registering event handlers each event
handlers interested in one particular
handle a socket or a file descriptor and
it has a method called handle
the it gets cool to handle the event and
then there's an event loop that just
sits there waiting for events to occur
on these handles and that's usually
that's handled by some low low the early
OS level select or a pole or the like
and so when an event occurs on a handle
the event the the initiation dispatch it
finds all of the interesting handles
handlers and then cools each one saying
this event happened so it's a pretty
straightforward pattern has some
benefits you know the event handlers are
sort of insulated from the lower-level
concerns of like listening on handles
and dispatching events it's actually
quite efficient and scalable because
there's no thread context switching
there's just one thread and you don't
have the overhead of switching between
all these different OS threads you don't
have the memory overhead as well as the
stack and so on and so forth
and then it also gives you an implied
concurrency model it's single threaded
so you never have the risk of multiple
threads accessing the same mutable state
so there's an argument that that's quite
appealing as well trouble is there are
some drawbacks so number one it's it's a
non pre-emptive model these event
handlers cannot block or can't take a
long time because that would mean that
no other events can hand can can could
be handled it also means that where they
have to work in a collaborative
cooperative fashion you know one faulty
event handler then that your entire
server is down then another problem you
run into is that the way that you
basically got an inverted flow of
control so if you want to perform a
sequence of operations that the you sort
of constantly having to go back into the
reactor wait for the next event then
your application code gets run and so
it's actually the code ends up being
quite difficult to debug and quite
difficult to understand and I have quite
a bit to say about that in a minute so
that that's kind of that so that's the
foundation for the nodes sort of event
processing structure
if you think about the the architecture
of your node application at the lowest
level you've got the node event loop
basically implementing the reactor above
that you have basic components like
networking and file system and so on and
then above that you have higher-level
components like database drivers HTTP
modules and so on and then above that is
your application code and at each level
except for the bottom most level the the
code is listening is basically waiting
for events to occur at a lower level and
getting notified so the event loops
going to notify the socket handling code
that a socket is ready for reading
that's going to notify the HTTP code
that's going to start reading the head
of the request and then when it's got
the header it's going to say cool the
application code saying we've got a
request and that's so that's sort of
you've got multiple levels of event
notification going on and the way with a
node you actually kind of process events
there's two different ways so one of
them is to register a callback function
so you'll just get cooled when an event
occurs and that's good for these
one-time events the other option is if
you've got a recurring event like oh
there's data to be read you can register
this event listener which will get
cooled what potentially repeatedly so
that's the model you're just having to
write a lot of cool back functions and
event handlers in your code so this is
you know kind of here's an example so a
node by convention an asynchronous
function takes a callback is the last
argument so here we're actually starting
a file you know find out whether it's a
directory or a real file and it takes a
callback and also by convention that
cool back the first argument to that
callback is an error object so if an
error has occurred that that object will
that value will be will will have it
well it will have a value just some kind
of error code and if it's undefined then
it's succeed
in this case so you can look the cool
back looks at the stat argument to see
what kind of file object and then
there's also event listeners which as I
said a good for these recurring events
and there's an event emitter class that
you can use sort of basically as a base
class so you can use it or you can
extend it so large number of objects
that emit events use this event emit a
clasp it defines methods for registering
event listeners so you can just say on
event name here's my listener function
and then the code that these two am in
an event calls emit with the event name
and 0 or more arguments that then get
passed to the event listener and so
that's that's kind of it so here's an
example so here we're reading a stream
so we're creating a you know kind of
like an input stream then I'm
registering an event handler for the
open event so that just says oh that
gets cooled with the file descriptor and
then I'm registering another event
listener for the data event so that will
get cooled when there's data so you
imagine it gets cooled with chunks
chunks of data so those are the two
models and on the one hand this looks
quite simple right we just have event
handlers we just have cool backs and so
on the trouble is is that you very
quickly in realistic applications that
need to invoke lots of asynchronous
services and kind of do fork and join
style operations you very quickly end up
in cool back hell and it's quite messy
so here's an example so this is sort of
a little I've just kind of simplified it
somewhat so imagine that you we've got
two functions x two that just takes an
argument multiplies it by two and plus
three that takes an argument and adds
three to it but to simulate an
asynchronous operation I'm actually
using set timeout that only code that
only produces a value after a 500
millisecond timeout so you could imagine
you know this is sort of what a database
if you could you know try to read from a
file or try to access the database you
get eventually your callback would get
invoked then okay
so then there's a scenario where we need
to do plus three and then times two so
we end up having the right code that
looks like this so we've got kind of
cool backs within cool backs down there
so that that's kind of pretty ugly and
then even worse is the scenario where we
need to do invoke a couple of
asynchronous operations and then get the
results from both of them and then call
a third asynchronous operation so sort
of kind of like a fork and then a join
and you can see that you know if this
was well up here's the synchronous
version simple right but here's like
multiple lines of code to actually do
all of that because you got to wait you
know the results can come back in you
know different order and you have to
handle that scenario and so this is a
you know two trivial examples you can
imagine that is you know more realistic
code where you're calling lots of
asynchronous operations this gets pretty
messy and a talking a little bit about
ways that you can simplify that so then
another big problem is writes to a
single threaded and that that means what
if we need to do a long-running
computation that's just going to block
the event loop and no other requests
will get handled so what do you do so in
order to do you know handle any
long-running computational blocking i/o
you actually need to do that outside of
the main event loop and there's two
options so one of them is you can use a
community module that implements web
worker threads so kind of like
implementing what you get in the browser
so asynchronous background threads which
I guess is okay or you can use the
built-in module that actually Forks off
a child process and that's kind of
interesting because you get that it
actually implements it provides a
messaging API for the parent and child
to send messages back and forth but you
know it's sort of weird in the sense
that well this is a multi-core world and
it's kind of weird that we're sort of
you know having to fork off child
processes because we single threaded
processes it's sort of it's kind of a
real mismatch there
so I don't you know I don't know how
that's going to pan out over time it's
quite likely that maybe worker threads
will get sort of taken out of the web
browser level and become a standard part
of Java JavaScript but maybe not but
it's just kind of you know it's sort of
weird having single threaded runtimes as
standard in a multi-threaded world all
right so that that's JavaScript we
looked at that
that's the reactor pattern we sort of
saw that on one hand it's quite nice
scalable but on the other hand we have
cool back hell and so I want to talk
about the third part which is really
interesting which I think is where a lot
of the power comes from namely the
module system so node you download it
you get a bunch of cool modules for
doing sort of low-level things like
basic networking TCP IP UDP HTTP
accessing the filesystem timers you know
it's like I did not count it but it's
probably like 20 different built-in
modules so that's pretty good what's
really interesting is that there are
thousands well last time I checked there
were 30,000 community modules out there
for doing all kinds of things from just
basic low-level utilities to web
frameworks to database drivers messaging
you name it that there's likely to be a
module for it it's funny one of them on
there is mate mkdir P and that the whole
purpose of that module is just to
implement a function that's equivalent
to make make dear - P on the command
line because the built-in one doesn't do
it so it's very vibrant community that
are just producing all of these modules
so you know so what is a module well
basically it's a collection of
JavaScript files it might also include
some native code because JavaScript
unlike Java isn't a systems programming
language and so you can't really write
low-level code in that you have to
resort to C C++ plus there's a package
file that sort of this gives you
metadata about the package
instant installing a package is quite
interesting and I kind of think like in
the Maven SBT world you have to go add
it edit a descriptor file to see what
version you have here you just go NPM
which is the node package manager
install package name it just gets
downloaded and added into your project
which is quite nice and then once you
have a module it's easy to use you load
it using require that gives you an
object whose properties are the public
exports of that module so in this case
it's the HT to http module and you just
call create server and modules I think
are very central to the whole kind of
node development system so if you once
again you look at the architecture of
your application at the lowest level
you've got core modules above that you'd
use community modules you'd also then
write your own modules because you want
to have modularity both within your
project but also say with across your
organization as well and then at the top
you've got your own application code so
it's sort of a very pervasive pattern so
there's a lot of modules out there but
they tend to be a variable quality you
know I guess that's the consequence of
their just being so many and then you
can very easily publish a module so a
while back I was looking for my sequel
database driver and I found like ten of
them but none of them seemed to do
connection pooling or there was some of
the other major feature written where so
something that we've has Java developers
would take for granted as you know we've
had matured JDBC drivers for years the
node community seems to be still working
on it but now it's partly because many
of them are using MongoDB rather than
just sort of boring old my sequel so
there's sort of issues we've got lots
and lots of modules but then you know
the actual you know there's not as many
useful modules as you may think so you
know so to summarize sort of an
interesting situation right we've got
JavaScript which is this flawed and
misunderstood Lang kind of
understood language we've got the
reactor pattern which on the one hand is
great it gives you scalable applications
but quite a lot of the time you don't
need the scalability and it also results
in cool back hell and then you also have
modules lots of modules but not not all
of them are great so in the JVM well
there's a bunch of different options out
there for sort of as an alternative to
this async programming model like Neddie
vertex spring sauce just introduced to
reactor pattern reactor project so sort
of why care well you know I found that
you know it's just easy to get stuff
done easy to write some simple network
services easy to push events from the
server to the browser using node and
that was actually really what got me
interested the ease at which I can use
libraries like socket dot IO that I'm
going to talk about in a minute to push
events to the browser so it sort of got
a role to play in modern application
architecture and here's sort of two
reasons for that so number one if you
look at the structure of applications
today they've kind of evolved like a
while back we built these large
monolithic single war file applications
and now they've evolved into this sort
of quote service-oriented architecture
where there's lots of micro services
that are collaborating either via rest
or via RabbitMQ so we've sort of I hate
the term sowe're because it has so many
hideous connotations but really that's
we have we know we're moving towards
this micro service architecture and then
at the same time the presentation layer
of our applications of it as evolved as
well so whereas before we wrote these
what web apps that just generated HTML
and then we added some JavaScript into
that HTML and we had the Model View
controller pattern running inside the
server with these elaborate web
frameworks today what we have is the
Model View controller pattern running
inside the browser written you know and
we've got a whole application written
there using a modern framework like
angular
or backbone or one of the others and the
role of the server has changed to
serving up static content in other words
serving up the HTML and JavaScript for
the app that runs in the browser
exposing restful endpoints for that
browser app to cool and also pushing
events to to the browser and I've that's
sort of kind of where I'm coming from
what I see is node actually it plays a
useful role as the front-end server so
it's sort of mediating between the
browser world html5 JavaScript apt in
the browser and all of the enterprise-e
services and message broker type stuff
that's running on the backend so it so
it acts it plays a very useful role as
an api gateway or another term for that
is a front-end server so if you know if
we look at that you know so you know one
part one thing the front-end server
needs to do is serve up static content
turns out that's really easy to do with
Java the with node it's a couple of
different we could use a low-level API
so here we're creating an HTTP server
that has a request handler function
that's using the file system low-level
filesystem module so like first check
does it Maps the URL to a file then says
well does the file exist if it doesn't
replies with a 404 if it does it writes
a header with the right content type and
then it creates a read stream and then
pipes that into the request so you can
see just a few lines of code we sort of
serving up files from a tiny little HTTP
server so that's quite good and then we
can use we can actually even simpler
than that if we use the Express web
framework it's just a one line
configuration to say serve static
content from this directory so that's
good you know we can serve up static
content so the next thing to think about
is well what about restful web services
once again that's quite straightforward
so that there's actually a few different
options there but
so one of them I've played with is
Express and that makes it easy to do
pattern matching against URLs and also
destructuring to get IDs out of URLs so
here you know we're implementing it so
we're saying for a get request on slash
portfolio grab the user ID and then go
off and return that their portfolio that
was cleaner
once again that's quite straightforward
and then there's also a module called
request that lets it vary lets you very
easily proxy requests it's basically a
higher-level HTTP client library but
using that it's quite straightforward
for nodejs
to act as a proxy so a rest request
comes in you can then route it to the
appropriate back-end server over HTTP
and so this is actually you implement
this is a little bit of CoffeeScript so
what so the proxy to back-end
is a function that takes a URL the base
URL and returns a request handler takes
a request a function that takes a
request and response that then proxies
that request to that specified base URL
and then down at the bottom I'm setting
up various mappings so like slash
restaurant gets proxy to the available
restaurant URL orders gets routed to
restaurant management and so on once
again pretty straightforward and then
you know then there's the really
interesting part of well how do we
deliver events to the browser today we
want to build these real-time apps where
the server's sending events to the
browser and the browser's updating
dynamically and node has some great real
great technologies for doing that so
here's my is my simple example with sort
of a very state-of-the-art UI so it's a
simple counter that increments once
every second and what's interesting
about this is the events occurring from
the server and that's accomplished with
this little bit of code using the socket
IO
event delivery module so basically
what's going on is like I'm initializing
socket dot IO and then when the browser
connects I'm going to show the HTML for
that in a second this connect this sort
of new connection handler just sets up a
uses the set interval method to cool the
tick function every every thousand
milliseconds and so what tick is doing
is incrementing the counter and then
emitting a tick event which gets
delivered to that to the browser that's
connecting so quite simple you know just
a few lines of code there and then
here's the client-side code so it's this
is implemented using knockout Jas which
is a which implements a variant of the
model-view-controller pattern so you can
see that there's a span element with a
data bind attribute the binds that span
element to an attribute of the model
that's defined in JavaScript it's then
connecting to socket dot io so it's
connecting to the server and then for
every tick event it's actually just
updating the model which because of the
binding will then cause the span element
to contain that new value so you know
real simple example but it was just a
few lines of code ins on the server a
few lines of code on the browser and
you've got events flowing so I sort of
have a more enterprise-e version of that
so this is where the events are actually
being produced by a server that
publishes them to RabbitMQ message
broker and then there's a consumer
that's then subscribing to those events
and then re publishing them to the
browser using socket IO and that that's
quite straightforward as well so you
know here's the here's the publisher so
it's publishing messages to AMQP so we
use the AMQP module we connect to AMQP
we then need to make sure that the
exchange that we want to publish
the messages to exist so we got we've
got to write some asynchronous code to
do that so and and when the exchange is
open we then use the set interval to
cool tick which then publishes the
message via AMQP so we're part we're
publishing the message to the tick tock
exchange you know it's sort of that's
the destination and then in the client
then in the intermediary that's that's
subscribing to the AMQP messages and
then re publishing them as socket IO
events so doing some similar things so
we're connecting to AMQP then we're
subscribing to the AMQP queue and then
for every event that every message that
comes in
pausing that message and then emitting
it as a tick event which then gets
picked up by the browser as as before so
you know there's a few details here but
you can see that it's not really you
know we're actually able to take these
messages that are coming from our
back-end systems and then deliver them
very easily to the browser as it was
this kind of thing that got me
interested in in nodejs in the first
place
kind of what started infecting my brain
okay so that sort of you know it kind of
went through that kind of quickly but
that you know that's the essence of
building a front-end server an api
gateway using nodejs and there's tons
and tons of details that I glossed over
but it's it really is quite
straightforward which is really really
nice provided you can you know deal with
all the quirks of JavaScript and so on
so the final thing I wanted to talk
about which i think is a really
important topic is how to deal with cool
back hell how you know how can we write
asynchronous call back style code in a
way that we can understand and debug and
maintain so if you think about it
there's a couple of different scenarios
that's really one of them is a
sequential scenario where what we want
to do a invoke some asynchronous
operation a
and that completes invoke B and then
when that completes invoke C so that's
one thing and then there's also the
fork/join scenario where we want to do a
and B in parallel when they've both
completed then cool C with the results
and if it without if you were right you
know write that by hand
you know that kind of code gets very
very messy so there's this whole idea a
concurrency abstraction which in the
JavaScript world is called a promise and
in practically every other language is
called a future which can actually help
simplify the code so the big idea here
is is that rather than functions taking
callbacks which that function will then
ultimately invoke instead the function a
and asynchronous function returns a
promise so a promise is an object that
represents an eventual outcome which is
either a success of value or so or a
failure in some kind of error code so
you can think of a promise or a future
is a little box that a value will
eventually appear in so I'm the client I
call some asynchronous operation I get
back this future and I know that at some
point something will appear in that box
you know Java has a sort of semi lame
implementation of futures Scala has a
really great implementation Java 8 will
probably have a much better
implementation it's very common concept
and then you use a library of functions
plus other with future methods to
actually transform and compose promises
in a really really interesting way that
actually ends up enabling you to write
asynchronous code in a style that almost
sort of kind of looks like you wrote it
synchronously a lot of the messy ups
that asynchronicity is hidden away from
you and in the JavaScript community
there's a spec that sort of defines an
API promises a slash a plus back and
then their various implementations one
of which is when when Jas which is part
of Cujo Jas which is this whole kind of
really really interests
in JavaScript project from from spring
sauce so let's look at how you use how
you use these promises so here's the
example I used earlier so that I
rewritten it to return a promise so you
see that there's no callback instead
what this code is doing is creating a
deferred which is JavaScript terminology
for this object that represents this
ongoing operation so we call when dot to
firm then we just return that function
just returns the promise of the deferred
so the deferred makes when you make up
deferred it you it makes a promise as
well and then asynchronously when
there's a value to be produced that's
ready it actually cools resolve on the
deferred which arranges for that value
to sort of magically appear within that
promise so you know sort of in one sense
we haven't changed things too much oh
yeah
so but when you look and then you know
if you look at the plus three code you
know that similar hasn't changed much
but where things have got a lot simpler
is in the higher-level code where you
can see that we're just doing plus three
you know calling plus three that gives
us a future and then we're using the
futures then method which arranges to
cool times two with the value that
eventually appears in that future of
promise and then gives you back a
promise that contains the value that's
returned by times two so we've sort of
got rid of any of the cool backs within
there and the codes really simple and
you know it's kind of almost synchronous
in nature and if we actually look at
this example where we're calling plus 3
and x 2 and then and then adding
together the results is even simpler
again so we just cool plus 3 and we cool
times 2 that gives us two of these
promises
and then we use the join function so
that gives and that returns a promise
that that will eventually contain an
array of the values from the feet from
the promises that you pass in so when
joints that gives us an array of those
two values and then we call the spread
method then cool some with the elements
of that array as arguments to to that
function so some gets the two values and
then does the you know returns a promise
that eventually has the result so you
can see that you know it's not quite as
simple as the synchronous code but this
is before it actually took kind of a
whole screen full of code to synchronize
on those two asynchronous operations and
then add the result together so you can
see how how using promises really does
simplify things you know but then one
question is well if you look at the raw
node API s they actually they take
callbacks right so how do we work with
them so one option is whenever we use a
node a node module API we'd have to
write code like this create a deferred
pass in a callback that resolves or
rejects the deferred and then get the
promise from that but when has a really
handy feature that lets you take the
let's you cool a node function and it
actually supplies the callback and you
just get back a promise so all of the
boilerplate code gets hidden we're just
so we're just saying cool FS stat
filesystem stat with path as an argument
and no defend cool kind of does all of
this cool back stuff and just gives us
back a promise so we've got this nice
way of kind of integrating old-style non
promise code into this nice simple
promise world and I want to finish up
with a file system scanner example so
you know well that does is read the
contents of a directory figure out you
stat to determine which of those file
which are those directory entries of
files which are dire
factories if their directories it needs
to recurse and then you kind of want to
combine the results so that's like you
know that that's trivial to do if you're
just sort of using synchronous API s but
it's really really messy if you if you
don't use promises and you're using
asynchronous API s so first thing we
need to do is read the contents of the
directory so we do that with file system
tree dear so that that's pretty simple
because we're using node F and cool to
do that so that gives us a future or
promise so kind of use those two
interchangeably that will eventually
contain an array of file names so that
that's a good first step right next step
is well stat actually takes absolute
path well those are file names and their
relative to a particular directory so we
then have to take those those directory
entry names and turn them into absolute
paths you know which on the one hand is
not that big a deal right we can use
join to do that and we actually in it
and it's a future containing an array so
we actually need to do some kind of map
operation and so what we're going to do
is just partially apply join to the to
the root directory and then use when dot
map to map over the array that will
eventually be in that promise applying
to absolute to each entry so we now get
back a promise containing an array of
absolute paths so you know this code
still kind of looks sequential we just
go to this extra kind of sort of fluff
around it so then the next step we have
to do is actually invoke stat on each of
those paths to determine whether it's a
file or to determine whether it's a
directory so just for fun I thought well
let's do that in parallel so there's
actually a parallel function that will
just execute a whole bunch of
asynchronous stuff and give you back in
an array whose elements correspond to
the values you get back from each of
those asynchronous things and the actual
what you have to pass to parallel
is an array of functions zero arc
functions that it will then cool so we
actually have to transform this array
this future or promise containing an
array of absolute filesystem paths into
a promise containing an array of tasks
these task functions pass that to
parallel which is going to execute all
of them and that gives us back a promise
containing an array of stat results you
know this is the path yes it's the
directory no it's a file this is when it
was created
so you know it's not so bad and then the
other thing we need to do is why if it's
a fight if it's a directory we need to
recurse right so we need to actually map
over the entries again if it's a
directory we want to recurse and do
everything we just I just described
where if it's a file we just want to
return the name return the part so that
will return a list of part this a list
of files and so we need to balance it
out by returning a singleton list there
so that gives us basically a list of
list of files which we then need to
flatten out or I should say a promise
containing a to be precise it's a
promise containing an array of array of
files and then we need to like flatten
it and to do that we can just use when
dot reduce that takes that promise
containing all of the array the arrays
and concatenates them together and gives
us back another promise containing the
eventual list so we do all of that and
we you can see that the code you know
it's obviously more complicated than
this than the synchronous code yet at
the same time because we're using
promises we're not using having to do
ugly nested callbacks within callbacks I
mean when I first wrote this the code
was just positively horrendous and what
we've got now is we've got we're using
as few weird functions like
when map when dot parallel and when dot
reduce but we've got something that's
kind of looks like it's doing things
sequentially even though under the
covers it's quite asynchronous so anyway
hopefully that's given you a sense of
how you can use promises to simplify
your code so you know that's pretty much
my talk so I sort of you know in summary
you know JavaScript is one very weird
very flawed language you have to be very
careful as to how we use it in some
cases we should really just use some
language that compiles down to
JavaScript like CoffeeScript and then
the asynchronous model is really
interesting on the one hand it lets us
build super scalable applications but it
adds a lot of complexity and then the
single threaded runtime is really
constraining when we actually need to do
things that would otherwise block the
single threaded event loop so there's
some real challenges there but I kind of
feel that you know despite all of these
problems today right now you know nodejs
is kind of a has a it's potentially a
very useful technology you know fight
two years from now it's quite likely
that saying the JVM while there will be
some very robust very easy to things
that are comparable to needs nodejs in
terms of power and ease of use
we might even argue that sort of again
winning we're going to get there a lot
sooner than that but today I think it's
worth looking at nodejs and just kind of
kicking the tires on it so that's my
talk so thanks for listening you know
you can follow me on Twitter you can
send me email you can you'll be able to
find some example code on my blog plain
old objects and you also find a copy of
the slides so thanks for listening and I
hope that you found it useful</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>