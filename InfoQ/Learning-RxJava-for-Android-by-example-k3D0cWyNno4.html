<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Learning RxJava (for Android) by example | Coder Coacher - Coaching Coders</title><meta content="Learning RxJava (for Android) by example - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Learning RxJava (for Android) by example</b></h2><h5 class="post__date">2015-06-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/k3D0cWyNno4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is scout shake in case you
didn't know so I work at a start-up I'm
an Android developer I work at a
start-up in Palo Alto called wedding
party so if you're getting married or
you know anyone who is getting married
definitely use our app because I think
it's definitely one of the best apps you
have out there for a wedding in addition
I also host this podcast called
fragmented so I usually don't say too
intelligent stuff but like my co-host
Don Felker's like a really smart guy so
you should just listen for him in
between like you know you can suffer
through me just to listen to his content
so that's basically the pitch for
fragmented podcast you can go ahead and
listen at fragmented podcast com
we usually interview some of like the
best like we're fortunate that some of
the best developers have come in as
guests so if you know you have to walk
the dog clean the dishes I have a long
commute or something you can just like
wire in and listen to like some really
smarts because smart people speed okay
with that a introduction I want to give
you like what the objective is for today
so Ari Chavez sort of like this beast
right like it has this mega huge steep
learning curve and personally the way
I've dealt with our exam so like when I
started out I've been doing Alex Avila
now possibly for maybe like a year so I
like to think I'm decently conversant
with like rxjava but I mean don't hold
me to it
but the thing is like when I started
like looking at the theory of eyeglasses
making any sense
so like you know they have this thing
where they say basically if you want to
teach a kid swimming just like throw
them to the deep side of the pool and
they'll figure it out a terrible
terrible idea for swimming don't do that
for swimming like you know your kids
will hate you for the rest of your life
don't do that but it's excellent for
Alex Java for our Taba I think that's
like the perfect way to learn just dive
in start looking at examples and
eventually like if you're doing it for
like maybe a month or so suddenly
everything will just start clicking and
you know it'll all make sense so with
that in mind basically what I want to do
is as quickly as possible I'm gonna try
to keep it very light on theory but more
heavy with code examples so I'll keep
switching like to code I apologize this
there's gonna be a lot of code in the
slides but I try to make it a little
pleasant to at least look and like
once we walk through it together it'll
probably make more sense I do however
have to start with at least like some
sort of a primer because I'm going to be
using a lot of terms like observable
observer subscription subscriber like
I'm going to be using these terms pretty
heavily and if that really doesn't make
sense if you don't have like a solid
understanding of those terms then like
the rest of the talk is really not going
to make any sense
so I'm going to have like a very quick
primer just a quick show of hands how
many of you have worked with Aleks Java
like cool so a fairly decent amount okay
so I have like a couple of examples the
way I wanted to work was basically try
to spend like more time on the things
that people would be more interested in
solid like a 50/50 at this point so I'll
just like run with it and like we will
see if you guys want to like change up
the routine at some point like you'll
see how that goes
all right cool so let's get into it
the objective for the stock like I said
is if you have never used our excel
before if you go home today add like
this one line and start using Alex our
that's a win and it is possible like
regardless of what you read online
people are going to say well our servers
like complex does it it doesn't make
sense it has a steep learning curve all
that is true it still remains true but
the thing is you can you can start using
it like right away and that's like the
whole objective I'm going to give you
like four examples where you can go home
and rip out all your async tasks your
timer tasks all that horrible garbage
like from your code and you can start
using beautiful art like our Xterra so
like that's the objective the very first
thing you want to do is basically have
this in your Gradle script now cradle
allows you like the Gradle build system
allows you to basically pull in
libraries left and right so if you
wanted to use Eric's Java all you have
to do is add this line however if you
are an Android developer basically what
you should be doing is making sure your
slides go in the right sequence but also
our X Android so you basically want to
use our X Android and as I walk through
some of the examples I will tell you
there are some constructs with our X
Android that work really well
specifically if you are an Android
developer also the the good thing is all
the dependencies for our X Java are
pulled automatically with our X Android
so at this stage you really just should
be using our X Android because it
do everything that you need specifically
as an Android developer okay so in case
you didn't know our X stands for
reactive extensions now our X is not a
new language right like many people
associate rx Java with FRP which is like
functional reactive programming that's
like a big debate of its own but the
important thing to realize is that it's
it's simple Java in the end it's just
normal Java but the folks at Netflix
basically use this pattern called
reactive extensions and reactive
extensions in turn was created by the
folks at Microsoft so this is a really
smart some really smart people have like
come up with this pattern and what it
allows you to do is sort of like write
code that behaves in a functional manner
so it doesn't necessarily have to be
function code but it sort of behaves in
this manner and that's where the true
power of like rx Java is so that's why
you can like go ahead and start using it
in like plain old Java classes so Alex
Java is just a library just like you
have like other amazing libraries like
dagger or retrofit and the like alex
java is just another library it doesn't
require any like huge change in your
framework or anything that you need you
can start using our java right away
okay so we have a couple of terms so
you're going to so this is a very
typical rx Java routine right so you
have like in observable then you have
like these like a lot of this code so
what exactly does this mean whenever you
think about rx Java all you have to do
is just think about the routine as three
constructs just think of any rx Java
routine that you see as like having
three constructs now what a lot of you
know again like this this thing with how
they play the piano right like so you
have rules and once you like sort of
like master of the rules if you want to
go to the next cell you just throw the
rules off and then like you start like
realizing that there's more to it right
it's the same thing with a like Java
when you start off just think of it as
like just have these rules in mind
because it would really help you get
like 60% of the way once you're there
then you can like actually understand
the nuances of like the theory that goes
behind behind it and then you can like
start swapping your code like left and
right so the very first thing that you
should know is there are three
constructs what's the first construct
the first construct is what is called
these animations are a bad idea okay in
any case the first concept is what you
call the observer now Eric Sava follows
the observable pattern in case you
didn't know and it's a very basic
pattern so what basically you have this
interesting thing right so assuming you
have a stage and you have like this
object or this entity that's doing
interesting stuff right
you call that the observable because
you're interested in finding out what
that thing is doing so that's like one
way to think about it usually in your
code typically all the funky operators
that you have like map flatmap the
bounds buffer all these things that
you'll eventually get to read like in
the list of operators for rxjava all
that basically all that good stuff
happens like at the observable construct
right so that's like number one the
observable the second thing is well I
mean you have this amazing person who's
giving you like some interesting events
but you need someone who actually
listens to these events right that's
what you call the observer because I
mean if you don't have an audience
what's the point of having like the
observer so that's like the second
construct so then you have an Rx java
retain always think okay there's got to
be like an observable that's like
shooting out interesting events and in
the end you've got you you also have to
have like an observer that listens into
these events right so that's the two
principal parts now another super huge
advantage with Erics java is it allows
it allows instant concurrency now all
the geniuses in the computer science
field have like I don't I don't remember
the codes exactly but basically everyone
is like in unison everyone says like
concurrency is like a hard thing to deal
with right concurrency is always
difficult it still remains difficult but
the advantage with Erics Java
is it sort of like abstracts all of this
away from you so the way it does that is
with this thing called like schedulers
right so you have subscribe on which
basically says hey you have this
observable and you have this observer
when you establish this connection
basically do it on this thread so in the
end if we do get time like we try to
touch on some of the things you can
achieve all of this with pure Java you
can use like executor is you can use
like implementations of like executives
like tread pools you can do all of this
the thing is schedulers are just like a
much nicer API to deal with all of this
right so you have subscribe on you have
you have like the observer you're
establishing the connection this piece
of code that you have here basically
sort of tells it sort of indicates on
which threads you won't have each of
these things happening so what the
subscribe on does is it basically says
hey you have this observer this is like
the interested stuff like all the funky
stuff that's happening in our observer
do it on this thread which is basically
like your which is your i/o thread
well the scheduler IO which provides it
a thread but for like for convenience
let's just say okay it's going to happen
on the i/o thread then you say basically
hey observe on another thread and this
is where rx Android comes in handy so
like I said rx Java is a very basic
library rightly you can use it in any of
the Java code that you have what what rx
Android does is like if you're an
Android developer you obviously know if
you have like a network operation that's
happening there if you try to do that
like on your main thread is going to
blow up on you right so what you want to
be able to do is say hey do all this on
one thread and do this other stuff on
the other thread so this other stuff
that I'm talking about is basically on
the main that I want to do it on the
main thread and for most sort of like
examples like introductory kind of
examples all like the observer that you
have there basically what you're going
to do is you're going to update like you
have like a textview you have like a
list view that you have a bunch of these
interesting events that are coming to
you're going to update all of that in
your observer right again this is just
like an introductory rule start off with
this sort of like understanding that is
not necessarily true you can do like a
whole bunch of crazy things with our
excel but to begin with let's just keep
thinking of it like that because then it
makes it really easy to sort of like
quickly sort of port your examples okay
so we have three constructs first is the
observable second is the observer and
the third is this layer where we sort of
like establish this concurrency right so
which is like the schedulers does anyone
have any questions at this point because
you they're going to have Q&amp;amp;A hopefully
at the end of this session but if you
don't understand any of these terms or
something doesn't make sense now then
excellent time to ask me because if you
have an example three or four and you
say hey what's an observable that's yeah
I can't help you there so
if you have any questions any questions
go ahead and stop me and ask so far all
this makes sense three constructs be
good okay cool I lied to you there's
this not three concept there's actually
one more thing and that's so I told you
like hey so I was very like coy and
saying like I get observer the observer
also has this interface right so in
order for an object to actually function
as an observer you basically need to
override three methods you have oh jeez
that's super small okay I'll read it out
this is uncompleted on error and on next
so if you have like an object that
implements these three methods basically
can function as what you call an
observer right now again this is not
necessarily true sometimes you may say
hey I don't really want an on error all
I need an uncompleted or I just need the
on next alexavic provides functions
which basically allows you to have
observers that have just like the
methods that you want but honestly I
would recommend that you always just
override all three methods and I mean
just put like a log statement on like
completed or something
here's why if by chance your observer
actually errors out like jump operation
errors out and you haven't actually
called if you haven't implemented on
error it'll blow up now the nice thing
with our ex Java here is basically it's
like going to like neatly handle that
error exception is like hey something
went wrong here deal with it in a nice
way but if you don't if you don't
indicate how you want to deal with this
exception we'll just blow in your face
so this is like thrown exception
so I usually it's a good thing to always
just like overwrite all three and once
you start using it enough you'll like
it's like all the API is right like you
you'll start like like when I see this
all I see is like okay on error
uncompleted on you you'll start training
your eyes so sort of like crossover all
like the boilerplate code so it's it's a
very good idea to sort of like over at
all three okay so I also I don't wanna
make it too boring for everyone so I got
like goodies can anyone tell me what the
exact exception is that'll get thrown if
you don't go right on error I must say I
brought three of these to begin with
these are basically the most amazing
chocolates I've ever had like that can
fit in
my farm I had three of these I finished
one on the Caltrain because I was just
like - I mean it was so good you get
this it's worth it man I mean I'm
telling you just like give me any answer
if you're if you're good like you know
what exactly the exception is that gets
thrown if you don't start off like
override Leon error go for it boom
pretty gets the first goodie by the way
you can attack and just like take it
from him at any point I mean if you want
I can't control that all right cool
let's see I talked about like this
connection so you have an observable and
you have an observer right you've
established this connection now you can
represent that connection in another
object okay and that object is what you
call a subscription so this is like the
fourth thing yeah I promise you there's
no more like entities it's only these
four like I'm not lying this time you
have three you have the observable you
connected to the observer you tell them
which threads you want to be doing all
the connections in in the schedulers and
what results basically in the end is
what you call a subscription right now
why do you need a subscription now
what's the point of having a
subscription
next Candyman
can you say that again you can
unsubscribe from boom can you get it do
you know what hmm oh yeah no I'm you get
it you get it
hungry man I want to have to talk to
myself again so that's why you would
have this subscription assuming like
with Android this is very common right
you have an activity or you have a
fragment and you're basically pausing
the activity or the fragment if you've
used async tasks this is like a big
problem what do you do if like your
activity has gone out of cycle like the
network operation is gonna come back
like hey I have a result so you stick it
on the UI and the UI is going to blow up
because it's like hey this activities
you have to handle it in certain
specific ways right the way you actually
handle that with rx Java is you get a
hold of this subscription object and you
basically call unsubscribe one you have
to do the extra work but it's basically
it's very neat and elegant in that it's
very simple this is the only way if you
want to kill like that connection you
can't basically get hold of the same
observer or like your observable and say
like unsubscribe from here and selves
Unser's unsubscribe from there you just
it gives you this subscription and you
can basically say hey okay my activity
is going out of the life cycle I want to
kill the supper so just like unsubscribe
from there so that's basically why you
would have a subscription any more
questions be good so far
I'm out of candy so I'm sorry I can't
give any more
on the on error not implemented
exception yes so like if you have an
observable and it for some reason calls
on error on that sucker right if you
don't have on error implemented it's
basically going to blow up saying I
don't know how to handle this and I'll
throw the exception yes please excellent
you're you're listening keenly yes so
this subscription object that I have is
basically for this specific observable
disconnection so this observer connects
to this observable and it gives you this
single object it's a single subscription
right I'm going to talk and in fact it's
the next slide so let's just go about
ok so you have unsub so like if the way
you actually get a hold of it is
initially with this construct I was just
like neglecting the subscription I was
just like letting it go into either I
can just assign it to this subscription
object right so that basically allows
you to unsubscribe now rxj like if you
have many of these rx Java routines in
your activity or your fragment basically
what you can do is it provides this
concert call like a composite
subscription and it's basically a very
convenient way because like with this
composite subscription it's basically
like a bucket you can say like hey give
me the subscription give me that
subscription I'll collect all the
subscriptions and in the very end all I
can do is like hit a single composite
subscription unsubscribe and then all of
the connections are killed so it's just
a very convenient way to sort of like
handle all this as answer your question
cool any other questions
how do you get multiple subscriptions on
a single observer I don't know I don't
think is possible you can't basically so
this subscription it represents a single
connection like the whole objective of
this subscription is because if you if
you got like multiple subscriptions and
you want to basically cancel out on one
of those are you going to do it right it
does make too much sense it mind
repeating the question for my answers we
get on with you perfect yeah okay so the
question was like okay how how do I get
multiple subscriptions from this
observer like from this connection you
can't basically the whole idea is to
sort of link this observable with this
you want to be able to I to identify
this connection independently that's why
like this is like the primary thing so
before I knew about composite
subscription essentially what I Suz I
still have like subscription one
subscription to s3 s4 s5 and in the end
like as my activity was going out of the
lifecycle I would like start calling
unsubscribe and subscribe this is just
like a convenience method but the whole
point is you want them to be independent
because if you want to cancel three of
them but not the fourth one how would
you do that right it would make it
tricky if you add multiple subscriptions
I mean what does that mean like if you
unsubscribe one does the other one get
unsubscribe so the whole point is to
like uniquely identify that subscription
any other questions yes
can you Reese absque ribe to this
subscription so I mean this gets into
like the territory of like when you want
to like cash things how about we do this
like like ask me this question towards
the end just just because they got this
point if I say it's like not going to
make sense because I told you like the
theories like super complex in this
right there are hot observables that are
cold observers you can have like this
subscription if you with a composite
subscription if you unsubscribe that
sucker is gone so the only way you can
like if you kill that connection it's
gone if you want to agree subscribe you
have to like repeat the process that's
like the TLDR of like that answer sorry
the question was can you realities here
you can see I'm very experienced at this
okay so the question was can you give
can you V subscribe using a subscription
without your question okay so the answer
is No
yeah so the thing is a subscription is a
connection it's a very tight sort of
link if you unsubscribe from the
subscription it's gone you cannot likely
subscribe however if you have the
observable like if you had this if you
had this interesting sucker stored
somewhere as a singleton and he was
capable of like producing events
constantly and then you reestablish a
new subscription then that would work
okay if you want to like talk about one
the details like probably let's do that
in the end cuz like right now people
think I'm crazy like what I mean it
makes no sense so let's like maybe go
through some of the examples and then
like and start making a little more
sense that work okay cool so now finally
examples how are we doing 24 minutes
okay who likes async tasks get out
you're not allowed in this session I'm
just kidding
a sync tasks okay in all fairness async
tasks actually have a very nice API I'm
not kidding you like until alexavic came
in it basically had the nicest API to
handle concurrency right what's the most
typical example so I I was just telling
one of the other folks here so I've not
used async tasks in a long time so like
when I made this presentation I
completely forgot how to use a syntax
and I was like wow use flash async
that's just money they still suck I mean
they're not that great now anyway but in
any case this is how do you implement
like a very basic async task right so
this is the Declaration of the async
task object the interesting thing that's
happening here is like you want this to
happen like in the background thread
basically API dot get user I'm using
retrofit at this point so it gives me a
lot of like the niceties of
where it basically makes life much you
should be using retrofit as well so you
have API dot get user it returns it it
basically issues a network call as you
know in Android all Network calls have
to happen like on a third other than the
main third you can't do it on the main
thread so this is a nice a pair that
sort of like a wraps that information so
it says okay do this in the background
it returns this user object and
onpostexecute what I'm saying is like
hey given this
user object this is basically just I'm
adding I have like an adapter to a list
you and I'm like adding a single entry
into that adapter right so I'm not going
to explain how I'm not going to go into
the details of acing test because this
is over rx Java and if you forgotten how
to use async tasks excellent that's like
where you want to be so let's like try
to like gloss over all like the
boilerplate the most interesting parts
are here right so this is where the
network connection happens this is where
the network connections happen yeah a
laser pointer and this is where
basically you update the UI view right
okay so if you have to convert this into
an RX Java construct right
like thinking about the three parts so
you have like this interesting thing
emitting events and you have like this
observer at the end that wants to do
something with this right if you wanted
to sort of like transform this sucker
into in like an Rx Java construct right
how would you think about this right
that's a rhetorical question I'll tell
you have to do it anyway so you have
what okay oh yeah okay and there we go
so the first thing I want to do is you
want to have an observable right the
observe the interesting part of this
async task code is essentially this part
right so you plug that sucker in to the
observer now look at it give this is
where we come in two operators one of
the advantages with rx Java is basically
it gives you like a whole bunch of super
cool operators right
the problem is there's so many of this
probably an operator for everything you
know this is like the saying there's an
app for that like in our a Java that's
probably an operator that you just like
give all of this for free this operator
is called just okay what does just do if
you have like maybe like an integer
object you have like I know you have an
integer you have a string you have like
a single sort of object then you want to
convert into an observable right just
basically just does that I mean that's
why it's worded excellently the API is
like okay you have the string but I
don't know man just give me an
observable for that and it does exactly
just that so here what happens is you
say absorb or just what it gives you is
an observable of a string though because
if you see this is this user name is an
edit text
so when I do get text dot to string what
it gives me is a string so I'm passing
into the just operator a string so what
I would what would come out of this is
basically an observable of the string
but I don't want an observer of a string
here basically what I want to do is
convert in the end I want basically a
user object right so the way we do the
secret sauce there is basically the
network connection so that's where this
comes in you have a map operator now I
like to call the map operators basically
the alchemists operator edge you give it
one object and what it does is it
provides you a function that will
basically just spit out a completely
different object that's essentially what
the map operator is so here what I want
to do is I have a username string and
essentially what I want to do is I want
to spit out a user object and the way I
actually do that is with retrofits call
it's the exact same call here right now
this is typically how you would convert
this the equivalent of like converting
the exact same API with this now things
can get a little better and like this is
why I recommend retrofit right let me
see if this is the next thing yeah okay
so with retrofit this is the exact same
API so in this example I'm going to
point you to a github project where I've
written some of these examples the API
that essentially you have here is get
user so this is like the standard stuff
this basically executes like the network
call it doesn't care about the thread
it's just boom going to like execute
that network call and give you the
result this is what this is like the
interface with the retrofit the
advantage with retrofit is it also gives
you this option of converting it
automatically to an observable now
there's I mean there are like certain
nuances to this because obviously your
API has to be in JSON because it
converts like it parses JSON
there are other formats or you can write
like a custom converter and basically
convert it to the user object all you
have to do is like indicate how to
convert it to a user object and then
basically it knows to give you an
observable I'm not I haven't looked at
the internals but I guess pretty much it
would do something similar to what we
just had or maybe a more efficient way
obtained at write so if you use retrofit
like all that chunk of code basically
just goes away but for the benefit of
those who don't use the retrofit we will
stick to like the old way of doing it
okay
we had the observable that's construct
one there were three constructs in this
on in any rx Java routine we think about
three constructs right the first was the
observable what's the second one you
observed right so given this user object
what you want to do is update your list
you right so basically you're saying hey
okay this is my observer this is like a
construct that basically deals with this
user object in some way so that's
essentially what happens here now this
observer has an uncompleted on error if
you notice like the signature of these
methods so uncompleted is only at the
very end of this call right so you have
this interesting object that's emitting
out events called the observable at the
very end it's going to say okay I'm done
like I've done all like the interesting
stuff that I have to do so I'm out when
it actually when you actually leg
reaches that stage uncompleted is called
so typically like the stuff that you
actually do here is going to happen in
our next so on next is when you're going
to be able to like sort of like modify
the events that keep coming out of like
this interesting thing which is called
the observable right does that make
sense so far are we good
there's something missing though if I
run this exact same code it's going to
blow up on me why is it going to blow up
on me
exactly we need to add the schedulers
right if I just said again this goes
into like the theory of our Xterra there
are like certain default schedulers that
run I'm not going to go into that but
right now this is a very sort of like
straightforward rxjava construct what is
going to do is going to run everything
on the same thread by default any app
like if you have code it's going to run
the main thread so it's going like fail
right there because it's going to try to
execute that onto your main on your main
thread and Android is going to say hey
that's a network connection and I ain't
going to allow that and it's you're like
blow up the way you handle that is the
third constant the third construct is
basically MN okay the third concept is
schedulers right so I say subscribe on
the i/o scheduler and I say observe on
the main thread so what happens is the
SUBSCRIBE on points to the interesting
stuff that happens on the top it says
okay all this interesting stuff do it on
the i/o thread all this like all this
stuff all you're like observing that you
have to do do it on the main thread okay
the minute I add this in I add my
concurrency layer to this you're good
this example would work perfectly well
so this is basically just the code if
you want again like I'll share all of
this so don't worry about like writing
it down or taking pictures it's all like
out there so it shouldnt be too much of
a problem so with this in mind you can
go home today and rip out all your async
tasks and basically just use the
equivalent code it's as simple as that
any questions on this so far
it here they are usually you don't have
to do too much because oh yes sorry the
question was what do you basically do in
uncompleted so why do you have
uncompleted in that case right there are
certain times where like your
functionality might demand it like you
may want to say like okay I'm done like
maybe okay so here's a use case
basically I'm downloading images like
one after the other like I'm downloading
ten images right
I shoot out a call as each image comes
I'm updating my views and hey image one
ready image two ready but at the very
end what I want to do is I want to say
like all your images are done I'm like
you know posting like a text view or
something uncompleted would be a good
way to do that now you could also just
like accumulate like the number of
object that you are expecting and do it
on next but that would not be the
idiomatic way of doing that right so if
you did that on completed then that's
good it's uncompleted tipic uncompleted
is typically where you want to do stuff
where it says it's really done if you
have something specific that needs to be
done when your observe completed like if
you want to release objects or you want
to do something uncompleted is probably
a good way to do it yeah question
aha I knew you're gonna ask that
question so I actually have it written
on my notes you may say code that's
shorter is generally good but that's
never the case like when the number of
lines of code are small that doesn't
necessarily mean it's a good thing and
as I go through these examples it'll
make sense yes we have more lines oh by
the way if I use a retrofit let me see
if I use a retrofit like hey look at
that the number of lines have gone down
right I mean
so it helps there but the point is the
advantage with using rx Java is like
once you have this pattern set you can
do like a crazy amount of things like
you can go you can let's talk about like
some of the air like some of the
problems with an async task right like I
mean here you started this so I'm gonna
like go through all of the problems in
it she does this is like my terrible is
like therapy session I'm going to
excited talking about all the horrible
things in the async task okay I'll try
to keep it short ever handling if you
had to like handle errors with async
tasks how do you guys typically do it
it's possible I mean it's not impossible
but how do you typically do it you would
have to have maybe like a try-catch here
on a network operation what do you do
with that catch operation do you just
like throw it out no I mean if you want
to handle it on your post execute you
would basically have to have maybe I
don't know like a tuple or something
that basically is caught in here and
then you check to see if one part of the
tuple has an exception if it has an
exception then you update the UI great
what if I had multiple Network calls
right like in our examine and all that
is like don't worry all that is just
going to happen on the on error any
error throughout the life like if you
have multiple observables running at any
point of time if you have a single error
it's gonna like whoop drop in all the
way and come into the on error that's
like a huge advantage like you you
shouldn't underestimate like the
advantage of having a neat API where
it's sort of like encapsulate all this
functionality error handling is one
thing lifecycle changes so I mean
everyone knows with async tasks the
problem is if your activity is going up
like if it's like an activity or a
fragment is sort of like exiting like is
going on stop and an async task sort of
like says hey
go ahead and update this view and post
execute this code alone without any
additional stuff is going to blow up on
you because like your activity is no
longer like alive
you have to write extra code to make
sure where can I do anything with the
activity can I do anything in the
fragment is am I like at that point of
my life cycle where I can basically make
UI changes which is not to say you have
to do some of that code without
exhibition the way you do it in rx Java
is like once you have that subscription
on your on stop you call unsubscribe and
then you're guaranteed that none of the
like the observe the observer base
you've killed the connection so
basically that doesn't happen so it's a
nicer way to do it with rx Java if I had
to do that with the async tasks like
it's it is it's possible but it's fun
yeah go ahead question
you could you could what if you had
multiple icing tasks the nested async
tasks do you call cancel on like the
outermost one or they flake you had
multiple did I repeat the question I do
to be the question did I damn it
okay so the question was why is it
basically harder like so if you have an
async task object so like if you have
get user info a task the question was
okay so like if I have on stop or on
destroy and I have a reference to this
task I could just call cancel on that I
think that's how you do it also right I
mean yeah we chasing - that's how you do
yeah you could do it but you have to
remember to do it if you do rx Java like
again the thing okay so this may like
this may seem sort of like convoluted
but once I learned this pattern is going
to be the same throughout now I have
like and I have like another like the
next example is going to be with timer
tasks right but that has a different API
like yes you can do it I'm not saying
you can't do it for sure you can do it I
mean people have been doing it what what
have people been doing before our Java
right so you can do it
I feel the API is nicer and again so
like to the other question that I had if
you had nested async tasks you can
probably can you call cancel on an async
task if it's already done then you can
right so I guess that's how you would
handle it if you had like nested async
tasks at some level yeah could probably
handle like that but it I mean trust me
at that point the core is not looking
pretty
I mean like with with our example it's
like all there is just in one a single
place right question
okay so let me repeat the question just
correct me if I'm if I've understood the
question incorrectly the question is
okay so once I exit my activity or like
the the life cycle has come to a close
and I kill the connection so I call
unsubscribe
what happens to like the observe so I
say like interesting stuff happens here
and what if like the network connection
took like 20 seconds right and at second
number 10 the activity is like you've
exited like the life cycle right so what
happens does it continue and come back
yes the observable like to my knowledge
the observable will complete what it's
supposed to do so it will finish that
and to a connection but as it comes in
so the observer like when it says okay
I'm ready to update the observer it
because the connection is killed it's
not going to happen
this can I say and this is actually like
again like this is me trying to like
sort of like pitch our Xterra versus
some of the other things that's actually
a use case right like if you have a
network operation that takes twenty
seconds you don't keep doing that every
time right how would I do that with
async tasks can I do that with async
tasks yeah sure I could - the async task
in an object I could get the result put
it in a singleton and then hold it
possible but yeah if I wanted a cache
like this observable essentially if I
say like hey do your stuff keep it ready
and then I can subscribe at any point
from any place to the same observer
it'll still work because you can
reestablish a new subscription okay
questions I don't know who okay so I saw
you first I'm going to do that first
okay so that's like one point for Alicia
so uh you mean how asynctasks help or so
if you cash so there's like this
operator called cash if you cash the
operator
it won't reacts acute the connection you
can establish the connection again right
you can say hey execute this network
connection if it's cashed it'll
basically spit out the last result that
it has so it will avoid having to go
through that whole network connection
again does that make sense okay
okay so the question was okay so
assuming you have started the network
call and now you have like rotated your
screen and then you have like entered
into the new activity your question is
like okay how do I like listen back do
that
so you have your observer you have a
reference to the observable right you
establish a new connection so if you
have like a new if it's rotated then
it's probably going to be the same
observer but if it was like I know if
your layouts are different by you have
like a different fragment so in the
fragment in question where you basically
want to like you you have to like
establish a new connection so you have
this reference available you connect
back to this guy and only after it isn't
because you're saying it would take five
seconds so at second number two it's not
going to show anything right like you
can maybe mark it you can mark it as
saying like okay it's in progress or
something but only after like second
number three will you get like the
completed call so until then it's not
going to have anything to show yeah
there were a couple sorry it looks like
a loader I haven't used loaders enough
so that we okay so I guess like the
question was it looks like a loader
possibly I've heard I've heard some
people say that thank God for our exam I
don't have to use loaders anymore so I'm
guessing it maybe does many of the
similar things I haven't used loaders
enough to maybe make a qualified sort of
judgment if it's the same or not
how about we like sort of like quickly
like I know someone out there who had a
question yes
questions what about retrying so uh yeah
what about we trying o rxl so basically
ok so the question is how do you retry
with rxjava alexavic has this thing
called has an operator called retry and
it does retry now yeah Alex Alva also
has like a bunch of super complex things
it has a retry when so how many of you
know what exponential back-off is okay
so basically what exponential back-off
is is assuming you have you tree you try
once and then maybe like your network is
down so you don't retry again like in
one second you want to retry maybe like
in two seconds okay you retry in two
seconds again like now but you haven't
heard back from like this server maybe
the server is down you don't try again
in two seconds you aim you maybe want to
try in five seconds right so that's
basically exponential back-off so as you
keep increasing it sort of like
increases this time span this is super
hard by the way to do it I mean I've had
to do like exponential back-off without
our Xterra again it's possible I'm not
saying it's not possible it's very hard
but with our example you have this
operator called retry when and it's
again this is a little more like you
have to understand the theory to sort of
like you know how it works but with
retry when I can point it to an
observable and then say okay only when
this observe basically returns something
like start retrying and in that I can
basically control like this operation so
you can do exponential back-off so basic
retrying is like super simple you have
an operator that says retry add like 1
you add the parameters the ill-starred
retrying but you can also do like super
complex stuff where you have exponential
exponentially backing of a train
questions yes please
yeah
so one again so this is an important
point and thank you thank you so much so
the question was okay API dot get user
is basically going to hold a reference
right in our observer out here you can
see I've used I've intentionally used
like Java six basically just because
like I wanted to be easy for most people
to use like I don't think most people
use a eight where you have lambdas right
so the problem is you have a lot of like
anonymous inner classes and whenever you
have an anonymous inner class the the
problem is basically that it holds a
reference to your activity right so if
you have this network connection going
on and then you come back so your
question was okay so you have a
reference to this your question is okay
I'm executing this network connection I
have an anonymous inner class that has a
reference to this when does it go away
my is that your question
what cases would you keep the references
okay mm-hmm I don't think I understood
your question exactly so you okay so
your point is obviously the your
questions at what point does it actually
get released
right so you're basically going to have
reference to the activity in any of
these you know like in these inner and
anonymous inner classes so my
understanding I've asked some super
smart people about this and essentially
the thing is when you unsubscribe it
will get garbage collected you've
released like the references I can't go
into the theory because I don't know it
as well but basically when you say
unsubscribe you are basically releasing
the references inside that doesn't mean
goes away immediately but the references
are eventually going to go away once you
unsubscribe
when the garbage collection happens
because you are basically saying okay
release the reference at this point when
you unsubscribe right my okay so your
question is my function one is still
going to be alive for 30 seconds
the problems I didn't quite catch either
the answer that was given orally the
question entirely right let's do one
thing let's like push it off to the end
because I've got like through one
example I have like another four
examples let's bring the question up
again yeah any other quick questions I
can handle at this point or shall we
move to the next example
really quick question okay what was
uncle oh I need to speak
if uncompleted is called do you need to
explicitly unsubscribe I do it I usually
unsubscribe do I need to
let's live up this I know yeah I mean
well the answer is not quick I mean so
the thing is eventually I think it will
get released you don't need to if it
gets on company actually I don't think
you need to if it completes fast enough
you don't need to because there have
been cases where I haven't had a
subscription and again smarter people
have told me if it's quick enough then
you don't need to worry about it
but I unsubscribe anyway just to be safe
okay let's get back asked me the
question in the end I can maybe point
you to like a reference is that where
because I've had these are like chats
I've had online I can maybe like give
you a reference to like some of the
things that they've said and you can
take it up with them okay so depth to
asynctasks
depth to timer tasks let's look at this
example now this is a very typical sort
of example essentially what I'm trying
to do is I have a timer I'm scheduling
this at a fixed rate and what I'm doing
is okay with a delay of okay so with
actually zero delay at this interval I
want to constantly keep repeating this
action do something it's basically like
a polling sort of example rate how would
I convert this to rx Java the first
thing is okay what's the interesting
thing that's happening here in this
example the interesting thing is
actually like the polling right like you
have a zero delay and you're constantly
polling every three seconds so they're
going to like use that to be our
observable rx Java has this really
convenient operator called timer right
in timer you can provide it with
essentially two parameters but it's the
third one is to indicate like what the
unit is so you have this as your start
delay and this is your polling interval
which is the basic same thing that you
have here okay so that's your observable
notice how like the API is like very
very similar to like the previous
example right I have an observable I
basically have a timer operator my
observable is saying okay I having
something interesting happening now
every every poll interval which is
basically three seconds given that I
have this observable what do I want to
do according to this example basically
I've got a little lazy here and said
okay just do something here so basically
the same do something here is going to
happen on next and that's it this is
basically how you so it's very similar
to the async task I mean the conversion
to rx Java is very similar and this is
basically all you have to do now let's
look at the other interesting part here
which is how you cancel stuff right so
you have a timer here and you can cancel
out here
if I had to do the equivalent in our X
Java I have my subscription over there
in the end I basically call unsubscribe
question is uncompleted call on a saree
seller again now in this case basically
it would depend on the operator it's
actually not going to uncomplete because
timer essentially is like a polling
thing so it's constant this this is
where you get into what hot observables
and cold observables are basically in
this case it's not going to call on it's
never going to reach uncompleted if I
remember the timer operator example yeah
in this case it's going to constantly
keep polling so it's not going to reach
uncompleted which is why it's actually
crucial in this point to call and
subscribe because if you don't is going
to keep running in the background and
that's like a super huge problem ok so
this is basically so notice how it's
very similar a like it's super similar
to like the previous example there is
something interesting here though
what's interesting here notice how like
in Iowa I always told you they're like
three sort of like principal concepts
that you need I don't have concurrency
here right like I haven't set up
concurrency and I wanted to bring this
point if I did any UI activity here as
you know it's going to blow up again
right but it's important to realize that
certain operators by default operate on
different schedulers right certain
operators have like a specific default
scheduler so unless you explicitly point
to a scheduler sometimes it's it's going
to have unexpected results right so I
wanted to bring it in this case in this
case I'm not really doing anything to my
UI so this example will just run right
because in the example that I wrote I
was just basically logging into a
console so in this case it wouldn't
really matter but just keep that in mind
always 1 2 3 always had three steps you
have the observable you have the
observer and essentially you have
concurrency setup okay so this is the
second example now the advantage that I
the reason I chose timer tasks is
because you can actually do some really
cool stuff right with timer the operator
I can basically say okay execute this
task after a certain delay right and the
way you do that is with this the example
that I just talked about is basically I
can also say hey do it with a start
delay but also provide this interval so
keep after a certain delay keep
executing this task every X number of
seconds which is basically the polling
interval right this is basically a nicer
API it does the it does the same thing
no actually doesn't do the same thing
here you don't have a delay with
interval if I say you know what I don't
want an interval every 10 seconds just
keep executing this task then this is
basically the API that you want to use
the advantage with composing rx Java
operators is I can do something like
this so I can say hey okay do this every
10 seconds right so I have a polling
interval every 10 seconds keep doing
this but you know what take only the
first 20 actions so I have an operator
that says take 20 and what it's going to
do is is every 5 or 10 seconds it's
going to constantly perform your action
is going to spit out events the minute
it collects 20 events it's going to
complete so your question was when does
it complete in this case if I had take
20 it would actually hit on complete
- right I can additionally do multiple
things I can say like because it's
composable I can I can take like what
gets spit out in this case with the
interval it spits out like a time not a
timestamp it's going to spit out like
integers like I think it's 1 or 1 2 3
this is where it's probably a good thing
to look into the documentation because
it is a little different you can also
specify time stunts saying like hey I
want to hear the timestamps but
basically you can essentially compose
operators left and right you have a
timer you can say take 20 map that
sucker flat map you can do a whole bunch
of things that's like the advantage with
the timer tasks that's the advantage
with our X Java using the timer operator
okay so I want to quickly do one thing
I'm going to switch to a genymotion
emulator what I've done is basically
have sort of like written these basic
example well nothing shiny opposites
this there is an easy way to solve this
I'm going to turn display mirroring on
okay
that'd look better okay so I have a
couple of examples that have certain
I've written in our Xterra
one of this is this variation of timing
and interval right so button one
basically what it does is it runs like
it's very similar to what I just pointed
you to button one all it does is it runs
out a certain delay so if you carefully
watch this
I hit button it says button click and
after two seconds it's going to hit next
and because I because I've said because
the very first API that I showed which
is observable timer all it does is it
executes after a certain delay and it
completes and that's basically what you
can see in the logs here is does that
look visible okay so you have button
click there's a two-second delay at
which point next is called and finally
completed its call this example does
something this is like the second a pair
that I pointed to essentially what it
does is it says hey every one second
just keep doing this so if the way I've
implemented it is it's a toggle button
so unless I hit toggle it's never going
to complete so it has like next being
called completely right so if I hit next
it basically kills this
so all these use the timer API I have
not used anything different like
everything just uses the time array but
just see like the versatility of the
worst utility of like the kind of
functions you can do with just the timer
operator there are a couple of other
examples as well but I really am running
out of time so I want to quickly touch
some of the other ones I how about this
I'm going to show you two examples tell
me which is more interesting one and
we'll basically look at the
implementation of that right so there
are two examples here this is a very
common case right so if you have like a
sort of autocomplete kind of
functionality right if you type if you
type a text character like I'm going to
type B I'm going to type r I'm going to
try to I'm going to type C so if you
have like an autocomplete search box
right a very common functionality is
like you have a bunch of characters and
then you shoot out a network call and
you show a bunch of results right what
do you want to do is you want to be a
little intelligent about this like if
the user is typing pretty fast what do
you want to do is you want to give them
like sort of some time to understand
like all the characters bunch it up and
then shoot out a single network all
right that's like a nice it's a nice UI
it's a sensible thing to do right you
can do that with our exam
super easily so if you notice here let
me clear this out I'm going to type
Bruce Lee and you can see it collects
everything in just like one single thing
right does this make sense this is
actually pretty cool
in order to implement this I had to like
again use like async tasks and there was
like a lot of timing thing it was
possible but it was not very
straightforward but with our X Java it's
like a single operator
it's called debounce that's like the
operator and it's very useful for this
case specific right so you can you can
do some pretty cool stuff with the
debounce operator that's one example the
other example is a form validation right
so I have this super simple form here
and essentially unless all three inputs
are valid like my submit button isn't
going to highlight right so let's enter
something here I have an email here
okay eight characters so let's
six seven eight I have a number just a
random number between one and hundred so
let me enter 101 so you notice here what
basically happens is it collects all the
inputs and it tells me what's wrong so
if I correct that if I correct the
inputs here this is why is this an
invalid oh so it's greater than eight
characters so if I hit nine the button
highlights right if I at any point if I
change this number it's going to like
again go back to the error condition if
I have ten five one zero
then if my email becomes invalid at any
point basically sort of combines this
the way it does the way it does the way
I've implemented this is using this
operator called combine latest right so
it takes the inputs from this box
it takes the inputs from this box it
takes the inputs from this box it
collects all of them together and based
on any condition that I provide I can
say okay light up this submit box only
after a bunch of these inputs are valued
right so that's using the combined
latest operators I think I'll have time
to explain only one of them which one
seems more interesting to you guys
combined latest okay cool
combined latest okay this is another
reason to use rx Android right with rx
Android you have this thing called a
widget observable and essentially what
you can do is you can point and edit
text to this visit observable and what
it spits out on the other side is an
observable of on text change event so on
takes change event is a common thing
that Android developers probably are
familiar with right so all I have to do
is I have this this is a normal a very
simple vanilla edit text I use this and
what it gives me is an observable of
some events
what is that event that event is
basically any changes to the edit text
comes out as an observer right so I have
the email change observable so I had
three edit text in the example if you
remember right so I have I have an
observable point into each of these edit
text inputs
now if you try to think about like the
concept where you have an observable you
have something interesting and then in
the end you want like an observer that
sort of like observes all of this
interesting stuff right the way I have
it implemented here is this is your
observable you have combined latest I'm
providing it with three observables so I
have like the email change like from the
last slide the password change and the
number change as a fourth parameter
basically I would pass in a funk 3 which
is again like an inner anonymous inner
class I've shortened it to like the
IntelliJ like syntax here just because
it didn't fit in the slide or if you
used if you use retro lambda or the sort
then makes it look much better but
basically it combines all of these three
and inside that function what I'm doing
is I'm checking to see if the email is
valid so I have email valid as a boolean
here this is the on text this is the on
email change event this is the event
that I get from the observer so this is
what it's spitting out to me right if I
do a dot text on that I think it's dot
text dot - string if I do that I
basically get the characters that were
presented to me so I check to see if the
email is valid this is a very standard
mechanism I use a matcher to see if like
the email is valid the important point
here is basically I try to see if the
email is valid if the email is not valid
I basically set so this email is
basically the edit text I set an error
on that same invalid email I do the same
thing for a password so if is the
password a valid thing it's a very
similar process how I do it is not
important like how I calculate if it's
valid or not what's important is I have
another boolean that says pass valid I
do a very similar process for like the
third thing the number and in the end
what I return from this observable so
combined latest takes in three events
and what I have to do is in the end I
have to spit out something right the way
I have chosen to do it is I'm spitting
out a boolean variable and if this
boolean comes out to be 2 that means all
three inputs are valid if it's not if or
if even one of them is false the
condition is going to end up being false
and so the final output that I get is
false right so
that's the observable part of this whole
thing if you want to implement the
observer basically you have the very
same syntax that you've seen before I
have a I have like an observer and on
next I get this boolean variable so this
is the this is the boolean variable that
I like I sort of expected from the
observable right that comes in on my own
next and if you can see I've written
like a nice helper here but basically
just lights up the submit button I check
to see is the form valid if it's valid
turn it valid if it's not don't this one
wants to this though if you noticed the
example
when I started out the example Oh
okay when I started out the example it
basically didn't tell me anything so if
you look at this code like I showed you
right shouldn't that shouldn't it have
basically lit up or like showed the
error you would expect that right
because like I have an email here I'm
entering an email let's make this email
invalid
I have characters here clearly this is
valid I have 50
only after the very end does it actually
spit out that you know why
it does not have to do with the validity
of the characters because it is like the
validity is being checked but if if it
was checking the length right then this
thing should have lit up right as I
switched to the next ed attack
exactly so that's basically what
combined latest is right combined latest
explicitly combines the latest of all
three of the observable so even if one
of them is spitting out events it's not
going to care it's going to collect
events from the first one from the
second one from the third one and in the
end it's going to pick up only the last
event from each of these observers does
that make sense so only after sorry give
me a question give me a minute
only after all of these three events are
collected do I ever like go back to the
observer and actually turn the form to I
turn the button to either a valid button
or an invalid button right question Oh
once all the observables okay
yes okay so the question was okay
assuming events are like only so
assuming an event is emitted from all of
the of assuming an event has not been
emitted from each of the three
observables do I get the function call
the answer is no only after each of them
have emitted at least one event do I
land up in the observer okay hmm
absolutely so the question was okay once
the process that I just explained
happens if I get another event does it
call the function again absolutely
that's the whole point like if you see
in this example rate it is spitting out
an event the the email is still pretty
much invalid right only after I hit this
does it become so which means like it's
gone through the function once and then
it's like processing each of these
events right that's like the whole point
of the combined latest question
basically you you are refacing what
exactly happens with combine latest the
only difference with that is it's the
very first time all three events oh yeah
it's pretty much the same thing that you
said but all could like the very first
time that all of the three events when
you like the way you mentioned it it
made me feel like it takes basically
once all the events are there it takes
the next event no it isn't the next
event the minute all three omit at least
one event your very first event is
triggered does that make sense
exactly it inspects the state of each
and every single observable once all of
them have emitted at least one event it
collects all of those events and passes
it down to a function subsequently any
other event that comes in is going to do
the same process right
make sense that's the combined later
question okay right you would probably
have to use I guess a different operator
you can use maybe okay sorry the
question was what's the workaround to
doing this right like assuming I
sherilee want the event to be triggered
after every field there are different
ways you can do it I mean I can think
the zip operator is a good way right so
like you can zip all the events together
the minute you get an event you have to
like inspect the state of each edit text
because again like so what would your
requirement be so the minute you tab out
of the edit text do you want to like
check it for that one alone and then tab
out of the second one you want to check
for that one alone and then the third
one and then you want to collect the
results at that point your basic yeah
combined laters won't help you at that
point because I combined me this helps
the you're like let the user do whatever
they want with the form and in the very
end once I have all my inputs let me
worry about it
that's like the use case you can handle
it at that point you probably have to
handle it independently right and you
can zip all of those together the
advantage with zip is it like it'll
shoot out like events all together right
so you can maybe like send like an empty
event from the others or something along
those sorts
any other questions we are sort of
running out of time I believe West I can
see ty yeah do we have time for ten more
minutes okay cool a quick question
how would we keep that to the end and if
it's general let me go through the last
example and then we'll keep all the
questions in the end that work I want to
quickly touch a combine okay so the
autocomplete the reason I want to show
this is because it's it's so simple it's
beautiful I mean like remember I talked
about like a text observable like with
the autocomplete thing all you have to
do is basically this the bounce operator
right so I have I have an edit text
called input edit text I use the same
widget observable and that gives me
basically an observable of on text
change events very similar to the
previous example all I do in the end is
this operator called the bounce what is
the D bounce operator only emit an item
from the source observable after a
particular time span has passed without
the observable emitting any other items
and I read it out super fast it may not
make sense which is why like the folks
over at rx developed this concept called
marble diagrams right so this depicts
basically what the D bounce operator
does it the way to like when you at
whenever you look at like a diagram like
this a marble diagram like this the way
to think about this is this is basically
the observable this is the thing that's
emitting events so in our case the input
edit text that's emitting events that's
this sucker here right so this is the
events that's coming in the operator
then I'm actually passing it down is the
bounce what the bounce basically does is
it looks for a minimum time span time
span here any time an event is emitted
if your time span has passed it emits
that event outside so let's look at this
yellow marble here you have a time span
here but before you even hit the time
son the next event comes in so when the
next event comes in it sort of cancels
out the previous one and since that's
passed through like it drops the green
marble and then you have the blue one
which follows the same process right so
the bounce is basically just this
operator that says you know what I'm
going to give you a time span and I'm
going to just take the last event out of
that time span you can do in that in
that sort of section you can do whatever
you want
so that's just it like the example is as
simple as this I just like added in the
D bonds operator there I have an
observer which is very similar to what
you've seen before
I allow the format and that's it so this
is essentially the autocomplete one I
have I have a github repository where I
talk about some of the other examples at
this point there are like ten or eleven
examples I would encourage you to look
at the examples you have to remember
some of this code I've written is
actually kind of old so it's like super
crappy code right so if you can send in
PRS that sort of clean up the code
that's great like look at this like I
rewrote the debounce operator and like
what was I thinking with the previous
code because I looked at it I was like
Jesus this is like really bad code
because it was at a point where I didn't
really understand what was happening
right but as you keep practicing more
examples you sort of like understand it
a little better and then like you can go
back and clean up code if you are at a
point further than me then I would
strongly encourage you send PRS and
clean up my code also a good way for me
to learn also if you have if you use
directs Java before and you have more
interesting examples you're like hey
Alex Java does this really cool thing
that you probably didn't touch upon or
you don't have any recovery me where
I've listed ideas this is like my to-do
list where eventually I'll try to get
down and flush examples if you want to
take an example send in PR be more than
happy though that's pretty much it you
can go ahead and have a look at that on
the gate of all the examples that I
posted in the slides everything is there
I'll also try to extend in slides to try
and maybe we can extend it through the
group that makes sense
cool okay we are going to have me five
more minutes I get five minutes of
questions let's try to get quickly some
questions he asked me first I'm gonna go
with him
so the question is basically how do you
learn the different operators practice
practice the RX Doc's are amazing at
this point they're really good and very
informative they have marble diagrams so
basically just try to implement the
example it usually there's always a
better way to do it that's like the
approach you should always have start
familiar as if familiarizing yourself
with the operators and you'll find
something that's interesting that's
basically how I did it
there's no because like there are like
50 or 60 or 70 operators and each of
like depending on the parameters that
you pass in they're going to behave just
a little differently so there's no way I
going to learn it in like a weekend or
something so just like keep learning
practice that's the kind of a stupid
answer but I mean that's what I did
question so the question was a lot of
the events that seem emitted are
immutable how
the way to deal with that is basically
to identify that's happening and not do
it I guess like that mean if you I mean
if you catch that event and replay it
maybe after like an hour or something
like and it holds on to it I mean it's
going to do the same thing right like I
said our Excel has a very
straightforward library I mean it he
doesn't do anything very specific I'd
like I don't think there's anything in
our ex Android also that sort of like
handles that situation but yeah you just
have to watch out you have to understand
what the operators are meant to do and
basically work around that issue you
have a question yes
how do you test excellent question and
this is a question I like I had this
question initially as well the TLDR of
this so like I had Dan Lew
okay so today I repeat the question yes
okay I'll repeat the questions how do
you test our X Java I had Dan Lew on one
of my podcast episodes and I asked them
the same question the way I used to do
it before is essentially with operators
what you can do is you can force them to
be synchronous so if I have like an
observable that's emitting events I can
like say to blocking to list and
basically what it will do is it'll spit
out like a list so it is sort of like
fake it to be synchronous and then I can
just use regular testing that's what
I've done that's like a hack ish way to
do it I've heard again I haven't gone
back because I've just been doing it
this way it's been working out decently
well for me I've heard there's this
thing called Eric's Android plugins
that's coming in and what that allows
you to do is basically say execute
everything in Eric's Java at this point
only on this thread so you have like
test schedulers and you can basically
say no execute every single thing on
this test generator and basically that
allows you to sort of like take the
synchronous thing without having to call
to blocking and doing all this stuff
those are the two ways that I have heard
about maybe there are other ways but
those work pretty well
like most cases where I've used are a
chav and I wanted to test something it's
always work so unless there's some super
different case I haven't encountered
okay questions hey ty just raise your
hand when we're up when times up I'd
only I'm just going to keep taking
questions and do one more question okay
who's the lucky one I think you raised
your hand first so let me give you the
question okay
yes that's all okay so the question was
okay if you if if you are explicitly uh
if you are explicitly pointing out the
scheduler that you want as we have done
in most of these examples like the
concurrency part where I say hey run it
on this scheduler that's another very
good way to do it like if you have a
very well architected application using
dagger that you can basically have
inject dependencies and schedulers and
you can say hey use this scheduler so
when you're running like maybe testing
you can say inject the scheduler yes you
can do that unfortunately many apps are
not architected that well with dagger
and so in those cases this helps but
yeah for sure that's definitely another
way to do it alright thank you folks and
if you have any questions just</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>