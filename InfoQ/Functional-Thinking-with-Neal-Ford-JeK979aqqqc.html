<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional Thinking with Neal Ford | Coder Coacher - Coaching Coders</title><meta content="Functional Thinking with Neal Ford - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional Thinking with Neal Ford</b></h2><h5 class="post__date">2012-09-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JeK979aqqqc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">by talk on functional thinking a lot of
times when you encounter these new
paradigms in the functional programming
world it's also mashed in together with
a bunch of details about new languages
like closure or Scala and now you're
trying to learn two things at one time
which just makes it that much harder and
so my focus in this talk is really
trying to take those functional concepts
but anchor them really really close to
the Java world and so most of my
examples here are in Java when Java
can't do it I switch to groovy I think I
have one closure example in one Scala
example but mostly I'm concentrating on
the paradigm shift that comes from
thinking in a more functional way and
I'm going to start with a metaphor an
essay in history lesson here's the
metaphor let's say that you're a
lumberjack and you're okay
you're the best lumberjack in the forest
at cutting down trees with an axe it's
stunning how fast you can cut down trees
with an axe then somebody comes along
and hand you one of these but they don't
show you how to crank it and so your
first instinct as a lumberjack is to
take the uncracked chainsaw on swinging
against a tree very quickly reach the
conclusion chainsaws are terrible ways
to cut down trees I'm going back to the
axe because it feels really good in my
hand I've been using this axe for 10
years this axe feels awesome when I
swing it I know exactly how to swing it
until somebody shows you how to crank
one of these things you can cut down a
whole lot more trees the point of this
is is the point that I made earlier
learning a new language is easy we've
all done this a bunch of times in our
careers because it's really just
learning new syntax but learning a new
paradigm is really hard and that's
really what I'm trying to focus on in
this talk is trying to get this new
paradigm instilled and so my first
observation is that functional is much
more way of thinking than a particular
language or tool set you can do
functional programming in Java using
just raw Java and with a couple of
frameworks that I'll show you as we go
along
here's the essay this is an essay by the
well-known blogger Steve Agee called
execution in the kingdom of nouns this
is written in 2006 and in this essay he
talks about this mythical kingdom where
nouns are first class citizens but verbs
are subjugated slaves verbs are not
allowed out by themselves they always
have to have a noun chaperone in fact
it's gotten so bad in the kingdom of
nouns that they've had to create a
special kind of noun that has no actual
nowness that does nothing but carry
verbs around because you have to
chaperone verbs at all times because who
knows what might happen otherwise of
course this land that we're talking
about is Java and this relies that
everything has to be in a class and they
quickly realizes that was kind of a
silly idea because in Java the first
version of Java they didn't have it even
have anonymous classes so if you wanted
a throwaway piece of code you had to
cook up a name for this made up now and
just so you could attach a verb to it
and of course that makes perfect sense
when you have a context like this where
shape has a draw method and that makes
perfect sense but when you get to arcane
stuff like this it starts making less
and less sense we really need the
ability to pass behavior around and
that's what we're really getting at
there is languages need a way to pass
behavior around as well nouns are not
quite sufficient and so not surprisingly
this talk is going to be largely not
about nouns but about verbs and here's
the history lesson this is a poster you
can download from O'Reilly which is the
history of computer programming
languages it only has about the top 200
on it there are well over 2,000
programming languages that people have
cooked up over the relatively short
amount of time we've been doing this
exercise called programming but I want
to point you back to a particular era
back in the 70s 80s timeframe and point
out a couple of events one of them is
this similar 67 anybody know the
significance of similar 67 back in 62
yes yes first object away in a language
similar 67 introduced those concepts
small talk came about in 71 C++ came
about 1983
now I think there's a robust argument to
be had over drinks as to exactly when
did object-oriented it was mainstream
before C++ I think that's what really
pushed it into the mainstream but the
point of that is they discovered this
concept back in 1967 and you and that's
back in the days when they were doing go
twos and unstructured jumps and code and
other crazy stuff like that we're just
thinking about structured programming so
you would think that when they saw
something as insanely useful as classes
and objects they would have gone oh yeah
that's clearly what we should be doing
not this other crazy stuff we're doing
but they didn't it took 15 years or more
for those ideas to finally seep their
way into the mainstream if people start
being productive and taking good
advantage of those ideas this happens a
lot of times in the computer world where
you have this mainstream technology and
then you have these offshoots like
academic offshoots and functional
programming there's kind of one of these
academic offshoots where they were
experimenting with different ways of
looking at problems artificial
intelligence another one of those you
have practical offshoots of things like
xbase and for GLS but every once in a
while these offshoots start really
bearing fruit and come and merge back
into the mainstream technology branch
and I think that's what's happening now
with functional programming not just in
the Java world in the dotnet world as
well
f-sharp now ships with visual studios a
first-class citizen or the dotnet
ecosystem and it's a functional language
based on ml family of languages if you
look at the changes that are happening
in most of the languages that are really
active right now in languages like Ruby
and groovy the things that they're
adding to them are all based on ideas
that come from the functional
programming world so now is a good time
to start learning these concepts because
these concepts are invading your
languages that you're using now whether
you like it or not you don't have to
switch to Scala or closure or f-sharp to
start doing functional programming you
can do a lot of functional programming
in Ruby and groovy and increasingly in
the near future Java and of course
JavaScript there's some really good
functional programming libraries in
JavaScript as well there's a great quote
that is very perceptive and it actually
shines through civil of the examples
that I have in the
talk and it's by Michael feathers the
guy who's responsible for the book
working with legacy code and this comes
from Twitter which is why it's a little
bit terse but it's a really good
distinction that he makes where he says
that object orientation makes code
understandable by encapsulating moving
parts think about the things that you
know about object-oriented period of
languages a lot of the features are
designed to either show or hide
information at certain levels from some
people can see it some people can't see
it some can see it but not change it
other people can see it and change it
the way inheritance and polymorphism a
lot there are a lot of machinery within
those languages to make it easy to see
and manipulate State that's what he's
calling moving parts functional
programming makes code understandable by
minimizing moving parts the concept
being if we get rid of parts then you
can't make mistakes in those parts if
you never see them as a developer you
can't mess it up garbage collection is a
good example of hiding a moving part
from you a very error-prone thing that
makes people don't make a lot of
mistakes on by paving that over they
eliminated a lot of mistakes that's an
example of hiding a moving part that we
used to have to deal with and functional
programming takes away some of the
moving parts that we're accustomed to in
the object or world so I'm going to talk
about a lot of examples of code and so I
need some code and a problem to solve
and here's the problem I'm going to
solve I've solved this problem a couple
times before and there's a really good
write-up of the imperative version of
this which is one of the reasons I chose
this problem it's a problem a number
classification so any hole positive
integer can be classified one of three
ways and here's the first of them it's a
perfect number if the sum of the factors
of the number minus the number equals
the number itself another one is saying
that some of the factors of a number is
equal to two times the number six is a
perfect number because if you take its
factors and add them up the equals twice
six so it was 28 and so is 496 those are
all perfect numbers so that's how you
determine if a number is a perfect
number or not and that's actually the
key to this classification scheme if the
sum of the factors is equal to two times
the number it's perfect if it's greater
than two times the number it's a
if it's less than 2 times the number
it's deficient so I'll write some code
that give them some number tell me which
of these three categories it lives in
and I'll start with an imperative
version of this code and one of the
reasons I chose this example is I'm not
going to go into a lot of detail as to
why the imperative version this code
looks exactly the way it does if you
want to read that description it is
actually the sample chapter of my
productive programmer book because this
example was written to illustrate
test-driven development and so the
test-driven design chapter uses this
example and shows you the thinking that
went into the shape of the imperative
version I'm just going to show it to you
relatively quickly so here's my
imperative perfect number finder the
first thing I do is create some shared
state some of this is to make
testability easier and some of it is to
do lazy initialization for sums I
initialize all these guys in a
constructor my is factor method is
really the one of the key little pieces
of this algorithm because what it does
is say well give me a factor in a number
if I can say number mod factor equals
zero that means factor goes in a number
with zero remainder it is one of the
factors so I can determine a factor that
way I then have a calculate factors that
goes through and does a loop up to the
square root of the number and there's a
little bit of an optimization at work
here because a really common way to make
this algorithm efficient consider for a
second if you were trying to determine
the factors from number 16 notice that
all factors always come in pairs because
it's always the product of two factors
which each pulls your target number so
if your target number 16 when you grab
two you can also grab 8 because it's the
symmetrical factor that equals your
target number which means I don't have
to loop all the way up to the the number
if I'm trying to find factors I really
only have to go as far as the square
root of the number if I harvest those
factors in pairs and that's exactly what
I'm doing I loop up to the square root
and when I grab one of them I come down
here and add both the number and it's
symmetrical factor to make this faster
it's a very common significant
optimization for this code
here is my some factors and you'll
notice I have a get some method that is
basically doing lazy initialization for
me the anticipated use of this class is
going to be I'm going to call this
perfect if it's not perfect I'm going to
call one of the other so I can classify
this thing I want it I don't want to
have to calculate that sum over and over
so I'm only calculating a sum want so
I'm lazily initializing that so the
first time through it gets initialized
and other times I don't have to do it
for a given particular number so that's
one of the reasons I have that shared
state there so more than the details of
the code I'm really interested in kind
of the shape of the code so you'll
notice this has internal state in an
internal state for two reasons one to
make it much easier to do testing
because it's easier to inject things
when you're doing testing and so that's
part of why some of the internal state
is there the other is to enable this
lazy initialization behavior this code
is very cohesive and that it's lots of
very small single purpose methods it
follows the kind of Kent Beck composed
method style of coding it's very
testable in fact it was created as an
illustration of testability and it's
also very refactoring because it is lots
of very small methods and my goal in
creating that code was primarily to
illustrate how things can be very very
testable by being very very cohesive but
what if I went into the with additional
criteria as well like I want to minimize
shared state which is one of the goals
that you see a lot in functional
programming I still want to maintain the
testability but I'd like to chase away
some of the shared state so here's a
slightly more functional version of the
same code still in Java but with a
different perspective in mind and so now
in my get factors method I actually do
the work of three different methods from
my imperative version I've collapsed all
those together so that I can own factors
as a local internal variable here so
factors lives entirely within here I'm
still doing my optimization here but
this is now split and consolidated in
one method and now form is perfect is
abundant and is deficient code I now
have gotten rid of the shared state but
I've now lost my optimism
now if I call this more than once it's
going to do the sum every time that's
one of the side effects of losing that
shared state I was holding on to a
useful thing in that shared state if I'm
trying to minimize that that I'm going
to take a performance hit or anything
this but that's a trade off and in fact
in a bit we'll come back for this
version and make it just as good in a
slightly different way but when you look
at this code you'll notice there's no
internal state anywhere in this code
which means there's less need for
scoping if I don't have any internal
state there's no compelling reason to
make things private because there's
nothing really to hide in here in fact
there's some real nice benefits of
making these methods public because that
get me the factors of a number method if
I'm trying to find prime numbers that
would be a handy method to have and so I
made them all static in public so now I
can say number classifier dot factors
and now get factors for a number for
other purposes we actually in the Java
world a lot of times don't think of
reusability at the function or method
level because it's been so beaten to us
that reusability always happens at the
class level but you can get reusability
at a much lower level as well this code
is still testable in fact it's still
done test-driven development like the
other code is still very factorable but
of course we've lost our lazy
initialization for now we'll restore
that in a really nice way here in just a
bit so this goes back to my contention
that functional is more way of thinking
than a particular tools that our
particular language you can do more
functional style coding in Java if you
emphasize some of the things that
functional programming tries to
emphasize like minimizing shared state
so one of the things that you'll find as
you start looking into functional
programming it is a pretty deep and
broad ocean and there are all sorts of
really fascinating little inlets that
you can find yourself kind of wandering
down a bunch of really fascinating stuff
about category theory and a lot of
theoretical stuff and so what I wanted
to do is is go grab some concepts that
kind of relate to us in one way or
another and show you a few examples of
some of these concepts in action and one
of those concepts that's going to be
very near and dear to our heart
very soon is this concept of a first
class or higher water function these
terms are basically interchangeable one
is a computer science II term and the
others of mathematics kind of term but
they both essentially mean functions as
first-class citizens he passes
parameters can be returned values of
functions we're going to get this in
Java seven that's what the lambda stuff
in Java 7 is going to give us our first
class functions finally pure functions
are ones that have no side-effects
outside themselves in fact the the
functional slightly more functional
version I just showed you was a bunch of
pure functions because they rely only on
their parameters and nothing else and
your runtime can do some really nice
optimizations if you have a lot of pure
functions recursion is something that we
don't really think of much in the Java
world because the JVM was never really
particularly suited for doing a lot of
recursion and so Scala and closure have
had to kind of solve this problem
themselves within the language but it
does give you some really nice benefits
in terms of eliminating state a lot of
times you can get rid of iteration
variables and things like that by using
recursion instead of and instead of
keeping an iterator going and another
one of these concepts the slightly
academic is this idea of strict
evaluation but it leads this really
useful concept in a lot of functional
programming languages of laziness and
being able to create lazy sequences of
things in fact in closure for example
all the collections try to be as lazy as
possible meaning it doesn't try to pre
calculate all the values in the
collection it only calculates as many as
you need right now and then we'll
calculate the new ones on the fly and so
it tries to do as little work as
possible by creating what look like
infinite collections but you just keep
asking for more values so let's talk
about a few of these and and show deeper
examples and I mentioned this idea of
higher-order functions which are
functions you need to take other
functions as argument or return them as
results this is the computer I'm sorry
this is a mathematics definition of this
and this is a really really common need
in our world in fact you bump into
this kind of scenario a lot I showed
this code in my a July picture and
design talk yesterday this was actually
the target of a refactoring exercise
where I got it down to a point where I
discovered essentially some reusable
code here because if you replace these
two lines with something different while
I basically got as a template for doing
transactional data access and so the way
that you would harvest this if you
wanted to save this in your code base to
make use of this later this template
that you've created is to apply a Gang
of Four design pattern to it something
like the command design pattern and so
what you do is you create this rapid
transaction it takes in a command you
execute the command there and then down
here you change your add order method to
rapid transaction create a new command
with this execute method and the little
pieces of work that you want to do but
of course this is just a cry for help
for portable code because that's all
we're really doing here that's all the
command design pattern is is a bandage
for the fact that Java doesn't have a
way to pass around code command is
literally just this noun that has no
real purpose in life except as a holder
as a chaperone for verbs being passed
around and so if you go to a language
that supports higher-order functions
like groovy this code becomes a lot
better and prettier because this is the
same code in groovy but here code blocks
are first-class citizen in the language
and anything in curly braces is a code
block and you can pass this and if you
want to execute a code block in groovy
you can either call the dot execute
method on it or you can use the
syntactic sugar of the open and closed
parens and it'll execute that code block
that you're pointing to that actually
gets rid of a lot of boilerplate and a
bunch of other stuff that that's really
not technically necessary it's just
there because the Java language doesn't
have this facility yet but the other
thing that's interesting about this code
block in groovy and the way that code
blocks are implemented in most
functional languages is this not just a
code block it's also a closure and you
hear a lot of things about closures and
so I wanted to give you an illustration
of what's so cool and special about
closures and I can't do this in Java
course because it doesn't support
closures
but I wanted to cook up the simplest
example I could that illustrates this
concept in a Java like language so I did
it in groovy so let's see how well I did
so let's see what this code does so this
is a method call make counter and what
it does is define a local variable
called very local variable and
initialize it to zero and then it
returns a code block ignore what the
code block does for a second notice that
anything in curly braces and groovy is a
code block so it returns a code block so
when I say C 1 is equal to make counter
C 1 is now pointing to an instance of
that code block and if I want to execute
that code block I can execute it like
that and when I execute that code block
what it's going to say is a very local
variable is equal to very local variable
plus 1 so it's incrementing very local
variable and in groovy the last line of
any code block is the return value of
the code block and so the return value
of this guy is going to be whatever the
value of very local variable is and so
if I looked at the return value here it
would be 1 and here would be 2 and here
would be 3 then I come along and say C 2
is equal to make counter I now have two
instances of that code block if you look
at this underneath in groovy code I have
fire the constructor on two closure
classes they're holding on to this stuff
now but now when I come down here and
say print out C 1 and C 2 when I print
out C 1 I get 4 when I print out C 2 I
get 1 and here's the magic special thing
about closures because technically very
local variable is out of scope by the
time this function ends but because I
create a code block right here by
putting that in curly braces I
instantiate a new code block it's a
closure because it encloses the
environment that is in place when that
that closure block has been instantiated
so it keeps its own version a very local
variable unique to C 1 so that you can
increment it across calls to this method
it doesn't reset that variable to zero
every time because it's it's now kept
captured in that closure block that's
why they're called closures it encloses
the environment that was in
place when it got instantiated and now
it can carry that environment around
with its own instance of it until such
time as the closure block itself gets
garbage collected and all that stuff
goes away this is a great example of a
functional language hiding state from
you hiding moving parts because that
state that you have to maintain is a
moving part that you have to maintain by
hand in the Java world functional
languages do this because it's really
nice to have code blocks that can have
values that live beyond a single
invocation so that you can do sums and
all of other useful things with them and
so this is an example letting the
language manage that state for us rather
than having to do it by hand and in fact
this is one of the reasons why you
should be interested in functional
programming right now because over time
we're seeing more and more busy work to
our languages or our runtimes like
memory allocation I don't know about you
guys but I never want to work in a non
garbage collected language again been
there done that got the t-shirt life is
just too short for malloc it just is
there's just too much of a pain in the
ass to deal with I've got better things
to solve then dealing chasing down
pointer errors and junk like that so I
like I thought the advent of garbage
collection was awesome I love that
feature and I never want to give it up
but over time we're seeing more and more
of our busy work two languages and
runtimes I concurrency closure basically
does for concurrency what Java did for
garbage collection in that it takes over
the assignment semantics and now you
don't have to worry about threading
anymore because that's just a part of
the the features of the runtime you're
seeing more more things hiding state
even things like tests there's some
really interesting specification based
testing stuff going on the functional
programming world that can write some
really really intelligent tests for you
and so all of these things that we're
seeing now we're seeing because our
runtimes
finally have enough excess capacity to
deal with these things so back in the
early 1980s I was in a university and we
were using a piece of software called
pecan
pascale and it had this crazy
characteristic that it would run on an
IBM PC and an Apple 2 by using this
crazy technology they called byte code
and when you compiled your Pascal code
it compiled to bytecode and then they
had a bytecode interpreter that ran out
each of those computers and it was a pig
in terms of performance I mean it was so
slow it was ridiculous we were trying to
write hello world programs and it was
too slow to be useful because the wrong
time just didn't have enough horsepower
to handle bytecode interpretation at
runtime but he fast forward a decade and
Java comes out and they use that same
approach and the runtimes are enough to
handle that extra overhead of garbage
collection bytecode interpretation it's
exactly what we're seeing with a lot of
these functional concepts like MapReduce
and those other concepts our runtimes
now have enough excess to capacity that
it's actually foolish for us to waste
mental capacity on solving these
problems that computers can just solve
almost invisibly for us now and so over
time this happens more and more and the
time is starting to come for a lot of
these functional concepts to make it
into mainstream languages and runtimes
so as I'm talking about first-class
functions this is actually the computer
science typical computer science
definition function can appear anywhere
any other language construct computer of
course we don't have that quite in Java
yet but we can get close using a library
called functional Java this is a library
that's been around for a little while
it's currently in version 2 x8 I think
is this current version what it tries to
do is give you as much functional
programming capability and job as it can
without changing the language so they
use generics a lot to mimic code blocks
it's a pretty nice library in that it
doesn't take an entire mavens worth of
jar files to make it run as a single jar
file as long as you have a Java 1.5 or
higher and this single jar file you can
use functional Java so what I'm going to
do is use functional Java and rewrite my
number classifier using some of these
functional programming techniques
and here it is so let's look at some of
the changes here's the first one in some
but call some now if you remember you
used to iterate over the list of all the
factors in sum each one of them up and
so what some does now is say return
factors dot fold left ad comma zero how
is that summing something well so let's
pull some of this apart first of all
notice this is not a Java list this is a
functional Java list because there's no
fold left on a Java list so this is one
from the functional Java world and that
ad guy is actually an enumeration it's
also defined in the functional Java
world so there's the entire namespace
for it
that's an add a little add function
here's what's going on so think about a
list of numbers for a second what a fool
does is say ok I want to convert that
list of numbers into a single value the
way that I'm going to do that is take
the second element and fold it in on the
first element but I need to know what
function to apply as this fold operation
in other words I need to take two
numbers and convert them to one number
you do that with an operator and the
operator I'm going to use this ad so I'm
going to add the second one to the first
one and then I'm going to add what is
now the new second one to the new first
one and keep doing that over and over
that's what a fold operation does and
I'm folding using add so that when I'm
done with this what I have left is the
sum of the list that's a fold in the
functional programming world and that's
exactly what I'm doing here with to get
my some of my factors I just say factors
fold left and I get a sum and given that
there's a fold left you can also guess
there's a fold right it doesn't matter
for plus if you fold left or right but
some operators like minus and divide
have order preference and so fold right
is if you wanted to subtract them all
toward the end you could do a fold right
there are a bunch of these enumerations
that have been predefined for you and
functional Java for pker for
mathematical kinds of things you can
write your own code blocks and insert in
there and I'll show you an example that
and second when we do filtering this is
has to be kind of bolted onto job of
course because through a framework but
this is really natural and languages
important to support this natively this
is the exact same code
food enclosure some factors method a
function that takes in a number as a
parameter and this is being a list so
you kind of read inside out factors of
numbers a function call that returns the
list of all the factors reduced is just
a synonym for fold left it's reducing
the list and plus is the method that I'm
using to contract to fold that list down
enclosure operators just methods with
odd-looking names and so plus is just
the the method name for the add operator
in closure world this is a good example
of another one of these kind of core
concepts of the functional programming
role this idea of using fold left and
that is to think about results not about
the steps required to get to those
results now I'm not for one moment going
to suggest that sequel is a functional
programming language it's actually a
weird amalgam of a bunch of different
paradigms but it does share one
interesting characteristic in that when
you issue a sequel query you generally
don't go until it how to allocate memory
on the database server and where on its
file system go find these records and
put them together no you just say I want
these results and you go get them and
what we're trying to do the functional
programming world is add some of that
same kind of capability at the language
level you don't have to worry about
iteration so here's the results I want
you figure out the most efficient way to
do this in fact the nice thing about
this is once you turn this over to
machinery there's a really cool thing
that a rich Hickey is talking about this
year where he has optimized the way that
some of these mechanisms work in closure
so that you can automatically get
parallel behavior and some of its list
operations and closure because you're
using these higher-order functions and
not trying to iterate by hand the
runtime can actually make some really
intelligent decisions about optimization
that you don't even see they just kind
of happen automatically so that's one of
the original problems I had to solve
which was how to do a sum of numbers
let's see if we can attack another one
of those problems in a functional way
that is how to find the factors of a
number so let's say 12 is my number in
question I need to get the factors of 12
but I don't want to do it eration how
can I do that
the first thing you can do is observe
or that it's going to be some of these
numbers but probably not all of them
these are all the possible factors of 12
I'm guessing that not all of them are
factors of 12 it's only some of them
which suggest a filtering operation I
need to take that entire set of numbers
and filter down to just the ones that
are factors of 12 which is exactly what
this code does factors of takes in a
number it then returns a range from 1 to
number +1 because ranges are not
inclusive in functional Java dot filter
filter takes in a code block that uses
this class and functional Java there's a
capital F class that has an F method
that stands in for a code block and you
could use generics to satisfy the type
system so here what I need is a function
that takes an integer and returns a
boolean and I'll create that as an
anonymous inner class like this and
you'll notice what I'm returning there
is my is factor method that I created
before so what this is going to do is
for every element in the list it's going
to apply this filter method and only the
ones that return true for is factor are
going to make it in this return list so
it's filtering down my list to give me
only the numbers that are factors of 12
but is this as efficient as the
hand-tuned imperative version that we
saw not even close because this is going
to touch every number
remembering the eye in the imperative
version I'd gone in and did that square
root optimization to make it much more
efficient and I've lost that here
sometimes when you see control to run
times you lose some of that control I'll
actually come and grab this control back
in just a bit but notice there's a
trade-off there we can also fix this in
a functional way now which I'll do in
just a bit
but this is what my functional Java
version of my number classifier looks
thinking about results rather than
thinking about steps the next I want to
talk a little bit about pure functions
which are functions that have no memory
or i/o side effects and when you have
pure functions your run
I can do some really useful things with
it because if the result isn't used
anywhere the runtime can just strip the
entire code out of your runtime you can
also get parallel execution
automatically by the runtime which means
it can also change the execution order
because you don't rely on external state
it doesn't matter what execution where
happens and all those are kind of
optimizations that the runtime can
handle for you but here's the really
cool one notice that if you have a
function that only relies on its
parameters every time you call it with a
certain value passed the first time you
call it with a certain parameter the
results are just going to be the same
it's going to be a constant result so
for example math dot sign and Java is a
pure function when you call sine of 90
then you know that you're always going
to get the same value back it's not like
that one time you call sine of nine you
get one value back and another time you
get another one so if you thought that
you were going to use the sine of 90 a
lot you could actually cache that and
say every time you want this value so
just automatically return it from the
cache a particularly invocation with a
with a particular set of parameters
which yields a constant value and
runtimes can start taking advantage of
this with a feature called memoization
so let me show you what I mean by this
so here is a really terse perfect number
classify are written in groovy using a
bunch of this functional stuff that I've
been talking about so there is my is
factor that hasn't really changed
factors of this is the the terse or
groovy version one two number that gives
you a range not find all and it's using
my is factor and so this is the same as
my filter method I was using for and now
in the in the groovy world instead of
reduce it's they call it an inject but
it does the exact same thing so factors
of member dot inject using zeros the
starting value and this is the code
block as you apply to collapse two
elements into a single element which I'm
adding them together with plus and then
there's my as perfect as abundant is
deficient so this is a groovy version of
a number classifier where every method
is down to the one-liner but let's say
that I have this and I realized that I
end up calling some a lot I try to
classify the same numbers a lot in my
problem domain so I end up summing the
same numbers a bunch of times
and that's really inefficient so what I
want to do is cash that sum so every
time I sum a particular number save that
in the cash I won't have to do it again
and so in groovy you create a hash map
like that and now my sum of factors says
well if I have already some this one
before return it otherwise do the
calculation sumit and then add it by
cash but groovy since 18.4 which is
about six or eight months old now has
this feature called memorize and so if
if this is a pure function if some
factors is a pure function which it is I
can now come down here and say sum of
factors is equal to some factors not
memorize and I am done now the runtime
cashes those values for me that
hand-crafted cash that I created is
useless now because the runtime is doing
this in fact I'll point you to I've
written up a bunch of these observations
in an Oracle series I'm working do
writing for IBM developerworks and I
wrote several installments ago I wrote
this article about memoization
as hard as I could I could not write any
caching code that beat the run times
memorization code and you can also tweak
this cache you can say memorize that
most this number of elements memorize at
least this number you can do a bunch of
tweaking for the internal cache that
memorized uses this is a great example
of eliminating moving parts because now
you don't have to handwrite a cache
anymore if you have something that's
used a lot you just say oh that's used a
lot memorize it and Shazam you're done
remember back over here in my slightly
more functional version of my number
class fire and one of the things I was
lamenting was the fact that I'd lost my
my lazy initialization but that guy's a
pure function so I could memorize that
guy and get my lazy initialization back
great example of eliminating moving
parts handcrafted code that you don't
have to write because the runtime can do
it for you
so as nice as it is to seed things to
the runtime sometimes you want to get
that control back what about things that
you want to control like for example
performance or optimization notice that
even database servers let you do this I
was using as a metaphor before a lot of
times you can go in and hand team the
optimization plan for a database server
you kind of do the same thing here but
it's just a set of new different tools
so you remember over in my imperative
number classifier one of the things I
did was optimized it by using the square
root trick but in my functional Java
version I had lost that so let's go get
it back here's an optimize factors in
functional Java world what I have to do
is attack this problem differently I
have to partition the problem myself so
what I'm going to do is say give me the
the factors I'm going to create an
intermediate variable call factors which
has the range from 1 to the square root
plus 1 remember ranges are not inclusive
in functional Java and I'm going to
filter those to get me the factors and
so what I'm getting with that first
chunk of code are all the factors up to
the square root then the second line of
code in this in this method says return
factors dot append so I'm going to
append onto list I have some other
factors some other numbers and the
numbers I'm going to append our factors
dot map we haven't seen map before this
is another one of those list
transformations what map does is apply
this function to every element in the
collection and giving you a new
collection when it's done so it's
basically going to take whatever
function I pass in and apply it to each
element the collection my collection are
the factors below the square root the
code that I'm applying to each one of
those is they give me the number above
the square root so it's the symmetrical
factor the div versus the mod of that
and so what I'm doing is tagging on the
remaining factors on to the end of the
list by doing that so I'm basically
going and harvesting the two sets of
factors in pairs or harvesting and not
in pairs but in
and see really to get the pairs and the
last line here is this nub of what nub
does is remove duplications basically
turning a list into a set I would have
done the entire thing on the back of
sets and functional Java but they don't
have the same set of methods on sets
this is actually better done on sets
just to automatically get rid of
duplications but no basically converts
it to a set when you're done there's an
edge case here for a whole number square
root that you have to watch out for but
nub handles that very nicely good
example of thinking about results not
about steps thinking about the problem
slightly differently but still getting
the same kind of optimization so let's
talk next about concurrency we also
probably one of the really cool things
you've heard about these functional
programming languages is that they have
a much better concurrency story than
kind of raw Java does and that's
absolutely true in fact there's a great
keynote that I go encourage you to watch
there's actually going to be a keynote
by rich later today and I encourage you
to watch that one too
but there was a keynote at strange loop
last year in st. Louis called simple
made easy that rich did and he explains
some of the philosophy behind closure it
makes you realize that closures more of
a vision for software development that
you could only really implement by
writing new language while I was looking
to this picture for rich I also found
this funny picture of rich and that's a
very rich like statement state you're
doing it wrong because he doesn't like a
very mutable state and one of the things
that rich did was figure out what makes
threading so hard in Java and it turns
out it's variables because when they
created Java they didn't really think
about concurrency when they were
creating variables they created
variables and all that mechanism and
they said oh we may need to run this in
threads we need to layer on some
threading stuff on top of this but they
balloon one thread of control in one
timeline they're also not atomic you
can't say make sure that these two
variables get set or neither of them get
set there's no kind of transactionality
around them it's hard to compose them
they have very subtle visibility rules
and concurrency primitives in Java
you're pretty much at lock and pray it's
just not a very elegant way of doing
concurrent code in Java if you think
that you know how to do it you should
read Java concurrency and practice by
Brian gets who will convince you that
you've been doing it wrong all along
it's a way harder problem than you ever
thought it was and really the core of
the problem here is variables the
problem is that the concept of variable
in Java conflates
too much on top of it because in Java
the identity and the value are kind of
inextricably tied together in this one
thing we call a variable and it's really
hard to logic about that because at any
given time its identity and value may
change which is really tough to do
reasoning about particularly in a
scenario where you've got multiple
things trying to address it at a given
time what rich did was say you know what
I can fix the concurrency problem in
Java but you have to give me something
let me handle all of your variable
assignments if you'll let me take over
that semantics and I'll make all your
threading problems go away
and so that's what he did enclosure
enclosure there's really only one
mutable thing and it's a reference to
something and a reference never goes
away but the value that it points to may
change so he's basically taking the
concept of variable splitting into two
pieces and identity which never changes
and the value that it's pointing to
which may change at some point in time
so in a given point in time the identity
points to a value you may update it
which means that it now points to a
different value closure has a very
explicit semantics to control that and
if they can control that then they can
handle the threading concurrency issues
for you this is software transactional
memory so when you update a reference
enclosure it always happens inside a
transaction and handles all these things
concerns for you so basically what rich
has done and he's going to do that with
values today he's it he's on a campaign
to add temporality to the computer
science world and it's long overdue you
because he makes a really good point
that
nothing makes sense without a time stamp
even a fact like the sky is blue no it's
not it's blue between certain times of
the day you can't make Universal facts
about things without supplying some sort
of temporal context to them almost
always and we don't do that in
programming language as much so in the
closure world of values an immutable
data and a persistent data structure
somewhere identity is a series of
causally related values over time the
identity points to values that may
change over time as the identity doesn't
change state is identity at a given
point in time and time is relative
before after simultaneous ordering of
events so what happens on the closure
world is identity as a succession of
state moves from one state to another by
applying pure functions to move it from
one state to another that's how you
update things through pure functions at
some point some observe or some other
program or some user or somebody is
going to look at that identity and
dereference it and find out what its
value is at that point in time that is
its state at a given point in time the
value pointed to by an identity is its
state the other thing that that closure
does is give you a way to consolidate
variable access and give you basically
acid characteristics around variables in
fact it's almost acid so in the
transactional world you talk about
atomic consistent isolated and durable
we have a CI we don't have durable
because this all happens in memory but
we do have atomic consistent and what is
it well the AEC I instead of a second
ago now can remember they are atomic
consistent isolated across several
different variables and the the
underlying mechanism is kind of
sophisticated but the syntax we're doing
is very quite simple so in the closure
world if I wanted to create a reference
let's say I want to keep track of a list
of messages let's say I'm creating a
chat application I want to create a list
of messages the way that I do that is
define a messages variable and it points
to a reference that is a reference to an
empty list right now so that's an
identity and the initial value there is
just an empty list
I can now dereference that reference at
any time that I want to by calling the D
ref function on it which now gives me an
empty list I don't have any messages in
it there's also syntactic sugar and
closure to say app messages which does
the same as doing a D ref if I want to
alter a message I can call an alter
function give it the old value at an
update function and what it'll do is
move this from the old value pointing to
the new value by applying this whatever
this this update function is and so
here's what this looks like if I was
actually adding a message to my message
list this is an ad message function that
takes in a message and what it says is
alter the messages list and conjoin the
new message onto the end of it that's
basically what that line of code says
but you'll also notice do sync over here
because this guy is a reference the only
way you can update that guy is within a
transaction enclosure that's the only
way you can mutate references is within
a transaction if you try to execute this
code without do sync being there the
closure runtime will actually throw an
exception at you that you're trying to
update a reference outside of
transaction which is not allowed in
closure but by doing that he has now
created a scenario where you can write
multi-threaded code you never have to
worry about deadlocks there are no race
conditions writers never block readers
and basically all the things that you
have to craft by hand just kind of go
away and so because he's taken over
concurrency he can also do a lot of
really nice things around optimization
at the language level that just
automatically makes things better for
you without you having to do anything
because now just like garbage collection
a sunk down to the level of the platform
so is concurrency this is very ambitious
in fact several other languages have
tried to try to create STM Haskell very
famously has software transactional
memory they try it in c-sharp and then
abandon the effort a few years ago
because trying to create software
transactional memory in a place that has
rife with mutable state is just too
impossibly complex to do Haskell can do
it because they favor immutability so
can closure
so it's a really sophisticated mechanism
that it requires rethinking some core
things at the language level to make
work and so that's how closure is
possible to do this and why it's very
difficult to do in other languages that
weren't written with this in mind from
the ground up so closure is very
ambitious and they've they've basically
rewritten a lot of your basic
assumptions about the world close
scholar is not trying to be quite that
ambitious and what they're trying to do
is build a bridge from the kind of world
that you know into the functional world
and paving it a little more nicely for
people who are used to auditorium
periods of code and so what closure of
what Scala has done one of the nice
concurrent features that they've added
is this idea of actors which is much
closer to the kind of a java model
without having to worry about
synchronized blocks and things like that
so here's an example this one only does
perfect numbers but notice that if
you've got a number like 16 for example
and you had 4 processors on your machine
when you're trying to determine if
actors if a particular numbers a factor
those can all run in parallel so you
could say you know what processor 1 you
handle number 1 through 4 and see if any
of those are factors and processor 2 you
have a 5 through 8 you can partition it
up that way because none of these things
are dependent on one another so that's
what I would do with actors in Scala so
I'll go up here and create a parallel
perfect number finder create a range of
values of this is going to be how many
partitions I want to have which may be
number of CPUs or something like that
and now for for each one of those
partitions I'll create the Lord upper
range by partitioning my space and then
create an actor and so it's going to do
this for each one of these ranges and
inside this actor I can create variables
that are local to this actor but can
also be used as accumulators and so here
what I'm doing is going through each one
of the ones of my partial and if this
basically if J goes into candidate was 0
remainder added the partial sum and now
I'm messaging this partial sum back to
who launched the actor this is using
kind of the Erlang message passing model
for concurrency and so a little bit
further down I kick off all these actors
by saying while I've got responses
expected start receiving these messages
and when you receive a partial sum you
gather it up add it to the sum that I'm
building a decrement the number of
responses I'm expecting when I've got
them all then the return of this thing
ultimately is does sum equal 2 times the
candidate which is my criteria for is it
a perfect number or not so I could
actually make this a little more
elaborate and handle all the the
classification scenarios but this one
just handles perfect numbers but it does
so spreading across all the possible
processors so it's a different way it's
a way of doing concurrency in a new
different way and it's another great
example of hiding moving parts all the
synchronized blocks and all this other
coordination that you'd have to do if
you're trying to write this in Java or
groovy have now gone away because this
actor abstraction is hidden all those
details from you and you can actually
call actors from the Java world by
calling akka which is a framework on top
of that actors library so I've just got
a couple minutes left so I want to leave
you with some thoughts about how you can
start doing this yourself how is this
going to apply to your day job when you
go back to work on Monday you can
already start moving in this direction a
little bit start thinking about
immutability over state transitions
there's actually a great article here by
Brian gets about the benefits of the
mutability in the Java world and they
are there some extreme benefits
including automatic thread safety and
this thing that Josh block calls failure
atomicity because there's a rule in Java
that constructors never throw exceptions
you either get a real instantiated
object back or you get null back and if
you have an immutable object if you get
an object back you know that it will
never fail because of any kind of update
scenario because you can only set it
state and constructor so you know that
there's no way that it's going to be in
a failure state after that because you
can't change any part of it after that a
fun way to find out how much you rely on
state transitions in your code is to go
back and in your code base do a global
search and replace and find the word pry
a private and change it to private final
and then try to compile your code you'll
get what I call your mutability score
how many places are you mutating things
and you can start chasing a few of the
the way of course in the Java world
immutability is kind of a foreign
concept and so virtually none of the
frameworks and two of like hibernate and
war eum's don't really support that very
nicely but certainly for little value
objects things like that you can make
them immutable and you get some definite
benefits from the runtime from doing
that start thinking about results over
steps the next time you start to write
an iterator for something or iterate
through a loop think about now how would
I do this if I couldn't iterate over it
that's one way to start thinking about
how can I apply some sort of
higher-order function this problem and
try to attack it and try to think about
composition over structure this is one
of the kind of sub observations that
happens to the course of this talk and
that in the object-oriented right class
diagrams and then save off useful class
diagrams the design patterns book every
single example comes with a class
diagram because that's the way you solve
problems as networks of classes that's
not the way that they saw problems
typically in the functional programming
world where they really want a very few
data structures and a lot of operations
on those few data structures so list
sets Maps a few very simple core data
structures and they build really hyper
optimized machinery for those core data
structures and make those really fast
and they expect you sending data plus
customization in terms of higher order
functions and then let the optimized
machinery handle that stuff it's all
actually based on category theory and a
bunch of really fascinating mathematics
but that's the way that they're trying
to achieve reuse is in a more generic
way and notice a lot of this results
over steps is really declarative over
imperative code and one of the places
that you see that a lot are things like
domain-specific languages which a lot of
people associate with dynamic
programming languages but both Scala and
closure are really good first-class
citizens in terms of writing being able
to write DSL zin them one of the stated
design goals of Scala in fact was to be
a good host for dsls and it is a very
good host for DSL even though it has
very strong static typing a lot of the
type inference in makes that go away it
makes for a nice elegant dsls
so to summarize going functional gives
you new ways of thinking about old
problems more and more you can see
control languages and runtimes and
mostly these are things you would like
to see control for because it's just too
hard to get correct or there's no huge
benefit of getting it correct I mean you
can write thread correct code in Java if
you're very very attention oriented and
you go and find every single place that
you might have thread deadlocks and
other stuff but life is just too short
for that you know you could chase down
memory pointer bugs all day long - but
that's not actually making your
purchasing order system get out the door
any faster so there is some immediately
beneficial starting steps because if you
start poking around and the languages
you're using now they're adding
functional constructs at a breakneck
pace particularly languages that are
evolving more quickly like groovy and
Ruby but even Java we're going to get
higher-order functions in the next
release so even Java is coming along so
this is very much aligned with language
trends and pretty much across the map
and these new capabilities give you new
ways of thinking about problems some of
the problems you don't attack now
because they're just too impossibly
daunting to think about from a
concurrency standpoint but if that
problem goes away then you can start
thinking at a higher level of
abstraction you may actually attack
problems that you wouldn't would have
been reluctant to attack before I
alluded to this earlier but if you want
more details about this I've been
writing this article series for IBM
developerworks for a year and a half now
in fact today I just published
installment fourteen of this article
series called functional thinking on
developerworks it's a free site you
don't have to do sign-in or anything
that's the table of contents for all the
series and each one of them are numbered
accordingly just about out of time but
do I have questions probably got time
for a question before we take a break
okay well looks like I'm about our time
I'll be around the rest of the day today
and tomorrow if you've got any questions
happy to answer them for you
thanks for coming hope you enjoyed it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>