<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Unidirectional JavaScript | Coder Coacher - Coaching Coders</title><meta content="Unidirectional JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Unidirectional JavaScript</b></h2><h5 class="post__date">2014-08-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RLAjMeR8898" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody today I'll be following
up the amazing talk by the react guys
with a different talk on unidirectional
stuff so this is a talk about
structuring unidirectional application
we have some overlap and I'll be talking
about Mercury instead it's a bit about
me I've been trying to make web apps
simple for very long time ever since
I've had to build stuff with backbone or
angular and I just get really really
frustrated so about two years ago I've
tried Elm and I was amazed about at how
easy that was journey downside with the
elm solution was it was all Haskell and
as much as much as I might be able to
like Haskell but maybe like six months
maybe six months you can't convince a
team of people to write high school and
if you can you're unlike some kind of
special company so a quick overview of
what we're talking about I'm gonna be
describing like what I think the word
unidirectional means and I might twist
word your introduction to mean something
doesn't actually mean but what's really
hard I'll be comparing it to like
existing stuff around MVC star and FRP
literature I took a lot of inspiration
fop literature I think everybody in the
web community took inspiration from NBC
star and if I have time I will actually
build an app with it because talking is
only so much you really should show that
works so as I go for this talk I've been
working on a library called Mercury it
uses a virtual dominant plantation
that's separate from react that's just
really lightweight
and that simple so those will be like
the reference implantation so I'll be
talking about but you can apply the
ideas with flux or backbone or bacon or
just like anything it might be a little
bit more difficult though so what's the
unidirectional application the first
time I heard the word unidirectional
was when watching a talk by the react
guys so they they give it they did a
great job of like pointing this new term
and basically do they say you know
anything that has a single directional
dataflow where there's basically no
two-way data-binding
like data just goes one way not yell
away now that clip would mean and I went
back to the elm stuff I saw two years
ago and it's like wait a second
the armed stealth is also unidirectional
Elm just used as like scary word called
FRP which stands for functional reactive
programming which sounds sounds pretty
scary to me so I'm going to jump into
the overview of like what a
unidirectional thing is you'll have seen
from like react flux talk earlier that
like you know you know have you have
like one line and it's it's all great
and amazing so my concept is more
heavily inspired by FRP and MVC and so
many examples I've seen in the
functional community is they really like
to be explicit so as you can see over
there there's a arrow that goes in one
direction now it's actually a cycle I
haven't really drawn the arrow that goes
like through the Dom just like all kinds
of stuff you don't want to know about
happens in the DOM and in the browsers
so when building I can have a piece
style thing they encourage you to model
your state so you start off and you earn
your an FRP system your functional your
pure you're not allowed to have any side
effects so like how do you do a pure UI
we know side effects well the only way
you can do it is you have a rendering
function that takes the entire state
that you want to render and then you
just okay I can't do any side effects
content Dom manipulation do anything I
can do is return like a scene
representation like a visual
representation of what I want to render
now if anyone's seen anything would
react they do something like that their
rendering function returns a virtual Dom
my examples with Mercury return averted
almost well it's just a slightly
different
at home so that's the rendering part and
the running parts all simple and pure
and like one direction one it's amazing
and fantastic works great so what about
the stage you were forced to like pick a
state so you're gonna sit down you
actually gonna think about like you know
what's the main um application what are
all these things I need to render and
you're just going to describe the entire
state and every time that changes just
trigger a reminder that's the that's the
way that works so at some point we have
to actually update state at some point
we have to actually capture user intent
and do something so both mercury and
react use a dispatcher or delegator to
take incoming Rotom events and delegate
into the piece of code as you'll be
handling it now again based on FRP
literature the people in the functional
act of community think you should
describe your your user intent and the
user interactions you want to handle
what types they just say you know okay
if I have a dummy app that can like add
a Fred I'm gonna have an ADD Fred type
put like a new Fred ID and like maybe
like a Fred name or description if you
want to add a message so have a new add
message type with a message say idea
Fred ID maybe in a message body you know
whatever else you might want so you end
up with defining your different inputs
and then once you've got one of these
new events that's already like in your
application domain so it's like an ADD
Fred message you just run you just right
you just run your business logic at that
point you run your updating logic to
update the states a new state you know
okay I have a fed I'm gonna like
dependents a list of Fred's your state
changes you've got like a classical
observable representation if you state
the few gets updated and you go to cycle
just it just gets rendered
and that's that's where the
unidirectional part comes in and that's
how the Union restaurant date of her
works now this is where I got stuck with
FRP literature the FOP community just
says or you don't need any kind of like
modularity or nested components or like
any kind of separation or structure or
in Haskell you have the compiler the
compiler loves you you just like just
define a new event as like a switch
statement over 30 different types and
you just you figure it out just
structure it like you structure all
Haskell programs then you ask them how
you start the Haskell programs and now
you've just lost two hours of your life
without any answers so having taken a
look at some of the techniques ohm uses
OMA is a functional library for
clojurescript that we uses react and one
of the new things that introduces is
this notion of a cursor and a cursor and
a lens are roughly the same and lenses
like a the way up is a way of taking
your big state and being like you know
what at some key path you know maybe
like big states don't Fred's the Fred ID
that that particular keep off I want to
embed a substrate that I can just read
and write to so you can go and separate
like your Fred logic into this child
over him and because of the way curses
or lenses work it couldn't just deal
with local states as it wants to
if you must be like okay I only care
about I'm afraid I have a Fred state
that's all I really care about and you
can embed the Fred state in the parent
state and every single time the first
changes the parent updates and the
render gets triggered so notice how
there's no communication between the
child state and show Brenda if you were
to communicate sideways you would end up
with like a large large mess
you'd also have to figure out how to
deal with that because just triggering
an arbitrary render of a subtree is a
really complicated problem
so journey of what you do is you just
have your top-level render logic you
know import the rendering logic from the
phred and you know if I have a list of
Fred's all I've got to do is loop over
it and call render felonies Fred no deal
what everything now one of the things
this allows you to achieve was avoiding
that switch statement that you would
have and like a Haskell environment
where like the input is just there are
30 different types of inputs and you
just have a switch over it at this point
there's two separate errors going from a
raw input to the actual inputs and the
parent doesn't need to care about what
type of events the children listen to
and you probably have the exact same
thing where the dispatcher architecture
in flux each individual store doesn't
have to care about all the actions of
the other stores and it doesn't have to
care about what updating means it
doesn't have to care about what a child
state is the parent doesn't really care
about implantation it's all of a child
and you now are able to nest components
recursively and that makes structuring a
larger application easier and this is
one of the pieces I was missing from FRP
decision so to recap some
responsibilities somewhere you need to
bootstrap your application
you generally abstract the application
in these boxes call them whatever you
want I use the word component because I
have no originality you need to convert
raw input them to user tenth you put us
in an input you might be tempted to call
this a controller kind of the same thing
when you update application stage you
just use your business logic because you
use observable state and because in
almost all of these systems you tend to
have observable models
when state changes you just notified UI
because the rendering function is just
like a nice pure function rendering and
it's pretty simple now this isn't the
interesting part ginseng powder is not
something being unidirectional the
interesting part is it being
unidirectional and immutable or
read-only so having not--we data binding
is nice but you also don't want to have
two-way references between concerns you
won't want to have a view talking to a
controller and vice versa and preferably
if possible you take some of these
concepts from functional languages and
you say you know what it's nice if
there's no mutable references anywhere
now if you think about this for a second
let it sink in what does lead you
towards is the ability to reason about
the source of truth each component is
the actual source of truth because
nobody else has a mutable reference to
it nobody else can come and grab it and
you know punch it in the face and say
like you know wait you know what
actually you're something else and this
allows you to reason about your
application because when you see
something happening in UI that looks
like a bug you can go and just trace
your top-level state you set up your
state you can just inspect it and see
what it changes to happen and when you
see that when you do a certain thing in
your way that looks weird and you can
actually see a list of all the changes
and updates and transitions being made
to the states you go ok I can see which
which one of these nested objects it is
and you just jump to that code and you
know that it is the source of truth you
don't have to go and jump around your
codebase and find all the places where
developers took shortcuts so we're back
to this diagram and this is the exact
same diagram
so there's a couple of tricks to making
something amitabh all when you do the
rendering our implantation of virtue Tom
returns an immutable virtual tree so
there's no local state there's no
mutable state in the virtual tree so
when it comes time for the like the
runtime or your event loop to render and
dispatch it can't mess with the virtual
tree because the virtual tree is
fundamentally mutable and because you've
got this virtual tree you can't mess
with the Dom because the only way the
Dom gets updated is by having a new
virtual tree now the reference between
the state and the random is immutable
because by default
mercury uses an immutable state
primitive so just like ohm it recommends
that you know what don't have meetable
state just have an immutable data
structure and every single time you
update it just shallow clone it to a new
state so what happens is every single
time render gets cold you get a new
immutable snapshot of the state which
means you cannot accidentally change
state and render that's just impossible
now the same happens between the input
and the state the input doesn't actually
have access to the state all I can do is
call a bunch of operations on it it can
just trigger state transitions and it's
mainly in charge of normalizing Dom
events and that kind of style so that's
kind of cool but if we compare to MVC
storm and take a look at what you have
two differences is and this article
comes from Wikipedia I just read the
Wikipedia article or
model-view-controller and I think
anybody can come to an agreement on how
that works or what are theirs so this is
just literally from Wikipedia so here
you can see all these bi-directional
references and you can see that these
arrows are fake errors and thick errors
means this mutable references there so
if the controller can just mutate the
view
you you lost your source was true for
about ran directly
you can't take a look at your view on
okay this is how rendering happens
you've got to take a look at all
controllers to have access to the view
and hopefully there's only one that has
access to the view but I don't know what
kind of big applications you've seen
someone last year once you can't tell
you can't tell where the source of truth
is there was an interesting paper I read
a couple of days ago from 1996 about 103
percent and it's curious to have a
snapshot into the past now this diagram
is a diagram of what the 70s small talk
NPC looks like and surprisingly enough
there's the exact same cycle and the
exact same unidirectional flow happening
here and you have this notion that the
model notifies the view and that the
view then called getting methods on the
model for data access so this actually
looks incredibly similar to
unidirectional apps it's just that it's
mutable and then here's an example
comparing it to flux now this one isn't
completely correct because having just
watched fluxes talk they've changed
things up a bit so the actual link
between the store and view looks to be
immutable but just like small talk NPC
the store no device to view and the view
calls get a method to install and just
like Smalltalk MVC when a new event
happens the view sends an action to
dispatcher or maybe the view sends
events and gestures to control so one of
the big differences between flux and
having an immutable unidirectional flow
is the way react works it allows for
local state in your virtual tree so the
react virtual tree is actually mutable
and the way you set up your react
components you have event handlers
right next to the definition of the
random effort which you know if you are
well behaved that's not a problem if you
are not well behaved you might be
tempted to change some of the local
state directly in an event handler
because that's a very convenient way to
fix a bug right now
so having look at all these diagrams
it looks like nominees ideas are that
new or that different it looks very
similar to the small talk MVC the
biggest difference here is the ability
to have immutable references so you can
actually reason about sauce proof the
other difference between something like
react MP storm and this approach is
somewhere here yes there is one link
between state and random but there is
only one way to do rendering which was
top-down you will never end in a
position where you have ten stores or
ten models talking to ten views and
having lots of interconnected errors but
I should show you a demo to concretely
show what this looks like so I'll
quickly start a new example
so the library I'm using is not that
interesting or exciting you should
consider it to be a reference to
plantation my particular implementation
of mercury II was designed to be very
modular if you ever get a chance to take
a look at it it's composed of lots of
really small modules which means if we
don't agree with my implementation you
can reuse half of it and switch out the
other half for something better
I've always been curious whether someone
might change my immuno state
representation for something like Maury
where Maury is the immutable data
structures dad's ohm uses and the ones
that are both in the closure script so
we want to abstract our applications
into some kind of component and when we
start building an application we start
with the state modeling the state so the
way this is set up is you are forced to
be explicit about what you want so let's
have a quick recap of what I'm going to
do I wanted to build a little example
with a list of counters and you can add
counters to lists and you can increment
and decrement counters which is the
pretty much the simplest possible
example that demonstrates you can do
dynamic stuff because any static UI is
really really boring so you start with
choosing a data structure I'm going to
use a hash table and I'm going to put a
bunch of objects in the hash table and
just going to have a number property
so we have a state I'm going to assign
it to a variable and we want a render
function so rendering takes the state
and figures out how to render it so I
have this horribly horribly ugly DSL for
creating a virtual Dom from JavaScript
using this h function you give it a tag
name and there's a children and you do
all kinds of fun stuff with object keys
the state CONUS so all of these data
structures that you have are just plain
JavaScript data structures so you can do
anything that you want with JavaScript
data structures and turn thing and divs
are the most amazing elements to create
they're definitely the best so you want
to show the number label we want these
two buttons for increment and decrement
we properly need a button to add a
counter so we set up a state we set up
the rendering we can now return the
state from this have the app and do
boilerplate because it would love spot a
plate so I made sure you need to render
a de application so we're going to
render the application into the document
the body and every single time the state
changes we'll just call render again and
do the correct thing
so this is really boring because there's
no interaction yet do you have to define
some interaction we wanted to finally
click to be an Advent what do we want to
add nothing we just want to add so to be
able to tell how to trigger an ADD event
we need to have a reference the add
event to trigger so we'll set up a bunch
of events and doesn't know how you do
JavaScript
I mean want to start writing some update
logic given the state I want to return
add operation and it's just going to do
state dot put some ID put an ID and some
number zero we don't care the rest and
you probably need to see you when you so
we have our update logic that defines
how we want to update our application
and we now need to set up an input logic
that defines how we wire our events
together so one on the event and happens
we just want to call update add and then
we need to thread everything through
which is a little bit tedious but just a
little bit of tedium gives you the
strong separation that you probably want
to have and obviously if you're building
like a really simple to app you don't
care about the separation like you just
do everything in line and you know that
you can separate stuff out later
so this is how you wire things up we
render the UI when an add event happens
it comes in through the input it
triggers the update function and if you
make this bigger bigger bigger bigger
bigger bigger and an update just mutates
the state it just says you know let's
put a new thing in the state and then
you can't do this because we call the
counters and you know we have this
object of counters trigger we render
here in the renderer you know we're
looping over the counters and we're
creating like a new thing
yay exciting exciting setting setting so
what I've been showing you how that
works because I probably type out
everything that's not how I do things I
will show you a pre-prepared one that is
the exact same thing and then you can
see exactly how this works so the
application start off with an add button
and when you click it we have a new
counter we click it again we have
another counter exciting setting yada
yada yadi and the increment and
decrement stuff works except increment
is wrong and it goes down which is a
let's take a look how do you do bug that
well we probably have an increment event
somewhere okay we have increment and
decrement events we can update logics
and inside the update logic you can see
there's a function called increment that
has a minus in it that's that's probably
what the bug is there so this was a
quick example and notice how in the
example code
none of these components were complected
and none of these components has
bi-directional references to each other
they were all very separate none of them
had access to each other's source of
truth none of them could mutate each
other and you have you have everything
you want and it's all nice and fun so at
this point our fact ask people whether
they have any questions or any
curiosities and shouldn't be shy
so my accents Dutch and I spent 10 years
in England so the British Dutch so the
question was what are the disadvantages
and advantages compared to react influx
for this so mercury is up in my github
on named Randolph's and I have a section
in here about like mercury fish versus
react where it shows somebody bandages
and you shouldn't read this you should
read this really Jim the quick answer is
with mercury by design were a lot more
strict about immutability so react
allows you to have local state in your
components and one of the things you saw
on a flux example was when a store
changes you go and update some state in
your component you go and grab some
state out of the store and set the state
on the component and that to me sounds
like two-way replication on data binding
between your model and your view so that
type of thing just doesn't exist in
mercury we just we just pass the
arguments around you just get the entire
state you don't get to like copy a bit
of your state into yourself you just
have to like here's the entire state
figure it out and please be pure please
make your rendering functions pure so if
you create function so the question is
why do we have these functions are bound
to the state so you create these
functions once for your component and
they basically enforce privacy so you
could create a whole bunch of static
functions where you bind the state to it
because this you have to pass these
functions to the stuff that handles the
input and if you have to if the input
has access to the state it can now read
and mutate it so you pay a bit of like
binding cost but this privacy gives you
separation
so the state that you see was not the
initial state it was an observable
representation of state so I wasn't it
was a full object that you can mutate
and just emits new immutable values so
there's two ways to do Network requests
and it depends on how much do you like
MVC versus FRP so people in the npc
community seem to think you know we have
a model we have a domain when we want to
do a network request we update the state
we'll just do it right there in a box
called state and we'll just update it
right there now since the state is like
an observable there's nothing wrong with
doing actually I request an update in
the observable later it will still
propagate through correctly that's one
option that definitely works the other
option which is an option that comes
from something like f RP or elm is to
say you know what updating the server
doing side effects like that that's just
a different form of raw output so you
put it right next to that box that's
called the DOM and you generalize that
box that's call to the Dom to be like
all side effects that I don't really
care about and I don't like for some
reason functional people don't like side
effects so at that point the response
that you are would have to be one of the
raw inputs and similar to the way how
flux says you know stuff coming from the
server which is a new action you could
do it like that and the benefit of that
approach is that that nice little box
there called parent is not going to make
actual requests it's gonna be like a
nice pure box just manage its own local
state doesn't have any side effect
doesn't mutate anything that I didn't
create which plays really nice with such
things as the buggers and time travel
because we have a pure rendering
function and because we have observable
state we can just catch the last 100
state snapshots and time travel
backwards and forth now or you can catch
the last hundred inputs you can just go
put a loaf acade around the inputs and
cache those and if your state doesn't do
side effects you can replay the last
hundred inputs and see if you can
reproduce the bug or see see if you can
send the last one of inputs to the
server every single time you get an
exception in production and I'm because
you don't do any actual side effects in
the state you can you can replay them
locally when something goes wrong on
production at the back that's okay as
application size grows how much more
complicated get does this get compared
to NPC I don't think anybody in the FRP
community has built applications bigger
than MPC applications now one thing you
do notice that this is very similar to
the MPC diagrams from the 70s small talk
I can't give you any information about
that like I just have not built
personally build applications big enough
and we're talking about applications
that are more than 100 thousand lines of
code that's not something I've done
so the question was when debugging
applications that use attributes or
databinding in your Dom compared to H
how how easy is it to actually see
what's going on so for H itself I
haven't built any debugger integration I
know that react has built the bugger
integration for that thing their thing
is exactly the same and they have they
have like a different tab in your chrome
debugger that's like watching the tree
of the Dom but instead you see the tree
of components so I imagine you want to
build something similar to that to be
able to inspect that tree and we all to
quickly jump from any Dom node that you
can inspect in you an inspector to the
source code they'll be faster because
somebody sat down and spent like a year
writing them I spend about free weekends
the threat of hood mori is that of data
structures are faster so that's really
nice and the question here was how does
Mori compare to the way I do immutable
data structures the consequence is that
the data structures Mori gives you are
not arrays and they're not objects as
you know in JavaScript the rendering
function we wrote just did plain
iteration over JavaScript objects and
play intuition over arrays so if you use
Mori I'll be faster but your rendering
function needs to like know the specific
Mori functions to call to do iteration
and getting okay I think that's all
thank you everybody
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>