<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building Web Applications with Ember.js | Coder Coacher - Coaching Coders</title><meta content="Building Web Applications with Ember.js - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building Web Applications with Ember.js</b></h2><h5 class="post__date">2013-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/u6RFyVN9sNg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so today I'm here to talk about ember
chance this is actually the first big
talk I'm giving on ember in a little
while so if you're familiar at all of
ember a lot of change in the past six
months or so and so what's what I'm
gonna do today is sort of a talk in
three acts so I'm gonna first start by
talking a little bit about what does
ember why is it why I think it's cool
why I think you should think it's cool
whatever the big picture idea as an
ember I'm not going to go into a lot of
nitty-gritty about the about the
implementation because part two is just
gonna be a live demo I'm gonna build an
app and then the third part is me just
talking about where the web is going and
how amber fits into that so I think a
lot of times people want to talk about
or want to think about okay so 2013
April 2013 web pretty cool but I can see
that some things are changing how do i
future-proof myself I think there's a
difference between how I ember future
purpose itself and how your app future
proves itself just because I hope embers
around in five years but probably most
apps that start today are gonna be in
maintenance mode in five years so maybe
not all but many apps so I think there's
a difference between how you should
think about future proofing your apps
and how we think about future proofing
things I'll talk really about both of
those things towards the end of my talk
so the first thing I want to say is I
think now is really a great time to be a
web developer I think it's never a bit
there's never been a better time in fact
to be a web developer if you go look at
pretty much every single web site of any
person that has a browser they have
hundreds and hundreds of really cool
experiments that they're they want you
to want to show you that there's really
new things going on so there's all the
Google stuff even Microsoft has all
these html5 labs new features that
they're prototyping that you can play
with I think Mozilla stuff is really
cool there you're there
graphics are the nicest of all the demo
sites but they have do really cool stuff
they have like 3d shooters they have
games
I think Firefox OS is really pushing
them so what I think if you go back when
I started doing web development solidly
in 2005 we were kind of in a dark ages
I think ie 6 was still really the only
browser
Firefox had just started to pick up a
little bit of steam so people cared a
little bit about multiple browsers but
really ie6 had 90% market share and I
think back then people talked a lot
about the fact that you know cool story
you know the next version of JavaScript
or whatever someone's working on of
html5 when am I gonna get to use that
and I think that was a reasonable thing
to think in 2005 after five years of
stagnation but I think people just kept
saying that so in 2013 after the last
five years of extremely rapid
development and I'll talk about that
more at the end of my talk we're still
talking about talking about the web as
though five years from now we're gonna
be in a stagnated State and I think if
you look back at the last five years
that's just not reasonable it's not a
reasonable way to look at how the web is
progressing I'm not but I think even if
you just look at 2013 things are really
great it's a really great time to be a
web developer so the first thing I want
to sort of talk about is there's two
websites that I didn't showing here
there's the New York Times and discourse
and the New York Times of course is a
site that is mostly dealing with content
it's mostly a content driven website
discourse also it's a form piece of form
software built on ember also a content
driven website the New York Times I
think is what usually people talk about
when they say this is an example of a
site you should not build using a single
page app so the question that I have is
is why what are the differences really
between these two sites and the first
thing that I'll say is it's certainly
not the amount of JavaScript if you go
look at the New York Times you'll find
that the New York Times has 802
kilobytes of JavaScript and discourse
this is over the wire dollar script this
course has 284 kilobytes and I'm not
saying this to say look ember so small I
actually the 284 kilobytes of JavaScript
there's nothing to sneeze at what I'm
saying is that sometimes you look at
sites you think this is just a static a
piece of static content and there's just
a ton of JavaScript in the New York
Times this case there's there's a bunch
of ads stuff there's some external
services that they're using for video
there's just all this stuff and if you
looked in your time they end up it ends
up adding up to something like 5 seconds
of before Dom ready this course has a
much smaller time so it's the answer to
the question what is the difference
between these two apps is not how much
JavaScript there is I think people talk
about single page apps or JavaScript
heavy
as the distinction and I'm just saying
as a practical matter in 2013 almost
every app that is a serious app that's
doing real things on the internet that
is what people would consider just a
Content app or just a document app has a
lot of JavaScript on it for whatever
reason it just turns out to be the case
and what I'm saying is that the
difference actually is whether the app
is designed to be long-lived or not so I
think the reason why people think of the
New York Times as a Content site and
they think of discourse as an app is
that the New York Times every single
time you click on a link you get a new
page the page gets removed then it gets
added now in New York Times this case
there's a lot of JavaScript so it's not
again about the amount of JavaScript
that gets loaded on any given page but
there is a difference this course has a
single piece of JavaScript it gets
loaded one time and then you stay on
this the discourse page forever you stay
on the discourse page for a long time as
you navigate around as you look at
different pieces of content so these are
two different two different ways of
building applications and if you want to
build your app as a long-lived app as
opposed to a short-lived app what ends
up happening is that you have different
kinds of data that need to reflect the
life cycle the application so you have
things that usually are called models
and what a model is is something that
lasts across all sessions so no matter
you reload the page you bookmark it you
give it to your friend you command tab
models are basically the same always now
they may happen to get stored in local
storage they may get sorted index DB
they may get stored on a server you
might use meteor parse but all these
things are examples of pieces of data
that are long-lived that live across the
entire lifetime of your of your
application be across page reloads and
then people usually call talk about the
controller and I think in most systems
that caught that pretend or talked about
being MVC in some way or another this is
really the role of the controller
regardless of where it sits in the
architecture it's managing pieces of
data that live across the entire
lifetime of your application but not
across reload so if you you know for
example if you have a piece of content
that you could expand or contract a
little triangle maybe that information
wants to live across the entire time
that your user is moving around the
application because you know if you move
out of a tab and come back to the tab
you don't want that state to go away but
if the user reloads you're gonna want to
start from scratch so usually in the
controller manages state that's just for
this session and the template of review
whatever you're calling it in your
framework dujour manages what is
currently on the screen what is
currently visible and I think different
frameworks do a better or worse job of
building an architecture around the fact
that this is what is going on but I
think fundamentally this has got what's
going on and it's how ember thinks about
the division of responsibilities it's
mostly about the lifetime of your
application so why does this why does it
matter
what these different what these
different pieces of your application how
long they live so one really big reason
is garbage so obviously you don't want
to be collecting your models so there
are some frameworks that say garbage
collection is such an important problem
that we're just as soon as you leave the
page we're gonna just nuke your models
and if you happen to come back to it
just to make another request to your
server and the problem with that line of
reasoning is that the models actually by
definition are things that should not
get new they're by definition things
that last a very very long time you
unless you have a hundred thousand
pieces of that or something from your
server and you really really need direct
control over the memory you normally
want that stuff to stick around you want
it to be around over the lifetime
grappling and then similarly a lot of
people will end up mashing together
their state of things like is this
triangle expander or not together with
their view state with their template
state and what that can mean is that you
have to choose between either leaving
all of your views around all the time
because they have all if this important
state and usually that means keeping
around Dom nodes and means keeping
around all kinds of expensive state or
you have to say you know what I'm just
gonna throw it away and the users are
gonna come back to this tab and they're
just gonna have to re-expand that thing
and I think both of those choices are
bad and so what that means is that what
you really want is a piece of your
architecture that's designed around the
second piece of type of state it's
designed around the exact route long
live hole session state and then finally
I think there is a route there is room
for your view state which is basically
things that if you leave you can easily
regenerate because now
you've moved all the important state out
of the view you can easily throw away
the DOM and just bring it back to life
from the other state now I think one
thing that simpler solutions often do is
they try to combine some of these levels
so for example a lot of backbone apps
combine the model and the controller
into one into one place on the grounds
that you should just be able to generate
your view from some other layer and I
think that's fine I think there's I
think there's utility in once you divide
up the things that are easily
regenerated bull and the things that are
not I think that's really a huge win in
and of itself but we have found is that
dividing these things up into three
layers provides both good semantics for
what things can stick around and what
things should be nuked but also general
organization so I think it turns out
that there's good organization reasons
to differentiate between things that are
going to be sticking around when you
reload the page and things that are just
temporary for this particular session so
really what ember tries to do is it
tries to think about ways to divide up
your application into reasonable buckets
that into the particularly these three
buckets so that's number one number two
is ember is just HTML so some of you
might know ember is history we come from
this proper framework and sprout core
like a lot of frameworks that were being
created around that time cappucino EXT
j/s they try to abstract away HTML they
try to tell you you just write some
JavaScript you write some widgets and
we'll put some HTML on the screen for
you and I think the problem with that is
that people already know HTML people
already know CSS either on your own or
with the rest of a team you have
techniques for dealing with CSS
somebody's gonna write a piece of HTML
and give it to you you need to use it
you need to use some CSS that already
exists maybe your application already
has a style that you want to use and
being told no problem just rewrite your
theme using cappuccinos theming system
that doesn't really it's fine if you're
gonna really bet everything on that and
spend months and months to figure out
how the system works but I think it's
really it's a lot better to just say
we're just we're just doing HTML we're
adding some features to HTML so an
example of this would be in ember if you
have an image tag which is the top you
can actually bind automatically without
having Ember
to know anything about an image tag you
combined its source attribute to some
piece of model state so you can imagine
having a URL triggered on your model and
you can bind the source attribute to
that and if it happens to change the
image will automatically update and I
think the really great thing about the
fact that it's based on HTML Dom
attributes is that if you go and you
have an audio tag which has an SRC so
the web's the web is all based around
tags and attributes the same exact
techniques work without ever having to
do anything special without ever having
to learn any new tricks the normal
actually binding solutions the normal
mechanisms for generating for building
HTML all that stuff will continue to
work so I think this actually turned out
to be really cool we were doing a
training a few months ago and we wanted
to do an RTO application and we didn't
have to add anything to ember for it to
handle the audio tag which is really
great so again I think the important
thing here is we don't want to replace
HTML we think hTML is the way that
people should build applications we want
to add to it we want to augment it to it
using handlebars which is a very popular
templating engine already we basically
use that same templating engine to add
features to HTML but which are live
bound which are gonna be working inside
of Ember so that's number two and number
three is is URLs so I think a lot of
people look at URLs they build they
build they start with building something
like the New York Times and you or you
get URLs for free and people get really
used to using URLs and in all kinds of
contexts and then they go to build a
single page application and they're so
busy with the UI with the UX whatever
their designer gave them that they
completely forget URLs they completely
forget that you or else exists so for
example to do MVC today handles URLs so
today you'll see the little R box means
that there's a URL support and the to do
MVC example but the first version of to
do MVC didn't support URLs at all so you
would go learn about how to build a
single page a single page web
application using all these frameworks
and there was nothing at all in the
first version about URLs now of course
it became obvious to addy that this is
an important feature so he added it as a
requirement but I think unfortunately
for many frameworks this is a sort of
tack on feature it's something that you
think about down the road
do I really need a URL or do I not need
a URL and I think the interesting thing
is that when you look at applications
like discourse or applications like
Facebook keep your eye on the URL bar
for applications like Twitter or even
applications like our do you find out
that people who are doing this for real
people who are really building web
applications no matter how single Paigey
they are have really good URL
experiences people really think hard
about how to make URLs good and that's
because people expect that when they're
inside of the browser they expect the UI
to be there is a URL bar and you can
copy something and it will have
something to do with the current state
of where you are and you can share that
state with your friends so I took a look
at my Twitter feed yesterday just
randomly the top post and I noticed that
pretty much every post on here has a URL
in it and I think it's hard it's easy to
forget when you're going you're building
these single page applications you're
you know you're jumping in and you're
focusing on all the single page EE the
JavaScript heavy the client-side
application it's easy to forget that the
way that people still mostly interact
with the web is as a URL box on top bar
on top and a black box on the bottom and
they want to make sure that as they're
moving around conceptually around the
application into different areas of
content that they can copy something
from there and paste it I think for
example it's kind of annoying that in
Gmail sorry not in Gmail in Google Maps
you have to say give me a URL I think
those UI's everybody can feel
something's wrong about that right you
want to just be able to copy it out of
the URL bar why do I have to ask for URL
why is this not working what is that URL
bar for in the first place and what I
would say is the URL is actually if you
want to think about what is the UI of
the web how is the web different from
native fundamentally the URL is the UI
of the web people use the UI for
bookmarking people use it for sharing
with other people on Twitter on Facebook
on Google+ people use it for emailing I
looked at my email box 80% of the top 50
emails in my email box had a URL one or
more URLs in them so people are really
people really want to be able to pass
around URLs their application people use
the command tab feature to open things
in a new tab or right-click open a new
tab right people are really relying on
the fact that as they're navigating
around applications they get URL support
and I would go a little bit further to
say if your application doesn't have URL
support it is not a web app it's an
application it happens to be delivered
using web technologies you happen to get
to it through the web browser but the
application fundamentally is an
application is not a web application
it's an app it's a application written
using JavaScript and I think one thing
that's interesting is that once you
start thinking of URLs as fundamental to
what you're doing what you realize is
that there's a lot of places where you
would think this is completely
inappropriate place for URLs but where
it's really valuable so for example
imagine I'm playing a first-person
shooter and I could just grab the URL
and I am my friend hey won't you join me
here now obviously you're not going to
give the your friend all the state
exactly you know all the exact specific
state that you have but maybe it will
give them enough information to join you
at the appropriate level or around the
same location that you are in the game
imagine that I'm in Gmail and I can just
take a link the current URL for an email
and send it to my friend who I see a CC
so I say hey friend I would like you to
go look at this email and I can see that
you're a CC so you should have access to
it why don't you we'll take a look at
this instead of telling them go search
for this subject 1 or I think one of my
favorite examples is if you go into the
chrome settings you get everything you
do including modal dialogues is a URL
and I think that's really helpful
sometimes you know my mom calls up and
she says I don't really know what to do
I'm trying to like you know add
something to my phone I'm trying to
change this setting and the fact that I
can go in there go exactly where I need
to be and I amber a link that says here
is where you need to go into settings
this is pretty this app seems pretty
unusual in the sense that it's my
personal settings I have a modal dialog
up what does it have to do with URLs but
when you think about how valuable it is
to share with your friends share by
email share by bookmarking don't think
about whether or not you should add a
URL you should be thinking about whether
it's appropriate to eliminate it but
it's appropriate to leave it out so this
is I think fundamentally what ember is
about today it's about making it so that
you don't have a choice if you want to
opt-out of URLs you have to think hard
and long about it and you basically get
URLs as part of the
packages building a number application
so with that why don't I start by why
don't I go build something so let me
let's build an application let me swap
ok so now I'm just gonna go and build
and build an app ok so let me let me
just start so here i've downloaded the
ember starter kit i've made a few small
tweaks to it the first thing is that I
am down I'm using the ember nightly
build instead of the one that we just
released there's a few changes in it
that matter to me I'm well I've also
included the showdown library which is a
markdown library and I've also included
the Twitter bootstrap library CSS
framework and what I'm gonna be doing
today is build a simple markdown editor
a little place for you to have a list of
files that you can that you can edit etc
so we're gonna start by just allowing me
I'm gonna start by allowing me to edit
my name so I want to have an input tag
here so input type equals text value
equals name and then we're gonna put an
h2 and h1 here which basically says
markdown files by name ok so a few
things I want to point out here so this
here is a script tag and it's basically
just a template it's the main template
for application it doesn't have a name
so it's basically what ember will use if
you don't do anything if you don't have
any URLs its gonna render this first so
also I want to point out this info tag
here is basically it's obviously not
using angle brackets and that's because
it's dynamic so it's basically the same
thing as regular input ID but it has
dynamic properties in this case we're
gonna say that its value is the same as
this name thing and that's gonna be
bound to this name field over here so
let me open it
great so I'm going to say you two cats
and great so it works so that's the
first starting point unfortunately if I
reload now of course it's going to get
lost so let's fix that let's have that
information get persisted to local
storage so what I'm gonna do here is I'm
going to tell my input that it has an
action which is save name and that
action by default is going to get
triggered when I hit enter so I'm gonna
go into here and I'm going to create the
application controller and the
application controller is basically just
the object that handles events from the
application template so it's gonna be an
ember controller and I'm going to say
save name it's going to get the value
which is the current name that's in text
box and what I'm going to do here is I'm
going to say okay I want to save this to
local storage so local storage dot say
app name equals value and so that's fine
that's gonna save it but of course I
also need to load it in the first place
from somewhere so I'm going to say that
there is an initialization here so this
is just a constructor function for this
controller and I'm gonna say this dot
set name local storage dot app name so
basically what I've done here is we have
this can we have this template over here
it's getting its information from the
controller that is the same name the
application controller and what we're
doing is we're saying whenever this
controller gets initialized which is
going to happen right away when the
application boots set its name property
to the local storage information and
when you hit enter which is going to
trigger this safe name function I should
probably then save it to local storage
so let me do this you to cats
and now let's go here we can see local
storage app name right correct and if I
reload you'll see it works and
importantly you can see that both the
input field and the the text over here
got the information so now we've stored
the information in local storage so now
the next thing that I want to do is I
want to list out all the files that I
have so in order to do this I'm going to
make a second template so it's going to
be script type equals text X handlebars
and now I'm gonna say that a template
name equals files and this is gonna be a
list of all the files that I have and
you'll see over here I basically created
a list of files over here that have
little slug title etc and then I've also
over here all I've done is I've made
that same array have indexed them by the
slug so that way I later on when I'm
gonna want to get it from the URL I have
an easy way to get it so of course in
practice you would probably do something
a little more complicated than this but
this is just for for demo purposes it's
pretty straightforward so what I want to
do here and I'm gonna grab some HTML
from I'm gonna grab some Twitter
bootstrap HTML from here let me
so it's just simple Twitter bootstrap we
have a container we have row span three
which is a table which has a list of
files in it and then span 9 which is
where we're gonna put the individual
files actually let me I'll kill that for
now so we reload it and nothing happens
and so that seems that seems problematic
and the reason that nothing happened is
as I said before everything in ember is
driven by a URL so the first thing that
we need to do is we need to provide a
URL for that files location so we're
gonna say this dot resource files ok so
now if I go back and add files again
nothing's going to happen so why has
nothing happened well the reason nothing
happened is that I haven't told the
application where it should put that
files template inside of my main
template so of course we want this is
the template that we want to appear all
the time no matter what we're doing and
we need to say ok here is where you
should here's an outlet and that means
when you want to put another template in
here's the place that it goes so now if
I reload you can see great so the other
template appears now unfortunately
having it be a piece of static content
is not very useful if I keep going down
this path you're gonna start wondering
why I'm not using Django or Rails or
something like that so let's start let's
do some dynamic content so here we can
see we're inside of a table with a TR
and I'm gonna say each file in model and
I'm going to say here's a TR here's a TD
and I'm going to say chip each file
sorry file dot was it title yep file
that title by file by author
nice
okay so we're gonna have a problem
though if we reload of course we have no
model so so far we've said loop over all
the things that are in my model but we
have not told it what the model is so
it's looping over nothing so what we
need to do is we need to tell it what
the model is and the way you do that an
ember is that you create a route so app
dot files route and there's a function
called model over here and basically
this model is just you tell it what the
model is and then that becomes the model
inside of your template by the same name
so we're just gonna return files here
right and that base is gonna say this
array of files is going to become the
model over here that we're looping over
it's by the same name so great so now we
have we've looped over the model so
awesome so the next thing we probably
want to do is okay I want to actually go
look at one of those individual files so
you guessed it then we're gonna want to
make another template for each
individual file so script type equals
text X handlebars data template name
equals individual file script and what
we're gonna do is we're gonna say h2
title - god sublime is really screwing
me here h3 author will save by author
slash h3 and then we will just put a div
here let me see if I know just the div
and we're gonna put the contents in here
right so basically now we're looking at
an individual file and we want to put
the title author in context so again as
you probably expected so we have a
template here but we haven't actually
said how to get to it so we need to
provide a route for individual files so
let's go back to our router we're gonna
say that we want a resource for
individual file and in this case we have
to provide a path and the reason we have
to provide the path is of course there
are many different files and it's not
instead of there just being one file so
we need to provide a little dynamic
segment there that says this is gonna be
the files ID now if I was to go to files
/ let's say one of the IDs is
rails is omakase it did enter nothing is
going to happen and if you go look at it
it's going to say hey you assertion
failed you use the dynamic segment hold
on let me disable this so that it does
not cause problems in the future it says
hey you used the dynamic second file ID
but you didn't have a plot file which is
how other member data hooks into it but
also you did not override your routes I
cannot you cannot get to the other side
but it basically says you didn't
override your routes model hook so in
order to actually say what is gone what
file to use we have to override the
routes model hooks so let's go do that
so we have basically the same thing app
that individual file route equals M bar
out extend it has a model this time it's
gonna take a list of all the parameters
that came in from from the URL you have
a files ID and we're going to return
files params dot file ID right so that /
am is gonna come from here and we've
indexed this little loop over here
indexed all them by their ID so now we
are going to do we're going to do that
so now we can see that we have gone to
files rails is omaha say and now we can
see that it's here
well there's one small issue here which
is that you can see if you look at the
original source that there is
it's hard to see it but it is marked
down and we would like that to actually
be marked on so it actually would be
easier if we go to Y Ruby so we can see
that there is some work down here and we
would like to actually present that as
markdown we would not like to present
that as as just plain text so the way
that you do this in ember is that you
create what is called a helper so I've
included the showdown library and the
showdown library is going to allow us to
convert normal text into HTML and we're
gonna say ember dot handlebars dot
helper markdown it takes it's a function
which takes a value which is basically
just whatever it is that we're in the we
want to convert we're gonna save our
converter equals new showdown converter
and then we're gonna return converter
dot make HTML value now we just go back
here we say okay we would like this
contents to be displayed as markdown
refresh well so this is not exactly what
we wanted we can see that everything's
escaped so the reason that everything's
escaped is that in ember by default any
text that you put into the page left
escaped and this is to prevent you from
having to deal with XSS in order to tell
ember specifically that what you want
here is something that is safe so I know
that I put it through markdown therefore
I know that it's safe what I do is I can
go here and I can say this is a new
handlebars dot safe spring and that
basically says you can safely convert
render this as HTML and now it's HTML
there's something weird with the CSS
here but ok and you can see by the way
that as I go back and forth everything
is doing the right thing well so we've
done all this but now if we go back to
the files list we have no way to
actually get to the individual pages so
that's X well there's good news which is
that we have already specified the route
profile so we can just go in here and we
can say link to individual file and then
we just pass the file that's currently
in scope
this is a little weird and then we close
the link - so what's happening here is
that we're basically we have a file in
scope a file object and we're basically
passing it along and what's going to
happen is that ember is going to
automatically pull its ID out and it's
going to use that as the URL to generate
the URL it's basically going to put it
replace it with replace this little
segment over here with the ID from that
object so now if i refresh it you can
see that there is URLs if you see on the
bottom right rails as ohmic I say if I
click on it great it's going to come in
here so great so we've done good so far
and if you go back of course you get the
lists now I hope that what you're
noticing is that everything in ember is
really URL driven it's very there's not
an easy way to think about these things
in terms of oh I just want to click on
this and have something appear you
really think about in terms of URLs but
we've made it so simple to use URLs that
you really have no excuse not to so you
get really the benefits of sharing
bookmarking so for example if I go back
here and command click sorry if I go
down here and open link in new tab
you'll see that it of course does the
right thing which means if I put it on
Twitter or something it's all going to
work so that's great so now the last
thing I want to do before I get into
editing how much time do I have
does anyone know ok great I'm still on
track so the last thing that I want to
do before I get into editing is what if
I want to actually leave them both on
the same screen at the same time so I
want to have what is called the nesting
UI so sort of like what Gmail as where
you leave a read-along the list on the
left side even though you're a middle
viewing something on the right side so
this is something that is can be a
little bit tricky in some frameworks and
ember we thought about out of the way
that our outlets and our routes work
from the ground up to support this use
case so what we're gonna do here is
we're going to put in the first thing
we're gonna do is we're gonna say that
our route should be nested so instead of
having two separate routes we're going
to grab this and we're gonna put it
inside and of course we don't need to
put files here anymore
right so now we have it nested inside
but there's gonna be a small issue which
is that if I go to rails as omec I say
nothing is going to happen and the
reason is similar to what happened
before which is that I haven't actually
told ember where to put that child
template so I've told them where I would
like you to render the file template
inside of the files template but I've
not actually pulled it where to put it
so that's actually rather
straightforward how to fix it so we
basically go here we create another div
with class equals let's say span nine
and inside of that div we throw in an
outlet and now what we can see is that
and now what we can see is that the
child template you can see that we have
a child route files and then inside was
rails omeka SE and we can see that that
same route structure that we've set up
over here represents the nesting of the
UI structure so basically you can have
nested you eyes and have them be
reflected in the URL very very simply
which is great now another thing that I
thought I would I point out is that you
can see that these why is why Ruby and
rails omeka say are becoming bolded as I
click on them and that's because when
you use the link to help here we are
automatically adding an active class if
the thing that you are rendering happens
to be the current active State so
without you having to do any additional
work you can just you can just kind of
this active State and if you look at the
CSS here you can just see that I have
said when a link is active and make it
bold different great so now the very
last thing that I want to show you in
the demo is okay what if I want to
actually edit these individual files so
the first thing I'm going to do is I'm
going to go into my file and I'm going
to add some text I'm going to add some
form fields so input well let's let's
throw in a label label 4 equals title
title
slash label
and then I'm going to put an input type
equals text I'm going to have ID equals
title and then I'm going to have value
equals title what is going on here great
value equals title and then I'm going to
say slash man and now you can see that
if I go and change things you can see
that it's changing in all the locations
and now I'll just do a few more of these
right I'll add a text field for the
author
and I will add a text area
for the contents and this yes so this
guy is gonna be a text area his ID is
going to be contents and its value is
going to be contents so if I go in here
and I actually let me throw in I can add
rows equals ten great so now if I want
to go in and say you know I want to say
rails is what I say you can see that I'm
getting a live markdown editor over here
and I didn't really have to write any
code to make that live markdown it in
there work the fact that it's going
through the markdown helper and the fact
that it's bound to the same code the
same that attributes that's making
everything just work everything is just
hooked up together got me asked me to do
anything else okay and the last thing I
want to sit show is basically okay I
probably don't want to have these edit
options open the entire time so let me
make it possible to just optionally put
in edit or not so the first thing I'm
going to do is pull out this block here
into a partial so I'm gonna say script
type equals text X handlebars data
template name equals file slash
underscore form / script one time it was
useful okay so I have this form and then
inside of here I'm gonna the first thing
I'm going to do is just change it to a
partial file slash form and that's going
to basically throw in the partial so
you'll see okay everything of course
still works as before but what we want
to do is we want to say okay I only want
to show this form if I'm in the middle
if I'm in an editing mode
so I'm gonna say okay if I mean if is
editing if I'm in editing mode show the
form and show a button whose action is
done and I'll put this done thing here
otherwise just show a button that says
that goes into edit and have an edit
button
okay so /if and we have an edit button
but of course I haven't told it to do
anything so that's not going to do us a
lot of good so we're inside of the file
templates so we're gonna handle these
actions through the file controller so
let's go over here and we'll say app dot
file controller equals ember dot object
controller dot extend the object
controller is basically just because
we're showing an individual object here
instead of a list which would be in a
RAID controller and the first thing
we're gonna do is we're going to say
okay the default for is editing is gonna
be false and then we're gonna have a
thing a method called edit and that
method called edit is going to say this
dot set is editing true and we're gonna
have it done which is gonna say this dot
set is editing false okay now if I press
the edit button we get all the things I
say done we're done so I actually had
more in my demo which was to now hook up
this saving to local storage the way you
I'll just describe how you do it and it
can be left as an exercise to the reader
so we already talked about how to do
local storage here you would basically
do a similar thing down here and when
you click done you basically persist the
current object of local storage and when
you boot it up the application you would
read all the objects out of local
storage in the first place so instead of
hard-coding this files list you would be
getting it out of local storage and then
and everything would just work exactly
the same you wouldn't have to change
basically anything about your
application other than how you happen to
persist the data into the local storage
instead of a memory so cool so that is
that's the demo and now let me move on
to the future of the world
so now we have built something so I want
to reiterate that I think it's never
it's really never been a better time to
be a web developer you can do really
cool stuff you can see there's 3d
Mozilla has just released a first-person
shooter that runs at nearly native
speeds using 3d so you look at this this
is a series of features that are common
in native environments and actually we
have all these features today on the web
we have typed arrays which basically
allow you to control granularly pieces
blocks of memory with you know integers
and not have to worry about the GC we
have WebSockets that you open up sockets
anywhere we have web workers which allow
you to have threads we have WebGL which
is basically a port of opengl to the web
and we even have asm.js now which allows
you to compile C directly into something
that runs me maybe only one and a half
or two times slower than C even though
it's compiled down into JavaScript so
Mozilla has has recently shipped this
thing which basically will look at a
subset of JavaScript and compile it
directly into C so it's a little bit
around the side but it's compatible with
any JavaScript which means it runs in
chrome today chrome hasn't shipped any
kind of special C optimizations
it runs in chrome today a little bit
slower of course than Mozilla but there
was now a path to running something that
is very very close to native speeds
directly on the web so you could compile
your C code directly to the web so we've
gotten really really far I think again I
think this is what I was talking about
before if you look five years ago
basically none of these features existed
and now all these features existed the
web is really moving forward quickly I
don't think there's a lot that you can't
do today on the web platform and I think
if you grow your year from now that will
be even more the case I think between
Mozilla and Google and even Microsoft I
think we were really making a lot of
progress so I want to talk a little bit
about es6 so I'm a member of Tizen 39
which is the committee that works on the
next version of JavaScript and the thing
that we're working on right now most
heavily is es6 and one thing that really
excites me is today every single
framework every backbone Emporer angular
knockout all of us have our own systems
for doing something that's like a class
like abstraction which makes it really
hard for ember to publish some little
library and for angular to use it or
vice versa
for ember to build on top of backbone
because there's so much cross just in
terms of building up a usable JavaScript
runtime model and es6 provides a single
class like abstraction that everyone can
use and so what I would hope that would
happen in the near future is that think
people like Ember could really build on
top of the lower level abstractions that
other people are building because we
might share the same abstractions and I
think that's really that fun thing about
es6 but for me what's even more exciting
is that once you start going down this
path of having class like abstractions
and a lot of the other features that are
in es6 which I don't have time to talk
about we start getting to a point where
we could start thinking about things
like this so web components are a
feature that allows you to basically
build your own elements and part of the
idea behind web components is that you
should be able to just subclass HTML
elements so you could imagine that that
in a few years
ember views will just be subclasses of
HTML elements they won't be this heavy
special abstraction that's trying to
deal with deficiencies of the web they
will instead just be subclasses of HTML
element and I think when we think about
the future we don't really think about
trying to polyfill this type of thing
right now because by definition it's
it's almost impossible to polyfill right
now but what we think about is building
our building the Ember architecture so
that's easy to swap in so we're taking a
very close look and all these things I'm
actually involved closely in a lot of
the work that's going into this and
we're thinking about ok so as we're
closing in on ember 1.0 as we start work
on ember 1.1 what can we do that will
make us more easy to adopt these things
in the future and I think it's it's
worth mentioning that like I said
earlier for ember this is crucial for
ember we're gonna be around in two or
three years when this stuff drops and if
we have to go spend a year to refactor
everything we did to take advantage of
new features we're gonna be hosed but
for your application I don't think I
don't think you want to pay the
short-term performance penalties and
complexity penalties to try to get high
fidelity polyfills of these features so
I think for your application you what
you want is the best possible
performance the simplest possible
architecture that works on today's web
and you but you also want it to be
future proof you want it you want it you
want us to be thinking about what it
means in three years for ember to still
exist and to adopt these new features so
that's sort
we take a sort of pragmatic
middle-of-the-road approach we're not
trying to polyfill what we what looks
like might happen in a few years and we
don't we don't even really know yet but
we are looking very closely at what is
what looks like is going to happen to
think about how that fits into our
mental model of the world and I think
one thing that's really interesting to
me when you look at all those new
features you look at you know we have
sockets now we have malloc
we have WebGL one thing that we don't
have even even web components one thing
that we don't have is anything that's
really taking a look at the higher level
architecture point I think URLs are
crucial and there's really nothing in
the web platform that's trying to take
it that's trying to take a look at how
you should make people build front-end
web applications that are URLs front and
center I think that's something that
ember is doing and I hope that in the
future the web platform tackles it but
for now really it's left to frameworks
to tackle the architecture point and I
think for now this is something that
we're looking at both how to take
advantage of these new features like web
components but also how to make sure
that you have a higher level abstraction
for building your application that
doesn't stop at the HTML oval so custom
HTML tags is great but that's really not
the end of the story I think we all know
custom H developments are much nicer way
of building jQuery UI but jQuery UI
really isn't enough to build an
application and I think everybody knows
that so we're really thinking about a
higher level we're not just thinking
about building more you know making HTML
better although that's certainly a part
of what we're doing but we're also
thinking about what the architecture of
an application looks like like I said my
plans to be around for a long time we're
not playing going anywhere so we're
really thinking about what it means to
be future proof and how it fits in with
the direction of the web I think for me
things like class view extends HTML
element is really the core of how we
think about things going in the future
but I think one thing that I would point
out is that nothing is done yet there's
a lot that has changed about web
components just in the past few months
so it's a it's quite hard to talk about
ok-hee we know what components are gonna
be X or this a SM bs is gonna be Y
therefore we are going to like bet hard
on the exact state of the feature today
we're thinking about sort of the bigger
picture what it means to subclass an
HTML element and less about the exact
specifics of how that is going to work
I have just a couple slides left so here
are features that if I were you I would
keep an eye on these are features that
we are thinking hard about how they fit
into the two amber so things like
modules es6 is gonna have a standard
module system that sort of replaces
commonjs and AMD and the Yui module
loader all these things just like
there's a class abstraction that
replaces everyone's classes there's a
module abstraction that replaces
everyone's modules we're thinking about
how that fits in because right now
pretty much everyone does this like
single global application namespace
modules are a different way of thinking
about things so we're sort of building
the core of how ember looks up objects
so that it's compatible with both a
single application namespace and module
lookup
similarly classes are gonna be around
embers thinking about how to do that
object that observe in a rate observer
are really exciting they're basically a
mechanism for getting information
without having to override setting yet
about what what things have changed in
an object both of those are really
exciting they're things that Google has
been working on for the past year or so
together with tc39
i've been watching with great excitement
as every meeting they come in with more
information
they've already shipped an experiment
inside of chrome behind a flag so this
is really exciting to me and it's the
sort of thing that I don't I don't think
we can get high fidelity today but we
definitely want to build our
architecture so for example object that
observes ship delivers messages
asynchronously doesn't deliver them
immediately when the change happens so
ember from the beginning has always has
always followed this as always not try
to make any guarantees about when
exactly messages will get delivered and
we're thinking about even more going
further in that direction so that it
will be easier to adopt object that
observes when it lands proxies are
basically a way of overriding you know
every set every get the in call all
these things directly on side on an
object and we're thinking about how to
make ember objects feel better so you
don't have to go through these special
api's right so you go through what look
like the standard api is but you get the
benefits because now you can override
basically everything and like I said web
components web components are coming in
the future they're still changing a lot
but the idea of you know an ember view
just being a subclass of HTML and it is
really exciting to me so I'll close by
saying yet again there's never been a
better time to build
to be a web developer we can see things
like high fidelity you know unreal just
announced with Mozilla that their Unreal
Engine is coming to JavaScript through a
fmjs which is really awesome there are
really great things coming down the pike
embers that ember gives you the tools to
build applications that leverage all
these things that thinks about the
future but we don't want to forget about
the feature that made the web possible
and exciting and awesome in the first
place which is the humble URL thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>