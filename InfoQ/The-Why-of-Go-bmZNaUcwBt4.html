<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Why of Go | Coder Coacher - Coaching Coders</title><meta content="The Why of Go - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The Why of Go</b></h2><h5 class="post__date">2018-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bmZNaUcwBt4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome I'm glad you're here I'm glad
I'm here yeah so I'll let people filter
and I guess I don't know a little bit
before I get started I guess my name is
Carmen I work on if anyone's familiar
with Travis CI it's a hosted continuous
integration service and I'm on the build
infrastructure engineering team they're
based out of New York and I thank you
for coming in this talk okay so I have a
confession to make
I've come here from the year 1983 no
really i time-traveled and I'd like to
thank some of the people that helped me
acclimate myself to this earliest early
21st century and Jerome pitoni is the
first but didn't make it into the PDF
yeah mm-hmm you will for that for the
posterity he's right there
Dave Janie Alan Donovan Steve Francia
and my whole team at travesty I so back
to 1983 imagine that you are my fellow
software engineers from the year 1983
and you happened upon a time machine and
you traveled to 2017 you get a glimpse
of an opportunity to see the future of
computers and the exponential impact
that they've had on society you'll maybe
start to look for ideas to take back
with you and maybe you can be the person
to make the next lougle ever the curious
person you dive into everything that you
can about what's happened over the last
35 years with programming from where you
left it in 1983 until today so you soak
in everything about the current
programming languages and software
during practices and you'll get to see
some of the predictions that you've had
about hardware were confirmed and you'll
be in wonder of some of the things that
are still going strong and in wide use
today some 40-odd years later you'll get
to see this fairly new idea of object
orientation started by small talk a few
years before 1983 and then get it see it
integrated with C and have it be named
C++ and then you get to witness how that
really takes off and you'll see things
getting added and iterated and polished
and wrapped and super reps and you'll
see the evolution of this thing that we
call a stack or in 2017 you'll see how
and why we call it Turtles all the way
down and you'll see that computer coding
has grown big time there's this thing
called the cloud and that's just really
other people's computers but all this
growth is because source code is now
largely available and free on the
internet
the internet came in 1994 my fellow 1983
years and tcp/ip was also finalized in
1983 and yet for all I just mentioned a
big but exciting Internet by the way
that's the original paper by Tim
berners-lee
and the hand ride Henry note bio some of
the supervisors and there's the tcp/ip
proposal including HTTP protocol and yet
for all I've mentioned which was just
but a fraction of what's happened in 35
years you'll see that software
engineering as a profession languages
practices it's still largely
unstandardized and it's bustling and
it's ever-growing and it's moving like a
bazaar there was even this book about it
I don't know if I want to read it though
so what you'll see without exception are
all these ideas coming from previous
ideas I mentioned Bell Labs here because
Bell Labs was really do record for some
of the innovations in 1980 and those
will are still in use today
they're also the combination and
maturation of old ideas and they're born
from the very same people so even though
you'll see this growth of ideas and
languages you'll also find a curious
anomaly a language called go I give you
this 1983 thought exercise probably
because that's often a comment that I
hear about go that it is a language
often criticized as being stuck in the
1980s that go has taken all the last
three-plus decades of language design
evolution and has seems to just ignore
it so I want to talk about some of the
things that people first criticize about
go before I talk about the design
decisions as listed here in this lovely
curated github case schema go is not
good you get the same complaints over
and over again to simple lack of
syntactic sugar no generics bad
dependency management stuck in the 70s
or the 80s battered of handling no
unused imports too opinionated to
verbose no ternary operator no macros or
templates okay my breath but I said that
all in one breath and most of people who
haven't really understood go ask
themselves the points or the the title
of my talk which is why so I'm gonna say
why go why why and where have other
languages where other languages have
evolved go looks like it has not it's a
curious anomaly why would a language
even consider itself a 21st century
programming
which with things like this so this was
really my question why it's moving what
in sort of like this opposite direction
and thus this talk is a product of my
quest to find out the why of go and I'd
like to share that journey after
celebrating five years since gos
inception in 2012 one of the creators
Rob Pike said go programming language
was conceived as an answer to some of
the problems we are seeing developing
software infrastructure at Google it was
created and conceived at Google the
computing landscape today is almost
unrelated to the environment in which
the language is being used mostly C++
Java and Python had been created the
problems introduced by multi-core
processors networked systems massive
computation clusters and the web
programming model were being worked
around rather than addressed head-on
moreover the scale has changed
today's servers compromised tens of
millions of lines of code and are worked
on by hundreds or even thousands of
programmers and are updated bitterly
every day to make matters worse bill
time has stretched to many minutes even
hours on large compilation clusters I
can probably read that entire article
and it's in it from here and make that
my talk but I do want to visit some of
these statements and delve into them
more fully chronologically and
thematically chronologically I want to
start from gos creation and move forward
and backward from this point to
understand what was present at the turn
of the century and move forward and
backward and with this timeline I'd also
like to organize things into three
broader themes software and languages
and associated tooling Hardware Multi
multi core processors
and threads and green hoods we're gonna
talk all about that and then context
which means events industry social
historical because one of the things I
asked myself to answer this why ago was
recognizing time place context and
people because humans write languages
and code and they don't do it in a
vacuum so let's explore this people from
1980 so that's pixelated 8-bit Robert
Griesemer Rob Pike and Ken Thompson it
was conceived it late 2007 at Google by
these three people and this if you know
who these three people are this is a
long legacy I want you to think about
for your programming career whether
that's two years or ten years or coming
on 20 years think about in the past I
mean think that you've built or done and
and wish maybe you could go back knowing
what you know now because between these
three they have built or haven't had a
hand in much well with what we
personally use every day I couldn't even
fit it on this timeline because it's
it's I yeah so Ken Thompson wrote at
Bell Labs UNIX what would be UNIX in the
1960s and then on like a summer off he
went to go write bsd he also then helps
Dennis Ritchie
write C and then he and raw pie catalogs
write utf-8 there's more as well this is
the legacy it's kind of hard to see but
this is the legacy of starting from the
pdp-7 operating system the first version
of unix and beyond right and that is ken
thompson and his legacy so to continue
we also have Rob Pike who wrote plan
nine which will take a prominent place
and go the operating system and we have
Robert gray Simar who worked on and was
one of the primary architects of the
hotspot JVM and that
important to know right now I'm going to
talk about that and the relevance of
that and a little bit later but I think
I'll go as being a product of these
things that were continuances out of
these bodies of work of these three men
and perhaps a product what I think go is
is like maybe a product that that fixes
the things that maybe haunted them right
a product that remedies the shortcomings
that they could only see but see in
hindsight and what I'm noticing is that
or at least have an inkling of is that
they're not interested in revolution
they're interested in simplicity so I've
talked about people and who's let's talk
about the actual technical limitations
around 2007 and then what go talk about
the historical contexts around the
decade prior to that and then talk about
what go did and its approach to the
language design design to try and see if
they can solve it so the the things that
are 21st century about go a language
often accused from coming from 1980s are
these things in my opinion so
concurrency distributed systems garbage
collection memory but especially memory
locality and readability so I'm going to
talk about each one of these and try to
give you a little bit of context in
history first massive concurrency
efficient support support for massive
massively concurrent programs so 10 to
the 6th green threads which ingo
parlance is called go routines
that's quite manageable or go but why
green threads and why massive
concurrency of all the problems out
there wide of these three individuals
choose that and in order to understand
why the creative creators of go chose
green Fez is one of the first-class
features of the language I had to
understand concurrency primitives so
that means that I understand threads and
events and finally in green threads at
the beginning of the 26 21st century so
green threads really quick before I get
started the try line for those of you
don't know green threads are the user
level threads so they're scheduled at
like as an ordinary user level process
and not by
the colonel and green thread memory is
allocated from the heap rather than the
stack created for it by the OS so and go
there know is known as go routines and I
have it oh I have it here so there's go
in 2007 and then we have C++ at Google
around the mid-early odds getting
efficient concurrency at scale was
important especially for servers
Google's experience with C++ in 2005 was
awful they couldn't afford one thread
per connection and so they had to use
these callbacks and event dispatchers
and it was leading to this horribly
inverted style of programming and with
go routines you could just write a
sequence of statements in what the
logical order and so there's a lot of
history behind behind the go routines
that's more nuance than simply just
threads are bad and go routines are good
so 15 years ago we had the C 10k
challenge when basically threads were
terribly expensive
and once a poll which is a scalable i/o
event notification and K Q which is the
BSD equivalent they came around 2004 and
2002 we they replaced the their older
predecessors of Poland select and so a
lot of the efforts shifted from how to
write programs in this event callback
environment and you have these papers
which will put up in the context like
Sita and Java niño and Python twisted
and apache mina but none of those really
caught on they have lots of little
groups pn people committed to doing
whatever it took to master that
technology and learn to think in
whatever the async framework required
but a few other things happened around
that time to dim the newfound promise of
events threads got better hardware got
better now there was some actual
competition so operating system people
had something to aim at previously
threads had been faster than processes
but now the incident so this so the
incentive was wrong but now they had a
clear goal and it turned
that there was a lot of low hanging
fruit to pick so hardware got better
yeah here it is
if you unless you had access to huge
servers big iron like the signee 4 50s
or the e3 500 you didn't actually have
more than one processor right and the
market for workstation CPU is not just
in the Intel realm but MIPS and spark
with single socket socket up until about
2005 and although you can get dual
socket Pentium 2 and Pentium 3 boards
most people were focused on the
gigahertz on the clock game right but
once we have the Pentium 4 with that
hyper threading in 2000 p4 and the core
2 with dual core on a socket and I think
it was 2006 the game changed and
especially changed on the server so in
2007 you could buy eight cores on a dual
socket chassis so now you see the trends
in CPU cores and clock speed and
transistors here
and in the software improvements and I
put it all the way up until the blue dot
ago so the very bottom black is a number
of cores and we're starting to see multi
course and then you sort of see some
other power consumption and Watts the
clocks which is the frequency single for
the single threaded performance and then
last of course is Moore's Law the
transistors so you had multi processing
and many CPUs many tasks at the same
time and we had thread advocates the
thread advocates won back all the ground
that they lost to events and they didn't
necessarily overtake them but the
playing field was a bit more even and
now that servers could easily have four
or eight cores for a few grand all of a
sudden the process model got a second
lease on life
so there's Ruby with mongrel and Python
gonna corn yeah paisa the multi
processing and everyone was back in the
game because for moderate workloads it
turned out that you could just throw
cores at the problem and you got at
least on the web tier near linear
scaling at least for a time but I think
the creators of go saw the writing on
the wall for threads and hardware even
in 2000
seven so you see here we're plateauing
on modern hardware and go routines they
realized even in 2007 that go routines
and greet friends were really going to
be the best possible solution but what
why I keep going back to the why why do
go routines give us the best of both
rules between threads and events and to
me I think that the answer comes from
taking this wider perspective than just
what generates the best graph on a in a
benchmark because focusing on just the
absolute point in time result ignores a
hundred percent of the software
engineering that went into that
benchmark and I'll talk about that in a
little bit but what do I mean by that
okay so let's let's go off on a little
bit of on the event side some programs
that benchmark really well using events
nginx is a good example right it's this
a whole event loop plus state machine
model which works well because HTTP is a
very structured protocol so like you
read the request line read headers read
body write status line write headers
write body and all of the configuration
is declarative in nginx so for this path
matching this pattern apply this
transformation but you notice that
nobody writes their application logic
inside nginx they always put it in front
of their app why why is it nginx an app
server like Tomcat or JBoss the end of
next model will manage mountable for
small groups of dedicated developers
it's just too nerdy for the wider group
of developers imagine being told yeah
ruby is too slow you need to rewrite
your program for nginx but first you
have to download a C compiler and then
you have to build your own state machine
but I happy enough this is what Sol no
js' does - the first learn C part so
nodejs is the event model taken straight
out of e poll and writ large on the
entire JavaScript community in the 21st
century and I think I I go on this
tangent on no des because I think no
Jia's success has lots less to do with
event loops are fast so much as it does
we can use JavaScript everywhere and for
that no GS folks are willing and
prepared to put up with a lot and so one
of the things that they're prepared to
put up with is auditing each bit of code
they write or depend on to make sure
that it doesn't block and I think this
is a good way to bring the discussion
back to go know Deus and other invented
models like twisted and nut Java niño
they're rooted in the idea of called web
callbacks right so just like Windows 3.1
GUI programming and if you can't you so
I get you get a notification and you're
expected to process that as fast a ball
as possible and if you can't the
responsibility for scheduling that
worked to happen later hopefully in
discrete increments that's yours
that's your responsibility and the
penalty for fail is failure is blocking
and latency and it's an unforgiving
programming model and it's inherent in
the design of the IO framework that
you're given so compare that to Java
land the server server let motto is root
model is root hopelessly rooted in the
idea of blocking so IO streams and Java
do have a way of telling you how much
data can be read before they block but
there's no way to wait for more data
without the thread itself sleeping and
periodically checking and when you
compose IO operations with primitives
like this extinct a gzip reader on top
of a bufferedreader on top of a network
reader it requires requires a thread per
connection approach so I explained
before how threads and events are
roughly comparable in terms of
performance and with 64-bit addresses
spaces the thread per connection is
wasteful on paper but in practice not
that bad so where's the clincher for go
I think the go routine argument starts
by by looking at the bigger picture so
it's not about doing efficient IO
through that's a point important but
what the go routines do with that IO the
difference between nginx and the Tomcat
examples and the reason why nginx that
invented web proxies successful in its
Nisha's HTTP proxy is almost functional
in its operation every request arrives
independent of any anything else it's
filtered it's processed and it's
responded to without interaction by any
other requests and that's my PHP remains
so successful so all that cruft about
sessions and cookies and memcache and
databases is the domain of the
application server and it's why threads
seem to be the dominant paradigm here
they have complex state not just a fixed
state machine so essentially you can
make the argument that applications are
the nexus for state management and that
means coordination so in nodejs there is
no coordination because there is no
parallelism at any one time the active
function can mutate whatever it needs
and this is basically how callback
paradigm works the whole program is this
rolling durable we love leaving notes
about work to do later and in threaded
application servers who must be threaded
because of their i/o paradigms
coordination occurs between threads so
that means using thread the thread
coordination primitives so if your
thread wants to take a lock but can't
and the thread has to register its
interest in that lock which is this disk
call and then go to sleep
that's another cyst call that's really
going to be hurting on your performance
and especially if that performance is
going to have to scale out so high so
it's not that having 10 to the 6 threads
is a problem in itself but the
coordination between the 10 to the 6
threads is where the overheads reveal
themselves this call impacts gosh 1980s
a bit so I'm gonna I went I kind of
banged on a little bit about events and
threads and basically wanted to say why
go routine is the best of both worlds I
want to move on to the second technical
thing that I think makes it really good
or go for a 21st century programming
language distributed systems so the
success may be the success from go is
that it is the first language or at
least it certainly started a trend to
produce programs that were
without a runtime and that's not without
its drawbacks
but I think the ability to come compile
or cross-compile as a program as a
single static binary has unlocked so
many deployment and usage scenarios that
were thought too hard or too taxing
since the 90s and I put this little box
over there because so much of the stuff
that you're gonna attend today and
tomorrow and the day after it's gonna be
about this box and I don't want to bang
on about that because you get to know
about that but just know that having a
single static binary can reduce the
complexity where everything else exists
so that's the distributed systems part
and that's certainly an incomplete
answer because containers that have
basically probably put operating system
vendors and distro packages out of
business or they will in the next decade
so the next and the third of the five is
this garbage collecting garbage
collection bounded pause time for GCS
which is crucial for real-time servers
so from everything that I've researched
about go in my Wi-Fi I go and and what I
think makes a 21st century with the
garbage collection is this this idea of
memory management so GC design and go is
aimed at reducing tail latency tail
latency is the thing that blows up
distributed systems right it's it's um
it's not running out of CPU that's not
the thing that blows it up its tail
latency because the Machine being slow
to respond to a request so triggering a
retry storm due to garbage collection
it's no different than slow to respond
because it's overloaded
however monitoring and and understanding
the the ladder overload CPU overload is
almost second nature to every programmer
so it's these 99% I leave agencies that
just come and blow up your application
and Leave No Trace that they're there
and I'm pretty sure that this is what
all the s are used inside Google have
been focused on for a decade because
unpredictable tail latency directly
translates translates to under
utilization and wasted resources so we
look at the work that the primary
engineers working on the GC who their
names are Ric Hudson and Austin Clements
what they're doing
side of the Google sphere of their
experience from their decades running
huge 10 to the 7 machine workloads so
let's talk about the next one we talked
about threads and events go routines we
talked about distributed systems we
talked about garbage collection we'll
talk about the next one which is still a
little bit about garbage collection but
is more specific to memory locality
memory locality in my opinion is way
more important than it was when Java
invented it over or over 20 years ago
because when Java was an interpreted
language the cost of an object reference
was immaterial right so I look at two of
these things how do the JC performance
of go compared to something like Java or
the hotspot JVM and these approaches are
difficult to compare and garbage
collectors because Java offers a
selection of Kjar of garbage collectors
and overall the Java collection and the
Java collectors they're very over the
mature and they're sophisticated and
they've been tuned over the years
so in principle they're excellent I'm
not going to argue that but the downside
is is that the Java language itself puts
a lot of stress on the GC the biggest
problem is is that Java offers no value
pointers or value sorry value types
beyond the built-in int and double so
everything else has to be atom allocated
as a separate object and then pointed to
buyer references and then the GC has to
trace all these references which takes
time and while the collection of the
youngest generation in Java is extremely
fast a global garbage collection can
take quite some time so you have these
specialized jve engineers that make
their living on this very niche area to
tune things to make up for memory
locality go on the other side has
strokes which are inseparable from their
types as values so true value types and
they do and the and the memory layout is
much easier for the GC so go always
performs goes-- performs full GCS but
mostly running in parallel with the
application up until Oh up until last
year I think the GC cycle only required
a stop the world phase they got rid of
that they've got and
right yeah so it's been removed in
versions but go 1/8 and beyond so all of
these numbers and things that I talked
about it does
yes depend a lot on what your
application is doing but overall go
seems to be doing very well with its
newest iteration of the GC so another
problem of Java and memory locality is
the inability to return multiple values
so for that one it often creates a
wrapper object to hold the results and
the JVM can recognize this pattern and
stack allocate the wrapper objects but
it doesn't happen without a lot always
putting increasing GC GC pressure and
JVM so the lack of the custom value
types has ramifications not only for the
garbage collection but also for cache
behavior because that's why there's
serious work on custom value types for
Java for anybody that follows that and
that's going to be the major feature
that's going to be planned for Java 10
I specifically meant mention the hotspot
JVM because Robert Griesemer one of gos
creators helped to build the Java
hotspot virtual machine which was built
on technologies from implementations of
the programming language small talk
names strong talk and he was working on
at the time so again we have this
individual who was one of the architects
of who now maybe has a hindsight like
20/20 of the things that he wishes he
could do differently or that old dodge
if you only knew now what you knew that
or if you only knew then what you knew
now right so this comes to another
famous quote about the making of go and
I just wanted to Segway briefly into
this before I finish memory locality and
what would in terms of what could would
get added to the language and what would
not and this is from Ken Thompson when
the three of us which is Ken and Rob and
Robert got started it was just pure
research and this we all got together
and we decided that we hated C++ and
returning to go we started off with the
idea that all three of us had to be
talked into every feature of the
language so there was no extraneous
garbage put into the language for any
reason so it's not because they didn't
do it because they couldn't it's because
they made a conscious choice not to and
I just wanted to take that let's go back
to memory look
let's look at compact object layout for
go so there's little control of how Java
allocates its objects in memory and and
with C++ you can but then there are
drawbacks like requiring lots of value
copying but the other thing about goes
that there's no object headers and and
that's important again for memory
locality and for performance struct
fields are not indirect um in Java if
object a has an instance of object B
then that's two memory allocations and
then worst locality and so there's finer
control over memory location allocation
and go and this is a small but I think
an important thing
go uses utf-8 because the creators of
utf-8 also are the creators of code but
I should mention that utf-16 uses twice
the space at least on Linux and it
requires transcoding when reading and
writing and I think that's a definitely
a good case to demonstrate the sanity of
utf-8 is a string encoding it makes
sense to at least point to when GoPro
GoPro more programmers never have to ask
what encoding is this in and if you've
programmed in at least C++ or other
languages you've had to at least ask
that question once so what else
lazy initialization of collections so
the zero value of a map or slice and go
is an empty collection it's not a nil
pointer exception waiting to happen so
by contrast Java positively encourages
you to allocate empty collections that
you're never going to use
Kliff click has a good talk he's a
hardware researcher and he has a good
talk about how modern CPUs are basically
memory bound and like how all the cool
things like speculative execution and
branch prediction are all aimed at
queuing up the next cache miss sooner
and so the processor and memory gap and
cache size is limited by the speed of
light so expecting memory to get faster
or cache size to be a function of dollar
spent in fiction so to map up memory
locality I hope that this gives you some
technical points about how go gives
programmers the tools to talk about
memory
efficiently if they need but only if
they need because it's also flexible
because when that level of control is
not required it's not an all-or-nothing
thing like in C++ or in rust so the last
thing I want to talk about for feature
it goes a language for the 21st century
is this emphasis on readability large
organizations have to hire inexperienced
people and I love this Brian Kernighan
quote debugging is twice as hard writing
the code as writing the code in the
first place therefore if you write the
code as cleverly as possible you are by
definition not smart enough to debug it
and that's a pretty smart guy saying
that right the other thing about
readability is that code is read way
more way more than it's written hundreds
of times more than it's ever going to be
written it's written once and then it's
spread over and over and over again so
go simple syntax it brings out a lot of
opinions but let's again look at what's
happening at Google around 20 2007 okay
Google as a company was started in 1999
by 2007 at the time when go was released
it had almost 17,000 employees 88% of
those were engineers and that was only
the beginning
here's where the numbers would be by
2010 24,000 and here's where the numbers
are today sorry it says 2010 I it's a
typo 2017 but today Google has by the
end of 2017 it has almost 76,000
engineers and the majority of these
people sorry
employees but the majority of these
employees is now hovering between 80 and
85 percent there are software engineers
so if you write code with polymorphism
and metaclasses imagine needing to debug
that code maintain that code having to
ramp up to growing that code base which
is growing by millions of lines every
few months there are several points that
I want to make about this
text with readability and the first is
about simplicity simplicity is a topic
that can be very context sensitive I've
seen simple is better be taken very
positively I think everyone in the
screen would agree but I've also seen
that people's retort when it's talking
about go is that it's an insult to
intelligent programmers or you're trying
to commodify programming and create a
situation where our bosses can replace
us at will
and there's probably a whole lot going
on with these statements
it could be culturally specific or inner
portion issues but it's not an uncommon
retort when you are in the NGO community
so there's the set of programmers who
feel intellectually offended that
learning go does not simultaneously mark
them as the apex program or the way that
C++ does I think the best way I've seen
it is like undignified simplicity so in
talking with Dave Cheney my fellow time
traveler out in in preparation for this
talk I was like Dave I've got some
thoughts and want to see my thoughts and
Dave was like I've got thoughts on your
thoughts so I was like I'm gonna use
those thoughts so this is Dave talking
from here you'll ear Dave talk this
afternoon but when I talk with Dave
about readability he gave me the
following thoughts you're not paid to
program
you're not even paid to maintain
somebody else's program really
essentially you're paid to deliver
solutions for the business that you work
for right and I think that this argument
is very successful with people who agree
that there that their careers are
benefited by delivering solutions not by
the lines of code that they write and
there are two more points about this
Dave's argument about like solutions not
code and I think this is brilliant and
I'm not it's not I can't even take
credit it's all Dave so the first point
is that programs which can't be
maintained are gonna be rewritten right
but that's mainly an argument for the
proko advocacy crowd because if you want
to have a career and go write programs
that can be maintained the second point
is about mobility right most of the
people here will be looking at a
programming as a career or have been
programming and
in your career and a very shrewd quote
about promotion and mobility if you
can't be replaced you cannot be promoted
if you're so if you're clever code is so
integral to the company that you can
never risk taking off get being taken
off of that project then sure maybe
you're never going to get fired but
you're also never going to be considered
for a different project or be considered
for promotion and so if one day you do
want to move sideways or up or whatever
within your company without having to
leave you need to make sure that
somebody else can do your job and being
able to maintain a piece of software
starts with being able to read it
so turnover and company switching for
engineers averages in 2017 and over the
last decade 18 to 24 months so the only
guarantee in your company including you
is that you're gonna leave and this is
the reality of working in software
engineering in the 21st century
so in the last 10 years if you've been
in this business for ten years at the
average number of jobs and companies
that we've been at maybe is gonna be
about five for some it's even ten and
and Dave further talked about his
experience about having worked and go
across four organizations during our
talk and about maintaining other
people's code and also knowing I'm going
to write code that I know is going to be
maintained that I have to leave and
others are gonna have to maintain so
this turnover and companies switching
for engineers and it's it's the reality
of working in software engineering in
the 21st century and this is the context
that matters beyond the programming
language itself okay so we've talked
about context and people and some
technical limitations that were
happening in software and hardware
around the time that go was invented but
I think to drive things home we really
need to understand to understand
software engineering right and I'd like
to finish this talk about that
the larger picture at Google and the
larger picture of our industry and how
this is influencing the design of go
by taking this holistic view of things
the first is that how we define software
engineering itself in 2017 and what is
the difference if I were to put it to
you to define for me what is the
difference between software engineering
and programming it's a good question
right and why do we have two words for
these concepts aren't they one of the
same but the best definition that I have
found is tightest winners who maintains
the C++ library is at Google had
standardized all the C++ dialects at
Google so I think he has something quite
interesting to say about it and his
thing was software engineering is
different from programming because it's
programming integrated over time so it's
a programming task is like hey I got my
thing to work right and that's hard but
sometimes the right answer to a problem
is I'm gonna write a program to solve
this and just be done with it
but that's programming engineering is
what happens when the--it things need to
live longer and the influence of time
starts creeping in right and and if
you've worked in this industry for a
long time you understand that right
library versions get updated the
operating system gets deprecated the
language gets resides the book
requirements have changed
you have to ship new features now other
developers are working on the code base
changing services to have different
options after a couple years rollouts
updating new servers updating front ends
complex networks of servers they're now
in the millions
not just to Google but it other tech
behemoths right what else I just listed
a bunch here because I started getting
excited about the idea of engineering
over time but moving to a new team we
already talked about moving to a new
company moving to a new computer your
hard drive dies I mean this happens time
happens things change and so how you
handle that and how you keep your
program working as engineering that is
what it is and and it may bleed into the
programming itself I think that was the
thing that Titus said
but it could also be layered on top and
all this complexity is fundamentally a
different flavor than programming and
it's different than I got it working and
sometimes it's not needed but we don't
when especially when we don't need to
plan for the future but when you aren't
certain and about time when you have to
be prepared this is software engineering
and designing a language for software
engineering the impact of time on a
system so the point is something that
makes sense on the face of it in our
everyday programming turns out to be a
horrible idea when you start to think
about change over time and there are
many things that do make a perfect sense
in this limited domain and sometimes we
do work in a limited domain but it like
in our programming domain but they don't
make sense when we're thinking about it
as engineering and thinking about change
over time and I'm gonna I'll share the
links and I want you to go look at this
this this talk because I think it blew
me away at the core everything that we
think about in software engineering is
it's kind of time time-based
right so think about this version
control you go back in time to
coordinate with your colleagues over
time continuous integration making sure
recent changes haven't broken the system
unit tests making sure your your feature
that you wrote won't be broken in the
future refactoring update something from
the previous time to the present time
design patterns ability to plan for
future changes without knowing what
these changes are going to be and then
of course dependency management so
packages which is the go parlance of
libraries and those that we depend upon
are gonna change so goes holistic
approach
oh absolutely understand this about
software engineering and probably it
reflects the zeitgeist that inform the
original design of go specifically the
focus on sustaining engineering through
readability
so the continuance of many different
engineers over a long period of time
these very clear module
aimed at keeping import dependencies
between packages linear thus keeping
compiles times down is everything that I
think was on the minds of the three
creators of go so I'd like to close with
talking about one less thing which I
call simplicity and the greater good
simplicity again as I said before it's
often seen negatively but in the context
of order sustainability group cohesion
it's a benefit and it's imperative that
in some aspects of the organization and
simplicity needs to be enforced
oops an example is road signs and Road
rules the number of vehicular deaths
when cars were first mass-produced after
Ford introduced dangers through line
relative to the population was extremely
high and authorities and government
officials had to figure out how to fix
these fatalities because cars we weren't
gonna take put people back inward in
horses and buggies so they started to
put come up with these rules they
started to impose limits rules that
everyone had to follow right so in the
u.s. you have to drive on the right side
of the road you have to stop at the red
light you have to go at green you have
to follow the speed limit you have to
yield and imagine if someone in the name
of imposition of freedom or creativity
or my rights decided that they just
wanted to drive on the left side of the
road like they do in the UK they they
would probably cause damage and maybe
even loot kill people lives have to get
lost so there are systems sometimes when
imposing limits can afford us all the
ability to use it efficiently and also
safely and imposing limits like this
makes things possible and it's exactly
what voted right and it's evolved and it
lets you evolve to the place to the
point where anything that needs to be
changed can be changed this is
sustainability and if you feel like this
is very top-down you're right because
NGO is first and foremost a language
meant for this context Rob Pike says NGO
is
not an academic language it's meant to
be used in the big crowded place with
76,000 engineers in 2017 where digital
traffic laws and street signs are needed
so I give you this quote which um gosh
am I like a real program right now I'm
using Dijkstra um
simplicity is a great I think everyone
has probably heard this and I I think I
you could you know say it every morning
to yourself as your mantra simplicity is
a great virtue but it requires hard work
to achieve an education to appreciate
and to make matters worse complexity
sells better so go doesn't have a lot of
things in the language as you saw before
but simplicity is ultimately reductive
you can't add more things to make things
more simple right you can't add rappers
and super rappers and libraries it's got
you just there's got to be a point where
you do a redo and you purposely decide
to make it small so if someone had come
up with go 20 years ago it wouldn't have
survived nor would have been adopted
there is no pretense that go is going to
be the end-all be-all but for a pretty
big set of the problems that we needed
to solve today it does a good job and
these are the problems that weren't
there 20 years ago nor are they going to
be there in 20 years from now and this
is the reason why NGO is popular today
these are the conditions that make go
useful so given what I've told you my
challenge to you is to watch these
conditions for today and see them change
because it will allow you to predict the
ascent of the new the next new things
and that that may surprise you thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>