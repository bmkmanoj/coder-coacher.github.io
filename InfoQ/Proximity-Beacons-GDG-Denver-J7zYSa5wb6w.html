<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Proximity Beacons - GDG Denver | Coder Coacher - Coaching Coders</title><meta content="Proximity Beacons - GDG Denver - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Proximity Beacons - GDG Denver</b></h2><h5 class="post__date">2015-11-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/J7zYSa5wb6w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today I am here to talk to you guys
about beacons and more specifically
we're going to talk about Google's
beacon api's and some of the some of the
features and functionality that they
provided to sort of enhance beacon
applications just quick show of hands
how many of you have played around with
some kind of beacon before okay about
half of you or so so just shout out a
couple of things when you think of vegan
is what comes to your mind this look a
web okay sorry kendry clear text okay
okay bluetooth proximity okay so in your
mind how would you define a beacon what
is it be gay go ahead okay okay anybody
else okay those are all pretty good
descriptions there the way that I would
characterize a beacon at least for the
purposes of this discussion here is a
vegan is a device that is typically
Bluetooth enabled it doesn't have to be
but everything we're going to be talking
about here uses Bluetooth specifically
Bluetooth low-energy beacons are devices
that advertise something doesn't
necessarily matter what that thing is
and in fact different beacons advertise
different things but all beacons are
advertising some piece of information
out to the world all the time okay and
those are devices that other than what
they're shouting out in broadcasting you
really have no ability to interact with
them or connect to them or anything like
that they're basically a giant mouth
with no ears okay and again typically
they're going to be using Bluetooth Low
Energy now that's important for a couple
reasons the first is that bluetooth low
energy is by definition because it's
supposed to be low power very low
bandwidth which means that it's
specifically in the case of be
the amount of data that these beacons
can transmit is very small it's
essentially 31 bites at a time and as I
mentioned typically a beacon is only
going to advertise one type of thing now
then there are some special cases we'll
talk about where they may interleave
between different one or two different
things but generally speaking you've got
31 bytes of data to represent what that
beacon is supposed to say to the world
that's not a lot okay and that
characterizes some of the things that
we're going to talk about today and why
these things exist in the first place
okay so I'm going to talk to you about
two specific elements today I'm going to
talk about Google's proximity beacon API
and then we're going to talk a little
bit about the nearby messages API has
anybody heard of either of those things
before you've just heard of them okay
couple folks so it's going to be a
little bit mostly new so that's good so
we'll jump right in the first piece that
I want to describe two is the proximity
beacon API this is a back-end service
that is provided by google for free as
long as you have a google account and
you can get into the google developer
console and all of those pieces there
this is a back-end API that is provided
to you by google as an assistance to
allow you to better manage and more
easily deploy your beacon fleets into
the field okay this is not hardware this
is not even necessarily clients like
software this is all the web service
okay it's a backhand web service that
exists only for the purposes of allowing
you to make to address the issues
associated with managing tons and tons
of beacons out of the world right you
think of most beacon applications these
are typically these little single
devices like the one I have in my hand
here in some cases you could turn your
mobile device into a beacon or maybe
even a desktop but a lot of times
beacons look kind of like this right so
and we can have hundreds or thousands of
these out associated with whatever our
application is maybe it's a an indoor
location based application or an
application where beacons denote
individual retail stores and a
distribution or whatever the case may be
you could have tons of these things out
representing whatever your application
is and on its face this little thing
doesn't help you a whole lot and even
the beacon manufacturers don't
necessarily provide you with a whole lot
of services to make the deployment and
the managing of that appointment easier
that's where the proximity beacon API
comes in most people who have done
large-scale beacon deployments of some
kind have had to write most of this
themselves before Google came along so
the idea is they're giving you something
that you probably would have otherwise
written yourself but now it's going to
be given to you for free so you can use
it using Google's backend so the
proximity beacon API provides really
three primary pieces of functionality to
you to help you deploy and manage your
fleet it helps you provision beacons
which is probably the most common thing
that most people would have to write
themselves for large-scale deployments
it also helps you with Diagnostics which
is a less common use case but still
extremely helpful and in my opinion
probably the most interesting one is
they allow you to attach additional
metadata to a beacon okay now again I
mentioned that these beacons don't have
a lot to say and they don't have a lot
of space to say it in so in order to
make beacons a little bit more useful
google has come up with a way to try and
allow you to provide additional data
additional context associated with this
tiny little device okay so let's talk
about that piece first so one of the
nice things about the beacon API is
Google does not lock you in to a
particular beacon tight those of you who
are familiar with beacons you're
probably familiar with the fact that
Google has their own beacon format
called the Eddystone corner but that's
not the only one out there Apple has I
beacon and those are probably the two
most popular but there's also a fairly
popular standard called the all vegan
which was developed by radius networks
which is a company that manufactures
beacons just like the one I haven't
so all of these standards have existed
for a fairly long time eddystone has
only been around for a few months but
the others for several years okay and
Google is not locking you in to their
format just because you want to use
Google's API it doesn't mean you're
going to need to buy Google beacons you
can if you already have ibeacons in the
field you're already using all beacons
or something else along those lines
those will work with this API all of
those are supported okay now if you
don't already have beacons deployed and
you're sort of starting fresh I would
recommend to you that the one you choose
is any stone and as we go through this
all kind of give you a couple reasons as
to why that is I'm not going to talk to
specifically about those formats I'll
give you some links to resources at the
end where you can learn more about the
individual beacons themselves I've got
videos from talks I've given previously
about that specific case we're going to
talk more about the api's here today so
as I mentioned what I think is probably
one of the most interesting use cases of
the beacon API is this ability to attach
additional metadata to a beacon okay so
walk through the typical use case for
just a minute here this beacon is
sitting somewhere out in the world could
be a bus stop could be here in this room
maybe our soda machine who knows wrap of
clothing even and this device is just
advertising and identifiers it's a
unique identifier the actual makeup of
that depends on the beacon format but
you know as I said you can only put
about 31 bytes in here so they're
they're typically 128 bit unique
identifiers of some kind okay it's just
a number and it's just spewing that out
into the world and every single beacon
that you own is spewing out a different
number so if you want to use that
information in a client application
running on mobile device then you have a
couple options the most common is your
mobile device is going to be scanning
for these packets that are being
advertised out in the world as the users
walking around whatever that physical
spaces and it's able to pick up what
those identifiers are and in a simple
application you might be able to just
hard code all those identifiers in your
app I'm not sure I've ever met
that but you could do it right so in the
simplest case you could say this beacon
which is identifier 12 is the front door
and identifier 15 is back door and you
know start so on and so forth you could
upload that information to a server
somewhere and identify that at any given
time this beacon identifier 12 is the
front door but it may be some point
later you want to reconfigure the server
and at that point this application has
to be able to read that identifier
upload it to the server and figure out
based on that what that beacon actually
represents okay that's a more common use
case and that's essentially what we're
given with the proximity beacon API but
what they give us is a very flexible
model into which we can put that
information ok so the beacon API has two
primary data structures that really make
up the majority of what we're doing here
the first is the beacon data structure
right and a beacon is comprised of an
advertised ID location stability some
properties and actually a description is
it another I didn't put in there as well
the advertised ID is the property that
represents the number coming off of this
thing ok so every every single one of
these beacons is tied to this advertised
ID to tie it to a specific piece of
hardware sitting on something in the
real world and that advertised ID has
that actual numeric value whatever it is
and the beacon type whether it's Eddie
stone I beacon or alt beacon ok so
that's sort of the key representing that
information to tie it back to the
physical world but then we've got all
these other elements in here we can
apply a Lincoln's location and that can
take a number of different forms it
could be just a lot long value of the
the address or wherever this particular
beacon is installed if you're doing
indoor location of any kind they have a
property for level so is it on the
ground floor is on the top floor you
know so you can do some more indoor
location mapping based on that
information and if you're familiar with
or are using the Google Places API you
can attach a places ID to a particular
beacon as well so where I'm going to go
into the places
you guys specifically but it's an
optional feature that if you're already
doing that to map out and bring in
client site to your application all
these different locations that you may
have you can tie those two beacons very
quickly by just attaching that places ID
to the beacon in the backend API okay
stability value is associated with how
mobile is this thing should it be static
is it on a car or something that is
constantly moving or is it somewhere in
between and you'll see this is an
optional value as well but you'll see
when we get to Diagnostics how there are
some interesting things that the beacon
API can do based on that information
okay so knowing where a beacon should be
by its lat long value and whether or not
it should always be there like with the
stability value of fixed allows us to do
some interesting monitoring a little bit
later on okay so you have the stability
value and then this idea of properties
properties is just key value data you
can attach whatever the heck you want to
this beacon it's just sort of basic keys
and values so it could be contextual
information that's specific to your
application what room are you in you
know we already have what floor you know
what maybe what's the address of where
you are anything else that's specific to
your application that you want to
associate with that beacon properties
are the simplest way to do that because
it's just key value dated okay so those
things make up that beacon data
structure and one of the important
things to remember one of the great
things about this API is that the beacon
well it has an advertised ID associated
with it the two are not the same thing
and the important thing there is that
we're sort of divorcing the idea of this
piece of hardware from what it
represents so we have this advertised ID
being the thing that's stuck on you know
stuck on the physical element but the
rest of the content declares what this
thing actually is and why that's good is
what happens when this thing blows up
maybe somebody gets it a little too hot
lets the smoke out of the chip and it's
not coming back right so we have to go
out and we have to replace a new beacon
on that same element by divorcing the
beacons roll from the advertised ID you
can use the API to essentially say okay
this ID is now associated with this
beacon okay it's not quite as
straightforward as all that but the API
gives you the steps to be able to do
that so you can accomplish that by
saying this is what the beacon should be
this is its role and this is the piece
of hardware currently they're
advertising that content and they can be
married together or divorced apart the
other piece is an attachment and this is
going to be a little bit more
interesting for what we're talking later
on this is just a blob of data be
whenever you want it to be it's defined
by just a name type and this blog and
this blob when you actually upload it is
just a sta 64 encoded blob with whatever
could be binary data textual data for
whatever you want could be an image the
only thing about this and they don't
explicitly declare this in the
documentation but through you know
conversations and some of Google's
videos the basic idea here is that
attachments probably should not exceed
about 1k so it's not a ton of data but
it sure beats 31 bites okay an
attachment is then associated with a
particular beacon beacons can have as
many attachments as you would like to
include so a single beacon can be
associated with one attachment two
attachments ten hundred whatever okay
whatever suits your application the idea
being that when a beacon is observed in
the field this API gives you the avail
the availability to tell the API which
beacon you observe and have it returned
back to you here's all the attachments
associated with that beacon here's some
data you can actually use and this
beacon tomorrow changes to be a
different radio with a different ID
alright the client side is going to get
the same data because it's looking at
the attachments it's looking at the
metadata not the actual hardware in
itself okay so attachments are going to
be really interesting because that's the
piece of data that's going to map
directly to the client side when we talk
about nearby a little bit later on okay
so attachments are pretty cool
in addition to attaching this additional
data the beacon API also provides
provisioning functionality so at some
point you have to be able to tell Google
about this beacon so you have to
register it with the API and at some
point as I mentioned you may get to the
point where this hardware is no longer
usable the radio doesn't work or it
broke carven over at something like that
and this beacon can't be in service
anymore and at that point you would need
to decommission it so registration and
decommissioning are one-time operations
where you bring it into service and then
when it's no longer usable you take it
away that's important to realize because
you can't bring something back from
being decommissioned so just because you
don't need it doesn't mean you want to
decommission it because you won't be
able to use it again that ID is used
forever it's gone forever and it can't
be resurrected the proximity beacon API
keeps track of every advertised ID and
they all have to be unique so this
beacon ID is currently registered to my
application that i'm going to show you
as a demo if you were to try and take
this beacon ID and register it with your
application it would not work because
this instance already exists in the
whole of the proximity beacon API right
so that's why it's important not to
decommission things that you may
actually need because you're not going
to be able to get it back if you want to
take beacons or the thing that the
beacon is attached to into a rout of
service you can use the activate and
deactivate functionality to do that so
when a vegan is registered it's
registered into the active state this is
a beacon that should be observable in
the world when you query for it it
should get returned all that stuff but
if let's say you put the beacon on a
service truck and that truck is in for
maintenance or something like that you
can deactivate the beacon temporarily
while it was out of service and then
when it goes back out into the world you
can reactivate it again so that
functionality allows you to go back and
forth as needed as opposed to
decommission which is a one-shot
operation okay so all this functionality
is provided to you simply so that you
can bring these pieces of hardware into
a system where you can manage them okay
and as I mentioned this is this is the
sort of thing that most beacon
implementers have written themselves at
least once
okay so this is the piece that you
probably will need regardless of whether
you use the other foot features and
functionality or not for some
large-scale deployment okay all right
and then the last piece of the API is
Diagnostics Oh Diagnostics this is a
this part of the API it still has this
training pants on so the proximity
beacon API technically is still in beta
if you look at the documentation there
are current version is beta 1 and they
are iterating on this to make it you
know change it make it better so
everything I'm telling you at least in
terms of the actual endpoints and
function calls could potentially change
in the future diagnostics is one of
those cases where we know what it's
going to do it just doesn't do any of
that stuff yet so some of the stuff I'm
going to tell you might be interesting
to you but if you run out and try and do
this tomorrow most of it's not going to
work okay but it's interesting to know
what's going to be available to you and
potentially where they might take it
from there so the Diagnostics
functionality allows beacons that are
able to report telemetry metrics from
the device so those are metrics like
battery level temperature how long has
the thing been up since it was reset the
last time basic information like that
all of that information can be brought
up when these beacons are observed into
the API and the backend API on the
diagnostic side is meant to allow you to
generate reports off that information
and get alerts from that information so
things like battery level would be
interesting to know how long is it
supposed to be before the battery and
this beacon dies if it's battery-powered
am I going to have to go out and replace
the battery in it before it stops
transmitting and users can't actually
interact with that thing so part of the
diagnostic API is to analyze battery
values as they come in and then
determine from that information what is
the estimated time left before the
battery is going to die and the
Diagnostics will report that back to you
so that at any given time you could look
at a report and say oh we've got three
or four
need to go out and be replaced in the
field okay that's the only metric that
they let you reap right now hopefully
you'll see alerts like that on some of
those other values i mentioned but right
now it's just battery the other alert
that's currently in there has to do with
location so as part of the observation
of beacons and the uploading of that
data back to the proximity beacon API
beacons that have a location and are
intended to stay at that location can be
analyzed by the proximity beacon API so
as part of the beacon API when a mobile
device like this observes a beacon and
uploads that information to up to the
server it will not only tell it what
beacon is found it will tell the server
where it is right now so here's my
location when I observe this beacon and
if that doesn't match the location where
that beacon is supposed to be and that
beacon is supposed to not move then that
will also generate an alert that you can
view using the Diagnostics API so you
can get some idea was this thing stolen
and if so maybe where it was or
something like that you can get some
information or out this thing we know
where it is but it's not what's supposed
to be so that information you can get
from here as well now interesting point
about diagnostics all of the data
necessary to make diagnostics work only
come off of the Eddystone format
eddystone beacons are the only beacons
that support this telemetry data in a
packet frame that is advertised off this
device so all the beacons that I have
around the room are eddystone beacon so
in addition to advertising this
identifier I've been talking about
they're also advertising in between each
of those packets current battery level
current temperature and all that stuff
that packet format doesn't exist in the
other beacons ibeacons and all beacons
so if you are using those beacons in
this deployment the entire diagnostics
API will give you nothing ok so this is
this is one of the reasons why if you
have a choice and he stone is probably a
good choice because you'll get some of
these additional features for free
alright so that's the server side we've
got all this functionality provided by
google that allows us to provision
beacons as well as attach all this also
metadata to it so that our beacons can
actually be more useful than just these
tiny little numbers we have to try and
decipher the client side okay we can now
push that back to a server and simplify
the client side software significantly
absolutely so the question was do beacon
IDs have to be unique and if so what
would stop someone from basically
jumping in ahead of the curve answered
nothing i mean the the way that these
beacon identifiers are constructed
depends a little bit on the format but
at the end of the day every single
format has at least all or part of it
dedicated to a unique identifier that is
specific to an application so target or
kmart or whomever should have a single
identifier for their application that
they're using and then the remainder of
that ID is unique to the individual
instance right so it's very much the
case that if you want specifically with
proximity beacon API if you want to use
this API it would be best to register
you know basically everything that fits
into your applications namespace if you
will because you're right if someone
else beats you to it you can't use that
beacon ad anymore you would have to
basically choose a different ID for the
piece of hardware that's already been
used and go off that instead there's
another question no actually so the
question was do they come from google
these numbers are there really defined
by you so depending on where you get
your hardware from most beacon
manufacturers will burn in a unique ID
for
you but the the traditional beacon
formats primarily ibeacon and Eddie
stone to find the standard in such a way
that they tell you how to make up your
own and ideally even though the
manufacturers make one up for you you
should make up your own and program it
into the bacon so it's not it's not like
i like i can go register my ID with
google so no one else goes and gets it
but the idea is they're designed to be
unique such that mine will collide with
yours unless we intentionally did that
for some reason yes that I intentionally
geez hardware deployment someone else's
so I see what your fiance is an
achievement of that it's like as easily
said what you wanted to say sure so I
think the question is basically could
you intercept another beacons
transmission by duplicating it in
something could i just am sure the short
answer is yes but at least if they're
within the same proximity you can't
somehow cause your signal to overwrite
there's so yes i could I mean it's very
straightforward to walk around I you
know I can download any often placed or
that scans Bluetooth and I can pick up
exactly what the advertised ideas off
our of all these different devices that
hasn't walked around so I can figure
that out programming into my beacon and
have it transmit the exact same
information however that doesn't stop
that device from continuing to transmit
so while I could I could take what
they're doing and maybe modify it a
little bit now a client who's in
proximity of these beacons is seeing two
transmissions instead of one and ideally
if you're able to guess what another ID
might be then you might be able to fake
it out a little bit but these all these
identifies don't really have any
identifiable information in them from an
application perspective they're just
numbers so at best you could broadcast
the same number as the one used you were
stealing from or pick up another number
and hope that that was used by something
else and try and confuse the application
so on the client side you might be able
to defend against that just by having
some understanding of where these
you can shoot me so that if something
like that happens you say well i got
this identifier for that beacon is way
out on the field then okay that's
probably not real or something is no
joke so if there's school then yeah
video you should never have more than
one in close proximity or whatever your
application but yeah there's nothing
precluding someone from understanding
what the beacon is advertising and
duplicating or trying to modify the
question is what does the client
application do with that happens and
that's okay so let's move now to you
talking about the client side so we've
got these beacons they're out in the
world and we've registered all this cool
and information with the proximity
beacon API so then all these beacons are
more than just a number now they've got
all this cool metadata associated with
it how do we see that information in the
application on mobile device in this
case in the emirate device this is where
near my messages comes now truth be told
you could do everything I'm about to
tell you with the proximity beacon API
directly I could use API calls just like
I would for the provisioning and
management to declare to the API here's
a beacon that I observed give me all the
attachments and all the additional data
you know that functionality exists in
the API I wouldn't necessarily recommend
doing it just cuz it's a lot of steps
there's no client-side library for this
or anything like that so you'd be
writing all those codes with raw rest
HTTP type stuff okay not impossible but
not everybody's favorite things for
their time doing either okay nearby
messages allows you to simplify that
greatly on the client side ok now I'm
nearby messages specifically actually
covers a larger range it's a it's a
google play services API that is
responsible for allowing two devices
that are in close proximity to transfer
messages back and forth and quickly
communicate so maybe to android devices
or an android device and an iOS device
if they're in close proximity you can
publish a message to another device okay
that's the core of what this API is
supposed to do what they've done is
they've brought vegans underneath that
and allows a beacon to be a type of
device publishing a message
you can use the same API to just accept
those messages as if it were coming from
another Android device or something like
that so it's just a subset of the larger
nearby messages just happens to be the
piece we're focusing on so the use case
here is your mobile device at some point
is going to come into proximity of one
of these beacons okay probably this is
happening over bluetooth so you know at
least in what we're discussing here and
so the mobile device is going to
recognize that it sees this beacon its
scanning for the signal it sees the
advertisement and it can pull out that
unique ID I got the number great now
what what nearby messages does for you
under the hood is when that vegan is
detected it will upload it to the
proximity beacon API and say I've
observed a vegan as well as all that
additional metadata like the current
location and other things that make that
API truly useful things that are
optional but if you don't do it all it
doesn't necessarily work to your
advantage okay so nearby messages does
all the work of communicating with the
API declaring that I've observed this
beacon ok then the beacon will return
sorry the API will return back to the
device attachments just like I described
to you before what is a little bit
different with nearby messages is that
they actually transform the data a
little bit on the client side you don't
see an attachment you see messages but a
message an attachment are essentially
the same thing ok and I'll show you in
just a minute how the data Maps across
but effectively what happens is
automatically all you have to do in your
client-side application is declare that
you want to use nearby messages and
declare when you want to be listening
for those messages and then anytime your
device walks past the beacon that is
registered to you you'll just see those
attachments cover all the other steps
and moving parts underneath it all ok so
it simplifies your code tough yes
that good question so the connection to
the cloud what radio is that using that
that's a network connection so you know
cell radio if it's active Wi-Fi whatever
it's going to remote server good
question ok so in oh before I get there
the other nice thing about nearby
messages is that it's cross-platform
right the predominance of AP is that are
in Google Play services are supported on
both iOS and Android and nearby messages
is no exception so by using the
proximity beacon API and the nearby
messages ap is you can you can build out
your beacon deployment and not have to
worry about it being Android specific or
or only working on iOS it will work on
both platforms using the google
libraries even though they're produced
by rupe ok so don't just think it
because it's google it's only a work on
Android Play services works on both and
you're my msgs works on both ok now
having said that eddystone happens to be
one of the only formats that works
seamlessly of both across both platforms
this is a little bit ironic but I Deacon
doesn't work well on happen it turns out
that because of the way they built the
ibeacon api's ibeacon devices don't show
up through the Bluetooth api's they show
up for the location API and when you try
to put play services on top of that it's
not able to pick up I vegans the same
way it can other types of beacons
because Apple is treating them special
and it turns out that screws up by
vegans ability to work well through
nearby messages only on iOS I bacons
work great on Android using nearby
messages sit on that one for a while so
again if you have a choice eddystone is
a better choice because especially in
the cross-platform case if you're using
this on client side this is going to
work perfectly seamlessly with this
whole mechanism on both platforms ok all
right so how does it fit everything
together well I'll show you an example
here in just a minute but the basic idea
here is that you're going to have a
Google developer console project setup
that these api's are going to attach to
and there's two AP is that you need to
enable the first is the beacon API and
the second is the nearby messages API
both of these api's have to be enabled
on the same project and that allows
Google to know when you are
communicating from the client side using
nearby messages which beacons are yours
and they do that because those are
married together in the same project ok
so that always has to be the case and
that way the client side can use nearby
on your server side you're using the
beacon API and under the hood they know
that the two are the same ok so your
beacons have to be registered against an
API using API credentials that are in
the same project as the API credentials
you're using on the nearby side and I'll
show you that as an example in just a
minute and like make that a little bit
more clear if it's fuzzy at the moment
the other thing as i mentioned that
nearby does if it transforms the data so
that name type and data that are in the
actual attachment when you're working
with the API on the client side they get
transformed into a type and content on a
message other than excuse me other than
the name changing exactly the same data
ok so you're not going to see an
attachment anywhere in the Android code
or in the iOS code they're going to be
called messages but the data is from the
attachments that you originally created
when you provision these things in the
API ok it's a little bit of semantics
but everything's still the same ok
nearby messages is an API actually
nearby in general is an API that
requires user permission now this is
this is not quite the same thing if you
are Android developers is not the same
thing as runtime permissions in six
point 0 vs the old permissions model
it's this is done by Play services and
it's going to happen on any version of
Android ok this is a an API that because
in in the general case it can use any
number of radios to do its job it could
be fairly power inefficient so they
don't allow you to invoke the API
the user has granted you permission to
do so so there is an explicit dialog
shown by Play services that the user has
to agree to before you can invoke any of
the nearby api's device it's a fairly
simple thing to do you just call request
permission and neither says yes you
already have it or we're going to show
the dialogue and will tell you the
result later you know same as any other
permissions request but this has to
happen ahead of time or it will fail any
time you try to access any of you guys
this user has some grant permission
first after that the the code involved
in actually subscribing to that API is a
ton right what is that four lines all
you have to do is invoke the nearby
messages API and say you want to
subscribe to the messages associated
with that the only thing that is beacon
specific here is the fact that we are
indicating that we only care about
messages that come from Bluetooth le
devices everything else is done
magically by those API console projects
that I just described it already knows
which beacons you're interested in
because they're registered with your
beacon API that's tied to the API key
you're using ok so the credentials
govern all of those pieces you don't
have to declare specifically these are
the beacon types or these are the
namespace IDs or anything like that
that's all managed in the beacon API and
as long as those credentials are set up
to marry to the right a the right
proximity beacon API then you'll just
start to see that stuff come down to the
device ok so in this subscribe method
the one piece of information that's
interesting is you pass a callback
called a message listener and the
message listener is where those messages
will be delivered to you as your device
moved into or out of proximity with the
different beacons ok so you can
subscribe to this and as long as you are
subscribed beacon messages from the
beacons that are near those devices are
going to be pushed down to the device
and you can react to them ok and I'll
show you that code here in just a second
but one thing that I want to point out
unfortunately is that nearby messages
does
not work in the background you cannot
attach this to a service on Android or
some other API that would allow this to
run while the applications background it
just doesn't work ok they explicitly
disabled that because at least for now
the way they've implemented this using
the radio to scan and connecting to the
API and all that is fairly power
inefficient so they only want you to use
this when the user is actively engaging
with the application that is scanning ok
so if you want to marry this with doing
something in the background I'll show
you an example of how you can kind of do
that but you have to go outside nearby
messages a little bit to make that work
there questions yes that's just the
question was is that the same for all
beacon types it has to do with using
nearby messages not any specific weekend
yeah so that is a downside now I have
heard that they're not happy with this
and they would like to make it better
that doesn't scream to me any recent
timeline or anything like that so I know
they want to fix that but I have no
delusions about the fact that it's
happening anytime soon ok so if you need
background scanning in your beacon
application and most of us do at some
level you have to kind of work around
that a little bit and I'll show you I'm
gonna be able to go through all the code
but i'll show you a basic example or
where to find one of how you can kind of
marry the two together ok all right so
then on the call back side the message
listener looks like this it's fairly
simple right you have to call backs
found lost messages are found when the
proximity beacon moves into proximity
with the device and at some time later
if you walk away from the beacon and it
recognizes that it's no longer there
you'll get a call it it's lost fairly
simple to implement not a lot going on
you these messages in both of those
callbacks are the elements that contain
the attachments from your beacons so
notice that the callbacks you're getting
on the client side never actually see
anything associated with this piece of
hardware that's all happening under the
hood I have no way of asking for the
advertised ID of this beacon that's all
going on inside your messages instead
what I get is the attachments associated
with that
which is what my application should be
designed to use to interact with
whatever that real thing in the in the
world is make sense okay yes see I know
so question was can you do any ranging
with the API know you'll have to you
have to go direct into the ble api's to
get transmitted power and stuff like
that so that sort of thing good question
ok now just another side now for those
of you who are Android developers these
callbacks don't happen on the main
threat don't ask me why they just don't
ok so the only reason that's important
is if for some reason you want to try
and manipulate the UI from these calls
based on the data coming in from the
beacons you can't do that right you have
to post it to the main thread using a
handler or whatever other mechanism you
want to use to do that you can't touch
the UI from these callbacks these
callbacks are in the background using
some IPC stuff and you have to get back
on the main thread to do that sort of
thing ok so just tip there all right so
a couple things before I run into a
quick demo other pieces of information
if you want to learn more api
documentation for the beacon API as well
as nearby messages i have done a blog
series on the proximity beacon API that
basically covers the same information
that I've been talking about you here
today so if you would like to read about
it rather than listen to it you can look
through the blog series that we have on
our site new circle com you can find it
directly by going to the beacons tag or
if you just go to our stream which is
our blog it's just new circle calm /s
there's a big old banner at the top for
the proximity beacon series and all that
part of that series is a screencast
video I did from a previous talk that
describes the beacon formats themselves
so if you're more interested in how is
any stone different from I beacon and
how does that tie into this thing called
the physical web and all these other
things that we mentioned but didn't
really go into there's a video that we
can watch it goes through some of that
stuff as well and then sample code all
my sample code for all my things that I
right you can find at mile high android
com and the two examples that I'm going
to walk you through here tonight are
also up there as well ok questions
before I go on to the devil ok so quick
mile high Android that's where you can
see on my sample code I won't have time
to go through the actual code but this
is nearby vegans and this proximity
manager those are the two applications
i'm going to show you right now ok so
you can go here you can look at the code
you can see how they work pretty
straightforward all you have to do to
get them up and running is create your
own dev console project with the beacon
API and nearby messages ok so as I
mentioned before if you've never seen
the developer console before this is
what it looks like but you just you sign
into this console consult at
developers.google.com create a new
project and one of the blog posts that I
have in that series show you can walk
you through creating a new project if
you never done that before go into that
project and the two api's you need to
enable our proximity beacon and nearby
messages ok just excuse me just flip
those switches and you're pretty much
ready to go so I mentioned that both of
those have to be enabled on the same
project the only other thing you need is
a pair of credentials and you'll need to
credentials and OAuth client ID which is
what you will use for the to interact
with the beacon API directly so whatever
your management console is to provision
and register and all that stuff you'll
need a client ID for that my client ID
is set up for Android because my manager
application is running on an Android
device if you had this as a web back end
or something like that you would create
one of these that's web credentials so
there's different types for different
platforms and an API key the API key
will be used alongside nearby messages
so the device application itself will
have this API key burned into it so that
nearby messages knows which project to
communicate with ok so two credentials
to AP is that's all you need with that
you can use the sample code that I've
got on those two projects right out of
the box ok pull that in some beacons
you'll need to have some of those ok
so I've got two applications that I want
to walk you through just real briefly
the first is I'll do the proximity
beacon manager first this is the
application that communicates with the
API to register new beacons create
attachments all that stuff okay and then
I'll show you the implementation that
uses nearby messages to scan for those
beacons and return the values okay so do
the beacon manager first now the first
thing that this asks me to do is log in
with a google account and I'm just using
google play services api's to
authenticate my google account and do
all that stuff so the the code in there
to do that is very simple and you'll see
it in the sample all I have to do is
click a google account that's set up on
my device and it will authenticate not
again the code to do that is 10 lines
maybe there's not a whole lot there
because Play services sort of handles
all that for you the account you use
must be an account that's attached to
that console project and it must also be
an admin on that project okay otherwise
you won't be able to access all the API
methods so the account you login with is
on the same project that has those
credentials at your showed you now what
this first applicator of the first
screen is showing me this is just asking
the beacon API to list all the beacons I
have registered so previously before I
ever got here I registered three of my
beacons that are sitting around this
room this is not telling me that those
are the beacons I can see this is just a
request from the API saying here are the
ones you've registered and they each
have a name a description and actually
if I wrote to this what you can see a
little bit better a name a description
in their current status which happens to
be there all active right each beacon
can have attachments associated with it
so if I tap on one of the beacons it
will bring up all the attachments i have
created that are associated with that
beacon ok so there's another API method
that says for whatever beacon name get
me the list of attachments these
attachments that are in here I've
basically just implemented a very simple
JSON structure that I'm going to use on
the client side to read the data these
are emulating offers that are like
coupon codes that you would put a router
retail store right so each of these
beacons has two pieces of data in
adjacent blob which is the Department of
the store and what the offer
right this is just data I could make it
anything I want I just chose Jason
because it's easy to read and all that
stuff ok you can have more than one
attachment on a beacon so for instance
this top beacon has two attachments
associated with it ok and that will
become important when you see the
client-side later on so I actually have
four attachments across my three
different beacons and this is all stuff
that I created beforehand just using the
API calls so if you look at the sample
code for proximity manager that will
show you how to interact with the
proximity API directly so we're talking
REST API methods just using regular
number calls good one of the nice things
about this are rather about putting this
on a mobile device is I can also build
in a scanner so if you were to have your
provisioning application on the web back
end somewhere when you wanted to
register a new beacon you'd have to
figure out what that beacons ideas come
up with a way to manually enter it make
sure you didn't typo it or something
like that my provisioning application is
on an Android device so I've created an
activity that just scans for active
beads and when it finds them it uses the
proximity beacon API to determine
whether or not they're already active ok
so each of these that are in this list
are the five beacons that I have around
room and you can see the three of them
that are already registered from the
previous screen of a shocking so the
three beacons that I have registered at
in my API console project registered to
me are showing up that way and I can
tell that they're mine by asking the API
to give me the data for each beacon so
what's actually going on here is it's
scanning for Bluetooth to get the
individual IDs and then it's asking the
API can I have the metadata for that
beacon one of three things is going to
happen when I do that it's either going
to say shirt here you go here's all the
data which means one it's already been
registered and two it's been registered
to me if I get a 404 back from the API
that tells me that that beacon hasn't
been registered yet and now those are
the ones that I'm showing up their
ingredient those are beacons that are
active but they don't have a home in the
beacon API yet so I could safely try to
register that as a new beacon to me okay
the third thing that might happen that I
don't have on the screen right now is
you could have you could scan for a
beacon that you don't own but has been
registered already that would return a
403 from the API meaning is forbidden
access okay so all you'll get a 404 or
403 or two hundred and one of those
three things tells me whether it's my be
in your vegan or nobody nobody has it
yet so we're using those to determine
how to implement the view here and then
I won't go through the process but if I
tapped on one of these beacons that was
able to be registered but I'll I would
pop up I could add some additional
description information it would
register with the API so all the basics
it's not super pretty you're well
designed but all the basics of a
provisioning application are in this
town okay so you would at least be able
to get you up and running to create a
few beacons add some attachments and see
what happens right okay so as I
mentioned I've got to beacons that are
advertising but I don't have been
registered I have three beacons that are
registered in the room and each of those
has a total of four attachments they
each have one and one of them has to
correct so if I go into this nearby
beacons application you won't see the
permissions dialogue have already run it
once and I already went through that
process but the interesting thing that
happens is in this application the
foreground activity is subscribing to
nearby messages and reacting to each
message that comes in notice what's
coming in it's those attachment values
that I showed you before we're just
displaying the department name as the
list view and then if I click on the
item it will display what the other text
was right so fairly simple application
but notice there's four elements there
even I only have three beacons because
each one of those attachments comes in
as an individual message now I mentioned
that you're only supposed to do this in
the foreground interesting thing that i
actually just noticed this morning
because it wasn't in a previous version
of Play services
when nearby is active Play services
actually puts a notification in the top
telling the user that you are using
nearby API right now you are actively
subscribed which means you're doing
stuff that potentially is draining their
battery okay now they actually give them
controls to shut you down from in here
so something to be aware of the sample
doesn't really handle that very well
just yet but it's just important that
this is a foreground only thing right
you you're not going to have that
running when the user leaves the
activity and everything goes into the
background now again I don't have time
to show you the code but there is a
check box in here that if I enable this
will set off a separate service that
uses the Bluetooth le api's directly to
do a background scan okay so if you're
interested in how would I use nearby but
still do something in the background the
nearby vegan sample has a service that
does background scanning in a safe
background way and still uses nearby API
when the application comes to the fore
grip okay so you can see those two
things kind of a concert maybe get a
good idea of how you would want to do
that so that I can still generate a
notification when the user is walking by
the beacon in the application or the
phones in their pocket but once they
actually take your phone out and want to
engage with that content i can use
nearby to get that rich or attachment
information down from the API yes
question which ask that question again
I'm sorry yes that's a very good
question so the question was about
permissions associated with scanning and
there was a change in android 6.0
marshmallow where bluetooth scanning
requires the location permission didn't
use to but it does now the sample
accounts for that so if you look at the
sample you'll see where it's checking to
see if we have a location permission and
on marshmallow devices if we don't it's
going to pop the dial on so that flow is
integrated into the sample because it is
required if you don't do that you won't
be able to scan for anything
depends on your application this one
does it on launch but you know it would
probably be more integrated with a
specific feature where you might want to
do it it depends on how your
applications written okay other
questions on that that again you can
find that sample code by just going to
mile high Android and clicking on those
links those will take you to my github
pages for those projects you can clone
them the instructions for where to put
API keys and stuff like that if you want
to play with them is in there and you
can kind of mess around with that stuff
and look at the code if you look at the
code you have any questions for me
please feel free to contact me at any
time I'll go back to the beginning here
and put up this slide which has my
Twitter information Google+ information
I can give you my email if you want to
contact me I love questions so that's
all I've got for you guys thank you for
your time appreciate it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>