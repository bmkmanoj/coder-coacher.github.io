<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Secure Execution of Untrusted Scripts - Forward 3 Web Summit | Coder Coacher - Coaching Coders</title><meta content="Secure Execution of Untrusted Scripts - Forward 3 Web Summit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Secure Execution of Untrusted Scripts - Forward 3 Web Summit</b></h2><h5 class="post__date">2015-08-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ztVvN1Nb2yw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right we'll get started my name is
gabriel gonzalez i am a software
engineer at twitter and today I'm gonna
be talking about secure execution of
untrusted scripts so before I begin I
want to ask the audience one question
oops who has ever done something like
this where something staller asks you to
install your software by doing curl some
URL which contains an installation
script and pipe that into bash sometimes
with root privileges who's ever done
that yeah a lot of people I've done it
myself so you're just as guilty as I am
and what I would like to do actually is
to fix this problem to provide a secure
way to install scripts such as they
execute with a very restricted set of
privileges however this talk is actually
and so actually there's an entire
website which is dedicated to gross
violations of this principle it's called
curl pipe sh tumblr com you can see lots
of egregious examples of this even from
very large popular software packages
like npm rust nicks and lots of other
things however the talk of the tile
might be slightly loose misleading
usually I tend to work more on Michael
foundational libraries and so this is
actually just one practical application
of a foundational library that I'm
working on and so this talk is going to
explain what that foundational library
is and how you can use it to build
secure installers and possibly other
applications as well so the first part
of the script I'm gonna give them
motivation for why I want to be able to
create secure software and second part
of the talk I'm gonna give an antenna
establish security across the pipeline
and the way i'm going to divide this up
is it's actually in terms of three
modular software pieces one's going to
be a court oculus which i've built and
that has a front end in the back end
which are used as part of the compiler
pipeline and finally another talk I'll
give a conclusion and if time permits we
can actually do a live demo where
somebody from the audience actually
gives me some code which I will run for
my laptop and I won't even check what
the code is
so that the actual foundational library
that I'm trying to do at the moment is
what I like to call the Internet of code
and the reason I call at the end of the
code it's the internet because it's
distributed and you actually use the
internet as the distribution mechanism
meaning that every type term value or
function this language has its own URL
so you can host all of these on their
own network endpoints for example if you
have your laptop with you right now you
can curl that URL right there sigil dot
place / talk it's this talk number 0 but
I've given on this subject and then
there's a true value that's posted on
the network that represents the how true
is encoded in this core calculus that
I'm building in this case it's a lambda
calculus that's why you see lamb doesn't
that code I don't expect you to
understand lambda calculus for the
purpose of this talk just know that it's
sort of a low-level encoding for
functional languages and what's neat is
that expressions can have references to
other expressions so you can for example
here is an expression this is the
implementation of the or operator in
this language and it has references to
remote URLs you can see this hashtag
introduces our mole preference and this
case is a reference to a type so I'm
saying here you can roughly read this as
saying the value be one that I'm binding
has a type which is given at this URL
the URL for wool and you can also
provide URLs for terms like true there
at the bottom and so by doing this
expressions can transitively refer to
other motor expressions which can in
turn refer to other expressions the only
restriction is that a it has to be well
typed be it can't be recursive and see
it has to form a directed basically
graft and the compiler will enforce all
these properties at compile time and the
software the existing software
architecture that this most closely
resembles would probably be JavaScript
although it's not the comparison is not
exact so in JavaScript you can obviously
host code at arbitrary endpoints and you
can include that and you know if you
bought if you do it's within the same
domain you know about violate
cross-domain security policies and so
there you could do that but there are
some important
this between this and let's say
JavaScript first one is that this has a
much lower barriers distribution hosting
code is just as simple as posting text
to a URL and embedding it is as simple
as a hashtag URL reference there is no
ceremony involved in distributing code
but another really important difference
is that is typed and the reasons is
important is that I want to use the type
system to enforce policies allotment if
I'd be injecting remote expressions
directly into my syntax tree I want to
have some say over what those
expressions can be did anyone attend
Justin's talked earlier on a Haskell and
pure script if you attended that talk he
explained that one of the benefits of a
type system is a type it's not only says
what something can do but more
importantly what it cannot do so for
example we can use a type like wool to
enforce something like that saying this
can either be only a true or only a
false it cannot be a side effect it
can't be a function it can't be like
some remote code injection that does
anything other than being true or false
and so types can be a way of enforcing
policy and I'm going to show a concrete
example how we can do that for a real
world program with side effects so let
me give you an example of how this would
work in four at the very low level so
let's say I have three Network endpoints
hosting code so the first one here at
the top it's going to be hosting the or
function and then we also have a network
endpoint for true and network endpoint
for false and since these are valid
expressions within this language I can
apply a remote URL to another remote URL
so here I can take the compiler for this
core calculus which is called morte and
morty will take an expression on
standard input so here I'm just typing
this in let's say pacing this in at the
command line and then it will output an
expression on standard output which has
been type checked has all remote
references resolved and then up fully
optimized and so here I'm saying I'm
going to apply the or URL in prefix form
the two arguments the true URL and the
false you are
and so morte will recursively resolve
all these expressions and remove all
remote references you'll type check the
program to make sure that it's valid and
then will optimize the program at
compile time so we haven't actually done
any code generation yet so this is all
compile-time evaluation and more table
output two lines one is the inferred
type of the program so morte says the
type of this result is going to be a
bull oops and then the value and it
helped demises away or true false to
true at compile time make more taste
really good at evaluating things I'll
give a few more examples of that but as
you can imagine it would be really
tedious if we had to provide fully
qualified absolute references to urls
everywhere throughout our program now I
don't even want to do that myself but
you can do to make programming in this
style easier is that you can actually
create local aliases the is this hashtag
syntax works for things other than URLs
you can also import local files using
either relative paths or absolute paths
so for example I can if I want to create
a shorter reference to the bull URL I
can just create a file a local relative
file name bool whose contents are just
hashtag the remote URL pointing to pool
and now i can use this within my program
just by saying hashtag pool and it will
import the file name pool embed that
into the syntax tree and that will tour
contain reference to the remote URL for
bull they don't bed the contents of that
into the syntax tree then type check
things and normalize things so if i want
to create convenient ergonomic shorthand
aliases i'll just create short hands for
bool true false and an or and now i can
run the same programmer before but all i
have to do is just say hashtag or
hashtag true hashtag false and again it
will resolve everything and give me true
evaluated at compile time morte though
is just one piece in a more modular and
reusable software architecture that I'm
building so morte is a very bare-bones
language it's highly minimal
I'll show you what it looks like in
later slides it only has three purposes
one is that it links code which is what
I used to refer to resolving remote
expressions it type checks that code to
enforce policy and it optimizes that
code at compile time as much as possible
and it's a total language meaning that
it can actually do a lot of optimization
at compile time basic and make
assumptions that other languages cannot
make and but programming amor take is
actually really difficult to do like I
wouldn't want to do it myself so I've
created a front-end language which i
like to call anna which is just a
higher-level language that is more
convenient to program in that compiles
down to this low level for calculus
called morte and more day itself though
it is not an executable program again
it's just text like those example files
that you saw before so we need some way
to take those lambda expressions and
turn them into real executable machine
code and that's a responsibility of this
northern component right here and
noordam is also what's responsible for
enforcing policy making sure that only
things that we whitelist will survive
the transition to generating machine
code all these projects have a true API
so they're all haskell libraries you
have an acyl api for generating our
compiling code but they also provide a
command-line interface as well so if you
don't want to ever have to depend on
haskell each of these provides
executable which takes something on
standard some text on snare an input and
pipe something on standard output and
the current progress of these products
is that morte is essentially done is
regular public consumption
well-documented stable and Anna though
is almost done meaning that the compiler
is done but it also comes associated
with a library of standard utilities on
a GUI building in fact you can actually
see those standard utilities online
there are URLs like the ones we've been
looking at so here for example is a
service a server that I'm hosting which
is just a file server and so all these
are just files for example here is going
to be the imitation of the side effects
type can be using later in this talk you
have files which correspond to the
original Anna source code and then side
by side with the morte encoded values so
for example here's the encoding of the
IO type the side effect type and
and then my passing through morte I get
something it looks like this low-level
lambda calculus right here so he's all
ready for distribution within anymore
take code malorum compiled on the other
hand is a highly experimental is just a
really hockey back-end that I piece
together just for this talk is not ready
for public consumption at all but it
works even if it's incredibly dirty
Sullivan gel polishes and releases on
separate library but right now Leo's
have to trust me for the morn of
examples and the talk will show how we
can actually change together these three
components in order be able to securely
run all these remote expressions that we
sprinkled all over the internet so the
challenge is that I want to safely have
important execute arbitrary code and I
want to do it over an untrusted network
so no encryption no authentication no
code signing I don't even care if the
code itself was written by the NSA
trying to infiltrate my system okay I'm
assuming the program is a complete enemy
and I don't even need to necessarily
trust the programmer at all and so the
way I'm going to do this is I'm going to
split a program essentially into two
phases in one phase is where we do
things that are entirely pure harmless
so that's type checking optimization and
linking remote expressions the worst
that that can possibly do is it just
work waste my cpu maybe takes up a
little bit too much memory downloads too
much code from the internet we can solve
that using quotas but it can't really
destroy our system and then there's a
second part which occurs in the machine
generations to the code gens de where we
actually compile a program to a real
point with side effects and the boundary
between the pure face and the side
effect phase is enforced using just one
type and new braiding what are the side
effects that we're going to whitelist so
in this code architecture all pure
computations are automatically
whitelisted you don't have to explicitly
ask permission from any central
authority to distribute them but the set
of side effects that we're going to
allow our secure installer to support
must be explicitly whitelisted by the
back end as the only things that you can
support and we can customize the back
end to allow different sets of side
effects for different application
domains all right so I'm going to give
you an intent example of a real site
epic program being compiled to machine
code if you have any questions before I
go on to that
you know the talk good so the running
example is we want to distribute safe
installation scripts and I just picked
five side effects that might be useful
for installers this is definitely not a
comprehensive list but I was just purely
for the purpose of this talk and our
installer will only be allowed to do one
of five things it can either read a
string from standard input it can write
out a string to standard output it can
download a file from some URL to a local
file path it can create a file from a
string and it can test profiles
existence notice that it's not going to
be able to do things like remove files
okay so the worst thing that installer
can do is perhaps do not do it analysis
on my hard drive by filling up a
partition ok that's the probably the
worst case scenario for these five
effects so obviously there's always
potential for insecurity in the set of
side effects that you choose like maybe
creating a file from a string is not
necessarily a secure enough side effect
maybe I want to do something like create
only X bytes worth of data as a side
effect which would be more secure but
these are simple enough for the purposes
of this talk and so these all have
associated types so for example this is
a type which says this get line command
is a subroutine which I'll denote by I 0
so I o stands for a subroutine that
returns some value in this case the
value it's returning is going to be a
string the string it read from standard
input and then there's going to be a
foot line command which takes some
argument names str that's a string and
then it will give me a subroutine that
will print that string and return a
useless value so i use prods 0 sorry for
the name to represent that useless value
that's sort of analogous to void in the
C or Java family of languages or unit in
scholar or high school or pure script or
other ml like languages and you have
download which you give it a URL and you
give it a destination to copy the URL to
and then that will give you a subroutine
that actually execute that copy and of
course create file give it a payload of
a path the contents of the file the path
you want to write out the file to and
that's a side effect that has no return
value and finally test file you give it
a path to check for the existence of a
file and then it will have a subroutine
that
will return true if the file exists or
false at the file doesn't here's an
example script and this is written in
the analane 'which there's some little
boiler play at the top you can tell I
like Haskell because I called this a
monad sorry about the name I know some
people don't like the word mo dad but
I'm unapologetic about it and so this is
the part of the script that you should
actually care about which are these five
statements that we're going to execute
and so here we're gonna say the first
statement is just going to print a line
to look to stand it out prompting the
user enter a file name this has the
useless return value it's an empty
return value so I'm just going to use
underscore to indicate that i'm
discarding the value and then the user
is going to enter line of input so i'm
going to prompt I'm gonna get a line
from the user using get line and I'm
going to store that result in this desk
variable right here which has type
string and then again I'm gonna prompt
the user for the file contents read that
in as the payload variable and now that
I have both I can just create the file
for the user so i'll take the payload
the user gave me the path that they gave
me and then create a file with that
contents at that location so i can then
do is I can take this and pass it
through an antenna interpreter so this
would be the secure client that I would
distribute that takes scripts and then
execute some in a secure way and so I'm
not going to really care where these
hashtag represents came from so they
currently refer to local files on my
system but those files might refer to
remote expressions I don't really care
where they came from and it's going to
like parse this code compile it down to
the core calculus result imports type
check normalized generate machine code
and then it's going to actually run the
program and then it's going to prompt me
enter a file name let me actually show
this in action so i feel i have this
working here on my laptop but let me
make that bigger there we go alright so
here is the actual programming question
it's a real program this and then I have
an interpreter function which will
basically take that program and will do
everything I just showed you if I modify
the program it'll update to reflect the
updated program give it a second type
checking and resolution takes the most
time because it's getting things over
the network here we go so our prompting
for a file name I type in output text
and then I'll the file contents are
going to be hell oh well that's totally
obligatory for any introductory tutorial
and now
if I looked at the contents of output
text there it is it's hello world so the
program is exactly compiled it can only
run with the side effects that I specify
if I try to put in any other command
other than the five side effects I told
you this program will be able to compile
completely so the entire pipeline begins
with is Anna program so i use the dot
anna suffix indicate and a program and
what we're going to do is the first step
is to translate this higher level and a
language into the low level calculus of
the Mart a language which is the
calculus of constructions and so I can
do that just by piping it through the
Anakim and so and adjust these sugars
from the higher-level language to the
lower level language so in goes this and
out comes this right here all right so
low so this is very low level everything
is done entirely in lambda calculus all
these seas and s's you see right there
that's the lambda calculus encoding of a
nasty string actually and then here's
the entire program and here you can see
some of the utilities at the bottom but
oh there's some things we haven't done
so this still hasn't resolved all remote
imports we haven't really type checked
it and we haven't optimized and ordered
why's the expression so the way we do
that is piping it through more tape so
more takes a morte program of standard
input and type checks it resolves
imports normalizes it in up to and
outputs the optimized version on
standard output so I'll just pipe that
through the more tape program then I'll
get something it looks a little bit
bigger like this so now all remote
references has been resolved it's been
fully in line and normalized giving me
this program right here and now this is
ready for code generation so I'm going
to pipe this through the noordam
executable and that will enforce policy
it'll verify that this program only
restrict itself to the site of five side
effects that I set out the very
beginning and then it will generate
executable code and actually because
this is a very happy example they put
together for the purpose of this talk
it's actually going to go through and
haskell intermediate Haskell's the
backend language and so it actually do
is it'll take this and will generate the
equivalent haskell program so just trick
that lambda expression translate it to a
shorter haskell lambda expression
without explicit types and then there's
this adapter function which inserts for
all programs which basically translates
all these lambda calculus encoded types
to the equivalent haskell built-in type
so they can actually generate machine
code and now this program can be piped
to run haskell to generate a real
executable that does exactly what the
first example did in practice the code I
ran just did all entirely within one
program instead of the command line but
it's functionally equivalent so I'm
going to go into more details now about
how the core calculus works and how it
supports this sort of type checking
normalization and resolution any
questions before I go on to that stage
of the talk excellent so morte is a
really really low-level functional
language and by low-level i mean that
the only things that you can that are in
more taste syntax tree is you have the
type of types which will denote by star
all right you have bound variables you
have lamb does which you can think of as
anonymous functions so if your program
to function language you might be
familiar with lambdas it's just like
this is saying an anonymous function
which takes an argument X of type a and
then returns a B and then we have pie
which is sort of like a function type so
this basically says this is a function
that takes a value name X of type a and
then returns a value of type B then you
have function application which
basically apply that's represented by
appt appt fa just means apply the
expression f to the expression a as a
function and then finally we have rural
imports which are this import
constructor right here and there's
nothing else there's no side effects no
strings no numbers no anything is just
pure lambda calculus and then the only
the only important operations which
morte exposes our load which is how you
resolve all remote expressions and so
that replaces all these import
constructors with remote sub expression
syntax trees we have the type checker
which given a fully resolved expression
will tell you either the expression does
not type check or it will give you its
type and finally we have normalized
which will take an expression and just
keep beta reducing and ada reducing the
expression to give you an optimized
program here's an example program a
morte
pipeline so again we start with our
original or true/false expression and
the first thing more tape will do is it
will take each one of these three
hashtags and replace it with the
equivalent remote expression so or will
be replaced with this lambda expression
right here true will be replaced with
this lambda expression right here false
will real place with this expression
right here and then it's going to
optimize a program just by constantly
beta reducing in this case it's going to
do beta reduce beta reviews beta reduce
and that gives you the fully optimized a
compile-time expression which evaluated
down to true so more tastes or like a
functional assembly language but I
differs from a lot of languages they're
functional but not its total meaning
that you don't have general recursion
and also normal it means that every
expression has a normal form which is
fully optimized it means that
compilation and type checking sorry it
means that evaluation is always
guaranteed to complete within a finite
amount of time told you can think of as
being a non turing-complete language
pretty much every other language you're
used to is Turing complete but it's but
a language does not necessarily have to
be turing-complete to be useful more
take is one hundred percent pure meaning
that has no built-in side effects in
fact the way we're going to represent
side effects and morte it's just we're
going to build a pure syntax tree
describing planned side effects so more
time evaluating things doesn't actually
trigger any side effects instead we're
just going to pass that pure tree to the
back end and the back end understand
that tree and then translates that to
all the side effects that it will
explicitly support another really
important thing in fact this is actually
very hard to find in any language which
is why I had to write my own is that
morte has no escape hatches or unsafe
primitives whatsoever everything you saw
a nice index treat that's it there's no
unsafe perform I oh there's no primitive
fi operations that break refreshing to
transparency there's literally no way to
break out of more taste security
guarantees other than a bug in the
compiler and like I mentioned before no
support for strings numbers data types
or pattern matching you can't even have
multiple top-level expressions all more
tape programs are just one big giant
expression you can't even have a
recursion but it turns out that you
actually
translate all those features into more
tape anyway and there's several papers
that actually explain how to do that
which are fantastic and so Anna's job is
actually to take those higher-level
concepts and then translate them down to
this core calculus so any questions
before I go on to how Anna works and it
does this translation so if you don't
have multiple top-level expressions you
can use let so this we're going to
create a new tupple binding call x which
has type T and it equals y and that can
be translated to an anonymous function
which basically says we're in a bind a
value name type X which is going to come
here from Y and then that will give us
back in E you can have multiple let's
just by nesting multiple lambdas and
it's the exact same way you're going to
bind functions so i can say define a
function which takes an are you two
arguments X 1 of type T 1 X 2 of type T
2 and it returns y which has type T and
that's groups over this expression E and
that again can be completely converted
to lambda calculus now or it gets really
interesting is how you convert data
types to lambda calculus so that's
actually possible it's rather actually
difficult to understand at first but it
works really really well so if you are
familiar with Haskell or any similar
language you can declare data types like
in Haskell like this you say bool the
type bool is either a true constructor
or a false constructor and equivalent
type declaration anna says here you have
a type pool it has two data constructors
true and false we can also explicitly
named our pattern matching function this
will be if in this case and this type
definition will scope over this
expression e so it's not a global
definition and that can be distributed
calculus you don't need to understand
that t-shirt grading process other than
it actually works and there's a great
paper explaining how it works which is
called automatic synthesis of type of
type data structures in the lambda
calculus also known shorthand as Boehm
berarducci encoding after the authors of
the paper and what's cool then is that
once we have this contract right here we
can
separately compile all those expressions
so i can actually separately compile
bool true and false so i can host them
all on their own network endpoints so
for example if I want to separately
compile bull I'll just give the type
definition and say a given out given
that bull is true or false give me the
definition of a bull and then that will
output this right here which I can then
save on a network I can do the same
thing for true false or if and they'll
all work together in exactly the right
way and they will have no references to
each other so these for separately Paul
expressions will actually be totally
self-contained you can encode records in
the exact same way so here's an example
of a pair of record with two fields in
it so it says this tight pair has a one
constructor called make pair and a
fields name x and y in a pattern
matching function called full pair and
then that will of course to generate
equivalent lambda calculus expressions
which I can now host on the network and
so we can do string literals we can be
encoded in line the calculus so in Anna
when you type in a string literal it
will actually translate that to a giant
lambda expression and here at the
beginning this was hello world then you
can see this is basically a nasty
included hello world h-e-l-l-o of comma
space WR orld ! end a string right here
and once you have an encoding for
Strings you encode things like string
concatenation you can code all string
operations using pure lambda calculus so
here if I can tell say and Anna
concatenate the strings hello and world
pipette through Anna pipe it through
morte it will concatenate them at
compile time so here again is hello
world encoded in a c lambda calculus you
can encode numeric literals in calculus
there's a simple and obvious way which
is the way usually taught in the
literature and actually uses a more
efficient representation using binary
numerals so 42 gets encoded as one and
binary 101010 which is binary for 42 and
you can do 64-bit arithmetic and totally
on mt calculus and actually completes
within a somewhat reasonable amount of
time a second
is done at compile time so you only do
it once and so here's the apple of
adding 263 bit numbers to get a 64-bit
number here is multiplying 262 32-bit
numbers to give a 64-bit number all done
at compile time and then once we
translate things to lambda khesari to
lambda calculus now we can start
generating machine code machine code
generator is actually pretty efficient
even those using these large time two
expressions because Haskell compilers
really good at at optimizing them away
any questions before I go on to the
backend code generation so like I
mentioned before morte has no built-in
side effects instead we're in encode a
side effect as another data type in the
language so here examples how we encode
the data type for side effects which is
IO and the way I represent it is as a
syntax tree which has five nodes and an
end of tree so each one of these
constructors right here is one node in a
syntax tree which behaves like a
placeholder for the equivalent side
effect on the backend for example this
foot lying constructed right here is a
placeholder for the real put line
command and it takes a string which will
eventually be passed to that command and
then this will be the remaining
statements to execute similarly get line
is a placeholder for the real get line
command and here's a function that will
basically consume the string read from
the real get line command and so once we
have this syntax tree defying an Anna we
can then ask Anna what is the equivalent
more tape type for that tree and i'll
put a type that looks like this it's
basically a function that takes one
argument for a constructor and this is
essentially a signature for all the side
effects that our system is willing to
support so we can actually read from the
type that this will only support foot
line get line download create file and
test file and nothing else and so now
that we've included in the type system
we can actually use that type to enforce
policy so we can take any program that
is generated by the morte compiler and
just type check it and see doesn't match
that type yes or no if the answer is yes
we do coach n if the answer is no we
abort compilation and we'll get a type
error explaining why you didn't match
that
signature and so this policy enforcement
is done at compile time so like you're
thinking about what security systems
this is most similar to this would be
closest to the sandbox approach to
security where you're essentially
whitelisting interactions with the
outside world but the difference here is
that we're enforcing that white list at
compile time instead at runtime so
before we even do code generation we can
detect if our program is enforcing it
matches our policy or not we don't have
to like throw an error or a partially
and partially abort a script to happen
to do something it wasn't supposed to do
so like I mentioned before since we can
specify the side effects in the language
that means we can customize with side
effects we can specify that means if you
want to have a different set of white
list of side effects for a different
application other than secure script
insulation you can do that just by
building your own io type and generating
the equivalent more take type and then
type checking that before doing codegen
and then you have to write the back end
to do the translation of those
constructors to the equivalent real
commands in the back end so this
approach is most similar to the sandbox
approach to security the most unique
feature is that it takes policy
violations at compile time but other
important features is that pure code is
automatically whitelisted so and a lot
of other security managers you either
have to do a black this approach if you
don't want to just like automatically
reject all code or a whitelist approach
which requires tediously like white
listening the entire standard library of
the language and requiring library
authors to do some registration policy
for white listing their code but by
divining put into pure and side effect
faces we can just autumn buy things by
only requiring you to explicitly white
less side effects and this allows us to
automatically accept pure code another
important advantage over other security
systems is the extremely low barrier to
code distribution you think about it the
typical way you will distribute code
another language is that you know you
you'll first you alter your code and
then you'll create a package for your
code and you have to alter some like
package description all right and then
you have to upload that coaches some
type
repository then a user has to download
that packet from the past repository add
as a dependency to some build file in
whatever builds tools are using and then
they have to import that package using
some import statement and then they can
use your expression but here all we have
to do is just post it on network
endpoint and then somebody references it
with hashtag URL and you're done that's
the entire distribution process and the
other thing that distinguishes this from
other security big approaches is that
policy is enforced using types which
means that the more advanced the type
system gets the more types of things we
can enforce at compile time which is
really nice all right do you have any
questions so far so I'm going to give a
few concluding remarks and if time
permits which I think it does I want to
actually try and do a live demo with a
member of the audience well they'll just
like put up some code on the internet
and I'm going to use it inside my script
it'll be pretty simple code but just to
drive the point home so one thing I'll
recommend is I would say like these
projects are not really ready for
general purpose use like I would not
actually not recommend that you use them
right now I don't think they're ready
for that things I need to do is that it
would be nice to allow the users to
select more high efficiency numeric
string operations that get done a run
time instead of compile time that would
be a nice feature to have especially
when doing like numerical code type
inference is still missing so the ANA
language isn't still an explicitly typed
language which can make it t is to use
for highly generic highly polymorphic
functions so the absence of type
inference I wouldn't recommend it for
general purpose use and then finally it
needs really better tooling for things
like our distribute code like how to
take a bunch of things letter on your
files a bunch of a library of code and
host it in easy fashion there needs to
be some way to easily discover all these
remote expressions sprinkled all around
the internet and there needs to be an
easy way to install code and we're here
installation just means creating a file
a local file of aliases some remote file
that's that's all installation really is
just creating shorthand aliases let me
see easy way to do that on mass for
installing a package
and this code is real it's up on github
so the morte library is it can be
located on github Haskell morte library
same thing for Anna the orem code right
now exists purely on a branch of the ANA
library it doesn't have its own
repository just yet but you can actually
check it it's there and if you have any
questions of course you can reach out to
me my twitter handle is Gabriel g 439 I
also like to hang out on our hospital as
the tech mode user and if and unless you
guys have any questions I won't actually
do a really quick live demo so first off
I want in that a lot of these
expressions are hosted online so here is
the actual I mentioned the place right
here I want user did you actually in
this case is i'm going to write two
programs and while you in the audience
will actually select which one to run so
here I'm gonna actually open up example
so we already had one example program
right here so the example danica alright
so I'm going to do yeah so I'm going to
move that too let's call it I 01 Diana
all right oops
so first off in order to import that I
need translated to a morte expression so
I'll say and import I am why not Anna
and move that and just make that the IO
file and it's going to take a while to
do the sugar ink is actually type
checking the result and type checking
iOS with strings in it takes a while so
this is why this process is actually
taking a few seconds give that some time
there we go so here is the expression in
the court calculus all right and then I
need to create some other files let's
call this I owe to Diana and so this
file is just going to say let me because
I don't want to take too many risks
while doing a live demo I'll base it off
of my other file so here I'll just do a
simple echo program that will take some
string read in for me sorry and then it
will print that string okay there we go
alright so let's type check that make
sure there are no bugs in it and then
i'll put that too I owe to give it as a
second
alright so now let's create a final
program so now a new example Anna so I'm
gonna do is I'm gonna import some user
code so there's going to be a URL and
i'm going to apply it to either I 01 or
I 02 and the user gets to select which
one to run is there anybody who wants to
volunteer to host a text on an airboat
mr1 endpoint does anyone have internet
access Justin you want to be the
volunteer okay I think we can do this
really easily using el pase okay let's
see if there's a way to get raw text or
something so I'm going to try it myself
so here would be like the polymorphic
identity function in morte I'm gonna
just like see if I can get okay see raw
yeah that'd work I think perfect let me
see if that generates something about
excellent that'll work alright so now
you using el pase I'll give you a rough
template for what this program should
look like so one thing that will just
help really quickly is to get the URL
for I oh ok so if you can actually
navigate to so this URL right here can
you navigate to that and just copy that
so that's this the path to the i/o type
sidled talk place / talk / 0 / io and
then you can write an expression that
looks something like this so you'll say
I'm going to take to IO actions so let's
say call I 01 and you're going to give
the type that we paste it up here so
sorry this I oh oopsies this IO type
make sure there's a space no no ending /
in the space after it okay and then
another io type I 02 hashtag the URL no
/ or space and now I'll let you select
which one to run using either I 01 or I
02 and i'm going to use your code within
my program all right tell me whatever
you think you're ready okay and so now
paste that and you
have the URL so do a public paste or so
just do something like this public let's
say alright and can you give me the
number for that el pase that you hosted
the code for
okay so you were right after me perfect
oh sorry I shouldn't have looked at the
code because I don't want to like see
what you're actually running again the
idea is that I shouldn't care what could
you put in there all right so now I'm
gonna go to the example dot Anna I was
right are yet it open and i'm just going
to use your url boom okay and you're
going to pick which one to run all right
and now interpret a statute exception it
wasn't invalid URL not the correct text
type oh damn okay well anyway let me
then just take your expression and then
just make a local file out of it for the
hell of it just to demonstrate the rough
concept okay so where was it where was i
before here we go okay so i'll create
just in there we go ok and now VI
interpret sorry example so i'll just use
refer to the justin file exited alright
and now let's do interpret oh sorry what
is no actually help me there is no it
doesn't look like there is hold on once
again let me actually read it oh ok I
see the user actually is a problem in
the remote string type that I hosted is
not encoded correctly ok so then let me
actually modify your example a little
bit further how embarrassing so I'll
just let you use the 1i have locally
instead ok and then let's try it there
we go oh sorry that's just the here we
go actually so there's a type error
obviously it caught a problem at compile
time invalid input type oh that's right
now I see what the error is so there was
a type error in both of our programs it
actually should have been this we have
to specify what the return value is of
these actions so I detected a problem i
compile time now it's succeeding
hopefully and then
give it to the second
so again resolution takes a while
getting things from the network type
checking these large syntax lamb
expression syntax trees and we go
succeeds generating executable and he
selected the first program okay so
that's the end of that example all right
sorry about the palm with the string
encoding apparently the code i hosted
was not included in correctly for more
teeth download it but yeah all right so
are there any questions other than if
not then that's near the top</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>