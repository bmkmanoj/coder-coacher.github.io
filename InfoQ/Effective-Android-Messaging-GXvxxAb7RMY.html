<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Effective Android Messaging | Coder Coacher - Coaching Coders</title><meta content="Effective Android Messaging - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Effective Android Messaging</b></h2><h5 class="post__date">2014-05-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GXvxxAb7RMY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so again my name is juan gomez aye man
and developer here at eventbrite I've
been here for about 10 months I think
and Tom said we're trying to do a good
job at making our Android I feel like a
real Android app and not like some apps
that are feel like they're ported from
iOS or just not to to the Android
experience I'm going to talk here mostly
about messaging I'm going to explain why
what i mean by messaging and i apologize
in advance for there's not going to be a
lot of code there's like four lines of
code in total so those of you that are
really really code inclined I the talk
is fairly technical but there's not
going to be a lot of code to try to keep
the level of the talk intermediate
there's going to be a lot of technical
details with just not a lot of code so
you just be warned this is the agenda
mostly we're going to talk about
different messaging protocols you can
use on the Android platform and we're
going to try to progress and build a
story around the options you have the
idea of the talk is how to effective use
these protocols to include messaging on
your apps and I'll talk a little bit
about what i mean by messaging so a
little bit about eventbrite we're a
marketplace of live experience life
experiences we try to connect people
with events we try to let you find great
events that you go and buy tickets for
those events and then we let the
organizers of the events engage with you
and create awesome experiences for you
to to enjoy this is some of the numbers
some of those numbers are a little out
of date but we have sold over 160
million tickets to our platform and and
I like to think that a lot of organizers
love us and we're trying to make
attendees love us too and working and
we're working really hard to make
a the experience of a member I really
mobile and that's part of what we're
going to be talking about today so I
guess I Tom made a great job of
introducing me so I'm not going to go to
that if you want this life this is my
lanyard page so you can just go to the
lanyard page and download the slides
these are the same slides that I use for
am def con which was an Android
conference that we had here in San
Francisco about probably a couple months
ago I made some changes so i might
upload the this deck later tonight or
tomorrow but at this pace you're always
going to find the latest version of this
deck you can download in PDF and and so
you don't have to write down and there's
going to be a lot of URLs so you don't
you're not going to have to write them
down just go this is the only year all
day off to write down and then download
the PDF and then you'll have all the
URLs so finally what what do I mean by
messaging the idea is to talk about the
different protocols that Android offers
to allow apps to communicate with other
apps on on other Android devices or even
other apps running on different
operating system or code that's running
on the server we're going to talk a
little bit about peer to peer peer to
peer is it's really really hard on
mobile devices those of you that have
tried it may be using bluetooth or some
our technology know this so we're going
to talk about normal protocols that let
let you fake a peer-to-peer experience
without communication happening on the
on a device to device level we'll talk
about how you can make device of device
communication happen at the end of the
talk but most of the of the topics let
you kind of fake up here to peer
experience so why why am I talking about
messaging why is this relevant there's a
lot of apps that need messaging there's
like instant messaging apps with of
course have messaging at their core but
there's also other types of apps like
multi multiplayer games or a lot of
enterprise app even our own eventbrite
app has a lot of messaging in
it and I'll talk a little bit about
specific scenarios that we have in our
app so there's many many apps that need
messaging on them and a lot of you might
be developing one of those apps or
thinking about those apps so the idea of
this talk is to show you the different
protocols that you have at your disposal
and to help you make an important
decision on how you go about
implementing a good messaging strategy
on your app so first we're going to talk
about HTTP so HTTP is really not
messaging on a peer-to-peer sense the
basic problem of HTTPS that is no full
duplex so the client can talk to the
server and then get an immediate
response but there's no way for the
server to communicate with the client
unless decline initiates the
communication so that's the basic
downside of of HTTP talking about
peer-to-peer communication but aside
from that HTTP is probably the the
messaging protocol or the communication
protocol then most of us use on our
honor Android apps if we use rest or if
we consume any kind of web servers even
if we do if we scrap HTML out of a web
page we use HTTP on on on our ABS
talking about HTTP and effective ways to
do HTTP will take the entire hours so my
recommendation is that you go and
download the slides for this talk call
effective Android HTTP and that's part
of the inspiration for the title of this
talk it's by Jesse Wilson he used to
work at Google maintaining the HTTP
stack so he knows a lot about HTTP and
now he works at square maintaining some
of their HTTP and we'll talk a little
bit about that to some of their HTTP
code so he's probably one of the most
knowledgeable people on the HTTP side of
Android so go download his talk he has a
lot of great advice I'm just going to
touch them on a point that I think it's
it's really important for most Android
apps and it's your HTTP stock so when
you're when you're developing an Android
app and you need to use HTTP be it for a
rest service or anything that you have
to do to http
the first thing you have to do is choose
your HTTP stack so the fact that you
have to choose between different stacks
it's confusing and it's sort of a
problem on on on Android but I'm going
to try to summarize the advice that
Jesse gives on his talk on how to choose
the best HTTP stack for your app so
basically there's 22 HTTP stocks that
are included on the android sdk the
first one is HTTP URL connection and the
second one is the ACA apache HTTP client
apache HTTP client has been around for a
long time so you're going to find a lot
of examples and a lot of people that
actually use it the problem is the the
apache HTTP stack that's implemented on
android it's really old and google
stopped up improving it and developing
developing probably two to three years
ago so right around the time of 2.1 and
2.2 that's when google basically
deprecated the apache HTTP client so for
it for 2.2 and below apache HTTP it's
good enough and the problem is that
httpurlconnection had will really nasty
bugs especially around the HTTPS part so
it was not recommended to use it but
then from 2.3 and above they fix all
those bugs so the idea that the
recommendation is that you use HTTP URL
connection on 2.2 and above so try to
use HTTP URL connection for most of your
abs because right now usage of devices
of below 2.3 it's around ten percent
probably even less depending on your app
so so for most cases you should be using
HTTP URL connection if you're still
supporting 2.1 and 2.2 you should have a
way to depending on the platform you can
choose which stack you're going to be
using depending on on on if the code
that you have on your app runs into some
of the bugs that httpurlconnection has
but the main advice is to use HTTP URL
connection if you're running on 2.3 in
about there's two so if that wasn't
complicated enough
sunu HTTP stacks 1 by google + 1 by x
squared so on the title of the slide you
see that I'm i ice a third-party
libraries and I'm including boli which
is a google library so a lot of people
ask well why you say is a third-party
library right now it feels like it's a
third-party library it's not included on
the android sdk your actual axel you
have to actually go and download the
source from the google rapist repository
you have to compile yourself and then
include it on your project there's not a
lot of the comment a documentation I
it's almost non-existent so that makes
it really really difficult to to really
if you're running into an issue with
Bali to try to diagnose it and and and
so there's there's some implement and
information is starting to pop up
recently on forums and Google+ but
there's no official documentation of
Bali except from a couple of talks at
Google i/o so that makes it really
really hard to to really recommend Bali
on the other hand there's it's ok HTTP
as i mentioned jesse wilson who used to
maintain httpurlconnection at Google he
now works at square so he forwards HTTP
URL connection and created its own his
own Fork and and it has some of the
things he thinks httpurlconnection
should have and it's he's taking it in
the direction he thinks it should go
it's it's a lot better document at the
Bali it's a lot better there's a lot
more community code and community advice
around on the internet so for now I
think HT ok HTTP feel feels a lot better
than Bali I'm sure Google will probably
catch up and I'm sure for the next
version of android bali will probably be
the first party HTTP stack but for now
you're probably better off if you use ok
HTTP it's better documented it feels a
lot better and the best part and it's
the last line there they're enforcing is
getting cut off by the projector it's
almost a drop-in replacement to HTTP URL
connection and apache HTTP client so if
you use
httpurlconnection you can migrate to use
ok HTTP without changing a lot of your
code because it uses the exact same API
as HTTP URL connection because in fact
it's a fork of HTTP URL connection
there's also a plug-in on ok HTTP that
you can put out so that that uses the
same API as a apache HTTP client so that
makes it a lot easier to to migrate is
the same API interface you don't have to
change a bunch of code on your app to
make to make the switch to a more modern
HTTP sack and as I said the problem with
HTTP four for the purpose of what we're
talking about today is that it's not
full duplex so the client has to
initiate the protocol that has to
initiate the communication there's no
way for the server to initiate that the
communication directly with the client
and of course if there's no connectivity
if you have low connectivity which is
something is really common on mobile
networks then HTTP is now going to be
your best option and we'll talk about
some alternatives to that later so an
improvement of over HTTP to try to make
it full duplex and try to make it better
for for the disorder communications
we're going to be talking about today is
web sockets there's a lot of
misconceptions around web sockets mainly
that people think that web sockets only
work on web browsers and that is not
true web web sockets work on anything
that can implement the WebSocket
protocol the problem right now is that
is not standardized as opposed to HTTP
which which is a known standard and we
all know how it works WebSockets a
WebSocket is not standardized there's a
lot of drafts from the w3c so when
you're implementing web sockets you have
to be careful that both your client code
and your server code are working on the
same version of the w3c draft so that
you don't have problems because they're
working on different versions so that's
that's the downside is not a standard
yet but that hasn't stopped a lot of
people from using it and you can I mean
if you if you structure code well you
can create a good app that takes
advantage of a WebSocket so basically
what happens is the client makes an HTTP
request to the server and that is that
initial HTTP request is the only part
that has anything to do with HTTP
everything else is a separate TCP
protocol that happens on a separate
socket so only the initial request is
the only one that has anything to do
with HTTP so although it's called web
socket is that there's no similarities
with web it has nothing to do with HTTP
only the first request the initiation
request goes to http everything else is
completely separate so the main
advantage over other protocols is that
is almost you can make it to be almost
real time so you can get responses
really really fast for like a instant
messaging app it's really effective so
while the you have the client open and
you're missing someone you can have a
service running with the WebSocket and
then you can have messaging going back
and forth since it's a it's a bare-bones
protocol that goes to TCP there's a lot
of other messaging protocols that people
have built on top of it I'm going to
talk a little bit about some of those
the main problem with salt kids right
now in Android it says there's no native
implementation mostly because Google has
google cloud messaging which we'll talk
about a little bit later so there's no
real web stock implementation on the
android sdk there's two options that you
can take the first one is called autoban
auto man it's a it's an open source
project that implements WebSocket really
really well it's a multi-platform
implementations of works in Java worse
than arm and they have they have a Java
implementation I think it normal
JavaScript implementation and they have
the under implementation and they also
have a really strong test suite to test
the whole WebSocket protocol the test
suite they have is so good that almost
everybody that that creates WebSocket
clients and
servers use the autobahn test suite to
make sure that their implementation is
up to standard so they have a really
really solid implementation for Android
that you can use and and it's also
commercially supported so if you wanna
if you don't want to go with the
open-source version you can pay them and
get a license and then get professional
support on the on the WebSocket client
and Autobahn offers there's also a lot
of you have probably heard of socket i/o
so there's also a bursting of a client
version of socket i/o for Android it's
open source to there's the link to
github unfortunately the color I chose
for the slides is not really visible but
when if you download the slides you'll
be able to to just access the github
repo it's not as well maintained as
autumn and of course be since audubon
its commercial they try to keep it
really up to date and really well
documented so the socket i applying for
android is not as good as auto man but
then it's an option in case you don't
want to use auto man and why you want to
use one or the other it's mainly the
protocol that's on top so autobahn uses
their own protocol for for how the
message the envelopes of the messages
and the tax they use to in the handshake
they use between server and clients they
use a different protocol that they
created that it's called wamp that it's
not very i mean the only the only client
and server that really use it are the
autumn and server so if you don't have
an autobahn server on the other side you
might want to use the socket i/o client
with which lets you use some of the
other protocols that run on top of
WebSocket that are a little bit more
common so it depends on on how you're
implementing WebSocket any of you have
any questions just feel free to raise
your hand and yeah good well that that's
the that's the I don't want to say the
beauty but that's part of how web
sockets work so it's it's it simulates a
constant connection but there's really
no constant connection going on and the
way you scale that it's similar to you
how you will scale any other socket base
communication so
and insensate we run zon porary 480
there's some magic you can do to try to
scale it just the same way you scale
your web servers but yes there's there's
ee going to be problems when you scale
up too many users that are not going to
be sold like what like what a standard
web server so you when you do when
you're implementing it on the server
you're going to have to think a lot more
on the architecture for scalability to
be able to support multiple users or
multiple a lot of concurrent you can
support multiple users find but a lot of
users to the point where it exceeds the
capacity of just one server so you have
to design your server infrastructure
really well so there's no out-of-the-box
solution to do it but you can you can
implement it relatively easy as you
would with any other socket based
protocol yeah good that's I was going to
get into that that's the that's the
right now is the biggest downside of
WebSockets so although WebSockets is not
connected all the time to the server one
of the biggest downsides is that you
have a display lien Android you have to
create a service that is listening all
the time so that of course is going to
drain your battery so depending on how
you do it depending on how you implement
it it's going to have a lot of
implication on the server side if for
instance i'm doing a chat a chat
application and and and i'm going to
talk a little bit about combining some
of these protocols to to make it better
but if they have a chat application i
want to be able to send and receive
messages all the time so i'm going to
have to be to have an android service
running on the background all the time
listening for messages coming in and
that service running that all the time
all those not making HTTP requests all
the time it's going to be draining your
battery and unfortunately there's a I'm
sure most of you have heard of parse
part shows to implement their push
notification solution and Android with a
really similar I'm not sure if it's
exactly websockets but I would bet is
it's something it's either WebSocket is
something really similar which creates a
service to be running on the background
all the time so
apps that use parts on for push
notifications on Android have a service
that is running all the time listening
for for WebSocket events to come down to
the phone so yes battery is a problem
but it for some apps where you can just
make just listen while the app is in
front of the user and then when the user
exits you can close it you can make it
you the battery consumption is not that
bad since that the app is in the
foreground and what you can do to
minimize the battery impact is try to
combine some of this protocols so that
you don't have a service listening all
the time so one thing you could do and
we'll talk a lot about a little bit
later is you can do a push notification
to the device so let's say i'll have a
messaging app and i i'm not looking at
the messaging app right now i have my
phone in my pocket and someone sends me
a message so you can initiate the
connection with a push notification into
the phone then notify the user that they
have an available message and then when
they go see the message and they open it
up then you switch to web sockets
because the diploma with push
notifications is that it's a lot slower
and there's no guarantee that messages
are going to be coming in and if i have
my messaging app open and i'm sending
messages back and forth i expect them to
coming out and come and go really
quickly so what you can do is you can
create a push notification to alert the
user and then when they open up the app
you switch to web sockets and then you
can have this near real-time
communication and not drain the battery
so we're going to talk a little bit
about Google Cloud messaging which is as
I said it's a way it's another protocol
that you can try to mix and match to get
a more effective solution for your app
so the advantage of cloud of Google
Cloud messaging as opposed to to push
notifications on other platforms like
iOS is that it offers a way for the push
notifications to be full duplex this is
something that iOS doesn't have push
notification which what the name implies
only happened from the server to the
client and that's why Google Cloud
messaging is part of why the change why
they change the name from
go see to the m2 Google Cloud messaging
is that their new implementation allows
not only server to client communication
but client to server communication which
on the Endor case it's really really
useful it's a fire-and-forget protocol
as opposed to web sockets or HTTP so you
basically send a request and you don't
have to worry about fart and forget just
talking about that the Google
implementation you don't have to be too
worried about retries or if you pie or
if the message is not delivered to the
server or if the message from the server
is not delivered to the client the whole
google cloud messaging implementation
takes care of of the retries takes care
of all that for you you don't have to be
monitoring if you're messaging if your
messages are delivered or not to retry
then you can monitor if your message got
delivered to make taken to take action
depending on and if the user gets or not
but you don't have to be babysitting the
message to make sure it gets to the
client that's the that's the fire and
forget part when I say it's no is
reliable is because there's no guarantee
that the message is going to arrive and
there's no guarantee of when the message
is going to arrive you can have a
setting to say if the message arrives or
it's going to arrive later than this
exact time then don't deliver it so if
it's if it's a notification that needs
to be delivered in a certain amount of
time if that time if that time spent
elapses and the message is not deliver
than Google Cloud messaging is get
through it gets rid of the message and
just doesn't deliver it if it's a time
sensitive promotion that you're running
or if it's a message that needs to be
delivered a specific time then if for
some reason the platform price of
delivery and it fails then it just
discards the message after a certain
time span and it's relatively easy to
implement especially of course on on on
Android so this is the basic
architecture of Google Cloud messaging
there's your client app of course
there's the GCM connection servers and
then there's your your why I have years
third-party app server which is your
server with your coat so basically
communication happens between your
and your server you can you can have
your clients communicate to your server
and then the server can take an action
to communicate to different device to
fake this sort of peer-to-peer
communication on a scenario like the one
I just mentioned where you have two
people on a messaging app and I send you
a message that goes up into the server
and then down to the Google Cloud
messaging platform into the other device
and then you can have a two-way
communication so I google has to
implementation the two implementations
the old implementation is just standard
HTTP implementation so that is not full
duplex and basically what happens is
your server sends an HTTP request into
the Google Cloud messaging server with
the JSON message so it delivers a JSON
payload and then that JSON payload gets
delivered into the phone and then your
server can pull the Google server to see
if the message God deliver or not so
that's that that's the basic
implementation they had that's the old
implementation and now they have a new
one and that's the one I mentioned the
beginning that it's full duplex and it's
based on XMPP so those of you that are
familiar with XMPP XMPP is a really
well-known chat protocol so basically
what you're doing is you're establishing
a establishing a chat session between
your server and the Google Cloud
messaging server so messages can come
back and forth from your server to
Google Cloud messaging and of course
those messages go down to the device and
then the device can respond and initiate
messages with your server to that XMPP
session so basically it's a chat between
your server and your device with Google
Cloud messaging as the middleman
relaying messages back and forth so
that's that's cool GCM si si si si si s
sorry I forgot what CCS stands for but
it's basically as I said it runs on XMPP
and it's a chat between your server and
your device with with Google Cloud
messaging in the middle
so the scenarios that push notifications
open up its specially two-way push
notification from the devices server too
there's a lot of use cases I mentioned
one you can use it to complement web
sockets but then you can use it to run
promotion you can use it to like we use
it to if two of your facebook friends
are going to an event we assume that
that's something that might be relevant
to you so what we do is we send you a
push notification saying hey so-and-so
are going to this event you might be
interested and then you can click and
purchase your tickets but there's many
other use cases that that push
notifications open for games if you want
to communicate like leaderboards or if
you want to communicate in-game actions
of course if it's like a fast paced game
Google Cloud messaging is not going to
be fast enough you're going to have to
try to use something like a web socket
or some of the other network discovery
protocols that we'll talk about later
but push notification is it's a nice
it's a nice option to communicate
between devices and especially from your
server to your device ah the new 13
studio so how many of you is using the
Android studio ok how many apps righted
ok so probably a little bit less than
half so Andres to use the new ide for
android it's based on IntelliJ by
JetBrains it's a really great idea it's
it's in beta right now but it's it's so
solid that if you have any concerns
about switching outside your switch of
course we all maintain apps so it's hard
to just say hey I'm just going to switch
but it's it's stable enough that you can
start thinking or at least drafting a
plan to switch to android studio and on
Android studio there's a really nice
things basically for people that are
just getting started you can just start
doing your google cloud messaging
implementation on the arm on the Android
side and then when the only thing you
have you have to do is there's a an
option and all the instructions are on
the you
the URL that's on the slide there's an
option on the tools where you can go to
Google Cloud Google Cloud messaging and
then you can say create server
infrastructure and it will create all
the server code you need for your google
cloud for your google cloud messaging
the server side on App Engine on but
it's now called Google compute engine
and then it generates all the server
code and you can immediately upload it
if you have a google compute account
google cloud compute account you can
upload it into google servers what used
to be up engine and then run all your
google cloud messaging code without
having to write a line of server code so
just by writing the under klein you can
do it on you can do it it's it's only
for basic scenarios of course there's if
you get if your your implementation gets
too complex this is not going to help
you but at least to get started it's a
it's a really useful feature and
especially if you want to try it out and
do like a real a really fast prototype
of of using google cloud messaging this
could be a way to just just get your
server code up and running fast okay so
those are the probably the three most
common although web sockets and and and
Google Cloud messaging are not as common
as I think they are going to get as more
people try to leverage all this
protocols and then actb of course is
probably the most common on all apps
there's another alternative that a lot
of people don't think about and is SMS
SMS it's it's a really powerful way to
communicate between apps there's no
middle men per se of course there's all
the servers from the from the cell phone
carriers that take your message from one
device to the other but it almost it
works almost like a peer-to-peer message
between devices so on low connectivity
scenarios or in scenarios where where
that what you need is just a small
payload of text
SMS is something that could be viable so
a lot of people don't even consider it
but for some for certain applications
that will discuss it's it's a viable
option and implementing SMS on anger is
it's relatively easy and we'll talk
about it the we'll talk about the two
sides and one it's really easy and
Google wants you to do it the other one
is not a tea not not as easy and Google
don't really want you to do so the
process of SMS it's mostly that is
asynchronous so you can send a message
you don't have to wait for a response
it's a ideal for low data connectivity
so if you have if the user has no data
connectivity at all or you can use SMS
to initiate some sort of requests or so
or maybe to combine it with another
protocol so for instance if they have no
data access you can try to send a push
notification for instance and if they
don't get it you can try to send an SMS
directly to the device of course it's
not going to be as clean as web socket
or as Google Cloud messaging but it's an
option it's mostly free in the u.s.
because messaging plans are so cheap and
even prepaid are prepaid plans are so
cheap and messaging is relatively cheap
here in the US and canada and europe too
ah but on some other countries it could
be expensive so it's something that you
have to keep in mind and in some
countries people are like ray limited to
the amount of messages to concern so
there's you have to be mindful of where
your app is used before you think about
SMS and then the final advantage of SMS
is that it works with with regular films
not just smartphones so if your app as a
component or your service has a
component that you still want to offer
two phones that are not smart phones but
SMS it's it's a good way to just keep it
like if the special leave is like a
messaging app you can to SMS you can
still keep people that don't have
smartphones in the conversation and then
eventually when they become smart phone
users fell down low you
the cons of course is that is
asynchronous so you can send the message
but you have no guarantee that the
message is going to arrive or when the
message is going arrived and I'm sure a
lot of you have had the experience of a
friend sending you a message a p.m. and
then you getting that SMS a 2 a.m. or in
the middle of the night so it
fortunately is not very reliable most of
the times the message arrived within a
few seconds or minutes but there's no
guarantee and the worst part is that
there's no way for you to to really know
for sure if the message was delivered or
not so that's that's a big downside it's
also a limited to 160 characters so for
you you can only really use it for
really small text based payloads and the
Android API is for receiving messages
are mostly undocumented so there's no
there's no documentation on the Google
developer well this was true as a couple
months ago before KitKat came out there
was no official page telling you how to
listen for an SMS message on a device so
we'll talk a little bit about how to do
how to send messages and how to receive
messages so when to use as a mess I I
talked about this already so how does
send SMS and this are the part of the
four lines of code that this
presentation contains so sending
messages is really easy all you have to
do is create an SMS manager which it's
really simple used there's a the class
gets you the full implementation and
then all you have to do is you say send
text give it the phone number there's a
set of parameters that I'm not going to
get into into detail and then you can
where I have hello that's where you send
your actual message so all you have to
do is just the phone number of the
device you're sending it to and that the
text that you're sending and that's all
you have to do so it's really really
simple to send messages to send SMS
messages from an Android device there's
a lot of use case scenarios for this you
like if you want to bury fly the phone
number that I on the phone number on an
android phone there's api's to get the
phone number but then we all know that
you can root your device and then you
can fake the phone number so there's no
way for the app to get the real phone
number C so for some reason your app
your server or your service needs the
real device phone number SMS is a great
way to capture that you can from your
app you can send it of course you ask
for permission from the user and then
you can send an SMS to something like
twilio or some some other server that
lets you receive as a mass and then you
can have a confirm phone number for that
user so it's something that you could
use and then receiving as a message they
said it's something that is not
documented by google it only became
documented recently on KitKat but most
of you are probably most of you are your
users are not running KitKat yet so if
you're going to use as a mess the
listening part of the SMS it's still on
documented so what you have to do is you
just have to implement a broadcast
receiver and unfortunately the phone
call or gannets is not very visible and
that broadcast receiver is going to be
listening for this intent this Android
that provider that telephony that SMS
received so what happens is when an SMS
arrives into the android phone the
operating system basically sends a
broadcast to all the apps saying there's
an SMS that has been received and then
you can grab the message and then
process it accordingly so if you put
some if you put a start tag or some way
to recognize or if there's a split over
if your messages are coming from a
specific phone number you can just get
the message and then have your app
perform a certain action the problem is
the user if once this when this happened
when the message comes into the phone
the user is going to get alerted by
their their SMS client so they're going
to see that that message came into the
phone so there's a few tricks that you
can that you can do
to try to avoid that to try to avoid
that situation so since you're
implementing a broadcastreceiver those
of you that have implemented broke of
receiving on your apps before know that
most productive receiver have a priority
so you can if you set the priority high
enough you could be the first step to
receive the the broadcast and then you
can cancel it which is not ideal of
course but Andrew it gives you that
option so the fact that that that option
exists it's something that's that that's
helpful on KitKat Google stop this why
because they have hangouts now so they
want you to be using hangouts of your
last year the foal SMS messaging client
and they don't want your app to the
cancelling messages that are intended to
go into into hangouts so for for KitKat
you can cancel that broadcast only the
the official SMS app on the phone which
is something that now you have to set on
on the phone settings it's the only one
that can cancel that brokers and it's
the only one that gets notified by the
operating system it's the first one
sorry that gets notified by the
operating system that a message has
arrived regardless of the priority that
you said on the on the broadcast
receiver so that's that's a that's a an
issue in on on KitKat and again I mean
it is not ideal that you're canceling a
broadcast that it's intended to go to
all the apps but it's it's a way for you
to to bypass that restriction of and
especially like if you're working on a
messaging app if you're building I don't
know Hanson or go SMS since all android
phones come without the fold SMS
messenger you don't want the user to get
multiple notification but every single
SMS client that they have installed on
the phone so basically what you want to
do is it's try to be the first that
receive that broadcast and then ah once
you get the the intent that in 10 has a
bundle in it and that bundle has an
array of SMS messages and that array of
course contain all the SMS messages
just arrived something else that is not
documented it's the SMS database there's
a sequel I'd database on your phone
regular C to light database just like
the ones you have on your app that
contains all of your SMS messages so
prior to KitKat you had access to that
you could get access to that SMS
database and basically you could delete
messages for the user so if for some
reason you were not able to get to the
message first to the broadcast receiver
you can basically just read it and if
it's just intended for your app you can
just delete it and then no other app
will have access to the to the well to
basically to that message on kid can now
Google remove that and since only the
full lab it's the one that gets notified
but it's the one that gets notified
first that a message arrived only the
full lab can write to the to the SMS
that database so unfortunately on kid
Kevin a bob we don't have that option
anymore of the of being able to read and
write especially you can still read the
SMS database but you can't ride or
delete messages if you're not the
default messaging app so that's that's a
downside but still SMS it's an option
that you can consider if the
requirements of your app are simple
enough and then finally we're going to
talk about now network service discovery
so network services service discovery is
not really a communication protocol just
like the ones that the other four that
we just talked about but it's a way for
you to implement real peer-to-peer
communication to a different protocol so
maybe one of the ones we just discussed
or something else that you just come up
with two sockets or maybe blue to
there's something else but what this and
this is basically Google's name of for
Apple bonheur which is basically just a
discovery protocol within the local
network so what network service
discovery lets you do is just you just
pay if you have a service to offer let's
say you're a printer and then you have a
printing service so you use basically
registered to the local network and say
if someone needs to print I am a printer
and I can print
documents so your app can on the local
network can use NSD to say hey there's
some documents I need to print who has a
printing service and then that there's a
the discovery lets you find the printing
service and then establish communication
true with different protocol and then go
on with your with your printing so it's
a it's a very useful way to create your
own protocol basically to have discovery
or some some sort of discovery within
the local network for your service ah
the best part is since this is using
Apple born you er it's compatible not
only with Android but with iOS OS X
Linux windows printers and a bunch of
other devices that implement the app
upon your protocol on Android
unfortunately it's only available on API
level 16 so most of you are not using
APA level 16 because most of our users
don't have it yet so there's an
alternative called JM DNS so JM network
service discovery and you can download
that it's it's so seldom source for you
can download the code it's just it's a
Java library but it's compact enough and
it's small enough that you can include
on your Android project and then be able
to to take advantage of network service
discovery in case you need it there's
other ways to do this if you don't want
to use real network service discovery
you can do a centralized checked in
server a fixed IP so you can have your
own server with a fixed IP and then you
can hard code that IP into your app it's
not ideal but on a pinch it's something
you could do ah but don't whatever you
do don't try to do multicast or
broadcast yourself to Java code there's
there's a way to do it in Java but it's
extremely slow and it's also a battery
drain because your app is going to be
trying to broadcast all the time and
trying to to ping other devices that are
on the network all the time and that is
going to destroy your battery so don't
try to do it yourself there's you can
either try to use this or use this
java library that minimizes the impact
on the battery so I'm going to talk so
those are the protocols I wanted to talk
about now I'm going to talk about two
specific use cases that we have here at
a member ID for those technologies if
you want to find out more about network
service discovery on android and on iOS
we have a blog post on our engineering
blog post and you can get the slides and
the link it's there or do you can just
google our engineering engineering blog
and then we have a blog post about
network service discovery and how do you
implement it on iOS which iOS has a
native implementation and then on
Android using the native on API level 16
and evolve or using JM DNS so here the
remember I we use network discovery
service for something that's called
gatekeeper so when we go out to events
we have a solution that we take to
certain venues that have a mid-sized
level a mid-sized number of attendees so
we take our own server solution that's
called gatekeeper tits out survey that
we install at the at the event and then
we can set up devices iOS devices or
Android devices add the different
entries of the event and then run them
with our app as barcode scanners so the
barcode scanners we can scan barcodes as
people go in and then the barcode
scanners use network service discovery
to basically discover that gatekeeper is
on the network and then communicate with
gatekeeper which is our own server
communicate every time they check
someone in so that all the devices that
are if you have a big event that has
multiple entrances and then you have
multiple devices at the different
entrances then all the devices can be in
sync of the bar codes that are being
scanned so if someone tries to go in
through this door with a barcode and
then someone tries to go through a
different door with the same bar code
this is the way we synchronize
the Barkers that are coming in and make
sure that the barcode gets only valid at
at once to using a network service
discovery the advantage of this is that
small organizers can run their events
without having to purchase expensive
barcode scanners they can use a cheap
Android phone that they can get for 200
bucks put our entry manager app and then
scan barcodes to their event without
having to purchase out expensive barcode
scanner well oh so the question is to
what's the advantage of using network
service discovery if I'm going to have a
service anyway that it's it's it's
basically offering the service the main
advantage is said and you don't have to
like hard code and IP address if you go
out in the field and you're setting up a
network on a local network you have no
idea what the IP address of the other
service is going to have and then it
could be one server but it could be five
or ten server so what network service
discovery lets you do it lets you
register yourself as someone that is
providing a service and then it lets
your clients weary the the network
directory for who is suffering those
services and then choose who to
communicate so if there's five servers
five servers running at the same time
then to network service discovery can
discover them all and then use them and
if for some reason that's not enough
when I add at sixth all of my abs
immediately can discover the sixth
server and start using it without me
having to make any code changes and put
that IP address on a list or something
of that nature so network service
discovery allows me to interactively
discover the services that are or maybe
maybe there's some service that runs on
a standard just like printers do
printers use a standard so I don't I
have no idea which type of printer is on
the other side the only thing I know is
that I need to print something and I
speak printing language so i asked the
network hey is there any printers here
yeah there's one right over there so i
can communicate with it send my
documents and then the printer prints
without me having to know anything about
that printer so that's the abandon
of using something like network service
discovery so gatekeeper is an in-house
illusion and it's something as running
on the local network and the idea is
that on big events you're not going to
have access or most of the time you
might not have access to the Internet so
this is a way to run it on the local
network without depending on so are our
entry manager app on normal you can run
it on on let's call it normal mode and
and that it interacts directly with a
website to http but if you're in a local
event when that's not an option then you
can run gatekeeper as a local ah so you
all you have to do is you set up a local
Wi-Fi without having to do internet
connection and for like an event let's
do let's say I have a I don't know a
food event there's really no reason for
me to to pay for an internet service if
all I'm going to do is just try to over
food to people and then if I have to pay
for internet in order to be able to
check people in it's not going to be a
very good a very attractive solution so
that's that's the advantage of
gatekeeper it's it's a low it runs on
the local network and that's why we use
network service discovery if you're
using something on the internet you
really don't need to do a lot of
discovery because you you already have
your URL and then finally and I
mentioned this already we use push
notifications to notify people when two
or more of their friends are attending
the same event so if you have friends
that are going to or friends that we're
coming here to to our talk tonight we
think that you might be interested in on
that talk so we notify you to a push
notification saying hey there's there's
Android event at eventbrite you might
want to purchase tickets and a 10 so
that's another way that we use some of
the sublet with discuss today so that's
the end of my talk I also wanted to
mention I think Tom talked about this a
little bit we're hiring Android
developers and iOS developers and mobile
developers in general so if you're into
said you can come look for me after the
session or there's a bunch of us that
are in the back if you want to come
after the talking and talk to us and and
if you're interested in what we have we
can definitely talk a little bit more
and that's it so if you have any
questions yeah go ahead yeah it's that's
so the question is about just as I
talked a lot about draining the user
battery draining well basically draining
the user data plan it's just as
important as the user Barry so a lot of
plans here in the US are restricted and
everywhere in the world and there's some
countries where is way more expensive
than here so what can we do to minimize
the impact we have on the user data plan
so yeah there's a lot being discussed
about this not only on Android but in on
mobile in general the one of the talk
that I I point you at the beginning the
one from Jesse Wilson about effective
HTTP gets a little bit of and in into
some of the details of maybe batching
calls there's a lot of there's a lot of
stuff being discussed recently I've seen
talks by people from Twitter about
things like batching your network calls
and basically how the network interface
works on Android so basically the
network interface on Android it has a
warmup period of I don't know this 20
milliseconds so basically when you make
one single HTTP call it takes around I
don't have the exact number it takes a X
amount of milliseconds to just warm up
the radio fire up the HTTP call and then
the radio doesn't go to sleep
immediately it stays idle for a little
bit waiting for more called suit to to
come and then finally after being idle
for for a few milliseconds it goes back
to sleep so all that period of time that
the radio is awake its battery and it's
it's data well mostly battery but it's
also data that that on that single call
that gets consumed so a way to optimize
that is to try to batch cold so instead
of making a call every time you
app needs data what you can do is you
can if you have the option of course is
try to batch some of the calls so that
they they get stored and then they fire
right away at the same time and then you
minimize the amount the amount of time
that radio is on because that time is
battery drain and then the radio is also
sending keep alives and and and things
like that to the servers and they even
the network servers so that's that's
bits that get counted on your data plan
so batching network calls there's also a
lot of discussion right now around proto
buffs and that's that's why I didn't
even want to talk a lot about HTTP
because talking about HTTP can get we
can stay here for a whole hour proto
buffs are a way to send data that it's
it's it's more compact as a binary
format is less verbose than XML or JSON
so basically you're sending a lot less
data and you're not sending when you're
using JSON or XML you're sending your
basically your data templates through
the wire all the time so all the
structure of the data you're sending
you're sending it back and forth all the
time even if you're sending the same
message multiple times you always send
that structure so proto bulbs abstract
some of that they're more compact there
a binary protocol so they're faster and
they're going to be cheaper for the user
because you're sending a lot less bits
through the pipe and that's going to to
minimize impact on yeah there's there's
definitely apps that are and Google is
trying to give you a lot of tools to
identify those apps so right now there's
especially on KitKat there's a ton of
options on settings where you can
identify apps that are using a lot of
location data a lot of battery a lot of
data so there's definitely apps that are
like definitely doing being chatty as
you said and using your your data and
your battery a lot but at it I think it
depends on NASA's developers to try to
be to try to be aware of most of the
stuff that we talked about today to make
sure we do a good job and we respect the
resources from the user both battery and
and data which is money for them if you
want a response type of
five seconds so the question is if you
want to response time of five seconds
which protocol to use well there's no
guarantee web socket is the one is going
to give you the fastest so if you're
going to do five seconds what web socket
can easily do a respondent on there five
seconds so it's going to be the fastest
it's also going to be the most
complicated and the most battery
intensive um so if it's a matter of
speed websockets definitely the fastest
if you're if you're talking for loop
looks of course g ZM can be really fast
but there's no guarantees so if for some
reason the message can get the liver it
can it can take several seconds so if
time is it's a constraint and you're
looking at something like five seconds
websockets going to be your option if
you want a minimize impact try to
combine it with different things so you
can you can for note for the not
time-sensitive sub you can use GCM and
then when you need the five seconds the
five second time frame then you can
switch to to WebSocket any other
question yes yes excellent question
excellent question so SPD is a protocol
that Google created it's analogous to
http it's implemented on Chrome you have
to implement a boat on the server on the
client android has no support yet ok
HTTP the library that i mentioned from
square has speed support boli has speedy
support too so either one of those two
will give you speedy support speedy it's
a more compact protocol than HTTP so if
you want to switch to speedy you can do
that but then both your app and your
server have to understand speedbit ok
HTTP and boldly they both do speedy
excellent question ok thank you very
much and I'm going to stick around if
you have more questions
so let's take</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>