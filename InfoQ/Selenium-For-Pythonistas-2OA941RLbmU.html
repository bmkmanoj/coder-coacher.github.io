<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Selenium For Pythonistas | Coder Coacher - Coaching Coders</title><meta content="Selenium For Pythonistas - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Selenium For Pythonistas</b></h2><h5 class="post__date">2013-06-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2OA941RLbmU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks grace
welcome everyone gonna be talking about
selenium a lot today first of all who am
i my name is Santiago Suarez Ordonez I'm
a lead back-end developer at sauce labs
I started sauce almost five years ago uh
I'm actually the employee number one
working from Argentina for three years
so that was quite a challenge um
Lenna moved to San Francisco a year ago
I venous mining committer for a while at
the open source project although 90% of
the code is Java there's still Python
stuff there there's still good stuff
others JavaScript as well um which is
kind of okay um I've been working with
selenium I'm piping for over six years
at this point and in my uh my set of
skills I would say that I'm pretty solid
on selenium Python and JavaScript on the
most
how about sauce laughs well we have
browsers in the cloud
we have a cloud of VMs with a pretty
high limits of parallelization and we
serve those browsers for users so if you
guys want to test using ie6 on Windows
XP or i-10 or Windows 8 or maybe Safari
on iOS 6.0 you can just fire your
selenium test pointing to sauce labs and
it'll all magically happen so you don't
have to pin your CPU or your ass low Mac
to get it done so you can get use the
power of the cloud for very fast browser
interactions and then move on we also
capture full videos screenshots and logs
of the executions so once you've run a
test you can actually go to our site and
see the full video of what happened with
the browser having the browser open
google.com and then typing whatever you
wanted to type and stuff like that I'll
show you guys the demo if you're
interested afterwards the point is is
selenium right now in the agenda first
of all I want to kill the myth that
selenium is a voodoo magic complicated
thing
that uh I don't know how it really works
is really unreliable and I don't want to
deal with that selenium is just a
library it's up to any Python developer
to use it or not
it's simple to use is reliable pretty
much every big player in the internet
nowadays is looking into our using
selenium to drive a client-side
JavaScript test so it's definitely
something you want to look into we're
going to talk about some testing best
practices and then some selenium best
practices and then some advanced
features and some more details about
selenium and then we're going to open it
for a Q&amp;amp;A if you guys have any questions
I brought some hot sauce I can't just
give them so if you ask questions you
get hot sauce um I only got sixteen
we don't need sauce it's just a
marketing move but it's actually pretty
alright um so first of all so when he
was great in 2004 that's almost standing
years ago it was a hundred percent
JavaScript it was just a piece of
JavaScript that would get injected into
a website and when drive the browser by
firing JavaScript events over and over
webdriver came around later to solve
kind of the problems that just simple
JavaScript wouldn't address like getting
around the JavaScript sandbox being able
to download files read multiple domains
at the same time and selenium basically
decided to migrate all the community to
webdriver so they call that selenium -
it was basically complete ditching the
selenium codebase moving to webdriver
calling it selenium and all the
committee and developers were happy
we're still using selenium good news is
selenium has become a w3c standard we're
still finishing up the drafts and I say
we are probably should some people are
very smarter finishing up the drafts to
make the selenium spec part of the
standard and that means that all the
automation bits all the parts that take
care of driving the brows are making
clicks and types are going to be part of
browsers and browsers will be opening a
port that you can talk to from any
client binding that are very thin and
simple to tell it to open a web site
click around get
get tax whatever you want to do from the
browser so that's really good stuff that
means that the Sony codebase were fully
disappear and become just client
bindings and and the code will be
maintained by what by browser developers
and it'll be robust and and I'll just
come out of the box with any browser
that you started using um so I want to
make a quick demo how do you use it I
think this will kind of kill the whole
myth and selenium being hardened so I
mean that thing that QA people do for
testing magic first of all selenium is
not a testing tool selenium is a browser
automation tool can you guys see them
all right so I'm just gonna open a
repple and get some stuff going here so
from selenium I'm going to import
webdriver well I'm some kind of UI
glitches here a browser equals webdriver
Wow and
done she ate create an instance of
webdriver chrome a browser comes up in
the back although I'm not really doing
anything in the UI I accentuate this
thing and now it's kind of a
representation of a browser let me move
the browser to this side so that this
looks easier so now I've got this
browser thing and I can tell it to get
Google comm for example you can see that
the call is blocking so as soon as they
call browser get is gonna block the main
thread in the repple and it's gonna make
the browser do some stuff load
google.com and then return so now I can
access actually be seeing the browser as
if I was a user going through the UI so
it can do browser that title and it'll
tell me what the current title of the
browser is and you can do fancier stuff
of course like saying search equals
browser I'm going to find the search
input so find element by name and I'm
gonna call it search so now I've got to
handle all the search and I can do
search dot send keys now I'm gonna type
Python meetup so as soon as I call that
it's actually tapping in the browser
real time and this is really fast this
is actually already built in in Chrome
so it's basically pythons and the HTTP
request to chrome and Chrome executing
whatever I tell it to do so now of
course I can do search I can roster the
title and it'll tell me what the new
title is which is Python meetup google
search and I can pull the whole DOM and
do all their stuff with the browser
itself so selenium is not really a
testing tool so lame is just a way to
interact with browsers from code an API
to browsers and it's very powerful um of
course testing idea today it's 99% of
the uses that you have for this kind of
stuff but it's still something that is
good for you guess - having your a
toolkit so I'm gonna kill it go back to
the slides
alright so what people use selenium for
and real browsers well testing of course
is 99% of it if you want to test a
website if you want to test a
client-side JavaScript off a website and
if you want to do across browsers a
cross browser there's no way to do it
without real browser
and nowadays the my name is kind of the
tool for that you can still use things
like phantom Jas I think it's a
JavaScript fake chromium implementation
but still if you want to test it or
Nighy what happens with the JavaScript
the JVM the JavaScript VM running on on
ie
what happens with it in Firefox the
stuff that you will need to do and real
browser side part a way to do it people
use it for higher level monitoring
sometimes you just have a lot of
selenium test I'll get you in a second
as people have a lot of JavaScript in
their websites and they just want to
check in real time in the production
application and the use of waiting for
that I've seen people capturing
screenshots with selenium so just open a
bunch of pages capture screenshot which
is part of what so any the selenium API
provides and then compare them across
browsers just to check for CSS issues
and stuff like that it's kind of a
headache to the that way but I've seen
people do it um there's a lot of people
doing clients high performance analysis
another part of the selenium API is
getting logging out of browsers so you
can actually start a profiler on the
JavaScript p.m. on the browser and then
do all the selenium stuff that you want
to do any kind of browse on interaction
and afterwards just pull out an har file
with the whole performance stuff at
Google test automation conference and
New York a couple weeks ago there was a
Googler talking about how they reuse all
of googles test selenium tests to
actually measure client-side performance
and all of Google Sites and it sounded
like an awesome idea is one of my 20%
projects to build that just
transparently on sauce so if you just
run a test you go other and you'll see
the performance performance dump without
having to really do much yourself and
I've even seen people use selenium to
just basically record screencasts just
drive a browser record a video of the
whole thing send it to your acceptance
TAS or the stakeholders of your project
or just put comments and audio and make
it a video online it's even a convenient
tool for that anything that would
actually be tedious to do by hand it's
always a convenience tool to use
about other libraries what do you think
about testacular which they renamed
karma karma I think I don't fully
remember what the implementation is but
what I've seen a lot around is just
JavaScript driving the browser
internally
I think the secular is just or karma
it's it's actually just JavaScript
embedded in the browser that's what
selenium one was there's nothing wrong
with it it's a it's cool that the good
part is that you only write the code
once it's just JavaScript and he works
in every browser but then taken to
practice in there's a lot of quirks and
browsers understand event firing
differently so typing in some browser
will no work in others or maybe doing it
with jQuery will not work well in dojo
it does work there's a lot of little
tricks like that and there's also a lot
of things that just fall out of the
spectrum that you will not be able to
download files or you will not be able
to interact with browser level pop-ups
like alerts alerts completely block the
JavaScript thread and there's no way for
something that is just running in the
JavaScript thread inside the application
for actually to actually interact with
that access it read it and so forth in
the same way you can't really do cross
the main and by that I mean you can have
a tab opening my website and another tab
opening Bank of America and have
JavaScript my website being able to
interact with Bank of America of course
you won't be able to read it your bank
account information for obvious security
reasons so browsers prevent that and
therefore any kind of JavaScript library
just will not be able to drive multiple
domains in the same thread so I'm sure
nowadays several years later there's
gonna be tricks to maybe circumvent some
of these but I think the point that
selenium is becoming a w3c standard it's
big enough for everyone to just confirm
or purchase just accept that it's a way
to go every browser vendor accepted it
Google already implemented in chrome the
Opera guys implemented an now extent
presto engine I think is the Opera thing
that they replace with chromium
Firefox is building it into Firefox and
that's actually the tool that they're
using to test Firefox OS which is
new mobile Firefox platform well I've
got a service I can recommend cold sauce
labs we actually uh we actually run
selenium tests in parallel in the cloud
but if you don't want to run things
faster locally selenium green is a tool
to create your own load balancer on top
of selenium with multiple machines each
is going to be running a browser another
option is to use phantom Jas there's a
driver for phantom Jas in selenium so
it's going to be a headless chromium
thing it's not legit alleged but it's
more legit than say H I think HTML I
don't remember the other fake browser
yeah HTML unit and stuff like that
mm-hmm
we're gonna have time for questions
later as well but let's focus on testing
cuz that's where you what you guys are
here for so I have some advice for
testing this is not purely selenium
stuff but it's always good to get
reminded of the fact that automated
testing is just coding the goal is
different the goal is to test another
application but it's still code and you
gotta apply good practices for that code
as well if you want to make it
maintainable robust and not just be a
headache that you're gonna abandon three
months in the project so don't repeat
yourself I think everyone here at this
point has a hazard what the DIY means
and and what's going to save you guys
from let me show you an example in the
testing land of why you want to keep
don't repeat yourself in mind
okay so I'm gonna make that bigger
probably is that okay cool so this is a
good example of a test case I don't know
if you guys know the unit test module
already it's the way you write tasking
Python and so when you just pick it back
from that learning is just a library
that you put inside your your unit test
so in this in this specific test I have
two tests one that I'm going to type my
name in Google and now I'm going to try
to find if there's the link with my
website in the href so I'm just trying
to make sure that going through the
Google UI I can find my site on the top
on the first result and another another
test is kind of simpler but it's going
to google.com typing soft laughs and
then searching that sauce you seen the
browser titles so this is a bit of more
of a making sense to use selenium kind
of stuff for the other test you could
simply use some kind of Google API
without having to pull up a full browser
for it well in the other one you do want
to check that the brazo tile gets
replaced and that's done by JavaScript
and there's no way to do it without a
real browser but if you compare this
test let me make it a bit smaller if you
compare this test
let me show you what they're actually
doing step by step step one we're
creating a browser instance as I just
said by hand step two we're getting
google.com step three we're finding the
query input typing my name by sending
keys submitting and then we're waiting
for the results to come up because of
course asynchronous JavaScript browser
stuff you got to wait a bit for it to
come up and I'll show you how that
happens later and then we find all the
links in the results and then iterate on
every link pull the H ref out and check
that it's out if son if my website is in
it I break the for loop if I reach the
end of the for loop I don't know if you
guys know what an else means and a
folder it means you reach the end
without breaking and that means I didn't
find my site so therefore fail and as
soon as I fail supposedly I'm gonna call
browser quit and the other test you'll
find a lot of very similar code I'm
basically saturated a browser getting
google.com type in
typing sauce labs submitting waiting for
results and then asserting that sauce is
in the browser title and then quitting
so there's a ton of the application here
and what's the problem gonna be with all
this duplication well first of all how
about if Google changes the locator to
find the search field the queue here by
name well if Google changes that I have
it hard-coded in two places so I
basically have to go to every single one
of my tests and replace it if I have 500
tests it's gonna be headache for sure so
you want to take that out there's also
something else that is being repeated
how are you stand abrazo in both I'm
instantiating Google Chrome at the
beginning of the test and I'm setting
implicit weights which is something that
I kind of want to use across the board
so I could totally take that out into
the setup of my tests both tests are
using Google com
I could also take that out that source
also hard-coded thing along the ways and
there's also even duplicated logic that
is multiple steps
I am Hart I'm duplicating the way I
search for something in Google if Google
decides to create two fields and maybe
having you click two buttons in a row
well I'm gonna have to go to every
single test that is implementing this
logic of typing submitting waiting and
replace that and fix it which is a it's
very painful so this is a kind of a
fixed version that I just wrote basing
the same logic where I'm implementing
first of all setup and teardown if you
guys don't use this in your own tests
you better do their methods their
built-in into the unit test test case
class and they're gonna get run before
and after your tests independently or
whether they pass or fail so I can be
sure that driver browsers acquit what we
call independently of whether an
exception is thrown in my own test on my
test fails or whether no exception is
thrown on my test passes
I'm also separating the browser
instantiation and the implicit weights
out and the opening of google.com and I
also factory something else out and it's
the logic for searching something on
Google and waiting from the results to
come back I call it search and as this
is probably not the right place to put
it you probably would have a framework
at this point which is in this
when in selenium land is called pager
object model we'll talk about a bit
later but it's basically just pulling
code out and targeted with a name that
it's very easy to read when you read
actual tests so I'm pulling all the
searching or waiting and if you read my
tests now they're very very simple
there's no duplication across the board
so in the first one I just do for link
in searching my name
check all the link attributes and stuff
and pass if nothing if the website is
there and in the other one is super
simple just search for sauce labs and
assert that sauce is in the title
there's no duplication fixing any kind
of changes on google comm will be just
as simple as going to the right method
and modifying it so keep that in mind a
duplication can happen in test and it
actually happens a lot
okay another tip that I want to give
even though it doesn't really apply to
selenium because selenium is not really
running in the same thread as the
application is so you can't really mock
stuff around but I found mocking so
awesome that I just wanted to dedicate
like 15 seconds to it if you guys are
running unit tests or functional tests
where you are in the same thread as the
application mark all the things mark
anything that is not under your control
if you didn't write that piece of code
you don't have to test it right now
so ride your test very focus on the
piece of code that you've wrote and
anything else I could make it slower or
less reliable mock it out and make it
return a default value it is gonna be
sacrificing coverage of course but if
your tests are unreliable you may as
well just not have tests you can't have
tests on you can't trust on they need to
be a hundred percent green when your
application is working correctly and
they need to be read when the
application is not so marking anything
and anything out that it's not under
your control and it's not really part of
the application is crucial for this I
actually it's a funny story I was
actually trying to write an example on
how to mock the open built-in I spent
like three hours and I decided that
she's not doing cuz it it's it's a
headache to use mock once you get used
to it you can kind of fly with it but
it's it's not fun
but it's very powerful so there's no
example for this another thing I want to
I want to talk about is writing small
tests the focus focus your testing what
you want to confirm don't write a test
like this I don't know if you guys can
see that but I can make it easier
don't write a test that does this test
sign up blogging search out the card
check out and log out I've seen this so
many times you'll think it's awesome
you'll think it's it's very fast because
that's all the things together some
chunking stuff together and I'm saving
time but reality is that there's a lot
of drawbacks to this and let me talk to
you about some of those um first of all
one failure in this test will basically
block all the other workflow all the
rest of the workflow from going through
so your test results if let's say you
break the sign up your application your
test results all don't say is you broke
a sign up I don't know what's going on
with the rest of the application I just
though that sign up is broken so you can
spend 10 minutes to fix the sign up now
soon as you commit you figure out that
logging was also broken and it was
probably a very similar bug but you
didn't get to fix it because you didn't
even get to know that it was broken so
writing isolated test one for every
single feature in your application will
give you a very detailed report as soon
as every bill ends tell you what's
actually going on and there's a tip on
how to do that then I'm gonna share in a
second on our disadvantages this test is
gonna take a while
tests that go through a lot of different
things and this even scales and unit
test level it's not just the one you
mean Shalini was just more visible when
you write a unit test that's 25 things
at a time yeah it's gonna take 4
milliseconds instead of one maybe no one
really cares well when you have
thousands and thousands of tests it
actually starts becoming important and
you actually start wanting to paralyze
things more I'm breaking pieces if you
break it a huge test doing fine things
in pieces and you run them in parallel
you'll get your results way faster and
they're gonna be a lot more independent
from each other which is what you're
looking for avoiding to test
dependencies this is very common
especially when you have hundreds of
tests across the board inter test
appendices
are generally caused by execution order
when your tests are all running in the
same order every single time that's
gonna gonna start making people lazy I'm
gonna start making people rely on data
from different tests for my own tests so
I don't have to generate if I am running
my tests after these accounts being
signed up well I don't have to create an
account myself I can just reuse that the
problem is that when you increase
paralyzation or when the execution goes
randomized then thinks is it gonna start
failing because the data that you rely
on it's not there anymore or is we
modify about something else and data
dependencies are very very painful to
discover and address so the main advice
is make sure your tests are running in
in random order don't enforce order
that's the worst thing you can do and
I've seen so many issues and pull
requests and testing frameworks like
know some PI tests saying make it run in
order I want to be able to run this
first and that's that's not a good idea
at all
never use data sets more than once I
never use the same data set in in
different tests create your data your
data before your tests start in the
setup and then destroy it in the
teardown so that you're sure that your
stuff is fully isolated if your runs on
its own is gonna work if it runs with
100 tests more it's gonna work as well
and another nice advice is wipe your
database every time your bill runs so
you want to start from zero you want to
have no kind of preconditions that you
can control being the database before
because then you migrate your staging
server and all your tests break that's
the thing you're gonna abandon selenium
are you're gonna have on the testing and
CI and you're just gonna go with it and
good luck here's a good example of a
data dependency kind of a purpose
created very simple where you basically
have the test start and then you have a
test that creates the account for the
user a and then you have the test that
logs in with that user and changes a
password and then how to test that
checks that you can close the account of
course running this in parallel or in
separate order it's gonna break things
and it's gonna take you a while to
figure it out in this case of course it
would be very obvious but when it comes
to complicated test Suites with a lot of
data states it gets really really hard
and it can take a lot of time
another advice I have is run your test
automatically run your test as much as
you can I think everyone here has
already heard of continuous integration
I don't know if you guys have heard of
Travis it's kind of the new cool kid in
the block especially for open source
projects you just push to get having
Travis figures it out by itself and runs
your tests you can tell it to run on
different versions on Python and it runs
in parallel it's it's really awesome you
can use Jenkins if you're all school you
can use pre commit hooks if you want to
get the feedback in the passer what's
important to know is that the shorter
the feedback loop it is to a test
failure the faster and the easier it
will be for you to address it right if
you break some code today and you push
the build or you push to the repo and
two months from now you hear that
something broke you will you will never
call that being yourself
you will not it was not your fault you
have no idea was your change and if
someone confirms that it's your fault it
will take you days to figure out which
change in the last two months will seem
volume breaking that and which line of
code I need to fix on the other hand if
you get on a pre-commit hook or in a
build 30 seconds after you wrote a
commit a failure it'll take you seconds
to actually go through it and fix it and
at least know what's going on
any questions cool
skip I'm going another advice I have
I've seen this especially in big
companies the bill is never really green
the bill is kind of okay-- green but
it's never really a hundred percent
green and that to me is kind of a snafu
it doesn't really work that way if you
have one test on a 5,000 test failing
something's broken
it's either the test or the application
which is a lot worse but something's
broken if you run it again and the whole
thing passes it's even worse because the
application is flaky so it's hidden so
people will not see sometimes or people
will sometimes and your developers will
have a really hard time to address it
but whenever something breaks it's gotta
be a priority zero for your developers
you gotta stop development you're gonna
be complete and able to push any new
features and you gotta fix that problem
now you're gonna say have 500 developers
in my company
and blog 500 people because one of them
broke something well there's different
ways to address all this you can have
multiple bills
you can also quarantine test it's
another option you can tag it test and
tell it well this is quarantine so we're
just not gonna read run it anymore
because it's flaky we have it saw
something we call flaky Fridays every
couple of weeks we decide well our stuff
is we got way too many flaky tests so at
this point we should actually go to them
and address them and fix what's going on
um
another option is instant reverts so if
someone pushes something and he breaks a
single test just revert that commit
instantly and assume that's the
responsive other committed responsible
for the failure there's different
approaches based on the size of the
company but what's important is you
gotta aim for a hundred percent green if
it test fails ten percent of the times
may as well not have it cuz it's not
giving you any help whatsoever
having developers lose faith on the bill
is probably the worst thing that could
happen to the quality of a company um
and we've all been there I've been there
as well I'd be like oh fairly the bill
rerun I'm gonna go get a coffee and then
it's gonna give you get real late and
that doesn't know the way you want to
address quality especially on a serious
company um and this is kind of what the
kind of bill that you really want to
avoid that's that's our bill today but
it's blue a lot we're going through a
big change and the bill is not really
doing this job right now but the thing
is you want it to be 100% blue with a
couple rats here and they're isolated um
the last advice from the testing set of
things you want to make writing tests
extremely easy that's the goal to
quality in a company you want to make
your developers be able to write tests
with three lines of code or with two
lines of code or maybe even better with
one line of code if writing maintaining
and fixing tests takes only focusing on
the logic of the test that's like that's
the place you want to be ad if writing a
test for your application takes a
developer writing seven lines of
boilerplate code marking a couple
library since
the two hours that it takes to mach ride
and doing all that kind of stuff no
one's really going to write tests and if
you force it it's even worse they're
going to write poor quality tests
they're gonna do it quickly and move on
you want to take care of all the
boilerplate you want to put your
smartest developers writing frameworks
that the rest of the developers will
just consume to write tests
I want to subclass some kind of test
case thing like I was talking to Julian
from from Django he said that he wrote
the live live server test case which
subclasses unit test and basically
starts a web server for you so that you
can write selenium stuff and heat an
actual running web server that's the way
you did testing you want to hide all the
details on the tests outside to a
framework and you want the developers to
just as soon stuff it's gonna work and
just focus on the lines of code that are
on the actions that happen with the
application and in the logic any
questions mm-hmm all right let's talk
about so many best practices
most of these are also good coding
practices good testing practices
whatever you want to call them test our
code but I want to highlight them
because they're selenium oriented as
well number one do not use selenium do
never use selenium if you can avoid it I
think at this point you've all heard
when you have a hammer everything looks
like a nail
yeah I tend to see this a lot with this
a legend crowd they know how to the
selenium so they want to use selenium
for everything they wanting somebody to
boot up a VM and hit the start button
windows tool and start ie and then
download a PDF and open it and selenium
is just gonna drive browsers this is
more libraries meant to automate
browsers if you have a way to avoid
using selenium please do because
selenium is not the right tool for you
good software engineers you know all the
tools that they have at their disposal
and they use the right one every time so
if you want to do things like testing
the the status codes of your application
testing that your application returns
200 on every page
don't use a real browser for that just
hearsay should EP live our URL live your
- especially if you're in the Python
world you got plenty of tools for that
stuff
of course you got requests which is the
right tool if you want to hit things
like testing plain HTML if you want to
check that your website's homepage has
the right amount of content the right
title don't use selenium don't use a
real browser selenium so when you dry
see full browser with rendering engine a
java virtual javascript beltram virtual
machine
it runs on top of an OS that is
generally unreliable if you're doing
Windows don't use selenium is slow and
bulky it is it is a necessary tool for
testing things like cross browser
client-side functionality and we all at
this point have that but if you can
avoid using selenium use the right tool
um this is what we were talking about
before that came up in the question
generated application state a lot of
times I mean any complicated a decently
complicated application will have a lot
of state in the browser
I'll based on cookies and what's going
on through the UI so for example if I'm
testing amazon.com of course I would not
be able to check out the shopping cart
if I don't have anything in the shopping
cart or I will not be able to get to my
orders if I'm not logged in yet and all
this stuff is browser state then you
need to have and it's very time
consuming if you want to make your tests
very atomic you want your tests to focus
on the checkout you don't want your
tests to go through the login to adding
anything to the card and check in any of
that stuff if you want your tests to
just open the checkout click on the
button in throw me whatever JavaScript
you guys have and then confirm that it
works
that's kind of the ultimate test right
it's gonna last 10 seconds instead of
minutes and minutes and if the login
breaks your test is still gonna pass if
searching on the card still breaks your
test is still gonna pass and you're
gonna know okay the checkout is not
broken at least um the way to do is to
do this is uh I mean there's a lot of
ways um the easiest one and I'm gonna
show you an example actually cuz why not
okay so here's our dev website this is
my version of our dev website and of
course if you want to log in you cannot
because oh there you go you get to the
login and there's a username and
password and submit and if my test
relied on logging in that would have to
load this whole huge page with the
header the footer and Google Analytics
and and the Twitter button and the
Facebook like thing and all that stuff
that makes a browser very slow and it
makes your test very unreliable and this
is not what you want to do what you want
to do is have something like this which
I'm going to show you very detailed task
log in admin all you want to do is have
your test type that and as soon as you
do it you're logged in as the admin no
security no password no interaction with
the UI no don't
loading the DOM and spending time
getting the facebook like button or
anything like that you're generating
application state very quickly very
easily and in the browser so if I had
your answer every single interaction
with the application using this I would
be able to run my test in ten seconds
just load five pages with no content
other than just happened you got an item
in the card and and you got to the
checkout page and then I can make my
browser go to the account page and now I
logged in and it's awesome of course you
don't want to deploy this to production
just make sure you don't how do you cert
that you're generating the correct State
ah well that's tricky right you're
you're faking application state at some
one way or another it could differ at
some point the way we're doing it is
we're calling the same controller
methods from the fake API and then from
the original API at some point they
defer of course but we try to put as
much similar code together as we can so
we only this they only differ in the
rendering of the template and other
details like that it's not ideal but
this is all about trade-offs there's no
there's no perfect solution or Silver
Bullet you got to know what you're
trading what you're sacrificing and what
you're getting you get a shitload of
performance and sacrificing coverage how
do you go you're testing the same go
past you are not you're definitely not
testing the same code paths of course
you want to have a test for logging in
that's that's for sure and that test is
gonna go through the whole you
I is going to type the username and the
password is going to check that you go
to the admin page but all the tests are
not testing the login did not need to go
through that through that flow it's
actually completely redundant and
unnecessary so you can skip that flow
for all the tests ago later and for the
test that needs to do the actual login
yeah I'll do it that way and get it
there's like even smarter stuff you can
do you can actually if you take all this
to a framework you can make your
framework with a switch automatically
make it go through the right UI if
you're in like a special build that you
have that you wanted to go through the
whole UI so : log in will actually log
in through the UI or you could have any
dev setup be like okay I'm running in a
developer's box so log in will actually
go through the fake logon it's gonna be
faster so it's a matter of trade-offs
right how much you want to sacrifice in
coverage and how much you want to gain
in performance yeah what's your best
practice for you just hire smart
developers and actually but that should
be it
mm-hmm it's a lot of trust it's part of
the trade-off right you're sacrificing a
bit of security on um on the improvement
of making your tests reliable and fast
and improve I mean improving your
developers lives basically um you could
write tests I mean we put everything on
there test every magic URL to be under
test and then we check that we cannot
open any route that is under test it
depends on how much of a commitment you
want to make of course if you're a gmail
comm there's probably a bit of more
hoops you can have the jump to get this
through the goal line but if you're a
start-up and if you're a three employee
company there's no reason to really uh
not do this and get the games out of it
all right hmm
um another tip I have and I think I
coined this odd sauce we call it guinea
pigs and they're basically this it's
taking a complicated widget out of the
whole workflow of the application and
putting in a very simple blank page and
it's kind of like the same thing is
generating application state by avoiding
the whole thing and just putting a
simple plain page and let's use the
example of testing gmail.com and and you
want to test a compose thing for an
email where you have all the making bold
and italics and linking and stuff well
if you follow my approach you're gonna
write a single test for every part of
the UI so the bolding the Tali C
underline every one of those buttons
will have its own test and probably have
multiple tests for different parts of
the behavior that means that you're
gonna have to go through the whole
workflow a lot logging in composing even
generating the application state could
not be the most efficient way to do it
so I like to just take stuff out like
like such a widget completely outside of
the page put it in a blank of the side
put in a blank page and then run your
full battery of tests your 700 tests
hitting every single button in every
single case and then for the rest of the
times you actually use a widget in the
workflow maybe write a smoke test or two
tests I check yes the integrity is okay
so it's probably working as well as the
one that we took out of the page again
you're sacrificing a bit of coverage
you're getting a lot of performance
gains um so when you kind of ask where
your flash objects it doesn't really
flash it's just a black box that you put
in your page in same way uh us canvas
nowadays is or Silverlight or god forbid
Java applets and stuff like that it's
just a black box embedded in the browser
the good news he said for Java for flash
there's a library that you can embed in
your Flash application and what it will
do is it will open the door for
JavaScript to interact with the apps so
JavaScript calls the special API that
this library opens and then inside the
flash thing there's gonna be clicks and
types in the same way so so when you can
do JavaScript and if you put a library
that can listen to jouster your
none and there are several libraries
they're all open source one of the guys
working at sauce
Adam Christian was involved in one of
the projects than they'd flash
automation in the past and god he hates
flash another tip I wanted to share is
to paralyze your test as we were talking
selenium is slow
there's no real way to speed up actual
browser running an actual OSS in actual
bm's
so running in parallel nowadays
competing powers a lot cheaper than
developer power I then developer time so
just cut a lot of VMs put the mean
Amazon ec2 give us some money and we'll
take care of it and this is how you do
it in let me see if you guys can see
that this is how you do it in Python
land this is knows I'm a nose guy but
you can do PI tests as well just call it
with - - processes the amount of
processes that you want no sass is a
special process time out thing the
default value is set for unit tests so
the process will actually tell time out
like 10 seconds after it started so you
want to pass a more reasonable process
time on for a real browser um something
to keep in mind is generally when you
run unit tests in parallel you want to
focus on how many cores you have cause
unit tests are very CPU intensive so
increasing the parallelization to like
20 if you only have two cores it's not
really gonna make you too many gains
it's probably gonna be counterproductive
when it comes to selenium so learning is
very very CPU as IO driven and i/o bound
sodium is making API requests to a
remote process every time you make a
command so when you call click there's
an i/o going to the browser and telling
a click on this element and then the
browser responds ok the element has been
clicked and stuff like that that could
go through the whole internet if you do
it on sauce or you could go locally if
you're doing your own laptop the thing
is it's all i/o driven so increasing the
amount of threats to more than the
course your laptop has is completely
safe um nothing in my own MacBook Pro
not the air about a pro I got to run
six browsers in my own laptop before
things started getting a bit wonky but
yeah
think about BMS think about the cloud um
page object models any questions all
right I have to be taking a lot of hot
sauce with me today page object models
pay traffic malls are simply chests an
abstraction layer on top of duplicated
code on the same way I had abstract
abstract at a search method that is
gonna take care of interacting with the
UI and that from my test I can just call
and ignore what's actually going on in
selenium page object models are just
that it's just a nice abstraction on top
of your UI you want it to be very tied
to the to the actual application logic
and let me show you an actual sauce test
for this cuz that's how cool we are
I can actually show you our code at
least at s1 um so I'm gonna open alright
so in this test we're actually
instantiating a job space object and you
we're sending it to oh you guys can't
see this stuff mm-hmm
now you can let me know if it's too
small so here we're instantiate a jobs
jobs page object we have a jobs page let
me show it to you real quick so this is
what it looks like it's all full of red
but that's part of my dev setup so this
is where you have every single selenium
tests on you run today and they'll tell
you their status and the environment
that they run on and you can filter them
by name so I can say Python and it'll
only show you the Python ones and you
can do even smarter filters like tags
and and the platform so I only want to
see the IE 10 tests and so forth so we
got a lot of JavaScript running here and
we got a lot of selenium tests tested um
so let me show you that we have the jobs
page and well a very simple test
basically called job space that open I
need to tell C which log in to use I
other tests have been more complicated
opens it and it ways for the jobs to be
fade fetch from our website a bit
smarter test it's actually doing more
stuff it's actually sorting it so you
tell you pull a widget out of the job
space the actually jobs widget and then
you initialize all the filters and then
you sort and then you check that o
mousse and you pull the topmost job and
then you sort it again and they pull the
topmost job again I mean they assert
you're certain they're not equal it's
not an awesome test but at least it's
getting to the point that I want to make
and that is there's no selenium code
whatsoever in this test you don't you
didn't see a single selenium interaction
in my whole test and that's really good
that's that's the way you want to write
your testing frameworks you don't want
99% of your developers who have to
understand the selenium API how do we
interact with the Dom how to click how
to type you want dedicated specialists
to do that part and you want to put the
rest of your developers just consume
from a very simple framework where they
can think in application logic terms so
I can say open the jobs page and sort by
ID and then pull the first one and then
watch the video there's no selenium self
there's no clicking no sending Keys yeah
but for developers very very easy to
write and it's very very easy to
maintain
whenever the workflow changes all I need
to do is go to the place where we sort
and change the logic there and all the
tests will pass out of the blue so page
object models it's just a fancy name for
factorize your code in good ways and put
good API C in front of developers which
you guys already do hopefully George
well basically all you're doing is
providing the library interaction for
you
yeah then your test is the logic mm
exactly you're providing an API to your
application logic and the test consumes
that and it's actually really there's a
lot of frameworks nowadays I don't if
you got sort of cucumber in the Ruby
land I think there's lettuce in Python
that's kind of forcing you to do the
same thing you kind of forces you to
write in English what you want your
application to do I'm not a big fan of
writing code English
but there's a good thing to that it
forces people to think higher level and
a framework like this does it as well
and it also enforces good syntax and
Python code which is also awesome so I
kind of like this as a replacement for
things like cucumber or or any of the
other frameworks where you describe a
BDD way yes the question is if you come
from a from a company where you have a
salty QA side of things and you're
signing an application from zero which
are the top three bullet points that you
would say are gonna pay the most when it
comes to testing right more testing so
how do you make your application more
testable number one make your developers
write tests that's this basically that's
gonna pay off so much if you tell them
you guys have to write the test for the
application they'll take care of the
application being testable for their own
test to to write to run if you have a
big company and the QA team is separated
from developers you're gonna have to
start enforcing good coding practices on
the UI of the application things like an
expressive Dom or you everything has
like an ID especially in a unique ID
Thanks I think that's basically gonna
pay off as much keep the UI the
identifiers in the UI solid so don't
change them when you change the
application side of things and keep your
QA on your development team very tight
because they want to collaborate you
don't want them to be enemies as if
being four years back where the QA are
the people that are finding out the bugs
of the developers who hate QAS because
they're not technical you want it to be
a collaboration nowadays lean companies
are moving towards we all do everything
we're all a team and we work together in
and that really pays off when it comes
to testing and therefore quality are
there any favorite javascript libraries
or frameworks that you find are easier
to build tests against like uh
templating libraries different
interaction libraries um at this point
in my life I don't write tests as much
to actually tell you what the new cool
kids in the block uh how friendly they
are well just mean it's kind of a lever
to write JavaScript unit tests not
really to write the JavaScript UI fi of
an application I know that exp and all
the libraries based on the XE had a lot
of features cuz they would because they
would generate identifiers in the UI
dynamically therefore it was just a very
painful process to actually find
elements and know how to interact with
them so it would take the best tool that
a QA guy or selenium writer has which is
solid ID Sonny would randomly generating
every time the page refreshes so it was
it was very painful at this point I
think selenium has matured enough and
libraries have gotten to the point in
which best practices on the UI layer are
pretty much enforced across the board so
I don't think I have any favorites from
what I've seen around George just want
to follow up what developers can
actually help you do to make over the
site testable is actually having some
backdoor way of introspecting the data
objects that are being passed through
the web browser so you might be
inspecting the Dom but in order check
whether the Dom state is correct you can
actually check the data up the data
state and the data state is something
else other than what your Dom is
expecting then yeah and that actually
almost bringing the test the piece of
code they are testing out into and only
your own HTML page because you just
actually mock data objects and then have
it influence the Dom yeah and then you
can remove your whole application server
from from the whole script yeah nowadays
I think we've all gone into the pointing
which we understand that gray box and
white box testing is a lot better a lot
faster and a lot more reliable than
black box testing where you don't know
how your application works you at sauce
we even reuse the database layer for the
tests and for the app so if we need a
new account we created with the account
the username model that the application
is going to use and if we need to check
for it we check for it with the same
layer so the code is just Python code
and it's one of the advantages of having
your tests and your application written
in the same language you can just share
code across the board and use it alone
so yeah using the database is a huge
tool to actually check stuff fast
reliably and not
having to depend on the UI for
everything at the end of the day for
coding a task the UI is this lowest path
to any destination you want to take a
generating application state checking
the application content URIs always the
slowest that's because humans are a lot
slower than actual machines that those
are the ones that are gonna be running
your tests so XPath used to be the way
that interact finding elements
interacting with elements it always
seems sort of unreliable to maze it
pretty much frowned on they say Zoar um
I am famous in this learning community
for writing for giving a whole talk on
why X bus Xbox xpath sucks and why CSS
is a way to go now we seem to selenium
one days where when selenium actually
use javascript libraries to find
elements using XPath and CSS so Sonia
was using Sissel which is the jquery
thing and that was super fast and for
XPath they was using something else
open-source but it wasn't really that
good
um nowadays both are gonna be done by
the browser the browser's already came
with the standard that is a CSS query
CSS selector or CSS query I don't fully
remember it someone who just relies that
lyza to the browser and the browser
takes care of it so both are gonna be
just less reliable and just as fast i
still lean towards the SS just because
no one really knows what XPath is and
how to write it except for selenium guys
so your developers will really know how
to write CSS everyone writing an
application on this point had to style
some element in the page so CSS is just
going to be more readable for most
people in the company it's not as
powerful as XPath but it's only like 5%
or the last two percent of the cases
where you actually need to do things
like going down a tree and then going up
and going down on the other direction
that you actually need XPath for the
rest C except CSS is alright it is more
readable and where people will be able
to do it so I tend to lean towards CSS
just with that cool thank you all right
I'm gonna keep on going with the slides
but it saved those questions I'm doing a
lot of mirroring here
hmm all right
another trick use JavaScript calling
execute scripts you'll be able to get
right into the JavaScript PM inside your
application the JavaScript contacts
inside your application so you can check
stuff like global variables in the
window you can even call events if you
need them you can check that Ajax is
going on you can do pretty much anything
and this is kind of gray box testing
again you're not really clicking and
typing but who cares if your test passes
and it's really giving you the coverage
that you were aiming for calling
JavaScript is great and it's a great
tool that you should keep in mind for
you for yourself um another piece of
advice I had is using weights for your
tests you really want your tests to be
able to handle a synchro asynchronous CT
your app you want to be able to handle
Ajax and stuff that it's not loaded at
the time you need it and that happens a
lot in websites right I click your
button and something renders and if I'm
fast enough the thing that renders it's
not gonna be there at the time I'm
looking for it human beings tends to be
slower than machines so it's not a
problem for us we know that when we
click a button something will happen
selenium is not a smart and you got to
tell it how to do it so here's a quick
example ahead as well so the first one
is using implicit weights it basically
tells selenium to implicitly wait for
elements when they're not available it's
only cite selenium its built-in and it's
implicit that's why it's called
implicitly wait
it basically means whenever I'm trying
to find an element in the page if the
element is not there it'll make selenium
recheck every half a second for the
element to become available if after
five seconds or whatever timeout you
pass it is not there yet your test will
fail something whereas an exception and
the stuff will move on but if the
element appears one second and a half
later silane will return out a second
and a half and your tests will keep on
going so your test is now a lot more
flexible when your application is slower
and it takes three seconds that says
well still passed and when the
application is fast and it only takes
the split second the test will be fast
as well
that's the the easy way right but
selenium is all about explicit is better
than implicit so selenium provides a
webdriver weight class or helper that
you can use and you basically are being
explicit about the fact that the element
will not be there as soon as you need it
so you instantiate a new webdriver
weight you pass it the selenium browser
and you pass it a timeout and then you
tell well wait until the presence of
element locator but located by ID search
and that will explicitly wait for you
and return the search as soon as it's
available
so it's basically doing the same but in
this specific case you do it by hand
onion the other one you set it up front
and every single find well automatically
or smartly do it for you whether you
want to do it explicit or implicit it
depends on you and how much you you
applied to the center Python I sometimes
like my test images be shorter and
simpler but it really depends on you
another big part of the selenium
workflow for developers is to debug
failures a 99% of the times people are
actually fixing tests rather than
writing them we all write tests is very
easy we're all developers writing code
ECC but when tests fail how do you
figure out what actually happened
so let's are so high level running on
the top of the stack so it's so hard to
actually figure out what actually broke
the workflow whether it was a database
that it was flaky whether the controller
or the view were broken it's really hard
to figure all this stuff out so there's
different stuff that you can do at sauce
for example we record full videos of the
stuff and people end up finding that the
videos are more valuable to them than
the cloud and the parallelization and
getting pristine VMS every time the
videos by themselves are actually the
value that they're looking for
capturing screenshots every once in a
while so that you know where the
application is had over time capturing
the page source and the HTML and even
better praying the full trace back of
the server-side failure in the page in
the view a lot of testing a lot of web
frameworks will do it already right if
you're doing pilot if you're doing Jango
and there's a 500 error some kind of
server-side exception Jango will render
an exception page for you and you could
use selenium to now
daaamn pull the exception Adam printed
in your results in the same way a user
would see it by hand and pay attention
to it I have an example of that but I
don't want to take too long one last
thing I wanted to show you guys it's
going to be a real-time video so this is
a peon it's a fully open source project
opping it have Apache 2 that were
working on for native application
testing a native mobile application
testing so you've got if you guys are
doing iOS or Android apps and they're
fully native nice and they rely on
swipes and all that cool stuff and pinch
pinching and shalini the so named API is
pretty alright for that actually it's
meant to be interacting with you eyes
every bender has their own kind of lame
option like UI Automator and and all the
other stuff that they provide well app
you miss kind of using those interfaces
to just provide a selenium remote
execution on the prodigal so you can
write your tests and CoffeeScript or
JavaScript or Python and then exercise
it on the application so here you can
see a simple test on the right you'll
see the Android emulator and below it
you'll see the iOS simulator so that's
why it kind of looks like an iPhone but
it's actually an Android phone so now
the tests are running and Android is
hopefully gonna open an application and
start doing stuff with it not hopefully
it's actually gonna do it cuz it's a
video
that's how I do that was um so now it's
typing stuff in the UI logging in woven
it's a it's a neroli user of a boom and
they're super happy with it and they
gave us their application as a demo
because it's actually it looks really
nice
that was are a lot better with real apps
then just forms and stuff so it's
clicking around through images and and
doing stuff with them it's pretty fast
actually we're we're now working on
putting this in our cloud so that again
you just ride your test using the
selenium API you put them in your CI the
actual browser the actual emulator is
running in our cloud so that you don't
have to deal with installing all this
all this machinery so again woven in iOS
now they resemble pretty similar UI the
actual tests that is driving both
emulators or emulator and simulator is
the same code the only thing that they
don't really share is the locators
because of course they have just
different technologies built in for Java
and for Objective C to this stuff but it
works pretty well is reliable and we're
working on that we're pretty excited
it's fully open source and in github so
feel free to just go home for the name
of the project let me show you um yes
app you you can find it IPM dot io it's
got a nice little website and all the
badges for stuff
my favorite part I hope we still having
happy ones here it's fully open source I
don't know if you even notice it's got
the logo in the Hat that's one of our
most and my most favorite developer at
sauce Bernie from Poland who made the
whole website in one night while we were
all sleeping cuz he was in Poland huh
it was not Christmas uh and I think
a thing that's yeah all I had so if you
guys have more questions
fart away</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>