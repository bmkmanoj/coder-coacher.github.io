<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scala for the Intrigued | Coder Coacher - Coaching Coders</title><meta content="Scala for the Intrigued - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scala for the Intrigued</b></h2><h5 class="post__date">2013-06-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/grvvKURwGNg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">you
it's a pleasure to be here to speak to
you today I'm going to talk about Scala
best time to ask a question or make a
comment is when you have it so please
don't wait till the end any time is a
great time and if you do have a question
or comment draw my attention if you are
you know raising hand I may not take
note of it so do yell out or you know
draw my attention and I'll be more than
happy to listen to you so let's get
started we're going to talk quite a bit
about Scala and what I'm going to do
here is to write some code play with
some examples and then if you have any
questions we can kind of go in that
direction as well so the first question
of course is why why should we look at
something like Scala the number one
reason is it's fun do you need any more
reason than that that's it right so it's
a lot of fun to program in a language
like Scala what drew me into Scala was
I'm pretty much a you know I really like
languages and I started programming in
you know c-sharp coming from C++
background Java C sharp and traditional
languages like that mainstream languages
like that but then along the way I got
excited about other languages like Ruby
and then kind of went on to program with
Erlang and as was kind of a getting
excited about Erlang God you know really
excited about the actor based
concurrency model in Erlang and then
when I turned around I looked around and
said well this is kind of interesting
Scala gives you the erlangs
concurrency model but on the JVM so
quickly I got drawn into it started
playing with it and of course Scala
gives you some of the really interesting
benefits of functional programming and
so let's talk about what you know what
are some of the things that Scala can do
for us
Scala is first of all a statically typed
language on the JVM so if you are
writing code in Java you have another
option to look at is to program in Scala
it's a language on the JVM it's a
statically typed language I don't think
it's good to say Scala is statically
typed like Java because it's more
statically typed than Java is and and as
we will see in a few minutes it is a
language which is hybrid functional
language what that means is that that
could be a good news and a bad news
depending on how you see it it's a
language which gives you the functional
style of programming
at the same time it doesn't force you to
do so so it's kind of like a dial that
you can you know turn all the way to the
left and you can write imperative code
like you are used to in Java or you can
turn their dial all the way to the right
and you can write functional style code
like in you know functional languages
for example in Erlang and other
languages so let's talk about some of
the things that we can do with Scala
itself well first of all Scala is a
functional language well you know in
that regard and what does that mean how
does it really feel like doing it so
let's take a look at an example here
let's say for a minute that we have a
list of values that's given to us we
call it numbers for example and we're
just going to start with a bunch of
numbers let's say a handful of numbers
now suppose I want to total these
numbers together or maybe I want to
double these numbers to get you know in
this list and do operations on it we
know how to do this in the imperative
style so let's take a look at an example
of totalling these values for example so
we could save our total equal to zero
and of course when I'm done with it
I want to simply print the value of the
total but how would I start totaling
these values we could say far and then I
is going to be values within the numbers
so this is like your traditional for
loop in Java or the for each loop in
Java you would probably say for INT i :
numbers in the case of Java to write
this isn't it and then of course I would
you know say here a total plus equals
and then I would specify the value of I
or if you want to call it as an element
you can call it as an element II as well
so you could write something like this
and ask you to total the values now in
this particular example as you can see
it did tell us the total is 21 but this
is a great example of a very imperative
style of coding now what is what is the
smell of an imperative code there are
there are two things we can look at in
an imperative code the first thing in
the imperative code is you cannot have
to tell the code every step of the way
not only what to do but how to do it so
in this case of course we told them to
loop through each of the values and then
of course the total is the values the
second smell of an imperative code is
the mutability of a variable that you
see here so if you notice on line number
3
we declared the variable as var meaning
it's a variable and then of course we
are constantly modifying this value in
the loop so that is an imperative style
of coding as well in a functional style
of coding we lean more towards a
declarative style of coding rather than
being imperative in other words rather
than telling how to do certain thing we
focus more on what result we want to
achieve and then simply let the code
take care of how to implement it so a
more declarative style of coding is
easier to write much more easier to more
expressive obviously for us to say what
we our intent is and then it becomes a
lot more easier to work with so how
would this look like in a more of a
decorative style of coding the other
thing of course in functional style of
coding is we would normally eliminate
the mutable variable so rather than
mutating this value over and over and
over we would program with no mutability
now of course at first thought that may
appear really strange how could you
really total values without really
mutating any variables at all well let's
think about this with the with us
somewhat of an experiment let's say that
I want to total everybody's age in this
room starting with him you know he's
really grim with no I'm not gonna ask
for your real age no so so we got a
total everybody's age in this room let's
say starting with him but let's say I
have a special post-it notes now the
post-it notes are special in that they
are right once post-it notes you can
write on them once but it cannot erase
them you cannot rewrite on them you
cannot overwrite on them so on this
post-it note the first post-it note
right there off I put a zero on it of
course I cannot change it now that I've
written zero on it and I'm going to give
it to him right so what's he going to do
he's going to take his own age and then
add to the value of the age on the
post-it note which is zero and then
comes up with this number but wait a
minute he cannot change the post-it note
what are his options
any ideas a new post-it note why not
right and so he's going to tear off a
new post-it note and write his age on it
plus zero and then passes it down to the
next person right so what does he do he
takes the age from the person on his
left adds his own age to the value
creates another post-it note and passes
it down
and of course eventually what I get from
the last person in the room would be the
total of everybody's age in this room
making sense so notice in this case we
didn't mutate any variable of course one
small concern you may have is gosh we
kind of tore off so many post-it notes
well remember one thing about you know
Java it's got you know fairly good
garbage collector in place and maybe we
could also figure out a way that this
can be more efficient somehow that
that's the second problem to solve right
premature optimization route of all evil
let's not worry about that problem right
now so the point is that we could be
creating these new values and not change
existing values well let's kind of put
that in code and see how that would feel
like so I'm gonna rewrite this code to
total but this time note is what I'm
going to do here is I'm going to start
with the numbers given to us so numbers
is the value that I've taken and I'm
going to call a method call fold the
left and I told that I would pass a 0 as
the initial value that's the value that
I'm going to give to him and I'm going
to pass to it another little value we'll
see what this is in a second and this is
going to take two values in here I'll
explain what this means in just a second
and I'm going to ask him to really total
these values together and then represent
the value so notice that it produce
exactly the same result as a previous
one but what did we do here well first
of all notice we did not mutate any
variable at all in the second expression
we wrote so what is for left doing it
somewhere does exactly what I explained
we start with the initial value of 0 but
to this function we are giving two
objects now the first object we are
giving to the for left method is the
value 0 that's kind of obvious here but
we are also giving him another object
this object we are giving to him doesn't
quite look like object in there in our
eyes but this is actually a function
value or that's what Scala called said a
function value basically is nothing but
an object that represents a function
itself so in other words the for left
method really took two parameters zero
being the first parameter and this
function being the second parameter in
other words we in functional programming
we kind of do two functions
what we normally do to objects so like
we can create objects within functions
we can return objects from functions and
we can pass objects to functions now we
can create functions within functions
return function print functions and also
pass functions to functions as well so
in this example we created a function
right here an anonymous function we call
it lambda expressions and then we pass
that function to the for left method so
the for left method said I'm going to
start with the value of 0 to begin with
and then I'm going to call this
particular given lambda expression or
function value and then it binds the
variable C to the initial value 0 we
gave binds the variable e to the first
element in the collection this is as if
he is taking his own age which is e and
the carry over which is C the value
given to him from the Left totals those
two up and returns it the for left
method now invokes this function one
more time but this time binds the
variable C to the value given from the
previous call to this function and the
element E's is bound to the next element
in the collection and the under sequence
continues until the end result is
obtained which is the total of all the
values now in this particular case we
are expressing a little bit about what
we want to achieve and we let for left
really do the iteration itself so we
didn't quite write the iteration the
iteration is implicit in this regard and
then of course we told them we want to
fold everything together and give us a
result so it's more decorative in nature
because we told an intent rather than a
particular set of actions to perform the
other benefit you see here of course is
that in this particular case we don't
have any mutable variable at all let's
step back for a minute and look at yet
another example of this how would this
look like let's say for a minute you're
writing Java code let's just imagine
that for a second and when I say Java
code here of course I'm talking about
pre Java 8 because a lot of what I'm
going to show you here Java 8 can do
that as well in terms of functional
style of coding and then we'll deviate
and look at things that Scala can do but
you know most likely Java won't do in
Java 8 as well but but looking at pre
Java 8 how would you double each of the
value
use within this collection well let's
think about this for a minute if this
was Java code what would you do you
would first say list of integer and then
you would say doubled equals and then
you would say new ArrayList of integer
using Java seven notation we don't have
to put integer over there and then you
would write something like for int I or
element in numbers and then you would
write something like double dot add and
then you would say a you know value e
times two and then eventually when you
are done with it you would output you
know system dot out dot print line for
example and then you would output
doubled over here that code won't run
obviously because a Java code not in
Scala but does that sound familiar
anybody here who's written code like
this before you have one brave person
raises their hand one more one more if
people are slowly in denial right I
fully understand right you don't want to
raise your hand in public for that
especially with the camera around that's
fully understandable but once you write
code like this how do you feel dirty
isn't it right you feel really dirty you
go home and the kids come running to you
say don't touch me I gotta go shower
first right because you spend their day
writing code like this there's a name
for this by the way and that's called
primitive obsession and and we have
primitive obsession when we code in
languages like this because we work at a
very low level of detail that takes a
lot of effort and we rinse and repeat
right that takes a lot of effort but
notice what what what's wrong with this
code this is very low level it's very
imperative and you had to spell out
every single detail to him
imagine speaking this out and how tiring
it becomes go ahead and create an empty
list for me please now start looping
through every value double the value
first add it to the empty list I created
so that you can keep adding to it and
then repeat this right so notice how
low-level we had to go through to do
this well we could do this in a much
much higher level if you will of a level
of abstraction
so how would simply saying numbers dart
map so what is map map is a function
that simply says I'm going to apply a
mapping operation this comes from a
mathematical term that we perform
transformations right now if you think
about this this makes a lot of sense
because a lot of things in
life applies this transformation we got
signals coming in and we transform the
signals you may have a little camera
that may have lights coming in you
transform the light as it goes through
so a lot of things kind of fit into this
really well and what do I want to do for
the mapping given an element on my hand
I want to double each of the elements
and then return the resulting collection
out of this so we focus more on what we
want to achieve then sitting there and
spelling through every bit of the detail
and also notice there's no mutability in
this example so what we have done in
this case is we've said numbers dot map
and so we applied this map operation and
then we said the operation we want to
perform on every element in this
collection is this doubling of the
values given to us so that's what we
have said here in this particular case
and and so if you focus on this for a
minute map is a function but the map
function itself is being called on the
numbers collection but notice we are
passing to it a function itself now
let's focus on this highlighted code for
a minute now what is a function for most
of us we would say a function has four
things right a function has a body a
function has a name a function has a
parameter list and a function has a
return type right so body name a
parameter list and return type of these
four things which you think is the most
important the body I hope right without
it there's no point having this function
well right here is the body of this
function right to the right side of the
arrow is the body of this function so
you can see that the body of the
function is right there so one down
three more to go hey what about the the
parameter list the parameter list is to
the left of the arrow well generally
speaking we would provide the parameter
list with the types of the parameters
and the variable names isn't it so we
could in general in this case we could
say int like this and then we could
write code like this as you as you can
see it still works so but on the other
hand we don't have to waste that effort
in Scala we can leave out the type
information I'll talk more about this in
a few minutes so right there is the type
or the parameter list rather so we have
this arrow separating the
parameter list on the left side and the
body of the function on the right side
so two down two more to go and and then
of course you say what about the return
type well the return type is inferred in
this case we don't have to specify it
and what about the name who cares about
the name it's anonymous function so we
don't have a name for it go ahead please
umm right so the question is is each
keyword and the answer is no you could
call this anything you want to
that's a great question by the way
because this is one of the complaints
I've heard quite a few times from people
is to say that functional code is hard
to read so don't be in little pressure
to name this as e and P and I feel free
to give it a good name if that makes
sense to you absolutely give a
descriptive name and I often tend to do
that when I write code for production I
do give a more sensible names depending
on the context of what it's supposed to
do so absolutely give a good name for
the variable and and so that's just a
placeholder just like a parameter - in
fact you all writing a function so
functions do have parameters and
whatever names we can give legally to
the parameters that's basically what we
are doing here element being the legal
name we are given for the parameter
really good question absolutely give
good good descriptive names for those
things as well so we looked at how we
can write a function and this anonymous
function we wrote is being passed to
this map function in this particular
case and what does a map function do the
map function by the way is an internal
iterator now in general in Java we are
used to write using external iterators
so what's an external iterator external
iterator is like a route dog that's also
lazy at home right so you say move and
it kind of looks at you and you have to
kind of move it and every step you have
to move it and just hops where you move
it to right where as an internal
iterator like throwing the frisbee at
the dog right and it immediately goes
gets it so you don't have to spell out
the detail you can't express the intent
so an internal iterator basically says I
am going to take care of the engine of
the looping and as a result you don't
have to focus on the looping but instead
focus on what you want to achieve for
that particular element by the way you
can do this in Java 8 as well very very
close to this syntax even but why do we
want to go
so remember if you look at this
particular case it feels like we are
losing a little bit of a control and by
the way that's a good thing and the
reason why it's a good thing is because
we are not spelling how to do things we
can employ polymorphism meaning I don't
want to tell you how to do so you can
figure out how to do it so the map
function can all of a sudden say hey
looks like this operation can be done
concurrently why am a sequential
evaluation each of the elements I can
you know distribute this across multiple
threads and have them run concurrently
if it so chooses to do it absolutely why
not make use of it so the internet
iterator can take control based on the
context and decide to do things on its
own depending on whether it should run
it sequentially run it concurrently or
other flavors as it may make more sense
so we looked at a little bit about the
functional style and how that can work
together but let's get back to Scala and
talk about certain things that are kind
of unique to Scala when compared to Java
itself one of the things that Java
provides is static typing well what does
that mean really well if you're writing
code in Java how would you write it you
would say for example lists integer and
then you would say of course something
like you know values equals new
ArrayList of integer and you would have
to specify these things in the older
version of Java in the newer version of
Java in Java 7 at least you can let that
go right but every step of the way you
have to tell what the type is and and
that can become pretty annoying right a
lot of times we specify the type and
it's kind of like you know what the type
is the compiler knows what the type is
and yet you have to spell it right it's
kind of like going through the TSA every
day I do this all the time it kind of
gets tiring after a while right it's
like dude if I want to be in a bad boy I
wouldn't be here doing it right so
that's the whole point
it's like you know what the contract is
but why do you have to keep spelling it
over and over and over that kind of
becomes painful isn't it
well in the case of Scala by the way you
don't have to go through that length
let's take a look at an example so I'm
going to say here say greet string
equals hello and I'm going to go ahead
and print this gray
over here so let's go ahead and print
the greet string that I wrote so it just
prints the value greet all right now I'm
going to say greet over here and let's
say this is going to be a howdy over
here I change the value and I'm going to
go ahead and print this as well and as
you can see that I was able to change
the value and print it but what if I say
greet equals one well notice how we get
a compilation error it tells me very
clearly that the code will not compile
because and it's not a runtime error by
any means at all
it's a compile time error it didn't run
through the first half of the code and
then stop and say oops
right it gave us a compilation error
saying I'm sorry I cannot run this code
because down below here you're violating
an expectation a contract so you cannot
assign a value of one to greet because
greet is a string now having done this
for a minute let's go ahead and remove
this code from here and let's get back
to this code and I'm going to remove the
colon string from here now when I got
into scala when it was new to scala I
first read that Scala is statically
typed so I started putting type
information in my code all over and it
took me a while to realize I was totally
wrong so one morning I ran to my
computer and it removed the type
information and I ran the code and the
code still ran and Scala was kind of
smiling at the background saying kid you
finally got what this is about right so
the point really is that Scala is
statically typed in fact it's more
statically typed and that means you have
to do less typing with your fingers
because the language is a bit more
intelligent it can figure out what the
type is so we don't have to be typing
the information with our fingers all the
time so as a result as you can see now I
can go ahead and change the value of
greet one more time in print it that
works fine
but make no mistake if I say greet
equals one we get exactly the same
compilation error we got a few minutes
ago because on line number one Scala was
able to infer at compile time that the
variable greet is of type string of
course when you look at that code that's
kind of obvious it's a string right what
else could it be right so and so it says
I'll infer the type so scholar does
fairly healthy dose of type inference
and the only times it doesn't do type
inference is when the type inference can
either be ambiguous or a bit confusing
and and I think Scala has a very nice
balance if you program in a language
like f-sharp I feel that they actually
push it a little bit further which to a
scary point where they would walk into a
function implementation to explore the
type and then decide what the parameter
types are which can be a little kind of
scary right because we change the
implementation of the function the type
can have a different meaning all of a
sudden and that could have other impacts
so Scala says I'm not going to go that
length to give you the type inference so
Scala will infer the type wherever it
can so for most part the places where
you have to specify the type is when you
are defining parameters to functions for
example you would also have to specify
the type when you declare members of a
class for example but for most of the
other times you don't have to specify
the type in fact I would say don't put
the type like Scala complain and then
start putting the type when you do need
to but of course you need to give really
good variable names obviously because
without the type information you really
to convey things a little bit more but
of course you know if we have a team
which is going to give variables with
you know letters like a and B and C this
is not going to make it any better so
it's not going to make bad code better
it actually makes good code actually
better in a way in fact if you notice in
this case in the case of Scala you
specify the type right in the reverse
order then you do in Java and the reason
is Scala says it's more important to
give a good name for a variable than to
specific or the type is and that's why
the type actually comes after the
variable name in this case please really
good question so the question is in in
Java typically I would define a list as
a variable type rather than an ArrayList
as a variable type on the other hand
here you're letting this two type
inference how does that work well let's
think about this for a minute if I am
creating something as a list of nor a
list and if I'm only using it within a
function scope itself it really didn't
matter what we declared it as because
it's still going to be treated as such
the real essence is when we start
passing the
out to other you know functions
what-have-you
so the same concepts appear here as well
when you're passing something it will
know what type to send it to so with the
newer encapsulated code it's the type
that in first it - may be more specific
to the type you create but when you pass
it the contract actually comes in and
then that's when the real contract you
know type gets in so that is why in the
case of function parameters you still
have to say what the type is in that
case you would say that it's a list and
not an ArrayList for example whereas
within your body it really doesn't
matter which way we specify because that
has no recursion outside of the scope of
this particular code the question is are
objects passed by value it makes
absolutely no semantic difference
between Java and Scala they're exactly
the same way as in Java passed by
reference in that regard so they're not
copied at all in this case so scowler
doesn't change the semantic meaning of
the objects in in any way it still
behaves like the way Java behaves
because Scala compile down to bytecode
and then runs on the JVM you can
intermix Java code and Scala code back
and forth so you can write some code in
Scala some coding job and call back and
forth of you want it to now that I would
recommend every alternate class to be
that way
but it gives you the ability to go back
and forth so it doesn't change the
semantics meaning right so the question
is how does it deal with when you do
send a particular type the answer is it
is exactly like the way in Java is you
can only send by only compatible types
for example so if the type you're
receiving is a base type you can either
send a base type or a derived type but
not the other way around in other words
the co-variants
are definitely handled in scala like in
Java is yes so the question is the great
appear should be mutable here I haven't
gotten to the immutability part on this
one yet so stay tuned I'll talk about
that in just a minute please
can you save our greet without giving
any value to it that that's correct you
cannot do that you cannot and the reason
is type inference says I'm sorry I am
clueless at this point I don't know what
you're referring to give me more details
at this point at the time when you can
actually you cannot say that if you if
either you have to bind it to a
particular value from which it can infer
the type all you have to specify
what the type is so that's correct and
and then in that case of course you're
saying I'm going to come back and give
you the value later on and Scala is like
all right I'm happy with you because
you're going to give me the value a
little later on but if you're not going
to give me the value now give me the
type yeah absolutely excellent so we
looked at the type inference but let's
talk about vowels and bars for a minute
now when it comes to variables versus
values now we all kind of have
programmed in Java for a long time we
have done mutability all the time and
mutability is something we do without
even thinking twice however if you have
a mutable variable that kind of either
is a little shaky things change and when
things can change there's a more
opportunity for how introducing bugs in
the code now when it comes to a sharing
what sharing is a good thing right
remember what mom told us right
no sharing is a good thing but
mutability is what we do and sharing is
a good thing but shared mutability is
devil's work and the minute you bring
shade mutability all kinds of things go
wrong in code now if you're writing
concurrent code and even if you're not
writing concurrent code if you're just
writing code avoiding mutability as much
as possible is a good thing now this is
great we can all agree to that but how
do you do that in Java
well the effective Java says as much as
possible make all your variables final
well great I'm going to mark all my
variables final but then what if I
forget to mark something final is it
possible absolutely right because we are
humans we could forget to write put a
final and how do you look for where you
forgot to write final when I wrote the
book on the JVM concurrency I made all
my variables final and and and the week
after the book was published somebody
tweeted saying oh my gosh I'm looking at
Vann codes book he's got 350 uses of
final I replied back saying yeah but you
didn't realize where I still forgot to
put final write and that's painful in
fact I remember the afternoon before the
book went to print I said hang on guys
let me verify if I have final everywhere
that was the lowest point of writing
that book
because I have to sit there and check
where I forgot final because I tell
people make it final and you don't want
to miss out final in the book right now
how do you look for where final is used
that's very simple grab for final how do
you look for where you forgot to put
final I'm sorry I'm still working on the
regular expression - right right that is
a lot of effort isn't it to look for
something that doesn't exist
well Scala says stop right there you
make a decision right now do you want
this variable to be a variable or do you
want this variable to be a value kind of
an oxymoron meaning you cannot change
this value right into this immutable so
in other words you can declare a
variable greet hello like this and Inc
and then of course you can go ahead and
change this variable greet equal to like
I just showed you before and you can go
back and change it as you can see and
then you can reprint the value on the
other hand if I mark this as Val if you
will then we are saying I don't want
this reference to ever be modified in
this code in the in the scope of this
variable now the beauty of this is I
will get a compilation error saying I
cannot reassign a value to a value
obviously in this case right so in other
words if you follow this approach you
cannot come back and say oops I forgot
to put final you got to make a very
clear distinction whether you want
mutability or not now comes the best
part you can easily do a code review and
I can do a very quick grip on var and
say why are we using so many variables
and as a code review I would say let's
favor values more than variables except
when we want to use an exception and so
we can apply certain special rules to ik
to deviate from the norm and favor more
vowels than VARs in the code and in
general I would say when you're writing
code in Scala you do want to prefer more
valves than VARs as much as you can but
it makes it a lot more easier to find
this now quickly to clarify this by the
way the VAR or Val purely influences the
reference itself so think of a Val as
final
in Java so if I have a final string we
know the string is immutable and the
reference is immutable as well
but if I say final string builder for
example then of course the string
builder can be modified but the
reference cannot be modified the same
concept appears here as well the vial
indicates the reference doesn't dictate
what the object can and cannot do that's
completely orthogonal to that and then
we can make the object final as well
sorry immutable as well if we wanted to
so as much as possible we can favour
valves but on that note let's talk about
something for a second now imagine for a
minute that you are writing a Java
function and in the Java function if you
say public void foo int a and then you
have some code up here and then you say
a equals seven and you have some more
code here now looking at this code we
all know that this is evil code right
why because this function foo quietly is
modifying the input variable provided to
it modifying input variable should be
punishable under law right because
that's very poor programming practice
how many times have you ran into bugs
because of it I had a guy there raising
the hands over there right I had a guy
called me up one day and said my code
doesn't work I don't know why it doesn't
work can you take a look at it so I'm
looking at this code and both of us are
looking at the code I'm like gosh this
is kind of strange why wouldn't the code
work and and then we start debugging
step by step and suddenly we realize in
line number seven he's modifying an
input variable our eyes are so much in
denial they don't see the code in front
of us right and then once you realize
he's change the input variable alike are
you changing the input variable and it's
like oh darn it I didn't mean to write
and this is really bugs creeping to code
and once we you know figured out what
the problem was we fixed it now what
does Java say Java says well since this
is a bad practice go ahead and mark this
as fine out right so in other words if
you mark input parameters a final that's
what effective Java says right make
things as much final as possible well
but you have to remember to put the word
final all you have to use a
tool that tells you to put find out
right now what if this is the way it
will work let's make a look at an
example define foo and I'm going to say
a is an integer and then within this
function I'm going to just print the
value of a let's start with this for a
minute
so I'm going to call foo with the value
of 4 so you can see the value of 4
printed now I go here sneakily I say a
equals 7 I modify it now notice what
happened it got really mad at me it said
how dare you are trying to change the
value of a in this code right why
because by default the parameter to a
function is immutable
now of course usual people ask me is it
possible to really make it mutable the
answer is yes go back and program in
Java then right so the answer is no in
Scala because that's such a bad practice
they don't want you to do that so input
parameters are treated as final and in
this case of course eval you don't have
to really say anything related to that
as you can see because that is the most
logical thing to do
so it really favors immutability as you
can see in these cases and in fact you
can kind of think about this for a
minute and say wait a minute
that is kind of interesting we do want
to treat input parameters as final but
why don't we do this in Java also well
that's why we have the book like
effective Java right now it's kind of
interesting to think about Java itself
when you say here is Java would you hire
anybody by the way who has not read
effective Java right you would that
would be like your first interview
question right Hey Dude do you program
in Java yes I very difficult Java know
well here's the door right so you want
to make sure they read effective Java
but I'm sure you have wondered one day
if effective Java is such an important
book to read why don't they fix Java to
be effective well actually they did but
when they got it done they called it
Scala right so a lot of things as you
can see is fixed the nice way because
that's the way it should behave so they
took a lot of these recommendations and
and worked on it as you can see here ok
that's great let's talk a little bit
about essence versus ceremony now what
is ceremony by the way ceremony is what
you have to do before you get to do what
you really want to do and
monie is boring ceremony really is
tiring right you're like I would not
have to be doing that but I have to do
this because that is ceremony well let's
think about some ceremonies for a minute
let's talk about Java for a second has
anybody had a chance to peek job at
anybody here have you done that before
a few people raising the hand very quiet
let's okay be brave right we all have
that are Java too a few people around
right okay so you decided to teach Java
and your audience is sitting in front of
you and saying I want to learn Java but
is it hard and you said no Java is very
simple because every book written on
Java says that right so it's got to be
simple right so they say well if it's
Java is simple can you teach me
something simple you say don't worry
about it I'll teach you something very
simple how about a Hello word and your
audiences immediately like cool I want
to learn HelloWorld in Java like let's
do it and then you said let's get on to
it right and you said public excuse me
yes what is public well you don't need
to know that right now okay and then the
student you know nodes don't loyally
public don't know need to know that
right now and are we doing HelloWorld
absolutely class excuse me what's a
class you don't need to know that right
now okay fair enough
hello world and there's a glimmer of
hope in this person's eyes yes we have a
low world and then you put this curly
like what now right then you say public
and immediately the person looks at the
notes you don't have to know that right
now awesome then you said static and
that's it is that something I don't have
to know also right now and the person is
very nervous right now right because
I've seen five concepts they don't need
to know right now and this is somehow
supposed to be simple right now this is
called ceremony right ceremony is where
you do stuff you don't have to do before
you get to do what you really want to do
what do you really want to do a print
hello world why aren't we not printing
hello world why are we writing all of
these stuff oh let me explain to you why
that's because the JVM wants a class
that has a public static void main
but that je viens problem not your
problem and Java says I'll make je viens
problem your problem
Scala says I'll keep the JVM from the je
viens problem and I will not you know
put it on your face so why not simply
say hello world over here and be done
with it
so notice in this case there is no
ceremony associated with it
you say wait a second you said a few
minutes ago that this runs on the JVM
and it produces a bytecode how in the
world could that be true because we know
that JVM requires a class with public
static void method absolutely true but
what Scala compiler the Scala C compiler
does is it says I'm going to pick your
code I'm going to write a class with a
public static void main method in it and
I'm going to stick your code inside of
it compile the whole darn thing and then
send it to the JVM so you don't have to
do it so in other words Scala compiler
wraps all this to meet the expectation
of the JVM so we don't have to sit there
and waste our time and effort looking at
stuff that we don't want to care about
so it gives an illusion of scripting but
it really is not scripting in the sense
of scripting it still is the good old
Java class we are writing under the
covers and we are sending it to this in
this particular case so you can see how
we have a essence over ceremony there's
a lot of things that are optional in
Scala like what for example you already
saw me a show a couple of things already
you can see that in Scala we don't have
to write semicolons so we simply said
hello world like this now if I put a
semicolon right it still works but you
don't have to put the semicolon anybody
here thinks that semicolons are
important not really right in fact I
gotta prove that semicolons are not
really good idea if you take a look at
your hand for a minute there's a reason
why your pinky is the shortest because
years of emotional abuse it's taken
right all these other fingers do useful
word and then you stop and hit the
semicolon it's like why me right so it
really is taking the emotional you know
toll on it well you don't have to put
some a colons in Scala as you can see
you don't have to you know put that
semicolons are optional parentheses is
optional in certain context return
optional so if I were to write a
function for example so I'm going to say
define foo and I'm going to write a
variable here and maybe I want to return
eight times two
I could call here for example foo and
send tweet to it and we can see that
it's returning a six I don't have to put
the return keyword so every the last
expression in the function is
automatically evaluated and the value is
returned so we don't have to say it our
type information is optional in number
of cases as you can saw here it knows
that foo is returning integer in this
case how so because it evaluates the
body of the code and says aha eight
times two what would that be well I know
a is an integer and eight times two
obviously is going to be an integer so
it figures out what the type is based on
the inference and we didn't have to tell
them that it's an integer type in this
particular case so a lot of these things
are optional classes are optional as
well as you can see we didn't have to
write a class in this case we just threw
in a few functions together so a lot of
these things are optional now what is
good about having optional things the
nice thing about having things optional
is you don't have to involve ceremony
and as a result you can directly get to
the essence of what you want to do
rather than playing around the compiler
and pleasing the compiler so let's take
this up a notch
please so the question is are there
times when it's better to put their turn
type maybe we have a mistake on the
return type or maybe we type something
incorrect the answer is if you are more
comfortable putting the type don't
hesitate to put the type in the
beginning and once you get really
comfortable with it you will kind of you
know start losing these guards around
you and you will realize that we've been
overworking most of the time so let's
think about this for a second um if we
write code I used to work for some
companies where the minute I write code
my boss would say awesome now let's ship
it but we normally write code and we do
this thing called testing as well so if
we ever use the code we write then all
these issues kind of disappear because
I'm going to write a unit test
my code and even in statically typed
languages by the way I favor unit
testing quite a bit so if I ever write
code that is unit tested it is going to
exercise a certain behavior out of it in
that case the type information really is
not the only validation I'm going to
have because my code is going to
exercise it right away so I'm not going
to say it is never useful but in general
I feel that the compiler is way
overrated than it really is compiler is
very useful by the way but we seem to
put it in a pedestal more than it really
deserves it so I would say down it a
little notch and say I'm going to live
with pouted and see if I really need
this behavior or the specification and I
find that a lot of times I really don't
I overworked in giving these information
up so the question is can have two
implementations of fou where they return
to different values in that case well
that goes to the issue of contravariance
where we are trying to return a
different type and overloading rules
would prohibit from from that happening
because a signature of the method
wouldn't tally up for the you know for
the conflict result so very similar to
Java it would enforce the overloading
ambiguity rules as well so we don't have
to worry about that either but but like
I said go ahead and put the type
information until yep you came to
declare no you cannot unless there's the
overloading as long as the overloading
doesn't conflict you can but if that is
the only difference between the
functions it would not allow you to do
that that's correct that's right yeah um
so let's take this a little bit further
let's say for a minute I want to
implement another thing that a caller
allows which is really nice as a
compiler support let's look at an
example here let's say for a minute I
want to write a factorial function and
the factorial is going to take a value
that is given to it and I want to return
a factorial of this number so I'm going
to say bar fact equals 1 I want to turn
the fact when I'm done with it so I'm
going to simply print the factorial
let's say our 5 in this case I haven't
implemented this yet so it gives me a
value 1 which is incorrect but let's go
ahead and implement this real through
mutability of course so I'm going to say
value of I within the values
let's say 1 to N and I'm going to say in
this case this is going to be fact x
equals the value of I so I have
implemented a factorial using a simple
iteration now iteration involves
mutability in this case it is it is a
very simple code but we are writing
imperative code in this particular case
we could have traded this with the for
left method we wrote earlier if we
wanted to
but let's change this a little bit now
let's say for a minute we want to use a
recursion to do this so I could say if n
is equal to 1 I want to return 1 itself
otherwise I want to return let's say n
times factorial of n minus 1 so this is
a very simple recursion now of course
because a function is recursive Scala
says I can't go multiple levels to find
out what your return type is so this
code will not compile by the way it'll
give us an error as you can see here and
to resolve the error you have to tell
them what the return type in this
particular case is now you can see that
we wrote it as a recursion now what do
you think of recursion tree curses are
really awesome isn't it right recursion
is the best way to really gather up
friends right they want to party with
you because you can solve problem by
using sub-problem solutions right how
cool that is so they won't hang out with
you so recursions are really awesome
until there's always this one guy in the
party who doesn't like you and says what
if I increase this value right and then
you increase the value and the party is
over right why because we got a stack
overflow exception and everybody is gone
you're sitting there alone and like it
was so cool if it only worked right so
recursion is such a wonderful idea but
how sad it is that we have stack
overflow exceptions how could we solve
this well what if we can solve this by a
little bit of a compiler magic now what
is this magic there's a fantastic book
out there by the way a book I really
like a lot it's called structure and
interpretation of computer programs and
if you just Google for sicp you will
find it so structure and interpretation
of computer programs book way Sussman
and Sussman talked about
a little technique we can use under the
under the hood so let's see what this
technique is they talked about you can
write a iterative code oh by the way
they talked about a procedure versus a
process now what is this distinction a
procedure is the code you write a
process is the code that runs it's kind
of obvious that that's what happens
already right because the compiler takes
a stab at your code the JIT compiler
then comes through so eventually what
runs it's transformed code already right
so the code you write is what you wrote
is a procedure and the one that runs in
effect is the process now what they talk
about in the book is they say what if
you write a iterative procedure and you
run it as an iterative process and we
did that a few minutes ago right we
wrote an iteration we ran this iteration
life is good we could also write as a
recursive procedure and then we could
then of course run it as a recursive
process and that's what we did at least
until the value became too big we were
able to render the recursion but we're
really big gains come in is if you can
write as a recursive procedure but
somehow quietly it runs as a iterative
process now you get the best of both
worlds right your right is a recursion
so it's very expressive you can still
have the party with your friends but it
runs as iterative this is like finding
that magic pill where you can eat all
you want and never act your midsection
if you find that pill please let me know
I can benefit from it a lot I need that
for the amount of travel I make I
definitely need it but in this case we
have this pill in this case of Scala
because Carla says if you honor the
recursion as a tail recursion then I can
take care of this for you so notice what
I'm going to do in this case I'm going
to go back over here to this code and
let's go back to five here for a second
but in this particular case I'm going to
change this just a little bit to say I'm
going to take a value of n but I'm also
going to take a factorial as an input
value as well and then in this case of
course if n is equal to one return the
factorial but if otherwise go ahead and
return factorial of
- one and then n times the factorial
itself so we did a preemptive strike
here and we said we'll perform the
computation first and then throw it AHS
up as a parameter now notice that this
became a tail call let's step back for a
second and take a look at this one more
time the function I had a minute ago if
you go back and look at this code I had
a second ago notice the last call that
is being made in this factorial function
is the call to multiply itself so in
other words the factorial says I have to
pass right here take the value of n on
one hand and wait for the result of
factorial n minus 1 before I complete
the operation and return so it's got to
hold the stack and climb on the stack to
the next level
on the other hand with a little
refactoring we just did what we did in
this particular case is we instead said
we're going to take this value of the
factorial right now so factorial of n
minus 1 and then we will do the math
right away right here in this code and
then pass that value as a parameter in
the in the parameter list so as a result
the last operation that's performed
right now is the call to the factorial
itself in other words as soon as the
factorial is computed there is nothing
more for this function to do but to
return the value the compiler can be
smart enough to say wait a second if all
you're doing is turning on the stack
waiting for this result to be received
only to pass it down why don't you step
down from the stack and wait for the
result so in other words very quietly
under the hood it can convert this from
a recursion into a very simple iteration
and this can be done with compiler
support fairly well so if I go back and
write this code for a second now notice
that the same result as before but on
the other hand this became tail call
recursive let's challenge this a little
bit to see how this is going to work so
if I increase the value like I did
before notice that in this case we did
not get a stack overflow exception of
course it gave a value of zero which
we'll fix in a minute that's because of
an integer overflow but notice it's
not really having a problem in the stack
at all so what's happening what's
happening in this case is the compiler
very quietly takes this factorial and
recognizes this is the last call in this
function itself so this is tail call up
to a and as a result can optimize for
tail call recursion and so quietly
transform this entire code into a simple
iteration under the covers so as a
result it becomes a while there is more
code to run keep running it and as soon
as you get a result return it right it
just becomes a simple iteration and as a
result of course I want to make this
work properly so I'm going to change it
to a big integer in this case and of
course if n is 1 I want to turn the
factorial otherwise I want to continue
with the value and return the result in
this case so in this case of course this
is a factorial and this is going to be a
big int a big int of 1 which is the
value that I want to send to it
initially for this to work properly so
let's go ahead and change this to of
course the result is going to be a big
int as well so in this case we are
running this factorial with a large
value 50,000 and and of course the
recursion is taking a little longer here
don't try to memorize that result you
don't need to know this but that's an
example of how the tail call
optimization really took place so it's
already baked into the compiler now you
say alright this is nice but anytime we
hear the word magic as programmers we
don't like it right because later on you
may come and change this code a little
bit and it no longer is still called
recursive how do you know that this is
broken to solve this problem Scala
provides a little annotation for
compiler support so you can say Scala
dart in this case you can say annotation
dot a tail drag and in this case of
course it'll it'll look through your
code and make sure that this code is
actually tail call optimized now what if
I don't have this code as tail call
what's going to happen so as you can see
in this case if I go back and put a one
times factorial and try to compile this
code it Yeltsin screams at me and says
what are you smoking this is not tail
call optimized why are you putting tail
call recursive on the top so you can see
that it kind of checks and balances it
so you can use the annotation
to emphasize that the code is really
tail call optimized and if it is not
it's going to give you a compiler error
and you can recover from it so let's
look at this for a second we made a
little bit of improvement in this code
now that we made this improvement we can
go for a large value of input as well
and we are able to use recursion but
there is one disadvantage in this code
what do you think we lost that's correct
the simplicity for the caller is gone
right especially so as a caller now I
got to send two parameters now you're
going to say what if I send the big int
to here no sweetie you can't you cannot
send two can I send zero no you cannot
send zero right all this unnecessary
complexity well what can we do to
eliminate the complexity well here's an
idea
why don't we change this to an
implementation for a second let's change
this to an implementation for a second
then we can write a function called
factorial which takes a number and then
it can simply return factorial
implementation of number comma a big int
one so we can really move that into it
and now we can simply say call factorial
with just one parameter rather than two
what do you think a notch better but you
always have this one colleague who comes
to you and says can you still call it so
if you don't want somebody to call it
you don't want them to ever call it what
would you do make it encapsulate right
the other day somebody said threaten him
no you don't want to go to that extreme
so you want to make it encapsulated well
how do you make it encapsulated oh right
a class well wait a minute we don't need
a class though do we
so here's an idea why don't we grab that
function for a second and totally move
that function into this function itself
and in other words because it's
functional style we can have functions
within functions as well nothing stops
us from doing that so we encapsulated
this function not through the class
approach as we normally do but more
functional style by having the function
within this function itself as you see
here so that's an example of how we can
use the tail call optimization and tail
call of course is relying on the support
by the Java compiler sorry the Scala
compiler to do this the Java compiler
doesn't support this and as a result the
bytecode doesn't quite directly support
this either so there is some limitations
to how far you can go with tail call
optimization um if it is to you know a
bigger function the tail call
optimization may not work to me returns
it says wait a minute this is too
complex for me to analyze I'm not going
to you know do it and you can also it
doesn't do what is called a trampoline
call where a calls b and b calls a back
and forth but scala also provides you a
class called tail drag which you can use
to provide the tail call optimization in
a trampoline as well and you can
certainly do that i was inspired by this
by the way and also I know how
trampolines are implemented in gluey so
over the holidays I really got excited I
wanted to write a book on Java 8 lambda
expressions because Java 8 is just
around the corner so I was writing the
book I said it wouldn't be so cool to
show how to do tail call optimization in
Java so the first thing I did was I
looked to see if Java supports it it
doesn't right now so I decided to
implement it and I kind of set out to do
what scholar does at the tail call of
you know tail direct classes but I
actually found out there's actually
other better ways to do this in Java but
this is another point I kind of wanted
to make is one of the reasons I really
like to learn some of these languages is
not that I would program in these
languages all the time but just
programming in these languages gives us
so many things we otherwise don't and
then when you go back to programming in
the language you are you know currently
program and you tend to kind of sit
there and figure out how to really bring
in certain concepts that usually people
cannot do so easily in those languages
but being equipped with some of these
things I think we really really are
expanding our ability to program in
these other languages as well so it's a
lot of fun to learn some of these things
whether we program in them all the time
or not
so let's talk about classes a little bit
classes are cute in Scala let's talk
about writing a class for a minute a
public class car a private int ear oh I
forgot to put final I'm writing Java
obviously right and then I would say
private in miles then of course public
in get ear and then of course in here we
would say return ear and then public int
I get miles and then of course return
miles and then of course we would write
a set method isn't it public void set
miles um this is one of my most
favorites this has to be named miles
also right as if there's no other
variable on earth and then this dark
miles equals miles if I ever find this
you should i strangle the person who
writes it in my code right
so we do all of this in Java I know what
you're thinking you're saying wait a
minute I never do this in Java
I only declare the field then I gently
right-click on it and before I could
blink my eyes the IDE vomits the rest of
the code right so what we are saying is
not only we want a language that you
know is not doing the right stuff but we
also have to invent IDs that constantly
vomit and then what do we have to do
step over the vomit all the time right
it's like oh don't sip on that right so
why do we have to deal with this ID
vomits in the code what if the language
does these things for us automatically
let's write this in Scala how many times
do you make your class non-public by the
way not a whole lot so why not just say
class car hey can I make it public
that's okay it's already public no need
to say anymore a Val mile sorry Val ear
is going to be an integer VAR miles is
going to be a integer also great what
did we do we have written a class ah but
I need a getter for ear done I don't
want a setter for ear okay no setter for
a year
it's a valve I want to get her and
setter for miles done
I want to construct a for the car class
done I know you're in a panic mode now
you're like what if all that is then
what do I do go home right enjoy the
evening you don't have to write stupid
code so you can simply say car 1 equals
new car here is 2013 mile to zero and
you can say car one dot here print the
car value so the class is already
written for you you don't have to write
the class you don't have to write the
constructor you don't have to write the
setters and getters of course it doesn't
follow the javabean convention you could
if you wanted to by putting annotations
on it but all that is done for you what
if I want to write some implementation
here well in Scala you don't really
write classes in Scala you kind of write
constructor very much like JavaScript in
JavaScript you don't write classes you
write constructor and that becomes a
factory to create objects so very
similar concept in Scala like in
JavaScript you are writing this little
constructor in fact if you will you can
simply over here say created for example
notice I say created and in this case
I'm going to say Val car one let's say
Val car one and the equals new car 2013
and I'm going to specify 0 and you can
see that creator got called because of
the constructor evaluation now I can
write a function here define drive which
is going to take a distance I want to
drive this car and and I could say miles
plus equals let's say there distance and
I could you know print out here for us
to see I could say driving for example
so in this case of course I could say
car 1 dot drive 10 and then and then of
course I can print out car 1 dart miles
to see if the value of miles has been
changed now notice how I put semicolon
here just to show that it's still
possible to do that or you can say car 1
Drive 10 and you can do that as well so
you can go scale up all the way to hi
ceremony or you can kind of start
removing a lot of stuff around it and
that would be just fine as well and and
Scala is quite happy with that to call
it so again a lot of serum Oh
removed around the code you can focus on
essence so you're writing a primary
constructor now of course a class could
have multiple constructors in that case
you can write what are called auxilary
constructors within this class or within
this rather this primary constructor and
then these obsolete constructors there
are some ground rules you have to follow
in Scala the auxilary constructors are
required to call back into the primary
constructor and the primary constructor
is the only one that can call the base
constructor so it's kind of like a
funnel if you will it kind of takes all
of these through the constructors the
primary constructor would then feed to
the base class why because it removes
duplication and code it removes a lot of
errors that we normally introduced in
writing constructors by requiring this
kind of channel through which we call
these methods and of course in Scala
classes are pure now what is it what do
I mean by they are pure Oh in the case
of Scala by the way you don't have
static methods no don't leave the room
yet it's much better than that
why because remember what we talked
about in programming we say separation
of concern and we all say Amen brother
that's great
we have to have separation of concern
and then what do we do we sit down and
say class and then we put instance and
static in it and then instance method
and static methods what is that
separation of all the concerns in one
place right so that is not a good
separation of concern at all why because
we are dealing with instance related
stuff and class related stuff in one
place and that becomes a pain in the
neck to deal with go ahead please
absolutely right so the question is if I
have it right here you're saying oh
pardon me over here sorry so here too so
this is basically the entire body is
part of the constructor so in other
words yes yeah yeah absolutely the
entire body is a constructor except
there are parts of it that get stripped
out as the members of the instance that
you're dealing with oh like a pearl in a
nice way yeah
um I so again you know if you ask me I
would not do that right so there's a
difference between can I and should I so
there's a lot of K and I but should I is
usually not an answer right so so that
that's something you wouldn't exercise
normally um so the real beauty of this
is so static things are really evil to
put in a class there's another problem
also how do you create a singleton in
Java you could write a private
constructor now the minute you write a
private constructor one of your
colleague comes to you and says hey look
at these two objects I created you look
darn it how do you do that oh I use
reflection to do it and now you're like
okay let me go plug that hole right and
then tomorrow you walk around proudly
and say now you cannot and he says what
about these two objects don't equity to
get those from oh i serialize and
deserialize it darn it let me go fix it
by the way the name for this this
pattern is called scotch tape driven
development you put a little tape on it
it peels a little bit tomorrow you put
more tapes on it well it turns out by
the way singleton is a pattern you take
five minutes to learn an ear to get it
right and in fact it's so bad that Java
figured a way to solve it a right way to
do singleton in Java it really makes me
cringe is to write an enum because enums
implements singleton fairly well but
that kind of smells is in there what
enum to write a singleton well what is
the reason why we prefer that because
singleton is so hard to do it's better
leave it to the class loader to do it in
the first place so scholar says all
right if that's the right thing to do
why don't we provide it for you so
notice what I'm going to do in this case
I'm going to have a class called car
here let's just remove all of that for a
minute I'm going to create an object
called car now notice in this case in
the case of Scala you can define a
singleton using a word object now object
basically indicates a singleton now it
so turns out you can just have a single
term by itself
or you can also have a single
with the same name as a class and if you
do by the way this singleton has a
special name it's called a companion
object a companion object has full
access to the object for which its
companion to the class for which its
companion to so in this case I'm going
to define an a method here will call it
as create for a minute and the create is
going to take a year let's say as a
parameter and then I'm going to simply
say return new car given year and 0 so
notice I can simply say car one here and
I can simply in this case say car dot
create and then I can say 2013 to create
a car object now in this case of course
I can print car one dart ear and I can
also print here car one dart miles to
know what the value of miles is and so
we kind of wrote a wrapper around this
now car dot create essentially is like a
factory that is creating the instance
for us but the car itself becomes a
singleton in this case we can go a step
further with this I can call this a
little bit different as apply and then I
can then call this as apply so little
apply method well the word apply kinda
comes from functional programming where
we are applying a function meaning we're
invoking a function we are executing a
function now a little difference but
what does this take us well the apply
has special meaning in Scala we can
simply drop it in this case and this
kind of becomes more like a factory if
you will so when you just apply this
method without any notation it
implicitly calls an apply method and the
apply method has some special meaning
now if you understand the apply method a
little bit now this changes the way you
look at things if you have an array of
objects or a list of objects if you will
so numbers equals let's say lists of one
two three four and five a bunch of
values I want to get the first element
how do I get the first element numbers a
parentheses zero gives you the first
element you kind of wonder why do they
have parentheses instead of the fancy
square bracket now you know the answer
it's because it's implicitly calling the
apply method under the
heard and as a result we are using a
short form notation for doing such
certain things so a lot of these hidden
gems are in Scala and and takes a bit of
getting used to but once you kind of
understand the nuances of what's
happening it's much easier to write this
language itself so we talked about quite
an interesting set of features already
but I want to talk just a little bit
more about function values we used
function values mostly but it would be
nice to know how to receive them and
process it and then I'll talk about
traits and chaining traits as the last
two things I want to talk about so let's
talk about function values for a minute
let's say we have these values of prices
given to us so prices equals and then
let's say we have a bunch of prices
right so of 10 15 20 25 30 35 and 40 so
our task on hand we are told to go total
all these price values you say I can do
that so let's go ahead and write a total
prices and total prices takes prices as
a parameter this is going to be a list
of integer values given to us and what
should I do within this function let's
say total equal to zero we could use a
for left method also if you wanted to
write we could say fold left our reduced
method we could use all of that but
let's keep it simple here for a minute
to keep our focus on the other part we
want to deal with so I'm going to return
the total from here so in this case I
would say price in prices and what do I
want to do with the price values we
could simply say total plus equals the
price value itself let's go ahead and
call this method to make sure it's
working so total prices and I'm going to
send the price as values over here in
fact let's go ahead and move these
prices below here so the context is very
close to where we are using it there we
go so that is basically a value being
total so you get this done very quickly
and the requirement given to you was
write a function that totals all the
prices so you're done well as the fate
may have it your colleague comes to you
and says I also need by the way in
addition to this another function that
only totals prices greater than
and 25 and you asked your colleague do
you mean total prices over 25 and your
colleague says yep that's exactly what I
want so you're sitting there and
wondering how do I write that function
in addition to this function and you
stare at this for a minute and then you
tell yourselves there's a reason why
they created copy and paste right I mean
if nobody should use it why would they
create it right so you copy in fact this
is so compelling
they gave shortcut keys how nice is that
right ctrl-c ctrl-v
right and so you say total prices over
25 and then simply you say if price is
greater than 25 then total otherwise not
so you got that implemented very quickly
well unfortunately your colleague comes
to you and says I also need another
function their totals prices under 25
also now you know you're in trouble
because you copied and pasted the code
one more time already and you know that
copying and pasting code a third time is
criminally negligent but nobody is
looking right now so you copy and paste
it one more time and this becomes under
25 right and of course in this code you
say under 25 and you get this working
really quickly so you could leap but as
you leave the building
your guilt kicks in because you know
that this is not what you really signed
up for right this is really bad coding
so you pull over to the nearest coffee
shop you're frantically trying to
refactor this but as fate may have it
bunch of your friends show up and say
what are you doing and before you could
close the lid they take a look at it and
they get to know your dark side right
and they no longer want to hang out with
you and they don't return your phone
calls anymore how really life becomes
right no we'd never want to do that we
want our geek friends so let's sit back
for a minute let's get back to the code
where we where and then rewind the time
and this is when we have this one
function on our hand and this one
function is working right so our
colleague comes to you again and says
hey I need a favor from you
I need one more function from you what
do you need I need total prices over 25
oh that's what you want yes well I'll
get back
to you so we're sitting down and saying
how do we really make this work well a
little bit of refactoring is needed so
let's not do that right now
let's interested go back here and say
well I wanted total values but it turns
out that I don't want to total all the
values I want to total only select
values sometimes I want to select all
the values that's perfectly fine so I'm
going to write a selector now what does
this thing called select or that I'm
specifying here well a selector by the
way is going to select now what is he
what I'm going to give to him to select
a price which is an integer and what is
it going to give you back a boolean see
how easy it was to write that so a
selector is just a function so it's a
function y notice prices : int the
square bracket lists square bracket int
so prices is an object of type list
selector is an object of type function
how do we know notice the mapping which
we specify here right after all a
function is a mapping of an input to an
output so it is just a mapping of a
selector that's all we have so now that
we specified it we are simply saying if
the selector is accepting the price
value then total otherwise no so now we
can come back here and say I want to
take a value as an input by the way
price and I want to accept everything
given to me so I'm going to simply say
true as a return value so this pretty
much accepts all the value given to it
now your colleague says I want to
function that totals all the values
which are greater than 25 you tell your
colleague to go write it himself or
herself so price is going to simply say
price is greater than 25 and then you
can say go ahead and only total values
greater than 25 now if you want a value
which is only less than 25 not a problem
you can simply write that and say less
than 25 and you can simply leverage the
code we wrote so in other words we've
made total prices a higher order
function in other way
the total prices says not only will I
accept the value like I did before but I
will also accept other functions like it
like in this case and if you really
think about this what did we just do we
quietly implemented the strategy pattern
look at the difference in Java if you
want to use the strategy pattern you
hold the corporate design meeting here
it just works as simple right so that's
a very lightweight approach to implement
a strategy you're not really forcing
yourself to create interfaces in
hierarchy of classes it just works so
that is an example of how you could use
a more of a functional style of coding
with this said let's talk about yet
another piece yes please
yes yes you can do that as well
so you could use default parameters if
you want to do you could do that or you
can just overload it either way is fine
yeah absolutely
a functions can have default values as
well right so in here right so equal to
you won't put boolean but you'd have to
put a function actually put a function
itself in this case yeah absolutely um
so given this let's talk about some
other feature that we want to implement
um let's talk about multiple inheritance
and you're thinking no let's not well
how many of you have implemented
multiple inheritance before oh wow you
all have dark past right you all
programmed in C++ Oh I mean secretly I
have said that's a language I really
like still but but how many of you who
raise the end want to go back and do
more multiple inheritance tonight not a
single person raises the hand right why
because multiple inheritance is a
gorilla
it is cute when you see it in the zoo
but you don't bring it home right it
topples your furniture you know Casa
Casas havoc right so well to be fair the
problem is not with multiple inheritance
it's with way job I'm sorry C++
implemented it let's get to that in a
few minutes but let's get back to some
other concept let's say for a minute we
are writing a class and the class is
called human and the human has a name
over here we'll give a string name we'll
put a Val
and then of course I want to say here
define listen and I'm going to say
listen is going to simply print out
print line and I'm going to say I am
will put a name here listening right so
you could use you know new Scala
facilities to put it into a little
dollar symbol but I'm not going to go
there so let's create a variable Sam
equals new human and then we'll create a
Sam variable and then we'll say Sam dart
listen so so here we go we have a little
human class with a losing method but
wait a minute what does the listen
method have to do with anything who
listens by the way Sam listens
there was actually one guy in the front
row in a couple of weeks ago and he said
wife and we all kind of lived in man
laughed and then after family said well
I've been married for two weeks it's
like wait you're still in that honeymoon
phase right you will know better very
soon we all have social not we all have
very contextual hearing right I always
pretend that I hear my lovely wife she's
she's wonderful and she talks to me all
the time when I'm working in the kitchen
and life was in harmony right she says
you're so nice to having you in the
kitchen look at you you're working and
listening to me
well except one day there was suddenly a
silence and I kind of looked up and she
was tearing at me and I said is there a
problem and she said I asked you a
question and you haven't answered it and
I'm not going to repeat the question for
you but I need an answer I knew I was in
trouble right so I had to really work
hard to get the question out of her
before I could answer but now she's
gotten better the other day I was
working in the kitchen nodding my head
and working away and and suddenly you
know there's a thing there's an email I
started replying to email and halfway
through it I realized she sent me the
email from the kitchen and she said
that's the way I get an answer from you
so I got busted right so we all have
this selective hearing so from time to
time but I one who listens by the way is
a friend where it wouldn't you agree a
friend listens to you right so a friend
listens to you but we kind of put this
listen in the human assuming that the
humans do listen but there's one friend
who always
to you and never speaks back to you dogs
how awesome it is to have a dog but how
do you do that
hey I want to inherit the dog from human
because I have the lizard method in the
human dogs don't like it right so what's
the Java answer to solving this problem
a mammal hmm
only a stretch Oh interface we have a
friend double interface now we have a
friend of al interface with a listen
method but now we have a problem right
human has a listen and dog as a lesson
which is duplicated how do we remove the
duplication now so we create an abstract
based class right and but how do you
reuse the abstract base class so we have
an interface on the top the two classes
will then delegate to the interfere
abstract base class and that's a lot of
work isn't it
microphone listens to you yeah it could
be yeah it get can get worse so if that
is the pattern we're going to follow
why can't the language do it for us
automatically so we don't have to put
there for it to do it let's see how so
I'm going to create a trait so what is a
trait a trait is kind of like an
interface to begin with so trait friend
and my trait is going to have a listen
method a trade as an interface except if
it has an implementation then it's buy
one get one free offer right there's an
interface call for the trait and there's
also an abstract base class being
created for it also at the same time
right so we got two of the things
together
so given this I'm going to say extends
from friend so in this case of course
I'm saying oh this of course should have
a name so name of is going to be a name
which is going to be a string and
haven't given a value to it at this time
so it worked
let's go a step further we say class
animal and the class animal has a name
so it's got a name here a class dog
which overrides override
name which is a string and it extends
from animal and let's go ahead and say
this contains the value name so let's
start with this so Val buddy
equals new dog and I'm going to say
buddy and buddy dot listen well that
doesn't work why because dog is not a
friend yet let's a width friend so it's
a little bit of a you know inconsistency
here because human doesn't inherit from
anything we use extends because dog
inherits from animal already we use the
word width so notice how we were able to
bring that listen into this fold by
simply using a width friend as a trait
so what did it do really what it did was
it created an interface called friend it
created an abstract base class called
friend so you got two things now a
friend interface and a friend abstract
base class it injected into human class
the reference to the abstract friend
implementation and it also injected into
the dog class the abstract base class
calls into it in other words it mixed it
into those two automatically so the
method is available on both these with a
we having to duplicate it so far so good
let's continue yep great please up the
answer is yes but let's come back to
that in just a few minutes please yes so
in other words in this particular case
it says you are putting a constraint
that this can be mixed in only in two
classes that have a name property so
it's a constraint you are propagating
you're saying I'm a trait but I will
only accept being mixed in when you have
this property brought in so the friend
doesn't have a name the human has a name
but there you said oh by the way I'll
only get mixed in if you have that name
not otherwise please not quiet the same
by the way so the question is is this
very similar to the default methods
being introduced in Java 8
not quite exactly the same because the
rules are fairly different for how
default methods in Java are implemented
compared to this you could say that
there's an overlap between them but they
are not a one-on-one substitute for each
other
the default methods we're really
introduced in Java 8 to evolve
interfaces that already exist for the
past 15 years the intent here is very
drastically different so there's a bit
of an overlapping area but the intent is
very different on this kind of takes you
into the decorator pattern area we'll
see in a few minutes the default method
quite doesn't solve that particular
problem good good question though let's
look at this one more time let's say for
a second I create yet another class over
here let's say a class that I'm going to
create here is the class call cat so
I've created a cat class and in this
case of course I'm going to create a cat
so let's create alpha which is a cat
scary cat and this is going to be I'm
gonna call Alf Dart listen will this
work and no that's because cats are not
friends right in fact cats kind of look
at you and say why are you back from
work why don't you put some more food
around and go back to work right anybody
with a cat is your cat friendly very
friendly I'm right Ron I'm sorry to
deliver this news to you you're in
denial but you're a nice guy you've been
really interactive sitting here so I'm
going to try something but no promises
ok but I'll try Ron Ron I'll try so
absolutely absolutely I'll try but no no
promises
so Alf is a lost cause so let's not even
mess with Alf so Ron's cat would you
share your cat's name with us Ron spell
for me
no wonder uh okay
so cat um okay
doc listen sorry we tried but but one
one last hope one last hope so what did
we do
cats are evil by the way but Ron's cat
is special in fact run would you say
it's one of one of a kind
absolutely so in fact it really is if
you look at what type the cat object is
it's not an object of cat type O so in
this case of course you have an
anonymous inner class and this anonymous
inner class extends cat by the way and
implements friend so it is one of its
own kind
cats are not friendly but Ron's cat is
special so not only can you mix in a
trait at the class level like you did in
the dog case and human case you can even
inject it at the instance level if you
wanted to right so so this gives a
pretty powerful trades and all this is
compile-time
programming in this case of course but
you're able to extend the behavior so
one last example I want to give you goes
back to your earlier question yeah boy
please how do you refer to the type you
can refer to it as a cat you can refer
to as a friend because it's anonymous so
you can only refer to them as one of
these two cat or a friend please
there could be two different types as
well we're going to see mixing of
multiple things in a few minutes we'll
get to that somebody had a question here
I think um you should never demand
anything to a CAD but nevertheless the
answer is yes so if a function requires
a friend you can send this cat to that
ron's cat can be sent but not cats in
general let's do that real quick before
we go to the next example
so for example if I said over here just
as a quick note if I said you know a
seek help from a friend
and let's say friend over here and in
this case of course I'm going to simply
call friend dot listen right so so
that's all I've done here let's remove
this listen let's remove this listen
here and then let's also get rid of Alf
so over here I could say seek help Sam
so obviously I'm sending Sam to the
method I can say seek help a buddy and
of course seek help
Ron's cat as well as you can see we
could send send that but I cannot send a
cat in general so seek help new cat oh
my I cannot do that right so that's not
allowed because cats are not friends so
let's get a step further we looked at
trades but let's get back to the problem
with multiple inheritance the problem
with multiple inheritance twofold right
what if methods collide with each other
that's a pain the other problem is the
diamond problem meaning that you have a
base and then they have common base how
do you deal with it what if the
interfaces decide to collaborate rather
than collide then that wouldn't be a
problem isn't it so the way this works
is the traits actually line up next to
each other like a terrain and then when
you call a method on a trade it can pass
the call to the next one and then they
all can work with the cumulative effort
let's take a look at an example I need
about five more minutes to get through
this so let's say we have a writer and
I'm going to make this an abstract
writer so abstract writer um so this
writer simply has a method called write
which is going to
a message string that's all I'm going to
take right not a whole lot of
implementation in it what am I going to
do I'm going to have different types of
writers on my hand let's say we have a
class called string writer which simply
is going to extend from writer so in
this case of course I'm going to write
the write method which takes a message
as a parameter and I'm going to simply
say here all that I will do here is to
say target dot append and I'm going to
pin the message well what's the target
by the way let's say the target is just
a new string builder let's say so that's
good enough for now right so let's also
write one other method override the two
string method and all that I'm going to
do in the two string method is simply
say target dot two string and return the
result from it that's good let's give it
a try so I have a writer and I have a
string writer but imagine I could have
different types of writers a string
writer a file writer a socket writer
encrypted writer Cardinals what are the
writers I can create write several
writers I could create but I want to use
this writer so write a method called
writes stuff which takes a writer as a
parameter so there's my writer and in
this case what I'm going to do is simply
write out writer dot write and I'm going
to write this is stupid
and let's print it out so I'm going to
print out the writer so let's go ahead
and try this out so let's call the right
stuff and send new string writer and see
how this shapes up so it wrote this is
stupid
great now let's say a few minutes goes
by our requirements change on us they
not only want us to write stuff to this
writer but they also want to convert
everything to uppercase and write it so
they want both the functionality to
write all the text as it is and to write
all in uppercase well where do I put
this new function to write an uppercase
here's an idea why not put it in the
writer abstract base class what do you
think of their idea hmm
not a not a great idea right because it
pollutes that abstract base class next
thing you know you come back from
vacation there's 20 methods in
right no you don't want to do that hey I
can put that in the string writer what
do you think not a good idea because it
is not available in these other twenty
different types of writers I have so it
looks like a good candidate for a trait
so notice what I'm going to do now I'm
going to go back here and say trait
uppercase a filter and in this case it
extends from the writer now I want to
kind of caution you the extents here is
a little bit confusing it really doesn't
mean extents it's more like a constraint
you can only use this uppercase filter
into stuff that is a writer right it's a
constraint you are placing now I need to
write a method called
write which takes a message as a
parameter and what am I going to do here
message dart to uppercase great but
where does this go by the way well
obviously have to write it into
somewhere where do I write it in other
words I need to write into a where do I
write it into well I don't know what
where is at this point but I know that
it's got to be to the object in my chain
now how do i specify the chain of the
object they decided to use the word
super the word super doesn't mean super
the word super here means the next guy
in the chain so it's a little bit
confusing we normally we use the word
super for inheritance hierarchy whereas
here it's a trait hierarchy from right
to left if you will right from right to
left all right
say that again oh no you can also use
super for the regular inheritance as
well so having done this how would I go
about specifying it here comes a deadly
combination of word called abstract
override the best thing about this is to
not look at it again and forget about it
because it's a bit confusing it simply
says abstract because I want you to
provide the right method in your
implementation over write because I am
overriding a method that's already in
the contract don't think too hard about
it it gets a little frustrating so
anyway we wrote that method how would
this work let's go ahead and try this so
now I'm going to say
right stuff new string writer but you
know where I'm going with this
with upper case filter and now you can
see that it actually nicely put it in
upper case how did this work the
requestor right by the way goes to the
upper case filter which converts a
string to upper case and then forwards
it using the super call to the string
writer which then writes it down now
let's do one more thing by the way well
it turns out that I had a discovery
which was very sad I came to know that
I'm a bad guy it's always kind of hard
to realize that right I travel a lot I
hang out with programmers like you also
what do you expect right just kidding so
I go home one I for one of my trips and
my little boy runs to my wife and says
mommy daddy is a bad boy and my wife you
know whispers to my kid and comes back
to discipline me and she said did you
say a bad word to the child to the
children I said bad word what did I say
and she leaned over and said did you use
the S word I said S word and then I
whispered and said I would never use
such an S word not that and then she was
supposed back did he say stupid I said
of course I said stupid don't say it
again I said what's wrong with stupid
she said look I've been teaching the
children to have manners they cannot
call people's tastes true you can call
people stupid I mean way to this all the
time at work right that's stupid right
and I'm like oh bub okay I will not say
it again so I had to put filters on me
right I mean you couldn't say stupid in
front of children I didn't know this so
this is kind of troubling so trait
profanity filter right and profanity
filter extends a writer and what do I do
here abstract override defined right
message string and what am I going to do
in do in this method super dot right
message started plays the word stupid
with the word right so that is my
profanity filter so now right stuff new
string writer with profanity filter much
better isn't it
well let's give this one more try you
know where I'm going with this right so
I'm going to say a right stuff new
string writer width upper case filter
with profanity filter all that three
together how about that so run that
awesome isn't it but of course you
already noticed one problem here because
the request goes to the rightmost object
and then it goes through the Train of
objects one at a time the sequence
matters a lot so as a result if I try
now right stuff new string writer with
profanity filter with upper case filter
notice what happens it doesn't remove
the content but don't don't worry about
it this is perfectly fine because the
other day I was very angry and I
screamed this is stupid and immediately
my you know little boys eyes widen and
my wife is like daddy is upset right now
be quiet so this is perfectly fitting
the domain right so you can see how the
chaining of object works but the proper
order of chaining makes a big difference
too but all that you did right now is
just implement the decorator pattern as
you can see right very very smooth way
of implementing just by using traits
which is already baked in and it can be
used fairly effectively so that is about
chaining of trades and how that's baked
then there are all these interesting
features that the language provides it
still follows the Java semantics but it
brings to the table
enormous about of conciseness there's a
lot more conciseness than I have covered
here but I hope that that kind of gives
you a idea of with what you can do but
the nice thing about this is it's not
all nothing proposition it's a language
on the JVM you can compile this into
bytecode you can layer your architecture
in a way that you can use Java where it
makes sense especially integrity
applications and then reach into Scala
where it makes sense in layers and then
you can build part of the system with
Java part of the system with Scala and
then bring them together and places
where I find this to be extremely useful
is when I want to do xml processing for
example the skull has really nice
features for it when i want to reach
functional style you can either wait for
Java eight or you can use it right now
in Scala you can use this where you want
to use good pattern matching for
instance or you want to use the
functional style as we saw here or I
meant even scratch the surface of
concurrency where you can use this
enormous Lee capable you know solutions
to either implement an acrobat
concurrency or use parallel collections
and stuff like that
so the beauty of this is it is it is a
language that's there but think of this
a lot of times when people ask me how do
you use this think of this like you use
spring or hibernate it is a language
that you throw in with a certain
capability but at runtime it's question
of having a few more jar files in your
class path and then you can start mixing
them in and I've seen this used pretty
effectively in in organizations where
concurrency is very important or they
have a very heavy lifting to do like a
lot of XML processing to do these are
the places where you will be able to
leverage the other benefit I see a lot
about this is I learn languages
primarily for one reason to use them but
more important to go back and program in
the language as a program in a much
better way than I did because these
these languages don't teach us a syntax
in fact it's the wrong thing to focus on
the syntax these languages teaches
idioms these languages teaches a certain
way to program a certain way to design
and I can bet you that my java design is
no longer the same I think differently
in Java I programmed differently in Java
and in fact when I got exposed to Java 8
by the way there are certain things I'm
bringing in to Java 8 in terms of
patterns that I've learned from these
languages like Scala and groovy and
closure and languages like that so just
spending time on these languages really
makes us better overall in programming
in the languages we already program in
and also gives the agility for us the
minute we realize this is a better
choice we are quick to go adapt to it
because we are familiar with it so I
hope that was useful for you thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>