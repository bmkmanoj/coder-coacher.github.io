<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java (SE) State of the Union | Coder Coacher - Coaching Coders</title><meta content="Java (SE) State of the Union - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Java (SE) State of the Union</b></h2><h5 class="post__date">2017-11-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/C6PUbIHMDZU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the subject that I was actually put
asked to put together as a Java SC State
of the Union to open the Java track and
it's an interesting thing because this
is not the typical thing I'll speak
about most of my talks tend to go into
technical detail and you know I'd like
to make a lot of fun comments about
technical things this is sort of a State
of the Union thing so I I tried to find
month to fight my tendencies to put in
commentary about technical things but
it'll still happen here looking at what
we're going to cover I'll do a brief
introduction of Who I am and where I
come from we'll talk a little about
history then we'll talk about some more
history and futures we'll talk you know
about trends in Java State and then I'll
do some of the political what is in Java
ninth the stuff but in a little
different way and we'll go in I'm hoping
to have some time to chat to actually
open it up to discussion so people can
comment on what they think about the
State of the Union for Java about me I'm
the CTO of Azul systems it has only made
Java Virtual Machines I've been playing
in that game for about 14 years now one
of the things we're probably known for
Edison is garbage collection we believe
we've solved garbage collection it's a
done deal
I've been working on that problem for a
while and here's some evidence of me
actually doing work on the problem that
is a physical garbage collector problem
it actually had a bug in it that machine
is a trash compactor it's in my kitchen
because I'm a lazy software engineers
what it actually does is it performs
minor garbage collection compactions
during the week so I only have to do the
full GC where i pause take the bag out
go outside once a week and since we
don't like once a week you restart
everything once a week and nobody knows
that anything happened right but I had a
problem here the compaction function
wasn't working you see the fragments
coming out the back so it wasn't
defragmenting correctly I had to open it
up and yank the fragments out and reset
the compact
and I thought it would be funny to take
a picture with the actual garbage
collection theory book at the time but
the really useful piece of information
here is that's the picture from 2004 and
I've been thinking this is funny for
that long or more and really lazy I just
don't read in my pictures if any of you
how many of you have seen if any my
talks before so you've seen this picture
right okay I really need a new one but I
look different now anyway
I have a long history of building all
kinds of things before a job but before
JVMs I built physical machines and
virtual machines and operating systems
and and an interesting little hardware
for all kinds of weird stuff I helped
design CPU instruction sets and choice
kernels and firewalls and network
switches and subscriber management
systems for millions of people and built
an app server accidentally and did a lot
of weird things that ended up with a lot
of mistakes and I learned from some of
those mistakes one of my hobbies is
actually to go around depressing people
about some of the mistakes I know
everybody makes cuz I've made them and
myself you might have seen my latency
and response and talks on the subject
but in addition to that I'm a member of
the JCP Java community process Executive
Committee
I represent us all there and by the way
we have an election going on you know
it's important to vote today not just
for president but also for JCP EC
members you get I mean the election is
ongoing right now so if you are a member
of the JCP please vote I I also
participated in obg decay contributed
some stuff and you know actually mates
did something that makes it into Java 9
which makes me pretty proud so that's me
now why am I talking about the Java
State of the Union it's kind of weird
for me to do that because I do think the
Java State of the Union is something
that you know really the project leads
are more equipped to talk about as a
whole so think of what I'm gonna do is
Java State of the Union commentary right
this is my view from some of the side
you know well involved side on what
goes on there we ship a Java as si
platform it's the only thing we do so we
care a lot and we track this a lot we
think we know what's going on but think
of this as selective comment Ori writer
then here's you know this is what's
going on we're responsible for it so
with that let's look at a little bit of
history rather than just where do we
stand today where did we come from how
did we get here what does Java been
doing and simple way to look at it is
let's look at versions started with
version 100 and we are now in version 1
point 10 if you look technically inside
the JVM we're still in version 1 it's
just been number anyone oh and two ones
means that those are the actual numbers
in the JDK insight now those numbers
have been switched over the years
because marketing people don't like this
kind of stuff so around Java 5
it went from 1.5 to 5 at 6 &amp;amp; 7 so when
we talk about Java 9
I'm actually talking about Java 1.9 and
not only did this kind of naming thing
happen if you actually look at what the
platform was called it started off as
Java one point X 1.0 1.1 1.2 but around
1.2 they decided ok 1.2 is a good basis
for Java so they called it the Java to
se platform and started counting from
there and then we had 1.3 so J 2 is e
1.3 that's you know that's Pizza Hut
making pizza and then j2se 1.4 and by
Java 5 they kind of figure out that
contradiction makes no sense so they
went with j2se 59.5 and see there's a 2
and a 5 and then finally we dropped the
2 and we're in the Java SE world which
is how we name things today so these are
the historical versions going back to
what actually went on in those and kind
of zooming in two versions in pine 1.0
was the first thing the Java did after
the alpha and beta it was this thing we
thought would be used to build applets
and
in web browsers mostly nice language
some basic library capability
interesting syntax but important things
were added in the first few releases
that made it actually robust and useful
on servers
reflection is one of the things I was
added fairly early on swing which we
still use for some things like drawing
on desktops was added around the same
time the notion of a collection a
hashmap
list a generic way of looking at generic
a way of looking at collections was
added in one too and along with that
came things like weak references soft
references phantom references all these
are fundamental changes to the language
of the platform so every time you see
one of these programming once that
happened was different than before
you no longer program the same way
anybody here still use vectors you know
uppercase vector that was a 1.0 data
construct that has been eradicated and
defunct and deprecated forever but it's
still there right it predated
collections but you know so every time
we went through one of these new
features that enable the dramatic new
way of using the language and expanded
the echo system quite a bit too so these
are big shifts 1.3 was more of an
incremental add more libraries thing in
1.4 we had a huge shift in capability
around niño now and i/o these days is
not the sexiest thing and people like to
hate it but then there was a fundamental
change to Java in that that was the
first time that in Java without some
native hacking of some C code we were
able to talk to networks with more than
one connection per thread after that
point we had a simple blocking API for
Java but with 1.49 I know we had amok
sir we had the ability to wait for
multiple things to be ready at the same
time and act on whatever come ready and
that meant that we could actually build
application servers and containers that
directly in Java without any
the jvm were able to terminate thousands
or hundreds of thousands of connections
that was a huge shift because that
enables a sea change at house Java was
used in servers rolling forward to Java
five generics a dramatic change to the
actual language and how we write things
up to that point we did not have generic
capability collections were simply
collections of objects so we're able to
describe generics
type them you have the compiler sort of
helps us will help us with the times
again things we like to look back in and
hate because there are many things we
wish interacts within different Nuits
but the kief ability came in there and
it's still the same to this day and how
it works and and that allowed us to
really leverage the notion of data
structures being things we don't build
but things we get from other people good
data structure has already come with the
JDK or made by other people that know
how to make them and it's pretty rare
that you have to build your own data
structure you mostly do stuff like put
things and data structures one of the
common very useful libraries that came
up in Java 5 is the Java util concurrent
library which is made up of a lot of
interesting things around concurrency
and Atomics and locks and stuff but even
more importantly useful data structures
well-written scalable concurrent data
structures that you don't have to build
the debug in and make work yourself
whether it's queues or or stamped locks
or or concurrent hash maps you don't
have to build them they're just there
which if you compare it to other
environments the ability to actually
just have somebody else like Doug Lee
having written all that for you is great
and have it be leverageable
that happened a decade before C++ had
similar stability moving forward from
Java 5 notice I kind of jumped over Java
6 Java 6 and mostly Java 7 were some
incremental releases from a point of
view of how they affect what you
when you program there were very there
was a a bunch of very important
capabilities and new libraries and XML
behaviors and things that were added to
the platform but fundamentally the
language itself didn't really evolve or
change in Java 7 the biggest changes to
language was that we didn't have to
write things inside the brackets and it
kind of automatically did it and we had
you know try with resources well yeah
but you know not wow I programmed
different now that didn't happen with
Java 6 or which other seven and then we
get to Java 8
Java he did this you have lambdas we
have lambda expressions we have
functional interfaces feels modern it's
almost like Lisp right and and we also
had another pretty interesting big
capability to came in in the stream API
allow us to actually program 2 streams
and collections and ways that is more
modern and useful to to model walking
data through them so these are two big
capabilities that came in Java 8 that
really changed how people program if you
look at it from the point of view of
when developers want a new version of
Java it's usually driven by one of these
capabilities like Java 6 did not drive
strong developer let adoption these are
the Java 7 Java 8 did people want a
program in this new stuff which means
you push and you make it make sure that
you can actually use it in production so
that's kind of where we are today Java 8
is the current thing the adoption of it
has been very good it has been led by
developers because we want to program to
these new features and we've pushed that
way what does it look like going forward
so Jeff and 9 is around the corner it's
right around the corner the corner keeps
getting a little bit further but but
it's not that far right and in the
feature set is pretty well known and and
a lot of work has been put into it it's
not just the combination work since Java
a Java 9 actually has things in it
been worked on for two or three releases
and took that long or taking that long
but Java nine is a fairly incremental
release from a point of view of language
behavior I see it much like Java 7 what
happens to how you program in Java when
Java 9 comes out I mean there's really
really cool stuff in there and all kinds
of new capabilities and libraries and
methods and things and streaming API is
getting better in but fundamentally
there isn't something you'd say aha this
has just changed everything and how I
write most of the features that we're
actually getting excited about and
looking forward to our knowledge of 1/9
are happening in Java 10 and beyond now
yes obviously there's this jigsaw thing
everybody knows about Java 9 I jigsaw
and modularity and we can talk about
what it does but does it actually change
how your program no I mean it doesn't
even change your code it changes the way
declare other packages and the way you
package your own stuff and it's good and
it's good housekeeping very much good
housekeeping for the JDK but it's not
fundamentally gonna change how you
program the actual changes are probably
going to come in the future like with
things like value types value types for
those of you don't know are the ability
to take things that are not quite
classes but code in like classes things
like XY z-- for points or small
structures it's a struct like behavior
and ability to pass and move around
tuples return tuples pass tuples without
the cost are full object overheads and
arrays of them and such so really useful
capability we've been waiting this for
this for a long time and it's looking
good in development this is a real thing
that is really being built just not for
Java 9 then we have things like arrays
2.0 arrays - that always a catch phrase
for all the things we want a race to do
different than they do today but to give
you a feel for what it means it's
everything from finally having a race
that have more than incest indices
because it is 2016 or 2018 by the time
it'll happen to the ability to have a
raise of things that are not just
primitives or references to the ability
of having a race that might be sparse
might vary in length might have all
kinds of interesting behaviors like coms
versus rose rose versus columns and
layout all this there's a bag of all the
things we want to see and if you
actually are interested in some of the
detail there's a great online recording
of John Rose talking about a race to go
at the Java language summit from I think
three years ago I encourage you to look
it up and see what what that is oh I got
ahead of myself with the race to go
there so that a race to that L will come
we also have interesting work on what's
called J&amp;amp;R FFI letters and letters this
is a foreign function interface which is
fundamentally the ability to go and talk
to native code without having to write
all the J nice stuff to do it think of
it as here's an h-file for c stuff i
want to call that function and that
function might have a struct that it
takes as a parameter i want to be able
to talk about that struct as well and if
i as it's gonna allow us hopefully to
make those kind of calls much more
easily to kind of discover and include
non Java interfaces and be able to
translate for Java to them without
having to do a lot of the mechanics and
code and stuff there's some very
promising work going on for that as well
in addition to that we probably will see
some changes to the language itself for
example there's some interesting debate
and talk going on about adding the
concept of vowels and bars to
declarative to declaring you know
variables in Java some people think this
is great some people think this is going
to ruin the language I'm sort of on the
fence but this is certainly in our
future for discussion and then a lot of
we don't know yet that goes on and on
beyond them so that's why we are from a
timeline perspective as a highlight I
depict and
and pick and choose a few things to
focus on they mostly look at this as
things that affect how you program
notice that adding a new XML parsing
library or the fact that we don't yet
have a JSON parsing library in Java I'm
not talking about there there's or you
know you add them to the platform you
standardize them or you get them on
maven from 17 other implementations the
ecosystem we have is huge
what's pectin standard or not is not
that much a concern but is the language
as a platform actually evolving to
enable new things is what I focus on
here now switching from looking at the
timeline usually when you want to think
about the State of the Union you want to
know how the Union is doing so how is
Java doing and and often when people ask
that question these days they ask these
kind of questions as Java is still
popular are there more cool things out
there that are displacing Java is it
trending away is this COBOL and I like
to say Java is COBOL but it's COBOL in
the 1960s it's the coolest thing to
program in still well are the most safe
thing to programming now these are all
valid questions and they occur and they
have occurred since Java started I've
heard these questions come and go since
about 2000 you know there's this really
cool new thing now that will displace
Java and people are writing in it's
called Perl and PHP in the lamp stack
that's the sticking over the world to
make Ruby and rails oh boy we build
everything in that there's just we build
Twitter in that right and then there's
the next new thing of JavaScript and
Python and go and these are very cool
things that's what people program a lot
of cool things and today but when every
one of these has come and gone they've
come and gone and replaced each other so
far we haven't yet in my opinion seen
the thing that is displacing Java we
will see it some day it will come when
we see it will recognize it three years
after the fact when Java has actually
started to wane and this other thing is
taking over all of its functionality but
I don't believe it's happened yet
now if you look at some examples of
actual data these are current data -
2016 this is a language popularity and
github chart and yes javascript is the
most popular language on github what's
the number two language it's Java and
what's the one with the high scoring
growing trend and a placement it's Java
that's actually surprising given what we
hear about the other things right if you
look at jobs job availability jobs that
contain requirements Java is pretty far
up there I'm not sure what sequel is
doing there quite this that's a website
I just looked at right but Java is a
very popular language and it's being
hired for lots of people know it whether
you believe we have eight or nine or ten
million developers running Java today
it's the it's the easiest language to
hire for if you want to build something
and you want to make sure you can find
developers there's a lot of them not all
of them are good just like any other
language but within that population
there's a lot of really good developers
and you could hire them it's one of the
safest place to go hire now you know if
we go back to these really cool things
that keep displacing each other as
anybody here tried to hire a ruby
developer originally what about a perl
developer now there are people who know
those things but they want to program
and go today they want to program in
JavaScript they want to program in
Python usually there's a trend away from
trends that goes on and the thing that
Java has in it I believe is the true
strength and a big differentiator is
that it's got this 20 years solid
history of code that works code you can
hire developers to work on you can go
back to 60 year old code and work on it
and find people that you can hire today
that will be able to work on that code
that's a huge huge ability another
simple metric this comes I think from
New Relic
but it's basically the number of job
titles can contain that language in them
and it's Java is huge in the difference
there but let's look at it a different
way I like to kind of take a look at the
20 year history we have behind us I have
been playing with Java since it was in
alpha since it was this cool little
thing running inside a web browser
mostly and in to me the big WOW point
was when Netscape went on a stage at a
Sun developer conference and said we are
putting Java in the browser that was a
that little cool toy I've been playing
with that might actually become
something that's popular and that was
1995 the next year there was no Sun
developer conference there was Java one
and it had 4,000 people in it which was
twice as much as the Sun developer
conferences ever had and that was a year
after this and it's grown ever since if
you look at how Java took over the world
and what the phases of that happened we
really had these three phases in my
opinion we went from introduction in 95
to completely taken over the world of
servers by 2001 it took less than five
years to actually get there which is why
I think that the thing that's the
slicing Java is not yet here we would
have seen some indication and when I say
displace things in 1995-1996 the way to
build applications for servers were it
was a C++ it might have been in thick
Sedo it might have been write directly
with sequel to databases and very
quickly Java this thing that was coming
from clients and just had a few
capabilities started taking over the
world with all kinds of things like
servlets and JDBC connections for such
we didn't have an era of applications
where applications were built in Java
not in other things if you wanted to
build a new HR application you didn't go
hire people to build an ANSI class +1
pythons or in Perl you would go and hire
people that world and Java and ran on
one of these platforms you can eat
and a lot of applications whether there
were business applications or web
applications or built that way over
about a decade but those was
applications that was what people build
for their needs their function whether
it was a huge web application or not and
in this decade we have a really
interesting shift for Java Java is being
used to build infrastructure pieces of
infrastructure that are fundamental to
everything we run now if we look at what
I mean by those JB JDBC poles were a
really interesting invention and
capability that started early on in Java
the fact you could talk to databases
with a connection it was a pool of
connections that managed it for you and
you didn't have to basically start a
process for every request you got from
the web the notion of servlets do you
guys remember what we had before
servlets if you've got an HTTP request
you forked a new process you have cgi
servlets made that the same process just
handles things locally and can able to
talk to different connections let them
go and the whole concept putting this
together was the basis for what we think
of as an app server or a container today
Java EE sort of evolved from that as a
set of specs and standards when it was
still thin and not kind of thick and
aging like we feel about it today and
that led to things like web logic and
WebSphere in jboss and Tomcat which we
build applications in rather than build
when I said I accidentally built an
application server that's because I used
Java 1/2 in 1998 to build an application
there were no application servers I was
lucky there was a JDBC connection I
could use so we had to build the
application server but by 2001 you
didn't need to do that anymore you could
buy one you didn't have to build that
infrastructure you just build your
business logic and that was great we
evolved into things like portals and web
services and so on data grids and all
kinds of things that really sounded sexy
at the time and look old now and there
were lots and lots of technologies in
there but really applications were
dominated by this and that meant that if
you built an application in Java you
just got there quicker and it was
because the ecosystem was huge now
shifting into this decade we have things
like Hadoop and Cassandra and variations
of Lusine and distributed systems like
solar and elastic in Kafka and SPARC and
storm and zookeeper and many others
what's common to all of these they're
built in Java they run on JVM even
though you don't program them in Java
necessarily most of them are just pieces
of infrastructure that serve some
functionality it just happens that
building him in Java was the way to get
there to scale to dominate the market
the way it is so infrastructure pieces
today the largest data bases in the
world this decade are in Java which to
me is a huge thing because I remember in
2005 looking around saying dammit why
don't and do all the data bases are not
Java we only have applications so this
is where we are today
Java dominates infrastructure it's still
very much a back-end application
building environment and yes there are
many many new cool things that keep
evolving and replacing each other to how
you build the front ends and how you can
do things together and you know whether
we call the new things micro services or
other types of services or all the way
to RPC we reinvent the pool new way to
do stuff in Joe attends to fit into
those but there are write better ways
and lighter ways to do things for the
right things
overall commentary in the State of the
Union is it's good it's not going away
Java is in a really good shape it has
fairly good stewardship it keeps getting
new features developed that are relevant
and it is maintaining it's very powerful
ability to actually run software over
five years ten years and still have
relevance and the ability to develop it
and maintain it so that's our look at
the state the history and where we are
but whenever I talk about one of these
subjects everybody wants to talk about
the now and what's
so this cool thing is Java 9 what's in
it so what's in Java 9 welders modules
modules are in Java 9 it's gonna be
modular but since everybody talks about
that I won't talk about that
it's got modules and some other stuff
and and and I'm gonna talk about some of
that other stuff here in the rest of the
time we have so here's the list of
everything in Java night that's actually
from the Java 9 project that describes
all the different jep's on open JDK that
are going into the platform currently
that's a long list and I'm not gonna get
into all of them so I hand-picked they
had a few of them to sort of zoom into a
little and talk about and those
samplings are just interesting selective
ones I've picked so these are kind of
the for the J shell of our handles
unified logging and spin whiteheads
that's what I'm gonna cover here let's
look at the first one J shell Java has a
ripple a repple stands for read eval
print loop this is a huge invention very
current in 2016 it's very important
because practically every modern
environment we program in has a rep also
Java really needs one too and modern
starts with Lisp now the reality is when
you touch this repple your immediate
reaction is how the hell did we not have
this for the last 15 or 20 years you
know everything else has it it's how
people play in a valued and poke at the
language of the libraries why didn't we
have it and there's no good explanation
for why that I mean really there's no
good explanation it's it's one of these
obvious simple things but this is a
great feature of Java 9 the platform
doesn't change our your program but
certainly makes you be able to poke
things interactively much nicer so you
now have a direct link to talk Java to a
machine and look at what the code hasn't
it in and play with it that's it Java
has a ripple like that's it you could
you could look at a lot of details go
look at online they're full talks and
examples on how to use it but it is one
of the coolest actual you
ability features in Gemini the next one
is var handles now var handles are
actually these technically fairly
complicated to code to and not
necessarily the prettiest things out
there but they do add capabilities
fundamental capabilities to the language
that let us do things that we had to
kind of do hackish things around before
and this is the actual purpose of what
if our handles are for it to let us do
things that we might no need to actually
use Atomics to do even though we don't
need the atomic functionality or we need
to do unsafe things to do which is even
worse if our handles are really there to
help us get rid of our habit of using
unsafe to bypass the java spec who here
has used some misc unsafe you're aware
that that's not Java right it starts
with Sun misc it is not in the spec
nobody's ever promised that the next
version or even dot release of Java will
actually have that method in it but
we've all learned and end up being so
kind to that functionality for
fundamental things in it there are tens
of open-source libraries that would not
work if it didn't exist that it's a
fundamental part of any practical java
implementation today that is not a good
thing because unsafe right there tells
you something you know it was labeled
correctly damn it now it's I mean what
what more than this can you say that
don't use this stay away you know it's
not safe right but it has functionality
people want or need now I like to break
down unsafe into modes and those modes
are so that the runsvold isms of unsafe
right there's a there's a safe way to
use unsafe then there's an unsafe way to
use unsafe and unfortunately the fact
that there are unsafe ways to use unsafe
makes the uses of safe sometimes unsafe
and then we have to question whether
safe is actually safe anything you touch
one thing with unsafe you put everything
in question we actually don't know what
you have all verification now
window all security is on the window but
more importantly bugs that couldn't
exist without this are introduced this
is not fundamentally about security or
safety it's about the fact that
fundamental things like actual integrity
of the heap and non corruption that the
GVM actually promises and maintains very
well go away when you start using these
ideas so far handles actually are meant
to a large degree to take the things
people are using and unsafe and give
them a proper java way to achieve the
same purpose so they don't have to use
this API and the proper Java way will be
in the spec and you can rely on it being
in future versions so you can convert
your unsafe code to use that so the
purpose is to take unsafe away from you
now some of you might have noticed in
the last year in some there is some
pretty loud discussion about unsafe
going away in Java 9 and and you know is
it going away in Java 9 no I actually
think it was a great way to get people
scared I think there's I think it was
planned I think they never meant to
really take it away they just threatened
to take it away and then everybody told
them about all those things you deal
with this you can't take it away now we
have a catalogue of how people use
things we can make sure we have the
right functionality so four or five
years so now we can take it away and
that is a good purpose unsafe should not
have been there to start with the fact
people use it as bad we do want to
eradicate it but it's not going to get
it Radek ated in java night what it does
mean is if you today are using unsafe
one of the things you should look at is
how to get rid of all uses of unsafe by
using new features in java 9 and if
there's something missing complain
be loud about it make sure that we add
whatever it is needed in Java 10 or
maybe in 91 or 92 or something so that
over time we will not need this API and
I do think this is very very doable and
very achievable and it's a noble goal
for maintaining integrity in Java now
there's some other cool things in var
handles one of them not just about
getting rid of unsafe car handles also
finally have a fence
API we can actually talk about wanting
to fence things and order things what
happening to do a vault alley door
meltdown right or a lock or something
like that so you can actually say I want
to fence things so that all those are
not going to be reordered in the future
and things like that those are very
useful for concurrent algorithms and to
do those cheapest fence you need and one
very important fence that I'm
highlighting here is their ability to
add what's called a reachability fence
that says this thing is actually still
reachable and still alive until I say
otherwise the typical use will be in a
try-catch like this or sorry try finally
block the purpose of this is to make
sure that that object does not die
prematurely and cause interesting weird
things to happen like freeing buffers
and then having access to free buffers
after the fact and things
there's several fundamental places
you'll find bugs around this either and
commonly written java code or even than
the jdk itself that this will help us
solve
so that's var handles and there's a lot
of stuff you can find about var handles
the next one I want to zoom in to is
logging now here is a few of the flags
that you could do to control various
types of logging in the JVM today and a
first thing none of these have any
standards to them if you've ever tried
to read a GC long you probably
understand how complicated or weird that
is and how it changes between versions
and by collector and how it might
actually be corrupted but they're all
these other things that get logged then
they all get logged with independent
slowly evolving kind of things in Java 9
we have a common logging mechanism and a
common logging regime and it's
controlled by - X log flag and it is
specs and behavior and if you want to
look at the details and the examples of
what that means and how you can filter
on it and what the proper way for the
formats to look like it all does you can
find a lot of that in this talk that I
refer to here this is one of the
important features I believe of Java 9
again not so much affecting your
programming style but really affecting
operations quite a bit now the last
feature I want to zoom into is my
favorite feature
it's called spin weight hints and why is
it my favorite is because I built it and
in spin what hints is is an interesting
thing both in functionality and an
exercise of getting something into the
code so what does it do spin right hint
basically adds a single method to the
GDK on the thread class and it's on spin
weight and that method that's absolutely
nothing
it really does nothing there is no
semantic meaning to the method
whatsoever has no effect on state it
does absolutely nothing but it does that
nothing very fast its purpose is to do
nothing quickly now why is that
important we have this common pattern
that happens in various communication
things written in Java whether there are
high performance or low latency or
bypassers or whether it's variations of
disrupters or other spinners where you
end up wanting to wait for something and
not give up the cpu either indefinitely
literally sit there spinning on a CP
until something arrives or temporarily
for example you want to grab a lock but
somebody else is owning it you can go
block in the OS but youyou ristic say
let's spin a little while maybe it'll
get freed before I go block that spin
well would look like this and it turns
out that that's a common pattern within
the concurrency utility in the JDK it's
a common pattern a lot of interesting
software people built on top of Java and
the way to use on spin weight is simply
to put that method call inside your spin
loop it does nothing except to tell the
JVM you're in a spin loop and the JVM
can actually use that to do things
better hardware usually has capability
x86 has capability for example to spin
better to spin faster with less power
but more probably to react faster and
this is a chart comparing the reaction
time to setting a variable on a spin
wait when you have that in it or not the
blue line is the reaction time when the
spin weight in is in
the red line is the current reaction
time without it so across a wide
spectrum and percentiles we get an
improvement in reaction time over the
loop that's the purpose of this thing so
that's why we put it in a lot of people
have been asking for it for a while now
the reason I actually went through this
is not just because I wanted a
functionality because we have you know
low latency customers that want it but
also I wanted to go through the exercise
of putting a feature into Java 9 that
did not originate with Oracle and did
not get developed by Oracle to do the
actual community development thing let's
see what it takes to do it the right way
so we built the prototype then we had a
discussion and we open a gem in open JDK
and documented it and then had proposed
code and had reviews on it and
discussions and eventually it made it
into Java 9 which I'm really proud of
but the cool thing about this is it was
an opportunity to measure how long it
takes to do the minimal possible thing
that you're going to adjudicate this is
one method that does nothing you can't
do less than this this took about eight
and a half months forth which was
arguing without the name of the method
you can go look at the open to decay
mailing list for the history of that and
it's a really interesting thing to
realize there's a huge difference
between complaining and saying you want
something and actually doing it there's
real cost to this there's real work
involved next time you talk about all
those things those JDK people don't put
in remember that it is a lot of work to
get it right to put it in thinking about
the next 10 or 20 years of needing to
maintain it and not wanting to
deprecated it in the future and and
letting all that you know is this the
right name is that the right
functionality is a future proof happen
because it needs to happen it's not just
always a cool feature why don't they put
it in we need that kind of thing I'm
hoping that this is not the cost per
method that it's the cost more of a
project the minimal entry level cost but
that's roughly what it does to go in and
I do think in just asking all of you if
you do have things you want in the
platform work they participate in it
opens the key is an open project that
allows people to do this
demonstration of it actually running to
success okay so zooming out here's the
features i can assume them to and we can
ask the question of okay which of all
these things are gonna make people
actually move to Java 9 what's the cool
thing that's gonna attract them to it
and the reality is I don't really know
and I don't think a lot of other people
know but this is where hopefully we have
run for QA and some discussion and we
could talk about those questions or any
of these cool projects up there that
people might know stuff about I want to
know stuff about good more five minutes
for Q&amp;amp;A and perfect time all right so we
have about seven minutes left for
question there's a couple volunteers
that'll be walking around with with a
mic so I've got a first question so 96
Java came out a lot of the complaints at
least one night o 90 six huh so a lot of
complaints that I hear is there's a lot
of boilerplate so people use other
languages this is cleaner what's the
future look like for removing
boilerplate so the boiler clean common
is an interesting point yes there's
certainly a lot of point right in Java
and some of it actually a lambda
expressions did a lot to remove but
there's still a lot others left for
example that valve our thing is an
example of trying to use inference
instead of being explicit in discussion
I'm fairly opinionated about that I
think boiler trade is really good I
think that it's that readability of code
is more important than right ability to
code because you've read it a lot more
more often and I find it harder to read
inference based languages because my
brain has to do inference yeah then when
it actually tells me what it does but
that's a personal taste thing and you
will find very good strong argument on
the other side - as far as trends I
think the main thing that's working
towards that direction is think like Val
and far in the language and addition to
additional things that remove and add
inference of various levels making
inference for lambdas better and other
types the the move towards primitive
based collections which I put up there
and I think I might have skipped talking
about but
fact that you can have primitive keys
and collections will probably work to
help with that too because we have
implicit boilerplate around the packing
and boxing of objects today and also
performance losses great things you know
the questions
actually sort of a follow-up on that I
had this epiphany when I was I write
some libraries that I put on maven and
when I write code I write it to Java 6
so to Java 7 because I want a lot of
people to be able to use it which means
I can't use the cool stuff so I wrote
some code and because Java it is that I
wanted to accept function to expose
functional api's but not force them I
wrote some stuff and built some tests
for it and literally had to kind of
comment out the Java 8 tests that
they'll run on Java 7 and 6 and and then
you know I upgrade my IDE and I look at
my code and suddenly my code is full of
lambda expressions and I'm looking and I
said I don't remember writing these and
and I learn I have to go no it's still
commented out I didn't put this in there
and it took me about 10 minutes to
realize that IntelliJ added a feature
that Auto recognized the boilerplate
collapsed it down to lambda expression
on the screen and now I'm looking at
lambda expressions in my D so the power
of that with IDs is pretty amazing and I
had a panic attack but five minutes
before I realized what it's going I just
did you know I don't remember doing this
to the code yeah thanks for the talk
it's is great I love the the State of
the Union I'm curious like you have you
know more than 20 years of experience
what's the what's the next like
revolutionary change you'd like to see
your what do you expect could be a
difference maker like not the empty
spaceship operator but something like
generics or lambdas like what what what
what do you foresee coming next that
could be the the next big thing
um that's a tough question um you know
there's this natural inclination to talk
about how you want it to be lighter and
micro-service friendly but I actually
don't think that's fundamental I think
that's more of a job for implementations
than for the specification on language
you know whether you get a faster
compiler or not whether the garbage
collector is better that's that's an
implementation that you want to use or
not but it doesn't change the what you
have a 9 or 10 or 11 is I think that the
main trends today around value types and
arrays and and those are actually really
important ones and honestly I think I
would have preferred to have those
before some of the things that we put in
already like invoke dynamics and jigsaws
but because I think those are more
fundamental to using and performing in
the language more but again it's a
matter of taste it is hard to kind of
look forward five years and talk about
features that I think this will pop up
and and I I think that most of what
we're going to see is more involved ways
of using api's and composing them
together maybe even using external
services and composing them together in
a way that crosses languages crosses you
know it's not so much Java specific but
a good job a wrapper for the
functionality and logic if you'd like
probably get hit for saying this but you
know Jeff of the Java EE is sort of a
very slow stale fat elephant that's not
moving fast enough and there are a lot
of efforts out there to do smaller to
Java EE that's still very useful for
programming as a platform small
containers micro profiles things like
that I think there's a part of that that
needs to go into the SE platform for
example we're sorely missing JA JSON
handling capabilities that are standard
yeah there's 17 good implementations but
I'd like one that works everyone I don't
have
depending on in on top of that taking
more of the features of people think of
as container features and making of
sander parts of the platform it is what
we find in environments like JavaScript
with node and Python and other things
with that the basic platform already
includes basic capability that we think
of as a container capability I'd like to
see more of that but again it's hard to
develop an intuition for what the right
thing is in five years slow and steady
and keep it compatible and don't break
things it's more important I think for
Java then sexy and cool and change every
year up here in the front of it
so a little bit back to the boilerplate
concept I'm a huge fan of project Lombok
I don't know if you're familiar with it
or not it allows you to avoid a bunch of
boilerplate in Java have you seen or are
you interested in seeing a lot of more
development in annotation processors at
compile time that can help alleviate
some of those pain points so annotation
processors are kind of an interesting
two-edged sword I think annotation
processors for project specific uses or
outside of the spec uses or interesting
capabilities they kind of evolved on
their own into an ecosystem or not you
can look at spring as a good example of
that too
but I see things that were in the
platform standard annotation so the
ability to rely on annotation processor
always being there as something I'd like
to do I've I've looked at various places
where I the only right way to do it
would have been with annotations however
it's since you don't have a built-in way
to force the annotation processor to run
everywhere the libraries used it it's
kind of clunky to put them in you know
yes it will work if you do these things
but it's hard for the library to require
and enforce that those things will be
done which means that there's some
unknown instructions posted somewhere on
how to use it one that certainly has
that going for it like or you can sit
down whatever you want to call it so I
think things in the platform that will
allow you to incorporate the
requirements of annotation
processors for code to require the
annotation processor to exist and pre
process the code before it ever gets
loaded and for Africa verifiers to
actually enforce those for example I
think those would be useful so something
like Wambach could say that code in some
way in the declarations of the packages
doesn't mean anything unless this
processor ran on it because today the
annotations are actually optional and
things break if you don't run them the
right way okay last question go back
here nice talk I just heard a question
anything interesting coming with the
Java secure socket extension in the
future releases especially from an
interoperability standpoint so there's
simple answers I don't know I really
don't know I have no idea so I hope the
answer is yes okay but I really don't
know so git will be around for about 25
minutes before the next session thank
you go great talk</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>