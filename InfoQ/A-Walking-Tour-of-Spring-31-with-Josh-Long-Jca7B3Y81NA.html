<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Walking Tour of Spring 3.1 with Josh Long | Coder Coacher - Coaching Coders</title><meta content="A Walking Tour of Spring 3.1 with Josh Long - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Walking Tour of Spring 3.1 with Josh Long</b></h2><h5 class="post__date">2012-09-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Jca7B3Y81NA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to my talk I'm Josh along the
spring developer advocate for spring
source today we're gonna talk about a
spring naturally spring 3:1 and I've
also got some content related to this
some of the other projects the and
ciliary projects besides spring core if
you have questions please feel free to
ask as we go it's quite literally small
enough that I could go to each one of
your laptops and stare of your shoulders
and answer questions that can be good
for us I have written some books on
spring not all of them good but I drew I
do try here's two of them working on
Cloud Foundry in action for Manning
right now and it's actually got a whole
bunch of stuff related to the spring
projects it's about building spring
applications for the cloud it happens to
be tangentially about boundary between
you and me this is just a little secret
since there's only a few of us here just
a handful I have written five books I'm
working on my fifth book now but I don't
know why people buy them that's the
secret
I'm not sure why they buy them you don't
need to the spring project documentation
has always been very very good so if you
check out spring sourcefed org there's a
lot of great documentation that's second
to none and and in particular that rule
book should go to spring source data
agra fort / rue it's free we give it
away I got a rally to go open source on
the book so yeah anyway that's me take
down that email take that in that
Twitter handle if you have questions
complaints comments please feel free to
reach out to me after the talk I'm more
than happy to answer questions if you
for some reason leave this room more
confused than when you came in that's
your recourse
right there that email okay I don't be
happy to give it you at any point in the
presentation so we're here for very
common refrains right we're here for
very common reasons which is we're using
spring and we're using it to solve
interesting problems and the problems
that people typically solve with it are
many fold right you've got the
productivity problems and you've got
problems that are solved by frameworks
and libraries and you've got your
application that sits on top of that
but very very salient Lee we have a very
diverse sort of ecosystem of target
platforms today right so a lot of people
how many of you've been using spring
them in just show of hands how many of
you have been using spring for five
years okay so you kind of remember I
mean I've been using spring since it
came out and I can remember hearing
these ideal sort of discussions about
how spring could help it engendered
portability in your applications right
and so if you're using spring back in
2003 it meant you could get away from
web the web spheres of the world
and get on to lighter more agile more
scalable little platforms like Tomcat
you know lightweight application servers
well nowadays we're hearing that same
sort of migration that Exodus we're
seeing that same sort of thing from
application servers in general to more
cloudy platforms like like cloud foundry
of course and other as well so the the
nature of our applications has changed a
lot the architecture has changed a lot
and having a shim underneath your code
underneath your application that lets
you move portably and cleanly to adapt
to these different types of
architectures is more important than
ever right because the cloud doesn't
look very much like anything that we had
before whereas Tomcat kind of looked
like something we had before we've also
got bigger data right how many of you
doing something with big data no sequel
or not only is equal yeah it's here to
stay we can't ignore it it's something
that's gonna be part of what we're doing
for the foreseeable future
and for good reason right this is a good
problem this is a great problem we have
too much data used to be that we
couldn't get enough data right we
couldn't have we didn't have enough
meaningful insight into the the data of
our application the data of our users
the data of our domains nowadays it
seems like it's coming out of our pores
all we got to do is collect it and
dealing with that efficiently and
effectively is a very very big problem
pun intended so we have environments
like Redis and MongoDB that are very
very popular today we have distributed
data caches like Jim how many of using
Jim fire eh cache or coherence or you
know something right if there's a
there's caches out there right now
designed again to solve these very sorts
of problems
and of course in that space there's a
speck days are 107 which has been
dormant hitherto dormant since the
inception of that jsr like five six
years ago and it isn't it is now seeing
a resurgence a new uptake and they're
redeveloping it or they're reinvesting
energy in developing it and of course
spring will have support for that you
know we also have a very wide variety of
clients do you guys remember when the
whole world was you know the whole
problem that we faced as developers was
making things work on Internet Explorer
6 and Netscape 4 in the desktop browser
and that was it everything else was sort
of why would you care you know who cares
about some sort of imaginary tablet that
looks like it comes from Star Trek who
cares about some sort of smartphone that
we hadn't seen yet you know it's just
Internet Explorer 6 and Netscape 4 well
things have gotten a lot more painful
since then right back I would kill to
have those same problems of just trying
to make things work on just those two
browsers nowadays you've got to make
your application you've got to expose
your application not just to your your
web browsers not just your desktop web
browsers of which there are at least
four right you got Safari Chrome Firefox
and oh yeah Internet Explorer you've
also got these portable sort of form
factor devices these small form factor
devices like the tablets and the phones
and so on and all those have their own
sort of quirks and compatibility
problems so we're definitely facing a
different landscape when it comes to
delivery of client technologies how many
of you just so I know we're not two-step
how many of you are using JSF come on in
a minute we all tried it once in college
you you guys oh yeah good you know it's
still it's still out there like the
dinosaurs you know but eventually some
comments gonna come down and we'll see
um so okay this is the sort of the
oldest slide I've ever had this is my
favorite slide it's been it's been
around this is the new 2010's version of
this slide but it's still the same slide
basically I've just happened to have
fancy vector gradients now it's been
it's evolved like I have you notice that
my belt buckle has adopted with the
years this slide has been around since
day one we've had some version of the
slide for many years
it describes the three pillars on which
Spring Framework itself is built right
so we've always said that with these
three different things plus good
documentation we can provide solutions
and the pillars are very important first
of all you have of course dependency
injection the Spring Framework itself
provides dependency injection it's a
form of information hiding right so at
runtime you don't know about the
characteristics of the specific
implementation you're using you build
code according to certain baseline
usually interfaces in Java and that
contract is all that you have to care
about you don't care about what
implementation you have it run time and
that makes it very easy to move your
application from test to production to
unit testing to etc right we also try
and provide wherever possible aspect
oriented programming aspect oriented
programming lets you change the behavior
of objects declaratively without
actually touching the code this is very
powerful right because we can now apply
services in a generic fashion to all
your objects so transaction management
is a very common example but logging and
auditing and filtering and things like
that right that's very powerful so we
make that available and make that a key
part of the framework as well and then
finally where we can't solve problems
using regular dependency injection and
pojos and where we cannot solve the
problem using aspect oriented
programming we provide libraries objects
that you have to compile your code
against so now you have a dependency on
the Spring Framework but wherever
possible we try and make those
dependencies as useful as possible right
so if you're going to use them we want
them to be the most useful thing you
could ever imagine using right at some
point you're gonna have to tie or tie
yourself to some sort of API but let it
at least be productive let it at least
be efficient and then all those things
taking together don't mean anything if
there's no good documentation on how to
use it if there's no guidance right so
the Spring Framework has been it's
always been about good code coupled with
good documentation and good
dissemination of information so if you
check out spring starter org there's a
lot of resources that'll help you get
started right like I said okay so that's
sort of the background today we're gonna
talk about spring 3:1 if we have time
we'll look at some of the to one stuff
and the spring data stuff and spring
security but you know I
holy and completely doubt we'll get
there we'll try though um how many how
many of you have looked at spring three
one so far some of the new bits which
version of Springer you guys using two
five two five two oh three oh okay three
oh good
so three oh is sort of the that's
starting to become the the curve right
it's there's a long cuz a long curve
between upgrade iterations so we see a
lot of people working on two five and of
course now they're steadily migrating to
three oh and three one of course now
that three one is out three one was
debut it was released last November
after about a year and a half of betas
releases so it's a very very well tested
well integrated release and if you have
any plans to upgrade just skip three and
go to three one because it really is the
conceptually complete iteration it's the
one that makes most ends in of itself it
it feels whole you know there's a lot of
new features there's environment the
environment abstraction and profiles of
course Java based configuration which
got a major overhaul in this release the
test framework itself has been adopted
to support the Java based configuration
and the environment abstraction we've
introduced a cache abstraction which is
one of my personal little favorite
features we've introduced partial not
done yet but we're still working on it
we've been Drew's partial support for
servlet three the support that will mean
the most for most people anyway we've
introduced that we've upgraded the
spring MVC engine to support new
features we added support for JPA and
hibernate for and corpse 2.0 and Java 7
so Java 7 actually debuted last July I
think you guys might remember and of
course spring was released a few months
after that so it was one of the first
enterprise it was the first enterprise
technology that was available that had
support where appropriate for Java and
Java 7 specific features this is not to
say that you need Java 7 to use spring 3
1 it's just that if it's available at
runtime we detect that and they can take
advantage of it for for things like the
thread pools
okay so as we go through this I'm gonna
work in terms of a little application I
built I hesitate to introduce it now but
just so we have a common background this
is my little spring 3:1 application
I built it on it's got a whole bunch of
little features including some of the
stuff we're gonna talk about here today
you can get it at github comm ford slash
cloud foundry - samples and it's the
spring MVC hibernate template basically
it's just a simple application
I started it up but I didn't have a time
to test it so cross your fingers demo
fail that's okay good
we need to spring ABC 3-1 good ah so
there's that good okay the application
itself is not all that interesting but
you can see it's a very sort of generic
database centric application we'll go
through the code though so first things
first the environment abstraction this
is one of those things that was
introduced inside of spring 3:1 it is
basically a way to ask in a programmatic
way the spring container for information
about the environment in which your
application is running so you can ask
you're gonna say okay you know I need
property files how many of you use the
property placeholder resolution
mechanism inside of the Spring Framework
right you can parameterize your
configuration based on property files
previously people have wanted to do
things like well you know how can I make
that property resolved to dev random you
know I want entropy application I don't
want this to be predictable or I want
this to come out of J&amp;amp;I or you know I've
got a I've got a rat going crazy in the
back lab and he needs to whatever he
runs I want a new password changed you
know or something I don't know so having
that plug ability SPI is very important
and that is facilitated through this new
environment spi these these abstractions
right the idea is that you have these
beans you might have one set of beans we
you know you might have one to the beans
that's used in production another set of
being that's used in test I mean if you
guys have created different types of
being groupings different config files
and then you switched out the files
based on the environment you're in right
very common sort of idiom very common
sort of practice and this feature
codifies that right it makes it a
first-class citizen inside the spring
framework it at practice it just means
that you have an object called the
environment object that you can inject
right and you can ask that object
questions like I need a property and I
want that property resolved against some
sort of custom property SBI property
resolution SPI that's the property
resolver interface so if you plug that
in you can control how properties
themselves are resolved and it also
means you can ask what profile is my
spring context running in am i running
in tests am i running in production
am i running in dev you know you can ask
questions about that through that
environment object using the definitions
the profiles themselves looks kind of
like this right this is what it looks
like in the XML normally you have a an
XML document and then at the top you'll
have a beans element and then below that
you'll have beans individual bean
definitions with this new profile
support you can actually nest beans
declarations inside of your your
outermost beans tag so these are
actually nested you can imagine one more
beans tag at the top of the document and
one more at the bottom wrapping these
two different chunks the beans that are
inside of the beans declaration are
grouped together inside of a profile so
they are only active if that profile is
active right so you have to say do you
have to tell spring somehow that I want
all the beans that are in my production
profile to be active otherwise it's as
though you didn't register the beans at
all right they're there they're hidden
they're transparent to the Container
questions on that okay so you can see
here we've got a production profile and
an embedded profile in production we've
got a proper data source pointing to
some sort of resource that we've got
configured using property placeholder
properties and then for our embedded
integration tests or unit sorry unit
test scenario we've got a little
in-memory
embedded database that we spin up in
tests against right so all you got to do
when you move this application is switch
which profile is active and then the
different data source is alive notice
that both beans both data sources
produce an object of type datasource
javac steps equal that data sources yeah
well gets it so the question is how do
you trigger the profile and we'll look
at that in just a second there's a few
different ways you know the result is
that you have two different beans that
both produce the type of javac
subsequent data source just like with
regular spring if you created two beans
of the same type and gave them both the
same ID and you activated both profiles
you would get a conflict right you can't
have two beans of the same type an ID in
spring in regular spring it's it's also
true if you activate both profiles at
the same time you'll get a conflict so
be wary there is analogous support for
profiles using the annotations right in
the Java configuration so you can use
the add profile annotation on Java
configuration classes we'll look at that
in a second
and you can use that also on individual
beans that you annotate this type this
approach is probably I wouldn't do that
I wouldn't I wouldn't use the profile
beans on individual beat on individual
components right better to keep that
inside the configuration but we'll look
at it anyway there's a couple of
supported out-of-the-box idioms for
activating profiles generically you can
set a system property so dDOT's bring
that profiles that active equals and
then a comment delimited list of the
profiles that you want to enable so
production comma you know my data center
one or whatever I mean you can set up
you can set up whatever you want this is
one way to do it it's a convenience the
right way to do it is actually to get a
reference to the application context a
pointer to that application context and
then from there you can get a reference
to the environment and then set the
active profile programmatically so if
you have some sort of decision that
needs to be made before you can activate
a profile you can make that decision no
problem and in fact in a web environment
where you don't have you know in a web
environment spring boots itself up as
part of the servlet as part as part of
the dispatcher servlet initialization in
that environment you actually have a
callback
class they get to run right before the
application context is you know brought
into life and in that in that scenario
you can actually write your programmatic
logic for activating certain profiles
and so on before the container starts
registering beans let's see okay so we
saw that let's see let's go through the
Java based configuration and then we'll
look at both of these examples I mean
you guys some of you said you're using
spring three oh okay
spring trio debuted Java based
configuration Java based configuration
itself is something that a lot we've had
support for in in a separate project
called Spring Java config and that was
available as a standalone project for
many many years now it's available baked
into the core of the framework right the
idea is that you have XML for defining
beans and then before we've had support
for scattering annotations on your
different classes to have spring collect
sweep up the beans and then register
them for you right but there was kind of
a space there still for one other
solution right a something that had the
best of both worlds you wanted the
static type safety of the Java and
annotations but you also wanted the
single resource that you could consult
to see the world view of your all your
beans right so Java configuration feels
that niche it provides the ability to
define all the beans in your in your
application in one place using Java we
have in three one introduced support for
things that you could do before using
xml namespace declarations right so for
example in spring 3 oh and before if you
wanted to turn on transaction management
it's as simple as saying TX colon
annotation - driven in the XML right one
little line turns on the feature spring
has always been you have to opt in you
have to say I want this service I want
this behavior we don't we don't make a
lot of assumptions about how you want
your beans to behave at runtime so we
have all these great little features
that are one mine away when you turn
them on they apply to the beans that are
in your application context where
appropriate you know and they provide a
lot of features a lot of functionality
but you still have
to turn them on so one thing that was
kind of missing from our original
support for Java configuration was an
annotation Java centric way of turning
on these features right once you've
turned them on they're very easy to use
they're just declarative you know the
lamentation based things let's see so
we've done that we've provided these
little you know switches these little
enabling annotations for lots of the
things that you would have used XML
before before like transaction
management and scheduling in the spring
MVC container and so on so here's an
example of a Java configuration class
this is a sort of you know very
interesting very plain sort of the
configuration class the first thing to
notice is that it's a regular Java class
that has at configuration at the top and
configuration is a special type of
component by this for the Spring
Framework right when spring sees add
configuration on the class it treats
that like a an artifact from which it
can draw information about your beans
remember according to spring all your
beans are the same thing at the same at
the end of the day when all your beans
are managed by the spring container
doesn't matter how they got in there
right it doesn't matter if you used
annotations on your component classes
it doesn't matter if you used XML or the
groovy bean builder or or or namespaces
or anything or Java config right they
all end up in the same big bag of beans
at runtime so this is just one more way
of telling spring about which objects
you want it to manage right so we have a
configuration class this is the Java
version of an XML file right this is not
a business class itself this is
configuration when when spring sees the
add configuration annotation it'll sift
through the class it'll create the class
and then sift through it looking for all
the methods that have at bean on it when
it sees at bean it's going to invoke the
method and then create that bean for you
know get the reason we get the return
object and then store that in the
context just like if you had done a bean
bean declaration in the XML so in this
case we have at bean public platform
transaction manager TX manager the ID of
the bean in this case is TX manager it's
the name of the method the type of the
bean in this case the class is platform
transaction manager which spring can get
at one time based on the return value of
the method and you can see that because
it's just a regular method you can do
whatever you want to set it up there's
no you know you're no longer beholden to
rules about you know one you have to
have a no argument constructor for
example you know that stuff you can do
whatever you want you can initialize the
mean however you need to so you have the
ability to use the full power of the
Java language inside these methods
construct the object however you want
and then return that and have spring
manage that with the same guarantees it
would give any bean that you registered
in the XML you can see here also we have
interdependence between beans right
we've got the platform transaction
measure the platform transaction manager
itself depends on the hibernate sorry on
the session factory right so the session
factory is a a bean that we would
specify as a reference in the XML right
can you imagine that a bean you've got a
property and then it says ref and it
references the ID of some of the bean in
this case and to do the same thing we
just call the method call a method that
creates the other bean and spring will
automatically intercept that call cache
the result and then configure it and
then return that value once it's been
run through the lifecycle promises of
the of the container so you have the
same semantics as if you were using the
XML if you call that if you call session
factory a hundred times you still just
get the same object it doesn't get
recreated a hundred times it's just the
same cached object that has been given
all the lifecycle callbacks and
everything right with me on this okay
let's see the other thing we've done is
that we've wherever possible we've
introduced cleaner ways of building
complex objects right and the spring
container we've historically used
factory beans factory beans are a way of
codifying how to create objects we've
hidden you know we've hidden the recipe
for creating a complex object inside of
a factory bean that's the value of that
pattern
well now that you're using Java and
using just Java config sometimes it's
easier to use more elegant more succinct
approaches like the Builder pattern so
here we have a local session factory
builder
which you can chain together and then in
one line build yourself a hibernate
session factory right
so we provide those objects where we're
appropriate you know the other thing to
notice and this is the thing that has
changed since the introduction of 3oh is
we've added these annotations to enable
some of those features I was talking
about so in this case I want all the
beans in my spring configuration class
to have transaction management applied
to it right so I've added at enable
transaction management on the
configuration class that annotation
turns on transaction management for all
the other beans and making my context
this is the same as if I was using TX :
annotation driven in the XML right so
you can see here I wouldn't need the XML
at all you'll also note that in this
case we don't have to specify a
transaction manager attribute or an
attitude you know an option for the
annotation because this type safe so at
runtime we can just pick the platform
transaction manager out of the defined
beans right you don't need the
annotation you don't need to specify it
directly another big feature another
thing that's got another kind of an
upgrade is the test support so we
introduced contexts we introduced
profiles and that's only only useful if
you can now test it right so the next
thing is ok when I'm running my unit
test I want to be able to specify which
profile is active when I run my tests so
that the write beans are active during
my tests so here I have an annotation I
have at active profiles on my unit test
this is just the standard spring test
framework right there's test running
framework that we've had since 2-5 where
you specify the context configuration
and you specify what kind of test runner
you would like right so you can this is
a spring mechanism that works for both
test ng and for JN and for you're
specifying that you want a certain type
of application context in this case we
want an annotation application context
and we're specifying that the
application context should look at these
configuration classes instead of an XML
file we're saying look at these Java
config classes
right and then at the bottom we're
saying I want this profile to be active
right so the beans that are defined
inside those configuration classes only
if they have an ad profile on them that
says dev or if they have no profile
annotation on them at all that's filling
it those lonely beans that'll be active
questions on that one okay let's so
let's actually see what that looks like
in practice here we've covered it quite
a few things already can you guys see
this in the back yeah no no this is an
addition too so you can still use XML
that's not going anywhere
it's very much a very good idea to use
if you want to absolutely and you know
the ideas that it's just a strategy
right it's just one more way of solving
the problem based on your tastes so if
you want to use the classpath xml
application context and you want to
specify an XML file as the argument for
that class Pathak's of my application
context more power to you man awesome
rock on you know we just happen to have
other ways of doing it now so you have
an annotation config application context
that takes as its inputs Java classes
and those Java classes are annotated
with that configuration like we saw so
it's just one more way of telling spring
the metadata that it needs to be able to
do the things that it does for you right
one more input let's see so so here's a
couple here's a simple actually kind of
a simple application the idea is that
this is an application that has a data
source there we go
it's got the same sort of it's got the
same sort of things you'd think you'd
expect most applications to have right I
have a data source I have a definition
that needs a data source I'm trying to
build a platform transaction manager
which manages transaction management in
spring it's a it's the feature that lets
you write code in a transactional way
agnostic of the underlying transactional
resource so if you're using hibernate or
JTA or JPA or JDO or
you know regular JDBC it's all wrapped
up by the platform transaction manager
SPI right you just specify the right
type and then in your code you can just
say add transactional add transactional
on the methods and they get
automatically they automatically
delegate to the correct instance of the
platform transaction manager configured
in your context common thing just
reiterating it for now the hibernate
transaction management needs a pointer
to a session factory so you can see I'm
using Java config here when I call this
guy session factory it calls this method
over here and then here I'm building a
map for properties and I'm then I'm
building a local session factory builder
and passing in the datasource adding my
annotated hibernate you know JPA classes
and then building the session factor
itself right you can see here I've got
an injected reference to another class a
type data source configuration right so
now that I have this ability to use Java
I might as well take advantage of some
of the flexibility that it gives me
right like object orientation and in
hierarchies and you know etc so here
I've got an interface and the interface
defines methods that have the objects
that I need in my application because I
intend to run this application in
different environments I need to have
that extracted out right so I know that
I need a working definition for a cache
manager I know that I need a working
definition for a data source and I know
that I need certain hibernate specific
properties based on the kind of
environment I'm running in so I've
extracted that responsibility out into
this little interface and I've created a
couple of different implementations of
the interface right so here's my local
data source implementation based on a
profile right so it's got at profile
local and it implements data source
configuration and it provides a data
source right here using an embedded
database and it provides a local cache
manager using you know using a regular
cache we'll just look at that in a
minute in memory cache and I've got my
little hibernate property is set here to
set up the database and so on so that
that is one version of this interface
again I'm just I'm just declaring a
dependency on that interface it's a
configuration class
expect one of the implementations to be
active I can specify one for development
one for production etc here's the cloudy
version in that same interface so again
at configuration class but the profiles
now cloud and I've specified another I
specified another type of data source
but this time I'm looking at my data
source from there's the Cloud Foundry
context I'm actually dynamically
creating the data source itself instead
of creating an in-memory data source I'm
looking it up from some sort of external
resource you might look up the data
source from Jane di in production you
might look at it from some other place
that's managed you know I also need a
more heavy-duty cache manager so here
I'm actually relying on Redis this code
will only run on a cloud right it's not
gonna run locally whoops
or at all if I need that there and I've
changed the properties here right so
again at runtime based on the active
profile only one implementation this
interface is going to be available and
it'll be injected into my services
configuration and then from there I can
call data source configuration dot
contributed session factory properties I
can call data source configuration data
source and I can call oh well that's it
and then and then the other thing it
does that contribute to cache manager to
the context so you have all these beans
defined conditionally based on the
active profile because I'm relying on
certain declarative services like
transaction management and like caching
I've got at enable caching and an act
enabled transaction management that
turns on these features for the beans in
my configuration right ok questions on
that one Kristen's on any of that stuff
ok a new feature that we have in the
spring 3 one and this one this one is
you know probably the least interesting
feature ever I mean you guys might like
it it's pretty cool it's nice it's just
so small and adorable but I give it a
slide anyway cuz it's awesome the idea
is that you have you've had historically
this P colon namespace
this P : property namespace and how many
of you have used that by the way the P
namespace if you write your typical beam
definitions in spring you have to say
beam class equals whatever and then you
say ID equals you know foo and then you
have property and then name equals you
know age and then value equals whatever
and then property equals whatever and
then it's a trend so you have these
stanzas of property elements underneath
each beam tag well if we're honest with
ourselves that could be more succinctly
written as one element with attributes
instead of inner elements right so
instead of saying being and then
property property property you can just
say beam and then P : age and P : name
etc and you just P : name equals and
then you said the value of the of the
property that's good for properties and
you know a lot of people have used it
it's very elegant but there has been a a
clamoring people have cried murder they
want something bigger and better for
constructors and who can blame them so
with 3-1 we debuted the constructor
namespace the constructor namespace
provides the constructor support for
what the P namespace didn't inside of
previous releases right so now if you
have a constructor and you want a way of
using that constructor inline inside
your beam definitions inside the
definitions in your XML you can just use
the C namespace write a small note this
feature requires that your code be
turned on with debugging symbols
activate it right which most the time it
is going to be anyway but you know just
a note okay so finally okay so the cash
abstraction this is one of my personal
favorite features it's got so much
applicable application and a lot of
people are doing today that it wouldn't
surprise me if it's one of your favorite
features as well as we talked about
earlier whenever we can we try and
provide useful abstractions on top of
otherwise sort of disparate technology
surface areas right so for example
transaction management is one of those
places where spring provides an immense
value by unifying the api's and
providing a common facilitating abstract
right another one is cashing right how
many of you've got some sort of pattern
in your code where you do some sort of
expensive computation check a resource
if the value comes back then you stick
it in the cache and then check that
cache and all subsequent lookups for
that same method right it's a very
common ATM we've I'm sure done the the
dance is only in different times in our
code but the thing of it is that's a
very common idiom there's no reason you
should have to rewrite it each time just
like you shouldn't have to rewrite
transaction management it's something
that a lot of us are going to do many
many times per application it's
something that is also imminently suited
to aspect oriented programming you know
it can be extracted out as an aspect and
then applied across all your objects you
know in a one quick one clean stroke
right so the cache manager API and the
cache abstraction provide that ability
the idea is that you have the cache
manager implementations and those
abstract away knowledge about backing
caches like gem fire like Redis like
coherence like you know eh cache etc and
then you have the cache objects which
you can also get references to right and
the cache objects are they represent
individual regions in which objects live
inside the cache as I mentioned earlier
this this is increasingly important
nowadays because we're seeing caches
being made available as a very common
default in different technologies
particularly in the cloud you're seeing
people adopt things like Redis how many
of you guys have heard of Redis it's a
it's a small little project very very
you know quaint some very small websites
are starting to use it how many of you
have heard of Stack Overflow ok yeah
they're using it for example you know
few billion requests not nothing big
nothing you know the right mom about
everything but still it's getting out
there you know and so people are
starting to use these technologies
because they need serious scale we all
know what happens when you push Oracle
too hard you've never seen a more
expensive fall in your life you know so
caching is a very very valuable thing
this is the thing that'll save the
databases I think
it's okay so we introduced the caching
support in 3-1 good awesome we've
already got several different
implementations that you can use out of
the box for each cache and for the Java
that you told about maps and for Redis
and so on other projects like spring
data Redis provide implementations for
which that's the the reddest
implementation the gem fire
implementation comes swings was from
string data gem fire other projects out
there in the in the open-source
community also provide implementations
so how many of you are using infini span
from the the JBoss guys it's a pretty
neat little cash and they actually have
an implementation the cache manager spi
as well right there's other like hazel
cast I think has one as well I mean
there's just a lot of different
implementations being provided already
by third-party people right
and additionally spring is spring is the
first enterprise technology to provide
support for Jace r107
right so will have it will have once
that spec goes final once it's solid
it'll be supporting spring 3 2 which
should debut long before Java EE 7 right
so you'll have a they'll have the
ability to access all these JSON 107
supporting cache implementations again
again with a little bit of chagrin
before the rest of the the w7 stack so
one common use case is okay like I just
showed you I showed you one version of a
cache that relies on just Java dot util
dot map in memory for my testing but
then when I'm in production I want to
delegate to Redis right
how would you achieve that in a real
application well profiles happens to be
a great use for that right you can
specify that this is one definition for
one environment and one for another so
here's kind of some examples right it's
very simple you say at enable caching in
your configuration class or you use the
XML namespace you say cache colon
annotations driven and you define a
cache manager like we did and then in
your domain code your component code you
can just annotate your methods right and
it would take your interfaces if you
want but you annotate the methods that
return you dem potent values so it's
we've all done the factorial example
where you memorize the return value of a
of a computation so each input is gonna
be a constant output so you might as
well just cache it and not bother
recomputing each time right to use that
to use this annotation for that kind of
thing it's pretty easy you can actually
do add cashable and then whenever
somebody invokes load owner the result
the owner object will be cached in the
backing cache store that we talked about
they you know managed by that cache
manager so if you have eh cache it'll
get stored in the edge cache for you the
key will be computed based on the
arguments to the method so you can
imagine a common scenario look up my
customer by its ID
well once I've looked it up I don't
wanna look it up again and again I want
to cache the result it's probably not
gonna change the only time I want to
look it up again is when the customer
object itself has changed in which case
I want to expire the records right so
here I've got an ID that's the key and
then the owner itself is going to be
stored in the cache you can specify
condition so you can use this spring
expression language to conditionally
stipulate that certain beans should be
used at certain times right or should be
cashed based on some conditions and you
can do anything and this is just kind of
a silly example but the spring
expression language is like how many of
you guys have used the JSF expression
language okay now imagine if that had
support for it most things you wanted to
do how many of you've used the jennipher
expression language but then also said
no screw it I need to use the JBoss
expression language because it's got
more power or I want to use something
completely different like there's like
what's that other one that used to be so
popular that's in tape estrella
ogl you know more powerful expression
language so the spring expression
language is a very large superset of
most of those it's got a lot of power so
you can actually call methods on this on
these beans you can access environment
variables you can access static methods
etc so you can do anything you want in
that expression language to make the
decision based on whether it being
should be accessed very easy right so
here's an example of that in this case
here I'm saying if the argument name has
a length that's less than 10 characters
then cache the result I don't know why
that's in a useful case but whatever you
know
otherwise don't cash it so you can get
really fancy based on the rules there's
no there's no it's not either-or right
and of course the for every time you put
an object in there's probably some
useful scenario where you want to take
the object out right like Bill Cosby I
put you I brought you into this world I
can take you out so at Cash evict tell
spring that whatever somebody calls this
method you want to delete the
corresponding entry in the cache when it
evict it from the cache alright so
you've got support for caching and then
I'm caching based on the same rules by
the way same same key resolution
algorithm the the parameters to the
method themselves become used in the
creation of a key that has looked that
is used to look up the object and then
delete it let's see here I have in my
little example here services very very
centered a simple pedestrian example
I've got a bunch of methods here that
returned data right and I want them
stored in the customers region here I'm
specifying which region in the cache to
use because it's just annotations you
can you actually use a static private
final constant if you want you don't
have to retype that in each time in this
case the region itself is just a string
customers so if you don't specify the
region you know you need to specify a
region basically see it's more useful
and this is a good way to do it instead
of repeating the string each time so you
can see I've got customer get customer
buy ID I specify the key as the ID and
then I'm storing the result
I've got cache evict on my delete
customer method right and same thing for
cache evict I've got the update
customers method here but here I've got
a special case here I've got multiple
parameters and I only want the first one
to be consulted because remember before
I stored the objects by key based on its
ID
well when the spring when spring sees
the update customer method it's gonna
create the key based on ID first name
last name in the birthday which I don't
want that would be there's no value in
the cache that matches that that a that
composite right so you can specify that
spring should only consult the
first parameter the ID parameter right
so you can actually get you can get very
very fine-grained control over which
parameters are used in creating the
composite key and so on any questions on
that before I continue okay so another
big part of this the spring 3 1 release
was the support for servlet 3o the
initial support for serve the 3 all the
rest some of the more exotic support
that most people aren't using anyway yet
will be available in spring 3 too and
there's already early access releases
and I that you can get if you look at
the blood that Springs from stroke you
can see people talking about the new
features in spring 3 2 and the spring
MVC support for asynchronous processing
and spring 3 2 already so show of hands
how many of you guys using Tomcat
something like it ok cool
Tomcat 6 crickets 7 yeah ok
how many of you guys are using GlassFish
I just I just say that to be nice I
don't think it was using it but it's
always nice to ask let's try it again
how many of you guys have met somebody
who once knew somebody who once used or
maybe looked at or downloaded a class
fish once even went if you did it once
that's enough anybody ok um well I tried
anyway the point is these these
containers have servlet 3.0 support 3.0
is actually pretty awesome and the
servlet 3 stuff is looking really good
you know it codifies a lot of the stuff
that was previously baked as as sort of
extensions to these containers
you know out-of-band extension that you
could use if you wanted to but they
weren't part of the servlet container
themselves by default certainly not part
of any spec and we've embraced those
features wherever possible so one big
part of that is setup for XML free web
apps right how many of you I mean you
guys are doing web programming with Java
I imagine show of hand yeah so you've
done a web that XML or 2 or 10 or 1,000
web that XML itself is sort of this I
mean
the specs make you use XML a lot you
know and spring has always been about
choice so it's nice to see them finally
embracing that the servlet 3oh stuff
doesn't require you to use web that XML
right
and so we've embraced that we actually
provide support for using completely
Java centric completely XML free web
applications the idea is that you
register a component that implement Aged
implements the servlet container it
works with spring support for the
servlet container initializer SPI right
in servlet Rio and whenever spring sees
these beans it'll launch them and then
it gives you a callback and a pointer to
the to the servlet context and then from
there you can programmatically register
servlets and filters and all that stuff
just like you would with web that XML
but it's in Java code so you have the
same ability as you did before to
programmatically build this kind of
stuff you know let's look over that
actually so this is
just swing application context initial
either now in this example no because
this is supposed to run on yeah let's go
different one github.com
so our config let's see if that has it
yeah there we go
that's what I'm looking for so here's a
very simple completely XML free sort of
a web application built on spring 3 1
and using servlet Rio and all that stuff
so again if you looked at a lot of what
we've done so far
we created a hibernate we set up
hibernate earlier hibernate had no XML
at all right we set up just completely
in Java
we're setting up a web application here
again no XML at all we could have used
JPA that we wouldn't have required to
XML in basically spring through when is
the only enterprise technology that lets
you completely avoid XML if you want to
you know it's kind of very it's very
very easy to write clean applications
quickly
where did I put it
mmm can't find a good reference to it
okay anyway bless you I'll find a good
example but the basic eights you can
write web that XML free versions of your
spring applications no problem at all
it's very easy we also have support for
sir I mean in server 3 oh we've what's
up yeah this is all three one as well
right in server three oh we've exposed
we support now whenever possible they've
the file upload to support the part API
the servlet part multi-part API is
inside of serve with fail basically how
many of you guys have used Commons file
upload yeah okay it's an old standby
right spring is very smart when spring
MVC gets started up when you have the
app enable web MVC spring starts up and
it detects the presence of comments file
upload on the class path and if it's
there then you can automatically submit
form data with files in it to a spring
MVC controller and the controller will
accept it as a parameter and it'll
automatically marshal it for an object
that you can get access to right like a
multi-part my object whatever and you
can pick it pick that object apart and
get the file name and get the input
stream and all that stuff
well now if it detects servlet three Oh
file upload support it'll also support
it there and you don't need common file
upload anymore right so in both cases
it's to you if you just have the support
available it's just transparent your
file uploads will automatically work you
can create your controllers with you
know all that stuff no problem oh here
we go here's the web app web application
initializer that I was trying to show
you guys are here if you create a class
like this and put it your class path
somewhere spring will detect it when
spring starts up and then it'll it'll
give you a call back and you can
actually create through annotation
config web application context set the
packages to scan register configuration
classes and then register that as a
listener right so here we've got the
context loader listener you could also
register servlet context add dispatcher
servlet you know you're gonna add a
servlet you could add the spring filters
and so on right all from Java so this is
in lieu of instead of web dead XML okay
so completely XML
for you in shipping NBC we've also added
support for things like the flash scope
and we've also very very extensively
sort of reworked the internals of spring
MVC some of the stuff you won't care
about for the very large 80% 90% case
right but we've also made it so that you
can plug in different types of behavior
based on the return values of controller
methods and based on the arguments of
those controller methods so how many of
you are using spring MVC ok yeah so if
you're using spring ABC are using the
annotation centric stuff where you have
the annotations you see at request
mapping and so on those the return
values of those methods used to be kind
of a it was baked in what would happen
based on the return value and only the
spring framework itself could extend
that now there's an SPI so if you want
to handle the return type of a
controller method and different way that
the framework then then the framework Rd
provides this is your hook same thing
for the parameters right so it's just
about extensibility you probably won't
need it but it's nice to know it's there
and then we've also added support for
the flash map stuff flash map is kind of
a common case how many you know you
submit something to a forum you want to
do something with the results and you
need to keep the value a crop across the
redirect right it's a very common where
you you do a submit you get a value and
then you redirect to some other resource
so that way if they hit the back button
it won't resubmit the form right but you
want that data to persist beyond the
redirect well by default that doesn't
happen right by default spring MVC and
everything else basically forgets about
that data once you've done a redirect
the context is lost so a common pattern
is to stick that in the session and then
redirect and then pluck it out of the
session once you're on that on that
redirected page that's called a flash
scope right you want something to live
just once one you want it to live for
one redirect and no longer and that has
become we've added support for that as
it's just a regular scope now so you can
say that this value will live during
post and then it'll also survive the
redirect we've added support we saw this
earlier ways to add support for
persistence that XML free JPA right so
you can use JPA too and you can use
hibernate for and threes you know as
appropriate and create nice clean Java
centric versions of these API is if you
want to work with them we've also made
it easy to setup JPA itself without the
persistence on XML and you can take full
advantage of all these different new
features and JPA to hibernate for
hibernate 4.1 and i think is like the
current one maybe it's for two now but
basically spring 3 one shipped all of
like three days we were tracking
hibernate for during its gestation and
as soon as it was GA we were ready to go
GA because we had tracked it so this is
the first easy way to use hibernate you
know we've also updated the court api
how many of you guys are using job
scheduling systems like quartz or BMC or
auto SACEUR cron or something those are
great but Spring has for the last three
and a half years had a very nice
integration in the core framework itself
where you just say at scheduled and then
you provide a cron expression or an
interval or a fixed rate and it'll
automatically run that code on a you
know periodically for you but if you
want to use quartz 2.0 then there's now
support for that in spring core as well
that mirrors it looks very similar to
the support we've always had for one for
right I mentioned Java SE 7 again it's
not required but if it's there we try
and make the best use of it we try and
take advantage of it so for example the
fork/join framework which can be very
useful for some very different kinds of
computations computations that are
basically if they if they can be done in
Lisp using MapReduce they could probably
be done in the fork/join framework
inside of java SE 7 it's very nice very
natural and there's now a task executor
integration on top of that the the
spring thread pool SP is mapped to that
nicely we take advantage of JDBC for one
if it's available in our in our code 3.2
is on its way you can already see
release candidates and stuff like that
sort of trickling out and people talking
about the new features in general three
one is a nice arrangement of
technologies a lot of the ideas that
were start
in three Oh kind of find their
completion in three one if you're
looking at if you're on to 5x and you're
looking to upgrade skip three oh just go
straight to three one it is a drop-in
replacement as always you know and three
two will be even cooler
thanks guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>