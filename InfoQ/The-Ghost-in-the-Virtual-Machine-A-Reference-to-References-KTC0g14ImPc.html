<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Ghost in the Virtual Machine: A Reference to References | Coder Coacher - Coaching Coders</title><meta content="The Ghost in the Virtual Machine: A Reference to References - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Ghost in the Virtual Machine: A Reference to References</b></h2><h5 class="post__date">2011-11-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KTC0g14ImPc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay like I said there's a few beers
left over here still if anybody wants to
take this opportunity to grab one beer
makes my talk sound better so my name is
Bob Lee I'm the CTO of a company called
square if you don't know what square is
we enable you to take credit card
payments on your iPhone or Android phone
and we're actually right next door this
is our old office as a matter of fact
and we use so far as like technologies
that we use we use Ruby Objective C and
obviously Java both in our Android
client and for our back-end services
which is where this comes in I'm going
to talk to you about Java references
kind of the genesis of this talk it came
from a couple places well first there's
not a lot of good documentation out
there on references and a lot of the
documentation that I found out there
when I was first looking into this
wasn't very good either wasn't accurate
or you know just wasn't detailed enough
and for me I had to learn about
references for two reasons one I worked
on the guava project I used to be called
Google collections how many people have
used that before so there's a guava is
kind of like the Google Commons
libraries and we had a bunch of classes
in there that make it easier to use
references including mapmaker that's
class that i wrote and then on the other
end i was also the core library lead for
a project called
android and that meant i was in charge
of like the java compatibility libraries
in android and you know and i had to
consult on things like the
implementation of references how the
garbage collector actually handled
references in the dalvik VM which runs
on Android
and make sure that you know it was
compatible with other Java platforms so
the goals of this talk are one to take
the mystery out of garbage collection
when I was first starting out in
programming it was something that I
ignored for a while and then just kind
of finally digging in and understanding
how garbage collected collection work
really helped me write better code it's
not really that hard to understand when
you just take a peek and look at what's
actually going on under the covers it's
not magic to to put an int to finalize
I'm sure we've all heard like that
advice that you shouldn't use finalized
errs but we're like oh but it's so easy
and you know it's like we don't really
understand the reasons not to use them
and I'm really gonna drill those in and
give you a bunch of reasons not to use
them in three to learn how to since
we're not going to use finalized errs we
need to learn how do you do manual
cleanup the right way and the right way
really depends on the context so first
of all let's talk about how garbage
collection works at a super high level
basically in Java you have a heap of
objects and so these are all these
circles represent objects they're all
referenced in the arrows reference
represent references between the objects
and you have this notion of Route
objects so and these are the objects
that the garbage collector starts from
and it could have like multiple these
could be like variables like local
variables or static variables or
whatever and basically the way the
garbage collector works is it crawls
this graph and determines which objects
are reachable from one of these routes
and basically so let me see here if we
took away a reference base from this
route like the reference between D and
the route then D is no longer reachable
and then by virtue of that E is no
longer reachable either since a D was
the only object that referenced it so
those objects are no longer reachable
and the garbage collector collector is
able to reclaim those so what does it
mean for something to be reachable while
the JVM defines reachable very
abstractly
it's basically an object is reachable if
any live thread can access it and then
the details of that tend to be left up
to the implementations and in the Java
world
just some examples of heap routes or the
places where the garbage collector
starts you know I mentioned the system
classes you know and if they'll have
static fields that represent other
objects and then those objects will
represent other objects and then thread
stacks so like your local variables all
the way up the thread stack in-flight
exceptions that's when people typically
don't think of if you throw an exception
the garbage collector has to make sure
that it doesn't free up that memory so
long as that exception is in flight J&amp;amp;I
global reference is the finalizar queue
that's one people don't typically think
about I'll talk more about that in more
detail later on in the talk the string
intern pool so you know it's like you
know Java intern strings that means it
kind of like memorizes them or make sure
or like replaces all instances of
strings with the equivalent values and
then other stuff depending on the VM so
garbage collection isn't a magic bullet
like you can't just let the garbage
collector manage all your state
sometimes you have to clean things up
yourself and like examples of that are
listeners if you're doing like UI
development file descriptors are a
common one native memory if you're
writing like library that manages native
memory you have to manually free that
memory the garbage collector doesn't
know about it and like external state
and what I mean by that is like say for
example I have a static map from an
object to some value well when that
object goes away I want to make sure
that that mapping also goes away and the
garbage collector can't necessarily know
to do that so we have a few ways to
clean up state first we have the try
finally block which I'm sure you all
which you're all aware of we have
finalized errs and which is basically
this finalized method and we have the
references API which is going to be kind
of the focus of this talk first let's
take a look at try finally I have a some
example code here that basically copies
a file into a given output stream and
the reason we have to use try finally is
because as you'll see here we open the
file input stream and then we copy the
data basically just read from the file
and then copy that data structure to the
output buffer but we have to make sure
that no matter what happens we remember
to close that file if we don't do this
and for example we encountered an i/o
error while reading this file
then we could risk that that file not
being closed and then we'd leak a file
descriptor and if you don't know files
file descriptors are a limited resource
and if you leak too many of them your
app your applications going to crash so
to alleviate that we use this finally
block here and this basically ensures
that no matter what whether an exception
is thrown or this returns gracefully we
close that file so kind of the benefit
here to of like closing this here as
opposed to like I'm back just letting
the garbage collector handle it is you
know for copying a lot of files we could
get in a state where the garbage
collector can't keep up and then we end
up running out of file descriptors you
may have run into a problem like that
before so like the pros of using finally
to clean up stuff explicitly as one it's
more straightforward you don't have to
worry about like background threading
and those types of concerns you can
handle exceptions in the main thread
whereas if you're doing cleanup in a
background thread and you know it blows
up well then you have to somehow
communicate that exception back to the
foreground thread and it ensures that
the cleanup keeps pace I kind of
mentioned this idea if we were just
letting the garbage collector close the
files then it might not keep up and we'd
run out of file descriptors so the cons
of using a finally block are one it's
more work for the programmer they have
to explicitly write this code to close
things to it's more air prone if they
forget to close things or even if they
forget to close it in a finally block
they could leak that resource for
example like I said if the if you
reading the file throws an i/o error and
they didn't close a file in a finally
block that file might not get closed and
cleanup happens in the main thread
that's also that's a pro in the sense
that it's simpler but it's also a con in
the sense that that the performance
overhead of cleaning up that resource is
imposed on the clients of that API so
Java 7 introduced a new language feature
called try with resources that makes the
try finally a block a little easier to
deal with so here's the code that we
just looked at you can have a try
finally block that closes the file input
stream in the finally block well with
try with resources this code gets a lot
more concise basically the difference is
now you can say try and you can you open
with a princess parentheses here and now
you can open up the resource and you can
open up this resource and you can
actually open up multiple resources here
but notice we don't need an explicit
finally block anymore the code the
compiler will close this resource for us
and even better it'll do some like
really nice exception handling that we
that doesn't really make sense to do by
hand he asked if it will explicitly call
closed method yes so this code on the
bottom is semantically equivalent to
this code on top almost this code
actually down here is actually a little
better because the exception handling
that's generated by the compiler is a
little better then what's up here up
here if this throws an exception we're
gonna call in doc close and if close
there was an exception that the the
exception that was thrown while reading
is going to be just dropped on the floor
and this exception by close is going to
be thrown whereas really you know in my
opinion you actually want the original
exception not this kind of like
ancillary corollary exception that was
thrown by closing so whenever you have
this expression here this is a new thing
you can pass you pass this statement as
part of the try declaration and anything
that's in these parentheses will get
closed so this declaration here so we
say try file input stream and we
construct a new file input stream this
implements an interface called closeable
so and you can have any number of
resources yeah you have any number of
resources that implement that closeable
interface and they will get closed
automatically at the close of this try
block so we've talked about try finally
and the benefits of that now let's talk
about finalized errs a little bit to put
it simply a finalizer is just a callback
method that's invoked before garbage
collector and this this has been around
before garbage collection this has been
around since Java 1.0 let me just show
you an example of what a finalizer looks
like here finalized is actually a method
on object and all you do is you override
it and so here we have this class foo
that
and it overrides the finalize method now
this is something I wanted to point out
here too
whenever you're overriding or in
implementing a finalizar you need to
take care to also call your superclass's
finalizer if you extend anything besides
object so in in this case we actually
use finally again we use finally with a
finalizer in this case so we do whatever
it takes to clean up foo and even if
that throws it even if the cleanup for
food throws an exception the cleanup for
bar will still happen so and that's
important depending on the context so
finalize errs are simple as a simple
idea oh hey just when my object right
before my advocates reclaim this
callback gets called but they have a lot
of problems and a lot of them like stem
from the fact that well one finalize
errs aren't very well specified and two
you're calling the cleanup code is on
the object that you're trying to clean
up so that mean that really opens the
door to a lot of nasty surprises so the
first the first one of the first ones is
the finalizar is not guaranteed to run
especially not in a timely manner so a
lot of VMs will just run all finalized
errs synchronously and if one person's
finalizar takes five minutes no one
else's finalize those we're going to run
until that one concludes so and that's
actually a common problem we ran into
that on Android closing down SSL
connections took some amount of time
because it has to communicate over the
network and that sort of stuff and that
prevented other things from getting
finalized and ended up like locking up
IO for the whole VM it was kind of a
disaster they have an undefined
threading model so that means yeah it
could be single threaded like I just
described or if the garbage collector
could call finalize on your objects
concurrently and if there's any entry
dependencies between those objects you
have to make sure that you write thread
safe code and anticipate that you must
you got to remember to call super got
finalized like I showed in the last
slide this is kind of a funny one
exceptions are ignored so if you throw
an exception from finalized then the
spec specifies that the VM is just
supposed to drop it on the floor and
ignore it this is a big one you can
resurrect references in a finalizar
like I said you can since the finalizar
code is on the object that you're trying
to clean up your what's to stop
your finalizar from taking
reference that object and storing it in
a static field somewhere and bringing it
back to life that's called resurrection
and that's kind of a funny situation you
have this kind of like zombie object and
from my experience the finalizer won't
be called again so you can still use the
object after it was finalized and it
won't be finalized again it's not
something that you want to mess with
even more worrisome is that obviously
you probably wouldn't do anything to
shoot yourself in the foot but other
people could get access to your object
this way and these it's like circumvent
your security and do that sort of stuff
I'll show you some examples of that here
in a minute
final answers keep objects alive longer
than necessary so you know just because
we're like waiting we need the finalizer
areas on this object well as objects
queued up and all the state associated
what that object can't be reclaimed
until that finalized it runs even if the
finalizar doesn't really need all of
that state so that's you're gonna you're
gonna retain garbage a lot longer than
necessary and possibly even run out of
memory and Josh Bloch did a test for
effective Java some years back and found
that using a class with a finalizar is
430 times slower to allocate and reclaim
than a class without a finalizer and why
is that well just allocating an object
and letting it garbage collected is a
really cheap operation whereas in
queueing an object that has a finalizer
and eventually running it later is not
very fast and so worst of all in my
opinion finalizer x' messed up the
references api because they were there
and then the reference hits an api came
along later they had to kind of
accommodate
finalizer x' and it made the references
api more complicated than it needed to
be and I'll explain how that is in a
second so let's talk about let's go
through an example of a finalizer this
is very similar to a lot of code that I
had to write as a core library lead for
Android and where I had to wrap a lot of
native api's and that sort of thing
managing native memory is something you
have to deal with quite a bit so I just
kind of boiled this down to the simplest
possible class that I could come up with
the class is called native memory and
all it does is it calls a native method
that allocates some native memory and it
stores away the address for that native
memory that's what's going on right here
it just has one simple method it enables
you it
all through to another native method to
write to that native memory we don't
really have to worry about the native
details all we care about is that we've
allocated some native memory and we have
the ability to write to it and this is
kind of a naive implementation of a
finalizar
basically when the finalizar gets called
we we just call into native code to free
that native memory so the code looks
simple enough but let's let's take
another look as I mentioned before
someone it doesn't necessarily matter if
your finalizar is safe you also have to
anticipate other people's code who may
be referencing your code and they may
have finalized errs themselves so I
called this code segment cause it
generates sig faults and so and I titled
this I call this slide let's play war
because with this class my segfault
Factory it will generate a fake fault
50% of the time just like war you know
your you have a 50% chance of winning in
this case you have a 50% chance of
crashing your VM so let's take a look at
what this code is doing basically all
sake fault factory does is it references
a native memory object and it has a
finalizar of its own so and in its
finalizar it writes to that native
memory object so what's the problem with
this that seems simple enough right you
know wouldn't you expect the garbage
collector to finalize this guy and then
finalize the native memory object you
get no such guarantee I mean like the
garbage collector isn't going to like
sort your objects topologically based on
which objects reference each other it's
just going to find all the objects that
are finalized well at that time I start
calling final answers on them so the
odds are this finalizer can be called
before the native memory one or the
native memory finalizer can be called
before this one so in this case let's
assume that the native memory finalizer
is called first and that native memory
is freed what's going to happen down
here where this is going to call through
to that native code and write to memory
a that was just freed and probably seg
fault your application so how do we fix
that
always use protection this is this is
that same native memory class from two
slides ago the blue code is is kind of
our updated code in this case we can
keep track of whether this object has
been finalized or not and we can change
our behavior based on that also we have
to take care to
synchronize the access to this because
the finalizar could be run for one
thread or you know it's like or from
multiple threads and you know it's
chances are that this right method could
be calling being called from a different
method than the finalizar so we
synchronize it we have to synchronize
both the right method and the finalizar
the finalizar sets finalized to true and
the right method checks final Heiser our
checks whether it's been finalized or
not and this kind of leads us in this
weird situation too you'll notice if the
objects been finalized in somebody calls
right on it like our sig fault factory
did what do you do who knows you know
it's like maybe you can blow up log a
message do nothing doing nothing
probably not the best thing to do and
kind of the unfortunate thing here is
that before outside of this there's
really no reason for right to be
synchronized I mean there's it's
perfectly fine for more than one thread
to write to this memory presumably but
now we have to add the synchronization
on it on to it just for the possibility
that the finalizar
may run at something could call it
concurrently and that's pretty
unfortunate so basically with this all
boils down to is finalized errs are good
for one thing in my opinion and that's
kind of logging warnings if maybe if you
forgot to like manually clean up an
object you've probably seen this with
database connection pools before if you
forget to clean up your connection
object you'll get a warning and I'll say
hey you didn't explicitly close this
connection you should fix your code but
there's also kind of a problem with that
because like what happens when you want
to disable the warnings well now you
have this finalizer that does nothing
but you still have to incur all the
performance overhead that goes with
finalized errs like I said Josh mounted
three four hundred thirty times slower
the alternative what do we do instead of
finalized errs this is where the
references API came in and tried to fix
these problems the references api was
introduced in java one two as a long
time ago late 90s early 2000s late 90s
and it introduced three reference types
which I'll go through the first one is a
soft reference and this we use for
caching the second one is a weak
reference this is for quick cleanup and
the third one is a phantom reference and
this is for safe cleanup
and so that's kind of the key here if we
didn't have finalized errs we wouldn't
need both weak and phantom references
and I'll talk a little bit about that
the key difference between weak and
phantom references is that weak
references run before the finalizar runs
so your weak references will be cleared
before the final before the finalizar
runs to your object isn't totally gone
people can still get access to it from
their own finalized errs whereas with
phantom references
they aren't cleared until after all the
finalized errs are run so they kind of
have some of the downsides of finalized
errs and that you have to wait until
your objects to totally finalize there's
also this other concept in the
references api called a reference queue
and a reference queue is how you get
notified about an object about a
reference to being cleaned up so I just
this is just kind of the API here it's
very simple it's in the java.lang rough
package you have a base reference type
parameterize on type T then you have a
soft reference that extends that weak
reference and phantom reference you'll
notice that soft and weak reference you
can optionally pass this reference cue
object and that's you only pass it in if
you actually care about getting notified
when that reference gets cleaned up if
you just don't want to keep a strong
reference to it you don't need to pass
on a reference cue
you'll notice that phantom reference
always requires you to pass on the
reference cue and this is because a
phantom reference doesn't let you
retrieve the original object once you've
created the reference via the reference
anyway so it doesn't make sense to have
anything but a queue here and this is
the reference queue as just how you
would expect a queue to look you can
pull it in which or remove an element
the difference here is just that remove
blocks pull doesn't so let's start with
soft references soft references are
supposed to be cleared when the VM runs
low on memory the the spec doesn't
actually make a lot of guarantees here
but they're hopefully cleared and least
recently used or at least frequently
used batch and there's a lot of you know
this is a subject of endless debate like
what's the best and it actually really
depends on your application in your
context for open JDK or Oracle's now
Oracle's VM the way soft references are
implemented is they have this VM
parameter called soft breath ler policy
MS / MB and this is soft wrapper
least recently used policy milliseconds
per megabyte and the idea here is you
can set how many milliseconds to keep a
soft reference around relative to the
number of megabytes of free memory
that's kind of and the default is 1000
so we keep around a software efference
for one second for every free megabyte
of heap that you have so use soft
references judiciously frankly you
should only use them for small things
you should probably not use them at all
anymore nowadays now that there's better
solutions like the caching
implementation in guava which I'll talk
a little bit about they're good for like
maybe quick and dirty caching where you
don't want to like think about the size
of your cash up front or something like
that and you just have small pretty
cheap objects then you just get a small
performance boost from catching those
objects the couple of the problems with
soft references is one they have no
notion of weight all soft references in
your VM are treated the same way
regardless of how long they how much
memory they take how long they took to
create and you know it's like when you
think about like how long something
takes to create there's a difference
there's two things you have to consider
one is the amount of CPU that went into
it did it take 100% CPU while it was
doing it or did it just take a lot of
time and not use any CPU or did it use a
100% CPU for a long time those are all
very different things and you don't want
like some lightweight object that took a
millisecond to create to be kept while
the while the VM frees an object that
took like 10 seconds to create right
also the way you know you don't have any
guarantees for the implementation I know
for at least last I checked dalvik
implementation of soft reference
clearing wasn't that sophisticated the
open JDK is also is really subject to
problems and we actually ran in to these
problems quite a bit at Google when
you'll remember that I just described
that it keep that open JDK keeps soft
references around based on how much free
memory you have left so what's going to
happen as you start to converge and like
run out of free memory and like that
you're free space gets lower and lower
your the VM keeps soft references around
for shorter and shorter periods of time
until you almost run out of memory and
freeze all of your soft references well
what happens when you don't have any
when all your caches are empty you don't
have soft references anymore well if
your app continues running it's gonna
have to recreate all those objects and
it's gonna take a lot more time and
require a lot of memory to recreate
those objects in your app just crashes
so it's kind of a disaster there
certainly could theoretically be better
ways to implement soft references but
this is the reality of situation today
so I shouldn't use them if you're gonna
use it you can't use it for like small
stuff I just want to kind of go through
a quick example here of how to use them
in this example I call it cached file
and the idea here is we're going to
cache the contents of a file in memory
and just keep it around it's okay if we
go have to go read the file again it's
not the end of the world but you know if
we read if we read the same file a
couple times it's nice to have it so
here you can see we have a soft
reference this is a little trick I like
to use here you'll notice that I
initialize the soft reference to point
to a null value and rather than just
making this field null and the reason
that I did that is it avoids a null
check down here a little bit later on so
that we have one method it's called get
data and this is going to get the data
read the data for that file and copy it
all into a byte array so the first thing
we do is we call get on the soft
reference and get the data out if the
software efforts been has been reclaimed
or not initialized yet then we're going
to get null but if it's not no we're
gonna go ahead return that data if it
was null then we're going to initialize
it so we're gonna read the data from the
file and then we're going to create a
soft reference to that data and you
notice that I save it away into that
into this reference here and we're gonna
return the data you'll notice that this
is thread safe the way I wrote this code
and it has I kept a volatile reference
to this field which you have to do if
this codes gonna be thread safe
I didn't synchronize it on it and so
kind of the interesting thing there is
two threads could call get data at the
same time and both read the file but
that's not the end of the world so
there's a reason I picked this a
particular example it's because I see
people do this some times but you should
not do this this whole idea of just
you're just caching the contents of a
file in memory it's something that you
should
do because the reality is operating
systems already do a pretty good job of
that for you so if you're also caching
the contents of a file in Java memory
that means you probably have two copies
of that file in memory and whereas you
know reading the same file twice is
actually a pretty quick operation
assuming you have enough memory it's
already cached weak references so weak
references are a little looser than soft
references they're cleared so long as
immediately after no strong or soft
references remain so and they're cleared
as soon as possible you know common
mistake is that people you try to use
weak references for caching but you know
modern viens especially will clear these
right away so they're really not useful
for caching at all you should if you
want to do lightweight caching you
should use soft references let's talk
about go through a quick example of weak
references at the beginning of the talk
I mentioned this idea of using listeners
if you write UI code you know what I'd
have to do this so we have a this is a
button class this represents kind of
like a button in our user interface and
it has an interface called listener that
can get called back whenever somebody
clicks our button so you can add a
listener as you see here and basically
all we do is we add this listener to a
list but we don't add the listener
directly to the list if we kept a direct
reference to the listener this button
would keep that listener from being
reclaimed and that would mean that you'd
have to explicitly remove this listener
from the button if you didn't want to
have a memory leak whereas now that
we're keeping a weak reference to
listener once we throw that listener
away elsewhere this button will no
longer notify it and it's kind of a nice
feature so we keep a list weak
references to the listeners whenever
somebody clicks this button we iterate
through this list and you know I just
notice I explicitly used an iterator
here rather than using the for each loop
and that'll become evident and the
reason why I'll become evident here in a
second but we loop through the elements
and we call we get the next week
reference and then we call get on that
to get the listener out if the listener
was null that means our reference was
garbage-collected
and we call remove on the iterator so it
gets removed from our list and we won't
we can just
that week reference now you got to be
careful to clean up the week reference
otherwise people keep adding listeners
and you know those listeners could be
garbage collected but we have to make
sure our week reference gets thrown away
also so if the listener is not known
then we just call unclick on it it's as
simple as that
finally we have phantom references and
phantom references are like the most
precarious type therein cute after no
other references remain and they run as
opposed to weak references phantom
references run after the final answer so
when your phantom reference is in queue
and you're notified that that phantom
reference was cleared you know for a
fact that nobody else has a reference to
that object and that's really important
from a security standpoint so for
example you know we were we talked about
native memory for your code to be secure
you have to make sure that people can't
access that native memory after it's
been freed it's like an example that is
a memory mapped file in Java memory
mapped files use phantom references
under the hood that's why he can't
explicitly close them and that's how
they know to like free the native memory
if they didn't do that and they didn't
check they didn't have like the overhead
of checks to see whether that memory map
file was closed or not then you could
access that memory after was freed and
potentially even access memory that's
being used by something else and get
since it's access to sensitive data that
you shouldn't have access to so a couple
little factoids about phantom references
is they have to be cleared manually and
this is really for no good reason that
means any objects that those phantom
references that that phantom of a
reference object references will be kept
around even though you can't really get
access to them and that has to that's
actually due to a patent yeah a patents
and get I mentioned this before will
always return null with a phantom
reference so if you want to really only
make sense sees a phantom reference with
a reference cue so let's revisit that
native memory class that we wrote before
and look at how to do it the right way
using a phantom reference like I said
we're going to use a phantom reference
because we want to make damn sure that
nobody has access to our native memory
after we've read it so we're gonna make
a couple changes we're going to add
whereas before we had a default public
constructor so anybody could construct
our native memory directly now we're
going to make it private this is
packaged private that's the default in
Java if you didn't know that I'm gonna
make a package private so we can access
it from our factory class which I'll
show in the next slide we're also going
to get rid of this crappy finalizar and
we're going to clean up the method we're
going to clean up the memory in a
different way so the first thing we need
is a phantom reference and the way
references work is as I said before
phantom reference extends reference and
then you can extend that reference to
store any state that you need to clean
up that object
well what state do we need to clean up
this native memory we need the address
of the native memory so that we can free
it so here we have our class I call it
native memory reference and it's a fan
it extends phantom reference and it just
keeps that memory address that's
basically all we need here the whole
purpose of this class is just to hold on
to that address for us now let's look at
how the native memory gets allocated and
free and so let's start here we'll start
with the allocation so we have this we
have this factory class now called
native memory manager and this is what
we're going to use to create our native
memory objects we call allocate on this
it's just static factory method and it
returns a native memory object this
class is able to directly construct the
native memory object because this is a
class that manages it uses that package
private constructor this is kind of an
interesting thing that a lot of people
get tripped up with on references we're
going to add we're going to construct
this native memory reference and we are
going to add it to a set so this this
static set and notice that this set is
synchronized so that it's thread safe
why do we have to add this to a set well
you have to keep a strong reference to
the reference object itself if you don't
then the reference object just gets
garbage collected and it won't get in
queued in your reference queue or
anything like that and that's actually
the way you want it to behave but you do
have to remember to keep a reference
around your own store
reference to it then every time somebody
allocates memory so we create that
reference keep track of it and then at
that point this is a common pattern we
clean up we take this opportunity to
clean up any references that were
cleared before this so if we look at our
cleanup method what it does is it poles
are referenced queue which we specified
up here and any references that we're in
queued we'll take those and we'll call
free on the address for that reference
and then we'll remove that reference
from our set does that make sense to
everybody what we did here so we
allocate the reference we keep track of
it then we clean up any references that
were left and we just return that object
and basically what's going to happen
here is the garbage collector once
nobody else reference references this
native memory object and all the
finalize was run and all that stuff the
garbage collector is going to tell our
reference queue about it so they this
reference to you here the garbage
collector is going to tell this
reference queue and we're gonna we're
gonna pull that reference off of the
queue down here and no to clean it up
well so that's how to do it with the
traditional like built-in platform
libraries the guava libraries actually
have some helper classes that make this
a little easier and a little more
efficient so let's look at what this
class looks like with the guava
libraries instead of having the
reference queue now we have a guava
specific class called finalize the bowl
reference cube and the difference here
is rather than polling a queue and using
that model with this we can use a
callback method and this will just be
called the background thread there's a
thread that backs this finalized Abul
reference queue you get one thread for
queue so you can allocate as many as you
want and you're not all on one thread
like you would be with finalized errs so
the allocation code changes we store we
can just store off the address and we
don't even need that separate reference
class anymore I'm just gonna use an
anonymous inner class here note that I
still add the reference to our set we
still have to keep a strong reference to
it but now this code got quite a bit
simpler I can just put the cleanup code
in this callback method here now this
looks like a
finalizer but why doesn't have the
problems of a finalizar well it's for a
number of reasons one I specified that
we we hit we have control of this
writing model now like you don't just
have one thread for the whole VM anymore
to this callback method here isn't on
the object we're trying to clean up so
it doesn't have a reference to that and
there's you don't have that kind of
impurity there like this only has a
reference to the address that's all the
state that it needs so we know the
object is we its obviously correct
we know that the that this code doesn't
have access to the original object
so whenever the Phantom reference gets
cleared this background thread what's
going to happen is it's going to pull
aren't that phantom reference off the
queue and invoke this finalize reference
method and here we just free the address
and we take care to remove that
reference from our set so you can see
this is quite a bit shorter this
includes both the reference class and
the factory whereas it's even shorter
than just the factory before nice little
class another thing that this does to
you that I forgot to mention is that it
gets the generics correct if you look at
this the original code that uses just
the JDK classes we have a cast here and
the reason we have this cast here is
because when they add a generics to the
v2 JBM they didn't parameterize
reference q correctly they just made it
of type t when you really wanted it of
like some class that extends reference
of type T so that we get we could get
our reference type off there in a type
safe way here's a little tip too like I
mentioned with phantom references if you
call a get method it always returns null
you can't get access to the original
object
the original API designer was a little
overzealous he's like I can't imagine
any reason somebody would want to get
access to an object that a phantom
reference references so I'm just going
to totally disallow it altogether but it
just so happens I did run into a case
where I needed to get a reference to the
object that I wanted to use phantom
references it was in a thread local
implementation for dalvik and basically
the situation there was I had a hash
table you know manually implemented hash
table and it contained these reference
objects when I'd rehash the table when
I'd have to grow it I would
to be able to get access to the original
objects so I came up with this little
pet this little trick I call it a weak
Phantom reference it's very much like a
phantom reference except it keeps a weak
reference internally so this will keep
the object around long enough first to
do things like rehash a hash table and
that sort of stuff but so we can still
get access to the original object so
long as it's weakly reachable nice
little tip don't forget I just wanted to
kind of drum this in the garbage
collector runs concurrently with our
code and when I you know I mentioned
weak references getting cleared this is
a great example here of what can happen
and how fast it happens and I've
actually seen this happen so I call this
class race the collector and it has it's
just a little static it's just a little
helper method it's called mmm I think my
batter is dying here but it has a
dereference method here you pass it a
week reference and basically what this
method is going to do is if if the
reference is no one's gonna throw out a
null pointer exception if it's not it's
going to return it but the problem with
this code here is we called it and we
checked if it was null but then we
called it again down here the garbage
collector could have run concurrently
with our code notice that we don't
actually use T anymore after this
reference here and garbage collected T
somewhere in here the garbage collector
could run right here and by the time
this code runs this reference could have
been cleared out and this method will
actually return null which you this
method is not supposed to do so the fix
for this would be to actually return T
here make sure your turn T here and so
it's stead of calling it on the
reference again there's some higher
level classes in the JDK one of them you
might be familiar with is Java util weak
hashmap weak hashmap heaps weak
references to the keys and strong
references to the values and this is
useful for kind of like emulating adding
an additional field to an object so what
do I mean by that well you can't extend
objects in Java like you can in a
language like Ruby but you could have
like a static weak hash map that map's
an object to a value that's associated
so say I wanted to add I don't know like
some identifiers for the object I could
map the object to some identifiers that
I use to that object when that object
goes away then that it's gonna be
automatically removed from that we cache
map and the value will be removed too
that's kind of the idea of those it's
useful in some situations it's not
concurrent so you have to synchronize it
and also you know this is kind of like
in my original native memory manager
class it does the cleanup in line so it
only does the cleanup it only cleans up
these values when you add more when you
change that week hash map that's kind of
a downside because it's going to keep
around that value until you access the
week cache map again when that value
should be able to be cleared a little
sooner than that another downside that I
found with we cache map this is a really
subtle point is that with the keys it
uses it calls equals on the keys when I
submit that it should use equals equals
because weak references are
fundamentally identity based when I'm
talking about a weak reference I'm
talking about that particular instance
that that weak reference is pointing to
not some other instance that could be
equivalent so it's some kind of like
weird subtle things happen whenever you
use equality with a weak hash map for
example like you might have a reference
to a key and expect that to still be in
the hash map but it's not equivalency
based so that could be removed and then
that mapping won't be there anymore the
next time you go to it so enter guava
map maker this is class I created
sometime ago it's a near drop-in
replacement for weak hash map but it's
kind of a superset it's well one it's
concurrent it's very similar to
concurrent hash map under the covers so
you have like reads that don't lock and
that sort of stuff it's more feature
full rather than just supporting weak
keys
it supports strong soft or weak keys and
or value references and you specify
those as it uses the Builder pattern
it's very easy and also as I just talked
about it uses equals equals identity
comparisons to compare weak and soft
keys that maker used to have some
additional functionality for like it
actually technically still does but
kind of going it's gonna go away
eventually some some like caching
functionality so that you could create
values on demand but we've replaced that
with a new class in guava called cache
builder and this is cat builder is kind
of a superset of math Map Maker that
includes all this caching related
functionality and this is probably what
you should use from now on instead of
soft references so it supports on-demand
computation of values I'll show you an
example here in a second but essentially
you give it a function that can take a
key and return a value and if you if you
if you try to get a value out of this
map and the cache the cache doesn't find
a mapping to that key it'll use your
function to create that mapping and kind
of the cool thing about it too is that
it will only ever create one value per
key and this is some kind of tricky
concurrency code to get right but
basically if you have two threads that
come in and try to get the same value
for the same key the first thread will
start the computation and the second
thread will wait on that computation to
finish so you can you're guaranteed that
you're only going to have one mapping
per key I'd also have some other cool
features like expiration you can specify
that your values should expire sometime
after they were added to the map or
sometime after they were last accessed
from the map so that's a really depends
on the situation each bolt and the
really cool feature that was added
I guess product six months ago to a year
maybe a little longer is size limbing
and this was really the missing feature
that people needed before they could
really replace soft references with
cache builder you can specify the
maximum size of your cache and once you
start to exceed that size it will remove
the it'll remove those values it's kind
of funny I noticed Vlad's here on the
audience he wrote the original
expiration code that was a mapmaker
so here's an example of cache builder in
action this this example I call I just
call this it's like a static utility
class I'm gonna call it getter methods
it has one method called on and you give
it a class and it returns you a list of
getter methods in that class so here's
the example usage down here basically is
called getter methods on food class and
over
you a list of the Gitter methods on food
outclass and what's a getter method for
the purposes of this slide it's just a
method that starts with yet so when you
call whenever you call this on method
it's just going to delegate straight to
our cache class that we got from the
cache builder let's look how we built
that up you call cache builder that new
builder and you can specify the keys
like the references to the keys we have
a weak keys soft values and when we call
the build method that's when we specify
the function that we use to actually
create the list of methods this is just
a function from called cache loader from
class to the list of methods and all
this does is the cache will call this
method whenever it needs to create a
mapping for a key so it gets the class
iterates over the methods in that class
and picks any method that has get the
starts would get and adds it to that
list and then returns that list and kind
of the cool thing about this is that
well what would we have to do if we
didn't use it use a cache here we would
have to repeatedly iterate through all
the methods in the class and if you have
a lot of methods in the class and aren't
get our methods you're creating all that
garbage and you're doing a lot of work
whereas with this we just keep that list
of methods and with this little amount
of code that value gets cached some
interesting things there's a reason I
picked this example there's some
subtleties with classes and references
I picked weak keys why did I do that
well this is a static field we want to
keep weak references to the class
objects and the reason for that is how
many people have like used dynamic
reloading of their web application or
that sort of stuff well if we were if
this class was loaded by the system
class path and we kept a strong
reference to a class that was in the web
app last load er well this class would
prevent that class loader from getting
reloaded and after you reloaded your web
app so many times you would run out of
memory keeping a weak reference to that
class object will enable that web app
class loader to be reloaded now here's
an even more subtle point why did I keep
a soft reference to the value and not
just a strong reference well in this
particular case no
that our value is a list of method
objects those method objects are all
methods from that class those method
objects have a reference to the class
that declared them so if we kept a week
where even if we kept a week reference
to the class itself and we kept a strong
reference to the value we would still
prevent that webapp class loader from
getting reloaded right because you have
a strong reference to the value to the
list which has a strong reference to a
method which has a strong reference to
the class
which has a strong reference to its
class loader well why couldn't I just
keep a weak reference to the list of
methods well if I did that I don't have
a reference to this list of methods
anywhere else and like I said before you
cannot use weak references for caching
there's would be a totally ineffective
cache and the list of methods would just
be reclaimed immediately whereas if I
use a soft reference as I did here then
those that list of methods will stick
around it's not the ideal situation you
know like maybe I just want this maybe I
just want to keep this list of methods
around permanently because of you know
I'm gonna have like a finite number of
them but if you want to enable reloading
you have to do this sort of thing so
does anybody have any questions about
that
cool all right so this is just to recap
the levels of reach ability from like
strongest to weakest this isn't exactly
linear but we'll kind of I'll be a
little hand wavy here strong soft for
caching weak which runs before the
finalizer finalizer like this is kind of
like you can still be referenced by the
finalize or even though your objects not
reference other ways and this is what I
say
that's not exactly linear you can go
back from finalizer to being strongly
referenced if you through be it like the
reincarnation I talked about before
phantom references which runs after the
finalizer and then just unreachable and
that's when things can be reclaimed so
this is a little demo I like to do with
this talk it's something I came up with
to kind of illustrate exactly how a
garbage collector works and show you
exactly what happens whenever whenever
we're dealing with these references so
here I kind of randomly generated a heap
of objects and you can see that they
referenced each other the different call
Ones are references the black ones are
heat roots so the red ones are phantom
references the green ones are soft
references and the blue ones are weak
references so I'm going to walk you
through exactly how a mark and sweep
algorithm works in garbage clashes this
is a popular garbage collection
algorithm pretty much all the garbage
collectors in Suns BM uses a variation
of this how many people have heard of a
mark-and-sweep algorithm before cool
it's a very simple algorithm but it's
very cool compared to things like
reference counting it handles things
like circular references really well
but the basic idea of a mark-and-sweep
algorithm is that just periodically you
have this background thread or you know
maybe grab just pauses periodically and
does a garbage collection so let's start
off with a market sweep algorithm you
start off with no objects reference so I
just kind of like made them all light
colored so we could keep track of which
ones are referenced and which ones
aren't the first thing that the garbage
collector does is it starts at a root in
this in this slide we just have one root
we're going to start tracing our heap
from here we're going to trace and mark
the strongly referenced objects so here
you can kind of see I'm like tracing the
reference from objects to objects and
marking the objects as I go and so kind
of interestingly here you can see like
the root has a strong reference to this
object which has a strong reference to
us a reference object as I mentioned
before we have to keep strong references
to our reference objects or else they I
won't get into you so we've traced and
marked all of our strong strongly
referenced objects you can see like this
object points to that one
none of these objects are referenced by
straw by strongly referenced via the
root so none of these are marked yet the
next step is that we optionally clear
the soft references so in this case
you'll see that we have like a soft
reference from here to this object which
isn't otherwise strongly reference so
this soft reference could be cleared or
maybe not in this case we have plenty of
room on this slide so I'm going to keep
it around so we'll trace and mark the
softly reference objects and as you can
see all of these objects come back to
life via that soft reference because we
decided to retain it so and that that
one right there you'll see that those
pointers right there those
one point two objects that were strongly
referenced so you know basically the
garbage collector is going to follow
those paths and see that those objects
already marked and stop stuff searching
the heap
next we're going to clear the weak
references so in this case we have we
have two weak references the one at the
bottom here you can see references an
object that's already reference but
that's one of the top references is an
object that's not referenced so that we
creff uhrin s-- is going to get cleared
the one that i've highlighted in red
there and those objects aren't going to
be reachable via that finally or well
not finally actually as you'll see in a
moment
now we get to up two objects with
finalized errs and this is where
finalized errs really suck you know
garbage collection was simple up until
this point but now the garbage collector
has to go and start with the finalizer
queue and this is just a queue you know
it's like a queue in your own
application and the garbage collector
has to put any of these unmarked objects
that have finalized methods on them in
the queue now we have to repeat all
those steps that we just went through
you know tracing the strongly referenced
object straight handling softly
referenced objects hailing weakly
referenced objects we have to do that
all again from the cue from the
finalizer queue and you'll see that this
finalizer queue brought all these
objects back to life so after that the
last step is we in queue any phantom
references in this case we have one
phantom reference here which points to
an object that's already the 30 mark and
this phantom reference of park points to
an object that's already marked so life
isn't too interesting none of them are
going to get in queued all these
remaining objects that weren't marked
are just dead so garbage collectors can
do a couple things in this situation one
it could manually go through and like
reclaim all this memory and market is
free all the memory associated with
these objects or two what's comp common
is if you've heard of a copying
collector how many people have heard of
a copy and collector before so a copying
collector basically takes all the live
objects and copies their memory into a
new place in memory and then just freeze
all the old memory and kind of the cool
thing about that it's a little more
overhead and now you got a copy all that
memory but you don't have heat
fragmentation so
and then all those objects are gone we
clear them all out they're gone and we
start with our heap again and we repeat
so you know like I said you start at the
root do the softly reference objects
weakly referenced handle the finalizar
objects and repeat all those steps again
and then you possibly handle the phantom
references after the finalizar is run
and then the remaining objects are dead
and you repeat so this is kind of like a
little tidbit in case you're wondering
whether I meticulously
tweaked all those little object graphs
by hand the answer's no I actually wrote
a Java tool that generated this
presentation so I write I write this
presentation in Java code this is
actually the code for this presentation
it's out on Google code it's called
crazy Bob's talks and in the case of
you'll see the code for this heap
presentation here I actually just
created objects in memory that
represented these objects and then wrote
a mark-and-sweep algorithm so it's a lot
more fun than like going from three like
thirty thirty some-odd slides and coming
up with all those animations myself so
thank you everyone for coming if you
enjoyed this talk i'm crazy bob on
twitter if you want to learn more about
like my open-source projects and that
sort of stuff also as I said with with I
work at square we're doing tons of very
cool Java code and we do lots of cool
open-source projects so if you're
interested in learning more you can
email me at Java jobs at square up comm
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>