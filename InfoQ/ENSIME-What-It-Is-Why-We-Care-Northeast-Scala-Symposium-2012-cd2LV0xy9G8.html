<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ENSIME: What It Is &amp; Why We Care - Northeast Scala Symposium 2012 | Coder Coacher - Coaching Coders</title><meta content="ENSIME: What It Is &amp; Why We Care - Northeast Scala Symposium 2012 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ENSIME: What It Is &amp; Why We Care - Northeast Scala Symposium 2012</b></h2><h5 class="post__date">2012-03-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cd2LV0xy9G8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">how many people get the joke in this
slide just anybody get this
it's like Amen basically okay and so I
mean the the joke is basically playing
on the fact that enzyme is not a new
concept okay
enzyme is is based on a concept that was
developed for for slime basically so
slime is a a common lisp editing mode
common lisp ide mode basically for Emacs
and it's most recently gained a lot of
traction as a mode for closure
so what slime basically does and what
enzyme does is they provide IDE like
functionality in a sub process
controlled by your parent editor and you
just the editor communicates with them
back and forth via protocol and they you
know they never block each other and and
you basically have your regular text
editor enriched with IDE like
functionality so it's like 80 80 to 85
percent of an IDE 80 and 85 percent of
your Eclipse IDE write your monolithic
craziness but tucked into a really nice
text editor package right your your
Emacs editor or your vim editor or
whatever you happen to be working with
and there's a lot of really lovely
things that come out of this I mean
number one you can continue to use Emacs
and you don't have to use fake
keybinding packages but more importantly
it is a totally optional workflow okay
this is something that a lot of people
miss with things like enzyme and and
slime and things like that and this is
the the thing that is compelling to me
when I'm using my editor which is J edit
okay I can open up a scala file that's
not in a project that enzyme knows about
that's maybe on a remote server I'm
loading it over some FTP connection or
something like that or maybe I just
downloaded a gist maybe it's not even
well formatted Scala I open it up in my
editor and it works in my editor okay I
know that doesn't sound very impressive
but try doing that in Eclipse just once
because it's just a nightmare to try to
make that work try doing it in IntelliJ
it's terrible so it works because Janet
is a text editor and enzyme doesn't
impose itself on Mike
text editing life enzyme does its thing
when I ask it to so this is very very
very powerful so this is this is this is
for me probably the main motivation for
enzyme but there's another really
important motivation here that is best
summed up by a single image this is
steady state eclipse in this image has
three files open Janet has 35 so 892
Meg's of RAM versus 318 Meg's of RAM and
Eclipse is sitting there using 10% of my
CPU while it's doing nothing this is
crazy okay and enzyme doesn't entirely
solve this problem but it hides it away
it tucks it away in such a way that the
prot the operating system is able to
manage it better and we're going to talk
about this in a second so I des okay why
are we doing this if we already have you
know modern ideas it's it's not 2008
anymore Eclipse actually works IntelliJ
is out there and it's it's functional
for Scala and things like that but the
fact is that IDE is our bad editors i
des have always been bad editors and why
is it that they're bad editors well they
give you everything you don't need and
about 70% of the things that you do okay
they were not designed to be primarily
text editors and the thing about our job
the thing about programming is that most
of what we're doing is manipulating text
you can make the argument that text is
just an abstraction for getting at the
ast and that's true but it's the
abstraction we work with it's the
abstraction we have and so our tools
should primarily optimize for
manipulating text that's the primary
thing we do that's the thing we're doing
almost all the time and the semantically
aware stuff needs to be secondary i des
get this reversed and they give us
semantically aware editing and AST
manipulation tools wrapped up inside of
really really really primitive text
editors and i this is backwards this is
entirely backwards so there are text
editors out there that do text editing
fairly well I mean basically any
decent editor is going to give you the
tools to be productive in text editing
why not start with those and then enrich
them with functionality IDs are also I
mean this is another point that's often
missed IDs are extremely confining they
are extensible I mean eclipse is
certainly much more extensible than it
used to be
NetBeans is much more extensible than it
used to be but they you know it's it's
try adding try adding support for a new
language to eclipse and then come back
to me and telling me that they're
extensible it's it's terrible it's a
nightmare I add support for a new
language to J edit every week and it
takes me five minutes like I I can't
imagine doing that in an IDE so this is
this is very very important so actions
speak louder than words and I think
screencast speak louder than actions so
here's a screencast showing and Simon
action inside Janet I'm using Janet
because this is just my editor of choice
right and some was built specifically to
work with Emacs but it is editor
agnostic which is a point I'm gonna
hammer home later
it's basically what I'm doing here as I
am starting the enzyme instance as a sub
process underneath Janet I was using
Janet prior to this without enzyme and
you know was only missing it for the
things that enzyme provides me right
Janet's function with functionality is
not compromised by not having enzyme
ready and what's happening here is
enzyme is giving us some Status Messages
down in this bar at the bottom I know
it's it's kind of hard to see increasing
this font size for Janet is actually a
bit of a pain but that bar at the bottom
there that status bar is where
everything is going to show up so one of
the features that I'm going to demo here
as soon as enzyme is ready is things
like finding the inferred type of a
particular value which i think is a very
very important thing for any scholar IDE
or any IDE for a functional language to
provide and that inferred type is going
to pop up at the bottom of there
basically anything enzyme wants to tell
us it is going to show up there at the
moment we are waiting for enzyme to say
full type check finished and this took a
little longer than usual because enzyme
has performance issues on anti XML so
here we go
the type of the nodes value is vector
case vector case is a class we can find
the inferred type of functions as well
as variables right the type is int see
that down at the bottom there we could
do job two declaration since we
just put the cursor over node and used
the appropriate key binding we can jump
into not only a declaration of values
but also the declaration of classes so
this is like your control click from
eclipse very very straightforward this
is amazing
error highlighting unsaved if your
editor doesn't have this you're wasting
about 90% of your day this this is a
huge productivity boost and notice it
was literally instantaneous my finger
wasn't even off the S key saving that by
the time that that error message showed
up it could find type errors as well as
name binding errors it doesn't find
everything because this is using the
presentation compiler but it finds a
ridiculous number of things and it finds
them fast which is the thing that
matters here I'm using job to type okay
this is your command shift T from
eclipse and enzymes implementation of
this is astonishingly crude but actually
works much better than eclipses which
I'm not sure how that works what I just
demonstrated there was syntax aware
selection so I was like expanding the
selection here I'm doing a rename okay
everybody loves refactorings and I can
do this on locals by just delegating to
n-side and time gives me this
refactoring support inside of my text
editor another thing but it's not just
renamed refactorings right it gives us
basically anything that scholar our
factoring offers so I'm gonna do jump
into a member here and then down here
what I'm gonna do is I'm gonna take the
right member of that tuple that I'm
returning the new group right and I'm
gonna extract local on this I'm gonna
extract it into right group okay sort of
thinks about it for a little bit and
then tells us the refactoring is
complete so we save and there's an error
because enzyme doesn't always get
everything right and I think this is
actually scholar refactorings fault but
this is this is a bug you just delete
the parentheses and life is good again
so yeah basically this is a small
fragment of the functionality that adds
time actually does that this is a small
fragment of the functionality
implemented in J at it enzyme provides
even more things that I don't implement
in jeddah like content assist right
where you're typing typing typing dot
and then you get your your helpful
intellisense assistant that tells you
what functions are available on a
particular type so this is this is all
very very useful stuff and this helps me
a tremendous a bit
in my workday so so what sort of
features are there in here altogether
well we already saw inferred type we saw
a jump to declaration we saw fast type
checking unsafe really really really
fast and anecdote that I want to
emphasize here when I started working on
enzyme in jannat I had two features that
I wanted to do okay literally just two
features that I wanted to enable and it
was worth learning enzyme to do this I
wanted an inferred type and I want to
jump to declaration error highlighting
is so easy to enable in J edit that I
just did it with one line of code
because you know it's an extra feature
and why not and after I turn this on and
I reloaded the plug-in my productivity
jumped by a factor of three so that's
pretty awesome
I was totally not expecting that this is
really really really really helpful and
worth fighting for to get this in your
editor and time gives you refactoring
it's not the full set of Java
refactorings but it's certainly the full
set of refactorings that are enabled
inside of Eclipse and the full set of
refactoring is enabled inside of
IntelliJ so yeah like I said 80% of an
IDE
we've got content assist and there's
even more okay there's more stuff that
we provide or those more stuff that
enzyme provides some of it I provide
there's debugging everybody loves dirty
buggers and some has had this for a very
long time in an essentially primitive
and annoying form Amon has been working
on this for the last couple months to
improve this substantially to the point
where the debugging support in enzyme is
really going to be appear for what you
have in Eclipse and IntelliJ and in
other editors in other IDs
there's semantic highlighting Eclipse
still doesn't have this I've been
bugging miles about this for three years
and eclipse still doesn't have this
feature aim and implemented it in like a
weekend so that's pretty ridiculous
Janet doesn't implement it because Janet
is limited in how it does syntax
highlighting and I cannot make it work I
am bugging the Janet developers about
that right now but realistically Janet
has like two users so it's probably
gonna take a while
enzyme is editor agnostic this is its
most important feature right here it's a
sub process it's a sub process that
Janet communicates with using the same
protocol
Emax communicates with it using the same
protocol that the new sublime text
enzyme mode communicates with it
it's totally editor agnostic and this
means that all of this work that Eamonn
has been putting in all of this effort
that he's put in we can reap the rewards
of that in our editors and it's
practically free like this is a
gift-wrapped IDE for your editor all you
have to do is hook it up it is multi
process and lightweight so remember I
had this screenshot from earlier where I
was showing Eclipse compared to compared
to Janet well
this Java process here at the top is the
enzyme sub process okay this is the
enzyme sub process and it's taking up
about as much memory as eclipsed it way
less CPU but about as much memory okay
so enzyme hasn't really made this
problem go away
in terms of process architecture or
anything like that what it has done is
it is move the problem into a sub
process so if I open up five projects
inside of Eclipse my memory usage will
jump commensurate to those five projects
and it will be one process image so I'll
have one process image that's taking up
four gigs of memory on my machine now my
machine has more than enough RAM to take
care of that but that's still a very
large process image if I do the same
thing with enzyme I'll have five
different processes one for every
project and now that sounds wasteful at
face value but think about Chrome why is
chrome fast it can't be because of
memory because Firefox actually uses
less memory than chrome does now so
what's going on here what's because
chrome is pushing this in two sub
processes sub processes are very very
very lightweight and modern operating
systems are heavily optimized for
managing sub processes they can page
them out they can page them back in they
can deal with them in parcel images they
can shuffle things around so much more
easily than they can with giant
monolithic things that are split up
using threads so this is super powerful
this is super super helpful and it makes
my system that much more responsive I
regularly open up enzyme and I just fire
up like seven different instance of it
and and it doesn't so my machine down
it doesn't cause me any problems at all
this is super super helpful it doesn't
slow down J at it at all because J edit
is a text editor that's a separate
process all of the communication with
enzyme is asynchronous
and so my text editing which remember is
the primary thing that I do my text
editing is not blocked waiting for the
compiler to bless my source code that is
really really really valuable
really really really valuable so what
are we giving up doing things this way
well we're reliant on the host editor
for implementation okay so poor aimin
slaves away on these lovely features and
people never see them because I don't
implement them and yeah there's nothing
that we can do about that because enzyme
is a subprocess enzyme is a server it's
a server that you communicate with via
protocol and you know Emacs provides a
pretty complete implementation of enzyme
Janet doesn't Janet can't because of
certain limitations sublime text and its
current currently evolving enzyme mode
is still not complete so there's work
that has to be done on the editor side
but this work is surprisingly minimal
okay I've put probably I don't know 16
to 20 man-hours into the J edit plugin
for enzyme and it implements about 70 to
80 percent of enzymes functionality it
exposes that to users 70 to 80 percent
in 20 man hours now that's including the
time I took to reverse-engineer the
protocol this talk as well as the
documentation that Amon has now written
finally is should empower you to do that
in half the time maybe a third of the
time enzyme is very very very very easy
to work with so what sort of clients do
we have out there right now it's its
editor agnostic what editors implement
this well I basically already listed
them Emacs is the big one this is the
reference implementation if you want to
know how enzyme does something this is
where you look there's an inferior
buffer you can pull up that gives the
output of enzyme I never actually use it
because I can never figure out how to
work with Emacs I
I refer sinja near enzyme using telnet
like a boss J edit is the Janet is the
client that I've been working on and
this has like one user based on
downloads
github and that I think that was me so
there's yeah nobody uses that but I find
it useful and it's enough that I
maintain it there's there's not a lot
else that's complete right now sublime
text it has a mode that's currently in
under active development which is
exciting because a lot of people are
using sublime text so ya get any time
out to the masses Mads Hartman has a
very old enzyme plugin for textmate that
I don't think even works with a recent
version of enzyme because the project
initialization is different I haven't
actually tried it though and then
there's like there's like a really old J
edit mode that I tried working with that
doesn't work and then there's a vim mode
that's apparently in development I don't
know for the most part these things are
still nascent but they're developing
quickly right there's a lot of interest
in this and I hope that this talk gives
you the tools you need to pull up your
editor extension API and implement it
because it's really easy and it will
make your life that much easier it's
worth investing this time so how does
enzyme mark okay what does the
architecture look like how do we how do
we talk to it enzyme is basically this
okay it's a layer on top of a bunch of
other projects the scholar refactoring
project this is the same project that
Eclipse uses to implement its
refactoring scelera form which is code
formatting a feature I didn't even list
because I don't touch it
and then there's the Java debugger
interface and things like this all of
this sits on top of the scalloped
presentation compiler which is a
different mode for the Scala compiler
that makes things run fast by basically
skipping a whole bunch of stuff it
doesn't deem it code it doesn't check
things like overriding or higher kinds
or anything like that
basically the presentation compiler
catches as many errors as it can in 1.5
seconds and then stops it's it's not
exactly like that but you kind of get
the idea more importantly it gives a
very incremental be updated ast so this
is this the whole concept for this was
developed by Martin or Darcy and Miles
Saban in the 2/8 stream to support the
new version of the Eclipse IDE so this
is what the Eclipse IDE uses it's what
NetBeans uses the Intellivision planet
that they live on and you know they kind
of have their own thing but it's
basically their version of the
presentation compiler and additionally
we have eclipse jd2
which is lives under here and this is
because classpath management is a pain
and there's really no need for a man to
rewrite all of that code you know
eclipse is an extremely modular project
it's very easy to pull out things like
this so the Eclipse JDT sub project that
basically the parts of it that are
useful for running and headless mode
live inside of enzyme this is also how
enzyme has Java support so you can
actually run it on Java files that's was
that what you're gonna say yeah yeah
that's not supported in jannat but it is
supported me Mac so if you open up Java
files that are in your enzyme projects
yeah you have an IDE just pretty cool so
how do we work with enzyme if you are an
implementer trying to implement enzyme
support in your editor how do you do it
you spawn the sub process there's a
batch script and a bash script inside of
the enzyme directory that you can launch
enzyme as a server that's the easy part
when you launch it you give it a file
this is a file that you select it's a
temp file or something just throw it
somewhere and enzyme when it starts up
it will write it will choose a socket
part something that's available on your
system and write that port out as a
number as an asking number into that
file so what you want to do is you
probably want to like busy wait on that
file or something like that just hang on
until a port is written into it at which
point you connect to it you connect to
that part and it's literally just a raw
socket and then you can throw the file
away or whatever it doesn't matter this
is usually very very quick enzyme starts
remarkably fast once you have this
socket set up you send s-expressions
over the socket encoded via the Swank
protocol now an S expression is a lisp
list so this is the whole parentheses
thing this is the foundation of Lisp
syntax and this protocol makes a lot of
sense because enzymes started you know
for supporting Emacs it was very much
inspired by slime which uses Swank it
this is not an annoying protocol to work
with a lot of people have talked about
like well shouldn't enzyme be using JSON
or something like that to send things
around no this is not a problem it's
very very easy to work with and it's
very very valuable to be using the same
protocol as Emacs so I highly recommend
you work with this zwei
his swank is easy and I will explain how
to do it in a second all of the RPC
calls are asynchronous this is super
important when you ask enzyme to do
something it will get back to you later
if at all usually when it doesn't that's
a bug but it will it will get back to
you later via a separate call so you
just hold this socket open and you send
s expressions down it and you can send
multiple things at a time enzymes going
to queue them up using actors internally
and and you just you don't block on it
do not ever ever ever block so one
important feature that your editor is
going to need to have enzyme support is
the ability to make these asynchronous
calls to be able to send things off and
then receive asynchronous callbacks and
handle them appropriately to be able to
preserve that state with J edit all the
plugins are written in Java or in my
case Scala so that's really really easy
to do with Emacs of course Emacs is just
built on that foundation some editors
like vim have a harder time of it but I
still think it's possible so how does
swank work this is the part that is now
documented that wasn't when I got
started and I literally spent about
eight hours in a telnet session sending
random bits to enzyme to see what it
would do so I came up with this well
this is actually a men's documentation
but here we go what you do the first
thing that is sent for a swank packet
the Swank message is six ASCII bytes of
hexadecimal encoded run-length okay so
this is the number 17 in hexadecimal
right here for those of you who don't
speak hex natively following that you
have that many bytes of s expression so
when you are writing a reader for this
what you want to do is you want to read
six bytes from the socket channel you
want to decode them as hexadecimal and
then read that many bytes and parse that
as an S expression and the same thing
goes for things that you send to ensign
so this is the entire point protocol
right here and obviously this this
run-length encoding thing you could use
with other textual content but s
expressions are what we use and they
work remarkably well what do these s
expressions look like well this is how
you initialize a project this is the
very very very first thing you will send
to an enzyme instant
when you start it up you get one enzyme
instance per project the project is kind
of a global motion inside of enzyme
itself so you start a new enzyme sub
process per project and this is the very
first thing you send as soon as enzyme
is awake right as soon as you have that
socket you're just going to stuff this
down the channel and it's the Anette
project
swank call okay the net project swank
call takes a whole bunch of parameters
that I have obviously elided for space
and this is things that you're mostly
getting from the dot enzyme file dot
enzyme file is generated using an SBT
plug-in or your build tool or something
like that and it's going to have your
dependency jars and your source pads and
things like that you're basically
sending this to enzyme and mass and
along with this call ok this is a
pattern that you have in every swing
call is down at the end there notice
there's a number at the very very end of
the s expression this is the call ID
remember calls are a synchronous so
enzyme needs a way to get back to you
and tell you hey remember that call you
made seven minutes ago I'm finally done
refactoring so that's that's how it will
tell you that call number one is done so
the response that enzyme gives you is
something like this return ok good
no errors project name well project name
and source routes this is kind of
redundant now I'm not sure why enzyme is
still doing it because we already have
this information in the dot enzyme file
but this used to be important back when
enzyme did a whole bunch of
introspection using SBT and then back at
the end there notice that call Aidid
number one this is the call ID that we
gave enzyme when we said hey and it's
the project now it's coming back to us
and says this is your response it worked
and this response could take a very long
time to happen so you you can't block
waiting for this you have to set up a
callback but there's more and
something's going to tell me some other
things just as a result of this init
project call it's gonna give me a
background message that says I'm
initializing the analyzer it's gonna
give me an indexer ready message it's
gonna give me a compiler ready message
these are the full s expressions that
it's sending me so these are global
messages that enzyme basically
proactively is sending down the channel
and telling me that these things are
happening right this stuff is going on
and you need to be able to handle these
so enzyme
indicates you with you not always
through callbacks but sometimes with
these global messages this is how
error-checking works so if you want to
do type checking on a file type check on
save what you do is you inside your
editor you register a handler for the
save action right and on the save action
you initiate a type check file call a
swank type check file call off to enzyme
an enzyme gets back to you instantly and
it says great ok well that doesn't
actually tell you anything it got back
to you right away way faster than it
could have type checked it because what
it's doing that is it's running the
presentation compiler or it's running
you know the Eclipse Java compiler in
the background to find out what the
errors are and as soon as it finds an
error in any file as it's going through
them one by one it will tell you via one
of these global messages so as soon as
it hits an error it sends it off to you
and it's your job to associate that
error which will be in the form of an
error message a file name a line number
and a column number you have to a column
span actually you have to associate that
back to where you are in the file and
actually know it's not a line number
it's character offsets from the
beginning of the file so it's begin and
end my mistake
anyway you have to associate that back
to where it where the error needs to be
in the file so you can display that to
the user and yours is going to be
getting these calls out of the blue so
you have to be ready at any time to
handle an error message coming from
enzyme that says error in this file
displayed to user please write and
you're gonna get a whole bunch of these
if you've got a bad user who's writing
invalid source files so what is uh what
is the future of enzyme look like good
first-class debugging has been kind of
the main priority for a while now and
enzyme as I mentioned earlier Amon has
been working on reimplemented the
debugging which used to be just like
controlling a JDBC sub process that was
horrible we implementing it on top of
jndi which is the Java native debugging
interface that basically every IDE under
this Sun is using so this will give you
things like you know call stack and
current frames and local values and
things like that
I'll giving you the full debugger
functionality that you would normally
expect from your IDE you could get that
inside of Emacs and if I find the time
inside of J it
so this is pretty cool this is like the
one thing that people miss going to a
pure text editor is being able to do
this debugging source jar indexing this
is is something that people always like
in various ideas right where you can do
things like look up the source of
java.lang string just by open type that
sort of thing in memory buffers this I
thought I mentioned this in the
limitation slide but basically because
enzyme is a subprocess it works on files
it doesn't work on buffers the buffer is
the thing in the memory that may be not
saved yet right it's something that
you're editing at the current time and
this is sometimes annoying because you
know a lot of times you want enzyme
functionality on a dirty buffer
something you haven't saved something
that doesn't appear to a file yet so
Emacs does some really dirty tricks to
save files out when you ask for things
like you're doing content assist right
type type type type type type type dot
write your buffers dirty Emacs has to
say that J edit actually has some really
nice functionality that very elegantly
solves this problem and so but you know
it's a hack and and it would be much
nicer if enzyme were able to synchronize
in memory buffers back and forth and
that's on the horizon stability and
performance there's a lot of bugs in
enzyme mostly inherited from the
presentation compiler which has a
ridiculous number of bugs and editors
okay more more and more more more more
editors okay Amon has put a ridiculous
amount of work into this he's done work
that we don't have to do now we can take
advantage of all of this in any editor
enemy a editor that is capable of
spotting a subprocess and sending these
asynchronous RPC calls we can get
advantage of IDE like functionality so
crack open your editors SDK do this like
you know make it work this is all the
tools you need there's more information
on a man's website
I have source code for the Janet plug-in
and the enzyme sidekick stuff the enzyme
sidekick the Janet plug-in by the way is
written I apologize I didn't know the
slides were going to be this low the
enzyme sidekick is written entirely in
scala and it has a
I don't know 60 to 70 percent of a full
enzyme client inside of written in Scala
so you can very very easily look at that
for source implementation so if it if
anyone has any questions we have 47
seconds left oh we have five minutes we
have five minutes and 43 seconds so does
anybody have any questions why why
aren't the ideas using enzyme is
back-end so there are downsides to using
enzyme like I said the in-memory buffer
things and things like that
and when you're an IDE generally you
have a lot of infrastructure already in
place for doing a lot of this stuff a
good example is the Eclipse plugin so
the Eclipse plug-in doesn't but the
Klipsch plugin for Scala doesn't bundle
a separate instance of Eclipse JDT it it
uses eclipses JDT through some very evil
mechanisms to get at that NetBeans uses
its musi the NetBeans Java support so
the advantage to an IDE is that you've
got these things that are fully
integrated so if you have an eclipse
project for an eclipse Scala project
that depends on an eclipse Java project
you can use OpenType from within the
Eclipse Scala project and open files
inside of the Java project
you wouldn't be able to do that very
easily if enzyme were the backend so
there are there are things that you lose
this way right right yeah so eclipse is
using the presentation compiler NetBeans
is using the presentation compiler for
its Scala support the difference is that
eclipse will first run the presentation
compiler and will be running the
presentation compiler constantly
basically to keep its ADT up-to-date
it's its ast up-to-date but when you
save a file in Eclipse it will also run
the official compiler and so this is why
there will be spurious errors that show
up inside of enzyme or occasionally
inside of NetBeans particularly relating
to path dependent types and things like
that that you just won't get inside of
Eclipse because Eclipse immediately
overrides those errors with the official
compiler which doesn't have those
problems so yeah so the some of the
infrastructure is unified scholar
refactoring and scelera form are also
used
by eclipse okay Nermin is cutting me off
so if you have more questions later see
me afterwards thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>