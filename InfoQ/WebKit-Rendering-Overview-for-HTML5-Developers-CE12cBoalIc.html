<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>WebKit Rendering: Overview for HTML5 Developers | Coder Coacher - Coaching Coders</title><meta content="WebKit Rendering: Overview for HTML5 Developers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>WebKit Rendering: Overview for HTML5 Developers</b></h2><h5 class="post__date">2013-04-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CE12cBoalIc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we Ferrari delve into front-end
development or rather the html5 and
JavaScript side thereof I've been doing
programming on the other side like for
desktop environment called KDE and
cross-platform support library called Q
and lately also WebKit now throughout
this progression I realize that if
you're a front-end developers and you
try to create web apps in certain ways
it would be very nice if you have
knowledge about how browser works or in
this particular use case how WebKit
works because that gives you a different
understanding in different perspective
on how you create things so today I'm
gonna cherry pick some of the topics
that I hope it would be very useful for
you the next time you try to create the
web apps so a little bit about WebKit
itself
WebKit was created as initially as a
form of HTML from from Apple and that
was almost 12 years ago if we look at
the revision and as you can see not
right now it's just almost everywhere if
use web browser likely it will be based
on WebKit mobile devices and application
runtime etc now if you see this
progression
you can see how operating systems and
browsers a'dope WebKit along the way and
on the vertical axis is the revision
meaning check-ins and you can see we're
approaching 150,000 there and that's a
lot of code and if you calculate this
this approximately 3000 commits per
month and I don't know about you but
that numbers is like scary
I think Linux kernel did this because
he's like 5,000 commits per month but if
you are about to build a development
team and try to work in such a
development pace that will be pretty
difficult to handle
that's why WebKit is very heavy on
test-driven development even before it
was becoming a buzzword and if you check
out WebKit repository right now guess
which one is the test portion that one
so just about 10% of your check out will
be code
the rest there just s there's a running
joke where people say WebKit is a bunch
of tests and the code is there to make
the test pass and what this has very
nice a very nice concept of social
layers
I think this starts to be adopted in
many projects as well so every
contributor starts by sending patches to
WebKit and after a while you will be or
someone can nominate you as commuters
where you have direct access to the
repository so this doesn't mean that you
can just commit stuff like crazy every
patch needs to be of review and after a
while probably about a year after you
contribute so many patches then someone
can nominate us reviewer this gif give
you an extra rights of reviewing patches
meaning you can accept reject give
refuse etc so for example Yui project I
think they started up this kind of
social layers now along the line of
heavily heavy on TDD and then a big team
thousand commits per man this allows
someone to get familiar with WebKit code
for us and then work to become commuters
and after a while when he's comfortable
working with a huge codebase then he can
start reviewing others patches as well
there's very nice statistic and
analytics on who are these commuters and
reviewers they're still mostly dominated
by big companies like Apple and Google
and as you see the commit rate the right
side chart there it's just you know
Apple has been doing this for a while
obviously and then Google catch up with
with the development throughout this
presentation I'll sprinkle links here
and there on the slide deck so that you
can follow it up at home if you want to
find more further information about this
so if you look at the browser at the
higher level this applies not only to
webkit-based browser but anything any
other browser as well what you see is
usually just the user interface and
underneath that there's the browser
engine and it embeds the rendering
engine which is
to display your contents as pixels on
the monitors and because you need to
save everything from storage to
persistent ease cookies and everything
then there's a way to store that for you
and the rendering engine needs to
interact with the network because it is
to pull the data off the server
JavaScript engine because sometimes you
want interactivity as well as graphic
stack we're gonna see what graphic stack
is in a couple of minutes
so what keep component itself usually
people talk about webcore and
javascriptcore get JavaScript core or
GSE the marketing term for that is nitro
is the one that is built in and it's
used by Apple on Safari and Mobile
Safari Google however use different jobs
game engine I'm sure a lot of people
know about this v8 but they also shared
the same web core and web core consists
of a lot of modules from html2canvas to
SVG and so on the design of WebKit
itself is following the pattern called
platform abstractions so if you see this
diagram Chrome and Safari they shared
the same parser they share the same CSS
lecturer pressure the same SVG models
and canvas implementation but the way to
output that operation and then show it
to the screen or even interact with
timer they're all different so that
depends on the browsers
operating systems and we had many other
factors this makes sense because if you
try to get some data over HTTP on
Windows the API to do that is completely
different than if you want to do it on
Linux and that applies to anything from
clipboard keyboard is probably the most
glaring example where every opportunity
that's it differently and geo locations
well Kisan mobile devices the way to get
your location is different than say on
the desktop or laptop if at all so one
of the most frequently asked question
what WebKit is why two browsers using
the same WebKit they behave differently
and this is the explanation because
underneath that they might use different
traffic stack they might use different
ways to implement certain abstraction
it's as if you take two same engines and
put it two different cars sometimes you
get different performance or put it in
two different airplanes
you don't want Airbus pilot to land
Boeing airplane for example just because
they use the same engine there are many
other factors that makes airplanes
different so let's take a look at the
first important blocks of web core which
is the loader and parser load
responsible to get something and unload
it possibly from remote server and then
parser it's responsible to consume that
data and then make something useful out
of it and if you look how they relate
the both HTML and CSS they have their
individual parsers and then HTML parser
will construct something called the Dom
tree and combined with the stylus this
will build a render tree so loader
itself is ridiculously complicated
that's nice blog post that explains how
this works basically there's two
pipelines one is loading for loader for
the document loader itself which is
responsible for loading the document
contents and then the second was for
resources such as scripts or images or
style sheets that's part of the that
document what is important here is that
if you build a webkit-based browser then
you can tweak the way for example if
someone clicks on the link do you want
to have the navigation policy that
follows that link and then open it a new
page or do you want to completely block
that in some cases this is necessary for
for example hybrid html5 runtime
environment and then there are cases
were if browser finds that this document
cannot be understood say it's not CSS
not HTML then for example in PDF so what
do we do do we need to open it in a PDF
viewer do we do save it we need to ask
the user etc so that's why it's slightly
complicated there it's different than
inline resources because or embedded
resources because you're supposed to
consume that as part of the document and
sometimes the data that you have might
not come fresh from the server but in
some ways on others have been stored by
the browser's and these are just some of
the list of possible cash in chrome
there are 10 and more so one of the nice
thing about having a being able to parse
HTML is something called tokenizer so
the tokenizer is responsible to split
this into tokens if you see simple text
here then the tokenizer will recognize
there's a tag HTML and body and P and so
on and those are packs so this seems
easy but if you read the specification
how many of you here have read html5
specification yeah if you try to print
it it's several hundred pages and
tokenize tokenization
involve 70 states so it's it's not easy
it looks from this example it's pretty
straightforward but it is not so after
we recognize all the tokens then the
next step is to parse it the job of the
parser here is to build a Dom tree out
of your HTML document and usually this
involves a process involving module
called tree builder where it is fed by
the tokens and then try to construct the
tree html5 parser specification
compliant it's also very difficult to
build in work itself is about 10,000
lines and again if you if you read the
specification it's quite not trivial the
nice thing of all browser confirmed is
the same new html5 parser is that they
will produce the same Dom tree even if
the document is broken or you have
mismatched tags etc so they sort of
define the same behavior new in WebKit
is threaded HTML parser which means that
when when it parses your document HTML
then it does it in a different different
thread so it won't block your UI this is
quite important on mobile device with
limited resource so from tokenizer we
can extract some useful information and
this is something in WebKit cause the
preload scanner for example if i parse
CSS and I find import then I can
immediately fetch that you are all
referred by
that CSS that's my starship without
waiting until the CSS distance is fully
parse same with HTML if I see there's a
script tag there is there's an image
then you can start to schedule and
network requests that pull this resource
of the server this is an example where
if I just open center calm and there's a
bunch of resources that are fetch even
before the document is completed very
useful to optimize the network
performance
so that's loader we get data it's been
tokenized it's parsed and we got Dom
free now we enter something called
layout a lot of people use the term
reflow I prefer layout because that's
what CSS specification says so this is
Dom free if you work with JavaScript to
manipulate the document you might be
familiar with this this is best it has a
standard and basically from that text it
will construct the tree that match the
way you will expect it this is the
actual WebKit class name and nicely
match to that html5 specification so the
Dom tree itself doesn't say anything
about how to hang those trees on the on
the screen as just pixels and therefore
WebKit has something called render tree
so the render tree implements the CSS
box model again very long specification
and they usually match one to one so if
I have a HTML document and there's a
render tree called render root and
there's a body in there stacks the
render tree is also used to navigate the
the tree structures and then do metrics
so if you click on a button or mouse
over then it knows that render tree
needs correspond to which dom tree
obviously if you read the CSS box model
specification you need to be able to
find styles for your rendering and its
tackled by something called render style
this is yet another tree tree structure
and roughly in layman's term this corpus
this corresponds to the computed style
if you do
daaamn analysis there say in some cases
you don't have a render tree for example
if you set the display property to none
then there's no render tree associated
with that because there's no need to
display that that particular node so
there's so many trees in WebKit's
that's confusing so we have dom tree we
have from the tree how do we create
those this is something called a batch
process historically it's been called
that way since catch them all time so
the logic is a Dom node is invisible and
then you attach it to the main view to
make it visible and therefore it's
called a patch so if I have a dome or
element in this case a div and then
create the render object associated with
that
that's called Pechman and then a WebKit
can display it as part of the main view
again for a particular node you might
have some style too many trees so we
always joke sometime it's a forest it's
not the trees anymore WebKit is a
collection of a lot of trees a Passman
process is also as complicated as a
loading process and this is just this
diagram captures just partial of the
actual attachment process that happens
inside WebKit code more precisely web
core so there's a huge difference
between style recalculation and layout
layout involve metrics and geometry for
example if you move one diff to another
another place then obviously the
position change Styles means only two
top style the correction means style
resolutions solving a particular
properties style properties for each
node so probably an example here is if
you change the top property of the style
then WebKit need to paint a larger area
because you know the position might
change but if you just change the
background color than the the rectangle
that is affected by the that change will
be pretty limited because it doesn't
move to another
I'll show you some demo later so getting
the right style involve CSS selector
matching because you might have a style
in your statute that defines the colors
blue and then you need to resolve it if
WebKit finds a paragraph element and
again this is this is store in render
style so there's a lot of tricks to
minimize layout and this is usually
involving avoiding touching some
properties that cause this geometry /
dimension recalculation there's a long
list there sometimes there's also a best
practice where you try to avoid one
property after another and do batch
processing so we get the document a
sparse is constructed as Dom tree and
then the layout process creates the
render Chi now how do you how do we
paint that so the goals of painting is
obviously to visualize all the render
objects as pixels on your monitors every
painting commands goes to the something
called graphics contact abstraction I
refer to platform abstraction earlier
and then there's particle optimization
that can be made there where for example
if that particular render object is not
visible to the viewport then it doesn't
need to be painted and of course to
handle transparency clipping and so on
again this needs to follow the back to
from algorithm graphics abstraction
means that every WebKit based product
will use different graphics TAC we can
see that Mac and iOS they fall into core
graphics and chromium Android use skia
the rasterizer from google and there are
others tool kits as cute and gtk that
used their respective graphics time to
put simply inside web pick what kid core
itself you want you will not be able to
see calls to particular core graphics
API or even skia api so it will simply
call graphics contact as an example if
graphics contact this has an api call
please draw around it button somewhere
then it will call the corresponding core
graphics API to create or to paint that
from the power
so if you have a graphic stack that
doesn't understand rounded corner it
means that your button will look either
rectangular or completely weird CSS
painting is again not easy it involves
10 stages from defining the outline
background etc so the way WebKit does
the painting or web core is to ask every
render objects please pain yourself
according to these 10 stages and then it
follows from back to phone with the
proper tree traversal based on your
z-index if you build webkit-based
browser the painting request can be a
synchronous for example the browser
doesn't need to paint certain areas if
it's outside the viewport if your patch
is very long it doesn't need to paint
the bottom part of the page if you're
still at the top so that's one way the
browser requests that the WebKit the
other way that happens as well for
example if the page has a script that
changed particular colors then what
could need to needs to tell the browser
hey that that that rectangle has been
invalidated we need to paint it again so
two ways now if you talk about graphic
stack the responsibility of graphics I
began to draw shapes and in the concept
of PostScript board were all graphics
that usually follows path is everything
this is different than UNIX in UNIX file
is everything in the world of graphics
path is everything so path is a generous
form of curves everything else is a
subset of path in order to make path
appears on the screen needs to be stroke
and fill this demonstrate the cheapest
possible stroke and brush which is on
the left and the most expensive possible
stroke and brass so if you want your
page to be performance just use solid
colors and no fancy dotted lines etc
this seems trivial but this allows you
to do a feature cross analysis so how
how much I will go from the designer
perspective tweak the page so it looks
beautiful but the same time
what kind of performance that I will
sacrifice painting is also complicated
because people you know paint or draw
text you know it's very hard to imagine
web P dot X and X are just curves
because those cliffs are crazy and in
many graphics tack curves cannot be
painted directly so it needs to be
broken down into a series of polygons on
top of that we also have anti-aliasing
support so that all the jack edges
they all look smooth this is why I'm
pretty excited with high-density
displays such as a retina technology
because at one point we might not need
to have entire lacing anymore
and of course in some cases you want
things to to animate rotating or have 3d
perspective and so on this just
complicates the work of a graphics neck
so painting that's general painting and
I like to touch a bit but hardware
acceleration in particular in the
concept of WebKit usually when front-end
developer talks about a product system
this is all we refer to right it's just
a matter of waiting your magical one and
then cast the spell translate 3d this is
unfortunately the very perverted view of
hotrod Larsen within the context of
WebKit and I'll tell you a bit about
that in a couple of minutes so many
devices phones or desktops even they use
system-on-a-chip so in your CPU
it has everything and if you look at the
particular GPU or rather the block
thereof
it has particular properties mainly
because this has been designed for
accelerating games and not not anything
else
so it has fixed geometry and it can do
some transformation and most of the time
it's optimized for rendering textual
triangles it's not a surprise for many
graphics programmers that sometimes
drawing a straight line is lower than
drawing a triangles if you're familiar
with games development this is typically
the way people use GPU so define some
practices points in the space and then
you apply some transformation and then
it will be rendered and then you can
possibly texture it so it looks
more realistic so the efficient used by
efficient use of GPU by WebKit involve
certain levels first is obviously to
extract the drawing primitive I mention
how anti-aliasing and curve and polygons
they're very difficult to handle this
could be delegated fully to the GPU so
if you use Mac or Safari on Mac which
uses core graphics as well as chrome and
Android that use skia this graphic stack
knows what kind of platform they are
running on and for example can I take
home my GPU is quite powerful
now let me delegate some of the drawing
primitive into the GPU so without you
realizing it without those magic 3d and
so on sometime the browser already used
hardware accelerated graphics what I
wanted to show next is something called
packing store and compositing so when
you build a interface user interest that
needs to be responsive some time you
want to decouple the user interaction
between rendering itself and typical
example for this is Maps how many of you
use Google Maps a lot of people use
Google Maps and you don't need to wait
until Google Maps downloads all the
tiles before you can you know pan around
and zoom and do crazy stuff with it so
the process of downloading the task is
separated from the process of maps
responding to your user interface
gesture so in in WebKit many browser
many webkit-based browser implements
something similar so the rendering
doesn't happens straight through the
screen but it goes through something
called back install and this diagram
illustrates it that backing store list
I'll explain a little bit why style so
when you zoom in scroll pan and move
your fingers on the screen on the
touchscreen
what you do is manipulate the backing
store so totally decoupled if you own
the very first version of iPhone
sometimes you can notice the
checkerboard pattern how many of you
have seen this yeah these days you don't
notice that anymore because the phone is
so fast that it catch up pretty quickly
but in the old days yes if the page is
complicated you scroll very quickly then
momentarily for a couple of hundred
milliseconds you don't see any contents
there
and this is exactly because the backing
store has not been updated to contain
that portion of the contents yet and if
you pinch-to-zoom
that even happens today sometime you see
blurry rendition of for example in this
case your SVG so that's something called
progressive rendering as you zoom in
zoom out the browser just displays the
scale version of your content and then
when you stop or whenever he has some
time then it tries to render your
content with a higher resolution and so
basically you can transform your finger
movement your gestures into just matrix
manipulation because panning means just
translate up and down and then zoom
means just scale it so if you look at
this time diagram from the moment that
you pinch on the screen until you stop
there will be two processes happening
there first is to display something
quickly as soon as possible although it
might be blurry blocky
and not perfect and then after a while
you're gonna see something sharp on the
screen so this is the trick that has
been used by minigames
application and many other typical
graphics intensive application for a
while and we've seen that in browsers if
you use the latest iPhone or Android
then all the browser's their use of
technique so baking stories uses cloud
because what you you can leverage the
the the concept texture streaming
instead of drawing a huge backing store
and senate at once you can just split it
into small small files and then send it
by one by one this is why the
checkerboard pattern happens as well
because it doesn't update the entire
screen but it's just a bit portion of
the screen we can extend that concept
further so instead of just huge backing
store for the entire page what if we
have back in store for each element and
that's called something as layer and web
core does use backing store for four
elements that for example has 3d
telephone or if it's a video attack or
if it's canvas or plugins
if you do a CSS animation and filters
and for animation this is wonderful
because the way animation works there
are two steps versus the initialization
so you just want to see hey I want to
animate this element please put it in
the GPU and then the animations that
happens this happens for every frame
where you manipulate that elements
wallet orgy size in the GPU so when you
see a demo how many of you have seen
WebKit leaves demo
this is a pretty famous demo back then
so you see leaf falling from the top and
those images there are individual layers
so for every single frame WebKit does
need to draw that image again and again
on the different position because it
already stores everything on the GPU it
just needs a GPU a it's the same leaves
but now different precision so the
rightmost diagram shows that that's how
it's visualized inside the GPU so you
put layers one after another x' and then
we just manipulate the layers the models
that's responsible for handling those
layers often call compositor and one of
the responsibilities responsibilities to
do twinning because if you want to move
a box from one place to another if you
want to have a smooth animation then
obviously there are twinning steps
involved they're new in every browser
engine is using compositor in the
separate thread again this so that we
can have advantage of exploiting the
multi-core processor and not blocking
the UI thread
core graphics via core animation does
this very nicely so if you want to debug
all this layer in compositing with
Safari there's very easy way so you just
need to type this on the terminal and
then suddenly you have an extra debug
menu on your Safari so I'll show you
here there's drawing compositing flags
and you can disable show compositing
borders here and that's why you see the
borders yellow borders there because if
I open this in my other browsers and
well the demo doesn't display any
borders but because suffer he draws some
borders around those layers then you can
witness the those composite layers so
the borders the colors indicate
something but what what is very exciting
is that each of these borders each of
these rectangles displays a number in
the corner I don't know if you pay
careful attention there so 66 over there
and there's two over here this
represents how many times
WebKit has captured that element and
then send it to the GPU that is very
important because you need to optimize
the amount of you need to minimize the
amount of texture upload if you use
mobile browser like Chrome for Android
you can even enable this stripe from
your browser you just need to go to
chrome flags and then enable something
and in addition to that this head-up
display also display the frames frame
rate chart how many frames per seconds
your your browser renders the page as
well as the amount of GPU it's not
really feasible but here I can see that
it's using twenty five point five
megabyte of 256 megabytes of GPU memory
we'll see that
optimizing the animation or even webpage
in general to minimize than one of GPU
memory is extremely critical so in order
to avoid texture upload there are only a
couple of things that you can do so it's
not as long as you animate the opacity
or animate means also change the opacity
move the element here and there and
change the size playing with the
geometry and do some you know filtering
that's fine there's no need for WebKit
to capture that element again and send
it to the GPU but everything else is
dangerous so this for operation this is
usually what people often refers have
accelerated CSS so constant texture
upload is rebab let's give an example
here
so I have a box that changed the color
from green to blue and I also move it so
that it's visible and now you can see
that number keeps increasing it's
because if I change the color then what
kid needs to capture that element again
just imagine this is you know capturing
as an image and then send it to the GPU
so changing the background color causes
a lot of texture upload and if I keep
adding this if you do it on your phones
or low power device at one point the
animation will stop completely or it
will start to skip frames meaning
instead of going gradually from blue to
green it just shows blue and then a
couple of seconds later green and so on
and if you use Chrome for Android with
head-up display you can see that this
totally separates the GPU memory so if
you do that I need to close this if you
do that no amount of translate3d in the
world will save you now if you just play
with transformation whether it's 3d or
2d or some other rotation for example
then it's fine because if we see this
spinning 3d cube although the animations
seems a bit complicated you can see that
be the number there they don't change it
keeps at the same number which means
that for every animation frame were I
rotate the spinning cube there's nothing
much happening there between the CPU and
GPU except the CPU to GPU head please
now use the different transformation
matrix for for this texture
same if you do a opacity change so in
this case I do a rotation and about
opacity change at the same time that's
fine and that will be very
high-performing because the CPU doesn't
need to tell the GPU please recapture
this and send it again so one one
operation one initialization and for
every animation frame is just a matter
of modifying the opacity and modifying
the transformation now if you've seen
the predictable demo from 3GS very nice
graphic library let me show it this is
pretty cool
even if you view this demo on on a
mobile device on a tablet for example it
is very smooth because what it does is
to prepare all the elements and then
send it once GPU textures and then when
you manipulate this this is a matter of
telling the GPU hey please use new
transformation matrix very light with
very minimal high performance and
there's a bunch of other demos for
example movies your example from One
Touch is nice examples where you can
have animation on the curve and that
will still perform nicely even on a
mobile device because it doesn't involve
the recapturing and capturing of Dom
elements
if you check this photon CSS lighting
and then you toggle between lighting
enable and lighting symbol you're gonna
see that enabling lighting will cost a
lot of texture upload because you change
the color and this is also very nice
example where you can build a
first-person shooter
using CSS and that performs nicely again
because as long as you didn't change the
lighting very much then it will be just
a matrix transformation matrix
manipulation where's that mean - yeah
here you can see that if I scroll this
the the number there changes as it comes
to the phone the view but otherwise it
will be pretty stable so when I do this
animation the GPU needs to do very
little amount of work and that's why
it's bit smooth filters nothing as long
as you play with filters change changed
some elements to have different colors
at some drop shadows and so on this just
tells the GPU to use different shader it
doesn't need to be captured that element
if you play if you build some game
sometime you need to respond to you the
user reaction and for example if you
have built a game where there's paddle
on this ball you need to define where
the ball move depending on how the user
behaves or responds to to the ball and
if you kick the animation based on Java
scape you're gonna miss at least two
timer ticks one is for the animation M
even and then one is to kick the next
animation so one of the things that you
can use is to prepare both animations so
you know either is going to go left or
right and hide it immediately as soon as
you know which one is according to the
user reaction as I've said before in the
movie show example this is a very nice
case where you can you don't need to
create this movie poster every single
time because there's only so many you
can see on the screen so you just need
to swap the contents and and therefore
you don't need to force a new texture
creation all the time and because the
user can only move either to the left or
the right then you can sort of priam
that and prepare some texture hide it
off screen
then show it immediately at the right
time one of the important thing of using
the rendering using the GPU is to offer
a texture upload because you need to
think the GPU like a cache so if you if
you go crazy and translate 3d every
single element that is not a wise move
now have some option before that color
transition will cause a texture upload
because in this case if I changed from
blue to green there's no way for the GPU
to keep that blue content and then
change it to green
unless use filter of course so one of
the thick tricks that you can do is to
do superimpose elements or worse them so
for example this is very similar mo like
I mentioned before but you see the
number the number stays at 1 and the
trick is because actually I have two
boxes there and then there are sit on
top of the other and their color I never
change them so what I change is the
opacity so the effect is that this will
create a box as if it changes the color
although it doesn't the drawback of
course you need twice the amount of
memory so unless you do it carefully
your GPU memory will explode but this is
far fine for subtle animation and
something that you do for you know two
seconds are supposed to for the entire
life cycle of a webpage so again
blending is something that you can use
to minimize the amount of texture upload
so as anyone who lives in big cities you
know that a car doesn't tell you
anything on how fast you can go from
point A to point B because if you hit
the freeway that looks like a parking
lot then it doesn't have that much so
because we're in California and chance
it Tesla so if you want to maximize the
power of the GPU you have to be careful
to minimize the actual upload and
minimize the manufacture so wrapping up
you've seen in a 10,000 foot overview
how loader roles and how WebKit layout
stuff
by our energy and how particles and
objects are painted and of course some
use cases of fat or acceleration so if
you know what is expensive what is not
expensive but ugly then you can do
future cost analysis it's also important
not to fight the rendering engine WebKit
improves slot so there will be threaded
HTML parser and with google chrome and
chromium there will be threaded
compositor and if you try to redo what
the browser is doing at some point it
will cancel your optimization if you use
CSS animation the browser knows how to
discuss animation very nicely so it can
schedule all the twinning and it won't
block your UI thread it doesn't cause
any JavaScript garbage collector because
it happened some different process etc
so don't assume that just by say
throwing translate3d or whatever then my
page will perform very nicely always use
all the tools or the metrics that is
available to you and make the right
decision so hopefully by knowing all
this stuff you will be able to build a
great web apps thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>