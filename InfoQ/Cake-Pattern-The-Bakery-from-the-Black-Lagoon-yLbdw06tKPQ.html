<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cake Pattern: The Bakery from the Black Lagoon | Coder Coacher - Coaching Coders</title><meta content="Cake Pattern: The Bakery from the Black Lagoon - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cake Pattern: The Bakery from the Black Lagoon</b></h2><h5 class="post__date">2013-02-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yLbdw06tKPQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for you for having me do the
keynote we're about to discover what a
terrible terrible mistake that was but I
don't know hopefully hopefully it's good
I wanted to talk about the cake pattern
okay
now the cake pattern is something that
was I believe named as a pattern by John
credi in a paper like I don't know seven
years ago I mean this is a fairly old
thing it's been around in Scala pretty
much as long as traits have but it
wasn't really it wasn't really talked
about in the mainstream or really used
in the mainstream until
yonis poner is blog post on how you
could do dependency injection with a
cake pattern and I thought it was a
really good blog post and this was like
four years ago now and just a quick show
of hands how many people have read
Jonas's dependency injection blog post
all right good good good it's it's a
good post old version of scallop but
it's good I am here to tell you that
that description of the cake pattern is
woefully inadequate because there's so
many things that the cake pattern can do
for you that are not really dependency
injection in fact using it for
dependency injection is like this tiny
little backwater of the cake pattern and
it's it's really only a very small part
of the larger picture so what do I mean
when I talk about the cake pattern well
I mean things like this okay so I
apologize for those of you on this side
who maybe can't see the bottom of the
screen I didn't realize there was gonna
be a symmetries so yeah so we've got a
user module right and the user module
has a function that allows you to load a
user which is something and then there's
a tweet module that allows you to do
things and then there's a MySQL user
module that implements user module and
then a Twitter module because every
social media startup will tell you
there's more than just Twitter for
tweeting and the the Twitter module uses
both the tweet module and user module
and you notice said it's using user
module in an abstract form it's not
using the it's not depending on the
details of MySQL to do this and then
finally at the end of the universe we
put everything together in in this this
giant cake we call universe new MySQL
user module with Twitter module and
everything goes together at the
dependencies line up
and the compiler will check to make sure
that we actually have an implementation
of load user and an implementation of
post because those are the things that
we need to be able to do stuff with this
so this is kind of like the the essence
the essence taste of the cake pattern
but there's a lot more to it and what
we're going to talk about is basically
four different things here we're gonna
talk about some of the type theory that
goes just very very briefly that
underlies the cake pattern and makes all
of this stuff come together and we're
gonna mostly we're just going to talk
about modules modules are what the cake
pattern is all about it's all about
modularity and modularity in a way that
isn't really supported by any other
mainstream languages there are other
languages that have modularity to this
extent but nobody cares about them
because they're all sort of often
esoterica somewhere and then the we're
going to talk about some of the problems
that arise when you do this you know the
cake pattern is really amazing it's a
very powerful way of doing abstraction
and organizing your code base but
fundamentally we're taking something
that's very very very powerful and very
very extensively extensive in its
implications and we're applying it to a
platform ie the JVM which is extremely
limited and that gives rise to some
really really really weird quirks that
will bite you hard every time you use
the cake pattern and then finally some
best practices for keeping things sane
so hopefully this is hopefully this is
interesting type theory here is a class
I'm sure this is a revelation to
everyone this class has a field in it X
which is supplied in the constructor
it's a private field which is
significant and then it has a function
which takes a Y and it returns a new
value using that X now stop and think
about that for a second we do this so
much every day this seems extremely
persik but if you think about it
something very odd is going on here you
can give someone a foo okay they have a
foo which means they have a function add
from int to int and that function add
uses something that is inside foo
something that is not visible
to you who gave them that function okay
this is really really interesting
now you could call this partial
application and in fact it is but what's
what's really significant about this is
there's a piece of data there's a piece
of state not mutable state but state
that is inside this object and hidden
and passed implicitly to the add
function as a hidden first parameter
that this pointer every time we call the
add function so this turns out to
actually be very very interesting and it
steps on an interesting core dichotomy
in the fundamentals of higher-order
logic and of course higher-order logic
is higher-order types so Universal types
everybody's familiar with the concept of
a universal type or at least you know
most of us are right these are standard
generics right you have a function that
takes some type parameter a maybe it's
inferred maybe not it actually doesn't
matter from a theoretical standpoint and
that function is just defined for all a
right so we've got this trait for all
apply you know apply to a give me an
option of a obviously a couple different
ways you could implement this but it
doesn't matter just like focus on the
type signatures so this is a for all now
those of you who know logic know that in
addition to Universal quantification
there's this concept called existential
quantification so Universal
quantification says for all a T of a is
true existential quantification says for
some a we no doubt what T of a is true
not for all for some this is a really
profound dual really really profound so
here's here's kind of what it looks like
in Scala we've got an exist trait and
then instead of a being a parameter on
apply a is actually a type inside of
exists okay and so if we have something
of type exists inside our function bippy
right then there's that apply method
that we could try to use but the problem
is that it's not going to work
so unlike for all we're we're free to
give any type any type instantiation to
a and it's guaranteed to be correct
because it says for all a here we have
for some for some we know not what we
don't know what a is
for this can't be valid because we don't
we the compiler can't prove that a is in
fact an int so it turns out there's
actually no valid type that you can
stick in here you cannot call the apply
method on exists which is seems useless
the the core realization here the core
thing that allows us to get this sort of
useless situation which is in fact very
useful as I'll talk about in a second is
is this sort of rule okay if we have a
type from t1 to t2 okay this is a
function from t1 to t2 we can at any
time say okay there exists an X such
that t2 we can this is this is kind of a
way of typing there a type by broadening
rather okay exists in X such that t2
we've thrown away some information in
this type signature and that's what
we're doing with the exists type so
here's the question why on earth would
it be useful to take information away
from you the developer right why is it
useful to have our types hide more than
they have to well what is the essence of
modularity information hiding all right
this is what we do to manage complexity
in our code bases is we take information
and we partition it off so that parts of
the code base don't know about details
of the other part of the code base and
we can evolve them independently this is
modularity and what's very interesting
is this is stepping on the core
principles of object orientation now I
know this is Scala object-oriented is a
bit of a dirty word but stick with me
for a little while
imagine we have this trait thing okay
this is a somewhat general concept which
is why I called it thing because that's
the formal word for it and so thing has
two type parameters one is contravariant
one is covariant whatever it doesn't
matter and it has some existential type
X inside of it and X you can think of X
as being a representation of some state
inside an object so you remember back to
that first slide where I had foo
okay the class foo that had an X and
then an add function that used the state
inside of foo acts the type X here could
be that state right it could be an INT
it could be something else we don't know
we don't know from the outside but we'll
know on the inside which is what matters
so we can create that state so people
can pass it around like a constructor
and we can use that state using the sink
method to produce some value and then
there's there's a morphism that we have
you know from state to state so it's a
you know it's not not too terribly
complex and the magic of Scala allows us
to use this thing even though we don't
know what the type is okay so we can
take and we can have a thing from int to
string and remember even knowing that we
have a thing from interest ring we still
don't know what X is it doesn't matter
we don't need to know what X is we can
get an X by giving source an int right
that's the input type and we can use
that X and pass it along and then do
things with that X and finally produce a
result okay even though we don't know
what the type of X is this is very
analogous to what happens every time you
use an object that has private members
it has some stuff inside of it that you
know the JVM is sort of implicitly
typing and carrying along with us
this is the explicit version of what the
JVM does for us every time we do an
object so this concept of information
hiding and and modularity via
existential types is actually very
familiar to all of us if you think about
it we're all doing it every day we just
don't think about it too much and the
neat thing about the cake pattern is it
allows us to exploit this concept in a
really interesting way okay
it allows us to take this concept of
information hiding by existential 'ti
and and use it to actually have more
powerful modules than what you could
have otherwise and that's really what
the cake pattern is about modularity so
modules the essence of a cake pattern is
a module a trait is a module so for the
rest of the talk we're going to assume
that we have transcended the realm of
packages because packages are terrible
and nobody should be using them anymore
traits are much much more powerful
because they're composable and they're
controlled packages are just a fancy way
of sticking prefixes on your names
they're not really a very good tool for
programming so traits traits are true
modules traits allow you
unlike packages to have explicit type
checked dependencies okay we like to
think that packages give us type check
dependencies because if we fail to
import something we get an error but the
thing is that we can't look at the
outside of a package and see all of the
things that were imported
we can't compose the this package with
some other package and change what was
imported inside of this original package
if it was imported in a specific way we
don't really have that option
having dependencies explicit with traits
as modules gives us that kind of
flexibility gives us that kind of power
traits also give us a complete
encapsulation ok we can hide things
inside of traits not only method
implementations but also type
implementations ok we don't have to
expose even the details of the fact that
there is a valid type for this
particular thing for this thing this X
that we're working with and we're
passing through our bippy function right
we don't need to expose those details to
the consumer because the consumer of our
API doesn't need to know
right if why would they care what our
implementation type is if you know
they're they're not going to be looking
at that implementation anyway so we can
just hide it from them it allows us a
far far far greater degree of
encapsulation than you can get with
traditional packaged stuff and I really
think that using using traits in this
way is how object-oriented programming
was meant to be used in a language like
Scala ok now we all know the benefits of
functional programming and I I tend to
program in a highly functional style
using very you know sort of Haskell ish
abstractions and whatnot that's great ok
and that's really important it has its
place but for organizing big giant
blocks for organizing things that are
logically modules I turn back 200 and
from oh oh we can get the cake pattern
and it's really really really nice to
work with in practice I've done it on
too large code bases now and there have
been problems but overall it's been a
phenomenal
positive experience so I like to think
of the cake pattern or rather the the
process of deploying the cake pattern as
it were in your code base in three
stages okay so stage one this is sort of
the the intro baby steps into the cake
pattern number one split your code base
into top-level traits okay the general
rule for this is is every single file
should basically have its own trait but
it's just everything in that file indent
it one more level throw a trade around
it call it a day that's that's basically
the first thing you do and this even
that simple step actually gives you a
lot of benefits because in order to
access the stuff that's in file a you
need to mix in it straight into file B
so now you have an explicit documented
and type check dependency between a and
B whereas previously that dependency was
implicit so you've already gained a lot
just by doing that so if you think of
traits in terms of modules then your
import mechanism is extends and with
okay so it's the inheritance
it's the inheritance hierarchy that
you're using to do this one of the nice
things about this is unlike with a
normal file you can actually use bare
functions inside of a trait because
they're not really bare they're
technically members but you don't think
of them that way because you're always
inside of your your cake so using Bare
functions is sometimes really nice
because there are times where it just
doesn't make any sense to put this
function inside of a class because all
you would be doing is wrapping the
function so you can get around this kind
of this weird quirk in the way that the
JVM works and inner objects are very
important to remember and I'll point out
why this is in a second but you
shouldn't you shouldn't feel like you
have to have everything at the base
scope of your trait all right
sometimes name collision happens name
spacing still has its purpose and we'll
go into that in a second so what does
this look like okay user module
all right user module has two functions
inside of it and the class we just
tossed it into the trait everything is
inside here you could very easily
imagine this have just
being inside of a file well I'm with the
exception of the bear functions and you
know that's how you might have organized
a code base without the cake pattern so
we have our user module and everything
is concrete despite the fact that it's a
trait we don't care
traits traits allow us to do that sort
of implementation thing and then we have
a message module that uses user module
it imports user module and message
module apparently does things with users
I guess as the the author of a message
or something like that so that's that's
kind of cool we've brought that in we
didn't have to use import or any sort of
implicit dependencies it's all up there
in the type signature and at the end of
the world when it comes to put these
together we're guaranteed to have both
of them but we're already running into
problems specifically right there they
save function if you remember back to
the previous slide user module also has
a save function and the the compiler is
gonna be able to disambiguate them
because the parameter type is different
in this case message as opposed to user
but that's overloading and that's weird
and terrible and an awful holdover from
the days of C++ we shouldn't be doing
that if we can avoid it right so rather
than overloading the save function which
is really unnecessary and gratuitous
what we can do is we can take these
functions inside of message module the
things that are logically relating only
to message right so render message save
message that sort of thing we could just
push them into an inner object this is
namespacing now like five minutes ago I
said that name spacing was really bad
because all you're doing is just adding
prefixes to a name and that's true it's
bad if you're using it to implement
modularity okay name spacing is not
modules name spacing is avoiding name
collision and that's precisely what
we're doing here we have a module we
have a mechanism for doing modularity
we're not using this inner object
message as a way of having a module
instead we're just using it as a way to
disambiguate this is the render function
specifically pertaining to messages so
this is a really really really good use
of object and one of the nice things
about this is that unlike packages
objects are actual things okay they're
objects you can put them in vowels you
can rename
you can carry them around you can pass
them along it's they behave just like
everything else in Scala so by using
objects rather than packages we're
actually getting away from one of the
more peculiar dichotomies inside of
Scala held over from the JVM and the way
that the JVM works so that's stage one
okay and the way that this the story
usually works is you go through your
code base you implement things in this
way life is wonderful and happy and then
you start running into problems okay
one of the problems you might run into
is testing a lot of people like to test
things apparently unit testing is good
and it's as we all know it can be very
difficult to test some sort of
high-level module that's using a couple
of other modules underneath it where
maybe one of those modules talks to some
remote service or does something really
complicated and you don't want to test
that module you want to test the
higher-level module instead so we get
into mocking and things like that and
anybody who's done mocking in a
large-scale system with maybe spring or
some other dependency injection
framework knows what a pain that can be
the cake pattern gives us a really
really really nice way of doing this as
you would expect remember we're working
with traits our modules are traits we
can just as easily make our functions
inside our traits abstract we can have
abstract functions inside our traits and
then concrete implementations somewhere
else
and our modules that depend on the
module that we care about can depend on
the trait that has the abstract form
rather than the concrete form this
allows us to create multiple concrete
forms not only one for our production
system but also maybe one for our dev
system and one for our test suite and
one for whatever it gives us all of that
flexibility the Precog code base is
exploiting this to the enth degree it's
it's crazy how much we're doing with
this we can swap out our storage
back-end just at the drop of the Hat
because it's very very very well
modularized and it's done using this
trick so make your functions abstract
okay um I still when I'm building a new
module I start with a concrete function
but I very very very quickly move to the
abstract form the
or interesting point on this slide is
not refactor your functions to be
abstract but refactor your types to be
abstract okay you don't have to settle
for concrete types this is the beauty
the real real beauty of Scala's abstract
type mechanism we can actually abstract
over our types in a way that you cannot
do if all you have is a package okay and
this is a really really really
interesting concept so all of you out
there who are yearning for the good old
days of gee baby oh I know there's at
least one of you this is how you get
virtual classes in Scala and it is just
as powerful as you would expect it to be
type bounds type bounds are really
really powerful you can use them to
successively refine your abstract types
and basically have virtual types where
the definition is split across multiple
modules which is pretty cool lifecycle
management this is a perennial problem
with the cake pattern okay you have a
module more importantly you have several
modules and you know because we live in
an impure universe those modules have to
set things up okay when they start they
have to have some sort of startup
routine they have to generally side
effect it's terrible and when they're
done they have to shut themselves down
okay this is a really really really
important thing and people start out
with the cake pattern by throwing this
set up logic inside the Constructors
which is a disaster like do not ever put
side effects inside of trait
constructors you will want to kill
yourself
it's terrible rather than putting it
into constructors there's a different
way we can do this using what I believe
our team are called the stackable traits
pattern okay which is basically the most
misunderstood modifier in the entire
Scala language and we'll get to what
that means in just a second so coming
back to our user module let's see how we
would progress through this second stage
okay
so we've got our user module and what
we've done is we've made the login
method and the save method abstract so
now we no longer have the details in
this user module of how login works of
how authentication or anything like that
works it's
the abstract type signature it gives us
the function we can work with it but we
don't know we're not tied to whatever
details of you know the auth back-end or
any of that stuff okay and then we could
have maybe an implementation on top of
MongoDB or something like that that
actually does the authentication and our
message module okay
the external module is bringing in the
abstract user module we never ever ever
ever ever want to depend upon the Mongo
user module we want to depend upon user
module because user module gives us only
and exactly as much information as we
want remember this comes back to the
essence of modularity information hiding
we want to hide the details of MongoDB
and all of its stuff we want to hide
that away because message module doesn't
care it only cares about login and save
so I mean that's that's that's great but
what if we wanted to have our save
function on the user object right we are
technically in an object-oriented
language rather than having a save
function that takes the user we could
just have the save function be a no art
function on user itself returning unit
because we side-effect like a boss so
this is this is cool but unfortunately
it's not really it mates breaking our
abstraction right user module here
remember is the abstract form if we had
looked at the code that I alighted there
it has a abstract login function okay
totally abstract the details of how to
save a user are not in this module so we
could a do some absolutely terrible
inversion of control thing and have like
a protected abstract function that
actually does the saving work that we
sort of stuff in user module and then we
delegate to that from save that is a
terrible idea we don't have to do that
rather than doing that what we can do is
we can make the concept of a user
abstract so this is a really interesting
thing it basically looks like this we
have an abstract type user which is
constrained to extend user like and then
user like is a trait okay this is the
abstract class that user that basically
defines
the signature of user and apparently
users have an ID and a name and they
have this safe function and you'll also
notice user like has a self type it's
constrained to be a user that doesn't
actually matter in this case because
none of these functions are implemented
but if any of these functions did
something like return this then we would
really need this so just get yourself in
the habit of doing this anytime you do
virtual classes and then finally down at
the bottom we have an abstract
constructor for user that takes an ID
and a name and it returns something of
type user this is really interesting it
returns something of type user user is
abstract so people can use this module
they can bring in user module and they
can actually work with the user type
without having any idea what its
implementation is not only not knowing
what the implementation of its methods
look like but not even knowing what the
actual implementation type happens to be
all that is hidden we have abstraction
at the method level we have abstraction
at the type level and this is so
powerful very very very very very
powerful when we go to implement this
it's pretty much what you would expect
we have the Mongo user module and it
just defines a class user okay it
extends user like does its thing defines
the constructor and away we go
and this is sufficient to implement the
virtual class it actually finalizes the
virtual class in the hierarchy so this
is the implementation when you have a
Mongo user module but you never have a
Mongo user module all you have is a user
module so you're working with user in an
abstract form so this is this is really
a very very interesting bit and we start
to see how this is getting closer and
closer to that existential type concept
that I talked about at the beginning
where we're hiding information not just
hiding it by you know shoving it over
here or putting in a closure or
something like that
we're actually hiding it at the type
level in a way that is type constrained
and we can talk about and we can reason
about very very very very powerful so I
promised to talk about lifecycle
lifecycle you know you can start off by
having this very simple concept here ok
we have the lifecycle module that has a
start up in a shutdown method ok this
seems fairly reasonable and the concept
that we're going to go for is any module
that needs to have a start up or shut
down routine is going to have to
implement these functions so rather than
putting that logic in something like the
constructor or heaven forbid the
finalizar we're actually going to put it
in these functions that we have some
control over it the problem is we may
have multiple modules that have set up
or teardown routines right
we don't want each module to have to
delegate to every other module because
that's a ridiculous amount of tangling
what we really want is we want to
somehow say hey I have a startup routine
I want to do some thingy but as part of
the startup routine I want to start up
everything else that wants to be started
and I don't care what that everything
else is I just want to do it okay this
is the purpose of the abstract override
modifier okay I don't know about you but
when I when I was reading the Scala spec
and I found the fact that you can use
abstract together with override I
thought it was a typo
this doesn't make even looking at it it
doesn't make any sense to me at all
basically what abstract override allows
you to do is access the super pointer
which is not really a pointer it's just
a namespace thingy but whatever it
allows you to access super inside of a
trait so this is this is our team is
stackable traits pattern basically what
we're doing here is exactly what I
described we have some init Mongo thingy
function which is a you know hidden
inside of the Mongo trait hopefully
hopefully private and that init Mongo
thingy function is going to happen as
part of the startup cycle but the other
thing that happens as part of the
startup cycle for this module is we
delegate to the startup cycle for every
other module in the known universe and
the same thing for shutdown so this
ensures that we can compose together our
modules we can put them together and
they can all have their own life cycle
that gets started at the same time and
shutdown at the same time the only thing
that is a little bit tricky about this
is the exact order in which these things
is are run is not non-deterministic but
you should treat it as such
okay it's basically going to depend on
how the cake was put together whether
Mongo module came before message module
or after message module in your with
clause right because that is actually
order dependent so that is going to
determine the order your module started
so it's very important to remember that
you shouldn't have dependencies between
life cycles startup and teardown
routines okay if you have a module that
needs another module to be started
before it starts you have to start
factoring things out in other ways
you can't just stack them together and
hope that it's going to work but in
general most modules tend to be fairly
self-contained and this sort of
stackable life cycle pattern actually
works really really really well
so that's that's basically stage two
okay and once you get your codebase to
this level things are actually in a
really good place it it actually takes
you a really long time if ever to start
running into problems with the cake
pattern in this form okay this is this
is in general most of the tools that you
need but some code bases are a little
bit more advanced and/or have really
pathological needs and that's when you
start getting into stage 3 of our cake
evolution stage 3 is when you realize
that composition is actually pretty good
after all and the age-old advice to
favor composition over inheritance is
might be correct so inheritance is
really convenient right our mechanism of
import by width and extends is really
really nice
and I'm not telling you to get away from
that I'm not telling you that it has
problems because it really doesn't it
doesn't have any limitations that you
wouldn't expect but there are times
where you need to have composition
basically whenever you have a module
that has some thing that it depends on
but that thing has state which needs to
be shared with other modules ok other
things that are outside your cake or
other instances of that module whenever
you find yourself in that situation you
cannot use inheritance anymore you have
to use composition at some level there
has to be a Val inside of your module
that is another module rather than
bringing it in via width or extents that
sort of thing happen
on occasion you also find yourself very
quickly as soon as you hit that point
you find yourself nesting modules within
modules and this is where things get
really really mind-bending because think
about traits right traits are not like
packages packages if you nest a package
within another package it just adds to
the prefix that it's putting on the name
traits on the other hand are modules
they're true modules and you can still
nest them inside of each other and what
you get is not just more pressing you
actually get more polymorphism and axis
of polymorphism that you wouldn't
otherwise have you can have things like
independent life cycles this way so you
have an outer trait an outer module
rather that has its own startup and
shutdown thing and then inside of that
it has sub modules and those sub modules
may live and die and live and die and
live and die many times over the
lifetime of the outer module that's fine
and you know sometimes you actually need
that to happen in order to do that you
have to nest modules within modules and
like I said this does get a little bit
brain mind-melting so here's here's
where it can start where you can start
to see what this looks like we have a
system okay inside this system is a user
module and we're doing this because
presumably user module is has a life
cycle that is separate from system
module okay and one way to think about
this one metaphor you can use is the
standard metaphor for determining
whether or not to use composition or
inheritance is a system a user well not
really so rather than having system
module bring in user module via
inheritance we can bring it in via
composition in this way so Val user
module and this is going to be defined
at some point when we put the cake
together we can also just do this via
standard sort of function application
take it as a parameter it comes down to
the same thing right it's just here we
don't actually have a reference to it
all over the place and continuing on
with this we to sort of see we might
have a storage module okay and the
storage module is part of a system
module right we're still using
inheritance because
inheritances it evil it's it's still
very nice and convenient so our storage
module defines some abstract functions
store and retrieve and presumably will
define a concrete implementation of this
at some point the problem is that we
want user module to be able to access
storage module okay if you remember one
of the things that user module has the
ability to do is save a user it also has
the ability to login I mean that really
implies that you have to have some
access to the storage module well that's
a problem if you want the system module
to be independent in terms of life
cycles from the user module because if
you cake them together if you just
naively make them all inherit together
then you're tying their life cycles
together and they can never be separated
again so what you do is we act er user
module ok user module has now become
user module module because names are
hard and user module module contains a
user module the interesting thing is
that user module module is what extends
storage module ok this is where you
bring the storage module into the cake
so that user module can work with it and
then user module itself is independent
you can start it up you can shut it down
you can create any number of these
modules just pass them around like
normal objects because that's what they
are and all of that works the way you
would expect so this is basically what
I'm talking about when I say that traits
make modules first-class because they
actually take modules and make them a
thing that you can get your hand around
and you can create them and you can
destroy them and you're gonna have
parallel modules that live next to each
other inside your object hierarchy this
is a really really really valuable
property of the cake pattern and it's
something that is completely out of
reach if all you're using our packages
or objects so this is great this is
really really great the benefits of this
are profound and and hopefully they're
starting to become a little bit more
real the there are unfortunately some
problems which arise when you do this
it's you know many of them are just
artifacts of the fact that we are
sitting on the JVM and it's it can be
annoying
here is a classic example of a problem
which can arise how many people see the
issue here okay what is this program
print no it doesn't it doesn't throw a
null pointer exception because any two
string rath are actually does it does
null checking so this actually prints
null world and bar the value of bar is
null world it's not hello world which is
really really really strange and this is
just like very unintuitive because
everything in here is a Val right
nothing's being reassigned
there's no point theoretically where we
should be able to observe a lack of
value here the problem is we are sitting
on the JVM okay and Val is an eager
construct
so basically Scala is making a hard
guarantee that when it hits the Val in
its execution path okay and it's going
to hit that Val in the constructor for
the trait when it hits that Val it will
be executed regardless of the state of
everything else in the universe
regardless of what things that valve may
or may not be using and whether or not
those things are available you can
actually see this problem in Java as
well and it is the source of perennial
threads on Stack Overflow because people
just find this very confusing basically
what's happening is the constructor for
C the class is running okay and the very
first thing that constructor does is it
delegates two A's constructor all right
delegates to a is constructor ace
constructor doesn't have anything so it
delegates to Bea's constructor
now Bea's constructor has bar and this
is where the problem is bar accesses foo
and concatenate sit with the string
world foo has not yet been created
because C's constructor hasn't run yet
C's constructors in the process of
delegating - it's super constructors the
super constructor delegated back down to
some state that's set up inside of the
sub constructor and that's where you
start having problems so this this
arises astoundingly frequently when
you use traits and since the cake
pattern is all about traits yeah you're
gonna see this a lot
generally speaking whenever you have
side effects or eager evaluation which
is another form of side effect so yeah
this is an initialization order problem
in most often it shows up as a really
strange nullpointerexception
a nullpointerexception that's happening
in a part of the code which cannot
possibly have a nullpointerexception
when the laws of physics appear to
evaporate suspect initialization order
that's that's really the general rule
that I can give you
unexpected JVM zeros in general like
it's not always know you could have
false or you could have zero right if
it's an inter along those sorts of
things just pop up and you have to deal
with them it's very strange and very
difficult to debug and sometimes it can
just tie you in knots trying to figure
out how to linearize your hierarchy in a
sane way really just any time you see
behavior that you can't explain so there
is a very interesting bug in the curl
parser inside the Precog code base that
I have yet to explain and basically
there is a vowel which is not abstract
it's inside of a trait but it's not
abstract it's not inherited it's just a
Val it could for all intensive purposes
be a private Val and I think it may
actually be now if I keep that as a Val
even though it's never used in the
constructor never access to the
constructor hierarchy the parser doesn't
work it doesn't crash it just parses the
wrong thing I have to make it a lazy Val
in order to make the parser function I
have no idea why this would be the case
absolutely not it doesn't make any sense
to me so basically just the solution to
this in general is you throw up a death
instead of a Val or you use a lazy Val
and lazy Val makes it late makes your
eager now evaluation a lazy evaluation
and and kind of gets around that problem
you need to be very very careful with
this so okay there's a there's an
interesting problem hidden the Scala
compiler itself Scala sees source code
where they're using the cake pattern
okay they design their cake a long time
ago before the community kind of built
up all this
wisdom about the cake pattern but it's
still you know the essence of it is the
cake pattern and they have a lot of
symbols that our pointers that the
compiler needs to know about the things
like what is the name of the class
object what is the name of the class
string what are the boxing classes for
integers and bullying's etc right the
compiler needs to know about those
symbols internally so it needs to have a
giant trait that has all of those
symbols the problem is that the notion
of a symbol is something that's defined
inside the scala c cake so you can't
create those symbols without the cake
being set up
so Scala C actually has a trait that has
literally hundreds of lazy vowels inside
of it and until they made those lazy
vowels eagerly eagerly populate
themselves by using a special function
that they called the the initialization
time amortized over all of those lazy
vowels was in the tens of seconds it was
insane absolutely insane so lazy val is
a real performance problem if you care
about performance at all don't use it in
a hot path and if you care about your
sanity don't use it if you can avoid it
the problem is that the cake pattern
makes it really hard to avoid so use
death if you can use lazy Val if you
have to yeah I don't know there's no
good answer to this so this is basically
the modification that we make we make
fool an abstract death we make bar a
lazy Val and this problem goes away
here's another good one there's actually
no code on this screen so there's no
real problem here and the reason is that
I haven't been able to minimize this bug
at all but it seems to arise when I have
situations like this basically what
happens in situations like this some of
the time is you have initialization
order for these constructors for like
the foo the more dot foo constructor and
the more dot Baz constructor sometimes
if they depend on each other or one
depends on the other you can actually
get a deadlock in a single-threaded
program initializing this code it's it's
mad insanity I have no idea what's going
on here basically the problem is that
objects stuff and
object more their objects so they have
locks inside of them that are used to
linearize their construction right
because objects are Singleton's so they
have to have locks inside of them
otherwise if you create them
concurrently you could end up with
multiple instances so those locks can
sometimes get deadlocked with the locks
of the inner objects inside of them
depending on the order that things get
accessed in and this can be a real real
hair raiser
it happens a lot when you have objects
within objects within objects between
objects especially if there's a lazy
battle sitting at the top so this this
has bitten us a few times basically the
way you recognize this problem deadlocks
seems obvious just do a stack dump if
you see a deadly if you see a deadlock
in your program initialization
especially if it's a non-deterministic
deadlock in your program initialization
you might have a lock order issue with
your objects very very very peculiar the
solution Val instead of lazy Val yeh
Scala you just you just have to be
really careful about which one of these
you're using in general lazy Val is the
right thing to do because it avoids the
omit order problems but it creates an in
order problems with the locking because
lazy Val is just like object so base the
the trend that we have followed in using
the cake pattern a Precog is we we start
off with Def and then when we discover
that creating a bazillion of these
things is a bad idea we move to lazy Val
and then when we discover that things
are getting deadlocked on this
particularly lazy Val we move to Val and
then we discover that that val is null
sometimes in the initialization pattern
and then we cry and generally move back
to lazy val very carefully so it's this
it's this horrifying horrifying cycle be
very careful of these two these two play
off each other in horrible ways
basically they know the transformation
is is trivial
other issues you're gonna run into using
the cake pattern compilation time sucks
this is true of Scala in general it's
more true if you're using the cake
pattern the Quirrell compiler
was at 1.9 source files that took three
and a half minutes to compile yeah SBT
is great okay if it were not for the
incremental compiler I would have wasted
man years but sometimes like even SBT
can't filter all of this stuff out and
it has to recompile the universe and it
can be terrible compilation bugs
surprise Scala see has bugs in it and
you will hit a lot of these bugs when
doing really dodgy things with the type
system where dodgy means more
complicated and existential the
presentation compiler is a really big
offender here presentation compiler
still does not work correctly with the
cake pattern so if you're using enzyme
put it on the shelf because the cake
pattern is going to destroy your type
errors the not presentation compiler
isn't very much happier
sometimes I've gotten type errors that
are just utterly bizarre and and
sometimes you just have to work with it
SBT also has some issues with this I
think they have been resolved in more
recent versions of SBT but in SBT ODOT
11 there's this really hilarious problem
where incremental recompilation of
things that don't need to be pretty
compiled can sometimes cause them to
change or can sometimes leave stale
class files lying around that then get
caked together and don't break but cause
your program to have the wrong semantics
which is the best thing ever right you
you run your program and then you get
the wrong answer and you're trying to
figure out why and it just turns out
that you had stale class files really
bizarre finally Scala doc is is yeah
Scala doc doesn't deal with the cake
pattern very well so if you care at all
about API documentation this is this is
something to be aware of so I have some
slides that that dig into best practices
and things that I think are important
but I think we're running short on time
so I'd rather open it up for questions
at this point so the question is do we
use packages at all or do we just have
one big flat one and the answer is yes
we do use packages we use them as named
prefixes so
it's just it's easier to organize things
yeah you organize the modules themselves
using packages because I don't know then
your namespace is a little cleaner when
you're trying to take things together
and I think we could very easily do
without packages and it wouldn't be too
much of a big deal so I'm not using
self-types I'm using extends the reason
for this is extends is a lot more
controlled extends in with you actually
have a sane ordering you can actually
put things together in whatever order
you want I was talking with Roland about
this earlier today actually self-types
cell types have a tendency to to put the
thing you're extending first which can
mess up your linearization and can make
things a little bit surprising sometimes
in the order that they're put together
there's also the fact that with
self-types you really can't have more
than one so it'll self-types only make
sense when you are trying to say I am of
this right I'm always going to be of
this and this is the one thing I'm going
to be so I used them with virtual
classes because I think with virtual
classes they semantically make sense but
for actual caking of things together
I think extends and with are more
powerful and more controlled so have we
thought about using abstract classes and
early initializers to to solve the
problems of initialization answer yes
and we do and I didn't have time to talk
about it
yeah so that that's like the that's like
the nuclear option to this is take your
trait and turn it into an abstract class
problems with Scala c29 or 210 right now
the Precog code base is on 2 9 3 or
whatever the latest is we haven't
upgraded to 210 yet I have seen a lot of
these issues with 210 when we find bugs
what we try to do is we try to minimize
them so that we can know what to do
within our code base and then I 10 I try
to take it against the latest master of
Scala C and reproduce it as well most of
the bugs that we have run into have been
reproducible against Scala 210 though
some of them under fix now the
initialization problems to performance
problems the locking problems are
identical between objects and lazy
valves that is correct which is why that
slide is so hilarious so to get around
the the earlier net problem you have to
use lazy valor object but to get around
the locking problem you has to use valve
so
they are in conflict and sometimes that
really ties you in circles okay thank
you very very very much for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>