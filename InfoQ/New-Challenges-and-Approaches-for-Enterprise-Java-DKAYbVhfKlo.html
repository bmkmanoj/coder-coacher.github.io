<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>New Challenges and Approaches for Enterprise Java | Coder Coacher - Coaching Coders</title><meta content="New Challenges and Approaches for Enterprise Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>New Challenges and Approaches for Enterprise Java</b></h2><h5 class="post__date">2012-08-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DKAYbVhfKlo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm going to talk about mutant Justin
approaches for enterprise Java is there
if there are any questions feel free to
ask me that we spend a little bit of
time talking about myself so my name is
Eva hug wolf I'm the I station
technology manager for Edison at this
was an IT consultancy in Germany you can
probably tell by my English that i'm
from germany as I'm speaker I wrote the
first German spring book and her other
books mostly German I do have a block
which is in English I i'm on twitter
almost all of the tweets are in English
presentations also all of them in
English and there is an email address if
you want to reach me ok so what we are
going to talk about is what I'm going to
talk about is which challenges I see for
enterprise Java in general and which I
think solutions we have for them or
answers where for them so let me start
by talking about why I think this
presentation makes some sense Java has a
broad support in the industry and in
particular in the enterprise there is a
lot of Java being used at the same time
the world is changing so there are no
sequel databases there is the DevOps
movement that joins development and
operations there is the cloud which
seems to change quite a few things and
if you look at in particular startups
and what they are doing they are using
those technologies so I think in the
traditional enterprise space there is
something to be learned from those
startups and also if you look at it
quite a few of these things are tied to
technologies that are not ready Java
like Ruby for example so the question is
what is the impact of this whole thing
to ask s enterprise Java developers
this is sort of fun well it's sort of a
silly slide so I mean what is java so if
you look at it there is the language
there is a programming model college ave
e for the enterprise there is there are
web servers or service in general and
there is the JVM i think the most
important part of the soul java
ecosystems are the service and the JVM
the reason for that is because they are
ubiquitous and also the JVM is well
optimized so if you look at the
competitive advantage compared to other
ecosystems I think it BOTS down to the
ridge of the fact that service
java-based servers are everywhere and
that is also why programming languages
like corrosion for example are running
on the JVM and don't don't invent their
own virtual machines so like all these
new languages and like all the other
things that are going on there I think
the enterprise developers also have to
ask themselves how they can leverage the
this ecosystems in the best way yeah
this is all subjective these are my own
opinions and it is obviously how to
predict the future so this is just my
attempt on doing so so let's start off
by taking a look at the traditional web
applications that we are probably all
used to so if you look at them the way
they work is there is a browser that
talks HTTP air to a web application
server and then HTML is generated on
that web application server and then
there is a database or some back-end
systems that you talk to using jdbc or
web services or whatever there is the
role that trauma place in this game is
that it renders the HTML so there is a
lot of logic that just takes the stuff
from the database from the back end and
run as HTML out of that implemented is
this using sir floods so the model used
is the software model it uses the thread
pool and if a new request comes in a
threat is taken from the pool the
request is soft worked on and then the
HTML is generated and returned in
software 3.0 it is possible to suspend
and resume handling of the request the
reason is because that way you can free
some resources while suspending the
operations on the request so that more
requests can be done in parallel and
threats are not hanging around they're
being blocked by io instead they will be
suspended for the time di o takes
however that is not too easy so you
actually have to call a method on the
request to suspend the work on the
request okay now there are new web
applications and if you look at them
they are quite different so what we are
seeing there is a browsers that does the
HTML rendering implemented in JavaScript
these are the famous one page
applications where you have a JavaScript
application framework that talks to some
no sequel databases for example using
HTTP and rest so there are no sequel
databases that just return the data in
J'son which can easily be used by the
Java Script system in the browser and be
rendered into HTML this used to be
something that you would do on the
server side using Java the other thing
that is happening is that there are
other back-end systems that are still
implemented using Java and they talk to
the to the front end using rest and HTTP
which is actually quite similar to the
model that you're used to because the
model that you're used to using circlets
does the same thing so there is HTTP
there is stuff returned and speaking
rest over HTTP air with let's say
Jason's not that different from what
HTML does however there are also web
sockets that's a new protocol
so that allows you to do communication
in both directions from the client to
the server in the other way around for
real-time updates for example and this
is actually a new challenge so we will
talk about that in more detail the web
or application server is has a pretty
reduced role in this setting because all
it does is it just returns basic static
HTML the JavaScript code and that's it
so there is no in the most radical form
there is no logic implemented on the web
server anymore it's all done in
JavaScript there might still be logic
and then you would have a hybrid between
this model and the the old model but
generally speaking that's not necessary
so the new thing here in the new
technology here that is that matters our
web sockets and if you look at it the
other thing that is also happening is
that there is more logic in JavaScript
so that means that stuff that you would
otherwise right in Java is now done in
JavaScript web sockets is also
interesting because there is not no
standard yet so if you look at Java EE
and the standardized Java ecosystem it
doesn't really have an answer to that at
the moment and the other problem is the
software model won't work for web
sockets the reason is because in the
WebSocket space every client has its own
connection and if you use the software
model that basically has one thread for
each connection you will have an
enormous number of open threats and open
connections and that it's not really
possible on a server so what you need to
do is you need to somehow work as I'm
from Ashley's first of all you need to
be able to handle more than one
connection using one threat because
otherwise you will have the number of
threats will be too large and the other
problem is that if there is some IO
going on and the threat is blocked
then that might have severe consequences
because one thread is responsible for
quite a few clients and all these
clients would wait for the threat to be
freed and do its work so that means that
the added synchronous behavior that was
added to surf let's shouldn't really be
an afterthought it should be baked into
the model firsthand and it should
probably be used throughout the stack
because if you do some I oh so you're
good to the file system for example you
it is not you shouldn't block the
current work on the current web socket
instead another web socket should be
served while you're waiting for the i/o
on the file and so on so you should have
non-blocking i/o as in from the parking
zone there is a way to do that or there
is a model that is quite a good fit for
that the actor model the idea of the
Metro model that is implemented in Scala
for example but also in other languages
like Erling basically says there is a
single threaded actor that also
encapsulated the state the benefit of
this model is that there is just one
thread working on the state so there is
no concurrent access to state so there
is a lot less problems concerning
concurrency the other thing that happens
is that this actor receives messages and
sends messages and these messages are
queued up so what you can easily do now
is you can use this model to work with
WebSockets so let's take a look at the
actor model more detail it's quite a
nice one for developers because all they
see is a single thread or model which is
nice it's not hard to reason about it
concurrency solve by running multiple
actors in parallel so that's how you get
concurrency in them by just executed by
hair just having more actors so for
example one actor for each client when a
message is received it will
at one point be handled so that's a
synchronous there is no waiting no
synchronous communication to the outside
instead msgs handled and at one point
and answer sent out so you can run quite
a lot of actors you can have one thread
serving multiple actors and working on
quite a few message queues models that
are frameworks actually implement that
is for example occur which is based on
Scala the other framework that is
probably not too well known is vertex
vertex is actually I think quite an
interesting technology so we are going
to talk about I'm going to talk about
vertex in quite a few places it is you
can think of it as a sort of a clone of
the ideas in nodejs so as acronis
behavior as acronyms programming model
and i think it's quite interesting as we
will see later on because it actually
takes it to to quite a distance ok so
that's the actor model and they are I
believe they are quite a good foundation
for web sockets because what you can do
now is you can just have one actor for
each web socket and they are only they
only do consume resources when a message
arrives so when there is the threat the
CPU is only really executed and used
when there is a message that needs to be
worked on I think this might actually
quite interesting because so far actors
have really had their strength in areas
where there is a lot of concurrent
processing that needs to take place and
in particular in the enterprise space
I'm not sure whether there are a lot of
applications that actually have a need
for these kinds of parallel processing
most of the time the the enterprise
application said at least I know are
concerned with transform
main data handling HTTP requests and not
with complex calculations that need to
be paralyzed so I believe that actors
are a good fit for the WebSocket model
and for that reason they actually might
add some value here to web frameworks it
might be become much more popular
examples of that are the play framework
again using archive for web sockets and
again the web vertex framework which
uses its own xlite model to also handle
web sockets so to sum up more of the
logic more of the HTML rendering is done
in JavaScript instead of Java I believe
the important new technology that might
impact the Java world are web sockets
because if you look at rest web epic
ends that's not too different from what
we are used to it's just that we are
rendering JS instead of HTML or XML or
whatever but web sockets are different
I'm not sure how important they actually
will be because the the big benefit of
web sockets is to have communication in
both directions so basically the
question is how many applications are
you going to implement in the future
that actually have a solver talking to a
client and pushing data from the server
to the client if that is the case then
you will probably go for web sockets and
then you will probably need to have a
different programming model because web
sockets are hard to air support using a
model that is in it that is inspired by
servlet and I believe actors might be a
good solution for that so that's I think
the first thing concerning HTML and web
applications there are other more
general issues if you look at the Java
EE model I mean what has been criticized
in the past is the programming model and
the Java EE model has learned from that
and has pretty much
improved programming model down however
there is also the development model and
the original plan for java enterprise
was to have one Java EE server that put
serve multiple applications so in my
case there is one job eserver and there
are three applications running on top of
that and that is if you look at it what
was originally intended with Java EE
however if you look at the real world
today what you usually end up with is
quite a few servers serving the same
application so it's actually quite the
opposite the reason is you want to to
use a cluster for load balancing for
easy scaling out for high availability
and so on and you can sort of saturate
one server already with one application
there are other issues and so the Java
EE model it tries to isolate the
applications because each application
has its own class loader so there is no
way that the applications can see
classes from one another so in that
sense they are isolated however the
problem is that it's only the classes
that are isolated from one another so if
the application server for example does
garbage collection then the performance
it will be taken by all applications so
they will all stop so that means if you
talk if you talk about memory and CPU
actually the applications on a Java
server are not isolated from one another
and that's a problem because there is no
way that you can it doesn't make a lot
of sense to run several different
applications on the same server if you
can't really isolate them because if one
application goes nuts then it hits all
the applications so the isolation in
Java EE is sort of half-baked and the
problem is that this half-baked
isolation leads to
other problems so if you look at it we
all know materialization is a good thing
so we want to apply that to Java EE and
let's assume that we want to deploy
those modules independently so the idea
is there's some piece of logic that is
shared by multiple applications and this
piece of logic needs to be updated
independently from the applications
because you want to well simplify the
process and so on and so on that is not
possible because models modules cannot
share classes because they are isolated
from one another the only exceptions are
ear files so in an ear file you can have
several modules and those modules can
share classes with one another but then
you still haven't solved the problem
because these individual parts of the
ear file cannot be deployed
independently so what people usually end
up with is a system that uses the web
services anti-pattern i called it so
what they do is they create a system
like this where there is an application
that talks soap to some module and this
module again talk soap to another module
all the modules are our war files and
they can obviously be deployed
independently because while deploying an
application or a war file is of course
very possible however here it is a
complex and inefficient model because
what you do is you are talking over HTTP
/ soap / XML or to some other system
running on the very same machine and you
could easily have a local call instead
which would eliminate the XML handling
as well as the HTTP and would therefore
become be much less complex and also
much more efficient
and so this is not really a good
solution this is an anti-pattern because
there is so much performance that you're
losing them okay so we need to have a
solution for that there are other
problems as well so not too long ago I
was sitting next to a guy in my company
and we were trying to solve a problem
and what happened was that we changed
some code we compiled the classes an
unscripted and it zipped together
warfare that warfare was deployed then
the war father was unzipped and so on
and so on so basically what you're doing
is you're zipping the whole thing in a
war file you're deploying it and you're
unzipping it again almost immediately so
all you're doing is you are heating up
the CPU and that's it and it doesn't
really solve any problems it's just a
waste of time and that is actually quite
unfortunate and the reason why this is
happening is because the java is
specification doesn't really talk about
an easier model for deployment you could
which is again sort of strange because
if you look at jsps i mean one of the
original reasons for jay's piece was to
the ability to change code in the JSP
and get immediate feedback I will
somehow this was was lost later on with
packaging warfighters on there are
solutions to that so there is aj rebel
that allows you to to deploy new
applications or new classes on the run
while the system is running without
shutting it down there are solutions
like plague rails or the maven tonk
maven thumka plugin that sort of tries
to solve the problem in specific
circumstances so they have their own
environments that are specifically tuned
for development however there is no
general standardized solution so there
is no common solution for all the web
servers and
believe this is quite important because
there might be quite as a productivity
gain because you get a much faster
turnaround time so this independent
deployment is actually quite a
significant point and as I said earlier
there are issues there I think again
actors might be the solution there
because if you look at it actors already
have this message queue where queues are
piled up and the only thing that you
need to do is you need to have a way for
those actors to work without any shared
classes now that's not too hard and we
already know the solution because that's
what also what we are doing in this Web
Services anti-pattern instead of using
shared classes we use a different
mechanism or a different data modeling
like Jason for example or XML again
vertex m has a solution like this built
in so what it has is there is a a bus
that you that can exchange messages and
you can use Jason as a payload and then
you exactly have your ex exactly ending
up with the model that I'm proposing so
a model where there is a data model s
Jason so there are no shared classes and
all the communication is asynchronous so
even if you if you rip out the receiver
of the messages the system will still
run because the messages are just piled
up and as soon as the system comes the
the the actor comes up again it will
work again and work on those messages
that have piled up so that's a solution
however rather well it's it's early for
that solution another solution that
comes to mind is GI it's interesting
because a nowadays jay is actually
gaining traction on the server so if you
look at the most popular job is over
they actually do have support for SGI
and and the u.s. GI solution is probably
the most complete solution however it's
also quite complex the reason why it is
so complex is because Austria I allows
you to reload classes at runtime which
is exactly what I want I want to be able
to redeploy parts of replication so I
need to reload classes however that's
not too easy in particular it's not too
easy when several modules somehow share
classes and it only got it takes you so
far I mean the main it was GI
application these days probably as
Eclipse and when you update Eclipse and
you you load new updates usually you
usually have to restart so it means that
even in this sort of most important
application there is first GI even in
that application it's not easy to
redeploy modules without restarting dual
system so that might be an alternative
and it's actually quite nice that it's
now implemented in quite a few servers
so that's great the other thing that you
can come up with our embedded servers so
the idea here is instead of deploying
the application to the server which at
the end of the day really doesn't make a
lot of sense because you won't deploy
more than one application to your serve
as i said earlier in the most cases you
will just deploy one single application
because you can't isolate more than one
application anyway so instead of doing
that which is sort of pointless because
you're not sharing a server you just
start a java application that includes
the server yeah that might even be
easier so customizing the service quite
easy so it's just part of the thing that
you are that you are giving to the
customer and if there are specific JVM
parameters so it's going to be part of
what you give to the customer so the
shell script that is running to the
application or whatever however again
this is not covered
by standard deployment so send
deployments only talk about war fights
effort files and so on the programming
model will be very similar however this
deployment model using embedded servers
it's quite different and it's not
covered by the standard of course you
can still do it so I think if you look
at it the deployment model should
probably be improved and I think
embedded servers are quite interesting I
will talk about a few other problems or
a few other reasons why I believe this
to be interesting was gie is i would say
complex it is a very it's it's a very
good solution it's very complete
solution but it's rather complex and
there are some alternatives again vertex
as I said Jay rebel it's not a complete
list there might be other technologies
that also solve some problems okay then
there is the famous cloud again the
question is why would I even care so why
is this something that is a Java
developer would care about the reason i
believe is it's much easier to create a
new environment so if you look at the
typical cloud environments basically you
just take the application you deploy it
to an environment and you're done so
there is no purchase for a new server
there isn't you don't really have to
wait for a long time until the
application is there it is just pressing
the button at one point and then you get
the application running the other probe
is the other benefit that's more like a
management costs type of thing you only
pay what you need so you only pay the
resources that you're consuming at one
specific point so instead of buying
server for ten thousand dollars you just
well rent server for a few hours and see
whether it works
and then that's it and it will just cost
you a few bucks so that's great however
there are challenges and i believe the
main problem is that servers can and
will fail so if you look at what we as
enterprise developers are used to we
have this highly available hardware and
server that is failing is really a bad
thing and someone in operations i will
have well we'll have to report to his
boss and answer the question why the
server field and the cloud that is more
or less what is happening all the time
so if you look at the emas own terms and
conditions what they say in a way is if
one of our data center has failed that's
fine and you have to deal with it and i
don't think that's a bad thing actually
i believe it's a it's a good thing
because it will we will end up with ice
textures that are more stable and more
and can deal with individual service
failing the other thing if you look at
it so you're paying what you use so that
means you should only use what you
really need at a specific point in time
so instead of the traditional enterprise
systems where you will just scale your
system to or you would sighs your
servers to the maximum load and the
cloud that's not a good idea what you
need to do is you need to have some
means to scale up and down so that
depending on the load the the right
amount of resources are consumed okay so
what's the impact on Java then well M
the approaches that we need to support
our scale out so we need to start new
servers if there is high load we need to
stop servers when there is lower load
and replication data a replicating data
is also quite important
there are some impacts so if you look at
HTTP sessions for example so in an HTTP
session you can store specific data for
one user that is logged into the system
and and if the server the users
connected two fields then usually the
HTTP session information is lost you can
set up clustering however that consumes
quite a few resources because the
information for the HTTP session will
need to be replicated across to at least
one other server probably also quite a
few more service if you really want to
have high availability and it only
really works with a small number of
servers so I think one of the impacts of
this whole system is that you will
probably end up with applications that
don't really use HTTP sessions and you
need to store the data elsewhere so on
the database on the client html5 local
storage actually gives you a good way to
start a significant amount of data on
the client or you can have alternative
solutions for the HTTP session so one
cloud environment that we are using
internally at adesso we have set up a
memcache d cluster to store all the HTTP
session information and that class is
highly available so if one of the
servers in the cluster fields then the
data has still replicated across to
other nodes and that is plugged into
tomcat as an extra as an external
session storage mechanism so that's an
alternative reason by the way was that
the software that we are running in the
cloud is using the HTTP session so the
alternative would have been to do a
rewrite which we didn't really want to
do so to sum up this case so session
application is not that useful in the
cloud because service might fail and
it's probably better to store your data
somewhere else
and because session application isn't
that important simple service that don't
really support session application or
are not configured to use session
applications are more important or
preferable in the cloud then the other
thing that's like the probably the the
basic thing about a cloud or one of the
most important theories about cloud is
the cap theorem it says there are three
properties that your system might have
so consistency says all nodes in the
system see the same data or have the
same data store availability basically
says you are not shutting down an
individual node and P is partitioned
tolerance so if there is a network
failure the system still runs and what
the cap theorem says is pick any of
those two you can talk about it in more
detail so I could spend probably an hour
so discussing it in more detail but
that's the short version so in the cloud
machines do actually fail there is no
high availability so at one point there
will be a partition so you will have a
system where at least two systems can
talk to each other because there is a
failure of one kind or another so at
that point you either have to sacrifice
a or C so that means at that point you
either have to detect the condition and
shut down one of the systems so you
would sacrifice a am shutting down the
system of course means that you're
sacrificing parts of the availability or
you would still give answers and return
data even though you're aware of the
fact that you can't talk to the other
node and the other node might have
inconsistent data so you would sacrifice
consistency am
why is this important I think it's
interesting because it's actually a
contradiction to what we are used to so
if you look at the two phase commit
protocol and it is basically meant to
have multiple systems and make them
consistent so what the two phase commit
protocol does is it says okay here are
some databases in the first phase i'm
going to ask all the databases whether
they can write the data and in the next
phase if all the systems agree that the
data can be written and is valid the
data will actually be written so the
idea is to coordinate the systems in
those two phases by having a vote first
and then actually writing the data
you're coordinating the systems in a way
that they are consistent however if
during the process your network
connection goes down then you do have a
problem and you are not able to
successfully make all the systems
consistent so that means that the two
phase commit protocol is actually not
that great if it for the cloud because
usually in the cloud the trade-off is
2am be partitioned tolerant and either
sacrifice say C or a but not p because
systems might fail I'm not saying that
it doesn't make any sense whatsoever to
use two phase commit protocol in the
cloud if you have a limited system and
you can deal with failures it might
still be okay but what I am saying is
it's not the ideal system for the cloud
not the ideal protocol for the cloud so
bring that back to Java usually this is
accessed your ear using the JTA API and
the two phase commit protocol in the
implementation of the two phase commit
protocol is actually in my opinion one
of the main differences between Java EE
service and simple web servers like tom
cat why because all the other features
nowadays can be implemented using
libraries so there are libraries that
would allow you to you
eg bees JSF CDI all the nice features of
Java EE however it's different for JTA
there are ways to integrate a two phase
commit protocol in tomcat but that's a
rather complex solution and you probably
don't want to go there also it is quite
hard to implement such a transaction
system correctly because you really have
to make a ballot proof because if you
don't that's the whole reason why you're
using two phase commit protocol from the
start because you really want to make
sure that in a case of an error you
still have transactions and it still
works for you and also it is something
that influences databases and or the
other resources so that means that it is
something that influences the basic of
your error web server it goes through to
all the different resources you might
have okay so that again means that
simple web servers they don't really
implement two phase commit protocol are
a better fit for the cloud because the
leg of two phase commit protocol isn't
that bad thing and there are other
reasons so simple web servers won't
include all the features that Java EE
servers have so you can basically come
up with your own libraries in your own
applications and you will consume less
resources because all the labret set you
don't want well you want include them in
your application and you end up with a
solution that consumes less resources
which is great because all the resources
you're consuming you actually pay for so
these simple web servers like tom cat
and other solutions are actually
preferable in the cloud and if you look
at it that's actually also what people
are doing so tomcat is used in Emma zune
it's also using cloud foundry in Heroku
there is tomcat jet
or a wide variety of embedded other
embedded service that you can use so
play for example is supported there as
well there is an even more a limited
system on google app engine so it's
based on jetty I I think but there is a
white list of classes that you can use
on Google App Engine so it's very
limited implementation of Java cloudbees
offers java ee by profile so that's a a
little bit broader and then there is
redhead and Oracle who offering full
stack Joey so if you look at it there
are quite a few big players like Amazon
or Heroku or Google that actually doing
exactly what I'm what I'm proposing
using very simple web servers in the
cloud instead of full-blown java ee
service because it is it consumes less
resources and the features in the java
ee servers are not that important for
the cloud by two phase commit protocol
so again cloud is also a reason for
using simple web servers like tomcat for
example yam aren't a tendency that's
actually a good point so it's very it's
interesting because if you look at it
there are several different ways of
implementing multi-tenancy so one way of
implementing multi-tenancy is what they
are doing in java is 7 which is
basically storing specific which is
basically sort of adding a hook to your
or our meta and then you say ok if there
is a very you add something to the query
that says only return the data for the
current tenant that's what they are
doing the model here is that you're
running one instance of your application
to support multi-tenancy so you log into
the application to tenants log into the
very same application and they see their
own data that's basically how it works
there are the ways to do that in the
cloud so what you could do is you could
run
virtual machines with two different
instances of the application so one user
from one tenant would connect to an
instant specific to that tenant and the
other user would connect to a different
machine with a different tenant which is
by the way not too too bad I think it's
probably even better it has its
advantages because there is a stronger
separation right basically the only
reason the only way to escape your
machine is by some back in the
virtualization layer which is probably
not there and also it is easier to
separate them again concerning garbage
collection CPU consumption and so on and
for that reason I actually believe that
this situation is probably not going to
change because there is just this one
this one way that mighty tendency is
currently as far as I know to be
supported in java ee 7 and that's just
one way of doing it and in particular in
the cloud there are other ways so I mean
one of the reasons why we introduced
this cloud system that I've been talking
about before is at adesso is because we
wanted to have an even better separation
between the tenants and better service
level that we could offer to them so and
we do that by separating them on the
Virtual Machine level because previously
we we try to do that by my having
multi-tenancy in the application itself
and that only takes you so far ok any
other questions so thanks a lot
okay so that's it so my point was that
if you look at the cloud that's another
good reason for simple web service like
don't get then there is cloud
architecture so again as I said the main
point is in the cloud service might feel
this also has an impact on the ice
texture of your applications so if you
look at traditional at your traditional
application you would probably end up
separating your web server from a
database so that makes a lot of sense
because the characteristics of a
database server is quite different from
the characteristics of web server
because well there is more I owe more
disk and so on problem is if you look at
it the probability for this service to
fail is about twice the probability of
one individual server failing maybe we
can do better and obviously we can by
having the web and the database server
running on the same machine now this
seems a little bit strange because
usually weapon database servers air are
well have different requirements in
terms of the hard way they need however
and if you look at the notes equal space
in particular there are databases that
have less heart requirements on the
hardware so using a no sequel database
actually makes that a pretty good option
and also with replication and so on in
the notes equal space that's definitely
doable so what you will end up with is a
system where you will probably separate
your system in services smaller
independent services to keep the results
of a failure low so if one of the
servers in this case failed
it will only mean that one service fails
not the whole application and probably
you will end up with this separation
because those services might fear for
different reasons so a customer service
might talk to your CRM system and might
fail if the CRM system is down or they
might use different databases so it
might be wise to separate them remember
however there is the first law of
distributed objects and that says don't
distribute objects so what you should be
doing what you should think about in
this case is still whether you will
really want to separate your application
in different servers because that might
cause the performance over here because
of distributed communications on there
are ways to solve that so if you look at
the system that I that I've just spoken
about you could for example say okay
each of these services has its own HTML
front end and if I open a page that is
specific to a specific server the
server's you go to that server and get
the HTML from that very server and then
you don't have distributed objects
instead it's just bare your HTML and
HTTP comes from challenges well we have
more services we have more Sabha and
infrastructure over had caused by java
ee is even less acceptable and even the
JVM might be a problem in this regard
and it is also it's sort of a
contradiction to the ER model where you
have all the modules in one place in one
server so it's very very different in
that regard and this is by the way
really hard challenge I mean if you look
at the JVM the JVM has this problem that
it had it's rather memory inefficient
because of the way that garbage
collection is done and that in turn
means if you really want to run a lot of
jb ms on a virtual light on on a cloud
environment you are probably going to
a consumer lot of resources which will
cost a lot of money so a cloud needs
these small services that's again not a
great fit for Java EE and maybe not even
further trivia so we'll see about that
okay so another technical technology
challenge is no sequel the thing to
prior to note here is no sequel is
actually not just one specific
technology the most simple technology no
sequel technology our key value stores
so they just store a value under
specific key it's like a map basically
like a java map that only takes you so
far so what people came up with is the
idea of these large column stores and
then there is a key and you actually get
a structured structured data that
contains multiple columns
document-oriented stores ah well give
your documents for large column as well
as document our stores you can actually
have queries so return all the documents
are all the data sets that have a
specific characteristic and then there
are graph databases that have nodes
edges and properties and so on and so on
none of these support joints the reason
is if you do a join you basically have
to have all the data in one place
calculate the join filtered out and so
on and that means that you lose the
ability for it horizontal scalability so
you can't distribute your data across
multiple service anymore because you
have to have a way to get all the data
in one place and that sort of
contradiction so I think that's like the
basic limitation of no sequel and
choosing one of these technologies is
clearly a trade-off so if you look at it
you would
use one of these technologies because
there is a specific problem that you're
facing and you want to use one of these
because they have specific strengths so
if you look even if you look at one
specific no sequel flavor there is still
a choice to be made so red is for
example it's a key value store it's in
memory it's very fast but because it is
a memory there is only so much data you
can store Lee Ark is very different
that's very scalable so you can store a
very very large amount of data in it so
i believe is then it really does make a
lot of sense because it will would level
these strengths and what sort of make it
pointless because the reason i mean the
reason or the the the main message
behind behind no sequel is basically
here is a choice of technologies choose
the technology that is the best fit for
your scenario and standard really
doesn't make a lot of sense there so
that also means that a general universal
no sequel java api doesn't really make a
lot of sense because there are so many
different ways of doing it in particular
jpa is a bad fit for it because jpa
depends on the relational model and it
uses drawings for example and as i said
earlier joints and no sequel doesn't
make a lot of sense because it put basic
sacrifice horizontal scalability now of
course there are general concepts in
jp-a that you can use with any data
store like the entity annotation for
example and you could somehow tweak it
to make it work you know you know you
could say okay so we are using identity
we are using some other invitations but
sorry no joints but that's sort of
pretty weird because I mean the reason
for for having a standard in the first
place is that it's well the standard so
you just program to the standard and it
just works
using that approach would basically mean
well you know so you can use identity
but all the other stuff is not usable so
it's not really the standard so it is in
a way proprietary because there are
limitations actually this is what what
the google app engine does with its no
sequel data store so they are using jpa
and there are other projects that do
similar things I think a much better
approach is what spring data does so if
you the idea of spring data is actually
from the original spring project and the
idea is to have all these different
api's that are out there like hibernate
jpa and jdbc and have an abstraction of
top on top of that that unifies the
parts of the specific AP is that can be
unified like the exceptions for example
or to make the API similar so exceptions
I mean you can come up with all the
errors you might ever have like there
might be a constraint problem there
might be a problem with a general
problem of some kind and so on and so on
you can build up exceptions for each of
them and use them for all the api's and
that's what spring originally did it's
not a full abstraction so you can still
use the specific parts of the API or the
hibernate classes or the JPA class or
the JDBC classes if you need to and this
model is actually a good fit for no
sequel because again you have you have
the same problems the same exceptions
and they can be unified and you can
still have the way to access the
specifics of these api's so if there is
a specific so reddit has some specific
features like a messaging service for
example and that can easily be used
using the proprietary API while there
might be a general key value API that
can be used with Redis as well as react
which
a lot of sense and the reason why it
makes sense is because it's easier to
learn so once you're using you are used
to the general idea of spring data it's
easier to learn specific no sequel
databases and there are additional
things so it's easy to create a
repository or data X subject because
that's supported by spring data so if
you want to have your right operations
that's easy to do and there is support
for rest services so it's quite easy to
come up with a rest service on top of an
existing database the other impact that
no sequel has is shown in this graph
that I showed before so basically direct
access from JavaScript to the database
in the back end instead of going through
your middle tier that would reside on a
web or application server so what I
think is interesting is that javascript
is becoming very important in the nose
equal space because quite a few
document-oriented database excusas Jason
as the data representation and if you
look at MongoDB for example there is a
strong JavaScript support for queries
and these kinds of things so in a way
that's like JDBC and relational database
systems so it seems that javascript is
very important for the no sequel
databases by java is only secondary
concern so to sum up no sequel is hard
to standardize because it's such a broad
variety of technologies JP I is not a
good fit for this model and I would
suggest to look at spring data because
it makes life easier concerning no
sequel databases it's not a complete
solution so there are just there are not
all no sequel databases are supported
but at least a few important ones a last
point def herbs so DevOps is basically
says that development and operations
cooperate collaborate more strongly and
continuous delivery is one of the
practices of DevOps and it says that you
should oughta mate and optimize the
pipeline that leads to risk air to your
releases we are going to have a keynote
about that tomorrow so I'm looking
forward to that what does that mean for
for us well first of all continuous
delivery is an important part of DevOps
and because at least during deployment
development operations have to
collaborate it's no there is no way that
one of these two parties can do a
successful deployment on their own so
the impact on Java I think what is
interesting is that quite a few of the
continuous delivery tools are written in
Ruby like puppet or chef or some of the
other ones so what I'm seeing at least
my company is that this might strengthen
Ruby and if you so what is happening
there is that people start using Ruby
for these automations and then they
start using it for other things in the
projects as well and if you look at it
that's also how Java got started so Java
originally started with applets and now
nobody is basically doing applets
anymore instead we are using it for
enterprise application development and
maybe something similar is going on in
this space and that's all so different
from continuous integration where we
have quite a few Java tools the impact
on environments again if you look at it
these continuously it continuous livery
tools in a way compete with server and
cluster management tools because these
continuous delivery tools allow you to
set up a cluster of application servers
quite easily and that was one of the
advantages of some Java EE service that
they have that they have a more
sophisticated way of handing a large
number of
cluster nodes and that is being leveled
now by continuous delivery so again here
you can see that simpler serve simple
services a simple servers are preferred
and the missing management features that
some of them have can be compensated by
those continuous delivery tools so again
we see I think we will see a push here
for simple web servers we will see
probably a push for Ruby in this space
and that's another impact so this should
be it yeah so thanks a lot for listening
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>