<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Douglas Crockford: The Better Parts - Forward 2 Web Summit | Coder Coacher - Coaching Coders</title><meta content="Douglas Crockford: The Better Parts - Forward 2 Web Summit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Douglas Crockford: The Better Parts - Forward 2 Web Summit</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rhV6hlL_wMc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well good morning everybody
and now the parts you've all been
waiting for
the better parts so we're gonna start
with with this guy Antoine de
saint-exupery a famous aviator and
writer brilliant writer he is best
remembered for having written with the
little prince which is one of those
wonderful children's books that isn't
really a children's book great bit of
writing but he wrote other books as well
and they were all brilliant and in one
of them in particular he writes this
sentence it seems that perfection is
obtained not when there is nothing more
to add but when there is nothing more to
subtract absolutely brilliant I've seen
this quote used over and over to
describe engineering architecture design
anything which combines creativity and
discipline he was talking about the
design of airplanes but it seems to talk
about all kinds of things and I think it
applies especially to software because
of the requirement for programs to be
perfect we have a greater requirement
for perfection than any other craft and
he gives us some wonderful insight as to
how to attain that perfection I think it
also has applied well to programming
languages and the idea is that we can
make programming languages more perfect
by removing their imperfections and
that's what I call the principle of the
good parts which is if a feature is
sometimes useful and sometimes dangerous
and if there is a better option than
always use the better option I think
this is obviously true a lot of people
don't they say you know I don't want to
use a better option
which really doesn't make sense but
there's a lot of that out there and and
I think it comes from a fundamental
misunderstanding we are not paid to use
every feature of the language at the end
of the project there isn't a manager
with a clipboard saying you'd use a with
statement did you leave out any
semicolons did you use commas as
operators do you know we're paid to
write programs that work well and are
free of error free of error wait a
minute when did that become part of the
deal it has always been part of the deal
it's just we attained it so rarely it's
easy to forget that it's the first
requirement so the the good parts I
wrote a book about it a few years ago
applied to JavaScript and remarkably it
is still a best-seller in its category
which is extremely rare for software
books software books often become
obsolete before they're printed and so
to still be current years later is it's
kind of amazing and it's because what I
identified as good parts actually are
good parts and and so the even though
the language has gone through a couple
of divisions since then it is still
relevant
now it's surprisingly controversial
there are a lot of arguments against the
good parts and I'd like to go through
some of these quickly the first argument
is well that's just a matter of opinion
it turns out it's not if you look at
programming
from the perspective of what can we do
in order to drive our error rate to zero
what kind of discipline do we have to
bring to the craft in order to get zero
errors then you have to go to the good
parts because taking unnecessary chances
removes you from getting to perfection I
have the privilege of being the
maintainer of jslint and I receive bug
reports from people from all over the
world things like we spent two weeks
chasing down some obscure bug which was
caused by someone missed typing a period
as an equal sign and that turned out to
be syntactically equal and nobody saw it
looking at the code and just cost us a
lot of time and money could jslint find
stuff like that and the next edition of
jslint will so but there's a cost of
that and that is that there are certain
silly expressions that which you cannot
use because they alias to these things
which don't go wrong very often but when
they do go wrong they really hurt you so
if you've always followed jeaious Lintz
advice you will never experience those
problems that's not a matter of opinion
that is a fact every feature of the
language is an essential tool you can't
take away the tools that I need to do my
work I'm not proposing taking anything
away from you I'm actually giving you a
better way to use the language by taking
out the parts that are problematic it is
easier to write good programs and
ultimately that's what you want I have a
right to use every feature ok the
conversation has changed and we're no
longer talking about what's the best way
to write programs we're now talking
about my rights and ultimately this
argument degenerates into I have a right
to write crap
and I don't care I mean this is not an
interesting argument what's more
important is you have responsibility to
write stuff which is good and that's
more important
I need the freedom to express myself I
want people to look at my code and go
wow I need to reduce my keystrokes this
is a really common one because we
imagine that we spend most of our time
typing to deter and if we could just
figure out a way to leave out some of
the keystrokes that'll improve our
productivity turns out typing is not
where we spend most of our time we spend
most of our time gazing into the abyss
saying my god what have I done if you
can reduce that time you're gonna be
more efficient if I could propose a way
that I can increase the number of
keystrokes by a factor of 10 and cut
your errors in half that would be a huge
win unfortunately I can't give you that
advice but you know that that shows the
the proportionality here and it's an
insult to suggest that I would ever make
a mistake with a dangerous feature again
weird we're way off topic now and
there's a good reason those features
were added to the language and this is
absolutely false
so let me tell you a story so Brendan
Eich the brilliant guy who invented
JavaScript put in a double equal
operator which did type coercion before
it does the comparison which means that
sometimes will give you a false positive
answer which is bad because false
positives are confusing and can cause
bugs and he recognized that he made a
mistake now he wasn't the only one to
make that mistake PHP has that error and
it lots of other languages did it so
it's but he's smart enough to figure out
that it wasn't right so when the
language began at standardization he
went to the Standards Committee and said
now's the time to fix it in fact I've
already made the fix in Netscape and the
fix made the code smaller and made the
language run a little faster so this is
a really good thing to do and the
committee said no we're not going to fix
it
we're going to keep it wrong because of
legacy issues and they offered instead a
compromise we'll put in the correct
operator and we'll call it triple equal
yeah
and we're stuck with that so I recommend
always use triple equal double equal was
not put into the language for a good
reason so Brendan talks about foot guns
the foot gun is a feature of a language
that you use to shoot yourself in the
foot so yet got away and he regrets that
he put so many foot guns into JavaScript
and he admonishes the committee that
maintains a language from time to time
let's not put in too many more because
they're people who go all right yeah I
almost always miss it's great watch
there's the fantasy of infallibility you
see this a lot especially in younger
programmers that my skills are so
awesome I can just do crazy stuff and
it'll it well it'll work enough and then
it's great and then there's a futility
of thoughtlessness you find this
especially among old guys it's never
worked it's never gonna work why do we
even try
you know Justin so two very very
different attitudes indicating two very
different life experiences but they both
end in the same place that is danger
driven development so one of the things
that makes the scheduling of software so
difficult or the management of software
so difficult is the difficulty of
scheduling so when we're scheduling we
have to estimate how much time is gonna
take to write the code and that's really
hard we don't know how to do that we
guess and sometimes I guesses are off by
not too much and sometimes they're off
by a whole lot but then there's an init
an additional time you have to be
concerned with the time it takes that to
make the code work right this should be
zero right because you should write it
and should work but often time B is
bigger than time a sometimes time B is
infinite and that happens when the code
is finished but the project is canceled
before it's made to work and that that
happens way too often so if you're doing
anything in a to try to save time which
adds more time to B you're doing it
wrong okay we we want to make be as
small as possible sometimes when people
in a hurry they think well we'll just
write sloppy stuff because it's quick
because we just have to go on except
they forget you still have to make it
work and it's much easier to make it
work you can make it work much faster if
you write it well you should always take
the time to code well even when you're
in a hurry
especially when you in a hurry so we've
got a new edition of the language coming
out the 6th edition and it's going to
have some good stuff in it there's some
new good parts being added to the
language I'm really happy about this I'd
like to share some of them with you the
first one the best one is proper tail
calls this is something we learn to do
with scheme back at MIT in the 70s and
finally this idea is getting it too
script with this feature JavaScript
finally becomes a real functional
programming language and it's really
simple all that happens is if the last
thing a function does is return the
result of calling another function or or
itself it works with recursion to then
the compiler instead of generating a
call return sequence will generate a
jump and a jump is a little bit faster
than a subroutine call so that's good
but more important it can reuse the
activation record so it doesn't have to
allocate memory every time it calls a
function which enables whole new kinds
of programming like continuation passing
style which is an incredibly powerful
form which we could not use until now so
this will be my most favorite new
feature of the language next one is the
ellipsis operator which gives us a much
better way of dealing with functions
with a variable number of arguments in
the past we had to use the arguments
array which was really awful an awful
awful thing so here you see two versions
of the curry function the first one is
written in the es6 style the second one
is written in the es3 style
it's just appallingly awful it's just
ridiculously bad there's lots of stuff
going on in that function that has
nothing to do with curry it's just noise
because of MIS design in arguments
whereas in the new one you just say dot
dot dot any place you want to indicate
and lots of things could happen there
I'm just just brilliant I love this this
is my second most favorite feature it
doesn't allow us to do anything that we
couldn't do before but it allows for
some things to happen in a much better
way we're gonna have modules in the
language which are great historically
the biggest problem in JavaScript was
the global object javascript doesn't
have any kind of linker and so that
common namespace is where everything
collides but that turns out to be a huge
problem for reliability and for security
so we're getting modules now this is the
new module system is much better than
the crappy require stuff that we have in
common Jay yes this is really good it's
inherently asynchronous that
it's great so that'll be good we've got
a new let statement which works just
like the old var statement except that
it will respect block scope so
JavaScript in the past never had block
scope had only had function scope which
isn't bad because you can write good
programs with function scope the problem
was there are a lot of people coming to
javascript from java and the syntax of
the languages are very very similar you
know so they assume that scoping works
the same way and it doesn't and so they
write stuff which is wrong because
they're confused about how the language
actually works and confusion leads to
bugs and so with the new let statement
they will not be confused anymore and
I'm all for eliminating confusion from
the world we've got D structuring which
is another feature which is not going to
allow us to do anything that we couldn't
do before but it provides a convenience
reduces the number of keystrokes for
doing certain kinds of things which is
completely unimportant what's more
important is that it can improve
readability for certain patterns of
certain idioms and and that's a
worthwhile thing I'll show you an
example of this a little bit later
then we've got week maps week maps I
think are the worst named feature in the
history of programming languages it's an
even worse worst name than proper Kayle
calls it's the way objects should always
worked in JavaScript an object is a
container of key value pairs and
JavaScript requires that all of the keys
be strings it turns out that was a
mistake it should have been a key could
be any value that would be much more
powerful we tried to fix it but we
couldn't because there are crappy
programs out on the web which assume the
bad behavior and so objects are always
going to be broken so instead we're
adding a second kind of object which
unfortunately is called weak map so and
that's a problem because nobody wants to
put anything weak in their program right
but it's really good and and this is a
powerful fundamental thing it allows us
to write programs that we cannot write
efficiently in the current language so
that's a good thing there are lots of
other features being added to the
language you have a huge number of
features being added to the language not
all of them are going to be good some of
them haven't proven themselves yet
things like generators I'm thinking
probably are not worth the trouble you
know there are lots of stuff coming in
but there's one thing which I am certain
is a bad part a very terribly bad part
and that is the new class syntax this
was the most requested new feature in
the language and the requests mostly
came from frustrated Java developers who
are now having to write in JavaScript
because that's where the jobs are and
they're hating it and they don't want to
have to learn how to do this stuff
correctly so can you please give us
classes and they're not really getting
classes they're getting syntactic sugar
on top of the prototypal system so it
looks like classes but it works kind of
differently and so there's confusion and
you know where that goes but worse than
that it turns out the best way to use
this language is to think about
functions functional programming is so
powerful and so wonderful it's so
expressive and if you're stuck in this
class thing you will never figure it out
you know you're always always going to
be stuck in this class thing which turns
out is really hard it's unnecessarily
hard and difficult and error-prone and
the people who are going to be using
class will go to their graves never
knowing how miserable they were
here's a new feature that kind of
straddles the fence it's got some good
news and some bad news it's a new way of
writing functions with the fat arrow
operator unfortunately it looks a lot
like an equality operator so I expect
we'll see some confusion there you know
get a little dyslexic it's gonna go bad
in unexpected ways and and the whole
point is to eliminate the function word
there were people who complained
function is too hard to type go there's
this new thing now called keyboard
macros you know just to know it's too
much to read okay so um so we got this
thing so here we've gotta exists here
we've got an example we're gonna pass it
a name and it's going to return an
object in which the ID property has that
name that's pretty nice except this code
fails in es6 this code is instead going
to return undefined it and it's not
going to return the new object so they
could have gotten it right they chose
not to get it right and so you know
you're gonna get screwed with this
someday so watch out so I've been
looking at you know I figured out how to
make languages better by making them
smaller and I'm still looking at at the
whole language trying to figure out how
can I remove the imperfections you know
make it small or make it good make it
more perfect because I want a perfect
language and so I've been reconsidering
what I recommended as the good parts so
in the book I recommended not using new
and I still subscribe to that new I
think was a problem I recommended using
object.create instead which is the the
fundamental prototype ol operator which
makes a new object that inherits from an
old object and I managed to get it added
to es5 just so that I could use it okay
so I was really happy about that but
thank you so I was really surprised when
I noticed that I've stopped using object
I create
and the reason was that I stopped using
this if you're not using this then
there's not much value in using
object.create
turns out there are a lot of reasons to
not use this one is it makes the
language really hard to talk about you
know which this are you talking about
you know this stinks with what what
state it's it's like programming it's
pair programming with Abbot and Costello
it's just really cool and this has all
sorts of really weird properties
everything is statically bound in
JavaScript except for this which is
dynamically bound and so there are
security errors and other kinds of
errors which come from the weird
behavior of this a few years ago there
were a number of researchers who were
trying to figure out how to turn
JavaScript into a safe language there
were number of projects like FPGAs at
Facebook there was the web sandbox at
Microsoft there was the caja project at
Google my own ad safe project and others
and we're all trying to figure out how
to make a safe subset so we could have
third-party code run with our code
without compromising us and one of the
really hard problems and doing that is
dealing with this because if you have a
method this gets bound to the object of
interest and everything's good but if
you call that same method as a function
this is now bound to the global object
which compromises all of your security
and how do you deal with that and what
the other projects did was they had
compilers which would rewrite the
JavaScript into a much bigger program
that had runtime checking and
indirection to prevent that from
happening and one of the consequences of
that was the transformed program was
much slower and so they had trouble
getting adoption my approach instead was
I can't figure out how to make this safe
so I'm gonna make it illegal so if if
there's a this in the third-party code
it doesn't get in the system so that
that turned out to be really easy I
could do a static validation and
determine if we don't allow the code or
not and my assumption was or the problem
with that is that the percentage of
existing code on the web that would pass
ad safe was a zero you know there's no
existing code
we'll pass because everybody is using
this but my hypothesis was if you remove
this from JavaScript what you have left
is still a very nice functional
programming language and that's all you
need to do programming so to determine
that that was true I started writing in
that dialect and I was very surprised to
discover that it was not a hardship it
made things easier I was enjoying
programming much more things were just
working and going together really nicely
so so I stopped using this entirely I
stopped using null one of the problems
with JavaScript is it has to bottom
values null and undefined and they are
not the same they're kind of the same
and some people treat them as though
they're interchangeable but they're not
they have weird characteristics which
causes confusion and you know where that
goes so I decided well I will only want
to use one of them and I want to stop
using the other one so which one do you
choose and I decided to go with
undefined for two reasons one it's the
value that the language itself uses so
if you have a missing parameter or an
undefined property and an object that's
the value of the system uses so that
makes sense the other is that there's a
terrible error and type of related to
null that typeof null identifies it as
an object which is wrong terribly wrong
and that problem is never going to get
fixed so if you never use null then that
error never will affect you and that's a
good thing so I recommend we should stop
using null to I also stopped relying on
the false eval use Java scripts faulty
values are the empty string the number
zero nan null and undefined and the
reason it does that is to look like C
that C is an under typed language and it
will it can do simple zero checks which
can also look for things like null
terminators on strings and null pointers
and stuff like that and JavaScript
wanted to provide that same kind of
convenience
but the behavior of the no objects is
weird and leads to bugs you know
sometimes you have a zero passing it to
something we expected undefined and it
caused programs to get lost and so I
recommend not depending on that anymore
so now if I want to determine if
something is undefined
I say triple equal undefined I don't
depend on the fall see check I don't
recommend using for loops a while ago I
was trying to teach beginners how to do
programming and they really struggled
with the for statement because it's got
these three clauses in it that are
separated by commas or semicolons and
there there's no identification as to
which is which and they were constantly
getting confused
what initializes what's the because it
didn't make any sense to them why it
looked like that and you probably
enjoyed that too when you were first
learning the for statement but in the
years you've gotten used to it but it
really is weird and and their errors
associated with for and and so I've
stopped using it and es5 we got these
wonderful new methods attached to arrays
like for each and map I use all of those
now exclusively I don't use for
statements anymore I don't use for in
something we got in es5 was object keys
which returns a string or an array of
strings and so with that you don't need
for in you don't have the problem of
that foreign has of iterating through
the inherited methods you know things
you usually don't want to be seeing so
it's a much more reliable way to do
programming ef6 will have proper tail
calls as I said before and at that point
I will stop using a while so here is our
two versions of the repeat function the
repeat function takes a function and
calls it over and over again until it
returns undefined
the first one is written with a loop the
second one is written with tail
recursion in es6 these will both run at
the same speed so there's no longer
penalty for using recursion
for loops of the substitution so when he
has six finally comes out with tail
recursion that's where I'm going I'm not
gonna be using loops anymore so I think
a lot about the next language what's the
next plan which gonna be there's got to
be a next language because if it turns
out that javascript is the last language
that would be really sad wouldn't it I
mean we got to do better for our kids
you know we got to leave him something
better and you know how will we
recognize the next language when it
occurs it serve like waiting for the
Messiah how will we know you know what
are the signs and I'd hear a lot of
prophets running around saying it's here
it's dark you know it's not dark it's
it's Python it was here all along no
it's not pipe eyelids it it's something
else but how will we know and the only
thing I'm confident of is that when it
finally arrives we will reject it out of
hand completely it's because programmers
are as emotional and irrational as
normal people now we think that's not
true we think because we're the
ambassador's to the computer we are
totally logical and rational and we are
not we're we're just like everybody else
we're just not aware of how much we are
like everybody else so here's the
evidence
it took a generation to agree that high
level languages were a good idea back
when people were struggling with machine
language Fortran was trying to lift us
out of the muck and the people who were
down of the muck said leave us alone we
like it in the muck and you know it took
a long time it took a generation to
agree that go-to was a bad idea
Dijkstra published his letter in the C
ACM in 68 and we argued violently
passionately for two decades about
whether or not we should do that whether
we should get rid of the go-to it took a
generation to agree that objects were a
good idea objects we're a good idea
we're best expressed in small talk ad
which is maybe the best designed
programming language in history
at one point the industry had to decide
we want to go with small talk or do we
want to go with C++ and the decision was
made by people who did not understand
object-oriented programming and we are
still stuck with that legacy almost all
of our languages since C++ have followed
from from that genetics and have always
gotten it wrong one of a few exceptions
is Ruby which still went back to the
original small talk and and gets at
least that part of it right and it took
two generations to agree that lambdas
were a good idea lambdas were perfected
in the scheme language was an important
discovery an important breakthrough and
like all the important discoveries the
industry took absolutely no notice of it
and this one took not one generation but
two generations before it finally got to
the mainstream anybody know which
language was the first to bring this
idea to the mainstream anyone JavaScript
this never got to the mainstream not
within miles of it
so the reason these things take so long
is because we don't change minds I mean
once stuff gets in there wrong it's
really rare that that ever gets fixed
and so it ends up we wait for a whole
generation to retire or die before we
can get consensus on the good idea we
imagine our mythology tells us that
someone discovers something and we all
move on it and that's not how it happens
the thing is discovered and 20 years
later maybe we'll move on to it so I
remember when the go-to thing was
happening you know there was this loud
debate argument going on all the time I
need to go to a central tool it's how I
think it's how I express myself I need
it it's so much more efficient I got all
these reasons for why I got to have the
go-to and I understand what you're
saying except I don't understand what
you're saying and I gotta have my go-to
and that went on literally for 20 years
and then one day it was kind of quiet
and we looked around said are they gone
can we get rid of go to now yeah we got
rid of it and we've never missed it
right and it's hard in retrospect to
understand what were people getting so
upset about because you know we're doing
fine without go to all of the
predictions about you know the end of
the world and all of that happening when
the go-to is go away never happened so
I'm thinking about the next language and
you can define I think you should divide
languages into two categories systems
languages and application languages the
system languages want to be very low
level it's what you would write kernels
and device drivers and memory managers
that kind of stuff you know low level
stuff and everything else should be
written in application languages we want
to get above the metal get a two-place
to a greater abstraction where we get
more leverage and more safety and we
need new languages in both categories
the dominant systems language today is
still C which comes from the early 70s
you know we have lost the ability to
innovate in systems languages
we're doing more innovation in
application languages but not enough and
in some of our languages I think get
this division law for example I think
the biggest design error in Java was it
couldn't decide if it want to be a
systems language or an application
language and because of its confusion
you end up with things like the
requirement to use threads at the
application level which is irresponsible
so so in application languages they're
almost all object oriented today which
is good because objects are good and
they're basically two schools there's a
classical school and the prototypal
school and most of our languages are
classical a few are prototypal
javascript being with the principal one
of those and it turns out the prototypal
school has a lot of advantages compared
to the classical school in classical
programming when you're designing a new
system you have to do a classification
you have to look at all of the objects
you're going to have in your system and
see how they're related and then you
have to build a taxonomy in which you
figure out how all the classes are
related what's going to inherit from
what what's going to implement what and
that's usually done at the time in the
project when you have the least
understanding about how the objects are
going to work which means-- means
invariably you get it wrong you just
don't have enough information enough
experience to get it right so you make
up taxonomy which is wrong and that gets
built into the hierarchy and that
wrongness finds itself leaking into the
new layers as you put them on top and
you also find that you're wishing you
had multiple inheritance because things
are not composing
correctly because you've got these
mistakes in the taxonomy and so you're
living with this system which is broken
and that adds a lot of friction slows
you down and eventually gets so bad you
decide we have to refactor now that
means you go through the whole system
and rip the whole thing apart and try to
put it together right but that's really
dangerous and there's a really good
chance it's not going to come back
together and it's scary and that's an
inevitable part of classical programming
it doesn't happen when you're working in
a prototypal system and I try to explain
this to Java guys and we tell them you
know we don't have to do this
refactoring and they go wow that's
amazing except you still have to do the
taxonomy right you're still gonna be no
we don't do the taxonomy you don't do
that go wow you still do the taxonomy
they can't imagine that there's any way
you can do it without doing all the
stuff that they've ever done and it
turns out you don't when you eliminate
those the classical dependencies a whole
lot of work vanishes you just make an
object and if it turned out well you
make another one that's just like it and
you customize it and you're done it's so
much easier so I used to think that the
important breakthrough that we got from
JavaScript was prototypal inheritance
the major benefit it gives you is memory
conservation the advantage that we have
using object create over object copy is
that we have less memory allocated to
each object that may have made sense in
1995 but it doesn't today Moore's laws
continued to crank on memory capacity
you now have gigabytes of RAM in your
pocket it's so worrying about how many
bytes get allocated to an object is just
not worth thinking about anymore it was
a complete waste of time
unless you're making millions of
instances of a class you don't want to
be doing that and I think if you're
making millions of instances you don't
want to be working in JavaScript I think
you want to be working in a better
language but it comes with a cost so one
of the costs is confusion we now have
own properties and inherited properties
which sometimes act the same and
sometimes don't and that difference can
be a confusion confusion can lead to
bugs that's a bad thing one thing it can
provide is retroactive heredity where
you can change what an object inherits
after it's been constructed I have not
found a good use for that and there are
lots of obvious terribly bad uses for
that you know it is also performance
inhibiting
that modern JavaScript engines go very
fast by making assumptions about the
shape of objects but when it comes to
the prototype chain they have to be
pessimistic because the prototype can
change at any time without warning and
so that is slowing down execution so I
used to think that the really important
idea we got from JavaScript was
prototypal inheritance I don't think so
anymore I now think Java scripts gift to
humanity was class free object writer
programming I think that is a brilliant
idea which is best expressed in
JavaScript and has and was not
previously expressed in any other
language so I've got a couple minutes
let me see if I can demonstrate this
idea so you all remember block scope
we've got the let statement now which
lets you have blocks here we've got two
blocks the inner block can see the
variables of the outer block but the
outer block cannot see into the inner
block and in JavaScript we can do the
same thing with nested functions so the
outer function cannot see the inner
function stuff but the inner function
can see the outer function stuff and we
can express this as a set diagram here
we've got the set of the variables that
the outer function can see that's the
set of variables that the inner function
can see you can see that set encloses
the other set and that's why this idea
is called closure which is a really
unfortunate name I wish we call it
something else because most people think
closure means retribution or vengeance
you know I've been victimized button
gave me some closure it's gonna feel
good you know yeah it's not so anyway
this took a long time to get to the main
stream because the language guys
couldn't figure out how to deal with
this case what if the inner function
survives the invocation of the outer
function you know when we call the outer
function we allocate an A on the stack
and we return the inner function we pop
the a off the stack but then we call the
yellow function it needs access to the a
and it's not there anymore it turned out
it was easy stop using stocks just put
it on a heap if you've got a good
garbage collector
it's better anyway so that's what we do
now and and it works so this is how I'm
going to be making objects from now on
I've got a constructor function I'm
going to pass in a specification object
this makes a lot more sense than passing
in a bunch of parameters because your
users don't have to remember what order
they go in and you can add new
properties in the future and remove old
ones that you don't need anymore it's
much more flexible I'm using the new
destructuring syntax to initialize my
variables so I'm going to be creating
member variables which will get initial
values from the specification object so
this is this means the same thing as let
member equal spec dot member and I can
put as many names as I want inside the
curly braces separated by commas and it
will make all of those variables and
initialize them from values from the
object I can use the same notation for
doing inheritance so I can call another
constructor and it's going to return an
object full of methods and I can then
copy those methods into individual
variables and in fact I can call as many
of these constructors as I want so I can
get multiple inheritance I can get
aspects I can it's a very flexible
pattern I'm then gonna create my member
functions my methods and these will
close over the member variables over the
other methods over the methods we're
making an accession object it does not
use this no this is anywhere then the
most interesting thing I'm going to
produce an object going out which
contains all of the public methods for
this object and we have some new
notation in the language where instead
of saying method : method and other :
other I can simply say method , other so
if the thing you're you're outputting is
a variable with the same name as the
property you don't have to save the
thing twice and then I'm freezing that
whole thing which makes the object
immutable which makes it
impervious to tampering I worry a lot
about security in particular because I'm
working at a company that moves a lot of
money through the internet and so I'm
worrying about security all the time and
making objects which are immutable
really really helps also future
JavaScript engines are going to be able
to optimize that because there are
special properties of immutable objects
because you know they're never going to
change there are lots of interesting
optimizations that are possible
originally we had this idea that we have
something that looks like a pascal
record which contains a bunch of
properties and then we associate methods
which act upon those properties so we've
got functions and data and the same
thing I think that was an important
transition step but it shouldn't have
been the final step I think instead that
or what I'm doing now is I have an
object containing only methods and it is
frozen and then I've got objects which
contain only data which are hidden
behind those methods and that's a unique
pattern that we only find in JavaScript
and I now believe that that is the most
effective way to use the language so I
am afraid I'm out of time so we have to
stop here so thank you everybody and
good night
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>