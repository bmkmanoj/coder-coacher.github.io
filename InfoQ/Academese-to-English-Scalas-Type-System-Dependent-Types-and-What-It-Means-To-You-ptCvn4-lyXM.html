<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Academese to English: Scala's Type System, Dependent Types and What It Means To You | Coder Coacher - Coaching Coders</title><meta content="Academese to English: Scala's Type System, Dependent Types and What It Means To You - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Academese to English: Scala's Type System, Dependent Types and What It Means To You</b></h2><h5 class="post__date">2014-03-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ptCvn4-lyXM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Heather Miller I'm a PhD
student at EPFL I work with Martin
O'Dare Ischia on a bunch of scholar
related projects I know a lot of you
from lots of different things and
documentation and otherwise so it's nice
to see lots of you for those of you I've
never met before hope to meet you so
today I'm going to talk about Skylar's
type to some a little bit talk about
some things that seem to be sort of
buzzwords in this world the the the talk
it's it's pretty ambitious I had you
know promised I would talk a little bit
about the type system in general I talk
about things like type level programming
type classes things that people like to
talk about use maybe that everybody
doesn't understand them and then also I
mentioned dependent types because well
in academia this has been sort of
research for about twenty years or so
it's what lots of people are doing in
type systems and suddenly in the last
few years people are using them you know
in developer land and people like miles
Saban have libraries which do stuff with
dependent types and I don't think people
really understand what this stuff is or
what it means so I wanted to sort of
give people some some sort of
clarification or you know some sort of
high-level picture of what all this
stuff is and how it helped it together
so originally my idea was well black
people talk about these things and
scholars type system and that it's so
powerful and wonderful and then I think
a lot of time people think it's like
this scary thing as well because it's
difficult to define it can do so many
things it's so complicated nobody knows
really like how to to approach it and I
want to change that I want us to to give
you a happier nicer picture of what the
the type system can do for you or what
it is really it's something that's kind
of auto magical that can help you keep
things sort of tidy and super type safe
and protected and I hope to say that it
can be helpful if you know how to use it
that's my goal kind of in this whole
presentation or Josh actually I realized
that this is a good analogy to because
it's like you know well probably helpful
probably indulgent I'm sure that's
probably protective so this is probably
like down my new like you know a mascot
for the type system I think
but anyway so if you're one of these
people who like types a lot in like type
level programming and aren't the type
systems this talk probably is not
exactly for you because I want to just
give a lot of high-level intuitions and
sort of like stitch stuff together to
tell you how sort of things are related
that you might have heard of so I think
that everybody can get a little bit out
of talk though and like I said my name
is intuition for how how basically did
get people more than just scholars type
system is powerful to sort of show you
exactly what I think that means so I
broke the sock into three chunks I'm
going to just kind of run through the
type system a little bit so if I start
using some words you know I'm talking
about I'm going to talk about sort of
some of the powerful patterns that the
type system and other things like
implicit conversions and whatnot enable
and then I'm going to go into the world
of like sci-fi and talk about dependent
types a little bit of what they are so
yep
first let's talk about a callous type
system and like I said whirlwind tour
and I'm going to skip several things
that I mean I just mean if you if you
actually know the the number of sort of
constructs and scholars type system it
would be ridiculous for someone to try
and cover them all in 30 or 40 minutes
insufficient in sufficient detail and
what you can't see down here is in fixed
types and self-type psychic you just
don't have time to talk about them but
what I will cover basically to tell you
what scale is predefined types are how
to define your own types talk about you
know what it means to have a
parameterised or a generic type variants
and bounds and then actually the cool
things which are abstract type members
you'll find at the very end of this talk
are super ridiculously powerful
existential types which Matt aren't that
powerful as you'll find I'll just you
know show you some higher cata types and
and and structural types and refinement
types so the obligatory I have to show
this if if I'm going to talk about
Skylar's type system everything is a
subclass of any and everything is a
super
is it nothing which you can't see is is
the subclass of everything as well right
yeah that's good actually
I don't know the slight the thing seems
to be poorly fit for the screen anyway
and hierarchy is broken into two pieces
one side has all of the the value like
things so on the left side everything
that that extends for many Val which
itself extends from any these are all
value types these are all things like
primitives or things we like to think of
kind of as primitives like Skylar's unit
type which is like void and then you
have everything else on the other side
and this is the Scala universe your
program lives somewhere in the middle of
all of this so these things are given to
you then you can make your own types how
do you do that well you declare a trait
or go Thanks you have you define a
clotting declare you have a through
class declarations or trait declarations
or you can you can create a type by
defining one using this type keyword
that you might have seen and make a type
member those are the two main ways to
sort of you know sum up types from
nowhere another way to make a type is by
combining other types so you can make a
compound type or a fan type a refined
type which is compound type is basically
the union of two types and a refined
type is sort of you know fudging a type
that already exists and I'll show you
that later so these are the ways you can
make types parameterize types so ty
privatization is basically generics it
allows you to write things that are
fully generic like classes and traits
and other things like that
and so the point at the point that I
wanted to make here that you can
basically add constraints to these
things you can use this notion of very
inserts notion of bounds to to to put to
control sort of what what can be passed
into a class or or what a type
instruction or class will take can take
so you might not want you know
I'll give you an example but to start to
start with with one of these things
variance
I'm sure if lots of you have heard of
this before the idea is that if you have
something like a trait box
it's totally generic a class tool and
class hammer that extends tool we don't
know we know that hammer extends tool
but we don't know if I have a box of
tools if that is also a box of hammers
or what relationship they have and this
is what variance does it basically says
well on the very left here covariance is
sort of the same as is sort of the
forward direction like you would think
if if hammer is a subclass of tool than
a box of tools
I'm sorry box of hammers it's a subclass
of a box of tools contravariance is the
opposite so yeah as you can see and then
finally there's there's invariants and
that's that's when there's there's no
relationship at all and that's that's
the default in Scala so if you ever
wanted to if you just assumed covariance
you have to add a type parameter or you
have to add a variant annotation to your
type parameter this little plus symbol
because by default it the Scala compiler
assumes there's no relationship between
a box of tool in the box of hammer so
you can control some things that you do
with your with you know with with these
things called variants annotations and
then you have this other thing called
these other things called bounds which
you can actually put all over the place
on you know on type members and whatnot
in in the you can you can put a bound on
a type parameter inside of a like with
this generic thing here and basically
you have upper and lower bounds in this
trait box here you basically say that
you'll take any type T that is a tool or
one of its that is bounded by by tool so
you can take yeah and then and then the
other way around
for for the upper bounds so you know so
and then yeah so back to the whole thing
how this fits into the whole hierarchy
all types have an upper bound of any
and a lower bound of nothing so you can
think of the Scala compiler
automatically adding these things for
you but yeah so you guys already know
that I'm sure if you're here the whole
point of showing you that was to say
well Java kind of already does all that
stuff too except maybe with type may the
type members thing otherwise you know
that's that's more or less the same what
I want to try and show you with you know
this entire talk is that Scala gives you
a lot of a lot more control over type
checking in your programs then then then
then just these these few things right
so it's a yes is where it gets
interesting so the first thing that I
wanted to talk about like I said and
soul this was was abstract type members
so a type member you can see it here and
the class person you have an abstract
type member pet and I mean it's just
it's a type where we don't really know
what it is and it sounds pretty basic
but the whole idea is that you can sort
of in super classes leave these type
parameters abstract and make them
concrete in subclasses so we can do that
in this this class Susan here class
Susan extends person and you can you can
make concrete this abstract type
parameter it's now a concrete type
parameter but our type member and we can
make it a cat right and sort of you can
think of that actually as being the same
as parameterization so if I wanted to do
the same thing like you would do it only
like just in Java or something you would
do something like this you would pass
pet as a type parameter to person what
this was big class I know yes okay no
I'm sorry so all right of course person
I said I had to take a tight perimeter
has to be changed I'm sorry I totally
forgot so you can then take class Susan
and extend Susan with oh man this is
messed up supposed to have supposed to
have cat you know that's right that's
fine it's fine
oh my god I guess I don't little
frazzled a day please and jet lag ah
okay yes so this is fine so basically my
argument is that these two things are
the same and and actually one thing
that's kind of funny I think this I
don't know the name of the paper I saw
it a little while ago
Martin wrote a paper with like I think
it was so waddler or somebody about this
this sort of thing with type parameters
and and abstract type members and things
like that and okay you know how what is
what is better what is better you know
and he found that they did some huge
empirical study actually and they found
that of course as the number of
parameters increases sort of the
complexity sort of of your code ends up
kind of exploding and you know things
are left tractable with with abstract
type members instead of you know making
some huge thing that has 20,000 type
primers in it and it's really funny it's
like some some like some paper that was
at a very good conference in like the
90s or something it's quite quite funny
so anyway the point is that this you'll
find later that this this these this
these abstract type members are pretty
powerful because we'll we'll see that
we'll see that it's possible using them
to subsume a lot of other sort of things
in scholars type system so anyway the
takeaway that that that I'd like you to
walk away with about abstract type
members is that you can you can still
achieve the same level of abstraction
without the verbosity of type parameters
and having to keep track of where you're
passing these things which leads me to
actually extend existential types a lot
of people I don't think no existential
types are because they don't see them
very often and a lot of you know day to
day code but the idea is pretty simple
behind them
the idea is that we want to be able to
still come
pile some piece of code where we don't
necessarily know what one of the
component types of something is going to
be so uh so exit yeah an existential
type includes references to two it can
have value members but usually abstract
types that we know exist somewhere in
our program but we don't really know at
the time when we write this one bit
thing
what specifically T is going to be so
that's that's or the intuitive idea and
sort of the key notion here is that you
can leave some parts of your program
unknown and still type check it and have
different different implementations for
those for those unknown parts so this
little code snippet here doesn't
actually do anything it just
illustrating you know you might look at
it and think well it doesn't make any
sense because I have no idea you know I
have no idea what T is but this compiles
and farm has it doesn't have to know
anything about about fruit or anything
else and it's all it's all fine you
could pass you know something like you
could or Apple whatever which could be
this T and you can still pass that in
and and it's also fine
sort of the takeaway here is that the
thing that people like about existential
types is that you can fully D couple
implementation details from types and
this is why people in ml and languages
like ml they like existential types very
much so on to the next construct and in
the type system that people like to talk
about higher kind of types you have to
in order to understand what a higher
kind of type is you have to first know
what a type constructor is so a type
constructor is is is here this on the
left-hand side here this parameterised
type that you see down here defines
actually type instructor so Q of T is
type constructor and it can be used to
construct instances of lots of different
things so a queue event queue of string
a queue of queue of int and a higher
kind of type is one that abstracts over
those over over those things those type
constructors
and so they're you know you can have two
different two different forms of them in
Scala so this is I think most often
people see form number one where you
just see it all together see is a higher
kind of type since it abstracts over the
the M type constructor and it's kind of
all in line and another one is actually
where you have a type constructor
defined as an abstract abstract member
so here D in this case is a higher kind
of types inside abstracts over callback
which itself is a type constructor so
really the the big idea behind higher
kind of types here is that you can
abstract over common abstractions so you
can abstract over things like container
types and if you've looked at the this
scholar like just the architecture of
the Scala standard collection library
you'll see you'll see a lot of this
happening a lot the last sort of
interesting variety of types I'm going
to talk about our refinement types and
structural types these things are
different but I'm going to really talk
about refinement types right now a
refinement type refines something that
already exists by by adding new members
are doing something new to it so
actually
yeah
and this is I'm sorry I told you had
this is this funny problem and these are
some old examples that I thought I had
gotten rid of so anyway what okay so
they can be they can be structural but
the I'm going to talk with just only
about the last example here where we
have something C which has a field age
of type int and we can actually refine
that and create an add an additional
field to it by by just doing it like
this here
by making concrete this field and then
adding another field and calling it name
the second the the middle example here
comes from comes from the Scott of the
scholars sort of similar to what might
have seen if you ever read the
programming at scala book by Martin yeah
so yeah refine types can be used
wherever a type can occur they're not
just for instantiating one-off types so
you can use them in line as well what's
the point that I wanted to make there
but yeah so I guess the idea is that you
can sort of have duck typing but totally
totally static rather than what they do
in languages another and dynamic
languages yep
shoot sorry it
well that's just this is so this is a
new a totally new a totally new type
that gets defined so what do you ask
you're asking who can see well this is a
stupid example I mean like this is it
this isn't meant display you can I don't
intend for you to actually use this this
is just saying hey you can add a field
to something yeah yeah that's that's
true yet yeah so I'm sorry this is again
a side effect of sort of a disaster that
happened this morning and and that's why
this slide and that slider in there I'm
sorry I tried to fix these before I
could get I got here but anyway my goal
was to give you some convincing examples
of things that you could do in Scala
that you couldn't do in a language like
Java or Java you can think of the type
system is giving you a way of enforcing
different shapes and you know making
sure different sets of shapes go into
different interfaces and it checks that
you know think that these different
shapes are correct and that they're
being passed around in the right way so
it's kind of like like like this this
childhood game where you know you want
to put a square peg in a square hole
round peg in a round hole but and Scala
has all of these other things like these
just these things like higher kinds
which like I said they let you abstract
over type constructors and all kinds of
other things so you can build
abstractions on top of abstractions and
then you can do all kinds of things with
with you know these type members and you
can refine things and you can make new
types all over the place and you can
combine them to do all kinds of
different things and as I'll show you in
a minute you can even do a lot of type
level stuff that will transform some
types to new types so so I haven't quite
gotten there but just sort of some of
these preliminaries ideally I'm trying
to trying to argue make Scala a little
bit stronger
of a language it's more like having a
like one of these these toys that are
more reconfigurable and clearly sorry
and clearly a like a transformer toys
more fun to play with than a brick in a
box toy anyway so some of the stuff that
Scala enables I can talk about a lot of
things but I you know wanted to sort of
prune it down to a few things that I
think are pretty important so everybody
has sort of type classes most people
know what they are by now a couple years
ago people didn't really seem too widely
use them or understand them but now
they're more popular I think it's not so
hard to convince people that they're
useful type level programming is is
something that's been around for a while
and you know generic programming and all
of these things have been around for a
little bit and I'm not so sure it's
there that you know in in a lot of
communities it's very well understood
what that means specifically and then
there's some stuff called
materialization or what Eugene and I
like to call materialization which is
another another form of kind of generic
programming and all this is sort of type
directed and so we sort of use the type
system to do very rich things that that
enable like a lot of flexibility and
eliminate boilerplate and all kinds of
things so the first thing I want to talk
about our type classes so what are they
what are they for I guess if you don't
know what they are they're they allow
retrofitting types with interfaces so
even something that that is is final and
you can't change you can add methods to
it and in Haskell they're actually built
into the language but in scala they're
they're a popular sort of type base
pattern which itself is based on on the
notion of implicit so just to give you a
quick definition of what they are a type
class is a generic trait so here we can
use ordering we have a
this is this actually ordering in the
standard library this is just a dummy
ordering but this is the type class for
that so this defines the actual
interface and you could have some method
compare in it which compares two things
and gives you an int should probably
give you the thing but okay so in a type
class instance which you can happen yet
you can have one type class in many type
class instances a type class instance is
itself exists as it as an implicit which
provides an implementation for that
interface and it's an implicit so that
sort of the wiring gets done
automatically so if you wanted to define
one that that ordered integers you could
define it this way where you have some
implicit object and it extends your your
ordering
type class and then you implement you
know your your compare method however it
means to have that implemented and
that's sort of the shape so you could
also have you've also Express
constraints and you know provide
suitable implementations for those one
way of doing that is with this this
notion of a of an evidence parameter so
you can basically require a certain type
class and something like normal like a
sort method and have this you know more
or less be completely invisible to the
user so for example if I have a sequence
I would like to know how to perhaps you
know have some notion of ordering maybe
in any you know and whatever I do with
it I'm sorry
I need a notion of ordering for absurd
invitation of sort so in this example
the ordering an instance of ordering for
sequences so imagine that there was one
for sequences
would be implicitly found in scope and
and used it can be used in the implement
than the concrete implementation of the
sort method in any way so this evidence
parameter provides a concrete
implementation of that type class for
whatever the type is that you end up
passing to to sort and in a short short
hand way of doing it is by using what's
called a context bound which is kind of
confusing because it's got a name and
it's something else but really does same
exact thing as as what we write up here
this implicit evidence ordering thing
just it gets rewritten like if you write
you know sort t : ordering it gets
rewritten to this this implicit evidence
thing by the compiler and yeah so that's
the basic idea of type classes so you
can you can you know use them as
constraints and things that you
implement and you can and you can yeah
so you can basically use it or you can
also both yeah so the next thing that I
think is pretty important and
interesting is this notion of type level
programming so the the basic idea behind
type level programming is that you do
computation with types at compile time
in the compiler so given some input type
saw or some types at compilation time
you do some computation to have an
output type and the way you do that is
you take two steps you define a type
level function which can take all kinds
of forms and be all kinds of different
things and then you need to apply that
function during type checking and I'll
show you an example in a second but yeah
in real life there's a lightweight use
of some type of computation in this can
build from pattern in Scala's
collections so one one common way so if
you want to create this type level
function
one common way to do it is to use
implicit which can be implicit values or
or that you know plus it does all kinds
of things and the example I'm gonna show
you it's going to be a bunch of implicit
values but you can use them for defining
relationships between types and so here
here in this little example I mean again
this is a small example the idea that my
goal is just to give you intuition but
in this example the idea is that like we
have we want to just figure out a
mapping from from country to city or
capital city rather so our goal is to
actually do this little very stupid
little mapping computation at compile
time but people might normally do this
you know at runtime right so here we
have so in this class has capital has
two two type parameters one has to be a
country one has to be city as you can
see and you can think of the the type
level function that we were trying to
implement as as you know the input being
the country in the output being the city
and you know we in this case have a
bunch of implicit values that in scope
that do this mapping for us basically
and sort of the magic part of the
immunity seems pretty straightforward
but the the part that's actually kind of
interesting is that in this this this
def lookup Capitol method this this has
this this this out this return type here
fee is calculated by the compiler so
that's going to be the actual like value
if you want to call it a value but that
like that's what we want that's what the
compiler is going to figure out for us
so you know you take as implicit
parameter has capital which like these
things are floating around in scope and
if I provide if I if I provide as a type
the country who I'd like to look up the
capital so in this case Val C equals
look up capital France right here it
tells the compiler basically you know -
it triggers look at it triggers implicit
search and and which itself is is
intertwined with type inference and it
figures out the the return type to be
Paris so it's a small stupid example but
I mean if you want to think of it like
your type is a value then this is a way
to do some very trivial computation but
computation nonetheless at compile time
so the type checker calls are our type
of a function and computes the capital
of France
oh I said what I didn't say though is
the way that you should apply these
things is well by by using an implicit
parameter for example in this case to
trigger this implicit this implicit
search which is sort of the type level
function so type level computation is
used all over the place
not super widespread but use nonetheless
so as I mentioned can build from is one
example where you know at compile time
sometimes frustratingly
the compiler tries to figure out what
the bets the best result type of like if
you call some Combinator on some
collection tries to figure out what you
should get back and you know that's
something that you could think of as
being totally like a compile time type
level thing right it's like doing
computations at compile time and then
another another use case our phantom
types which phantom types can be thought
of as types that exist only at compile
time so they add additional checks but
they don't have a runtime representation
themselves and you can using this sort
of type level approach you can you know
for example make a list or a collection
or something and track the length of
compile-time and one one situation where
this would be could be useful is when
you need to
two-zip two lists together or to two
collections together and want to make
sure you want to make sure that compiled
you want to reject the code at compile
time if they don't have if they're
nonsensical and they have different
lengths so this is one example where you
could use something like a phantom type
so the my favorite use case sort of our
favorite thing about about using types
in two powerful ways is this notion of
materialization Eugene likes
materialization a lot as well I know
that for sure
so materialization is a it's all about
trying to get rid of boilerplate when
you are defining type classes so if you
wanted to have something be parametrized
by a bunch of a bunch of different types
you have to basically write these type
class instances for every type that
you're interested in having a type less
instance for so I wanted an ordering of
string or an ordering of something else
not all the time but sometimes you would
you know you have to just write all
these different type class instances out
and sometimes you can you can make a
generic function or Jumeirah I'm sorry a
generic implicit def return a type class
for some range of types and that can
help by reducing boilerplate but
sometimes you there's just no way to use
a unemploy it generic sort of function
to abstract over sort of the the tedium
of writing type class instances so in
those cases I mean this is like you know
for example we can abstract over all
possible types at a generic could take
and I mean this is a for example in this
serialization framework that that Eugene
and Philip holler and I worked on of
course there's no way to know every
possible type that you are going to you
know
need to generate serializers for so in
these cases we use a macros actually to
help us so we basically just combine
macros and implicit you know in order to
prevent there from being a growing
number of implicit vowels that that
define our implicit vowels that are
basically your your type class instances
and so in the case of serialization you
would make a an implicit or an implicit
a def like this gen Pickler which itself
is implemented by macro and the way the
matt like the way you do materialization
is this macro inspects the type type
arguments so in this case would inspect
this this t thing does something that
corresponds to sort of the logic of what
it should do
but you know evaluate to a type class
instance in the end and so that's sort
of the intuition I hope it's hope it's
pretty clear and then sort of like the
last last thing I wanted to sort of
briefly like hopscotch over is dependent
types I don't know if anybody's heard of
these things before in the world I'm not
going to give you an academic treatment
of them I well again my goal is to try
and be a little bit intuitive so I want
to tell you first what dependent types
are in general there's a lot of
languages on the planet like Idris and
and Agda and cock and epigram and a
bunch of things that are you know fully
dependently type languages and and you
might have heard ok well there are
dependent types in Scala
I mean mile Savin does a lot with these
dependent types what does that have to
do with the other thing and then also we
have this notion of dot and dot II which
you might have heard of which is
Martin's new experimental compiler and
DA d stands for dot e is a cute little
nickname which stands for
dot which itself is an acronym for
dependent object types so these things
all have the word dependent in them are
they related actually well we'll see so
just to give you an idea of what a real
dependent type is a full-spectrum
dependent type the idea is that types
actually oh I lost I lost a transition
so types depend on values I had this big
thing so types depend on values and and
what that means is that in the type you
can include a logical proposition which
says something about what the values of
those types should take right so it gets
a little bit complicated because I'll
show you but a little example in the
language called cock is this here the
goal of this little thing here is to
define a subset type which is kind of
like a refinement it's so so think of Z
as an integer and we want to make a new
kind of Z but we want to make a Z star
only apply for things that aren't 0 and
Z plus Z plus is a things that are
greater than 0 so this thing here this X
greater than 0 is this logical
proposition that you want to attach
right to the type that says something
about the values that the the type can
be represented in it's kind of a simple
like example another example that you
might have heard of is being able to
figure out at the type level whether or
not you're going to call head on an
empty list these are things where values
and types we can try to intertwine them
and sort of make programs that know a
little bit more it gets a little bit
tricky though because this is all based
on logic and so values of types have to
contain proofs that these propositions
are true but another example
is that of a binary tree say we want to
ensure that whenever we make an update
to that tree we want to make sure that's
balanced and so with the penta types you
can you know we can do that by having
some kind of logical property attached
to the data type and it could look
something like this but this is just
yeah and that's that I mean it's just
another little example where they could
you could consider them useful but
there's a small caveat sounds really
great sounds like you can you know get
rid of a lot of runtime errors by having
dependent types because you know any
boundary conditions or anything else you
can try to find a way to get rid of
however because you know so yeah the
idea is that you're mixing values and
types at but you need proofs about these
properties as well which means that the
dynamically typed dependently typed
programming language can also be should
also be able to be used as some cap of
logic so in order and in order for logic
to be consistent we need to require we
need all kinds of very interesting
requirements like you know programs have
to be total they can't crash or they
can't they can't ever they can't allow
non termination which in a real
programming language is is not yes
yes so the reason the reason why is is
so I'm not quite sure like what you're
asking so in order for so everything is
based on like logic and proofs right so
in order to prove anything you have to
generally you know not get caught in a
situation where stuff doesn't terminate
right and so if people are using if
people are using these programming
languages to do the things that they do
in them they need to they need that the
program's not terminate because
typically what they're doing is well
like I was going to say in the next
slide proving theorems these languages
are proving theorems so the due to these
caveats it's not really like you know
you just you just just will not compile
you cannot write something that doesn't
terminate basically so these caveats I'm
sorry do these caveats fully dependently
type languages to have a tendency to be
useful fourth you're improving and
that's popular in the world of
verification where you know you've got
some closed world program and you want
to just ensure that it's correct make
correctly making decisions so I mean
thought there's a infinity research and
verification of compilers and it was
even this.j s cert which certifies a
JavaScript interpreter but anyway the
point is that but a subset it's a subset
it also verified the specification and
all these other things but that's what
these languages are used for because of
these these sort of aspects of their
design it makes it difficult to write a
web server in them right you just can't
sorry so that brings me to Scala well
what the hell does that have to do with
Scala actually not very much because we
have dependent types but they're not the
same kind you can't just attach an
arbitrary proposition in logic to our
types and do anything with them I mean
these are all just based on paths
usually right and you have these
dependent method
types as well which you might have run
into and I'm running a little bit low on
time but this I'm just going to give you
the gist of this so you can use these
dependent types to have a type safe key
value store where if you have for
example in this this class by the mouth
no okay in this class awesome DB you
have this valid data map where you your
key you have a key value a key and a
value and your value is represented as
any and you want to you know reject
things at compile time if if you know
you people are passing in the wrong
wrong values sure and basically the idea
is that you can use you can use sort of
nesting of objects and these dependent
types these these dependent these types
that are dependent on on this nesting
and on these paths to ensure that you
always you know you get compilation
errors over over a bunch of you know
weird runtime errors so the idea and two
seconds is that if you for example in
this object keys you want to create a
new key a new key with where its value
is a string or its values an int you can
do that so we know statically that this
should always be an int and you can set
it and this data store thing down here
set keys dot foo 23 and your and your
and your new DB thing and you can get it
and it gives you more type information
than just any it knows that it's an int
and of course if you try to pass a you
know a string to the thing where we know
it should be an int it doesn't compile
so with the traditional key values or
you can insert values of the wrong type
but path dependent types help us enforce
that the type specified each key always
match the corresponding value so I'll
wrap up but these things are actually
taken to some real level of utility in
languages I'm sorry in libraries like my
old shaving mile savings shapeless
library
and yeah I didn't I didn't I didn't get
to how this relates to Dottie
but basically Dottie is a research
compiler which which experiments with
these with with which it basically does
projections to try and simplify scholars
type system by by representing more
things as like abstract types and stuff
like that you don't lose anything you
don't lose language features you just
end up finding ways to represent them
with a smaller subset and and dot
dependent object types is actually just
a calculus and these things like I said
have nothing to do with really like cock
and Agda and these other languages but I
can stop there yes but you don't it's
just a type checker right no it's no
there's no you can't like compile
anything and to anything that you can
use you can if you but this I don't even
think you can pretty print trees that
come out of it yet Martin has been
working on it for a year now and he has
successfully compiled the Scala compiler
and whatnot with it and the number of
things that are not trivial but he's a
type checker kind of guy he's not a
back-end person so now we're trying to
figure out how to reuse parts of the
Curt that you know pieces of the current
Scala compilers back-end to hook that up
to Dottie and to see if we can you know
compile all the way through any
arbitrary Scala program it's on github
yeah but you just can't do anything with
it I mean you can you can yep
yeah
the only thing the only thing in the
type system that you know encourage the
cost is using an actual structural type
because that makes these reflective
calls which I believe at least Daniels
bwak at one point figured out how you
could get rid of this reflective call
but otherwise of as far as I know I
don't none of these other type none of
these other like type system constructs
or features or whatever they don't do
anything else a compile-time it's all
totally static so you don't have to
sorry don't do anything else at runtime
it's all totally static so I don't think
there are any other sort of type system
performance things other than the
compiler is slow nothing at runtime and
yes
mm-hmm
from a high-level hug to
yeah so like an so so I mean I guess
pickling is a pretty straightforward
example in that like you have this
pickle method what you want to have
implemented and you know that you want
you know to take in some arbitrary type
and then you want to emit a you know an
array of bytes for example so you have
that much shaped information and
basically you know you want to be able
to figure out how to serialize different
instances or different types of objects
or whatever so the macro itself would be
kind of going around and traversing like
this this object and figuring out what
it is and then figuring out how to to
you know implement the stuff in that
type class instance but the whole point
is you should be able to pass any
arbitrary type to it and then macro does
all of this sort of static work of you
know stuff that's not so simple and and
yeah and then you can make that macro
implicit and then the pattern applies to
code generation basically is the
observation it's if that's clear I hope
it's clear okay but yeah I think I think
a we're over time so thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>