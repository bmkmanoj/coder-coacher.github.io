<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Invokedynamic: Changing the JVM Forever | Coder Coacher - Coaching Coders</title><meta content="Invokedynamic: Changing the JVM Forever - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Invokedynamic: Changing the JVM Forever</b></h2><h5 class="post__date">2012-11-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BOOXa06y96A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we'll jump right in here talk a little
bit about what invokedynamic is how it
works
I get some kind of high-level points
about the structure of it and what its
gonna change for Java and JVM so first
of all me
Charles Nutter I'm hideous on pretty
much all the services that are out there
so should be pretty easy to find I have
been a JRuby guy for about the past six
six and a half years or so working
full-time on JRuby and in order to make
JRuby run well I also have kind of had
to become a JVM guy I've learned about
how the JVM works internally how it
optimizes stuff how it's improving in
the future or for various types of
languages and most recently spend a lot
of time working on and under trying to
get to know how invokedynamic works
inside an hours how to use it
efficiently how to use it well
I think we've done a pretty good job in
JRuby of taking advantage of invoke
dynamic so what is this invoke dynamic
thing anyway that everyone's been
hearing about probably the biggest
feature that came with Java with Java 7
with Java 7 JVM and the api's I kept
with it so is it about invoking let's
what you might think automatically that
it has something to do with just
invoking methods but that's really just
one possible use there's a lot of
different ways that you can use invoke
dynamic use the capabilities it gives
you other than just doing method calls
so then it must be something about
dynamic it has enough dynamic in the
name so it must be about dynamic
languages or dynamic typing or something
like that nothing that's actually going
to be useful for our statically typed
languages right well it's it's a common
use case for this and dynamic invocation
dynamic typed languages are certainly a
key use of invoke dynamic but they're
not the only one and I think we'll see a
lot more creative uses of dynamic in the
future so what I've kind of been calling
invoke dynamic is a user-defined data
endpoint and of course that's kind of
meaningless so we'll we'll break that
down and say what I figure out what
we're actually talking about JVM
one first of all to give you a good
general idea of how the JVM works
internally how its operations are
structured so we got about 200 op codes
in the current JVM specification about
10 or depending on how you count at 16
of these are what I would call data
endpoints and this should make it a
little bit more clear we have end points
for voguing a method where you're
possibly passing in some arguments
possibly getting something back but
you're doing something you're making
something happen by calling a method and
there are the four four different types
of invocation on the JVM right up until
invoke dynamic there's field access
getting data to and from object fields
or static fields and then all the
different ways of accessing arrays so
the two primary data structures that we
have on the JVM are objects and arrays
and accessing fields kind of has an
analogue inputting and getting things
out of arrays so pretty much all Java
code revolves around these endpoints all
the other code is stack manipulation
local variables flow control exception
handling the the program flow but
everything revolves around getting data
into and out of objects and calling
methods so those are what I call the
data endpoints for the JVM and those are
where that's where we're going to focus
a little bit on how the JVM works so
let's kind of batch this all up and
we'll say we have an entire we have our
pool of JVM operations we've got our
endpoints in here our data endpoints
we've got all of our other little glue
and plumbing that goes along with those
that really just try and get us from one
method call to the next or from one
field access to the next and as long as
we stay pretty much within these lines
within these boundaries were ok but we
can't go outside the lines we can't
color outside the lines and do our own
operations it has to be one of these
specific available end points on the JIT
at the JVM level or we've got a you know
compose it ourselves and this is this is
frustrating to a lot of people they look
at the JVM and they say well why isn't
why doesn't have my
operation why doesn't it have my dynamic
invocation why doesn't have my lazy
constant supporter my lazy finals and
you know the truth is we can build all
those things on top of the available
operations but it would be nice if we
could really just reteach the bait teach
the jvm new ways of doing method calls
new ways of finding these data endpoints
let's look a little bit more deep and
how these endpoints actually work and
you'll see why this ends up fitting very
well and to invoke into the future of
the JVM so for invocation we have a call
site which is where we're doing an
invocation we've got a method call
somewhere on an object or a static call
within that call site we've got a method
name a signature which represents the
the arguments that are coming in
possibly an object we're calling it
against if it's not a static method and
then a return type possibly void on the
VM operations side what the JVM does in
response to one of these call sites is
things like method lookup that goes and
gets the actual piece of code in memory
for the call to be executed it does some
type checking on arguments and on Tom
the target to make sure we've got the
right types of everywhere that along the
line will actually then branch and run
that code and then probably cache some
of this so we don't have to look it up
every single time these are kind of the
base operations the JVM does in various
ways we'll look at this a little bit
more graphically we've got our VM
operations in our call site here we're
calling a fool method on some object
that call goes to the JVM the JVM sees
that we're doing an invocation of some
foo method that in this case takes no
arguments it will hop into the class for
that object and find the Foo method that
it needs to use to link this call site
to connect it to a piece of code so that
it can execute grabs that method and has
it in hand do a little bit of type
checking at this point now that we have
the method and we know what the return
types are we know what the target with
the argument types are supposed to be we
can check to make sure we've got all all
the right types in the right places and
do whatever castings we need then we can
our branch actually invoke the code and
call the foo method the body of the foo
method and then like I say probably
cache it somewhere stored away in the
JVM however the JVM decides to do that
sort of a transparent a sort of an
opaque process that we can't see into
but it will cache this to avoid having
to do it over again so the different
invocation types you saw all these in
the chart or the various JVM op codes
first of all virtual method invocation
which is calling on a concrete object an
interface invocation are largely the
same the operations are mostly the same
set of operations a little bit different
in the interface case but but for the
most part those two are very similar
calling a method on an object static
methods are a little bit different
they're not really called on any
particular object like as in groovier
and ruby if you're calling what looks
like a static method you're kind of
calling it on a meta class or a meta
object at that point in Java static
calls are essentially just functions
they're named functions that are happen
to be namespace within classes so
there's a little bit less complexity to
this all we have to do is go find that
function somewhere in memory under the
color under the package class and method
named branch to it make the call and
then probably cache it again somewhere
so we didn't have to go looking for it
again and then there's all these special
indications invokes special which is
used for invoking constructors and
invoking superclass methods and again
this has mostly the same sort of
operations a few a little bit of
different act different ways of handling
type checking access checking making
sure that you're only calling super from
within the same class making sure that
you're calling the direct constructor of
a target class rather than some
superclass constructor things like that
but again mostly the same set of core
operations let's look at how field
access works so with field access we
have a call site essentially if you
don't think of fields as being a call
but it really is it's going on it's it
says on this object or on this static
field get me the value set the value
doing some operation that's various
fairly simple but it's like a call site
so we've got a field name we have again
a signature for it what the type of that
field is
and we probably have a target class or a
target object that we're putting or
getting that field from on the VM side
the VM is going to check figure out what
the offset of that field into the object
is or where that field exists in the
static space where it keeps static
fields do some type checking to make
sure we've got the right values coming
in we got the right values coming out
and then access the field and then again
probably cache some of this information
away somewhere so we don't have to
constantly go and relook up what this
field is on a given class array access
is is again similar but even simpler
than either of the other ones our call
site in this case essentially is just a
target array object and offset into that
array which we provide as the index and
then if we're setting a value into it
we're also giving it a value to to
insert into the array of that index and
the VM is going to do its type check to
make sure we're putting the right type
of object in that array or the right
type of primitive and then access that
element maybe use some caching to see
that we know we've got the right access
of the Ray and of course things like
array bounds checks will happen in here
making sure we're not walking off the
end of the array but again mostly the
same set of operations are seeing seeing
core VM operations as some of these
other operations some of the other other
endpoints so you kind of have deja vu
after looking at all this stuff each of
these different what we would normally
consider very different operations at
the JVM level are based on the same
common features the same common
operations that the VM has to perform
now what if we just had those lower
level operations available and could
wire up our own way of accessing data or
our own way of doing method calls and of
course this is where invokedynamic comes
in invokedynamic can kind of be split up
like this we have our call site which is
the invoke side doesn't necessarily mean
that we're calling a method it could be
accessing data on a field or an array
somewhere but we have our call site
that's the invoke side and we have our
VM operations which we can dynamically
compose in any way we want
so all of the things that we
do normally for doing method lookup
field lookup accessing making method
calls we can stitch those together in
any way we want
and in jva in the JVM terms in jsr 292
invoke dynamic terms the invoke side is
the bike code the voc dynamic bike code
and a bootstrap method which we'll talk
about a second and Method handles which
are the core VM operations we can
compose in any way we want so first of
all the bike code it's a new invoke byte
code at the JVM level and VOC dynamic
like invoke virtual or invoke special
and so on and it can do all of what
those other operations do has a name and
a signature just like the others and
then there's a bootstrap method that we
attach to it so at the bytecode level it
looks like a normal call but it also has
a pointer to this bootstrap method the
bootstrap method is essentially a
user-defined binding a user-defined
linker or that invocation we can say
here's how here's the instructions to
the JVM how to wire up this call or how
to wire up this data access and then the
JVM will run with that bind it into the
call site and optimize it and this was
all done with method handles method
handles that have our our basic
operations getting a function getting a
field accessing an element of an array
but also let us do argument manipulation
if we want to filter the arguments as
they pass through or do a calculation
based on the arguments that pass an
additional argument all sorts of ways
that we can manipulate the argument
chain as it's going similarly we can
manipulate the return values do casts do
conversions to a different languages
type do type checks on those use
aspect-oriented programming sort of
things that wrap around this but that
optimize at the JVM level rather than
being cute little class loader and JVM
bytecode tricks there's also some basic
flow controls so we can test some value
and then branch to two different paths
if that's part of our logic for how a
call is supposed to happen but the most
important aspect here is that these are
core operations that the JVM knows how
to optimize
so when we assemble all of our logic for
doing a method call or accessing some
data but JVM sticks that right back into
the site where we've got our invoked
dynamic right back into the calling code
and optimizes it as if it always lived
there so it was always part of the
caller so this could be a little bit
difficult to to conceptualize especially
since there's no direct way to do invoke
dynamic from Java code itself you have
to emit byte code for it so let's walk
through what this looks like here we've
got a telephone switchboard and up at
the top is our call coming in someone is
making a call to the JVM saying that I
need to access this end point I need to
call some method whatever it is over on
the left here we have our lovely
bootstrap method which will receive that
call in figure out what's necessary to
fulfill that call find that address find
that method whatever it is all of these
wires and plugs over on the other side
here this is basically our method
handles we're figuring out how to plug
this call through some translator
through some other switchboard into a
target method once we've got that we've
got the entire circle all the way all
the way wired through the entire call
has been routed at this point as far as
the JVM is concerned ven doesn't need to
do anything else it's just making that
call directly to a target method or to
access some target data and all of the
rest of that just disappears and the JVM
optimizes it as if we were always
calling this target method none of the
other stuff has to has to be called ever
again and this allows us to decide how
to bind that target method doesn't
necessarily have to be a normal static
Java method doesn't have to fit into a
normal Java type structure but it
doesn't necessarily have to be
dynamically typed either all we're doing
is giving the JVM new instructions on
how to call some piece of code so you
really decide how to reach that end
point you can decide how the arguments
get translated and adjusted and coerced
and whatever else along the way you can
decide when the end point should change
if somebody decides to load new code or
you're doing a language that has open
classes where you can modify the method
tables you can decide when that needs to
change and when it needs to be updated
and you really get to decide how the JVM
handles your language your call
whatever the logic is now for a little
bit more concrete use cases the first
one is obviously dynamic invocation is
probably the simplest one to understand
we have some named method we have some
arguments in hand make a call how do we
actually do that so we're gonna do a
method lookup possibly based on the
runtime types at the very least based on
some some runtime target object that
we're calling against and as in Ruby or
groovy or some of the other dynamic
languages this is potentially mutable
these could change over time so we we
need an efficient way of saying here's
how you get this method here's how you
go look it up in some table and prime
optimize it as well as possible then
possibly some type checks that are
specific to the language a groovy at
this point may do its its checks to make
sure you're fulfilling the static casts
that you've done to make sure that
you're doing the right call calling the
right method for the type of arguments
are passing in I will look at this in
terms of our little diagram here so
again VM operations and call sight in
this case we're just we're still being a
fool call but we don't know what method
this binds to until its runtime until
we've actually gotten the class in hand
and we're doing our invocation
so we tell the JVM about it again the
JVM is going to go to some method table
in this case not necessarily a class
could be an arbitrary table that has a
just a list of functions in it grabs
that foo method and has it in hand we're
gonna do our call get the actual value
out and now this is a little bit
different will actually catch this in
whatever way is appropriate for for our
code for our algorithms for our language
if we know that we need to change it
we've got the way of invalidating it and
flushing that out and getting a new
function next time now lazy constants
are another kind of interesting unusual
use of invoke dynamic
in this case we're talking about for
example a constant that you that might
require going out to the database or
doing some expensive calculation against
a file on the file system something you
want to do once but maybe you don't want
to do it right away at boot time you
don't want to have all hundred of these
constants get loaded immediately load
them when they're needed so in this case
our call site is essentially accessing
some named constant in this case we'll
call it lazy Const if that we're gonna
now calculate it lazily but then forever
bind that value so we do this code
becomes invoke dynamic down to the JVM
level we're going to hit our lazy
computation code whatever that is make
some calculation call out to a database
hit a cache in memory somewhere and then
the awesome part about this what makes
it actually better than final fields in
a lot of cases is that then this value
comes all the way back and lives at the
call site lives at the location where
we're accessing it and it is truly
constant to the JVM one of the little
known facts about the way the JVM
optimizes finals for example is that if
it isn't actually a final constant value
like a string or an integer it will not
optimize away multiple accesses to it if
you access it 10 times it'll do all 10
accesses in this case the JVM we're
telling it this is really constant there
is no way this is ever possibly going to
change and it can optimize it actually
better than what you get out of finals
in regular Java code so delegates are
another one this is kind of similar to
what similar use case to how we do
delegates or function pointers in C
sharp for example with the method
handles we have our arbitrary function
pointers that we can pass around sort of
like reflection but faster than
reflection because again this is known
to the JVM it's at the JVM level we've
got access to these pointers we don't
have to have any of the typical
anonymous inner classes we don't have to
have any of the typical bridge methods
we can actually just have a a direct
pointer to a method to a piece of code
and this is actually how the lambdas
support in Java 8 is going to work it
uses invoke dynamic to bind this law
find the lambda code directly into a
call site let's see how this looks so
we've got our call site here where we're
actually setting up a closure setting up
a binding to to string that we want to
look like a lambda as far as Java eight
logic is concerned so that goes into the
JVM again retrieve that lambda from the
target class from a target location
build that structure around it like we
would with an inner class and create
that object but unlike an inner class we
can bring that all the way back bind it
into the call site where we're creating
this lambda and not have to pay that
cost of creating the object every single
time one of the biggest problems with
using inner classes as function pointers
or inner classes as a lambda like
constructor closure type construct is
that we create that object every single
time both dynamic for this sort of lazy
case is just caching that structure once
and then we don't have to create
recreated every single time it can be an
optimized call from then on so multiple
dispatch is another one I don't have a
direct example of this but it's dispatch
essentially based on whatever the types
of the arguments are that come in so
Java has in a form of overloading based
on method based on the argument types
but in Java itself is actually pretty
much single dispatch you will have to
define it if they decide at compile time
which of those many overloads you're
actually going to call so doing that at
runtime has always been a challenge for
folks if you're going to use reflection
you need to be able to get the right
method in hand at runtime figure out
what the arguments are that you're going
to call with this is one of those cases
that can be much easier to optimize with
invokedynamic the call site again looks
pretty much like a normal invocation
maybe we're only passing in object
arguments but on the VM side on the
bootstrap side for the invokedynamic
logic we can look at all those arguments
find the target method that goes with it
and then save that off cache it store it
in the call site and never have to do
that calculation again so what normally
was an expensive wall
king of all of the arguments before we
can do our call now it gets built in and
optimized as if it was just part of the
JVM to begin with so let's talk about a
few ways that that regular Java
developers might benefit from this or
JVM users will benefit from this
so obviously coming up in the future
we've got new language implementations
dying j/s &amp;amp; nass horn r2 implementations
of JavaScript that are completely
invoked dynamic based taking as much
advantage of invoke dynamic as possible
to optimize JavaScript because there's
really no reason why we shouldn't be
able to have the fastest JavaScript
implementation running on top of the JVM
there's also other languages small talk
actually has two or three
implementations on the JVM now that use
invoke dynamic to optimize a little bit
more interesting for me is taking
existing languages like Ruby and groovy
and Jai thon and finding ways to
optimize them make them run faster we've
always believed that we could make JRuby
be the fastest Ruby implementation in
the world and now with invokedynamic
it's actually starting to happen it's
starting to happen in a major way and of
course I show that off a little bit so
this is going to be a graph I've got for
benchmarks here from left to right we've
got a base64 encoding of a particular
string we've got Richards which is sort
of a VM simulator benchmark does
multiple target methods it does
polymorphic calls those things that a
lot of VMs would find difficult to
optimize sort of a benchmark of the
worst case scenarios for a VM a simple
cs101 neural network and a red-black
tree that will create a large tree
traverse it search it delete elements
out of it and do that multiple times try
and see how fast we can do that purely
implemented in Ruby and every each one
of these cases so if we look at that
JRuby running on Java 6 what we have
here is pretty good numbers we're
definitely faster than the standard Ruby
193 which I believe is still in general
the fastest ruby implementation other
than
it has a bytecode VM but it is not a JIT
version so we want to be faster
obviously we should be faster and these
numbers are pretty good but not as good
as we'd like to see we can say that Jo
is faster but we're only on the over the
edge now if we move to Java 7 we get
invokedynamic in there and the JVM
actually understands how a ruby works
then the things change quite a bit
just by moving our invocation logic our
call logic to invoke dynamic getting the
JVM to better understand how Ruby works
2 3 5 since some cases we've heard about
10 times improvement in the performance
of Ruby code and there are cases where
Ruby code now can actually run as fast
as Java code for certain types of
algorithms and that's that's incredibly
exciting it's something we've known we
always could do but we just needed a
little bit more JVM help to do it and
that's what we get with invokedynamic
all right so I definitely believe invoke
dynamic is the future of Java it's
already changing how the language
evolves with Java 8 lambda stuff now at
this point I could show some examples of
how invokedynamic works some actual code
in the form of method handles and how
they actually function if that would be
interesting or if anybody has any
questions right now we could do that too
so let's take a look a little bit
probably the most interesting bit to
look at is method handles and how you
can build them how you can compose them
together let's bring up the actual Java
Doc's forums you can see whereabouts
they are so again Java 7 or the package
that you'll be looking at is java.lang
invoke a new package that came along
with jsr 2 92 92 method handle is
essentially that that function object
that we've got in hand they like I say
there's various ways to compose them
probably the most interesting aspect is
then when you finally go and invoke it
let's take a look at what the methods
are here enough a little bit all right
so very much like a reflected object of
java.lang reflect method works
we can invoke against a method handle
there's various ways of doing this
invocation invoking with the exact
arguments like for example not doing any
casts not doing any conversions from one
primitive to another or invoking with
arguments allowing it to do some of
those coercion x' for us we get these
from the method handles object so method
handles provides a couple different ways
of getting access to those data
endpoints several of those are on the
met the inner class method handles
lookup take a look at the methods here
so the lookup object is essentially
you'll like your java land class where
you go to get a method or a field or a
constructor in this case we're getting
method handles out so get a constructor
off of a target class with some method
type and the method type is basically
the signature some arguments some return
value that's all there is to it we can
also get getters and setters for fields
regardless of whether a method was
defined as a getter or a setter we can
get essentially what would be like a
field object in the reflection ap is
again all of the all of the typical
invocation styles are here so we have
special we have static and we have
virtual which covers both virtual
indications and interface indications
there are also some convenience methods
so if we have the existing reflected
versions of these we can unreflective
into one of these handles so we can take
a method and turn it into a method
handle or a field and turn it into a
getter setter then we have those in hand
faster than reflection and we can start
wiring them in to invoke dynamic stuff
so the question is is this meant to be a
more modern replacement for reflection
in a large way it is it's meant to be
reflection that the JVM understands in a
large part there are implications of the
current reflection API the fact that no
matter what you do is going to box those
arguments into an array to pass them
through no matter what you do is going
to try to cast them lots of extra logic
in that they've done very good job of
optimizing reflection but still has all
of this extra cruft around it and the
method handle API was intended primarily
to provide a VM level way of getting a
function pointer or a field pointer that
has none of that overhead and you can go
straight into the method yes yeah
exactly and then intended to perform
better because the VM could see it and
optimize it well all right
let's take a look at some code here
think this works look at that tella J
totally deserved that award okay so
let's take a look at a few examples in
actual live code so here is the call
that we're gonna activate we've got a
get property Javadoc home we've
everyone's done something like this
before if we want to do this with the
standard jsr 292 api's we need a lookup
object which we can get through calling
method handles dot lookup now the
interesting thing about the lookup
object is that it's basically like this
is my view into the JVM into these
classes from this point to the code so
if there's something that's private and
I can't call it from here I can't look
it up from here either but if it's
private I can look it up from here give
that handle out and other people can
call a private method because I haven't
explicitly given them access to it so in
this case it's just a public method it's
also a static method so lookup find
static on the system class the method
name is get property and the method type
over here it receives it the first
argument is return value so it returns
string and it takes one string argument
simple enough very similar to the
java.lang reflect api's and how you get
method objects out of them this extra
weight this other way here is using an
API called invoke binder which is which
is our API wrote to kind of simplify
some of this process you as you start
working with method handles you have to
build backward from a target endpoint to
do a lot of those translations and a lot
of the argument manipulation
whereas invoke binder to lets you kind
of go the other direction so mostly the
same at this point here and then once we
have this method handle in hand we can
just invoke it call invoke pass in our
arguments and it does the calls for us
field get another example so we've got
our system out field again a static
field just for simplicity here with any
of these if you were doing this call
against a virtual method or doing this
call against an instance field all you
have to do is essentially pass that
target object as the first argument to
the call it's it really doesn't care in
the JVM level similar to how the
reflection stuff works you pass the
argument that is the class that you want
but the object you want to call against
and then have the additional arguments
if you need them so here we're on our
lookup object again find static getter
on the system class the field is named
out and we're looking for a print stream
and this should be the exact type on the
target class once we have that in hand
we can call that we're just doing a get
here so just invoking it with no
arguments we'll go and get that static
field and again if there was a target
object we'd have invoke against this
object and it would get the field from
the objects just like a would with
reflection it would create a little
structure so here we're calling it
against an instance of an object so we
actually have an instance field here
that we're going to set we're gonna set
the name field look up find setter not a
static static static getter in this case
but a direct center on my struct the
name is name and it's a string that
we're going to be getting out of we're
going to be setting into it here we'll
skip the invoke binder bit invoke it
down here passing an instance of that
struct in and
setting the name value now where it
starts to get interesting is being able
to combine these in different ways
perhaps you have an operation that
always goes and gets a field call some
method and then calls another method
with the result of that one and you want
to have that optimized at the JVM level
rather than generating code for it every
single time if we want to with certain
argument in here so we've got our we're
doing set property this time so we get
our set property method which returns a
string and takes two string arguments in
this case a name and a value now we want
to actually insert one of those values
in there so it's always being used
essentially a currying a value into this
handle we insert my value in here at
index 1 in the argument list and then
from then on we can call it without
passing an 8 arguments into it but it
will still optimize at the JVM level as
if it was a direct method call it just
knows that this value is bound into this
chain bound into this method handle
curried into it and it can be passed
automatically can also drop arguments so
we have a demo 1 class here with let's
go to to args
so the two args method takes in two
arguments and then just basically turns
them into a string form of the array so
we know what we got ok let's go back to
two arts we're getting an instant
getting a reference to that method it
returns a string and takes two string
arguments now in this case we know that
the target the consumer of our method
handle is going to be passing extra
arguments or passing an arguments that
we don't need for this particular case
we can drop that with dropping a string
argument and the second in the two index
so we're passing in three strings we
don't need all three of them we drop the
last one and then we're able to invoke a
method that takes two arguments passing
the three the third argument knowing
that it just gets dropped so this is
when you want to compose the same
argument list and you may be one of
those methods takes two arguments one of
those method takes three you just tell
JVM how to deal with that argument
difference and you can have it all in
one handle on one function that does it
for you permuting is another one that's
kind of interesting it's it's sort of a
sort of an insert and a drop combined
into combined into one in this case what
we pass for building this handle
changing these arguments around is well
just what order and we want we want
those arguments reordered restructured /
muted and you can do it multiple times
so we've got our two arch method again
and we're going to permute the arguments
that come in is we've got three in this
case we're calling it with us two
strings and an integer we don't need the
integer because we know that that target
method doesn't need it and then we're
actually going to reverse the to the
first two arguments so we passed the
indexes in the reverse order the first
the one argument of the zeroeth argument
and then when we call it with one two
and three the three gets dropped the one
in the two get reversed another way that
we can compose these together and
manipulate the arguments as they pass
through the system now folding start to
get a little bit more complicated a lot
of these a lot of these terms come from
functional programming as well so if
you're familiar with left and right
folds we've got that essentially as part
of our functional composition of these
method handles so now we've got a three
yards method which take a look at it
three yards again basically just takes
them and turns them into an array form
string all right so you've got a
reference to our three arts method we're
going to take each of the arguments get
the first letter of each one and then
pass that back in as one as the third
argument so here we've got an initials
method that takes two strings and
essentially just combines the first two
initial characters and door note into a
new string with our three yards
reference we've got our initials
reference
and now we actually do our old old
arguments takes the arguments that are
coming in passes them to your your
folder and aren't in our case that's the
initials method and then whatever the
result is that's a new argument in the
process now we have three arguments in
place down to the bottom we call it with
these two arguments it takes the
initials passes them in as again as the
first argument for the next call and we
get the full three argument form here by
calling just with the two arguments so
lots of ways you can combine this and
again all of this optimizing at the jvm
level rather than having to generate the
code to do this kind of a way of
programmatically generating JVM level
code without doing byte coding without
loading classes in at runtime okay
filter is similar to folding filter lets
you take every argument that you're
passing through this chain and make some
change to it make some modification to
it in this case it's our two arts method
and our filter in this case is going to
be up case every argument that gets
passed in we want to up case it before
we send it on down to the next level
send it on down to the function and as
you expect we call that it does our up
casing and then we get our string out
with up case versions of those all right
spreading I won't really go into right
here spreading and collecting are
essentially the equivalent of doing
variable argument lists we want to
spread a certain number of arguments out
into actual parameters or take a certain
number of incoming parameters and stuff
them into an array for the call again
this is stuff that you could generate as
your own code or that you could write
the Java code for in every single case
but you can build it programmatically
here and the JVM optimizes it is if you
did write that Java code or if you did
generate that bytecode okay a branch
this one's probably worth looking at so
here I'm using invoke binder in this
case and what we actually are
we have a test method that takes all the
arguments in and makes some decision
about returns a boolean in this case
we're using the upper down method as our
test so we're gonna pass in either the
up value or some other value so we're
passing in a 1 or a not one to decide
whether we want to up case or down case
this stuff let's go back so if this test
returns true
this method handle that we were giving
to the branch if this returns true we're
going to call the up case path if it
does not we're going to call the down
case path and so essentially now we've
got a handle or a like a java.lang
reflect method that actually does a test
a boolean test on the incoming arguments
before it branches from there and it
optimizes just like any other piece of
java code or any piece of JVM bytecode
we call with one in my string if up
cases it call it with zero in my string
down cases in this case a switch point
is a little bit different it's a test
that essentially you can only turn off
so if you want it to be absolutely fast
as possible always following the true
case switch points an excellent way to
do it and then when you turn it off it
will follow the false case forever now
the magic of this is that the JVM since
it doesn't knows it doesn't have to do
any calculation on that switch point it
doesn't have to call out to your code to
make that decision it can optimize it as
if the test isn't even there it'll
always follow the true path and once it
does get turned off the JVM will say ok
anybody running this code needs to
re-examine what they're doing pause now
you're going to follow the false case
from now on so you can do these tests
that are extremely fast and optimized as
if there was no test at all as if there
was no logic for the garden before it or
the branching so here in this case we've
got our switch point that we're calling
against the first two times since it's
true the switch point hasn't been
flipped off we can
we'll always call up case every single
time we invalidate that switch point we
say this is now this is about this this
case should always go false from now on
then from then on it will call the other
branch accession and is a little bit
complicated but as you might expect if
you wanted to be able to handle an
exception as part of one of these
handles or as part of what's essentially
a java.lang reflect method you've given
another handle that does the exception
handling logic so if an exception gets
raised when you do this call it will
call back to your code call back to this
other handle and fix it up and be able
to handle the exception for you which
could then re-raise it possibly or it
could follow another exceptional path or
do some different calculation but you
have it all in one box one handle that
you can use for this now okay so that is
kind of the basics of the different
method handles and how you throw them
together let's take a look in a a
different project here that shows
actually using method handles with
invokedynamic
okay get on time so what we're going to
do is we're going to write a little
piece of a voc dynamic code that can
take this car class and call methods
against it dynamically based on a string
based on some new language so we've got
two methods here honk and hello hello
just throws these two things together
and honk just print something out now
our bootstrap here
alright the bootstrap logic is let's
actually go okay so now the bootstrap
you'll see it gets an actual instance of
the method handles look up this is how
it knows where to go get the methods how
to get whatever this is what you use to
bind that that call you've got an invoke
dynamic is coming in it's doing some
call you need to be able to go get the
the target for it you'll have the name
from the call site so whatever that name
was it was actually being passed in and
the method type so very similar to how
you get the method handles what you get
on the bootstrap side of invoke dynamic
is hopefully everything you need to tell
the JVM where to get this data from will
how to call this method so in this case
if our invoke dynamic says that it needs
to call the hello method we're going to
go we've got our lookup object we find
static find the hello method here which
is from the car class and in this case
we're actually going to add some
parameter types to it we're going to add
an additional argument that says from
invoke dynamic so our prefix that gets
attached on here is going to be from
invoke dynamic and we'll stick that on
whatever the object is it's passed it
let's actually step through and you can
see how this works live believe this
okay I'll explain the other half of this
because we're going to do the honk side
so in this case we won't be using the
halt the hallo method will actually want
to call dynamically the honk method will
call the the honk method on our car
object we're going to basically split
that name up this one is sort of a
specially encoded name you can have
these names be pretty much anything they
don't have to be standard Java method
names you're encoding it to say this is
a dynamic call to honk in this case well
split it up and we'll get that last
element because this is the method we
actually want to call we'll look it up
as a virtual method on the car class
with them at the type of gap coming in
as a standard call to this very simple I
think it's just a yeah boy takes no
arguments and then we're just going to
bind that in directly constant call site
basically tells the JVM this is never
going to change you can optimize it as
if this code was basically written in
line at the invokedynamic site all right
so let's go back here okay
so we're actually generating a little
method like I said you can't use any
book can't do invokedynamic directly in
java but we're going to admit some
bytecode here so this bytecode for our
call honk method creates a new instance
of the car and calls the constructor on
it and then dynamically invokes will do
the honk method here
now down at the bottom we actually get a
reference to that we'll just use regular
java.lang reflection for this and we can
call it and watch what it actually does
hopefully this will work properly let's
see all right let's give it a shot
okay I have a feeling it's my freakout
here oops
so I'm sure it works properly okay all
right
that's what I get for changing the demo
Wow I'm doing it okay
instructor me sir I bring this all over
again okay
mm all right look like that demo is not
gonna work like I hoped it would all
right
well are there any other questions and
I'll see if I can't fix this up while
we're talking through its it's a kind of
a difficult abstract thing to think
about especially since you can't do it
in the normal Java code but if I can get
this demo to work should be a little bit
easier yeah go ahead
well so possible security risks that's
actually a pretty good question the fact
that you can get access to private
methods and can get access to
constructors that you normally wouldn't
be able to call would make you think
that maybe there's a security possible a
security problem there but you really
can only give access to those private
methods if you would be able to call
them from that point in the code anyway
the lookup when you get it in hand when
you make that lookup call this one right
here there's a bit of special JVM magic
that's going to say you only have access
to what you normally could call from
this point in the code if you can call
private methods you can call private
methods and if you want to get those
private methods and give those
references out to somebody so be it very
similar to how if you were to create an
inner class at this point it would be
able to call those methods would be able
to call private methods and access
private fields and that's up to you if
you want to give out the keys to your
private code and you're protected code
so it's oh it's still you'd still have
to opt in to any security issue that
would come out of that but it does give
you a way to access those private fields
private methods without the overhead of
an inner class or having some other like
little accessors that are generated like
the java c compiler does you can
basically just give a handle to a
private method to someone that you try
all right well here's what I'll do I'll
promise that I'm gonna have a blog post
about this that walks through the whole
thing and possibly a video to show it
all working but it is a difficult thing
to kind of communicate because it is
very specific to new languages very
specific to new language features like
and like Java eight lambdas but I'm
hoping that I can come up with a couple
good posts about more general cases
general uses of this they'll help
demonstrate why it's useful even if
you're not a language implementer and
that's about all I have</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>