<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Android Lollipop: Bluetooth LE Matures | Coder Coacher - Coaching Coders</title><meta content="Android Lollipop: Bluetooth LE Matures - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Android Lollipop: Bluetooth LE Matures</b></h2><h5 class="post__date">2015-01-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qx55Sa8UZAQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right we'll good afternoon everybody
okay let's try that again good afternoon
everybody
thank you for ending your day with me my
name is Dave Smith and I am here today
to talk to you about Bluetooth le and
more specifically we're going to talk
about some of the changes that have come
about in Bluetooth le
in the api's as we've matured and come
into Android 5.0 and the lollipop
release bluetooth on Android has kind of
a checkered past
you know we first saw Bluetooth api's
show up for applications in 2.0 and
those up those api's were simple but
they were stable and one of the reasons
they were so stable is because the
Bluetooth stack at that time was based
off of a fairly well known and stable
stack called bluesy is anybody here
familiar with bluesy never heard that
before okay a couple of you so it's a
it's a longtime Linux stack for doing
Bluetooth communication inside of the
Linux operating system and it was up
until very very recently the core stack
that Android used as well so all of the
api's that we had early on in Android
were worked quite well
but there were some issues with bluesy
one of the biggest ones had to do with
licensing as is common with a lot of the
pieces in the Linux kernel the bluesy
stack was licensed under the GPL which
is something that is commonly very
unfriendly to Android being a licensed
under Apache there are some issues
associated with that that I won't go
into but essentially in Android 4.2 they
decided that the bluesy stack needed to
go and they were going to replace that
with a completely new implementation
that they called blue droid this was
brought forth by Broadcom and it's
pretty much solely maintained by that
one entity with some help from Google
that was a stack that was apache license
so it was much more friendly to the rest
of the android stack but it was
brand-new so as a result we all saw at
the application level that really from
Android 4.2 on into the future the
Bluetooth stability of Android has taken
a tank and that's primarily because
they've been
starting over from scratch essentially
on the Bluetooth stack and sort of
building their way back up you know on
and from there to kind of coincide with
this we got Bluetooth le ap is at the
application level starting in jelly bean
4.3 so just after they made that change
and as a result many of you who have
probably played around with this have
realized that the original Bluetooth le
API is were pretty shaky themselves you
know they were very finicky they would
kind of work half the time I couldn't
even get a demo to work but you know
they were what we had and we love them
for it as we've moved forward the the
blue droid stack has continued to get a
significant amount of updates and
probably just looking at the commit logs
the amount of changes that have gone
into blue droid from KitKat to lollipop
is probably one of the largest sums I've
seen since it was introduced so they put
a lot of work into blue droid and at
least from the limited experience that
I've had with it so far bluetooth and
bluetooth LE specifically seemed much
much more stable and Android lollipop
and hopefully moving forward okay so
that's good news in addition they've
added a ton of new features which is
what we're going to focus on for the
rest of the talk here today so just a
little background on Bluetooth le for
those who may not have a lot of
experience with it we won't go into too
much detail here but effectively when
we're talking about bluetooth LE
communication there are one of four
roles that any device can main can take
on as part of this communication there's
a central role peripheral role an
observer and a broadcaster now the the
pieces that we have on the right there
the peripheral and the broadcaster those
are devices that are designed to
advertise their presence to other
devices you know out in the out in the
world whereas the central and Observer
are more scanning devices that are
looking for other advertisers around
that they can communicate with the
connect to okay the primary difference
between a peripheral and a broadcaster
is whether or not that device is
connected so you think of a broadcaster
as a device that simply advertises on a
regular basis some packets of data out
into the world and all the interesting
information that they have to say is in
that advertisement packet the the device
is not going
double you can't get any further
information by connecting to it and
trying to you know get further data all
we have is the the advertisement these
are effectively the beacon type devices
that you see from you know a number of
different companies around peripheral
device on the other hand is something
that you can advertise but then a device
can remotely connect to a peripheral and
get further information from what are
called the services and characteristics
on that device and we'll talk about how
all that stuff is put together so it's
kind of the distinction between those
two and then on the opposite side of
that we have central devices which are
devices that scan and look for
peripherals and observers which are
really just listening for those
broadcasts coming off of a beacon type
device okay now the central and observer
role we've had API is to do that stuff
on an Android device since the original
jelly bean release in 4.3 okay so as
soon as we had ble api's those were the
device roles that we were able to enact
on a device now with the lollipop
release they've given us the api's to do
advertising as well and to generate
what's known as a GATT server which
allows us to create peripherals and
broadcasters on Android devices as well
so now from us from an Android device we
can implement any one of the primary ble
roles whereas prior we only were able to
do about half of them okay all right so
just a little bit of the architecture
here so the Bluetooth le operates on
what's known the general attribute or
the gap profile it's basically just a
giant table of key value data where the
keys are unique IDs and the values are
any number of different things and they
just collect themselves together in
logical groupings so generally a single
device would be considered to implement
a single profile now if you're if you're
working with some of the adopted
profiles that the Bluetooth SIG has
defined for interoperability like health
thermometer or proximity profile or some
of those things then that profile and
the pieces underneath it are well
defined you could just as easily define
your own peripheral device that has your
own custom collection of all these
components
and we would still sort of refer to that
overall device configuration as a
profile it's just the top-level element
and underneath that you'll have a
collection of one or more services now
these services can be defined either by
a fully unique ID or UUID or if again
they are part of the adopted profiles
that the Bluetooth SIG defines that will
be defined as a 16-bit what's known as
an assigned number it's still a unique
ID but it's assigned by the Bluetooth
SIG so that everybody knows that each
one of these services has the same ID no
matter what if you want to generate your
own service that does something
completely customer specific you would
create a full unique UUID the 128-bit
version and you would use that to define
your service instead okay
services generally are logical groupings
of functionality so you know there would
be something like a proximity service or
a power service or a time service or
maybe a thermometer service and
underneath that service would be one or
more characteristics that are the
individual values that make up that
logical functionality now there may only
be one but there may be additional ones
like for instance let's take the
thermometer as the example thermometer
service may have a read-only
characteristic that provides whatever
the current temperature value is of the
thermometer now this is the value of
that characteristic there may be a
second characteristic on that same
service that defines the units of the
temperature may be that one is read
writable so that you can configure what
the units are that the temperature is
reported in and maybe if you write that
characteristic the device starts
reporting its temperature back in
different units okay and that's just an
example but you can apply as many
characteristics under a given service
that you would like whatever the
individual points are that you need to
read and/or write on that specific
device okay now every single one of
these elements services and
characteristics each have a unique ID
that's basically that key in the giant
key value table that makes up what we
call the gap table okay
all right so just a little bit about
constructing you you IDs because it
becomes important when you're writing
the code
I mentioned before that there are 16-bit
you IDs for the assigned numbers but
there are also full 128-bit versions it
turns out that if you just took one of
those 16-bit yo IDs and you passed it to
the Android API s it would have no idea
what to do with it because that
designation is not quite correct it
turns out that what actually is going on
is that anytime you have one of those
16-bit UUID is associated with an
adopted profile service or
characteristic that is just shorthand
for the 16 bits that fit inside of this
top UUID that I have listed there
essentially in the red section so inside
of there the actual UUID is the 16 bits
that you're given if you look at
bluetooth documentation inserted into
that larger what they call the common
base for all Bluetooth uu IDs ok so
every adopted profile service
characteristic will have the same base
you UID with those individual elements
filled in so you can see that the
example I have at the bottom there with
the health thermometer which in
Bluetooth documentation is defined just
as hex 1809 the actual UUID you would
need to put in code to connect to that
service is 1809 stuck in that larger
number that I'm not going to read ok
questions on that alright so that's kind
of the basics of getting us up and
running with using ble ok let's talk a
little bit about what's changed from a
year ago to now essentially when we had
the original release and even up through
the KitKat api's some of the
functionality that was available to us
when specifically when it came to ble
scanning the first is that scans were
very limited in terms of the filtering
we could do
so essentially you could from a device
you could start a scan and you could
retrieve events for every ble
advertising device that would be picked
up inside of range regardless of what
that device was you know you had to eat
in your code just determine either by
device ID or by looking at the
advertisement packets with whether or
not that was a device you were actually
interested in there was no assistance
from the
name work to make that easier for you
there was there's essentially only one
option which is you could pass to the
scan request a list of service uu IDs
and ask the framework to only send you a
callback
if a device that advertises one of those
services came about so that you kind of
do some filtering out but it was nothing
more than that okay the other real
detriment that a lot of us saw with the
early ble is that it only allowed for
active scanning basically what I mean by
this is that scanning could only happen
while the device was powered on or fully
powered up you couldn't start a scan and
then let the device go into suspend mode
that would disable the scan essentially
at the same time that functionality was
not drilled low enough into the stack to
be able to have an active scan while the
device was suspended so if you were
running scans all the time you were
basically murdering the users battery
and there was no real balance in there
you either had to set up some sort of a
wakeup schedule and turn scans on
periodically and shut them off or the
device would never be able to go to
sleep okay so that was a big problem
initially another fairly annoying thing
for beacon applications was that if you
started a scan you could only retrieve
one advertisement per device during that
scan so even though a beacon may be
advertising every 10 seconds as soon as
you got the first advertisement the
stack would never deliver the remaining
advertisements to you you had to stop
the scan and start it over again to get
the next one well if a device if all the
device has to tell you is its
advertisement packet you kind of want to
see them all okay and so that was a sort
of a frustrating thing where we'd have
to stop and start scans all the time
just to scan for beacons and then
finally as going along with the
advertisement piece and Google kind of
punted in the first release on this and
they would not give us any parsed data
for advertisement records so the
advertisement data was basically handed
to you in the scan callback as a raw
byte array they said here you figure it
out and the byte arrays weren't even
properly sized half the time you know
advertisement packets are 27 bytes and
usually the arrays were 60 or 70 bytes
for some odd reason they just it didn't
make a whole lot of sense but the data
was there and we could work with it but
it just it was
very finished so fast forward to the
latest release and all of this stuff has
gotten a lot better okay so from the
scanning perspective we now have an
array of filters that we can apply to
scans to let the framework do the
differentiation on what types of
advertisements we actually want to see
we can filter on anything in an
advertisement packet now device name
manufacturer data advertise services
anything that's in that packet we can
filter on and the framework will do the
work instead of us having to put all
that stuff in our code okay batching of
scan results is another really big one
this goes to the power consideration so
that now we we can do a couple things
but with the filtration and the batching
together these are actually sent down to
the down to the hardware abstraction
layer so that the scan filtering and the
the ability to batch multiple scans
together is handled by the hardware so
now the device can fully go into suspend
mode with an active ble scan and then
when the application wakes up at some
later time all the scan results as a
single batch can be delivered to the
application so it allows for much lower
power longer term scanning than we ever
had before with the jelly bean and a
KitKat api's okay
they also fixed the advertisement piece
so now if I run a scan and multiple
advertisements come in from the same
device I can see them all thank you so
we don't have to worry about that
anymore
and then we don't have to do manual work
on scan records anymore there are actual
classes for scan records and
advertisement data that we can call nice
methods on to get out the device name
and the UU IDs and all that stuff okay
so life is much much better than it was
before
okay so then on top of the improvements
the new features that we have really
fall into these two categories so we
have the ability to advertise now from
devices and we have the ability to
instantiate in our application what's
known as a GATT server it's basically
just a way of saying that on my Android
device I can now set up my own table of
services and characteristics and expose
the
to the world for other devices to
connect to me okay those two pieces
together make up what we call peripheral
mode you need both right you know in
fact it's kind of interesting some of
the GATT server api's have been around
since the original jelly bean release
but without advertising there was no
point to them you know they existed but
if you couldn't advertise out your
presence other devices couldn't connect
to you so we kind of needed the whole
package but technically speaking
peripheral mode means you have a GATT
server and you can advertise okay now
this is kind of a yay a moment a little
bit because well we've got this feature
it is required to be implemented at the
chipset level okay so this is a feature
that's it's basically a hardware feature
which means you're probably not going to
see it on every device just because it
gets updated to the lollipop release
okay in fact even with just the Nexus
devices that have been updated already
the Nexus 9 and the Nexus 6 do support
this the Nexus 5 and the Nexus 7 do not
ok so generally speaking just because
the device is getting lollipop doesn't
mean it's immediately going to be able
to advertise they've given you a new new
method to basically you have to check on
the framework to determine whether or
not your device is going to be able to
support this feature ok yes question
the question was there was some
discussion about whether or not it was
the chipset itself or the certification
I don't know the way they've documented
it anyway is that it has to be supported
by the chipset but I think the really
what it means is that the what they've
added is they've added api's at the
hardware abstraction layer and the
device manufacturer for whichever reason
either does or doesn't support those
additional api's but they're they have
to do with the hardware it's not
something that they added in the Android
stack so that just magically gets turned
on for all devices good question though
okay so let's talk a little bit about
the actual API is here so we're going to
walk through some of the code that you
would be using if you were going to
build some of these in your application
so regardless of where you're headed the
class that you're going to start with is
always going to be a Bluetooth adapter
okay now there's a couple different code
paths on this diagram here so the red
code path that I've got on the left hand
side is the way that you would do ble
scanning and jelly bean and KitKat and
then the green path over there on the
other side is the way that we do ble
scanning and the new API is using
lollipop
okay now the old API is do still work so
that's not like you have to run out and
branch your code just so that you can
support ble on the latest release if you
use the older api's they've been shimmed
into the newer ones so that they work
appropriately but you're going to lose
some of the additional features like the
filtering and the batching and some of
those other things when they're
available but the basics are either
directly from the Bluetooth adapter in
the older case you would start an le
scan with a reference to a callback and
that callback would just be handed a new
device every time one that was
advertising was picked up by the scanner
they've moved that into a new class in
lollipop called a Bluetooth le scanner
it works effectively the same way but
now instead of talking to the adapter
you get a scanner from the adapter and
then you call scan on that okay but
other than that the api's are roughly
the same in either case there's still a
scan callback and the result of that
callback is going to be a Bluetooth
device
so Bluetooth device is just a reference
to whatever remote device was found you
can have the name the address and some
other basic information that was
advertised about that device during the
scan okay doesn't mean that you're
connected to anything at this point if
you you need to make additional steps if
you want to start communicating with
that actual device for some of the
filtration and stuff like that as far as
I know they're not planning on doing
anything like that and there aren't any
existing support api's to do that now
yeah so and the idea is I think the
simplest way to solve that problem for
now is to use the older api's if you
have a if you have a use case for the
newer stuff then you at this point you
would need to fork your code to support
that on newer versions only but the
older stuff works fine and you can see
just looking at the log messages on the
device calling the older ap is on a
lollipop device do trigger through a
real scanner so that they're calling the
new stuff you just have no way to insert
a filter mm-hmm okay now if you're
working in a beacon type application
broadcasters observers that sort of
thing that's kind of it that's really
all there is to it you know there's
advertising and scanning and once you've
scanned for the devices and read the
advertisement data you're done you wait
for another advertisement and move on
but if we're talking about clients and
peripherals here then we need to move a
little bit further down the line so once
we find a device that we want to connect
to so this is looking from the client
side or the central side once that
scanning device has found the remote
it's interested in then it will take
that Bluetooth device call the connect
GATT method on it now there's a
difference there because the Bluetooth
device also has a connect method that's
used for the old Bluetooth classic stuff
so something different than what we're
talking about today the connect gap
method and of course past that a
callback will give you a reference to a
Bluetooth GATT instance and once you
have one of those you're connected to
that device and you can start reading
and writing services and characteristics
okay so from the Bluetooth GATT we can
enumerate a number of pieces of
information about that remote device we
can get any one of the Bluetooth GATT
services that
are enumerated you can either list them
all or you can get a specific one by its
UUID and then from a service we can
enumerate all of its characteristics
again get them all or get a specific one
by ID and then from characteristics
descriptors descriptors is another
lower-level discussion that we we
probably won't get into much it's just
another layer of segmenting data
characteristics can have multiple
descriptors they're basically just like
properties okay all of that information
is actually given to us as part of the
connection event so we can query all of
that without having to do anything
asynchronous with the remote device as
soon as we're connected to it we can get
servicing characteristics information
synchronously without any waiting but if
we want to start communicating with the
actual device then this is an
asynchronous process so the with that
connect gap method that we had to
initially deal with we pass it a GAC
callback and that callback instance is
responsible for triggering all of the
events once the remote device has
responded to whatever our request is so
if it's a Bluetooth if it's a
characteristic read or write if it's a
descriptor read or write that we would
make that request of the GATT object and
then sometime later the GATT callback
would trigger an uncharacteristic read
or write or you know to tell us whether
that succeeded or failed and what the
value was okay
now there's an additional layer in here
that I didn't mention earlier for
notifications so this green path that's
in here has to do with characteristic
notifications and that's actually a
really helpful feature if you need to
subscribe to a characteristics value so
inside of Bluetooth le if you are
interested in a specific characteristic
and you want to get the contents of that
value on a regular basis and you want to
know anytime that value changes so that
you can update something on your side
the way that that's done is by
subscribing to that characteristic with
something called a notification so in
the API is the idea is that from your
Bluetooth GATT you would simply ask the
framework to set characteristic
notification true on that specific
characteristic and then anytime the
any whatever GATT server you're
connected to anytime that peripheral
publishes a change to that
characteristic you'll just get a
notification and you can update on your
site you don't have to keep calling read
and some sort of a polling loop or
anything like that okay now there are
some caveats on doing that we'll talk
about them in a little bit but generally
speaking if you're interested in some
value like say a temperature on a
thermometer you want to update the UI
every time it changes you would probably
subscribe to it with a notification okay
now the only difference there is that
the callback there is going to be on
characteristic changed instead of on
characteristic red okay but other than
that it's the same path all right so
advertising this is some of the new
stuff from lollipop so if you have a
device that supports advertising
checking with that method we mentioned
earlier you can get an instance of
bluetooth LE scanners cousin the
bluetooth LE advertiser again from the
adapter and bluetooth LE advertiser
allows you to start an advertisement
using two pieces of information the
advertised data and the advertised
settings advertised data is essentially
the packet that you want to transmit
from this device as the advertisement so
and you these have builder classes
associated with them so you can define
exactly what you want in it you know do
I want to include the device name
include the transmit power level of my
device all these pieces that you want to
add up keeping in mind that
advertisement packets are limited in
size I mentioned before they're about 27
bytes and the framework will tell you if
you've built an advertised data that is
too big to fit in that packet when you
attempt to advertise you'll get an error
code that says advertised data too large
or something like that so you have to
you have to play around with this a
little bit make sure that the data
you're trying to stuff in will actually
fit okay and in addition to that you
give it the settings which really just
defines what transmit power you want to
use which is basically just defining how
how much distance you want to be able to
cover with the with the Chad vert Iseman
whether or not the device should be
connectable so this is going to be
different whether you're talking about a
peripheral situation versus a beacon or
a broadcaster the timeout associated
with it if you ignore the time out you
can just broadcast can advertise
continuously until you decide to stop or
you can set a time
that says only advertise for say the
next 30 seconds and then the framework
will shut that down for you okay and
then a latency mode which is really just
a couple constants to define the
difference between low power versus low
latency which is really just how often
do you want to advertise low latency is
going to be advertising very quickly
maybe even multiple times a second
whereas low power is going to be much
much less often okay all right now if
you are using the older AP is I figured
I would leave this slide in just for you
folks you may still find yourself having
to parse scan record data manually so I
want to just briefly go over what that
is so this is the method that's in the
scan callback that you would see on the
jelly bean or KitKat AP is whenever a
new device is picked up by a scan and
notice that we have the device the
receive signal and this raw byte array
that represents the advertisement data
called the scan record now in those
releases we didn't have any classes to
parse them so you have to manually chunk
through it yourself really all this data
is is it's just an array of these
advertisement data structures which are
just these little payloads consisting of
a length type and then a variable
payload of whatever the length was
defined in the first one so it's fairly
easy to parse through you just have to
realize what's in there and do it
yourself
and the types themselves are defined
again by the Bluetooth SIG and each type
identifier will be device name service
uu IDs you know all those pieces that we
talked about before you could stick in
one you just have to go through the
process of chunking them out yourself I
won't probably be going through it today
but in the example repo that I've given
you there is a sample parser for
chunking through those things that was
used back on the older API is to do some
of these examples okay all right so then
just a couple things that are good to
know that you probably won't see in the
documentation anywhere there are a
couple hard constants that are defined
inside the blue droids tract and these
have evolved a little bit over time so
it's interesting to note based on the
version you're trying to support as well
the first is that there is a constant
defined for the maximum number of
concurrent notifications you can be read
stirred for so as a client you can only
register for a maximum of four
concurrent notifications I means you can
be registered or subscribed to four
different characteristics to be notified
on you know for any given event that
number was four in jellybean it was
increased to seven in KitKat and as of
the lollipop release they bumped it up
to 15 okay
so depending on which Android version
you're running on your device may fail
to subscribe for a notification if
you've already hit that limit okay
so just something to keep in mind then
additionally to that there's another
constant they've defined which is the
maximum number of connections so as a
client I can connect to multiple
multiple peripherals at the same time I
can connect to this device then scan and
connect to another one without having to
disconnect from the other that maximum
again has been a bit variable it was
started out as for in jellybean evolved
to seven in KitKat but this one has
stayed there so even in lollipop seven
is still the maximum number of devices
you can connect to at any one time you
wanted to connect to another device
you'd have to disconnect from another
one first question
sure so the question was are those
software those are software limits is
there anything in hardware the answer is
not as far as I know so you're right
that those limits are they're hard-coded
constants in the Bluetooth stack now
because of that and because they're not
in any of the hardware abstraction
pieces they're going to be the same on
every device so this doesn't mean that
these are numbers that manufacturers can
define based on whatever you know piece
of hardware they've chosen to implement
their Bluetooth on they will be
consistent but they are defined in
software and as far as I know they're
not defined that way because of any
specific hardware limitations I'm not
really sure why they chose those numbers
but that's the numbers that are in the
stack for sure good question one more
question
that's a good question the question was
is that at the platform level or per app
that is for the entire stack yes good
question
okay yes one more ask the question again
I didn't quite hear the last part good
question so does the system coalesce
filters together
the answer is it's up to the device
manufacturer because that specific piece
that they've added in lollipop is is
part of the hardware abstraction layer
so it's up to each manufacturer to
implement their there Hal driver
essentially as to how they would manage
that on chip so some might some might
not it's up to them
good question okay so let's jump into
some of the examples
all right so I've got a couple examples
to show you and what I'll probably do is
show you the example first and then
we'll walk through the code so let me
switch over here okay so the first
example that I'm going to show you is I
have one in my hand and a couple around
the room these little key fob beacon
devices these are made by a company near
us called KST and this is just it's a
simple little temperature sensing beacon
so it has a temperature sensor on it and
it advertises that temperature value
constantly so that we can read that back
from other devices and I've got them
around the room and I've got one up here
so I've got a little Android application
that I will bring on screen for you that
simply broadcast or simply goes out and
scans for these devices and then
displays them in a list here now this is
just it's constantly scanning and as the
advertisements come in we'll see the the
data inside of this list update so it
just displays the device name the
temperature value that was advertised in
the packet and the device address and
some other information and the coloring
is based on the temperature so as the
number gets higher it gets closer to red
and closer to bleed because I'm a great
UI designer and that's the way I put it
together so this is a basic example of
monitoring other beacon devices that are
advertising their data but what I can
add to this is if I flip on my Nexus 9
here now you all know my password I can
flip on another example that I have here
which is an advertiser and as soon as I
do that you see the Nexus 9 shows up in
this list as well so the Nexus 9 is I
have another application that I've coded
to do the same advertising packet format
as these little beacons the only
difference is I've wrote a little app
that I can control whatever the fake
temperature is and every time I hit the
Update button it will change the change
what that advertisement is to the new
data I can try let's see if autofocus
works I may not be able to
the better or worse yeah right well
we'll have to stick with that sorry what
so if because of the focus which you may
or may not be able to read those of you
up close may be able to see it but as I
change this value not only does the
temperature value change but the device
address is actually going to change too
and you'll see why that's the case
inside of the code but it turns out that
every time the every time we restart a
new advertisement with the new AP is it
actually uses MAC address randomization
so it doesn't use a hardware MAC address
it generates a new one so every time I
start a new advertisement it will
generate a new address something it's
very important to realize if you're
expecting that to be the same on every
device don't know
I mean beacon devices use that as a
security mechanism but they tend to do
that in a pattern like there are some
beacons that will randomize their MAC
address but they do it every so often
this only happens when I manually start
and stop a new advertisement so I think
it's just part of a new advertisement
gets a new instance and moves on from
there
yeah yeah I think so yes
well my phone does but it's because I'm
looking for the device name so the in
this in this specific case I can rely on
the device name as the only exact unique
piece that I'll get in every
advertisement okay so let me flip over
to the code and we'll see how that works
yes and no so one of the pieces the
question was is there a way to detect
distance one of the pieces of
information that you put inside of an
advertisement is the transmit power
level the reason that they do that is so
you can do some basic calculations
between transmit power and the received
signal strength to try and make a rough
determination of distance now obviously
all the factors between is it through a
wall you know is it raining out all that
stuff is going to give you not allow you
to get an exact number but the the RSSI
by itself is not enough you have to know
the transmit power to be able to figure
out the difference and so in
proximity-based ble loca situations
those have the transmit power defined in
their advertisement so they can do that
math the the beacons that are made by
the Cupertino Fruit Company essentially
that's how they're near or far that type
of stuff works it's based off of that
difference good question okay so let's
start with the scanning piece and I'll
show you both pieces here open up some
classes so I can take that off alright
so first thing to realize is when you're
working with these api's they're not
going to be supported on every device so
you're going to want to make sure that
if nothing else inside of your
applications manifest you declare
whether or not you require use of heart
of bluetooth LE and you can do that
using one of these standard uses feature
declarations that you know we've used a
million times before defining whether or
not it should be required now in this
case because this is required this means
that places like the Play Store are
going to filter out my app from device
that don't have these features right so
I get some assistance there if you don't
want to force that level you can always
do this as a non required check and you
can check at run time if you just want
to disable certain portions of your
application based on whether or not that
support exists I'll show you that code
in a minute you're also going to need to
make sure that you have the Bluetooth
and Bluetooth admin permission you're
not going to be able to pretty much any
of this without both of those okay all
right so first piece that we'll look at
here this is the again this is the
scanning device so this is the one I had
running on the handset that was going
out and looking for the different
beacons so a couple of pieces that we're
going to need we're going to need our
Bluetooth adapter Bluetooth adapter
always comes from the bluetooth Manager
system service okay so we just we get
service we get the adapter and in
lollypops case we get a reference to
that scanner from the adapter okay so
those are the pieces we're just going to
need to have hold on to then to do some
basic checking here anytime we move into
the foreground in this app I'm going to
verify that this device has the support
it needs first so the first thing I'm
going to make sure is is bluetooth even
on
okay so just basic check about whether I
got an adapter or whether the adapter
says things are enabled if neither of
those are the case the framework
provides an intent you can fire the user
into settings to turn bluetooth on first
okay otherwise none of this is going to
work then additionally if you wanted to
check for Bluetooth le support at
runtime you could do that by asking the
package manager for that feature this
does the same check as what I put in the
manifest this is just doing it at run
time if you maybe didn't want this to be
a hard check maybe you just want to shut
off this part of your app then you could
do it this way instead okay and then
we're just going to start a scan so as
long as this app is in the foreground it
is scanning and the way that this works
is our Bluetooth le scanner just takes
these three pieces of information that
to define what the scan should be so
it's the scan filter the scan settings
and the callback okay so the scan filter
defines any information that we want to
tell the framework these are the
specific devices I'm interested
I could add things like device name and
other pieces in there as well all I'm
interested in is I only want you to give
me devices that advertise that one
service that I was talking about which
has the temperature data in it okay
which is what all these beacons do all
these beacons advertise that temperature
data inside of a thermometer service and
so I have that UUID for that service
defined as a constant somewhere and then
that that information I only want
devices that are advertising that
specific service and then the settings
are used to define the the data about
the scan you know should I do
low latency scan a low-power scan you
know that type of information so that I
can a low latency scan is going to pick
up devices much quicker but I'm
obviously only going to want to do that
if I'm in the foreground a low-power
scan would be the type of scan I that I
could run and then the user could leave
the app shut down their device and the
scan could still run safely without
completely destroying the battery okay
so there's a couple different options in
there that you can pick from and then
the callback is just where you're going
to get more information as the scan
progresses so we start the scan and then
the information will come inside of this
callback now there's one of two options
there's scan result and there's batch
scan results so I mentioned that if in
the scan settings I had enabled batching
the way that I do that is by telling it
to delay scans by a certain amount of
time and that tells the framework that
it can batch results up to that amount
and then deliver them all at once if I
had done that then the callbacks would
come in here as a group but in this
application it turns out they all end up
coming through individually one at a
time while we're in the foreground so
each one of these scan results has a
fully nicely parsed scan result object
that I can look at no more raw byte
arrays and so inside of this little
helper I've created I basically just
take the scan record from that
advertisement and I construct another
model object for it I just call it a
temperature beacon so I can jump into
the beacon real quick and we can see
that really all this is is just a piece
of data that holds the received signal
address device name and the current
temperature value and so those values
are pulled out of that scan
record again I can get them very nicely
from the framework by saying I would
like the device name please I would like
the service data associated with that
UUID and it does all the work of parsing
through the byte array finding the right
chunk and returning back the value that
I need okay so that's all done for us
now this the structure of the service
data in this case is custom right like
it's not defined by the Bluetooth SIG or
anything it's defined by the guys over
at KST that made these things they
basically said that inside of their
advertisement for this service the the
value for the temperature will just be a
2 byte packet basically will be the
degrees in Celsius where the high byte
is the actual degree and the low byte
will be 0 or 1 based on whether or not
it's 0.5 they only have half a degree
resolution on their temperature sensor
okay so they define that they tell me
what it is I put it in okay if we were
building an application around an
adopted profile we would get all that
data out of the profile spec from the
Bluetooth SIG okay yeah the the
advertisement data record is 27 bytes
yeah so the idea is that the entire
advertisement is 27 bytes what you fill
it up with is is not really defined so
if you only had that one element in your
add data it could be 27 bytes of service
data if you added the device name that
would truncate how much space you had so
it doesn't really matter each one
doesn't have a specific space as long as
the sum total of them is not larger than
the packet size you know I have not done
testing to know how quickly android
advertises on the low latency mode
basically you set it to low latency and
that advertises as fast as android is
willing my guess is it's definitely more
than a few times a second but I haven't
actually timed it yet they don't they
don't document what that actually is
so good question okay so we're just
taking this data out of every
advertisement we get and then we're just
throwing it into that list that you saw
in the UI every time I get a new
advertisement I just replace that
existing element in the list and update
it so you can see the result now
something to point out here and this is
true kind of across all of the Bluetooth
le
max but the none of these callbacks will
come to you on the UI thread okay so if
you want to do anything in a scan
callback a gat callback anything you
want to do anything touching the UI
you're going to have to post that result
using a handler or some other mechanism
to get that on to the main thread before
you try to touch of you okay so for
instance in this case I'm taking that
data and I'm sticking it into my list
adapter that I created but I have to do
that by posting a message to a handler
on the main thread I can't do that
directly inside of my scan result
callback it will fail okay it'll tell me
that I can't touch a view because I'm on
the wrong thread and all that fun stuff
we've seen a million times so just keep
that in mind okay questions so far yes
correct the stack defines that limit
well essentially the indication is when
you attempt to do so you'll get a
failure no no the failure to make either
the the next connection or subscribe to
that next notification so that that
attempt will fail now I will admit that
at least on the connection side the
return code is not real obvious to the
fact that that's the reason why they
just give you a generic failure that you
can't really determine that beyond maybe
much any other failure but at least
that's what you can look for is you
attempt to connect to a device and it
fails and you'll know internally that's
why not really no the only failure code
there's only two return codes for that
right now there's got success and got
failure hopefully they will add some
more that's time good luck no that would
be a disconnect so we'll talk
well so if if we're talking about a
situation like this where there's no
connection made then something goes out
of range only thing that's going to
happen is you're going to stop seeing
the advertisements from that device in a
connection case well if you're connected
to it and it goes out of range you will
see a disconnection event you try to
connect to them that would fail it would
be the same yes as far as I know you
guys distinguish whether you're max to
my knowledge that's correct yes okay all
right so then just quickly here this is
the same example using the older AP is
so that this example runs on older
devices as well as a new device and if
you run it on say a jelly bean or a
KitKat device it's going to launch this
activity instead excuse me and so that
the functionality is pretty much the
same I just want to quickly run you
through the difference in the API so you
can kind of see it if you've never used
the older api's before basically we
still get a reference to our Bluetooth
adapter but there's no scanner anymore
it turns out in the older API is the
bluetooth LE scanner didn't exist we did
this a different way all of this code to
check for Bluetooth is the same and as
far as setting up the scan we instead
would have called start le scan directly
on the adapter okay and we still pass a
callback and we still have the
opportunity to do some filtering but the
only filter it supports is a list of uu
IDs for services we can't filter on
anything else in the older versions just
turns out in this case that's all it
need so I am actually leveraging that in
this case now the other thing that's
going on in this older example based on
this block of code that you can see here
is that because I can't see all the
advertisements unless I keep stopping
the scan we have this runnable set up
that basically starts the scan for five
minutes then shuts it off and then for
two seconds turns it back on and just
toggles it back and forth while we're in
the foreground the reason again is
because if I didn't do that on older
versions I would see one advertisement
from all my beacons and that's it so I
wouldn't be able to continue to get
those updates of whatever the current
temperature is as I stopped and started
again
luckily that's been fixed but if you
have to deal with that on older
platforms you have to do a mitigation
strategy kind of like this okay and then
similar thing with the scan but back in
the old days we had to parse these
things by ourselves so we got that raw
value and I just have a very simple
parser in here that you're welcome to
look through later on it basically just
chunks through those 80 records in this
raw byte array and turns them into a
simple structure that you can get things
like the name or the service data or
stuff like that from okay so if you want
to see an example of how to parse the
data yourself if you need it there's one
in here I'm not going to spend too much
time on it now and luckily if you're
supporting only Ollie pop it's done for
you okay so let's take a look at the
advertising side so what happened when I
flipped on my Nexus 9 and it magically
added itself to the list of devices that
I could see I go to my other project
here my advertiser
you'll see it's actually pretty dead
simple okay so we have the simple
activity and that's the one that had the
slider on it so I could set the
temperature and hit the button and go
from there in this case I have the
Bluetooth le advertiser off of the
adapter and then any time we're in the
foreground going to check those same
support issues now there's one more to
check this time I need to make sure that
the device I'm running on supports
advertisement because that's different
than just supporting the ble api's okay
so that's checking whether or not this
multiple advertisement is supported
method if not then this is no good to me
I can't do this on this device okay so
inside of the advertising same basic
format I have a settings and a data the
settings defines the the information
about the advertisement the mode is how
frequent you know so you know low power
versus low latency is this device
connectible in this case no because we
want this to act as more of a beacon I'm
just advertising data I'm not setting up
any connect ability here timeout 0 means
advertise forever but if I want to set
this
to an actual value I can tell this to
timeout after say fifteen or thirty
seconds and stop advertising at that
point okay if I just want to do this in
short bursts and then what's the
transmit power I want for the
advertisement there's a low medium and
high setting okay
the ad data I want to make sure the
device name is in there in this case I
added the transmit power level and the
data that I'm including is that current
temperature value so whatever was set on
that slider and the UI gets packed into
that two byte array that I defined
earlier as part of the KST protocol and
that gets added as the service data for
this advertisement and it just gets
built all together into an ad data
packet and then using my advertiser I
tell it to start advertising and that's
pretty much it there is a callback
but the callback only exists to tell you
whether or not you succeeded to start
advertising or whether there was a
failure okay now multiple applications
can be advertising at the same time so
one of the reasons that you might get a
failure is there's a maximum of I
believe it's for applications that can
advertise at any given moment so and
luckily they did a little bit better job
with the error codes here in this case
if you fail because there are too many
advertisers already it will tell you
that you also can't restart an
advertisement to the same callback so if
I called start advertise and then called
it again later I'd get another error
saying that I'm already advertising you
know for this particular instance okay
so you only have one of those in any
given time so a little bit better error
handling in the new stuff but other than
that not a whole lot of interesting to
really see here and so this data is just
going to advertise constantly just like
my other beacons now one thing to note
is these advertisement data packets are
immutable you know the only way to
create one is using this builder I can't
hold on to a reference and say well
actually I'm going to change the temp to
this now and do all those things on the
fly to modify what's going on inside of
the advertisement so what I have to do
unfortunately and this is why you saw
the MAC address change every time I
updated the the piece there is that in
order to modify the ad data
I have to start a new advertisement okay
so that I can create a new ad data
object and I can pass that to start
advertise against oh in side of the
click handler for that specific button
that I was clicking there's basically
just a method that I use to stop the
current advertisement and start a new
one with whatever the current data is
inside of the UI okay that's a little
bit unfortunate maybe that will get
fixed in another version but at least
for now the advertisement data you
provide to the framework is static if
you want to change it you have to
restart your advertisement with new data
okay yes question ibeacon is all about
proximity right it's how far away are
you from some thing and then there's
some unique identifying information
about what that thing is this is
essentially could be the same idea right
I could have this at the front of a
store or something like that where that
I need to uniquely identify this thing
and have other devices be able to
determine how far they are away from
this specific maybe point of sale or
something like that and in order to do
that this has to be advertising
information like where it is and how the
current power level so that people can
determine proximity that's just one
example kind of stealing from what
Apple's doing but you know maybe there
are others as well
okay so the next example that I'm going
to show you is a little more involved
and it might be hard to see with the
lack of focus on here but we'll see so
what I'm what I've got defined here is
now I'm going to show you a basic client
peripheral communication so I've got the
the nexus 9 is going to have an
application on that's going to set up a
GATT server and it's going to provide
some very basic information it's just a
very simple server that has one service
and two characteristics and the
characteristics are going to define how
much time has elapsed elapsed since some
given offset and then another
characteristic that allows you to set
when that offset was okay so some very
basic information and at anytime another
device couldn't query that service to
get either one of those pieces of
information okay so the the gap
peripheral has pretty much no UI on it
in this case all that is going to show
up on this screen is any time a device
next to this server it's going to show
that device in the list okay the the UI
that hopefully you'll be able to see
okay is actually going to be on this
device and actually what I might do is
just put them on top of each other as
you can see it a little better but
basically I just have a couple buttons
where I can use this information to get
the current value of the characteristics
and in the case of the offset value I
can there's a little bit of UI in here
that I can use to set the current offset
that should be resident on the server
device okay it's probably easier to
explain if I just run it so first thing
I have up here in the corner is a Scan
button and that will run a scan for any
devices in the area and since my server
is active its advertising so it shows up
in the list here as my Nexus 9 and then
I can connect to that device and you see
it shows up here in the list and then
what's what shows up down here is a
current time value so basically what
we're seeing is the number of seconds
that have elapsed since whatever the
offset is right now the offset is zero
so that's what January 1st 1970 or
whatever that is in Pacific time but
I've got some basic pieces in here we're
using this Update button I can set what
the new offset should be so I'm going to
say why I'd like to figure out how much
time is elapsed since let's say well now
let's go back since 455 so five minutes
ago and that will go to the device you
can see there's a little notification on
the server device that says it received
that characteristic right and then the
data that shows up in that in that
counter is now based off of the time the
time that has elapsed since five minutes
ago and now based on this device is
current clock okay now the other thing
that's going on which you may or may not
be able to see because of the focus is
that every few seconds it's counting up
okay and that's going on using a
notification so this client device has
subscribed to that characteristic to say
any time this characteristic changes
notify me so I can update the UI and so
the changes are not going on because the
client is constantly polling the server
the server is triggering a notification
every so often when it decides that
something has changed okay on the server
so the the server basically that that's
a value that gets passed over to the
server then the server does the math of
current time versus what you gave me and
returns that back as a characteristic
okay so just kind of a semi contrived
simple example okay have I I'm sorry ask
that question again no no I haven't you
like how quickly I can pump
notifications before they're not get
received anymore no I have I imagine
it's actually pretty responsive but I
haven't timed it right now it's
happening every two seconds I think I
could probably safely do it without any
concern a couple times a second but I
haven't really tested that all right so
let's look at the code for this example
so we've got two activities one for the
peripheral and one for the client and as
I mentioned I've just defined just a
very basic GATT server with a service
and two characteristics one for the
elapsed time and one for the offset that
it should compute the elapsed time from
okay these are just uu IDs since this
has nothing to do with any adopted
profiles I just generated my own uu IDs
you know if you have a Mac or Linux
system you just run UUID gen on the
command line and take the output right
or you can generate them any way you
like so we just have those three
parameters defined for this piece here
so on the peripheral side some of the
same code we've seen before because the
first thing we have to do is set up
advertising so that other devices can
find it and connect to it so all those
pieces are the same so we're still going
to have our Bluetooth adapter and our
Bluetooth adapter is still going to have
a reference to a bluetooth LE advertiser
all those pieces are the same as they
were before
what's new is now I'm also generating an
instance of a Bluetooth GATT server okay
and this is generated by calling open
GATT server on the Bluetooth manager and
giving it a call
back okay now the GATT server callback
is going to be responsible for handling
all the incoming requests so anytime a
characteristic read request write
request anything like that it's going to
be coming in through that callback okay
so we just call open GATT server and
that registers that instance with the
framework I have to do a little bit more
work here which is I have to define on
the server the services and
characteristics okay so this gets a
little code heavy I almost wish I could
do this in XML but basically I can
define the service that I need using
that UUID
and a characteristic for each one of my
elapsed time in my offset okay and I
just passed the UUID for that
characteristic or service and the
properties associated with it so my
elapsed time characteristic is defined
to be read-only so it's only defined to
have the read permission on it and it
also supports notifications so clients
can subscribe to this for the purposes
of notification you have to define that
as property on the characteristic the
other one is readable and writable so I
have to define the properties and
permissions on both of those if you
don't do this and you try to read or
write the characteristic it's just going
to fail okay so it's important to get
these bits set appropriately add the
characteristics to the service at the
service to the server yes well no you
don't set that up here and maybe we can
talk about that a little more detail
offline because that that's a property
you define on the actual write as
opposed to any characteristic okay so we
define that server and it's initialized
so now anytime a device attempts to
connect to this we and tries to query
for one of these services or
characteristics the framework will route
those requests to our application
because we've told the framework about
our server and it knows what services
and characteristics are on it okay all
right so then we jump down to the
advertisement piece real quick there it
is
advertising code not really any
different we're advertising our one
service so that other clients can filter
on it that's just making it easier on
them we include the device name there
and then we pass that advertisement off
okay so this is just advertising all the
time now the one thing that's different
here that's important this is a
connectible advertisement okay if I
forget to set this because it defaults
to false I've essentially turned this
nice server I created into a beacon
nobody's going to connect to it okay so
that's important to realize all right so
that's all set up and then eventually
later on when clients connect to me and
do all these other things we'll start
seeing events going on in the callback
so I'll just go through those quickly
here so the callback has methods like
connection state change this tells me
that a device has either connected or
disconnected from my server so I can
check which one of those events it is
and in this case I'm just posting that
to the UI so that it can add it or
remove it from that list okay nothing
crazy there characteristic read requests
this happens anytime one of the clients
asks to read one of my characteristics
off of that service so I have to figure
out first of all which characteristic
were they asking for are they asking for
my elapsed time or my offset value and
then send back a response to the device
using the API s so there's a send
response method that I use to provide
the value to the read request for
whatever the characteristic is now read
requests by default require a response
from the service so even if for some
reason somebody sends a read request to
my device that it has a service or
characteristic that I don't understand
it's not part of my device even if that
manages to happen you want to make sure
that as a default you always send some
response back or that could essentially
lock up the client waiting for a timeout
or something like that on the other side
so in this case I'm sending back a
failure with no data but you want to
make sure to handle that case as well
okay and then characteristic write
requests we have one characteristic
that's writable and it's that offset
value so if a client attempts to write
to the offset then we'll Pat we need to
make sure that that's the characteristic
they're asking for and then we can steal
the value out of the characteristic now
notice that the the value from the write
request is
not in the characteristic object it's
given to you separately don't ask me why
they did that but if you call get value
on this characteristic it will be null
the value they attempted to write is
right here okay now the question was
asked about right no response versus a
default right in on the server side that
determination is made using this value
so if the right was made with the no
response bit set this will be false
otherwise this will be true so on a
server you're simply responsible for
determining do I need to send a response
and if I do same thing as we did with
the read okay then the idea of setting
that or not sending it is responsible in
the client-side okay and then we pop
that toast that some of you may have
seen when the offset actually went
through sure so we're going to see the
client in a second but yeah the question
was does on write on the client-side get
called on write on the client-side gets
called when the response comes back
essentially so question
you know to be honest to be super robust
probably generally speaking you should
never see those because the framework
shouldn't route them to your
applications callback since they're not
defined as a service or characteristic
on your server but kind of like I did
before if for some reason something
happened you'd want to have a catch-all
in there so you probably would want to
have a maybe a response error or
something that gets thrown back it's
probably good practice okay last thing
in here is the notification so what a
couple things happen anytime the right
happens or inside of this server to sort
of mimic a change because I mean since
I'm basically giving an elapsed time
basically it changes every second but
I've decided that I'm not going to
trigger the notification that often
instead I'm just running a simple
handler that pulls every two seconds and
so every two seconds we're faking a way
of saying yes the characteristic has
changed okay it changed again and so
either every two seconds or any time the
offset has changed we just passed this
notify method here which goes through
and for that one characteristic passes
the current value and calls this notify
characteristic changed method to all the
connected devices that I have okay and
then any devices it's kind of nice from
this side I can just do it to any
connected device I've seen and the
framework will deal with whether or not
they've actually subscribed on the
client side and determine whether or not
they have to get pushed in okay so I can
just notify everybody that a change has
occurred and go from there okay real
quick we'll go through the client side
so client side looks very very similar
the one major difference comes inside of
the the connection in the communication
but very briefly I'll show you the the
scanning piece so here inside of this
we're we're using our Bluetooth le
scanner again looking for those
advertisement packets coming from our
device we're looking for only devices
that have our custom service advertised
so that way we fill
throughout everything else we don't care
about and then inside of the scan result
we're just going to add those to a
collection which is what was showing up
inside of the overflow menu up there so
I had the scan button in the overflow
and then the the options menu basically
just defines the overflow to be my scan
button plus a button for every device
that I have in my collection okay so as
they scan they just pop in there it's
just an easy way for me to keep it off
the UI so when I selected that Nexus 9
out of the overflow that's when it
attempted to make the device connection
so from that Bluetooth device connect
gap give it the call back and the call
back has very similar methods on it you
know on connection state change services
discover it I'll talk about that in a
minute
characteristic read and and in this case
characteristic change now there are
other methods on here that I'm not over
writing because I don't need to you know
there's on characteristic right on
descriptor read and write all those
other ones I showed you in the slide
basically there's just a simple setup
here where from the client side when I
attempt to make that connection
initially I will see that here in
connection state change telling me that
I've connected to the server so great as
soon as I've connected next thing I'm
going to do is attempt to discover
services I want to know all the services
on this device to make sure that the one
I'm interested in is actually there ok
so that is going to trigger again
another asynchronous call on services
discovered so in that case I'm going to
loop through all the services that I
find make sure that I have the right
service available to me and then I'm
going to attempt to read that elapsed
time characteristic from that service ok
so this is all just happening one after
the other this isn't as a result of me
clicking a button or anything like that
then the read characteristic method is
going to trigger the on characteristic
read yet another callback right so this
will get triggered a couple different
times throughout the app but essentially
inside of here is where I can determine
if the characteristic result that I get
back was for the elapsed time pop that
into that text field in the UI and if it
was the offset value then I actually
display that date somewhere else in the
UI too
so anytime I get a read back from either
one of these I'm going to just pop them
up into the UI again using a handler
because this is not the main threat okay
remember that the other thing that I'm
doing is for this elapsed time as soon
as I've gotten the initial read I enable
notifications on that call okay so this
now I don't have to read this
characteristic anymore any time the
server calls that to notify
characteristic change that we just saw
I'm going to get a call here that's all
set up at this point okay and in that
case it's going to come through on
characteristic changed instead of on
characteristic read so I have the same
basic block of code in there where it
just pushes that value up to the text
for now so you can see it in the UI so
for every notification or for the
initial read is just updating that
counter with the new data okay and then
the final thing that we saw was that I
could push that little button to set the
new time offset and it would fire that
off to the device okay that was inside
of this update button and this is just
some basic code that showed that
dialogue and then once I get whatever
the timestamp was from that dialog that
was set up we get our characteristic
from our service we set that
characteristics value and we tell the
server we would like to write that
characteristic on the server okay and
then that's where it updates that piece
and then remember the code on the server
side as soon as a write happened it
triggered a notification so that's why
immediately on the client side I saw the
update okay
questions on that
I finished exactly on time so thank you
so I don't know if they need this room
or not but obviously if you guys have
questions maybe just come up here and
we'll chat about this stuff so that
other people can clear out so come on up
so the sample code is on github and the
link to that is in the slides</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>