<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Fixing Code at 100mph: Techniques to Improve How You Debug Servers | Coder Coacher - Coaching Coders</title><meta content="Fixing Code at 100mph: Techniques to Improve How You Debug Servers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Fixing Code at 100mph: Techniques to Improve How You Debug Servers</b></h2><h5 class="post__date">2015-01-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7KS4L-mA_-c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">sounds good
alright thanks and thanks everybody for
coming down and this time Pratap I meet
a group for having us and heavy bid and
all the good people who have helped so
without further ado let's get into it so
a bit about me Sasha said I'm one of the
founders at Sachi P I've been writing
code for the past I'd say 16 years my
background is in real time and high
school systems in aerospace which I did
for like eight years so a lot of work in
C++ Java real time stuff then our first
company was also build out both products
for architects and engineers but like
global architects and engineers they
kind of build bridges and airports and
those those kind of interesting things
just actually through the process of
scaling out that service which today
hosts I think like 50 million people
that we came across some of the pain
points and challenges there comes Brosky
at the idea of to keep it with a strong
emphasis on the word pain what we really
wanted to have is like and always we
wanted something essentially that would
tell us when and why code breaks in
productions we built this kind of
always-on debugger which tells you you
know when something bad happens in
production at scale water is what's the
source code what's the variable state it
actually caused that air to be and let
you paradise that very efficiently and
what I want to talk about today really
it's less about that or really about
some really efficient techniques that
have to do with being able to debug code
at scale in production much more
efficiently based on research that we've
done and the experience we've accumulate
as a team over the years and working
with our many customers and share those
techniques with you to hopefully you
guys will find them useful to your
everyday work in general check out the
blog it's a key P it's not a product
blog additionally all the stuff they're
talking about today is based on research
that we do we publish there a lot of
benchmarks a lot of things about new
ways to debug and new ways to
essentially deploy and work that code at
scale now
one note weathers brought up here is how
to pronounce the names I'm definitely
going to go into that for those of you
which are kind of curious let's see how
this thing works
this is taki and this is key P and
they're essentially how we named their
company so it's a two key P and they're
the company dog so this is kind of
people are curious about the name this
is the reason why alright let's get into
it
this clicker clicking its clicking
alright so I want to talk about today
about a few techniques for production
debugging some of those which I can you
know are very I wouldn't say
foundational but something that I know
we've seen a lot of people use and and
we use in our everyday work and we feel
that are very kind of helpful to people
so we cannot talk about them and then
we're going to go to start going more
and more into some deeper more advanced
stuff okay which is also very
interesting it kind of shows you how the
JVM works kind of behind the scenes so a
lot of interesting stuff around that the
thirst the first thing going to talk
about really is techniques for thread
naming and we'll saw and we'll see
exactly why that thing which is actually
know the thread name property is one of
Java is kind of unsung heroes okay it's
like something we all know that's there
we don't really use it so I want to show
you some interesting users and
techniques in which you can put it into
really really good and efficient use so
essentially this is what we all know as
a stack dump okay we debug we're sorry
as a thread um who need debug in
production today and there's a new
matter if you use J stack or profile or
mission control visual VM this is what
we used to sing and the problem here
that we all know very well is that while
we're able to see exactly what each
thread is doing at the moment of the
snapshot we don't really know why it's
doing it we don't have no notion as to
the variable State and you know when it
actually started working there's no
state captured and
and that's tres and really for us to
debug in production debug is always
about getting to the state which is
causing that error who mucho who tree
trying to fix so the the problem is that
when the JVM takes a stack trace of
stack dump it doesn't really come to us
and ask us you know what information do
you want to put in that trace but
there's a caveat to that because there
is one place that he that Jamie actually
consults with us and that is the JVM
name yes sorry the thread name meaning
if we were to say at every entry point
leading to a servlet or when we dequeue
something every entry point into our
code okay if you're to set interesting
relevant information into the thread
name such as the context the transaction
ID parameters pass to it this will
essentially mean that if we're to take
as a trace like it's like a thread dump
a second after instead of seeing this
which which what you usually see we can
be able we'll be able to see stateful
information within the stack trace
itself so for example and this what we
do you can embed into that I'm sure
exactly how that plays out in actually
live starters in a second you can put
you can essentially plug into this
thread information like what's the
current message ID if this is for
example if this Q if this third is the
cueing messages format you and
processing them what is the idea of the
message what you are we dequeuing it
from what's the transaction ID when
what's the current timestamp because the
meaning for this would be the next time
that we look at a stack trace instead of
seeing this okay what we'll be able to
see is this actually when you do a j
stack and and a bunch of others we
talked about in a second it's your
moving form state when you're not seeing
any state within the thread to have
place where you can see ho okay this is
what this fluid is doing and so if
you're looking at the hundred-foot take
a practical example where you have a
server that's hanging and you've just
got I could I like a thread dump of it
okay if you use it this technique a fish
efficiently within your code you can
very easily immediately see if the
threads were
started which one started which one
starts first and by doing that you can
say all right these are the ones which
have been working for the longest these
are and once or probably had a vibe at a
very high probability causing this
machine to hang and then you can go in
and not only see the time in which they
started but you can actually see all the
parameters passed on to them so instead
of just getting a J stack and don't try
to figure it all right I'm seeing like a
hundred queries okay but which of those
is the one that's actually hanging okay
this is something that happened
yesterday so I don't really have any
context here if you use this technique
you'll mentally be able to see exactly
when that frets start and any other
relevant information to embed it to it
now this will work regardless of which
tool you're using meaning if you're
using J console or Mission Control if
you're using a profile or commercial
tool this will always play into it so I
would say that in terms of production
debugging using thread naming an
intelligent way is something that is
super helpful and I've used it so many
times but nowadays when I debug and I
see like just bear thread name when I
getting like a stack trace or like even
when a JVM crashed and looking at that
HSC are are okay like the first thing I
look is the actual State embedded into
that now this actually plays you know an
even a bigger role in what happens if
code crashes for example and even you're
not using like a thread um for example
if you have an uncaught exception in
your code essentially a thread kill or
something that's going to essentially
terminate either the thread or return to
the thread pool so what we need to do as
engineer is we need to make sure we sit
an uncaught exception handler on to that
thread or the thing that's most
important at that point when that thread
crashes okay there's no longer any
variable State embedded into it other
than than the thread name that we put in
okay so I think one affecting one really
strong effective technique that we use
in debugging production debugging a lot
nowadays and is really an efficient
using I'm going to talk about how that
also plays out in a bunch of other
number in a number of scenarios we
actually have a great blog post about it
about five techniques to improve your
server logging so which another four
which I haven't talked
but here which I encourage you to use or
to take a look at another thing I want
to talk about and all these stuff and we
didn't talking about here the demos are
available on github is how to use J
stocks J stacks and thread dumps better
I think I know most of us are been using
J stock for a long time and then thread
dumps in general just to understand when
something bad happens something crashes
when something hangs when looking at JV
and trying to figure out we'll probably
use something like a J stack or any
tools essentially to give us a thread
dump really a production debugging
foundation now there's two problems
inherent with those kind of tools
especially in production the first one
is there is no state right this is
something what you just talked about how
we can actually embed state into every
thread um that we use the second one the
second problem is that we can only use
those tools okay when actually we're
there I mean in production when
something happens we're usually not
there to do anything and we only get
there in retrospect this is different
then when you W buggy normally and we're
there when the issue happens what we
want to have essentially is the ability
to have pre-emptive J Stax meaning
freedoms that happen when some things
when bad things happen with us without
us having to be there and the key to
doing that is another effective
technique that we've been employing
quite a lot is how to programmatically
create thread dumps so one of the things
that we do is the ability to actually
execute J stack on yourself when
something bad happens in your code
meaning if your server drops or goes
above a specific application threshold
in terms of throughput you would
probably want to log that and not just
log that be able to log a state full
thread dump I'll show you exactly what
the server was doing at that point so if
you get called in a few hours later and
all and that instance is already brew
started which is no longer happening
which is the case with production bugs
which are usually kind of sporadic this
technique actually enables you to have
the kind of the software self debug
itself when something bad happens
essentially be able to come in and
activate J stack on yourself so you see
here
just opening up a process this is an
interesting technique how to get your
own PID using the run time MX bin
Factory all this stuff is up on github
and then the next bit is when something
bad happens in your code you have a
thread which is looking for a specific
throughput threshold and if something
goes be below that you can activate a
stack on yourself and essentially create
a situation where you log a pretty rich
thread dump which also has the state
tell you exactly what that server was
doing at that time another example which
we all blogged about recently things
with the guest post is how to do that
when you deadlock so a lot of times only
things that you can do actually as you
can detect deadlocks internally within
your application and when you deadlock
you can activate a J stack on yourself
because deadlocks are very surprised at
every they happen every now and then and
it's hard to get to them in production
when they happen so one of cool things
you can do much in the same way that if
you fall below or go above a specific
threshold or you deadlock internally you
can essentially create a J stack and
target out yourself and this is kind of
result when you'll be looking at we can
actually see state for each of those
threads so so far we've talked about I'm
going to kind of switch gears here we've
talked about our ability to create
better thread dumps and to insert state
into them the problem with this
technique is that the state that we're
able to capture is fairly limited right
we only we're sending you just a string
okay what happens if you want to go much
more dynamic and we don't know exactly
what is it that we need when something
bad happens let's talk about a few tools
that we can use essentially to get to
dynamic state within the JVM without
restoring it in production ah my
favorite two I would say out of all the
tools are out there and a lot of people
don't know about it
SB trace so this is an amazing tool it's
essentially an open source application
which uses a Java agent which we'll talk
about in a couple of minutes which it
essentially lets you run meta scripts
can inject code dynamically into a live
JVM without restarting it and without
modifying
any of its state so you're not you're
doing it in a way which is read-only so
its production safe it's as if you can
go in and start playing with variables
but gives you a very powerful ability to
go into the JVM and see exactly what's
happening within it using an interesting
language the con is you can only read
that you can only they kind of querying
or introspection you can do is read only
which on the surface of things sounds
good but there's a caveat to that
because just with a mere virtue of you
not being able to modify anything
there's a ton of stuff you can't do
meaning for example if you want to come
in and log something in a specific point
you want to say that JVM okay log
something where that happens and doing
that dynamically you can't do that here
because logging by itself
changes the application state or if say
for example it's a given a more simpler
example you want to print the content
are of an array or an ArrayList you
can't do a loop because a loop you know
has the potential essentially to go to
run infinitely which from be traced
perspective makes it unsafe having said
that there's a huge list of restriction
so but don't worry it's actually super
powerful tool and you can do some
amazing things with it and there's
ashley techniques we talked about we can
let you override those restrictions so
we look about when you look at beach
race essentially what enables us to do
is to write these scripts which are very
similar to Java code and essentially be
able to take those and inject them into
a running JVM
for example this script what it does it
lets us print out to screen whenever
anywhere some wherever anybody in the
application writes to a specific file
that's really powerful you're trying to
figure out who's writing to this file
under and under specific conditions okay
so essentially you're injecting into
dynamically without changing the JVM
state without putting at risk injecting
code into the into the Java IO output
stream to say alright wins when this and
when this thing happens we're writing to
a specific file let me know about it so
the kind of syntax that you see it's
interesting especially you're writing a
little script and you're telling beat
race where to put it in and and
the language is Java as you see so since
you're writing a little JavaScript on a
Java method you annotated where where
you want it to be injected then you take
this scrip you do be trace the PID a
point to your file and that's at
Beatrice will compile it will verify
will let you know if it works and if so
lets you inject that so get another
example class loading a lot of time we
have no idea who's loading that class
what is the stack trace by which this
class is being loaded you know you're
getting you're getting kind of debugging
class loader hell if you all so this is
a cool way to say well you know what
every time somebody's loading a file ok
inject that script or somebody when
everybody's somebody's loading a class
or specific class give me a J stack
which is interesting because it also
ties into our previous technique so this
is another cool application for it
another one I want to show you is really
powerful show me whenever I wanna inject
code whenever somebody allocates a new
character array anything anywhere within
the application and you can write a
script here which is no I'm trying to
figure out who's allocating large string
arrays for example with specific set of
values and them okay that's hard to
anyone within the application you can
take the script essentially putting
whatever you want printing you know the
the content do an aquarium you can look
at the stack and then inject that very
quickly now the cool thing about
Beatrice it comes with this huge library
of samples so it's not as if you have to
say which covers like a hundred
different use cases from connection
pools to overflowing Maps through memory
allocations so essentially all you
really have to do is familiar stuff with
that library and then just use that and
then you can kind of play on those and
manipulate those so I really you really
have to start from scratch so this is a
tool which I would really kind of gladly
recommend you guys familiarize yourself
with because it's super helpful in
situations and because by it by design
it's not on a state mutating tool it's
safe for production so if you can come
in an ops team you say well don't change
anything you don't do anything that JVM
this is a very safe tool to use you can
see here you can also do cool stuff like
timers and your tell them print out
every millisecond there's a bazillion
things this tool can do
so I gladly welcome warmly recommend
that you guys look into it but as I said
this tool is limited meaning there's a
bit we've seen you there's such a huge
list of restrictions here and one of the
things we'd like to do a lot of times is
you know I want my debugging stuffing in
production to be able to come in and say
well you know it when something bad
happens I want to log it okay I want to
I want to get it or for example when
something bad happens I want to get a
stateful start our thread stack a dump
of whatever happened so to be able to do
that you cannot do that with J stack
sorry would be trace but you can't
actually use that with Java agents which
another very powerful technique within
Java that you can use Java agents are
essentially an advanced technique for
modifying code as it's running and it
has so many uses essentially the
foundation that all that all the
profiling techniques all the debuggers
that you use in all the commercial tools
that we use today the vast majority of
them use this technique and the JVM
actually has two types of agents that it
can run for you completely different
things each has its own kind of
strengths and weaknesses now the pros of
using this technique we're trying to
figure out or do something in production
to get a specific State the pros it's
extremely powerful you can do anything
you want you can change code dynamic you
can say anytime somebody's invoking a
specific server with a specific set of
conditions any worth in the app I want
you to do this anytime somebody's
logging anytime somebody new can go
essentially and ask anything you can
possibly want now the cons here is that
unlike be trace in which you use a Java
syntax to express what you want the JVM
to do in runtime Java agents require our
bytecode which is a much much lower
level which is kind of a bummer but I'll
show you guys a technique on how to
overcome that okay so essentially if you
look at a Java agent okay essentially
it's it's it runs like a verse it runs
exactly like
a standard Java Java application but
instead of having which one JVM will
load for you in real time you can use je
console for example in visual VM to
attach a piece of a Java inch we just
wrote into the JVM live you don't have
to restart remember the whole point here
you don't have to restart your JVM at
any time this is all live stuff so
instead of having a main which is no the
entry point which the JVM will vote for
you you have something different which
the JVM recognizes called a pre main
which is essentially you get arguments
but much more important you get a
reference to a point into an object
called instrumentation which essentially
enables you to instrument code and it
does that but letting you add object
called transformers transforms are
essentially means for you to say alright
I won't transform this class because I
want to add these bits of coders and the
powerful thing here is this can be any
class it doesn't have to be code that
you wrote which makes it much more
powerful if you're trying to debug a
third-party library and it's doing wacky
stuff like a caching framework or
something and trying to figure out
what's happening there and you don't
want to change the code and you don't
want to change the code you don't know
build that artifact this is a great way
essentially to add and code it lets you
weave your stuff into it and the way you
do that socially all you have to do is
implement a super easy interface called
class file transformer which has
practically one method ok which means
transform ok
you can ask him I want to I want to
essentially transform one class and I
want to take its bytecode and I want to
mode modified as I said the problem here
is that you have to work with bytecode
but the good news is they're amazing
libraries and tools which automate most
of that work to you for you that the
point you get fluent and kind of get a
bit of practice with them it becomes
second nature the best one which I use
and a lot of tools used nowadays it's
called ASM here we see an example of how
essentially we're taking a class fall
and we're saying Ori I want to change
that class but specifically I want to I
want to change a method in that file so
once you this is use as this technique
uses a visitor method if there's a
visitor pattern story we're essentially
you're loading up bytecode and then at
the end once you know when all the
vision went that method is ended
essentially here what I'm doing is I'm
adding a call I'm telling you know what
we've a call in to my class called hook
or whatever class that I want which
essentially calls anything that I want
to do so I can come in and say you know
you know what transform all the servlets
in the application so whenever they
start I want them to call into my code
first okay or if this is a caching
library whenever it calls into a
specific method put or get from the
cache call into my code now the thing is
to actually weave that stuff in can be
tricky because you have to know a bit of
byte code especially if you want to add
like ifs or stuff this is where I
recommend you guys take a look at this
beautiful plug-in that's available
through ASM called the SAS semi fire
which essentially enables you to write
in your IDE Java code and have the
plug-in dynamically show you the ASM
representation of it which means all you
have to do is just write the code that
you want to write and then take the code
which it automatically generates for you
and paste it into your visitor at that
point by doing that essentially you can
you have the part to do anything with
the JVM you can simply go to any class
any set of classes within the JVM beat
your code be it yours or third-party and
essentially do what you want change the
code or in run time to log things to
gets tagged Dom's to query variables all
that good stuff the second the second
group of agents which I want to talk
about are call Native agents okay this
is a whole nother beast this is actually
if you if you really really go want to
go super deep this is as deep as you can
possibly go with the JVM this is
essentially saying I want to write code
that enables you not to just debug my
code or change my code I don't say I
will essentially want to get access to
everything that's happening within the
JVM now you probably want to have a very
good reason to do that okay and
something that a lot of vendors use when
they built it and you use that as well
but it's a great thing to know about
so essentially native agents are written
in C++ so that's one big change
you're riding at the JVM level you're no
longer you know you're no longer writing
in Java it's super low love in a sense
and using something called JVM ti it's a
super robust API and C++ provided to you
by the JVM and the reason for its being
it enables you to do super powerful
stuff for example you want to get a
callback every time the JVM starts
garbage collecting and or when garbage
collection starts and ends you can do
that do you want to get a callback every
time the JVM synchronizes a monitor you
can do that you want to set a breakpoint
and pause execution programmatically
when something happens so you can
debugger something you can do that as
well anything that you can know anything
that you've ever seen any debugger or no
or tool do you can achieve using that
that API you can tell them you know what
whenever somebody changes the value of
this field anywhere within the app I
want to get a callback when everybody
wins when whenever an exception gets
thrown within the JVM I want to call
back on that as well and the API is
super rich and super robust so on one
end it's great well I mean like if
there's more stuff you're like threading
JIT compiler you want to get a callback
whenever the JVM composite composite
method you can get you can do that as
well so on a lot of hand it's amazing
because you have all these amazing
capabilities but there are severe cons
one it's much more complex to write
meaning this to actually nail it down
and to get a live native agent running
in Java it's something that's usually if
you're trying to fix a problem if you've
gotten to a property to a snow to a
position when this is what you're
contemplating Wow okay you're dealing
with some super hard stuff so this
because it can take just a master
technique of doing that can take
somewhere between days and weeks to
actually get to figure out exactly how
to plug it in and get it to work the
second bit is its platform dependent I
mean you're writing in C++ so all that
stuff you know we're running for Windows
or you have to get the thing to compile
and this is something that we as Java
devant to have this thing on your or
your Mac on your windows you're gonna
have to spend a lot of time getting
thing to compile and the last bit which
is kind of probably the kind of the
biggest thing about it because you're
writing at the jet your the code is
you're going to be writing is going to
operate at the JVM level you no longer
protected by the JVM meaning if you
generate and you know you're out of the
land of null pointers every mistake that
you're gonna make is a sig sig and it's
social will kill the JVM so if to be
super careful about that on one hand
it's like with great power comes great
comes great responsibility this is the
classical example you know on one and
you can do amazing stuff with it on the
other hand you have to spend a lot of
time on it and make sure your code is
super stable ah one more one more piece
one more kind of interesting component
which I wanted to cover with you guys
today has to do with something called
the serviceability API so this is an
uploaded example today so essentially I
know this is another extremely powerful
tool that not a lot of people know about
within the kind of JVM ecosystem and
talking specifically about hsdb
essentially this is an amazing tool this
is out after beat race this is probably
my or and and of course jay stack this
is my third go-to tool hsdb essentially
is an out of process debugger which lets
you connect to the JVM okay and
essentially introspect the entire memory
spec of the JVM and do amazing things
you can query you can have like sequel
like queries we essentially iterate
through the entire heap to search for a
specific object in the JVM so we're not
just talking about a profile which shows
you already this is how many are and
this is how many string objects you have
this is how many characters you can
actually see specific variable States so
this is an extremely powerful tool not
only that it comes with an extremely
powerful API and I'll show you guys some
very very interesting stuff you can do
with it so essentially if you look at
this tool the kind of thing that you can
do here kind of mind-blowing meaning you
can actually come in and see histograms
or you can come in and say well you know
what show me all the string objects
there whose
or show me all the objects where this
field is equal to that use using
something called oql object query
language which I'm not going to go into
that now but it's a very it's a very
easy syntax and essentially you can do
that and kind of zoom in on every piece
of state you want within a live JVM
again without restarting it and the
thing is this is also this runs out of
process you essentially load load load
up hsdb and you just attach to a live
JVM you don't have to have specific
permissions or something and that moment
you can start getting all this data now
what I wanted to share today is actually
and I wanted to do at least one kind of
live demo it shows some cool stuff that
you can do because when I started
playing with this tool the thing which
are which kind of boggle my mind is like
how can an external application
essentially be able to come in and
introspect and RJ know and an
application completely out of process
know and be able to understand exactly
what's going without with it with the
manager heap without the first
application the JVM actually telling it
no this is no the the segments in the
memory where the objects are you know
there's gotta be some way in which new
the JVM reports all that information out
to hsdb
and that's super interesting to me
because the kind information you can get
from that tool there's no other tool
which can give that to you that level
information again it comes with the JVM
I encourage you guys to play with it so
the thing is and this is what I'm gonna
show you is actually the JV hint the JVM
has an amazing system okay that's
available to all the developers and you
can use that to expose everything that's
going on with thinning like it did you
ever think about whom I actually want to
run on all the objects that are
currently in the heap regardless if I
have a direct pointer to them or not
because I'm looking for something oh no
I want to do a histogram you can do that
with this API even programmatically the
key to the castle is the JVM exposes
essentially its entire internal object
structure system to anyone who's
interested in as a part of the
serviceability API use you know every
object meaning every generation and in
the manager every thread ever the the
compiler every AAB
within the JVM the direct objects were
powering the JVM are exposed to you
through that and you can access those in
runtime so I'm going to show you are and
just to give you kind of a sense of the
kind of partner the kind of power that
you have you can Google all this stuff
up for example you see that the JVM
hotspot GC nerf is collected heap so
this these are all fairly documented
classes a fairly you can document API
you can use essentially in Java to come
and essentially query see all the
regions within the JVM all the memory
regions or a Java thread see all the
frames everything that's going on within
it it's a super powerful stuff and I'll
show you a demo in a second how to
approach that or in this case you know
this is the main class this is the
runtime hotspot VM this is a singleton
which is exposed to you which you can
use essentially to uh this is the keys
to the castle like the old universe
which is a list of all the memory
regions allocated by the JVM and not
only that a way to iterate on those and
actually get access to all the objects
that are alive within the JVM at a
specific moment in time or get all the
threads that are running and not just at
and see there are a representation then
not just as Java threads we all know but
as actual OS threads and be able to get
access to all that stuff and just the
amount of the amount of things you can
do here is just mind-boggling just in
terms of your ability to interact with
all the internal systems the string
tables the object heap it's all here
what I wanted to show you for example is
how a small demo where essentially you
can come in I'm going to show you them
or how you can essentially run iterate
on all on all the space on all the
regions within the manager heap in a
safe way using plain Java code so let's
see essentially the way that you kind of
connect yourself into that system go to
VM type system this is all the code I'm
gonna put this code this code is gonna
be on github this is all the code you
need to put in place it's not a lot so
all you do you you act as though symbol
those symbols which are JVM ah sure
which it exports you as native symbol
and native symbols and essentially what
you do is you do this loop here which
iterates on all these symbols and builds
a reflection map I'll show you an
example of that in a second okay it's
actually kind of like a a manifest of
all the classes of the JVM and where
they are in memory and once you have
that all you only need to do essentially
to do some pretty cool stuff scanner you
initialize it and then you say all right
give me the parallel scavenger heap okay
and give me the actual heap
give me a pointer to the actual heap in
memory give me a pointer to the actual
young generation and give me a pointer
to the old generation two immutable
space okay give me the classism dislikes
think about like reflecting into the JVM
okay and this is all safe stuff this saw
something the JVM exports to you so you
can do pretty cool things with that and
then once you have those you can say
alright give me the actual address
values of those in memory the actual
regions within the JVM get those map
does into into a simple array and start
iterating on those and search for a
specific value now this is a very very
simple demo but you can leverage the
serviceability API to do sophisticated
quiz not you're just to run on the magic
heap raw but to actually run on it as
objects so you can say specifically look
for specific object with specific values
or attributes and this is something
that's very very powerful when you're
trying to debug in production and you
have this technique and you can
essentially come in and incorporate
things from the serviceability API into
your code so this is another kind of
tool which I wanted to share with you
guys um anyway there's a bunch of other
stuff which I want in which we blog
about as I said that I think can be
interesting to you if you haven't
checked it out so um a bunch of here's a
recent post feed about like land res
expression in Java 8 and another stuff
we didn't get a chance to talk about
today like toolings that you can use for
debugging productions commercial tools
and this talk I only spoke about
touching but someone to lose come into
JVM so this is another thing which I
kind of encourage you guys to check out
and um so anyways with that I'm gonna
say thank you and hopefully see people
have any questions no this is this is
the entire premise of Beatrice meaning
the way that it's built is it does not
allow to invoke any code which is not in
the Beatrice libraries which are safe me
and will not compile the script it also
the syntax the reason why its kind of
quasi Java but it's not Java it doesn't
let you do keywords like for or for
example or wall or those kind it doesn't
let you throw an exception it doesn't
let you out look there's no new in it
such like what it does it takes it has a
little compiler which takes the B script
language and composite into byte codes
so there's no and it checks to see all
the stuff that you're doing is is safe
otherwise it will not compile so that is
the whole premise and I think that's
also why people especially it's in
easier cell in organization if you have
like ops people you want to introduce
this thing versus hey I just wrote a
custom Java agent and I playing around
with a bytecode or I just wrote a native
agent I can crash the JVM it at any
moment I'm so like why a beat race
really if you go into the hard core
production is a great tool just because
it's so benign so that's why it's a good
trade-off between it being benign and
you would be able to introduce it into
production fairly easily no the
beautiful thing about about thread
naming is just it's part of the thread
class all you have to do is just
essentially if you haven't read that the
only thing there's two things set the
thread name also make sure you use a try
finally clause I've seen people set the
thread name get a narcotic ception
essentially and then the third is now
dirty weather with the name which when
the name increment with the state which
essentially has nothing to do with it so
as long just do with try finally clause
and then set the name correctly
and again this is a technique which will
manifest across whatever tool you use
even in Eclipse okay even if you're
doing something even in local debugging
you and y'all
like if you can a tomcat container
you've got like 200 threads on it okay
even with debugging view the thread name
will play a part there so that J stack
any commercial tool that you might be
using
Mission Control visual VM all these
displays into that that's like out of
all these techniques you know some are
like I would say no B trace and this is
kind of straight for itself the other
kinds more advanced I would say there's
really no reason why not to do it I
highly encourage you guys do yeah so
hsdb so hsdb okay essentially is
read-only as well edges to be armed now
it does enable you to edit stuff it's
actually pretty cool what they do there
they use an actual Windows or Linux
debugger to connect because then it's an
out of process connection the the sample
which I showed you is actually inter
process so within your code from within
the JVM you can introspect yourself by
loading up the times but by loading up
the times the type system manually so
but those tools are well be trace is
read only those tools can't potentially
alter state hsdb is a console tool for
the most part you don't alter state it's
not that it's not the purpose of the
tool but you can actually go in and
change stuff I think I think you can do
that but that's that's something which I
usually will not recommend to do in a in
production ad hoc but it is possible so
let's see Beatrice so Beatrice will work
with non sound vm's because its uses
simple Java Java agents will work with
the non gen VM the JVM Ti is a
specification meaning any JVM should
support it thread names force because
their Java the only bit here was it son
specific is the serviceability agent and
then hsdb because these are not develop
they're not a part of the specification
so out of all these techniques they're
the only ones which will open work for
open JDK in hotspot but if you're using
like a V 9 or like or like an a like a
zing I can't guarantee that won't work
cool
any other questions
all right three two one
thank you guys a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>