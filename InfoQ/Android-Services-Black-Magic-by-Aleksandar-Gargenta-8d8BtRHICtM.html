<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Android Services Black Magic by Aleksandar Gargenta | Coder Coacher - Coaching Coders</title><meta content="Android Services Black Magic by Aleksandar Gargenta - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Android Services Black Magic by Aleksandar Gargenta</b></h2><h5 class="post__date">2012-02-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8d8BtRHICtM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay and I think we're ready to get
started it's two o'clock on my android
phone so I time has come so hey everyone
my name is Alexander garganta I also go
by Nick me on Sasha and we'll be doing a
talk on the what Marco brand that is the
black magic of Android services which is
basically a fancy way of saying we're
going to be talking about some of the
kind of interesting verticals that exist
in android we call them services glad
they involve a lot more and you'll see
that you know we obviously won't have to
have a time to cover all 60-plus of them
at least as that's how many account on
my Nexus Galaxy Nexus but we'll cover
some of the more interesting ones just
to give you a taste of how they're put
together to give you an idea of the
they're kind of the the flow if you will
of data as well as control all the way
from the top of the stack so the a
player down to the colonel in a lot of
cases I only have about 10 services that
will actually go over and these days you
will see or very much describing form of
diagrams some of which may be hard to
read if you're sitting in the back and
there are some open seats up front so
let's hear your chance to take advantage
of the seats if you want to be able to
read what what some diagrams anything
just to I guess which is used myself I
the work at the company called Maracana
helped with the liver and the developed
training courses on among other things
android internals android security and
the like i happen to profound it and I
organized the San Francisco android
usergroup so we have meet every month
you guys should if you're local come and
check out some more events they're free
and very educational I also on the Java
user group I core on the html5 is a
group I tend to speak at events like
this I been doing actually I'm sorry I
career mostly on the server side java on
linux so what a linux administration
along the way but then moved into kind
of
that's I give that one should I don't
want to say desktop the client side so
Android embedded systems and the like
I've worked in other liberal
technologies like black Porsche and a
mass proxies that sort of stuff you know
long long long time ago the company work
for purposes all open source software
specifically one large part of that is
Android and we provide training we
publish content we record videos now
tutorials all that most of it is
actually available for free on our
website and we helped sponsor and run
different communities organize different
communities around the technologies that
we're passionate about so i'm pretty
sure actually let's just by a show of
hands how many of you have never seen a
picture it looks like this okay cool so
that means you came to the right place
so we're not going to be talking about
the stack we're going to be talking
about essentially the you know
intersections through the stack so think
of it as you know way of going you know
from the top of the stack down through
the application framework through the
native layer to the linux kernel then
we'll be discussing some of the services
along the way as i mentioned we'll be
looking at only about 10 out of the you
know 60 pluck soup while services that
gave da is to get a taste of how they're
put together how they're similar in
anyways ensures no communication but
also how they're different and and why
they're different that said i do want to
point out that there are or they're
actually in fact there's going to be an
interesting talk on the camera how after
this one folks from tina they are
sitting in the back are going to be
talking about it right here and there
were actually a couple of interesting
talks already on sensors audio and a few
other things so by all means you know
there are definitely complimentary talk
to this one in fact there may be some
redundancy to for example what Benjamin
talked about here last night if any of
you actually sat in this room that's
that hopefully will
to be interesting and well entertaining
so oops hold on that's not what I meant
to click on and so that said hopefully
by the way one thing I just want to
point out from from this picture I hope
that you must you have movie with an
idea that applications essentially one
in separate processes that they
communicate to services mostly through
binder binder is IPC mechanism that
Android provides in form of a kind of a
kernel driver will mention briefie and
the next slide kind of high works the
services do talk to each other most of
which run inside of this system server
process others may run in other
processes like for example the media
server which will touch upon later on
they among themselves top sometimes
through simple java calls most of which
are actually written in java some look
some of which are written in actually c
c++ but when it comes to the native
layer and belatedly i mean you know the
user space call I mean the different
kind of say stage fright or the plugins
that Andrew provides for different for
example media codecs the different
Damon's and so on and so on most of the
communication between the Java layer and
that is through the J and I although in
some cases there's actually the
communication can also be done through a
binder and can also be done for unix
sockets and will touch upon those as
well and then finally the kind of to go
from the native layer down into the
Linux kernel and actually acts as the
drivers that's essentially you guys
probably know you know given the you're
here this conference about it already
but you know there are obviously
different api's from system calls to you
know interacting with the drivers
through ioctl methylene through you know
simple read the rights and so on and so
on so we're got your point essentially
like I said different services and take
a look at how they crisscross through
this through the stack so let's start
off with something it's kind of easy you
know
the vibrator service they say it's easy
because it doesn't involve as many
moving parts okay and of course this is
the vanilla AOSP implementation this may
differ to what you have on your device
especially for example there are
companies are specialized in providing
hectic you know better haptic
implementation in form of both software
and hardware which actually AOSP does
not embrace because it's not it's closed
source and so this actually is kind of
what the vibrator stack if you will the
floor looks like on a Galaxy Nexus
device okay most of these slides are
geared towards Galaxy Nexus and ice
cream sandwich so let's let's go to just
take a look at this so here we have is
two different processes one being this
example application on the left and this
system server on the right and then down
below as you see we have a corner with a
couple of MIL two drivers exposed to us
now ultimately this application wants to
vibrate the device would have been are
maybe it's because the notification
although in that case you'd be going
through different you wouldn't do it
directly would actually go through a
notification service but let's assume it
was the vibrant device for whatever
reason some provides in-depth accepted
like feedback before we can actually
talk about you know the location we
actually have to jump on the right hand
side to talk about the system server
before talking about assistance sir we
have to talk about the the service
manager and by queen of all with air
might as well talk about the Buddha so
at you know when the Android device
boots up we know that you know we
initialize the colonel below the colonel
colonel execute this inner process in
the process parses these in our C files
which hopefully you guys know about if
you don't you know will and see Benjamin
stocks from yesterday when published and
in it are see among other things
launches this service manager which is
this box right here okay and I part is
follow the lines it's actually going to
get uglier than this but I'll try to
draw attention through the different
things and don't worry about
to read everything else planted along
the way the service manager is a daemon
that basically shred white in it so
should it exit you should you know it
would automatically be restarted for
example and one of the things that it
does it actually goes and registers with
the binder as the convicts manager
basically registers itself is this a
binder service at at position zero which
is a special position and the reason for
that is so that others can find the
service manager now search manager's job
is to essentially act as a registry of
all the other services so as you will
see you know for us to actually be able
to talk to some other service and this
talk is about services we have to find
that service in the first place and for
us to find out we have to talk you know
talk to something that has a reference
to the service ultimately a reference is
nothing more than a kind of a logical
name which is taking it as a string
right it mean by character buffer and
some sort of an ID an integer that you
need to identify is a particular process
and in that process a particular service
in that process that binder knows about
so service manager is in fact a service
or it's in itself because it acts as
service to others that actually need to
query other services so he registers as
the context manager now one interesting
thing about the service manager is that
you know our applications can't randomly
register services with the service
manager one of the things the service
manager does it implements a security
track which is kind of hard coded and it
checks whether weather's been the
registration is one of the trusted you
IDs system the system user is actually
one of the trust of you I these so
that's why you know this is the services
you get from the service manager are
somewhat to be trusted although you know
if you were to attempt the selinux stock
or haciendo talk happening concurrently
you know you may hear otherwise anyway
service manager gets launched and
essentially you know becomes available
to everyone because it's at this long
location after that the zygote starts up
which hopefully you know is this how big
belviq instance if you will that listens
on on a unix socket and
and first itself to start your
applications but before it does that it
actually functions self to start this
big process called the system server
system server is run by the system user
which you know has capabilities of
talking to the service manager now what
does the system server does it actually
goes and execute this system server Java
you know a clutch class making sure runs
a main method that main method goes and
load some native libraries initial I
registers a few essentially J&amp;amp;I
libraries if you will with the jni
environment and then starts bringing up
or or booting services like I said
there's 60 plus services not only which
are coming from here but most of which
are so one of the services that it
registers in this case that it actually
instantiates so it creates that's kind
of what this means so it's kind of hard
to see but it got builds a vibrator
service now Bible service happens to
implement a vibrator aidl which turns
out to be an interface in Java well you
know that gets compiled into essentially
an interface and particular implements a
stub we'll talk about how this comes
into play again and then the library
service won't sustain she it begets a
registered that's where this well I
guess it's hard against for some reason
it can't actually select it so let me do
it this other way so registers this
service with the service manager now the
service manager knows about this service
they've got instantiated by the by the
service the system server and that's it
now the system server boots other
services and at the end in the end of
the day goes in you know tells the
activity manager service hey we're done
utility manager service goes and sends
out that boot completed event and sends
out and other intents to launch the you
know the the launcher and our system is
booted now no application starts up
assuming the user started started it and
here we go that's the application the
example applet APK that application you
know let's assume has some sort of
example activity that activity actually
wants to vibrate if device so what we're
doing it with instance you this Android
or as the vibrator in some cases you
actually use the context to get system
services in some cases you stash it and
there's different in some cases you just
say context dog get package manager for
example which is also system service so
it's not very consistent depends on what
every you know on different servers in
this case actually you don't know
instantiate you you do use the context
though get system service you after you
get a vibrator and you call a public
method or method on it to to vibrate the
device now the vibrators job is as you
will see just a proxy are called vibrant
device to this vibrator service which is
sitting over here so vibrator itself
could have been actually called vibrator
manager a lot of services actually split
into two parts the manager and service
the manager acts essentially as a proxy
to shield you as the developer from
knowing that there's binder calls
happening in the background okay so what
this does it actually goes the vibrator
goes and gets a reference to the service
manager by asking for you know whatever
is it handles 0 which is the context
manager and that's how it learns about
this service manager the thing that we
already discussed it babers and again
how does it know that is because it goes
to binder and binder itself references
the service manager because it knows
what's the position 0 so you give them
give that information then what we do is
we go as the service manager over here
to tell us to give us something f by
name vibrator this is this is just a
strange nothing more than that and
essentially well that gives us is a
reference to this service that we
previously talked about okay now we
don't actually get a real reference we
get an ID of that service which behind
the scenes we can kind of think of it as
a reference we then bill and ask this I
fiber stub to actually give us this as a
proxy and we now have something that
looks like I vibrator service to use now
when I say we
II I don't mean our application i mean
this vibrator you know which is
essentially a proxy so that's how you
get this now you're ready to find a new
vibrator the device so we say you know
this service that vibrate that goes and
essentially makes a call to binder
that's what this uses means or calls
binder and says execute this transaction
by some ID and execute such a such
method by some ID every method or very
essentially service has a particular ID
it's not important to know but that's
kind of highly worsen with the covers
and it also passes like for example
information how long to vibrate the
device now the binder essential the
river is that over here to this vibrator
service now the vibra service one thing
is interesting is that it extends this
stop now this stub is something that was
created automatically by that aidl tool
if any of you know that is great if you
don't essentially aidl is an interface
different you know android interprets
definition language which is useless
cried these services to their clients
and so this tool can generate these
practices stubs that we help with
marshall linked data across this binder
channel if you will so that we don't
have to deal with low-level you know how
do we convert some rich java data types
for example into these parcels which are
the objects we can send over the binder
wire to the other side and then how does
the other side d marshall them into back
into java or visit it can use or java
data types in c by the way we don't get
that work so if you implement services
and c++ as we'll see later on you end up
having to do this by hand this
marshalling marshalling where's here the
ideal to essentially generates these
stubs and proxies it makes its trivial
so ultimately this service this stuff
has a transact or on transact method
that's what get the binder calls but
also by the way managers are these
threading and so on and so on in the
background so every private process in
android has essentially a thread pool
which to which gets a from where you get
grabs a threat to actually serve as
these remote requests and so finally
this stop l does it
it captures that on transacting on Anton
Zeck request figures out which actual
methods to involve and then cause the
method on the vibrator service so in
reality you kind of think of this
transaction is going to this star which
choirs a service but because there are
one in the same at the wrong time it's
one object you know the essential live
in the same memory space if you'll so
this service at this point one thing
that it does and this is actually why we
need services in most cases is that AE
checks for whether the polar has the
permission to actually in this case why
we're the device so you know one one one
could argue why would we have to go
through this entire elaborate you know
will and talk to some other process to
library device whether we just talked to
drive ourselves and so a lot of cases
has to do with security and so the
services is provided they essentially
that gateway that then first security
permissions for us and to it also acts
as a mutual exclusion point because you
don't want multiple locations vibrating
the device at the very same time we're
different for example patterns that
wouldn't work very well so for example
one of these services synchronize if you
will because they're stateful in being
synchronized blogs there were these
requests to continue so the library
service the first thing that it does but
yeah persistent state throughout the
lifecycle the vibrator used to working
on a cross-country processes and that's
right so so we basically we there's a
lot of code in Android written with an
assumption these services are there and
they're always going to be there so so
and in some cases their state that's
important in some cases their potential
isn't like so for example location
manager service will remember what was
the last known location is the provider
that's not that public with the other
state here is like is there someone else
already vibrating device that's the
state in this case anyway the religious
mission does not get you a question the
question is how I gosh I like to answer
I don't know if anyone wants to ask you
is how does
how does the vibrator service know
whether or not we have a permission to
libraries device and so the way this
works is that binder one of the things
that it does it passes edit on your
vocal binder transaction from process to
process it passes the UID and the PID of
the calling process to the process being
called and so this service can just say
what is the ravel tyvm PID now once you
have a UID the user identifier and in
android every application gets unique
uid that that persists for the lifetime
of the application of the device once we
have a new idea we can actually ask the
package manager which is another service
to give us to tell us everything we know
is about that application including for
example which permissions it holds or
uses once we know which permissions it
uses we can basically know we can in all
that list is there a permission that you
know that we won't enforce now all of
this is actually you know shield it away
from us from these you know by these
little helper methods but ultimately
every service in a very trivial way can
ask does the calling of a process held a
particular permission and if it doesn't
it can simply draw a security exception
so that's again one of the reasons why
we have services so that's what the
first thing that like that service does
and then goes and basically you know in
a synchronized block businesses okay now
i'm going to buy great device now the
other thing that the library service
does compared to just talk into a normal
you know in this case of you know a GPIO
driver is that it we could you know it
also provides more features like for
example it can implement pattern
vibrations so we don't have to actually
do it ourselves like if you want to
vibrate for a little bit than not and if
I wear again you know we don't do it
ourselves we actually girls give it an
array of you know Long's which you know
provider timings and it goes and
implements that behavior for us so kind
of to provide a haptic feedback not just
the simple stupid vibration it's on off
and done so anyways there's more value
to services that you will see then just
simply wrapping the drivers so assuming
we have the permission assumingly you
know enter the synchronized wat well
then the vibrator service does incalls
and native method and a lot of these
services actually parts parts of their
implementation or go to natively and so
native will just say a method in java is
native essentially that
means is that it's implemented in Jay
and I right now for those who don't know
dr j license for java native interface
it's a way of java code essentially
linking to native methods or functions i
should say they are implemented in C or
C++ and then so when somebody goes it
involves a native method in Java that
actually goes and more muscles that Java
data giallo data types in to see data
types you know that are you know somehow
mapped properly and then you know the C
code or let's say c++ code goes in
execute here it says it c++ the real is
not object oriented in this case it's
really nothing more than simple you know
using simple sponsors for name spacing
so the actual implementation or you know
the next step happens inside of this
vibrator service dot cpp now this
service comes from a library called live
android servers that are so which is
actually loaded I had a time by the
system server on boot so one of the
things the first things in system server
does is the rewards this Android servers
thought I so far now this library is
actually compiled and this I just one
thing I wanted to mention it I don't
know if it was obvious this box
represents the Java world right so or
the dalvik world I should say so all of
this so far has been happening in bulk
now we escape the dalvik boundary we're
still in the same process we now
essentially execute a function in this
service now that that function all that
it does it actually execute or looks for
a call component specifically the
vibrator call now I hope the most of you
are familiar with this avo call but if
you're not going to just quickly mention
it so in android we have multiple forms
of how the hard web structure layers I
mean the kernel itself to the form of
drivers essentially provides fall but
now we have also userspace Hall the
reason why we needed are two reasons why
we need at least is one we want to
provide consistent api's to the top of
the platform so top layers of the stack
so that we can build these services you
know you know the same similar way
important consistent system to system
we're not actually not annoying we're
having to worry about the actual drivers
they may be used on read the covers so
that's that's the
reason why we we basically you know we
need all the other reason is you know
the criminal code or the Colonel's
called stopped because if the colonel is
you know should be GPL of course there's
different you know some people tend to
interpret it differently but if you want
to keep your secret sauce secret and you
don't want to release your code under
GPL android it actually works very hard
to make that possible so everything in
android with a few exceptions is
licensed under you know the business
friendly quote unquote license like you
know apache or MIT or bsd license so the
entire for example bionics lips your
libraries vices that you're not lgpl but
rather as as vsd so point being is this
these car components in android can me
remain proprietary if you as a as
annoying and want to keep them that way
finally now in this particular case this
vibrator see actually implements a
vibrator H file which comes from this
lib hardware legacy in you know include
if you will directory and there's a you
know a vibrator of age and so this just
does a simple you know call to in this
case any driver exposed to this is FS by
literally you know but saying bouquet
writes a particular you know long which
is how long it should go and and turn on
the vibration for and then you know like
say you know now you are all so
literally this is just writing to a
driver through simple I oh nothing fancy
you know to turn on the vibrator or turn
off now of course there's better ways of
doing this but unfortunately vibrations
you know the coral hectic you know the
world of haptic feedback is is riddled
with happens and so this is what asp can
provide out of the box without running
into any sort of issues there but
ultimately that's that's where the
vibrator looks like okay now i know you
had a question that asks you a question
or okay so i did get your question any
other questions pretty comment i'm not
using cruise
so the the threat posed for the sister
that I posed for the binder obviously
the vibrator is going to take a long
time to execute yeah so so and this is
differs from service to service
ultimately a lot of calls to bind there
for example can be implemented through
nothing more than you know like it one
those what are those one-way calls in
which case the client is actually wait
for for the completion and the threat
the try pulling is then the binder side
is done automatically so so the colonel
automatically or the driver managers
that now the system server itself
different services inside this is the
server have their own threats so for
example the vibrator especially if you
give it some sort of a pattern to
vibrate on what it does it actually
builds a threat or thread pool and
execute the vibration on that pattern in
that separate thread independently of
anything else happen so now this is my
server process this this guy also has
you know for example start services in a
different thread to allow the resto
system code to boot up you currently but
there's a a you know a thread pool for
the entire system server it's more like
there are a threat posed for individual
services or better yet different calls
are in point in run through two threads
they're owned by those particular
services and it's again you know so so
so in some cases sound redundant because
you could just you know Phi of the
threat from the binder and just execute
everything in there or in this case of
the vibration for example it does manage
its own tray okay then sorry through
from say it again to the service manager
so how does it how does this work so so
when the system server goes over here to
talk the service manager no it actually
so so the system server and this is kind
of hard to see in again did there too
many lines and at some point you'll see
that I gave up on lines but the system
server actually uses a service manager
java class to say get a service by a
particular day now that class wait
it actually jumps into the jni again
over Jane I to the to deliver binder a
little binder actually goes and asks the
sludge that / binder for for it for
service at position zero and then uses
that actually creates a handle if you
will to something at position zero and
then anytime the lines to for example
ask for a service like in this case over
here you can see it's asking for a
service called you know vibrator so this
that kind of wine it already know is
hard to get to it and it's essentially
talking to the driver and it's which
talking to Jonathan memory mapping /
back / buying their passing in a prayer
you know in particular area with passing
a particular request at a you know for
whatever something by a particular name
and getting or sorry in this case it's
talking to the service manager but
talking to it through binder as well so
now we also your exotic it's in this
case use for anything okay so this is
again one of the simpler ones let's take
a look it's sending a little more
complicated if you will the power or
department so I'm pretty sure most of
you hear a familiar with wakelocks if
not from you using wakelocks but you
know maybe from your dislikingly clocks
for one or other reasons so anyway in
Anjali we use wakelocks to prevent the
device from essentially you're going
into this suspense states to conserve
power but the question is how does that
work so in this case we have an you know
again on the right hand side sorry on
the right hand side we have a system
server which again you know has a system
server java class which in this case
creates a power manager service power
manager service and what it does and by
again this is just simple you know you
so that's why i created the file manager
service basically gets register the with
the service manager again using you know
power so critical power as as a main and
that's got the service manager you know
remembers it also power manager service
service links with this power the TPP
which we'll see later on
you know so so it provides some
functionality okay and now we are you
know that's this is the system server
part let's grab the booting process
that's a good application it wants to
use a wakelock so what it does as an
activity that any mountains to grab a
weight loss in that activity it gets a
reference to the power manager and again
it gets a reference the power manager
usually through the context by saying
you know context don't get systems
system servers or system service puts in
quotes Viper power and essentially gets
a reference to the power manager now
again this is where that you know that's
sorry and that's what that's what gives
us this now the power manager it does it
acts as a factory for these wakelocks
wakelocks are objects that are built
from the power manager now what it does
is that it gives those wakelocks over to
the activity the reason why it provides
is offices weight loss is because wake
locks are stateful they need to know
where they are so that you can acquire
them and later on you can release them
and the state is in the wake lock
essentially it so it's a kind of a
unique ID if you all or a name or attack
so the riverwalk is given back to the
activity activity when at some point
does say wake lock that acquire okay and
this doesn't have to be activity could
be you know a service or something other
than that so it acquires the way o'clock
now the acquirer actually goes to the
power manager stub which is a very
process should say which again we get a
reference to buy for going to the
service manager okay what is essentially
this this reference this proxy is really
left friend see this guy over here of
course we can't go to it directly we
have to go through it to bind them okay
so so we're actually the power manager
in this case itself is more to say this
power manager is useless after we get a
get a wakelock the actual communication
with the power manager service is
through the way cloth not no longer to
the power manager so after we say aquino
acquire for release later on it again
to a proxy goes to the binder again
binder issues a transaction on this
power manager service power manager
service is essentially tight or even
extends from this stub that still
provides one of those all transact
methods which is what binder action
votes that stop those Linda Marshalls a
request into something that the power
manager service employment through job
nose and then the power manager service
now actually goes and say say wants to
acquire weight loss it goes a calls a
native method which now comes from this
power the CPP file again it's
implemented through J and I and then
this again the cougars and execute a how
essentially function which is acquired
the wakelock which is implemented in
this power let's see now part at sea is
actually part of this lip hardware
legacy daughter so you could be
implemented elsewhere but that's
essentially what this you know by
default uses to load it and what this
does it does nothing more than a simple
right again simple I all right during
this case sis weight loss or is this far
away clock and passes the tag name as
well as potential you know expire if
you're you're asking for a wakelock to
expire later on when you want to release
their wake lock it does exactly the same
thing except that it goes again all the
way down here in court ops to wake
unlock to basically on log at servants
or not log that they wake up okay yeah
well I think when I remember dating to
the power minus service instead of
mapping all the calls on to Colonel
wakelocks the power manager service
actually maintains all the user space
play box and then there's a single
wakelock called power manager service
which are crabs in the panel and
releases if there's no way glass that
users visited requested so it's
basically and it's possible that that's
I'm not going to say let's not do or
does what's going on um I've actually
not I should have double-checked this
for ICS either way whether whether
sure the power manager as you said
multiplexes you know the weight loss
ultimately is going to go to that driver
whether it's going to use a shared wake
lock or whether it's going to use you
know Apes app-specific wake lock what
being is that that this wake walk over
here is referenced as a some sort of
state on the side of the power manager
service so that thing knows essentially
what's current outstanding ok cool first
one is if the application should fail
always so activity manager service is
also actually aware of the current
outstanding or its aware of basically
applications and hold wake locks and not
look specifically into how I where it's
holding that list but it does handle
that there may be something else as well
that I'm not looked into but I know that
a service matters activity insert
manager service does have a essentially
cleanup code as well in there so so so
that's also a good point so binder
allows you to to basically attach a call
back to pretty much any process so that
if it dies you can execute rent in
random clean up but I know that there's
basically more cleaner that can happen
even if an application misbehave which
is not you know it dying it just
basically says goes in as you know stop
state and doesn't release awake log
there's there's some time outs and so on
and so on implemented activity manager
service but this box says hey this
process
before present no we r memory kill her
it doesn't care about the way clocks
activity manager service does and
lactating managers is actually the first
line of defense if you will in memory
management so it would it'll preempted
kill applications the let me read killer
can't comes into play when when it
activity manager service doesn't
actually properly or when the
applications don't die the user
wakelocks among other things yeah oh
yeah so let's move on I do have a quite
a few more things to talk about and the
other one around the time so our lungs
so you know this is folly that you know
here this morning by having you know
this happened so i use the best clock
IDK which is system admin assistant
application to to basically you know
schedule in noir on the right hand side
again what do we have you know we have a
system server instantiate this alarm
manager service a lot manager services
links to this alarm manager service the
TPP which we talked about you know cobb
but it does later this on the other side
we had a that's called the best clock
again goes and talk it has internally
some sort of activity called alarm clock
which is some sort of you know functions
static a bunch of static functions
implemented in this alarms alarms
actually loses a context and asks the
context for your manager context
actually this context implementation
goes down to the binder it figures out
to gives it something by name alarm so
now we have the alarm manager now the
alarm manager is where we invoke the
alarm manager again is implemented as a
binder service so this is really where
we what we talked to is really a proxy
that proxy goes down to go to the binder
from the binder we have a call to the
alarm manager service now they're saying
for example schedule something to be to
be woken up and then this good this goes
it invokes a you know war manager
service you know of native confirm
implementation which uses I Oct else to
talk to the to the driver which is
employment 3 / desolate alarm now
there's these lists of things that are
scheduled and then you know there's
management of what's the next thing that
s essential needs to like
device we have a time to go to the
specific survivors but ultimately that's
the that's that's what happens when you
schedule a repeating up you know
repeating wake up or exact wake up in
the in the future so package manager
this is a you know again just to show
you a little bit of a difference here we
actually had yet another process so
let's say you only install in your
application what happens so typically
you actually send an intent to install
application and you pass by you or I the
location of an apk which can be an SD
card could be somewhere else and what
you're doing is you're essentially
launching this package installer package
installer you know inside of it has a
package installer activity which happens
to talk to his convenience class called
instead app progress which in turn gets
a reference to the application basically
this application package manager and
again this application package manager
is an instance of package manager can so
that it actually builds it instantiates
it's kind of hard coded this package
manager this application package manager
and essentially again talks to the
binder gets a reference to the remote
service which is this package manager
service and now has a proxy so hopefully
you're seeing a pattern here right and
that then we then involve that proxy
transaction method that goes against the
by there from binder and goats
transaction into the package manager
service how this is getting here again
the system server put in here and
registered with the system's service
manager so now we have the package
manager service between Oh extends from
this stub again but the processes that
care of the marshaling the marshaling so
now that this does it talks to this
installer which is you know just a local
a local you know convenience if you will
you know object it's not exposed
elsewhere which in turn actually what's
interesting talks to this install d
sorry I should say it sends messages to
install the UNIX socket these messages
are read by this install detaining now
though why do we need this installed the
you know Damon why don't we just not
directly install the application and
well the reason being is the system
server runs as the system user and every
application went when installed when
created needs to be assigned a unique
UID and then all the files and
directories need to be owned by that you
ID so we can't change all the the folder
file the feathers if you all the files
from the system server so instead we
have the stall d do that work for us
thus install deal runs as root and the
reason why only we can talk to install d
and nobody else is because this
basically socket is only readable and
writable by the system user and root so
that's how we get the directory
structure created now of course there's
more work that happens in the background
like the you know the moving of the
libraries into the room in the native
life in the right place the running of
the decks optimizations and so on and so
on we're not going to go into that now
that's kind of the workflow and what's
interesting is there's a helper Damon
here being used to augment that workflow
Wi-Fi so as you can see it's
progressively getting more complicated
Wi-Fi Wi-Fi i mean the Wi-Fi management
not the actual communication to Wi-Fi so
ultimately what we have is again let's
say someone application the lines to
issue a scan of you know local hot spots
i gave him an activity again given
manager hopefully again but now you're
seeing that manager is nothing more than
a proxy to shield us from no knowledge
of the binder the manager actually talks
to this proxy which we obtain the grabby
reference to this Wi-Fi service now when
we invoke a method call on that proxy
that becomes a transaction through
binder so gets the binder then from
binder we get into this you know Wi-Fi
service Wi-Fi service garden here by the
system server basically creating it and
then registering with the service
manager the Wi-Fi service what it does
it calls the thoughts of this Wi-Fi
state machine there's a sport management
of the state on what's you know where is
the state of the Wi-Fi whether it's
active inactive whether it's supposed to
be active
other drivers loaded and so on and so on
because the Wi-Fi driver tends to be one
that actually can be loaded out loaded
and reconfigure with different firmware
if you for example when I use it in a
out you know in another motor in this
peer-to-peer or Wi-Fi direct mode so
lets me get more get into the details of
it but ultimately well this is doing is
then invoking Wi-Fi native Wi-Fi native
is essentially just a bridge to the seal
and which or c++ if you will which
basically links to this Wi-Fi dot CPP
now Wi-Fi that CPP actually talks to a
hull component which again comes from
this would Harbor legacy it's Wi-Fi dot
C which by default and most of all is at
least my galaxy nexus does use it and
that's in such an implementation that he
uses one of the things that I Patsy is
responsible for is for example loading
and unloading the driver into the midst
of the colonel on my next success for
example that does happen on the Galaxy
Nexus that doesn't happen it's actually
it's not delivered as a module but one
other thing that it does let's say you
want to scan for hot spots or you want
to initiate like a thin supplicant or I
don't know connect to initiate a
connection to a particular network it
basically talks to this WPA client which
comes from the the exterior directory
and you may notice that you know there's
this WPA and there's different versions
of its the five six and eight on galaxy
nexus for example uses version 8 this
client then sends a message violet a
eunuch socket again it gets you know I
know these lines crisscross your looks
in the we're sends a message via Linux
Akkad chew this wpa supplicant the wpa
supplicant is actually what talks to the
driver and does the configuration of the
driver now the way past the driver it
depends on you know the database
supplicant support different drivers in
this case on at least the Galaxy Nexus
this is the Sun welcome driver that is
essentially that implements this NL you
know 80 to 2 2 to 11 you know to 11 so
802 11 API and essentially that's how
the configuration happens go ahead
I don't look at it I'll be a supplicant
standard one they have it over and
you're using that so you don't have to
change standard there are I mean are not
that I'm so so so honestly I've not used
WP or they're not had any experience
with wpa supplicant prior to android so
i have seen changes to the source code
but that said it is in the external
directory so they are you know I'm
suming trying to stay as close to the to
upstream as possible but I can't very
specifically the percentage if you will
the code it's affected by you know
android i dunno to do different versions
of it that you know different different
devices for different versions will ever
be something and depending on which
which cars they have or form driver
there is the reason why they use sockets
to communicate the system server to the
other demons is because it's just a
one-to-one connection on many to one
connection like applications document
system service yeah I wonder why don't
you find your just to talk well because
that would be a supplicant is a it comes
from from linux already i think it's
dual license that's not why we we can
use it and so they already has this
framework for basically you know so as a
client in a server if you will so using
this way
right good point okay so location I'll
just quickly go over this so location
basically has a again a service here
called location manager service which is
put in you know created by system server
it extends from this star which you know
it's this stuff comes from an aio file I
know from the other side we have an
activity that wants to talk to a manager
the manager gamecocks the proxy just
like we've seen already nothing too
exciting on this side yet when we say
for example get less last known location
with this disaster which provider we
want to you know do this for with this
GPS network or passive and it also looks
at whether it knows or has the previous
last known location it then let's assume
it here we want GPS he goes and talks to
the GPS location provider which
essentially first of all we talk loads
it as a Java class or Java object which
essentially is implements the native
functionality through this you know gps
location provider TPP which in this case
looks for violet hardware not only party
like a safe harbor for a component
called GPS and then he has the glib
hardware has a specific mechanism that
he uses to search for these kind of how
components some of them are legacy some
of them are current the newer GPS being
one of them and on my galaxy nexus
allows this particular library that's
the first 1i refines so deal opens the
library the library provides the
function prototypes that you know
they're declare in the gps dot age and
that what that knows how to talk to the
actual gps hardware in my case in Galaxy
Nexus it is talking to this particular
you know that's where the GPS is exposed
through and how it actually works its
proprietary I don't actually have access
to the source back to this I had no clue
how it actually behaves underneath the
covers that's set on galaxy s4 sorry
Nexus S you know there was one extra
component there was a GPS Damon that I'm
not sure exactly what it did in terms of
it provides some sort of state whether
it's to make GPS when it does candid
caching weather may the GPS
quiet you know signal acquisition faster
by using you know access to networks and
so on and so on again that that's the
part that was proprietary I know that it
you know that was not part of the
standard if you will but that's what the
gps or the lid gps if you will talk to a
galaxy on certain xss now one thing
that's interesting about location though
and this is true for other things like
sensors and so on is that it also works
the other way around so for example if
you subscribe to receive your location
updates what you're doing essentially is
over here you're passing a reference to
some sort of a listener all the way over
to this manager service this manager
service can for example now use the
listener to post updates you know they
get from the from GPS and then the
binder call goes the other way around
now the update is being executed inside
of let's say the activity this you know
the main Pullman its location listener
by a binder thread inside of the client
app so the communication can happen you
know back and forth so asynchronously so
so you cannot change public API at all
and call yourself and your quarter
device names are compatible device
period understood um live in servers so
you mean what's implemented here there
so it's a good question I been believed
that the CTS or the CDD does you know
talked about it specifically the Android
sir for example the live and good
service in one needs to implement it
does say for example what the you know
GPS age must stay consistent so this
implementation can be whatever you want
to as long as you're providing the same
consistent implementation of the order
of the hall component but whether for
example you can go and change this I
believe UK probably can I've not looked
at it specifically let me actually have
a few more things to talk about and will
that but I want to run out of time so
and then I'll get answer your questions
afterwards um here's another another
more complicated you can see a lot of
lines so for example here what we want
to do it let's say change the volume or
of our device right there is something
in Android called audio policy there's
actually a pod this morning on the tiny
tiny also I nobody else is part of what
we're going to use a tiny time something
how audio file or something the
basically you know doctor talks about
this in little more detail but anyway
let's assume we want to change the
change the volume so again real activity
touch the manager toss to the stuff plus
the driver down the little the binder
binder goes over here to the audience
ray to the audio service and that all
your service again it gets really messy
with his line so it's kind of hard to
follow so bear with me here on this
audience service calls this audio system
this audio system is actually
implemented in Jay and I through audio
single CPP this in turn and loans this
audio system work which comes from lib
media which actually initiates another
binder call ok and this call is done in
C or C++ so it causes BP audio spoil as
a service which actually in again girls
and gets a reference to something called
audio policy so now we go grab a
reference to this although specifically
the other palaces service which extends
this this article is a service rosenthal
essentially loads a call component a
specific you know how component sorry
not yet it goes and causes all your
parents manager default which they rose
the hall component which in the case of
Galaxy Nexus allows this tiny also
implementation which is new essentially
to it's a simplified implementation of
the also and specifically in the inside
of the mixer see cause or passes through
ioctl it's essentially controlled to the
to this driver to tell it for example
Tojo's diwali ok now the volume dozens
can be directed for specific channel so
you can have volume you know 44
whatever bluetooth and be a lot speaker
and so on and so on so the nike sig is
you can see here what's interesting here
is that you have actually to bind your
calls to get to this and the reason for
this is because this is where the media
server this is in the system server this
one actually going to leave for last
because we are going to run at a time
because this this one is so complicated
I you know give up on drawing lines tell
me why you get to this let's couple
mention a few more things and that the
left one is interesting so telephony is
down again slightly differently the
really wild system server with respect
as we talked to the weapon itself
instead what it does you have in this
phone app which essentially causes call
controller I don't know why we have two
of these one of these is an extreme
activity which talks to this form
utilities which talks the phone madacorp
call manager which does talk to the
audio manager which actually mentioned
in previous slide that we could just
resent repels assistant the you now in a
phone call so the system knows how to
steal focus away from other applications
they need to say playing music resume
talks this phone once we talked to the
phone where the phone is actually sorry
implemented by that's a cdma phone or
gsm phone the gym or regards next we
have the gsm phone which actually talks
to will Lil is the radio essential
interface or specifically real talks to
this real d which is a daemon then the
way the communicator is not by a binder
but thought it through unix socket so
those the WebSocket real d that
essentially we use to exchange messages
a vot is persistent and the reason why
it's persistent why it's not just a
simple how is because we needed to
receive calls from the basement modem or
unsolicited requests like when there's a
phone call coming in so there's
mechanism for us to receive those in
here as well as to send out messages one
of the things that really does it
actually loads something called reveal a
liberal which in turn looks for a
specific library that's that is
essentially a halt so in my case it's
this bed early a little you know second
a library which in our case again uses a
specific driver too
initiate communication with the basement
modem through you know AT commands for
example and again this is mostly
proprietary we don't have access to the
driver most the time and you know but
that's the general how it works this is
where all your component to it which
we're not going to you know have time to
how does you know you all fit into this
picture let me just mention one last one
and then we'll probably wrapping up so
device policy service so the best policy
is what you use to enforce the or or use
the device administration which was
added in frail and so for example let's
say you want to initiate a whitening of
the device okay let's say you have you
are replication is device policy enabled
so you are with device called a device
administrator let's say you want to
write a device you're an activity that
goes and talks to this device policy
manager that again biased on this proxy
via then you know that it gets from the
service manager via the binder talks to
basically and this is again gets very
complicated from Morgan William little
talks to basically this let me find it
now the Vice Boris manager service
device policy manager service actually
talks to let's say you're doing the
white command as sure you get the
permission for it does the recovery
system the recovery system actually
schedules goes over here and this is
hard to see that he writes to this cash
recovery directory let's say you want to
wipe the widest system and then busy
schedules a reboot via the power manager
powermanager essentially over here as
you can see is touch this part or is
implemented and this is again a binder
so this power manager is what we talked
to the previously which is implement why
power manager service so there's
actually maintain your binder call
happening here this is still in the same
process these girls it essentially goes
back over here to power to in shade a
reboot I should say talk to this shuttle
thread which stops the power to issue a
reboot the power actually goes and down
there somewhere I can find a link past
two sorry right here to the power CPP
which actually does a system call to
initiate a reboot all reboot because we
wrote this file that we want to
and we also should fected something in
them in the bootrom we basically
initially you want to do a recovery what
happens now is the recovery Damon this
is after the reboot runs execute this
recovery see this goes and reads for the
command and then based on the command oh
I have four minutes that's amazing and
then reads from the command and then
based on that command version
essentially execute a in this case now
erasing the volume which then you know
talks to the MTD and you know erases
block by block or just reformants the
volume depending on how its implemented
so it's interesting here as you can see
there's again quite a few services
involved and this is even touch the full
picture me if I actually have to draw up
lines for everything you know it sir
just wish spaghetti as it is but
ultimately you know this looks it's
interesting is the service call happens
after a reboot through the use of
recovery and let me just make sure this
brief way it's just well I guess three
and a half minutes in this case audio
playback so again this is son of
complicated sorry just you know just get
up on lines let's in order to play an
audio track and audio track is you to
play through something called media
player media player yeah I don't know if
any of you have a chance to look at the
API but you'll see it has a fairly
complicated state machine I have to go
and call you know set the data source
that you prepare and then you actually
do the play and hids calls actually
burst quite quite deep through the stack
ultimately the what happens here is that
this activity will be talking to a media
player which really just implemented to
a C code which starts to an actual proxy
to a media player that exists over here
and so the ji is happening on the client
side we're not doing binder you know
from drive up to two system server or
media server in fact we're doing the
binder call from here so from here into
here so it's kind of it's not what we've
seen before and again it couldn't drag
lines for binder this player of service
I should talk to this media player
service which figures out what sort of a
player to get let's assume this is a
playing a local file
and so if not looking for that state
right player what's interesting is they
bind their support sending file
descriptors from process to process and
even though the file descriptor is not
really the same number if you will on
the side of the other on the other side
it does point to the face same physical
file and the same offset in that file so
that's so when we see a plan that's an
mp3 file we're sending a file descriptor
to the other side to initiate the
playback we let say to the raw data
right we're copy the data we're just
setting a file descriptor now the state
site basically goes and in this case
that's a initiates in all you know this
awesome player it's interesting name
this awesome player basically goes and
again depending on whether arena in a
set data source or the prepare or the
call those different things that happen
but ultimately what happens inside of
this we're now in the stage fright what
happens is that also player builds up
this pipeline of a fuels media sources
that essentially present what you want
to play so let me just quickly mention
this and ultimately we are you know the
despite going basic doors by I thought I
have two more minutes this popular basic
arose like this you have a media
extractor which reads a raw file then
you have essentially a decoder that
actually the codes data from that file
then you have something when the curve
is implemented through this open max I
all plugins which vendors can provide
and then we hardly actual a media player
which is reading essentially one bite or
i should say byte buffer at a time so
it's saying okay because one byte buffer
the fact this business is going extract
my guided by gotta retire there is goes
it reads one byte buffer at a time from
this media source which could be either
over media source agree or it could be
like a network media source ultimately
this then talks to the audio flavor are
you fingering my key steps who also the
study also toggle supports the micro no
driver and you know that's gotta mean
you have play a pair of like happens
there's also communication with the
other policy to acquire a focus and
other things again i'd be happy to talk
more about a bit unfortunately we have
run out of time so this is you know I'll
take any questions offline but thank you
for a thing</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>