<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Learning Functional Programming without Growing a Neckbeard | Coder Coacher - Coaching Coders</title><meta content="Learning Functional Programming without Growing a Neckbeard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Learning Functional Programming without Growing a Neckbeard</b></h2><h5 class="post__date">2012-12-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OOvL6QAxRK4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I mentioned in the description that your
eye
functional programming can help you
write code that's like Pam Grier and I
realize that not everyone may know who
Pam Grier is so I thought I'd give you a
short introduction by showing you the
trailer for Foxy Brown Pam Grier was a
yeah no kidding
Pam burr is an action star of the 70s
80s 90s and today and Pam Kerr is pretty
awesome so what does it have to do with
us good question well we want to learn
to write code with drive that don't take
no jive so I want to introduce you to
the Pam Grier criteria for code
badassery so Pam Grier like the code
that we want to write is powerful
beautiful and tough to mess with so when
I say powerful I mean the code you can
do big things with you can do them
easily and you can do them quickly right
tough to mess with I mean secure from
manipulation it's hard to start to mess
up yourself that's a good criteria of
code and also that it's easy to maintain
it's hard to mess up unintentionally
later another word for this in terms of
comas quote coded robust but I felt
really weird calling Pam Grier robust so
I went with tough to mess with the last
one is beautiful so I'm not trying to
objectify Miss career I'm trying to
function of by her because it's fun
spunk I get it all right um the point is
though she is undoubtedly beautiful and
the last two attributes contribute to
that and I think that's a really good
analogy actually for functional
programming so we want to write code
that's elegant and that's concise and
that is easily readable
although functional programming has a
bad rep for that and we want it to be
able to be easily reused
that's a beautiful quality in code and
we also want it to be fun to write if
it's not fun to write you're not going
to want to write it and the language
isn't going to get any any any momentum
so this is a scala meetup we're talking
about writing functional programming in
Scala there's a couple things I just
wanted to mention some things that
you're going to notice about the Scala
code in here
one is that you don't need parentheses
for method calls you can just if you put
the name of the method you can then put
the arguments after it another one is
that semicolons are optional and return
value is also optional you can use
semicolons you can use a return value
but you don't have to which is pretty
cool
another thing is that Scala is a
statically typed language with type
inference okay that's a lot of buzzwords
in a row
what statically typed means is that
everything that you declare has to have
a specific type if you have a variable
and it's it's a sequence of characters
that forms a word that's a string and
you say it's a string it has to be a
string when you assign it and what that
what the place that that's enforced is
that compile time rather than run time
so if you mess that up the compiler is
going to tell you you're not gonna be
able to run the code now type inference
is interesting so if you've written Java
code you powder in a lot of code where
you like have to repeat the type eight
times you're like this is a string I'm
passing you a string you're getting back
a string and it's like come on computer
like why can't you figure that out so
Scala cans that's pretty cool so like
what does it look like it's kind of
small I apologize I'll make that bigger
next time so we see we've got a value X
and we declare the type after we say
string equals a so the type of the first
one what is it the first line anybody it
says it it's a string good job what's
the type of the second variable Y
integer you figured that out what's the
type of the third one it's a float or a
double what's the type of the fourth one
two thing so you're smart enough to
figure that out by reading the cool
thing is the Scala compiler is also
smart enough to figure that out by
reading I also show through up there a
list declaration notice you don't have
to declare what type of list it is it
knows that the list of strings and just
to show you that we access strings but
I'm sorry we access elements in a list
by just doing parentheses in the index
this is just a few like quick just so
you're like ah you're not like whoa what
is that when we see some Scala code in
action
so that's Scala here's a method in Scala
this is a paddling method I wanted to
point out here that the types are
defined after the variable name which I
mentioned before the return type here of
haggle is a string and it's defined
after the argument list so that's good
to know
notice there's no return in here the
last line of the method is the response
so it just returns their response if you
take off their response here actually it
still works which is kind of crazy if we
were to do this
oops oh it's so tiny even I can't read
it I apologize if we do this still works
it's kind of cool it just knows it says
hey the last expression that you defined
is a string so I'm gonna give you back a
string and in fact we could even take
off this and the code would still no
it's pretty cool right um so yeah
notice here yeah so that's just a little
bit about what Scala looks like just so
you're not I don't want you to be
surprised by anything in the code well I
do but not just by this in text
functional programming that's what
you're here for functional programming
is awesome and you want to know how to
do it preferably without you know
growing your proverbial neckbeard and
I'll get to that in a bit but what is
functional programming okay good
question that no one asked me directly
so to answer that we have to ask another
question well what is a program whoa man
so I'm not just asking that to be
philosophical because actually is
important
does anybody want to throw out a
definition of what a computer program is
it's what set of instructions for a
computer very good it was not a trick
question that was exactly the answer I
was looking for in fact it's on the next
slide so we'll ask a kid this is
actually from single simple English
Wikipedia a computer program is a list
of instructions that you tells the
computer what to do right so everyone
knows everybody that's what a program is
right wrong okay
sorry little girl that's not actually
wrong and our lovely brightest wave it's
not actually wrong it's true that is
that is one definition of a computer
program that's what a computer program
can be however that's not the only way
to write a computer program that's
actually called imperative programming
and and we have object-oriented
programming which some of you may be
familiar with it's a different variety
of imperative programming as well when
you do imperative programming you're
saying do this then do that then do the
other thing and then maybe give me back
the value right we've most of us
probably written programs like that
object-oriented is a little different
it's saying this is a doohickey that can
do this and this is a what said that can
do that so hey do a key go ask the
whatsit to do that but it's still
instructions and they're just having to
be encapsulated in a different structure
so that's that's the most sort of more
familiar type of programming that we
normally do if a program isn't that if
it's not a series of commands then what
is it that's a good question too
so the concept in functional programming
is it asked the question basically what
if instead of telling the computer what
to do we just told it what things are
yeah not like a lot of cheers not love
like ah because it's kind of a weird
concept like I mean you're probably
saying some stuff like okay I tell
computer what the computer a computer
what things are all the time first off
so why is this different you're probably
also thinking if I already knew what all
the things were I probably wouldn't even
be writing a computer program so fair
enough right but let's talk about what
the evaluation of expressions mean
instead of the execution of commands so
what's an expression what things are so
this is an expression so here's the
first one
it
says the valve the queen is equal to
elizabeth ii that's a that's an
assignment that's a really common type
of expression however this is also what
things are it says that the governor
given a state is the top vote-getter of
all the candidates and this is this is a
definition of a term but it involves
doing some computation to get the result
and so this last one is super important
it's critical that's a function and
that's our building block for functional
programming so what is a function
function is a relation between values
where each input value gives you exactly
one back thanks C for T so if you've
taken a CS class or done programming
before you're probably thinking like
wait a second that's not what I learned
a function was and this is this this is
a mathematical definition so you may
remember this from algebra or
pre-algebra
so it's stricter than our normal
programming definition our normal
programming definition says a function
is just a subroutine it takes a
parameter sometimes no parameters and it
returns a value what we're accepting as
sort of our guiding principle we're
doing functional programming is that
we're going to follow this definition of
a function so it's both a definition and
a rule kind of a guideline you don't
always stick to this but you try to as
much as possible and that's how you do
functional programming so it still it
still covers a lot of things that you
know and love like you might know this
as in fact as a static method so you
don't need an instance of a class to
call a function like this so here are
some examples
we got math dot square root we've got
collections dot sort when you copy an
array a lot of times you do this these
are all static methods and these are
functions under our def and our new
definition that we're accepting so does
anyone recognize that bottom
illustration this is something I
remember from math a long time ago it's
like a black box right the idea is you
put something in and you get something
out and you when you put the same thing
in you always get the same thing out and
the reason why I included it is the
thing that's important is that it's a
box it's closed you can't besides that
one input area put anything else in it
nor besides that one
output area can you get anything else
out which is pretty important and so
here's a definition of something called
a pure function which is sort of this
limb or limited function that we've
adopted so a pure function basically it
can be described only in the terms of
its return type which is what comes out
of the meat grinder down there and its
arguments which what is what goes in the
top and if that means it doesn't touch
anything else in the rest of the program
which is pretty interesting that's our
building block we've taken away some of
our abilities when we do that right like
manipulating state is a pretty important
thing to do in a computer program so
begs the question what do we get in
return this cat is skeptical I should
have had that up low same so um so
here's some things about functions that
we're going to go over first one
functions are deterministic you'll
always get the same result if you put
the same data in that never changes
there's nothing you can keep giving the
same function the same thing over and
over and over again you never get
anything back believe there's a
definition of sanity that involves that
so this is a really calming thing to
know it's it is because you know you can
reason about the correctness of your
small chunk of programming and that's
like that's really useful because if
you're a working programmer and you've
ever had a bug you know how unusual that
is actually so it kind of eliminates
this entire like vector of bugs which is
where something happened in the rest of
the program and all of a sudden my my
program my small sub program is
returning different values it's also
really nice for unit tests because you
don't have to set up state debugging it
can make it easier to pinpoint where you
need to debug I am NOT going to say
debugging functional programming is
easier because that is not true but this
can have benefits for debugging in that
look if something's going wrong with
this function you know it's you know if
something's going wrong with the output
in the input you know what's happening
inside the function
you know something outside didn't cause
it so as I just said so this is tough to
mess with Pam approves and so this is
pretty cool so we want to keep that
another one is that functions are
encapsulated this is a really cool
concept so as anyone like done any
object-oriented programming in a big way
yeah so I in college they tell us I'll
go into programming and I remember being
quizzed and quizzed on the for benefits
of absortion programming and I can
remember any of them except
encapsulation right now I'm abstraction
maybe but anyway encapsulation is really
important what that means basically is
like the stuff inside the function it's
a black box in a lot of ways and one of
them is that you don't care what happens
inside of it as you have you have the
description of the function acts as a
contract right it says if you give me
this I'll give you that every time
guaranteed that's pretty cool
so this is really good for readability
it means sort of that you can skip large
chunks of things if you don't care about
them it's kind of like I was saying with
debugging right like if you're if that
function ain't broke you don't need to
read it that's kind of nice it helps
with reuse it means it means if that
description of the function fulfills
your contract requirements you can use
it somewhere else and you're not going
to worry that the original caller is
somehow changing it and it helps with
maintainability actually which is I
think a really awesome salient point you
kind of have these multi small chunks
and you know that about creating that
you've agreed to you've agreed to keep
it that way so it encourages you to
break things down and make things
smaller and that's usually a good thing
this is beautiful I think this is a
really elegant way to write code it it's
it's making promises in your function
declarations that are are very you can
rely on them so I like that this is also
tough to mess with for the issues that
for the reasons I said before you kind
of have this unspoken agreement with not
only yourself but yourself in the future
and all other programmers who are using
your code this is what my function takes
and this is what it returns so that's
cool functions are commutative I don't
know if that's the right word actually I
looked it up on Wikipedia and it looked
like a pretty good word what I was
trying to say was that the order doesn't
matter this is a fancy way of saying
that right so if we look at this code
you squint and look at it it says you've
got a vow first thing and it does one
thing you've got a vow second thing
calls do another thing and the third
thing depends on the results of those
two values does it matter if we do one
thing before another thing not really we
don't care as long as we've got it by
the time we're ready to do the last
thing and this this is like a super
powerful concept because what this means
is you've got these little chunks of
work and you can parcel them out to
different machines and to different
threads and that's where we're going the
chips aren't getting they are having
more capacity instead we're running into
parallel cores and parallel computing is
is becoming more and more important and
functional programming you get some of
that just for free you don't have to
worry about crazy structure or anything
like that
because if you've got your little chunk
you know that that it can be run while
other chunks are being run another thing
that's useful about it is lazy
evaluation let's say in this example do
another thing takes freaking forever to
run that happens sometimes right what
you can do in a functional programming
language is you can you can just wait to
run it until you need it instead of when
you initialize the program running that
really long do another thing and you
know your users are just waiting they're
like watching the spinny thing you can
wait until they click on whatever it is
build the widget and do it then so
that's pretty cool data is immutable so
this one is pretty interesting this is
one that to me was not immediately
obvious from looking at the definition
of a pure function what this is saying
basically is that once you've created an
object you cannot change it and if you
want an object that differs in some way
you got to make a new copy so you're
probably familiar with this from if
you've used Java because this is a
string work string is immutable so we've
got two strings up here right first one
says San Dimas highschool football rules
and the second one we've taken the first
one and we've called to uppercase on it
now s2 altered s1 right it changed it it
called it made it uppercase what happens
if if you do print line with s1 it's an
uppercase or lowercase its lowercase and
the reason why is string is immutable
and immutable means it cannot be changed
so if you want that uppercase string you
got to copy it and then
okay step so this is pretty powerful
actually this means that there's another
whole class of bugs you can just like
don't care like I'm done with it because
the reason why is you know once you've
got an object that no one's going to
change that there isn't going to be
another calling program that changes it
right it's also tough to mess with like
I said it kind of gets it gets rid of
some bugs for you so that's pretty cool
Scala actually has both immutable
immutable data structures there are some
things that are really hard to do with
immutable data structures and one thing
that might be coming to mind is it can
sometimes be less performant not always
and we can talk about that afterwards if
anybody wants because it's complicated
subject but it can be slower so
sometimes you need a mutable data
structure but Scala defaults to
immutable so we want to just do a
mutable this is our building block it's
pretty cool functions or deterministic
functions are encapsulated they're
commutative by which I mean order of
operation doesn't matter any math folks
let me know if that's not the right word
and data is immutable anybody have any
questions at this point about those four
things that's absolutely true they are
and that's absolutely true and they're
not new and these any any not only kind
of new language use these people have
been encouraging folks in Java to do
this for a long time and if you go read
as anyone read effective Java it's
pretty good book is by Josh Bloch and it
talks about some like best practices for
Java and it's been around for a while
the first edition came out like what 96
97 or so
maybe that's wrong that could be totally
wrong he covers all three of these
concepts and he especially encourages
people to make data amitabh also you're
totally right not new concept at all in
fact nothing I'm going to cover it with
a new concept I will point out the one
there's one or two main things about
Scala that you can't do in Java but none
of this is new and in fact functional
programming goes back quite a while so I
hope I can I hope one of my goals with
this talk is to explain why it's
incurring a resurgence and why people
are interested in it now and a lot of
that has to do with what I was talking
about with parallelization because
that's become more and more of an issue
so this is our building block anyone
have any other questions is a great club
great great point
indeed this isn't new or we are in fact
reinventing the wheel here so this is
our building block let's build I really
like that guy's leg oh that's Legos guys
whoa okay um but how do we do it
so we maybe need some like guidelines or
concepts to like snap these together
because right now all we've got is these
little floating bits of computation and
I mean you know yeah sometimes you just
want the square root of something but
usually you want to do something more
elaborate so let's figure out how to do
that so one of the ways that we can snap
our functions together and this is the
one I was talking about this is
something actually that you can't do in
Java is treating functions as
first-class citizens so functions are
first class objects on Scala so what
does that mean it's kind of like a weird
it sounds almost kind of political right
um I don't think it is I don't know so
what's a first class citizen a first
class citizen is an object that can be
assigned to of or sorry not just an
object but a type of object that can be
assigned to a variable stored in a data
structure returned as a value and then
pass to a function let me get there
we're doing the strings first so so that
but you're right I am saying that cuz
that's the last one on the list right
and it's actually my favorite but um
well I don't know I'm not gonna pick a
favorite so this is a string and I'm
just showing you here with this string
we've assigned it to a variable we've
made a list of them we've stored them in
a data structure we've passed it to a to
a method and then we've returned it from
a method tie a knot returns a string or
maybe it was the other way around I want
to show that in Java you you can in
Scala as well of course you can do this
with like user specified objects or user
specified defined classes like if we
defined a rope we could then assign it
to a variable we can store it it we
could have a list of ropes we could we
could create functions that took ropes
in and then we can also create functions
that returned routes so
we can do this in Java with I'm sorry in
Scala with functions which it turns out
is like a really big deal
so right here I'm just doing the first
two I'm assigning a function to a
variable and I'm storing in a data
structure so let me see if I can
actually make this a little bigger that
help I might ruin some of my funny
images later but we'll deal with it when
we get to it guys so right here I've
defined a very important powerful
parallel lies enterprise scale function
that when you pass it a string it adds
and spam to the end of it obviously very
important tasks to do so I wanted to
show a little bit so this is this looks
even to me now a little bit like just
like a forest of punctuation right I
mean we've used basically and tight you
just like hit shift and went like that
over the top row the keyboard so I
wanted to go through a little bit so ad
spam is a value it's just like the value
that we defined for string maximum has a
type the type is this whole thing so ad
spans type is a function that takes a
string and returns a string and so
that's the structure its list of
parameters types arrow return type
so arrow sort of signifies arrow to the
set my left or right arrow to the to the
left sorry
signifies a function so that's the type
of ad spam so once I've defined it I can
then call ad spam on egg and bacon and
get that this point it's not that
different than a def but hey you can do
that might be worth doing some time
might be it might help one benefit I
could think of doing this with is for
readability if you have a function that
maybe you didn't write but that has a
really impenetrable name you might want
to rename it you could do it with this
we also could put a list of functions in
there and then call the function
directly from the array again it's kind
of interesting but not like super useful
so let's get on to the next ones
next one after this we'll be returning a
function as a value okay
returning functions from functions so up
here I've defined this function tag text
and this is something that you might do
if you were for some reason creating XML
by hand or HTML by hand right so you've
got text and you want it you don't want
to write a separate function every time
you want to add a new tag you don't want
a bolt you don't want have to write a
new bold function and write a new italic
function people don't even use those
anymore right oh gosh so um you you
would write this tag text and you could
pass in the tag and the text so if we
call tag text with emphasis and we put
in pay attention the result would be
pay attention tags with emphasis and we
could instead put in you know strong and
I'm really strong and it would it would
have I'm really strong tied with strong
so that's all right
to be honest I find that not super
readable you're doing tagged text m pay
attention and I have to in my head sort
of like move the M out and figure out
what's going on there so one another way
of doing this would be to have this
function that returns another function
right so tag text too I rewrote it it's
another function is another forest up
front the season I realize I probably
didn't really help with this particular
definition but tactics to takes in a tag
which is a string and it returns a
function so it's the same thing we saw
before it's a little hard to read but if
you look in here what you've got is
you've got a parameter list and arrow
and then the definition of the function
so tag text too if you pass and spam it
returns this tag with and spam toggle
and spam is a function and tabatha and
spam itself can be called on something
else which is kind of cool I think this
is actually really beautiful I find that
more that I find that much easier to
read to read tag text with something and
then the text itself and it doesn't
really clutter anything up or take any
more lines of code to create a bunch of
functions that are named
mostly using a function like this that's
pretty cool
powerful so one way that this is really
useful is in writing libraries actually
the reason why that's really useful is
because it means that you can provide
your users with like a framework and
then let them specialize as much as they
want so when I have been tagged texts -
I didn't constrain what tags you want to
put in there I hate to say it but add
spam is actually not valid html5 tag I
don't know why but if I wanted to define
it I can and if I had some need to as a
consumer of this code I totally can
that's pretty cool um you also you count
as a consumer of your own code I read
all these quotes to where it's like if
you come back to code you wrote a month
ago and it doesn't look terrible you're
doing it wrong and I always find that to
be true and I'm always having to reuse
my own code and so thinking about
yourself in the future is kind of a good
thing even if you aren't reusing
something at the moment you may want to
do something different with it later so
being as flexible as possible is pretty
cool
just like a little nerdy side note you
could use this function you notice I
basically just took a function with two
parameters and broke it into a function
with one parameter that returns another
function you can do this with any
function of multiple parameters and
haskell which is a really very
functioning functional programming
focused language actually does that so
it's pretty crazy
it's called currying it's also called
partially applying a function so does
partial application makes sense to
describe that we partially applied tag
text to when we gave it a spam and then
we finally applied it when we gave it
the text in the middle so partially
applied it's also called currying after
Haskell curry whose first name is the is
he's a namesake of Haskell the language
I think that's right okay so so far
we've assigned them as variables we've
put them in data structures and we've
returned them as functions now we're
gonna do the last part and I lied this
is my favorite part now we're going to
pass some functions as arguments to
other functions function party so this
is actually the meat of functional
programming I did not make this by the
way it was created by a professor at
Willamette University as a design
proposed design for like Haskell shirts
and he has a whole webpage with like a
bunch of them in there
maybe my favorite thing like like
functional programmers like it hot and
it stands for higher order and typed ah
awesome so functions that take functions
the joke here is that functions that
take another function are called
higher-order functions and like I said
that's the meat you need that for
functional programming and this is not
something that you can do with Java you
can build interfaces that allow you to
approximate it but it's it's not
possible and this is like kind of a big
value add for Scala
it's allowing you to do this so let's
talk about something that you actually
use instead of my silly and spam example
for loops for loops all the time that's
just something that as a programmer you
use constantly right and so this is a
really stupid for loop admittedly but
it's in its structure is something that
probably you've done a million times in
Java you've got an array you put it set
up a for loop you say starting at zero
until the length of this array
I want to increment I and for each index
and I do something here it's something
stupid you're gonna print out hey the
other day I ate a name of fruit but you
know you you do pretty complex stuff
with that that's a basic building block
of imperative programming so I rewrote
this in Scala Scala declares has its
array of fruits or its list of fruits
it's basically the same concept the for
loop looks a little different um it
starts at 0 and it goes it has this
until syntax to go until fruits salt
length and it just assumes you're
stepping by one otherwise though it's
basically the same thing right it's not
any different as I've written him here
so I think that there's a better way to
do this how many times have you written
something like this where you've stepped
through a list so many times right it's
boilerplate code it's boilerplate code
that I fat-finger more often than I care
to admit as well that's just like number
one if I see something weird going on
with iterating through a list I'm like I
typed it wrong cool I typed it wrong
like that's my first thought
that's that sucks I'm going to pause it
that we have really really powerful
machines right here that we
you you know take with us in our
backpacks on the train and they should
be able to do that kind of thing for us
so let's do it
let's get abstract let's abstract that
boilerplate away cuz I'm sick of typing
a for loop so one way to do this because
now we have this magical power in Scala
where we can write a function that takes
a function so what we might to do this
might be to write a new function and
have it take an array and then that
inner function does that make sense to
guys if we go back and we look at this
this guy is like a mini function in here
and that's the only part that ever
changes so I want to abstract something
that lets me just pass that part into my
function so that's my sort of proposed
syntax it's a for each is what I'm
calling it it's going to take a list of
fruits because we're iterating through
fruits right now
it evolves I into PI ax promise
spoiler alert a list of fruits and then
it takes a function that's gonna that's
going to do fur it's going to transform
a fruit argument of fruit into a unit
that's scholars word for void so
basically it's going to take up fruit
and return nothing shouldn't do that but
we're going to do it so with my with my
um sort of concept here I've kind of
defined a sample for each program
function so what it does is it takes our
fruit listener function and it iterates
over the list cuz that's the same thing
we always do I know I'm going to do it
the minute I get a list and now I'm
going to for loop over it and it calls
the function on each individual fruit
member okay so if I rewrote rewrite that
I would have my fruits I define a
function and then you for each for each
fruits tell them some things kind of
about cool about that is kind of
readable so more let's do it more so
sometimes I want to talk about things
that aren't fruit like pi so I want to
make it generic so what I'm doing here
is a is kind of like any
so what this is saying is if I give for
each a list of anything as long as my
function can handle anything it's cool
we can iterate through it so even more
abstract what if we weren't limited to
list what if I had a set of fruit would
have had a map of fruits to their
countries of origin I mean I could have
a lot of fruit collections I actually
this is true was a member of a fruit of
the Month Club in high school which is a
kind of a collection so this is even
more abstract right I've defined this so
I can do my for each on any kind of
collection of any kind of thing although
I don't know what you would do except
for fruit and I don't know I'm even know
why you'd be writing about that um this
basically a lot of hand waving is what
Scala did and so this is how you'd
actually write this sort of moronic talk
about fruit method in Scala
so it's fruits for each tell'em all
right it's not bad right so this little
function that we defined earlier so I've
moved the function we defined earlier
into that collection code so we're now
calling our for each on collections
this is not how Scala implemented for
each I want to be super clear about that
because I feel like otherwise people are
going to leave mean comments on the
video this isn't even close to have
Scala implemented for each the writers
of the Scala collections libraries used
all sorts of really cool functional
tricks that even I don't know about of
elite or not they they use different
ways of doing it that are faster and
smarter and safer than this so that's
cool that's a good thing and so that's
kind of one of the values of this kind
of abstraction right someone way smarter
than me can figure how to do it way
better and I don't have to change my
code to get that those benefits that's
really cool
it gets better without without changing
things and I can't make stupid bat
finger mistakes like I do I equals 1 or
whatever I do I plus plus plus and it
doesn't compile things like that I don't
even have the opportunity to do them
anymore so that's awesome it's powerful
it's cool balanced because we get to
configure what we want without really
caring about the mechanics so you get a
lot of a lot of stuff out
that's pretty cool so something kind of
juicier is now we're trying to do this
thing where we've got a list of fruits
and we want to make a list of pies out
of them so I just want to point out here
that dot dot is list concatenation it
says take a list of pies and add to the
front my new pie does that make sense to
folks I'm creative I'm adding a new pie
to this list so I want to take a list of
fruits and turn it into a list of pies
so on earth this is also another really
common thing that you do with for loops
you want to - for each member of the
list make something out of it or do
something to that member it's pretty
common something you all the time so
data is immutable remember with
functions don't want to return a new
member but basically otherwise going
through and doing something each member
the list super common we do it all the
time so there's this cut there's this
function called nap which does that for
us
the same way for each went through and
just did something without a return
value to each member map is going to go
through and make a new pie for each
fruit on the list and it's going to
return a list which is pretty
interesting so these this code and this
code are equivalent does that make sense
to folks awesome so I'm going to get
even crazier here so back there we
define to make pie as this function
we're doing that thing we saw it really
where we can define a function to a
variable we don't well this is a silly
example because of course you would need
the function make PI again you're going
to use that all the time right but let's
assume we only needed it for that one
step we don't need the intermediate
value you don't have to you don't have
to declare it as a variable you can pass
it directly into the function so I've
sent some examples up here we do this a
lot with it with other kinds of objects
with primitives so up here instead of
instead of declaring a string that's the
kind of fruit I want to make my PI out
my pie out of I can just pass that
string right in that's a pretty power
that's pretty useful concept the reason
why that's useful actually so at first
you might just think ok cool you're
saving some lines of code I don't think
it's really useful about that blueberry
in this in this example
blueberry fruit uses kind of fruit right
to make it spy kind of fruit is a
reference and kind of fruit could
through a malicious or simply
incompetent actor be changed by another
program another function another program
just another program or doing something
bad so that would really screw up your
function you wouldn't get what you
expected so if you don't need that
intermediate value it's a really good
idea to pass it in anonymously because
then you know what the value is we can
do this with a function and so I've done
it here instead of those first two lines
are equivalent to the last one so I want
to stop here and make sure people can
read that last line I understand it's
pretty confusing if you've never seen
this before but basically math is still
it's still a method on the collection
and we're declaring a function
anonymously and passing it in so that
make sense to folks any questions about
yeah Kevin so the difference between map
and for each and let me see how I
thought I had to find it um this tree
map and for each is that for each is
return type is unit and match return
type is a list so yeah so for each
doesn't do doesn't give you anything
back it just does something for each one
map on the other is going to do
something to each member of the list
that something could return you if you
were doing it over fruits it could
return you a fruit so you could be
peeling each fruit and you'd get a list
back of unpeeled fruit or it could
create something new like a pie like we
did in this example so I'm against the
folks yes
that's true that's why we don't use for
loops you've hit upon it so you're right
you don't want to be changing and the
only useful thing would to do would be
to output so that for each that I was
calling dumb actually is maybe the only
reasonable place to use it for a for
loop and that's why we don't use them so
I've rewritten this I've rewritten our
original one in this second block to
take the anonymous function and then I'm
thinking well what if my list of fruit
changes season changes all of a sudden
now it's pumpkin pie season and I'm
going to just go ahead and make pies
take a list of fruits does that make
sense to folks instead of hard-coding it
the cool the kind of cool thing there is
that we've reduced this down to a
one-liner and I think that's pretty
interesting if we go back to the
original one which was up here we've
gone from that to one line you can argue
about the readability we'll talk about
that in a bit the kind of thing that's
kind of cool it's still a one-liner that
makes it really easy to pass it
anonymously into other stuff and we
talked about the benefits of passing
anonymously right you can't get messed
with if you do that so that's beautiful
collection handling so there are a bunch
of methods like this and I'm going to
talk about a few of them briefly I
encourage you to explore them on your
own
one is filter filter takes a function
that takes in a member of your list and
it it uh it takes in a number of you it
takes in a function that this is kind of
hard because you get you can do it's a
function that does a function that this
so filter takes a function that that
takes a member of your list and returns
a boolean and what it's going to do is
it's going to return a list with only
those members that satisfied that
boolean so that's a pretty common thing
to write you literate through a list and
you only want to get back ones that meet
certain conditions so in my example here
I've filtered out pear and honeydew
because I don't like those fruits I
think they're watery
fold so fold is a little more
complicated so another thing that for
loop I think the glaring omission here
is accumulation a lot of times you'll do
a for loop to count right you'll do a
for loop to add all the values I want to
get all the votes I want to get the
cumulative age of everyone in this room
you would do a for loop right so fold
lets you pass it
beginning value and it's going to take a
function and what it's going to do is
going to take that first value in that
first as an accumulator and it's going
to call your function on the first on
the fur it's going to call your function
on the first value plus the first value
the list it's going to take the result
it's going to call it with the second
value and the third value and the four
value it accumulates counting like I
said is such a common case that there's
actually a like syntactic sugar for it
there's a different method for called
called reduce and reduce just starts at
zero and counts these can go left or
right so the reason why I want to show
you guys it's an example of how powerful
functional programming is Google company
you may have heard of with a combination
of map and filter has used that our SIA
map and reduce filter to probably safe
search right map and reduce has used
that to index the web and it's a
framework for doing like massively huge
data processing that's used by a bunch
of people as well could you grab me my
plug for my computer thank you all right
so this is powerful you can't see
because I made the text bigger but
there's Pam down at the bottom that's
super powerful nested for-loops we do
this all the time right
the examples in books are always like
cards like you go you loop over the
suits and then over the whatever ordinal
numbers I find cards kind of boring so I
did PI because I do not find PI boring
in the slightest
so for here this is an example so
everyone knows vanilla vanilla ice cream
apple pie go well together maybe you
want to try all the possible pairings of
pie and ice cream in the world right
that would be awesome you would probably
get sick this is a nested for loop to
let you do this it's going to go over
for each pie that you have in your list
it's going to take the pie and for each
ice cream you have in your list it's
going to make a serving with a piece of
a pie and a piece of that ice cream so
probably a lot of pie and ice cream but
sometimes for science you have to suffer
so we know that we can we can reduce a
for loop with mats right so one way to
do this I'm going to make this really
big let's just do that right this this
for loop here and the inside let's make
that map instead
so hang on sorry so if we go in here
right and we do map we replace this with
nob I'm going to say well we've got ice
creams right that's a list so we can uh
ice creams we can map over and what we
want to do for each one is we want to
take an ice cream so that's our that's
our per am and so it needs to be in
parentheses and we're going to create a
function that creates a new serving so
we have a function that fits new serving
and we ought you know we don't need to
add it to serving since a map it's going
to return a list so it's going to return
a list of ice creams for each pie so
that makes sense we probably could go
ahead and do it with the other one right
maybe it doesn't want to go next okay so
we could do it again
so we're mapping over the pie and we're
mapping over the ice cream and we're
returning a new serving for each awesome
right one little problem
this code isn't going to compile so the
reason why map returns a list right so
we've got for each pie we have a list
we're going to end up with a list of
Lists that's not the type we want when
we just want a list of serving so we're
kind of stuck right like we're gonna
have to do something else to get our
list of Lists into one whole list and so
there is a method for that it's called
flatten flatten takes a list of Lists
and it turns it into one list so we've
got this is how we would call it we have
our thing our our double map that
returns a list of Lists we're going to
call flatten on it here's my question
this is the functional programming way
of doing a nested for loop this is what
it looks like
is this better than that Oh kind of
looks about the same length it's maybe a
little less readable Pam Grier is
skeptical and I'm skeptical too frankly
so the solution comes in the form of
function composition so function
composition is taking two functions and
taking the the return value of one and
passing it to the other so you make one
big function and I love this
illustration they get such a good
illustration of that right it's pretty
simple concept you could see it as s of
G of X express that way a lot I've got
these two functions bake up high and eat
a pie sometimes I make a pie and I don't
eat it right away
that's unusual sometimes I eat a pie
that I did not bake that's more usual so
I need both these functions right but
also sometimes I just want to bake and
eat a pie and so I want to take my fruit
and my crust and I want to turn it into
a happy Kelsie and I can do that instead
of writing a whole new function I can
compose them here's where the magic
happens
flatten compose flat map which is our
final compose map which is what we had
to do earlier right we had to call map
and then flatten it's called flat map
flatmap
is magic this is true and I will show
you so flat map basically is a map and
then a flat so it takes a map and
creates a list of lists and then it
flattens it into one big list this is
pretty cool so
I want to make this bigger what do you
guys think this code does just guessing
from reading it anybody want to get gas
takes pies and ice creams and then it it
creates a serving right this actually as
it turns out is equivalent its syntactic
sugar for doing this which i think is
actually really cool basically the way
that for yield works is it flat maps
until the last one and then it Maps
because this is so common nested loops
something you do all the time so Scala
has this syntactic sugar to make that
easier it calls flat map it calls flat
map it calls map and then it yields the
results in a list which is what you
wanted from the beginning this is
beautiful man all my fonts got out I'm
gonna put these up on the internet you
can see how how lovely all of this was
supposed to be so for yield is pretty
cool because you can do all that school
stuff with it right so you can also do
assignments in there and you can do
filters so in this first one we got we
get all of our pairings right but we
only return the ones that taste good or
in this one we get all of our pairings
and we only return the ones that taste
good and then we give us serving to each
one in the audience and I get all these
thank yous back it's a good it's a good
thing it's pretty cool and this is
pretty powerful you can with building on
these do a lot of stuff okay so oh i'm
blown up too big sorry powerful there
she is this is cool right so these are
some ways we can put functions together
so I have one more way and then we'll be
done but we're going to take a quick
detour it's not a detour but it's going
to seem like a detour know what is know
talk to me what's know not a trick
question
nothing it's nothing what can be null in
Java
anything almost anything you're right
there are some distinctions but almost
anything any reference can be null in
Java what happens if you reference an
OLE object NP everything explodes I also
known as a no pointer exception what
kind of code does this lead to
Oh yuck so Big Ups to my coworker Doug I
kind of cribbed some of his code here
his examples here but this is an example
of how you might have to write you what
you want you want to write some code
that lets say we mapped all those
pairings and we not the best one and we
want to write some code that looks up
given a given PI looks up the best
pairing and serves it okay so in in Java
we can't assume that map isn't null we
don't know where it came from we don't
know who touched that we also here's
another thing when we get that we can't
assume the PI we're passing has of an
entry in there what if you passed cowpie
the answer would probably be null unless
we tasted that which it grows and so you
have to be able to return null as well
because it could be that there wasn't a
stir there wasn't a best pairing to
serve
okay so Scala programming doesn't use
null a reference types can't be Nolan's
call you can't make them no cool let's
stop using no let's rewrite this okay so
the first we don't have to check and the
second one wait a second
so null sucks but sometimes things are
null and so an example a really good and
example that's used all the time is when
you get something you call get on a map
or a you know associative whatever and
there's no there's no corresponding
value so what should you return in that
case it's kind of to say it might depend
on the type right so maybe we do need a
concept of nothing Scala has one it's
called an option an option is like a
parent type and it has two child types
it's either a sum that has a value of
any kind inside and we've specified that
when we called it or it's undone so I
have this example of a string we've got
an option of a string so it's like a
container does that make sense like
list is a list of a string it's an
option of a string and it's either some
string or it's none so if we do get on a
sum we get the value back if we call is
defined on a sum it's true so we have
these two functions we do get on a none
it returns a no such element and if we
do is defined it's false
okay so let's rewrite that you know so
this is what it was oh so here we go I'm
sorry
so we've rewritten this we have an
option now that we do when we got when
we call the get on the map we get an
option back and then if it's defined we
return a serving and we have to wrap it
in a sum because it could be none and if
it's not defined we return to none again
this isn't really any better looks a lot
like that right so that option by
ourselves doesn't get us much oh and by
the way what does that do with
functional programming right why am I
telling you this
haha option is kind of like a collection
collections have map filter flat map
reduced if all defined on them turns out
sodas option so when you map over an
option you get back an option you call
map and you pass a function that does
something to the value but it only does
something to the value if the value
exists if it's a sum so that makes sense
to folks you want to you want to do
something to the value if it's in there
and if not you want it to be safe you
don't want it to explode in your face
we've also got flat map so the reason
why you might need flat map right so my
favorite pie is rhubarb right and I want
to get the pairing for rhubarb because
I'm stoked about it right I can't call
it directly because it's an option
because not everyone has a favorite pie
crazy as it may sound some people like
all of them so what I'm doing is I'm
mapping like in my try mapping right I
try mapping and calling get on that
pairings map and getting the pairing bad
here's the problem looks a little like
our last problem we get a sum of a sum
of butter pecan pecan which is the best
ice cream to have with rhubarb pie so we
can't really use a sum of a some things
get complicated so we need a flat map
again to do that kind of operation you
also can do filter
um I don't I don't oh I put butter pecan
I don't like pecan pie I think it's way
too sweet
so if I'm at a restaurant and this I
want to know what the pie is I'm going
to order it unless it's pecan pie right
so my order is going to be some it's
going to be the same thing as today's
special unless it's pecan pie and then
it's going to be none so here's where it
gets cool because we have flatmap
defined because we have map you can do a
four yield over option so check out this
code it says today's special pie
pairings get best ice cream get that one
and yield my dessert if any of those are
none the computation stops and we get
back on nun which is really powerful and
so I want I want to explain again that
on the left is the inner value it's like
when you have a list enough for you you
get the value that's in that list we're
getting the value that's in that sum if
any of those are none the result is none
and so this is a dumb example admittedly
but this is a really common pattern
where you have a bunch of values and
need to validate all of them before
performing a final computation or you
need to do a step a series of steps of
computations but if any of them don't
pass a validation you have to stop or if
any of them do do something wrong you
have to stop this is pretty cool we know
for yield is beautiful and powerful
right we saw a ungry already but this is
like especially tough to mess with it's
really readable for one thing I mean
this almost tells you in English what's
going on which is basically that I'm
picky it also it eliminates a huge
source of bugs that are directly read to
programmer error where you just forgot
to check I think that's really cool so
for yield took care of nested for-loops
and it also took care of nested if
statements cuz I suppose what this is
right like if the today's special is
good and then if I have a pairing for it
and if they have that ice cream gave me
the dessert so we took care of these two
nested layers of boilerplate okay why
could we do that we could do that
because option
is a monad everyone should go because
monads are famously scary this is like
the part of functional programming
they're like the average programmer will
never be able to understand this I don't
think this is true let's talk about what
is a monad those go into it really
briefly admittedly this is a complicated
concept there are approximately 40
million tutorials on the web about what
is a monad they all have like crazy
metaphors like it's an assembly line
spaceship burrito man but I'm going to
give it to you straight this is what it
is I'm not um Daniels Buick Spivak I
think is in a really awesome writer on
Scala by the way highly recommend his
blog this is a quote from a log post of
his and I've linked this off but the
slides up and you guys can read the
whole thing what is it that makes thing
a monad option or list or another monad
okay so there's there's two things going
on one is that you can wrap up a value
inside of it you know how to do this
with a list you do it with a list all
the time we just started it with an
option it's pretty easy you just say
option contains this value the other one
is that you have this function that digs
in there it's going to dig inside the
thing and it's going to take it's going
to take a function that we supply and
use it to take that value and make a new
thing so there's a lot of words but
that's the flat map process we just saw
you have a function and you have a
process that's been abstracted away that
lets you get in there and apply that
function to the value and it returns the
same type Scala calls that flat map
again I explain why it's called flat map
until I read this I didn't understand
what was so special about flat map this
is what's so special about flat map it
lets you make new things it lets you
take a thing and use its value to
compute a new thing which is a really
powerful concept it's magic it hides our
boilerplate and we saw two ways already
how it does that we saw how it hides our
boilerplate for lists right it hides
that for loop and then we saw how it
hides a nested if statement boilerplate
that's tough to mess with that's really
cool
anytime we can eliminate boilerplate
we're doing good for ourselves as
programmers because we're limiting the
points of failure and that's I mean I
think really I think I think one of the
things that drives me to be a good
programmer is that I'm very lazy and I'm
very sloppy and I want a machine to keep
me from being those things and once I
get my Roomba to do all of the household
chores I'll be really happy but until
then I'm satisfied with flat nuts so
these aren't the only monads um you can
have known as that do a lot of things
you can accumulate errors so what we saw
as we stopped when we got an error and
the definition of flat map meant that
you couldn't keep going with
computations in your for yield but you
could accumulate them one example of
where you'd want to do that is if you
were validating a webform and you'd want
to see all the errors that someone made
and so you would still have an error
results at the end but you would have
all their errors listed that's one one
kind of mode add another one might be a
cursor position in a database or file to
let you know how you can move forward
States the state machine and then this
one's pretty powerful and this one's
hard to wrap your head around so I won't
expect you to an environment that
changes can be a monad where you've got
a function that lets you go into this
environment change it and pass it on to
the next function and this is mainly how
we handle side-effects and functional
programming because you have to be able
to handle side-effects and that's one of
the things that turns people off from
side effects for I mean from functional
programming because all code has side
effects I mean I write for the web so
I'm dealing with nothing but side
effects but monads are the way we handle
those so this is so powerful this is
like the thing about functional
programming that freakin rules this is
the thing getting rid of that
boilerplate and and having the computer
do it for you is the reason why people
like functional programming so much and
it's the reason why people fall in love
and become very fanatic about it so
here's just this brief extra credit whoa
semicolon is a monad that's right just
don't they right now just think about me
you're going to bed tonight
that's right okay so we're pretty much
done I want to go over the ways that we
talked about to sort of state to click
our blocks together and build something
cool partial application also known as
currying that was really useful lets us
create a bunch of functions from one
master function and it lets us let other
people create other functions from that
master function higher-order functions
that's awesome that lets us
abstract away iteration and operations
over containers functional composition
lets us use our building blocks very
directly composing them that one's maybe
the best Lego metaphor for yield which
is syntactic sugar but it's pretty cool
syntactic sugar and then monads which is
the big scary one so yeah that's it I
just have three more slides about the
psychology of functional programming so
I titled this without learning in Dec
learning functional programming without
growing a neckbeard because I think a
lot of people are intimidated by
functional programming I know I was
certainly when I started working here
and started using Scala big complaint as
people say it's not readable I'm sure
having seen my tiny little punctuation
force worse like roll across the screen
you might agree I think this code is
amazing I came across in a closure
tutorial and basically it says is closed
your code which is closures also
function programming it's a lisp so talk
about punctuation imagine if every time
you read Java source code and you saw an
if statement or a for loop or an
anonymous class you had to stop and
figure out what it meant now some of you
who are newer to programming may
remember that I know I do that's a real
thing people don't come out of the womb
knowing how to read Java code or
imperative code in general so there are
things except for Jordan back there he
did um so he was Ruby Ruby from the age
of two um so you had to learn how to
read that and the same thing really does
happen to you with map and flatmap and
for yield at this point um you look at
code and and you can read it you really
do learn to read it and those functions
become less of a translation in your
head Oh Matt means this and oh you're
mapping over a list and that's learning
any language any including programming
languages so I really think that's a
really good point and one that you don't
hear a lot about functional programming
I think that function programming is
really good at dsls Scala specifically I
want to throw that out there which goes
totally contrary to the to the
reputation that it's not readable this
is an example of library specs too for
writing unit tests but I like a lot tell
me that's not readable
that's literally plain English and one
of things that's cool is not only as
that plain English
this is completely configurable by the
user you can write your own matcher
functions so you can say such as such
input must redirect to a certain path
must have a certain state must look like
a certain thing and those are a little
more tricky to write but once you write
him you can use them over over going to
anyone can look at your test code and
see what it's supposed to be doing I
think that's really cool finally I told
you about pure functions I think it's
really kind of unfortunate that there's
a concept of a pure function it's not I
get it pure has a real meaning but pure
also has you know like any word in any
language it has other associated
meetings and I think there's a lot of
this is a neck beard and he's holier
than thou there's a fair amount of
discourse out there about functional
programming that's dismissive or snobby
about if it's not pure if it's not
completely purely functional it's not
good it's not useful I mean these are
things we aspire to that's kind of what
I said about functions like that rule
about function is something we aspire to
maybe you don't hit it all the time that
doesn't mean that functional programming
concepts can't improve your code and as
you pointed out people have been using
these things in Java which is suppose
you know a language designed for object
orientation for quite a while these are
these are useful concepts and the goals
they're trying to achieve are useful
concepts whether you're writing pure
Haskell or not I think it's good to
remember so finally I'd like to say
thank you and I would like to wind up
with a picture I hope that you learn to
write your code more badass and I hope
that you learned how much that I like
pie and so I'd like to close it out by
showing a picture of Pam Grier eating
pie and giving Julia Roberts a dirty
look thank you so much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>