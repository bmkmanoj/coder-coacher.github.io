<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional All the Things: A Functional Panel - Forward 4 Web Summit | Coder Coacher - Coaching Coders</title><meta content="Functional All the Things: A Functional Panel - Forward 4 Web Summit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional All the Things: A Functional Panel - Forward 4 Web Summit</b></h2><h5 class="post__date">2016-04-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/re4oOOkqs3E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so welcome to the JavaScript
functional panel I had to look up there
just to make sure that I remember the
name of the panel
I'm brian lonsdorf I guess we're just
gonna go down and introduce ourselves
really quick so chef I'm Phil Freeman I
work on the PR script compiler in its
libraries I'm Evan jerky
I designed own programming language and
work on that make a nice function
language for browsers that no red ink
yeah good point
hi my name is Lee Byron I work at
Facebook on react meetable Jas and graph
QL hello my name is Hardy Jones I'm not
as cool as these guys but I'm a big
language nerd so I like all languages
your script Haskell JavaScript web yes
so we've got we have a good mixed crew
of people here we're gonna talk about
functional JavaScript and functional
programming and just kind of in general
we don't have any closure scripters so
if anybody has any questions that they
want to ask later in that regard let me
know or something okay so I'm gonna
start this off by saying so functional
programming used to be like the cell was
a few years ago they were like the
future is parallel and you have to be
functional if you're gonna be parallel I
don't know if I like by that so much
anymore maybe I do but I feel like
there's a lot better cells what is
what's everybody's take on that do want
to start fill like what's the cell of
functional programming if not
parallelism sure so I think for me the
strength I mean I think parallelism is a
there's a great cell still although I
think you know it it takes a little bit
of effort to sort of see it's not
immediately obvious why that's why
that's the case it's all more obvious to
me something like building
domain-specific languages let's say I
have a complex problem domain and I want
to you know express ideas to singly and
some you know reduce the set of ideas
and express build build things up build
ideas up succinctly in this
domain-specific language that's always
been like the way I've sold pizza people
so I saw the story was like our
concurrency parallelism a couple years
ago
and I think that makes sense if you look
at the sort of historical trend right so
a place where sort of functional
functional concepts become nice when
your application starts like crumble
beneath you and you're like oh is there
a better way to do this and so when you
see people who have these massive
distributed systems and they're like
this is not working out for me
it makes sense to me that that happened
a bit earlier and I think we're starting
to see that more in front end where
people are saying oh we can bring in
these concepts to solve these problems
we know we have where as on survey was
just like everything's broken like what
if it wasn't right and it hadn't gotten
to a point where JavaScript was like huh
but for me a lot of the important piece
is just how can we simplify the process
of getting to a good product so it's not
really about functional programming or
particular sort of pieces of it but just
like we have this paradigm that's a
simple fly simplifies your process to
get to a good product that's I totally
buy that most people are starting to see
like mutability is the way they're like
writing object-oriented code all
immutable and stuff and mutable J's it's
getting really popular and you know I
think every work like every Enterprise
job I'm seeing now is starting to adopt
that so that's really cool that n-type
safety so it's hard to separate
functional programming from types unless
you're doing closure and even then
they're starting to add types so I
wondered for JavaScript errs what would
you know what the can they do right now
with the type tools they have and how
does that compare to what you can do I
can toss in some because I spent some
time working on flow which is the type
checker that we're working on at
Facebook and to go back to your original
question like what is it about
functional programming that seems so
enticing I think that parallelism was
like a nice early cell but parallelism
is an outcome of the true values that
you get and the value is simplicity and
composability
and when you have those two features
kind of regardless of how you implement
that or how you achieve those two
things all kinds of other things come
about as well yeah and it just so
happens that distributed systems are
really hard it just so happens that like
when you have really hard problems
having very simple composable pieces to
assemble to solve hard problems turns
out to be a much better way to solve
them than like throwing the complexity
wall at the problem and seeing what
shakes out and type systems like I think
this is another example and it's like
it's also an outcome similar to you know
how do you make distributed systems
better we've been trying to apply type
systems to programming languages for
decades in both functional environments
and non-functional environments but I
think what we've proven to ourselves is
it if you like look at any Java program
that has a type system it just it sucks
like there's all these places you're
like a cast two objects and like carry
on you're like what is it doing for me
really and the nice thing about a
functional environment is because you
have things that are composable types
want a composable environment in the
first place so typing ends up being just
a much easier thing to solve when you
have like very simple very composable
pieces and you can do that in JavaScript
today like if you write simple immutable
of functional kind of components that
are designed to compose together then
the type checking tools that we have for
JavaScript end up being way more
powerful than if you don't use that kind
of programming technique and this is I
think been a big factor in sort of the
uptake of type stuff is that when people
a lot of people think types they think
types in Java and they just forget to
say in Java and so like the fact that
they have emotions about that it is now
like my problem you know and so like I
can say hey you know it's different this
time but like you there is this sort of
built-in distrust that sort of this
historical relic so and I think that's
starting to change just because people
are eating JavaScript applications that
are big enough or they're just like this
is collapsing in on itself how do i and
type systems have kind of been on the
fringe for a while right like you kind
of foray in and you hear things you're
like oh my my software is gonna be
provably correct it's like no it's not
like unless you're using some very
specific programming techniques and
environments like and you won't have
provably correct program
they survive in those environments their
jokes like you know I proved it's
correct but I don't know if it's it so
may be correct but it doesn't run yeah
like like you have to be careful like
did you actually prove did you put the
right thing yeah exactly
I don't I don't tend to like that
framing like for me what it's like when
I
I made a like type inferred functional
language but the point isn't I like
types the point is I really like to be
able to refactor in the certain way so
when I remove a function it's nice to me
that I can just say here are the four
places that are affected or when I add
something to an API I know that it has
to be handled in all these other places
and so it's that sort of static
automated help that I find really
valuable and a lot of times I feel like
we get stuck talking about types but it
that's kind of the way to getting this
nice outcome in practice I mean a type
system can be a good a good type system
should be a tool for sort of managing
complexity right I think it's important
to remember that and this goes with like
you know you say like managing modules
and other kinds of problems that like
simple types can actually be incredibly
valuable as well even if it's something
as simple as can i distinguish an email
address from a phone number as two
strings right yeah and I think part of
what sort of held up functional stuff
like this taking off is both you have
the Java side of things where people
don't trust it and then you have the
people who are really into sort of the
mechanism that makes it all work and you
get this this like avenue of
communication that doesn't make any
sense for some people are saying like I
don't trust this and other people saying
if you just get extremely obsessed about
the details like it'll make sense but
like the real story is like we want your
application to work better Hardy if
you've done stuff in like crazy hardcore
type stuff like pure scripts and then
also like JavaScript and like how do you
feel like your programing differs and
the safety fields and stuff I think when
you're using javascript you have to pay
a lot more attention to everything
that's going on whereas if you have a
compiler like pure script you can dish
off a lot of the cognitive load to that
and encode different things in the types
of some like phil is saying you can
differentiate between like an email and
some other type of string so you don't
really have to like have all these
checks inside your code it just kind of
fits together one way you know and one
thing I've noticed along these lines is
as I've sort of gotten into functional
stuff it very much changed how I write
JavaScript or Java or C or whatever it
happens to be but the thing is is that
even knowing how I ideally would write
it I still can't seem to achieve that
often so like there's a part of LM stuff
that's got a big javascript piece and
I'm like I have these architecture
principles and I'm not gonna stray from
them and then I get to the end and I'm
like what did I do
how did this happen to me you know what
I mean so I don't know I'm still quite
perplexed by that like I don't know how
to how to get around that yet so I don't
know the follow-up question here about
kind of mixed paradigm you know we're in
in JavaScript in particular or Scala
Swift there's a lot of mixed paradigm
languages even F sharp came out as a
revolution when they first announced
that but I was curious how all your
thoughts were I kind of felt like I feel
it's a little awkward to mix
object-oriented stuff and functional
stuff you know in general but maybe
there's a way we just haven't found yet
so we have thoughts well so I have
talked with some Scala people about this
kind of stuff and my feeling is in some
ways it's like the ultimate learning
curve but it has issues right so you can
be three years into writing a scholar
code and really just be writing Java
code with some local type inference like
that's a Avenue that's open to you and
so in some sense Scala isn't really
giving you the whole promise of these
nice things but on the other hand the
learning curve was I just have to write
less code and I get what I was doing
before so you have this extraordinarily
gradual easy to manage learning curve
that I think is really powerful so I
don't it yeah so so you have this this
flipside of like we can get people to
come but we can't convince them to like
it's hard to know if you don't know
if you're using it correctly yeah yeah I
remember when I first started doing
functional programming I was like I
think I'm doing it right and then like
you know of course I'm using compose all
the time perfect but yeah it's
definitely uh you kind of get it after a
while but mixed paradigm makes that and
I don't know if other people experience
this way but like one of the things that
sort of has driven my understanding of
programming and how to put large things
together is just using languages that
are like forced me to do things that I'm
not comfortable with right so like when
I first learned scheme I was like wow
like something new and crazy is
happening here and and that sort of
comes back again and again and again so
like being in that environment we're
just like the thing you want to do just
isn't permitted has been really powerful
in terms of internalizing what things
mean without like reading a crazy paper
that maybe still wouldn't make sense you
know one thing I'll kind of add to that
is so I all of my side projects I use
either closure or enclosure script or
Haskell and pure scripts and some
language that gets me all these benefits
right the language forces me to do
things the right way despite sometimes
when I feel weak and I want to kind of
fall out the wrong way but when I'm
building stuff at work it can be a much
harder sell to say like hey we've been
like building this product for a while
we should convert everything to pure
script I might feel like that would be
really great if we had done that but
like that that can be really really hard
so one of the benefits of the next model
is not just incremental and like what
you said before I super resonate with
the ability to learn things
incrementally is extremely important
when you're like you can just do
everything the way you were doing but
check it out like did you know that
JavaScript arrays has have this function
called map and reduce like learn those
first and then you're like wow this is
an interesting interesting way of
thinking and you can kind of seed the
bits one one piece at a time rather than
like I don't know the first time I
learned Haskell I was like and like an
on CS person like JavaScript programmer
and sounds like you should really learn
Haskell and I took a class and like I
was I was lost at minute four I was like
like everything whatever my head
like what's a monad and like you know
four or five hours later over beers I'd
finally dropped the idea of a monad and
like my brain shifted and then like the
entire world was upside down and like it
turned out that you know it was upside
down all along and that was right-side
up so I I was maybe like a year in when
I was like I think because of years of
like one step at a time
oh that's why map is cool oh that's why
reduce is cool and like one little thing
oh that's why nullable types are
interesting you know it's like oh those
are all monad monadic operation okay
cool it all clicked for me after a while
I think beer helps but in in tandem with
incremental learning I think is also the
ability to incrementally add these ideas
to the environment that you're already
using so if you're already if built like
a big thing and your team has dozens of
engineers working on this thing and like
you're now enlightened and you want to
use functional techniques at the very
least is hard to convince your team and
even if you convinced your team like hey
are you gonna like drop the thing on the
floor and start over in a new language
that can't be done and I I want to like
push back a little bit on the idea that
you can be enlightened in this way like
really really these are like tools right
and they either help you make a good
thing or like they don't help you enough
to be worth it yeah and so one thing
that I've noticed in companies that are
sort of starting out using Elm is a lot
of them do a process where they're doing
something I find out about react and
they're like this is amazing and then
there's then there's like oh well what's
the next piece here and so I've yet to
see a company that didn't go through
react and sort of as projects like redux
and flow become more popular we see
direct impact on how many people are on
the mailing list to the website and this
kind of thing so you I think it's it's
important to have sort of both halves of
this because like this gradual learning
curve is really good and so when people
come to alum and say what's this map
thing they're like well it's like in
JavaScript I think that's been really
really a huge part of why we're seeing
this uptick in functional stuff not like
it's sort of independent of people who
make languages along these lines
yeah I totally agree with you and white
says maybe the wrong and another piece
of this though is I've never observed a
company that said this is I don't like
how this is so let's do a full rewrite
like and I was always a terrible I would
never recommend that right so what
people end up doing is choosing a little
piece and saying let's try that in Elm
or closure or a pure script or whatever
it is and that's how you sort of have a
low-risk way of trying it out if it
doesn't work you throw it away like and
I think if you're trying to do something
more intense than that you're not doing
service to like yes I think we're saying
the same thing because I 100% agree with
that like you have to have an
incremental way of introducing these
things and whether that's like you're
happy with JavaScript you and keep
JavaScript and you just want to
introduce the ideas and kind of
libraries that help use your JavaScript
you can keep your keep your JavaScript
or I mean that's why I like all the
people who are up here talking about
like new languages except our empty seat
which is our shadow closure scripts but
all of these compile to JavaScript and
that's important because they have the
facility to speak with JavaScript
enabling exactly the kind of thing
you're talking about and that's like a
very important and critical and
intentional detail yeah another thing
I'm sorry along these lines is that the
sort of JVM functional languages sort of
are a couple years ahead of JavaScript
one so maybe four or five years older
than the ones in JavaScript and I think
the main thing there there's like the VM
was ready for that kind of pressure
earlier in Java Java world and so we're
just starting to see our like crop of
this is actually the thing I'm most
excited about is that as a functional
languages push on the JavaScript VMs the
JavaScript VMs kind of reflect that by
saying I go people are trying to do it
this way we'll make that path faster and
I just like positively on all the stuff
that we're doing proposal hey is
probably wait the closure scripts
private Nam anybody anyway I was I was
hoping that someone was here for closure
script that could just come up for a
second because I feel so sad there's an
extra C
but I think probably tom was not here so
anyway so Phil how would you sell pure
script to your boss so I think you know
the most important thing is what we were
just saying right that you can drop an
arbitrarily small piece of pure scripts
or any other language alongside you know
into into a JavaScript application
that's like the beauty of you know
objects and sharing this common you know
there's common runtime right is that I
can I can pick something that is more
suitable for peer scripts and you know
and target that and fix that and and
deploy it you know compile it to
JavaScript and deploy it and there's no
reason that I can have you know pick the
piglets all that stuff right and also
right for the for each individual job
right but yeah as far as like the
incremental like learning and stuff I
I'd be curious if you could get in there
teach some of the JavaScript or some
functional stuff and then take the next
step until like a more pure script or
something that's a little bit heavier
the GHC J is crazy but yeah it seems to
be a common issues that how are people
going to sell this to a boss who you
know you have a team who doesn't really
necessarily know or I mean the question
so it becomes like you know if it's so
easy to just drop this other language in
them what is the part that should
replace right and I think there's plenty
of examples you know where Haskell for
example has demonstrated that these
ideas make you know particular types of
jobs much easier so what is a passing
right maybe have a passing job that I
want to do and I can just isolate that
and solve that in peer scripts or Elmo
or what have you and and a piece to
consider as well as like so I've been
writing Haskell code maybe like 6 years
7 years now it's like a long time and it
took me I'm gonna say like three years
before I was like I know what's going on
here and like once I passed that like
it's an extraordinary powerful tool but
like part of it is this sort of how can
you do the gradual pieces and so I'd
also sort of the question like how would
you sell it to a boss is interesting in
that I'm not sure if you're selling it
like maybe a mistake has been made
already right like if you
on a team we're sort of the direction is
towards react stuff people are
interested in immutable stuff like it's
not a matter of like selling the idea
it's just like we have these concepts
that we like let's take the next step
which i think is a different thing than
how do we just insert a new paradigm how
do you gradually morph your team and to
this you implement the Elm architecture
in every language and every system well
and one one thing that I've noticed
looking at teams that are using Elm
these days is that this gradual approach
is a hundred percent how it happens and
it's usually on the companies I've seen
it at least these days are smaller teams
so it'll be between two and six people
who are on the front end team and some
of them or like one person is sort of
really into Elmen like gets it and sees
how to make that transition and that's
the process that happens and I think in
in the cases that I'm aware of it's not
a matter of like how do we sell it it's
just like the structure of the team
permits that pathway and I'll be curious
to see as things progress if we do start
seeing teams of like 20 move over and
what that looks like I don't know what
that process will look like honestly so
that kind of leads in the next question
we're seeing like everybody implementing
the Elm architecture and everybody
getting interested in these ideas and
then like we're getting immutable stuff
even redux kind of looks like a free
monad if you squint what we seem to be
going to the functional land and
stealing ideas and implementing them in
JavaScript ourselves what do you think
is next up anybody have the next big
functional language feature that it's
going to be in JavaScript so so my guess
would I think the core pieces that make
functional stuff appealing aren't like
new necessarily right like it's like
what if we just had variables and we
didn't then change them later so like we
removed a thing but what if we had
functions and they like didn't have this
feature so to me like the essence is all
in those P
and that's I think the part that's most
attractive so I'd be somewhat surprised
if like the fancy stuff was really what
people got excited about in that like in
my personal like writing a compiler in
high school like though as I would try
out a fancy thing I would find myself
months later rolling it back and being
like actually I sort of over committed
to an idea that didn't exactly match my
FRP I think this is an idea along these
lines where like I'm not as bullish on
that idea as I once was and I think of
it as like what I thought the idea was
wasn't what it turned out to be but but
there there is this sort of siren call
of like look at this crazy thing that's
like sort of mathematically beautiful in
a certain way but I have a hard time
sort of weighing that against you know
the core idea of like functions are
really powerful abstraction and to think
that we're gonna invent something that's
sort of better sort of feels weird to me
there's kind of a few aspects of that
question that I think is interesting so
I actually think most of the ideas that
are coming out of the functional
programming world like we've we've
successfully built that bridge between
the JavaScript D front Enders world and
like the functional programming world
and react has come out of that and in
immutable data structures have come out
of that and FRPs
is coming out of that and so we're
getting some tools to play with but
that's not the whole picture you also
need the language to kind of help you
through that and JavaScript really is
not very good at that and you need the
runtime underneath the language to make
that kind of thing efficient so I think
like we've successfully built the bridge
between humans so that like ideas are
starting to flow and so that part feels
good and we are starting to see the
language in the VM start to react
we have arrow functions so you know it
used to be really annoying to write
lambdas in JavaScript now it's not
annoying
and so that's like a language level
improvement JavaScript VMs are seeing
these kinds of pattern
and they're starting to optimize them
that will have to continue quite a lot
what other language features can we add
like should we have value types and
JavaScript you know should we have
immutable data types that are kind of
baked into the language right now we
only have scalars would be really nice
if we had immutable by default value
types that we could we could start to do
really interesting things we could move
things between web workers and kind of
treat them as like really fat threads we
could do all kinds of really interesting
stuff even as a compiler target like you
put element you put pure script you put
closure script on top of this stuff you
still end up compiling down to
JavaScript and you're limited by what
that platform can do so this is
something that has been like from the
very earliest days of elm like house
like oh we can have different threads
and it'll just communicate really well
and just like JavaScript like we you
can't do that I think it's lady but I
can do this is the biggest existential
threat to JavaScript and like like our
ability to survive doing what we're
doing is like javascript is a single
thread and environment and any kind of a
synchronicity is really really hard we
don't have anything that are like
threads web workers kind of like threads
they're like some of the good parts but
most of the bad parts and and it's
actually like the worst possible
scenario right like CPUs are not getting
faster they're just getting more coarse
we have no way to take advantage of that
people are like abandoning desktop
computers in favor of mobile devices
actually the most commonly used mobile
device around the world is four years
old so it's not even that like as new
devices come out people are getting the
new device they're getting older devices
because the older ones are getting
cheaper so like if JavaScript is gonna
be the platform that propels us for the
next 30 years as Alan mentioned in the
previous panel in this room then we have
to come up with some primitives to take
advantage of the cores on the processors
that we're actually operating on and my
personal theory is that the sort of web
assembly stuff that's happening is
directly sort of influenced by the most
it's like looking looking at like death
in the eyes where it's like like this is
gonna take over the world and like are
we gonna be there or not so like if you
want to be competing with native iOS
stuff you can't just be we're just
slower so you're saying parallelism is
still the sell it so I mean why doesn't
so
to reverse a little bit why doesn't
JavaScript have primitives for
parallelism the answer is because
parallelism is like the biggest foot gun
in programming right it's like there are
lakhs of mutexes and there's mutation
and shared mutable straight across
threads and there's race conditions and
like ask your like local friendly C
programmer like how many times I've had
a parallelism bug and you're like oh
that's why we don't do that because like
we want JavaScript to be the language
for the masses and so we make that piece
remove we don't want browsers to crash
like there's lots of reasons why you
would make the trade-off to say actually
like a single thread is totally fine I
have a sort of jokey idea along these
lines so like if you if you talk with
someone who does Java stuff like they
have all the abilities to do these kinds
of crazy things and in generally don't
write like if you in like maybe 80% of
cases people are maybe maybe it's higher
I don't know but I had this idea where
like to make so I could write a
scheduler myself that did this kind of
concurrency it'd be really nice if I had
go-to so I was like what if we added it
to JavaScript and yeah that would make
JavaScript worse but that's also good
for me so no but yeah I think it comes
back to this idea of like why is
functional good it's good because it's
simple and like the parallelism comes
out of that parallelism is possible when
things are simple you can control a lot
more so like and you add a type system
so it's like hey you're mutating that
thing here and then you're using it
another thread don't do that
rust is full of really really cool ideas
on this line and this is another piece
that I've observed that if you say to
JavaScript folks like hey this is faster
forget any other detail like they're
gonna be into that thing and so I think
one of the things that it's a shame we
haven't been able to sort of take
advantage of as much as we could is that
when you have a sort of fully type
correct programming language where you
know this program will work you'd never
have to check all right I'd like to add
X and Y is X and int is X afloat is X
string is X an object is X inner okay is
this is Y and go through that on every
single one and like the amount of
acrobatics that people go through to
like get that
- like let's just add the two numbers is
crazy and I wonder what kind of speed
we'll be seeing when those checks start
to sort of be the to go I mean and I
wonder if if like JavaScript VMs can
sort of evolve to a place where that we
can't get rid of that guy me too so Evan
you mentioned it'd be really nice if you
had go-to in JavaScript but isn't there
something similar to that that if it's
not go through there's something like
that
so I've done tricks along these lines
where you have yeah exactly exactly
so so the thing is that it doesn't give
you the full the full power in that if
you want to jump ahead you can do it
with a certain trick but if you want to
jump around it's not okay but so the
thing is like if you're if you write
compilers you're like the the like ten
people who are like go-to is pretty
useful I mean this is so JavaScript like
it serves two purposes at the same time
it's both a language that we need to use
to make real things and is used by tons
of people like computer science PhDs and
all the way down to like a high school
or who's learning how to program and you
definitely want that to be a nice safe
environment yeah of course but at the
same time it serves this purpose as a
compiler target and it's definitely not
assembly even though we might want it to
be so this I'm actually super excited
about web assembly it is like a really
encouraging kind of Avenue for these
things to go and something else you guys
have been mentioning back and forth is
having like concurrency primitives or
parallels and primitives but isn't there
like a pure script library for EM bars
or something that's something similar
not quite involved but there are sort of
like user space well there's there's
libraries that you know build things
that look a lot like empires and these
kinds of things right so yeah I'd like
to see I'd like to see JavaScript of you
know in terms of like what what things
would be best brought over what features
brought over from functional languages
to JavaScript and so instead of adding
features I quite like the idea that you
know JavaScript could sort of stop
adding features and constants
moron you know being able to implement
you know things like pure functions and
user space abstractions more efficiently
I don't know how realistic that is yeah
the committee response would be like why
not do both Joe we've got ten giant
companies pouring hundreds of thousands
or billions of dollars and we'll just
head we'll just do it all so we've got a
few like 10 minutes 9 minutes I think
it'd be good to just talk about for I am
a JavaScript programmer and I'm
interested in functional programming I
see this every single day not just
because I always talk about functional
programming like most people are really
interested in this right now what do
they do do they jump headfirst into you
know Haskell or a different language and
come back or do they you talked about
the gradual learning for me just to
throw this out there I found Scala to be
quite enlightening as a stepping stone
into a more hardcore language but is
there any thoughts on the JavaScript
programmer who wants to learn how to be
a functional programmer I think there's
quite a few nice libraries out there
that can help and you don't have to
leave JavaScript completely so Ram does
a really good library that I'm sure most
people are familiar with but it doesn't
force you to go so far out of your
comfort zone there's still a lot of like
you still have to like you can still
deal with nulls and undefined stuff like
that there's other libraries that are a
little bit stronger like sanctuary it's
it's kind of like random but it has like
your maybes and your I there's and stuff
like that so there's a bunch of
libraries out there that can kind of
guide you along the path you know and
you can use however much or however
little you you feel comfortable with so
my suggestion is to kind of hit it from
both ends like take small things and do
them one step at a time so here's a
challenge for the next month never write
a for loop and just like you know it's
you're gonna give up sometimes but like
every time you encounter foil up you're
like what am I really trying to do and
that's actually a really good thought
exercise for thinking of how you might
do something in a different
but at the same time you should tried
new languages like take a class on
Haskell take a class on ML or scholar
scheme and see what it feels like to
play with those languages I think pretty
fast as soon as you make like one thing
like man how did that work and the first
time you encounter something you're like
oh I have a list of things
now what and you can't you like there is
no for loop for you to fall back on what
does it look like you're gonna get all
these different views from that
different way of thinking but it's gonna
be a slower process but having the other
side where you can kind of take these
ideas and like put them into practice
immediately in like the code that you're
writing today that that's how you'll
actually feel them out in the context of
like real software so and the way we
think about this in in elm like my
personal view is I learn by seeing the
code and playing with it and like
changing it so for me a lot of it is I
want to show you the simplest example
and be like look it's not it's not so
weird okay we're cool right and like
let's add a little thing here and add a
little thing so really think about
what's the simplest possible version of
it and sort of gradually introduce more
concepts and I think one thing that
looking back was important for me and
learning was there were certain concepts
that I found scary such that I was sort
of afraid to engage with them in a like
let's use this to do something kind of
way and only when I finally used it was
I was I was like oh it's not crazy
everyone just said it was crazy for no
real useful reason so so there's this
element of I think overconfidence is
like quite an important way to go into
this kind of thing just be like this is
I'm gonna be able to do this and once
you get your hands on on something often
that's the case and if you find yourself
in a case where it doesn't make any
sense maybe try something else right
like you want to have this sense of like
this is gonna work and I think this is a
nice way to sort of get yourself really
into into one of these languages maybe
another piece is implement some of these
ideas yourself so if you're ever like
hmm like reduce sounds cool like what is
it doing exactly right the reduced
function you know like pretend you're
interviewing yourself first
like go to a whiteboard and like how is
it what is this actually doing right
type it out in code and then you you'll
have a much better understanding of what
these tools are doing for you after
you've kind of like written a few of
them yourself and I remember like when I
first learned like fold like reduce in
scheme like I got it and then they were
like okay now you write it and then I
like didn't get it anymore and I just
like stared at it for like a week and
then I got it again like there was this
like cycle but but you probably know
more about FRP because you like forced
yourself to building Elm and you're like
oh like now I understand exactly why you
want these things to work the way they
do yeah that that took a couple years of
course it does don't do what he did but
seriously you know you take these pieces
you do one piece at a time so I know
when I was first playing with Elm I was
like man folding over time
mind blown and I was and it took me a
long time to understand that concept so
I like wrote Munda myself I was like
okay in JavaScript I have this like rxjs
library what does it reduce over time
mean and I just kind of wrote three
versions that didn't work and I probably
got one version that did work it was
like oh this is actually not that
complicated and then like all kinds of
ideas made sense to me after it's
interesting I feel like there's also an
element of like the culture of
JavaScript is this like take it remix it
yourself and like learn from that so I
wonder if this is a cultural thing cuz
like that wouldn't it wouldn't
necessarily be the same advice in a
different setting that's quite
interesting me like speaking to myself
in the way that I learned I learned I
write by building stuff so and if you
learned by building stuff build stuff I
think it's probably far more enjoyable
to so if you go in to experiment let's
say in a wrapper or something with folds
right it's far more enjoyable to have
you know used like a fold over time and
see an interactive thing happening right
the web the web has stuff like a really
great playground for like functional
ideas functional programming community
so I've been historically not great you
know like resource to learn these things
yeah we should probably be taking more
advantage of you know the web for these
you know as a teaching tool I think we
hit our monad quota earlier so I won't
bring that up thank you last last minute
thoughts we got two minutes
want to set any buddy have any thoughts
they wanted to shout out for the last
conversation topic
I guess maybe just closing like
hopefully this was some helpful insight
and sort of instilled in you either the
confidence or overconfidence to start
trying stuff out and like see what
happens like ultimately it's about
making your code nicer and you know if
you do some experimentation
I can't imagine you'll come out the
other side feeling bad about what you
learned yeah and I would add to try to
like understand why these features are
adding value to you because you're like
oh like all the cool kids are doing
functional or like I understand at a
high level why it's interesting but you
know I haven't bothered to learn it yet
for me at least it was much more
powerful when I saw like in my own code
building real stuff how like changing
something had some effects like months
down the line for maintainability or for
ease of use of understanding or for
performance or for some other reason
having a really clear understanding of
what I was getting out of it provided me
with them with the motivation to learn
more and and one thing I've also noticed
is part of why I have this weird love of
typed functional stuff is not because of
the ideas about it's like I wrote a
thing and then like it didn't break
later and I was like so amazed how does
this how is this happening like what's
going on here so so independent of any
like particular understanding you'll
start to notice he's like huh this
didn't break and like just unreflecting
on that you'll start to see like what is
this really giving me I think I would
say for anybody that's trying to get
into it like don't be afraid to ask for
help I mean nobody really knows this
stuff to start with and like everybody
you have your mentors and stuff that you
can talk to and get help from or just
the community itself
I mentioned Rambo before that community
is really good
you mentioned rxjs that community is
also really good cycle really great
community like there's just a bunch of
different libraries that have a good
community around them and you can ask
for help on random stuff and as a
cautionary tale that's excellent advice
so when I was learning how so
learned it on my own for like three
years and at the end I got everything
but like had I sat down with someone at
any point in those three years I could
have saved a lot of time so like just
don't be afraid to be like hey what's
going on here and by virtue of all these
communities being like small and growing
I think it's just a necessity that folks
are friendly so like no one's gonna be a
jerk about like people are excited about
these ideas and they want to share them
and like see if you like them too yeah
there's a lot of in San Francisco
there's a lot of meetups that are very
very friendly people are afraid of
functional programmers sometimes I think
cuz they're all like I am a
mathematician but it's not like that at
all so go check it out that's our panel
thank you everybody for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>