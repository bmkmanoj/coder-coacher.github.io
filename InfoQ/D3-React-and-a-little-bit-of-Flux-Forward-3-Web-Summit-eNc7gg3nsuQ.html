<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>D3, React, and a little bit of Flux - Forward 3 Web Summit | Coder Coacher - Coaching Coders</title><meta content="D3, React, and a little bit of Flux - Forward 3 Web Summit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>D3, React, and a little bit of Flux - Forward 3 Web Summit</b></h2><h5 class="post__date">2015-08-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eNc7gg3nsuQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this journey really started about a
year ago um we're at my work we started
considering whether or not we should
have moved to react and flux previously
we were using backbone with d3 um and it
was causing us some troubles so we
started thinking about other
architectures that we could use and
react and flux started to become one of
our best options so a little bit of a
bad track I work at a security company
called illumi oh um and the best analogy
of her so far of what we do is what I
like to call the hotel analogy so if you
think of a traditional data center as a
hotel and all of the servers that you
want to secure it to be the hotel rooms
then traditionally with firewalls we're
just securing only the front door so as
soon as an intruder gets into the front
door they have free access to all of the
hotel rooms what we try to do is secure
the hotel rooms themselves and with
illumination what we do is show you
visually who's going in and out of each
hotel room that you care about and how
you can visually secure those rooms and
say I only want to allow these this
traffic in and I don't want this traffic
in so
what it looks like is um these squares
represent our certain servers on what we
call workloads and they are grouped into
this contract of a construct of what
applications are running on these
workloads and which environment dev prod
testing and what locations it could be
like physical locations it could be kind
of virtual locations and so that we can
identify the rules that we want to write
by these groups so you can see I'm these
are workloads when you first pair them
when you first install our software on
your servers um and then we want to tell
each of these workloads what their role
is what their function is so for example
for this particular one I clicked on
it's a database
so I say okay database and for this one
it is oh wait no that was a load
balancer okay I'll go back so this one
is the database and I know because it
says database in there
and this is all going across the
internet I'm so depending on the
internet speed this might be lagging a
vault oh yeah
so I usually wanted to show you guys
illumination and demo some of the
functionality but unfortunately
illumination is highly dependent on
network speed I'm and as you can see
after i clicked on save it's still kind
of loading so i may or may not be able
to show you everything i wanted to UM
in that case we're going to go back to
my back-up plan of these gifs so oh oh
it went did you see so it went to right
here okay i'm going to try something
else so now that we have the roles
assigned to these work clothes what we
can do is write rules on them so we say
between this web workload and this
processing workload i want to add a rule
for this service
so I say save and depending on how nice
the network wants to be to me it will
turn green oh there we go yay and but
i'll show you these gifs and so this is
me turning the roles or turn assigning
the workloads to the roles
and it turns and then this is how we can
secure the entire group
so just assigning roles to each of these
lines that are the traffic links that
represent the traffic links so the
reason why we started thinking about a
potential alternative to backbone with
d3 is because it presented with us with
two primary challenges the first being
that if you take a look at these
elements these work clothes and these
groups um there's actually a lot of
visual complexity in them so depending
on the data state of each of these
elements and I can have borders i can
have na borders like there could be dash
borders and they all encode a certain
meaning and on top of that some things
some digital elements such as the
group's their state is actually highly
dependent on the were closed on the
state of the workloads within them so a
data change on a workload could
potentially change what the what the
group itself looks like so what that
meant for us is that the first problem
um we were we used to be solving with
e3's what we call enter update exit
pattern and we wanted to keep track of
like all of the Dom elements that was
going and going in all of the Dom
elements on that we were moving and it
became such a jumble in our head to keep
track of that we got a lot of bugs and
the second thing about all of these
views depending on other views meant
that in backbone we were listening to
mall views we're listening to models and
models were being mutated by views and
it was creating this giant spaghetti
ball of events
so I'm for this talk because I can't
show you the code of illumination I went
and created an example expense app and
that was initially supposed to be very
simple and then it got really out of
hand because I had a lot of fun with it
um and it has three primary function
first you can add an expense so let's
say this morning I wish I would have
gotten a coffee and then that adds it
right here and then I could say that I
put it on my chase credit card and
that's a category I'm and to categorize
each expense I drag it over the category
I want and in categorizes it so I'll put
this on their groceries um and I could
click on an element to inspect its
details and I can click on a category to
inspect it and I can also click on an
expense essentially edit it so these are
kind of like the simpler functionalities
it's kind of like a simpler version of a
lot of the functionalities we have in
illumination
so um when I first heard about react
about two years ago when it first came
out um I didn't pay much attention to it
because I if Court is sounded a lot like
what d3 was already doing I'm so react
is a library thy face book came out with
to help us solve the problem of a single
page app and all of the data changes
that can change different parts of that
application with d3 d3 is a library for
developing interactive data
visualization and it also I see a hand
hi oh yes do that
thank you for letting me know um and d3
is a library for making data
visualizations that actually also tries
to figure out how to intelligently
update different parts of the
visualization based on data change so
they do a lot of the same thing but with
different approaches so I have for my
example the Dom structure of one of
these expense rectangles so it has two
rectangles and one text element and the
code to actually render this in react is
I just tell it that my structure that I
want in the render function and react
will then take that and I'm their
virtual Dom will keep track of the
elements and then calculate the minimum
set of changes to the Dom to go from one
state to another so we don't actually
have to do much work to figure out how
to update between states with the 3d
approach is called enter update exit or
enter exit I'm an exposed as to us I'm a
function called enter and that tells us
of the subset of the elements we need to
insert into the Dom em because of the
data change and also the subset of
elements that we need to remove from the
Dom because of the data changes so with
d3 instead of reacting in care of it all
for us and we have the ability to
control what we do but it also means
that we have to be doing the ones doing
that like doing the thinking of the
keeping track of
so because they're so similar and they
do they try to do the same things I mean
there's this problem of who does what
who keeps control of the dom and how do
we make sure that in particular react
doesn't get angry because um when we
tell react to all of the elements we
wanted to keep track of and the virtual
Dom um if we then go and change
attributes not the react it freaks out
that we kind of like pulled the rug from
under them um and it actually gives us
really nasty bugs that like take half a
day to find because we have no idea what
this is from personal experience and so
the pattern that we came up with for
illumination was that reacts manages the
structure reacts manages what gets
entered into the Dom and what gets
exited from the DOM and d3 manages the
attributes
and the primary reason for this hunt
this thinking is um it takes advantage
of two things first of all that react
makes react is very good at making
things on component I can't ever say
this word componentized
and that's easier to reuse and it also
abstracts away the structure from us so
that we don't have to keep track of it
and with d3 it has some really amazingly
beautiful um functionality one of them
being the transitions I'm so animating
animating Dom elements
that we can take advantage of but
transitions required III to have access
to Ali's the attributes of an element so
for example this this is transitioning
in the expenses in the Spence app and at
the end of the transition this is what
the Dom structure of the expense looks
like so previously we saw um just kind
of dish soap I'm reacts takes care of
this first part saying this is the SVG
element I want and the class name and
then d three takes care of the rest over
here
and how we did that was on the left hand
side we have the d3 code and on the
right hand side we have the react code
so um we grouped the d3 code into two
parts first being the enter function and
the second being the update function and
the enter and then you can see with both
of them that they're only changing the
attributes of the Select of the
selection of Dom elements that we've
given it and in update
we call a transition on them and have d3
calculate the states between the enter
and update
and from the react side we call the
enter function from component amount so
right here so this means that while so
this means that when react has inserted
the Dom element into the Dom we set all
of the attributes the starting attribute
and when react has finished calculating
the diff and finish updating it to its
next state then we update it with the
next set of attributes with d3 and
that's also when we asked III to
calculate all of the in-between
attributes between the when i first
started and when it ended
you
so when we first read about slugs it
kind of clicked right away because we
were having so much trouble with um the
events going back and forth between the
views and models and it was hard to
debug because we didn't know where the
events were being triggered with floods
it has a unidirectional flow data flow
and so um all of the data is stored in
the store and then the store listens to
any dispatch event triggered by the
dispatcher and anytime any of the data
changes it emits a change event to the
view the view then takes what's in the
stores and renders and next rear enders
itself
whenever a user and whenever a user
interacts with the view we trigger an
action that then goes and calls the
dispatcher to let the stores know that
something has changed
so the most important part of this is
that the views can get the data from the
stores but they're not allowed to mutate
it without first having gone through the
dispatcher and the dispatchers primary
job is to make sure that we don't have
any race conditions and updating the
data
so how this translates for us in this
expense app is that these stores look
the stores I have our for the graph
itself so this right-hand side is a
graph and this left-hand side is the
panel so the stores keep track of the
expense data the category data I'm
anything I might have changed on the
wrath and any of the selection so
currently i have selected this safeway
expense so any of the selections i might
have and the views in the react
component i have the expense app that's
the route parent of all of the view
components
and then I have the graph component that
renser renders the right hand side and
then i have the panel component that
renders the left-hand side
and then i have the expense component
that i previously showed the code for
and the other three visual elements are
on the graph
and then down here in the visualizations
this is the d3 code that I call from the
react components up here
sorry what oh yeah you're on me
oh yeah that looks a little butter um
yeah these are the stores these are the
components and then these lines all
represent so the dotted lines means that
i've subscribed to a change listener
from the stores and the double stroke
means that I not only instantiate but
also pass down data via pops and the
single line indicates that I only
instantiate and I don't pass down data
Oh
so
in the stores this is what the
categories look like it has an ID and it
has a name and that's it but to be able
to render it on this side we need a lot
more information we need the color the
film it's a fill color we need its size
and we need its x and y positions and
the same thing with the expenses we have
some basic information but we need a lot
more than that to be able to render it
on the screen so the biggest lesson we
learned from having gone through this
process with flux is that these
calculations of I'm between what we get
from the store and what we need to
render on the screen needs to happen at
the latest possible moment of the flux
cycle
so in the expense AB example I did it in
the graph component and so you can see
the graph component on component amount
subscribe to change listeners in the
stores and then whatever its parent AB
component changes and passes down new
props we also call the this unchanged
function
and what this unchanged function does
whenever the data changes is it actually
just goes and calculates
all of the data we need to render so it
calculates categories and expenses that
you saw up above and fills it in with
the rendered data and it also calculates
the data for these links and give some
matter that in data of like which
elements are highlighted and how they
should be positioned and then it sets
state of all of those new information
and the triggers react to go through the
life cycle again and when ya go to go
through the component life cycle we get
to render and we render we we
instantiate each of the components link
category and expense components and
returns them
so the reason why this was really
important for us is because previously
when I showed you illumination um I was
changing one piece one element at a time
I was changing the role on a workload I
was giving um I was adding a rule for a
traffic line um but the difficulty we
had prior is our users could go and
change the states of all of those things
and all of these other pages and we
wouldn't know the set of changes that
they would have made so that when they
go back to the illumination page we
didn't know how to reflect those new
changes but with flux and reacts
together what we found was because all
of these other pages were mutating the
same set of stores that illumination was
listening to that whenever a change was
made in a different page it would update
the store and then the illumination page
would know about it and recalculate the
data to render on the screen so that
whenever the user came back to this page
it would be the correct set of data
that's already been calculated and shown
and that allowed us to do things like
being able to
say take a group and then get it ready
to write rules on them so it allowed us
to say go into a different page and um
set so you set some of the attributes
and then
so we could bulk edit the workloads
create a new rule set come back and have
the container ready book oh look at that
and then we can then click on each of
these links and add the rules
so moving to react and slugs from
backbone has solved a lot of the
problems for us and it also has given us
a lot of new things new opportunities to
explore so because it's kind of it kind
of did a wave for a lot of the bugs for
us the previous ones that we had and now
we can start considering new things that
are very interesting to us so for
example I'm on this screen you see about
50 workloads a lot of our customers have
thousands of workloads or tens of
thousands of workloads or hundreds of
thousands of workloads so what we're
currently working on is how do we scale
that up where we're not overwhelming
them and we're not overwhelming the
browser
but still giving them the
functionalities they had at 50 were
close
and I've also gotten some very
interesting feedback while preparing for
this talk and somebody asked me you
allow both react and d3 to have control
of different parts of the Dom why is
that why why not just have react have
the full control of the DOM and then
have d3 just calculate the data and I
thought a lot about that and I thought
that was really interesting but I think
that currently we're not very good I
think currently react has a really good
set of things I can do and d3 has a
really good set of things that it can do
and we should be able to leverage both
of them
and I think a reactive gives us enough
flexibility to be able to do so so the
way that I started thinking about this
is this isn't a one-size-fits-all
solution for all problems I'm hoping
that this is a flexible approach that
we're if we're asked to build new
features on top of it or we are asked to
build new features on top of it maybe
sometimes it fits in really well and
sometimes it doesn't but it's it's
flexible enough for us to tweak parts of
it and then and then and then be able to
incorporate the new things
and another thing I realized while
thinking through all of this is about
two years ago I joined the d3 data
visualization community and I met a lot
of really cool amazing people that were
really really intelligent and they
talked about all of these principles
that were like really when I didn't
really understand and I felt a lot like
a poser um because and then going
through preparing for this talk I
realized that I think for me what I want
to start working on is a concept of data
visualization that's actionable um and I
think react and d3 together helps that a
lot so thank you very much and them if
you have any questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>