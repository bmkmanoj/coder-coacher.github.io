<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Demystifying Type Inference | Coder Coacher - Coaching Coders</title><meta content="Demystifying Type Inference - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Demystifying Type Inference</b></h2><h5 class="post__date">2015-02-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bS2Tt7C6mDw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'll need you in a second to switch to
my to my rifle right sorry about the
delay can everyone hear me
is everyone all excited to hear about
demystifying type inference good good so
good good to see so many of you here
especially warm welcome to Paul it's
Paul here
yeah you've come to the front okay but
Paul came all the way from Paul Paul
came all the way from Oregon just a
heckle my talk so thank you thank you
for coming I hope I hope you I hope you
feel welcome so I've chosen this image
of a like a human brain to sort of be my
metaphor for type inference because it's
it's very much a black box nobody really
certainly I don't know how it works but
I'm gonna try and explain a bit about it
today
give or take some Corrections probably
I'm sure there's other people in here
who will spot issues with where I'm
saying and please shout out some people
I don't need to tell so let's let's get
stuffing a few examples this this is
this is really basic stuff if we write
Val value equals hello the type
inference will automatically put in
effectively a colon string there it
knows that that's a string that's that's
kind of what we want if we were to write
write this list now either there's a gap
there let's see we've got got a gap here
which is which is going to be where
where something goes I'll reveal in a
second the type inference is able to
work out that this is actually an either
even though we don't anywhere mention
either in in the values we apply to that
that list Factory so that's this again
what we want if we were to if we were to
write this the compiler is able to work
out this is an exception even though
once again we've not mentioned exception
we've mentioned a subclass of it and
it's Infernus from from the return site
that we've specified here so this is all
good so I've been just find three good
things now this this doesn't work this
is for connected to my old laptop right
so tuppence it's not working so well
okay can anyone tell me what type is
inferred in the gap there NFL did you
get it wrong
get out what oh okay like that is that
is that good enough any bail so this is
actually float float onto two lines and
there's a massive gap here and this is
actually the same one I showed you last
time except the type last time is a lie
what is actually inferring is this
product with serializable with either of
in turn string this is correct this is
this is I mean that there are very good
reasons as to why this comes out as the
inferred type but we would actually
probably prefer that be either event and
string I think most the time another
pretty simple example if we've got a bar
which we assign some 42 to given that
we've assigned it some of something
rather than just 42 we probably may want
to have the option later on to assign
none to it but we don't get that because
it's ascribes off must be the type some
of him so none is not a possible value
for that again there are good reasons
for it or other reasons for it at least
and we have to live with that okay
any guesses as to what this one is now
that the gap is misleadingly small here
in fact the gap is a question mark for
now right okay so if I if I can bring up
so what was it it was a list of vector
and range it's a list of vector and
range so something like this here we go
yeah
now but the thing is this this isn't
this isn't even the whole story
this is actually an infinitely recursive
structural type well as when I say
infinite it doesn't look in front it
does seem to terminate that's because
the compiler has a little hook which
says if this looks like it's infinitely
recursive actually just just fallback to
any or something now somewhere in here
there is probably in any that is the the
compiler getting out of jail so so
that's that is probably not what we want
I mean my it might do something useful
but nevertheless last one this this is a
a list of the vector companion class
companion object and the list companion
object any guesses as to what this what
types inferred here is another question
mark it is a compiler error
yeah so the type that is inferred it's
not actually a super type of the the two
values it uses to work out what the
super type is so what we have lists
yeah so so we get we get in fact to
compile errors one one for each of the
values neither of which is the type that
it should obviously be I mean list of
any would be a better better type to
infer than whatever this is so there we
are it doesn't always work as we would
like it to so what are the things that
that may influence type inference I mean
the compilers doing it all the time
whenever it evaluates an expression a
polymorphic expression there is there's
a type there that the compiler has to
work out in order to know what to do
with that expression so if you apply a
parameter to to something then that that
will influence maybe the the type that's
in that expression if there's an
expected return type so if you are use
if you're putting an expression in a
parameter position where the the type of
that parameter is known that that
becomes the expected return type and
that can influence how the expression is
evaluated if it takes an implicit and if
there exists a a single unique implicit
if there's no implicit it doesn't work
if there are if there's more than one it
won't help but if there's a unique one
that can force it down a certain route
with with type inference and it can
infer a type based on that and of course
if you just write the type in in square
brackets in in the expression then that
will that will may be obviously very
strongly influenced what the type is may
be maybe it will it will then people
then throw it into a type error ok types
this is just a reminder you can sing
this if you like I'm not going to
so the nothing types of subtype of the
nullpointerexception type the
nullpointerexception types of subtype of
their etc etc etc all the way down to
any I'm going to use these as examples
I've color-coded them to make it easier
I hope maybe not easier to read nothing
is that does say nothing at the top
there in in bright bright hot yellow
down to cold red with with the any type
at the bottom but I'll mainly be using
as an example of
type hierarchy it's quite simple and
that we're hopefully all very familiar
with runtime exception is a subtype of
exception which is a subtype of throw
balls so I'll use these in a few places
so this is just a just a quick reminder
right so parameters if we if we have a
method called foo which takes a single
parameter T we can infer the type of T
from the value we choose to apply to
that that method so foo of
new exception will give us the type
inference exception nothing nothing
clever at all there really if we have
two parameters what the compiler does is
it needs to find a suitable T that works
for both parameters so say we had
exception and error well neither the
type exception or the type error will be
appropriate there because it would break
either one of those parameters so it
falls back to throwable now this this
shouldn't be too alien to most people
here and what the compiler does it just
finds the best type that fits fits all
the parameters now this is a least upper
bound or a love who's familiar with
loves good good so the in our in our
type hierarchy at the top of the
hierarchy we always have any any is the
any as the top type nothing is the
bottom type and everything else fits
between these two as I've said there and
there is a diagram that is missing
unfortunately but it's not that
unfortunate because it was a really
terrible diagram it was it was a little
bit larger than the the missing image
icon and it came from I think I think
it's originally from the the Scala
language spec a great source of no
notice it came from language spec great
source or something inspiration possibly
which yeah I can't I can't believe I'm
try to explain a diagram that's missing
it's not very exciting anyway so
imagine a diagram and an abstract
diagram with any at the top and nothing
at the bottom that that's what would be
there so say we are the compiler we're
trying to work out a least upper bound
for for our expression so the first
thing you want to do is find the
intersection of all the super types of
the the types that are involved in that
Bible so I'll show an example in a
second grab the intersection of all the
super types of the types that are that
are applied as parameters in this
expression and we're going to ignore
type parameters because that complicates
things at least for the moment now if if
there are super types that are implied
anyway by by the presence of of the
types in our intersection then we can
remove them because they're sort of
implied anyway and the answer that the
lab is going to be the intersection of
all these types now this probably
doesn't make a lot of sense until I show
you an example so let's let's take for
example we've got a list of right of 0
and left of 2 so they're both they're
both either zuv integers or either of
integer comma integer but we're ignoring
the site parameters so now so we can
just write that the the right value the
first parameter has these super types
right either product serializable
anywhere and any and the left the second
parameter has pretty much the same
except instead of right it has left so
as i said we find the intersection
between these two lists so we lose the
right in the left and I said we remove
the redundant super type so of these
which one's going to get rid of any
sessions anywhere and any okay so we're
left with either product and
serializable and we find the
intersection type of these which leaves
us with either with product with
serializable which is why we got that
result before
even though we thought actually maybe it
wasn't wasn't what we wanted okay so you
know scarlet can do multiple parameter
blocks unlike Java and we can have a we
can have a type parameter so I use this
so I use the the added benefit of the
laser pointers you can see how how shaky
I am I hoped I'd be really cold and then
then my shivers would be stuff in
anti-phase with my nerves but so we've
got fn1 this this is the same as we saw
before weird with with creating a list
true sample fn2 takes two separate
parameter blocks and the way the
compiler works is it will work out the
it will work out T for the first block
without looking at the second one it
won't use any information from that the
value you've got in the second block in
order to work out T and once T is
established that's it it's not going to
change now if we were to write this
function to the inferred type from this
it'll be a bit like that some type I
showed it being summer 42 it will infer
right not either which means that when
we apply the second parameter the second
parameter block we get a compile error
because left is not a subtype of right
so that's no good we can get around it
by artificially adding this this type
ascription here but it's it's not what
we want it's what we want to have to do
so in this particular case if this is
the kind of code you want to write don't
use two parameter blocks use one we also
have something like this which takes a
more complicated argument involving T as
the second parameter now this this can
actually be useful where we're taking
advantage of the fact that the first
parameter block is done separately from
the second because we can we can safely
put a value in here we put the string 42
don't know why but string of 42 there
and this this function here we're able
to just say underscore plus one so it's
a lambda now nowhere have I have I
suggested that this is a lambda from a
string to the string except this
parameter here so as soon as we we apply
the 42 here there's a string T is known
to be a string and we use that in
determining what this what this
parameter here is what how to understand
what this plus actually represents this
is a string concatenation plus it's not
an integer or long addition plus or any
other kind of plus so what's generally
happening here and this was something I
I didn't really I never really thought
of until I spoke to Adrienne Mars when I
thought of my research for this talk I I
went out to see him in in Switzerland
and asked him loads of questions about
the type system and he said think of it
as a constraint system and there are
various constraints that are sort of
provided to the the solver the type
system they all the type inference sir
and these these constraints come from
different things like the the expected
return type the the the the results of
implicit search and so on and all it
does is solves an expression for a given
set of constraints now that's not a
simple thing to do but but that is that
is one way of looking at it and we get
problems if the system is over
constrained if it's over constrained
then there is no possible type that will
that will satisfy all of the constraints
we've we've suggested and you get a
compile error or if it's under
constraint in which case the compiler
will probably tell you you need to
specify a type somewhere neither atom or
or infer nothing or or any or any valve
yeah whatever you like pick something
okay
little diversion here I I tweeted
recently about how you can how you can
provide a default for a type parameter
now often you'll write some code that
that takes
your method that takes a type parameter
and you will want that method to do
something useful if you don't specify
the type parameter but you'll wanted to
do exactly what you say if you do
specify the type parameter now the ways
to do this I'm not going to give you the
code because it's it's not long it'll
take probably long time to talk through
and if you want to find out how to do it
follow me on Twitter and check my tweets
for the last couple of days the way it's
basically done is using implicit search
and prioritization of implicit send it
it does some some people say it was a
hack I don't use anymore of a hack than
many other things that certainly I do
but yeah maybe so so ok here is his the
simplest method I could come up with
that that uses of default and we want we
want to default for T all we do is you
have an implicit parameter which uses
this in fixed type defaults too so I'm
going to say that T our T type defaults
to string okay and that means that we
can say foe of Apple and this remember
we're actually inferring the return type
it's always now but we successfully get
the the Apple we wanted by specifying it
there but if we don't specify it we get
string which is what which came from
this default here so if you've ever
wanted a default type parameter it's
about three lines of code they're a bit
hacky but they they to work in at least
some simple examples such as the the
very useful ones I've shown you here
another thing we might want to do
sometimes you have a method that takes
two type parameters it needs to take to
proc to type parameters because it
fundamentally it uses like a type T and
a type s but one of them you want to be
specified by the user because the user
is sort of controlling what the method
does by virtue of specifying the type
but the other one is is something that
exists just because it the method is is
polymorphic and needs to be there so you
don't want they really want the user to
have to specify it so it's a bit like
this we've got this this action method
which takes a parameter T and we would
normally specify s manually in order to
determine which type class gets pulled
in through the implicit does this look
Phegley familiar to anyone yeah I got a
few nods that's good so you can rewrite
that as this first to find a class which
takes apply method or it hasn't apply
method which deals with the well let's
do it backwards we deal with the the
specified type first def action s1 type
parameter and that will create our new
unapplied class and then this will
automatically as soon as you apply it
soon as you provide the T parameter can
you all see the cursor there brilliantly
clear but as soon as you apply the T
this method here will be invoked and the
T will be inferred so you can have got
an example we can say action string and
the the T type which is int will be
automatically inferred so that's that's
one thing you can do to make make your
API is a little bit nicer how am i doing
the time
Oh to go or Oh excellent
okay and I'm good so in in Scala
subtyping is nominal now what I mean by
that is that it's determined by the
names of of the types the names of the
classes
you define and the traits and so on if
you say something as a subtype of
something else than it is now
it must be structurally sound as well
you can't you can't have a have a type
which has methods it just don't make
sense just because you say they just
because you say one it's the subtype of
the other so given given a couple of
types be an a we can say B is a subtype
of a if Phegley it has the same
capabilities as a what does that mean
well if B can be a subtype of a if all
the methods of B have the same
capabilities as as A's equivalent
methods methods with the same name so if
all methods take and return compatible
types and these methods Mattox must
accept every argument that the
equivalent method in a will accept now
subtly differently B's method must
return some value not every value some
value that AIDS method could return now
this is the subtle difference between
covariance and contravariance return
types of methods are covariant they vary
with the type whereas parameter types
are contravariant they they vary in the
opposite direction I'll hopefully show
you some examples of this who is very
comfortable with covariance and
contravariance and invariants there's
Dean who was hearing that the first time
I gave this talk is still comfortable
with it so I so at the very least by
giving the talk to Dean before I didn't
I didn't make him worth it
variance which was a risk let's have a
look it's this mortar down here so I'm
using color coding again covariant stuff
will be purple
and contravariant stuff will be sion
everyone okay with that it's too late
now
so I will I will also I'll also
hopefully make it very obvious that
super is a super type sub is a sub type
of super this is the little symbol we
use for is a is a super type of so
covariant things vary with their types
so Coco variant type like list for
example will vary in the same way that
that that the the type of the list or
the type of the covariant thing varies
so because super is a super type of sub
we can therefore infer that Co of super
is a super type of Co sub now if we
change that to contra this arrow versus
reverses super contra of super is now a
subtype of contra of sub now the reason
is in order to make those methods work
in the types in order for the in order
for the methods to accept suitable
parameters which may be dependent on the
parameter type of either the params type
there the generic type parameter we must
we must have those method parameters
varying in a contravariant way otherwise
we leave open the possibility that you
could call and call a method on type
that just can't deal with that
particular value for now
we can just think of contra is working
in Reverse we can we can mess these
further so ko of ko of super is the
super type of coat of code of sub and
Contra of contra now this these two
effects we cancel each other out so you
reverse it then you reverse it again you
get back to covariance so contra of
contra of something is a covariant type
so you're all following this we can mix
them up contra of Co of super is a
subtype now because there's one contra
in there and same thing if we have Co of
contra of super is a subtype of Co of
contra of sub ok that's it it takes a
while to get around this so the easiest
thing to do is just think whether the
the types are covariant represented by
plus in the in the definition or contra
variant represented by a minus sign and
you multiply the minus signs we can say
that in this this example here this
let's take this example here actually
contra of contour of super contra of
super is covariant sorry is it's
contravariance in that particular
position super is covariant in that
position silence if you had enough of
code covariance and contravariance es if
you haven't got it now then there there
are there's a whole lifetime ahead of
you to to practice it we also have
invariant system make things a little
bit more confusing I'm only going to
briefly mention invariance that's when
something's neither covariant nor contro
and it doesn't vary so if it does so it
doesn't have a plus or a minus in that
in the definition so one example of an
invariant trait in commenters a traitor
a class but a type in Scala is ordering
you can you can compare two things using
an ordering provided they are the same
type we could argue that it's not me
it's not really meaningful to to compare
the the ordering of something and a
subtype of that thing I mean there might
be a there might be a total ordering
somehow but it's not something you would
normally want to do so if if sub is a
subtype of super so same relationships
before there is no subtyping
relationship between ordering of sour
and ordering of super it might be that
you can cast them and it might be them
in the case of ordering this will
actually work but in the general case
there is no there's no relationship
between ordering of SAP and ordering of
super no no no no subtyping relationship
it is it is implied just because the
parameters happen to be a subtype of
what one is the subtype at the other
it's not okay
or at least vaguely acceptable so give
it a given given the ordering exception
and ordering a throw throw ball these
two types are in many ways as different
as int and string they are they are I
mean they're both orderings but they're
they're not relate they don't have a
subtyping relationship but be careful
because if we have a foe of tea and a
bar of tea and there's a relationship
between the the the non generic path the
type then we still have the relationship
there between those two provided they
have the same the same type so that's
that's maybe a possible trap you could
fall into into thinking that there is
always no relationship between them we
can still have that right I will do it
before about how to calculate the least
upper bound this is this is basically
what I said before and I said we ignore
the type parameters because this is this
is a little bit more complicated so with
type parameters we follow the procedure
as we did before we find the lab of the
of the main type and then we look at the
type parameters and we trace the type
parameters through the through the super
types so generally if you have a type
like write of int that that int can be
traced back to the the second parameter
of the either type that is it's super
trait that's what I mean by tracing it
through to the tip to to its parent type
and we then have to do two different
things depending on whether that type
parameter in in the definition so in the
definition of either whether that type
is covariant or contrarians if it's
Kovarian we do the same thing with the
type parameters we we find the lub as we
did previously if it's contravariant
instead of a lab we found we find the
glib the greatest lower bound now this
is this is I think actually easier than
finding the love you just find the
intersection type so it's a with B with
C you just you just with them together
and that will give you the glib of the
other types for a contravariant
parameter and you recurse on a nested
parameters so so if it's a complicated
expression with we're deeply deeply
nested types you use the same algorithm
over over again it's a bit a bit
generous to call this algorithm it
really is a sort of this is vaguely what
happens there are details which I
haven't mentioned so one other possible
thing that can can influence the type in
expression when you're when you're
evaluating it is the return type the
return type that's expected for the
position that that that expression is in
the code here are two methods which look
very similar they have different names
and they have different return types one
returns an ordering one returns a list I
haven't shown you the implementations
because they're boring I also don't know
what they do
really and I've also I've also made
these any to kind of indicate that that
type is not an interesting type pretend
it's not there so we can call these
these two things here Val X these should
look very similar except this is using
an ordering this one's using a list and
we call the different methods here what
happens do both of them work the neither
of them work
there's one of them work one of the
works which one the one which isn't the
one which isn't go variance correct so
it would actually yeah first thing to
note is that Scala can't infer the type
of something just roll and er I kind of
touched on this before where where I had
a had a lambda which wasn't where the
parameter to the lambda was not
explicitly ascribed to type Scala just
doesn't know how to do that the Ritz
generally speaking to many possible
things to many possible things that
could influence what that type is the
Scala could do more global analysis of
the code that exists inside that lambda
and make a guess as to what the what the
what the type is meant to be but it then
becomes a horrendously complicated
system as opposed to a monthly know
somebody it is friendly complicated
either way but it's it is yet further
away from simple so it just doesn't try
and try and infer the type of lambda
unless it's got some more information
now with ordering these are the two
definitions from the Scala standard
library source code on ordering and
lists they differ and that's a trait
that's a sealed abstract class but
that's not the relevant bit it's this
plus here that is the thing that makes
this different from ordering and which
means that list does not work so if our
return type is ordering then we can say
that the return values type is anything
that's a subtype of ordering of T now
ordering is invariance so we can say
that the T must be exactly T the T does
not vary it is invariant so we therefore
know what C is for the for the function
parameter value so although although
invariance may seem like you haven't put
the effort in to add all those out all
those pluses and minuses throughout your
massive hierarchy of types it actually
gives us
it gives us an easy answer here but in
the case of list list is covariant in
its in its parameter T so I'm going to
read this out we only know that the
actual T for the expression is a super
type of something which is a subtype of
the expected return type what is that
saying it's saying very little about T
we don't know anything from that it's
something which is the super type of
something which is a subtype it could be
anything we know nothing about it
therefore our system is under
constrained and there is no useful
information to come from from from the
expected return type to infer that about
that type T when used in the lambda is
that okay does that make sense is that
correct I had to think about that quite
long and hard to to come up with a
wording that that made some sense I hope
I hope it's at least close right so
constraints return types are only useful
in inferring types which are in
positions where where the the variance
matches so we have to have to work a
little bit to to check that the the
variance does actually match contrast so
this is this is this is a return type so
return types are covariant contra so T
is in a contravariant position there
because it's Co of contra whereas the T
here well a a parameter is contravariant
but the parameter type here is a
function and the parameter type of a
function
the first type parameter is itself
contravariant so it's contra variant of
a contravariant thing and it's covariant
of that so T is contra contra ko
multiply the the pluses and minuses we
get that that is covariance or
contravariant
did I mess up here I checked I changed
this several time I don't know try it if
it works it's right if it doesn't work
change change that to contra and the
other thing to go this is how hard it is
so we can we can write this inferred
without specifying the parameter here
just by virtue of knowing the result
type likewise if we reverse for contra
and ko here we can say this this will be
inferred this this type here but if they
match we have a problem we have to
actually say this is this is explicitly
type KO event in order for it to work it
out I'm not gonna ask that's okay
because is probably not try it out
so back to our list of things which
which influence type inference the first
I'm going to order them this time so
then the number one thing which will
definitely influence it is the is
explicitly specifying the type that will
guarantee that it is that type or at
least compile error if it's not been
specified explicitly then the compiler
will look at the parameters the
parameters although the types of the
values you apply to the method call the
types of them will will influence
potentially the types in the expression
if there is unique implicit that that
can also influence the type and finally
so it's it's notable look this is the
this is the last thing on the list the
expected return type that is the last
thing the compiler checks or the type
inference of checks to see whether it
can gain anything from from from from
from from from from the well it's the
last thing that is checked in order to
influence the the type so what can we do
to take advantage of knowing this order
of things well if we're going to use the
expected return type we have to make
sure there's nothing else that beats it
nothing else which influences it
so no no implicit sorry unique no
parameters in the type if you if you're
not going to use the the expected return
type and you want to use use implicit
make sure they're unique or at least the
most the highest priority implicit in
scope is it is unique and be aware that
you can't infer a type in a covariant
position from a covariant return type or
likewise a contrary position from a
contravariant return type now
all the examples I've given so far have
had pretty much a single single type
being in further than you one time now
you can have types that take several
generic parameters and these are
independently excuse-me independently
determined so the the types of I'll show
you oh yeah can build from who is a fan
of can build from four so Scott has this
thing called can build from it takes
three parameters and the the two
parameter which is covariant this it is
dealt with independently of of the
others and and what you can do
yeah I've got a whole fight on can build
from this is yeah we have a from type an
element type and to type we can happily
deal with the to type independently if
anything that affects the LM type or the
from type what this does it gives you a
means of creating a new a new container
collection from an existing one and this
is used extensively in the the wonderful
collections library in Scala we have
methods like map and flatmap anything
that creates a new instance of a
collection type
and if you change several of these
together you can get a type to flow all
the way from the expected return type
back to the back back back to the the
earliest implicit sin the soviet the
earliest calls in the in a long
expression or a for comprehension so it
sort of flows backwards and i probably
don't have to I've got nine minutes no I
don't have time to to spend much longer
on can build from but there is an
excellent answer on Stack Overflow by
Danielle several about about how can
build from works in particular breakout
who understands who knows what I'm
talking about here
both references no keep going yeah is
anyone know a song called breakout I I'm
impressed
I'm disappointed in Paul but I'm to prep
I'm impressed waiver on that breakout
let the party start is is from Rahsaan
by Miley Cyrus which which comes up
whenever I search for breakout yeah
that's the only reason I know obviously
so I I'm very satisfied that actually
there is nobody in the world who
understands maybe me other than me but
understands I would like to meet that
person if they existed so I've I've
glossed over quite a few things that are
relates to type inference that I just
didn't have time for it says eight
minutes there but I'll answer some
questions which I probably won't know
the answer to but overloading
overloading can can can really limits
the capabilities of type inference it
makes things more complicated for the
the typer weak informants this is kind
of a
a nice little hack that the compiler
does - to work out that for example a
float is a bit like a double it's not a
sub site but it's a bit like it and this
is used to make a few quite simple
expressions work as you might expect
them but doesn't really scale to larger
larger things it really does just
confuse things a bit path-dependent
types I haven't talked about a tool they
are they're probably one area that you
may be fine that as soon as you start
using them stuff doesn't work what does
infer this you would guess you would
expect it to there are reasons for that
I had to cut load of material on on why
that is unfortunately either that or I
didn't write it f m-- and polymorphism
who's familiar with that few people
you've maybe seen it in other people's
code F found a poly more from is
polymorphism is a way of I guess ok so
there's there's a tour coming up there
is a talk I'm ff-funny so all I will say
is that if a fan of polymorphism is a
way of having like a type that is sort
of both contravariant and covariant in a
in a class and it's kind of a if you if
you have that it's kind of a it's a
get-out-of-jail-free card and well get
out of jail and walk straight into
purgatory card
and of course scar has both type
parameters and type members we've
probably seen very similar most of the
time until you until you sort of expect
your type members to be inferred in the
same way that your type parameters are
or your being able to refer to type
parameters by name as you can with with
type members they each have their pros
and cons and and and there they're
basically implemented in the same way
but one is when it's heavily biased
towards specifying it all the time type
parameters you're kind of forced by the
compiler to always specify them in in in
any place you specify the type of
something whereas a type parameter your
if the the syntax is biased to not
bothering to mention them and that is
kind of the reason why you end up with
them appearing to be two different
things that don't don't work quite as
well as each other that's all I've got
I've got five minutes for questions like
I said I won't I probably know the
answer this is about the limit of my
understanding or beyond it I can't say
is that no sort of yeah okay Paul what
is it oh yeah go on go on
finality did you say
ah so sorry about this actually I I gave
this talk in London in December and the
the night before I had I said it would
have dinner with master ski and I asked
him does does the finality of a class
have any influence on on type inference
he said oh I don't think so over class
okay so he's great there yeah anyway
over dinner it was myself Martin and
bill was there around bill yeah so so
bill can verify the story is true I -
Martin I went so so Martin why is it
that when you type whatever it was list
of I think I said list of vector and I
think maybe it maybe I said they said
why does list of vector and a list of
lists list of vector event and list of
int give you this horrendous type and I
oh whoa whoa well I didn't think was
that bad okay this this changes between
different minor versions of Scala all
the time yeah I I I said - Martin what I
got I got my laptop out said why does it
do this and and and I hit return and
this really nice concise little site
came up that's like oh well that's
that's that's taking the wind out of my
sails so but then there Martin said oh
hold on you can a nice impact around for
about five minutes they said oh I've got
another example which is example using
vector and range so he was very
satisfied that he found a way of
inferring the surrenders type yeah
that's good I think I think you probably
shouldn't have access to it I mean it's
it's probably for the best
any other questions for me or Paul yeah
got the front yeah
ah right
no because they come from case classes
so because right and left our case
classes and case classes can't inherit
from one another so either can't be a
case class it doesn't therefore extend
from serializable and products can you
do that I try to go and it didn't work
you can show me later okay and this for
talking about something different
oh right yeah yeah but I can't modify
either that's the yeah yeah I yeah so
where I said where I to fork the
compiler then maybe I could a guy in
purple yeah you it's how the scope sorry
carry on I don't know the answer but
it's way way out of scope there are
probably people here who can answer that
but I've got 20 seconds left I will
probably round up there so thanks for
coming everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>