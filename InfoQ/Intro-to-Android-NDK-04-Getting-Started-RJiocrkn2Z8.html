<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Intro to Android NDK - 04 - Getting Started | Coder Coacher - Coaching Coders</title><meta content="Intro to Android NDK - 04 - Getting Started - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Intro to Android NDK - 04 - Getting Started</b></h2><h5 class="post__date">2012-04-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RJiocrkn2Z8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so now that we have the NDK
installed on our file system the next
step is for us to actually build
something with the NDK and then through
that hopefully understand how to use it
and what it has or doesn't have so what
I'm going to do is actually build an
application in the in klipse environment
and then later on compile it from the
command line in order to build this you
will need the latest version of Eclipse
the latest version of the SDK at least
one platform the latest version of the
ADT which is a toolset or plugin for
Eclipse already pre-configured and pre
set up if you don't know how to do this
I suggest taking a look at lead or
Android comm and then clicking on the
SDK tab now this is what it will end up
seeing let me actually before we get
started switch over to my browser and
switch over actually not to my browser
by this preview essentially this is what
we'll do we'll create a Java library in
which we will define some native methods
so those methods as you will see will
implement later on inside of a C source
file now before we get there what we'll
do is of course we'll compile this
library using java c or eclipse will
compile it for us international class
itself and then we'll use a tool called
java age - J&amp;amp;I to extract a header file
from the original java library or better
yet the class file which will then
implement in our c c++ source file after
we implement this will actually create a
make file there's two different parts to
the make build system the Android LMK
and the application I'm Kay you'll see
that only this one is required and will
then run the NDK build this is
essentially the step where we'll do the
NDK build which is why we install the
NDK will produce the dynamic library
will then write a little bit of you know
some sort of a client gap
that will be of course compiled again by
eclipse into a class file and then this
application will use or attempt to use
the Java library or the Java class which
in turn will load the native library and
essentially provide the implementation
with the disciplic Asian or this client
application expects ok that's our goal
now to get started what I'm going to do
is I'm going to go and create a new
Android project I'm going to give it
some sort of a name like for example in
this case I'm just going to use
Fibonacci as an example application so
I'm going to call this Fibonacci say
native and I'm going to click on next
choose a build target in this case I
have quite a few I could choose any of
the build targets we're not going to do
anything special at least nothing that
wouldn't work on say API level 8 or 9
but doesn't doesn't matter in this case
I'm choosing the latest one clicking on
next and then I'm going to choose a
package name like for example call
Maracana dot Android dot phoebo say
Fibonacci native ok and then I'm going
to create activity for example say
people are cheap activity minimum SDK 15
again I'm just using this as an example
feel free to go and lower the SDK to
something like 8 if you want to be able
to try to run it or upload it to market
for example so click on finish and this
builds a basic structure of my
application it's going to take a little
bit of time for Eclipse to go and figure
out that there is in fact the our file
and for this red section to go away and
now it's done ok so the next step is for
us to actually create the library itself
so we do this by right-clicking on this
the package and create in a Java file I
should say a Java class that I'm going
to call for
full fib live just some name that I
chose to do and clicking on finish this
will essentially create an you know
simple class file now this class file is
just to show you this class file it's
basically this library right here now
you don't see this but it's already been
compiled by eclipse into a native class
so we actually have all of this or
they've done of course we haven't to
find anything there so it's really
useless at the moment okay so let's go
and define something okay so what we'll
do is define for example four different
implementations of the Fibonacci it's
actually algorithm or sequence two
implementations are going to be written
in Java two are going to be written
natively and we're just going to use a
test performance later on we'll
introduce other things into the mix but
this is going to be to get us started so
for example the naive draw
implementation may look like this public
static you know long fib JR I'm going to
say J's for Java RS for recursive so
given some sort of an N which is going
to also be a long I'm going to say well
return if n is greater or less than zero
for example returns zero otherwise if n
is equal to 1 return 1 otherwise return
fib of j r of n minus 1 plus fib of j r
of n minus 2 so this is how essentially
the fibonacci sequence is defined
nothing too special not in too exciting
now now that I had this I'm also going
to define a native version of this
method public static whoops I should say
native static fib J I should say n R for
native long and this is essentially J
and I what this means
oops I'm going to say I'm going to
forget forgetting one part which is the
return value
I'm essentially saying here that the
body of this method doesn't exist
it'll be provided natively it's kind of
like if you're creating an abstract
method this would have been an abstract
class you could say an abstract method
somebody else will implement it well in
this case somebody else will be a are
made of code which we'd have to write so
then I'm going to define a version of
the same through notch algorithm but
this time around around we're going to
use the iterative approach so public
static long fib J I I for iterative long
end and I'm going to say return whoops
not quite so for example long previous
equals doesn't matter - 1 long result
equals 1 and then for some sort of long
I equals 0
I'll ops I less than n I plus plus
whoops we are going to say give us a sum
so sum of result plus previous ok so
this actually matters so that's why we
initialize the previous and the result
to minus 1 and 1 so that initially
they're going to cancel out and then
previous equals result and result equals
the sum and all we need to do is return
the results and now we have the
iterative version of the Fibonacci
algorithm and finally we're just going
to go and say for fun public step-ups
native doesn't actually matter in which
order you define it but I like to do it
this way
static long fib and I long n done so
this is essentially our entire fib Lib
library that's if you take a look at
this this is what we've now built so now
this part is actually done and to show
you that we have even the library class
I'm
go and open up my terminal I'm going to
go to the directory where this is
located so in this case is aaanthor I
should say workspace course where
androids out workspace again I know it's
confusing and there you'll see that I
have my Fibonacci native project and
there you'll see I have the bin
directory or LS bin classes and then of
course I can go and type column boom
boom and here is my class file so that's
that part is done the next step is for
me to build the or extract I should say
the shared I should say let's take a
look at this the header file right now
I'm going to use a tool called draw age
- j'ni to extract this later on you'll
see that you don't even need to do this
step there's a there's another way of
registering the or binding native code -
to java code without the need to to
worry about specific name spacing or the
mapping rules so for the time being
we'll actually do it this old-fashioned
way
so what does it mean first of all I'm
going to create a directory called J&amp;amp;I
now why am i creating this directory is
because that's where NDK expects to find
native code okay it's by convention and
now that I have this I'm going to run
this tool called Java H - J and I and
I'm going to say I want to go and clasp
at load classes from my bin slash
classes directory and output the header
file into so the destination is the j'ni
directory and I'm specifically looking
for a class by the following name call
Maracana dot Android dot Fibonacci
native dot fit lid enter if everything
worked correctly under the j'ni folder I
should now have this header file so what
do i do then well let's take a look at
it I'm going to go into first of all the
clips and do a refresh of
my project because by doing that I get
the clips to discover the new folder and
now you'll see that I have this file
let's open up this file notice by the
way this file looks kind of good meaning
it syntax highlighted and the reason why
this works is because in my Eclipse I
actually have CDT which is a set of
plugins that enable me to write native
code right in Eclipse it's not just a
Java editor it's also a C C++ editor you
can certainly go and add that support to
eclipse through help and then install
new software and then you can search for
CDT now let's take a look at this
resulting file why this file you know
what is this file to find well fib lab
you'll notice has a certain packaging
and it has a class name with certain
native functions or I should say methods
but ultimately they'll become functions
so now check this out in C we don't have
the concept of sapporo of namespaces so
instead in order for later on java to be
able to invoke these functions written
in the C language or I should say Mia I
guess the C language will need to
somehow map from the Java namespace into
a flat namespace of C and the way this
is done at least with j'ni is that this
function by for example fib n r is
prefixed with a rajala underscore the
package name underscore the class name
and then finally the function name
notice that that function name takes in
three arguments though a pointer to the
environment the jaw of the point to the
reference the class student which is to
be found and the J long which is
essentially as you will see the N itself
this is the version of this function in
for at least for this NR 5 NR and here
is the same function for fib and I okay
so now that we have this the next step
is for us to go and I'm going to
actually copy these two functions like
so or I should say it's probably the
that'll do this way I'm going to copy
this entire header file like so so copy
and then go over here and type paste I'm
actually making a copy of the entire
header file doesn't seem like the most
you know logical thing to do but you'll
see in a moment so now I have a file by
the same name except you know that it's
dot C so just to show you what we're
doing sorry
we've now essentially done all of this
this is what we have I'm now going and
creating this file okay that file as you
will see will import from the header
file
Parshin city include so now that the C
file here it is
I'm going to go and have the C file
include the header file so calm or
underscore Maracana underscore Android
underscore Fibonacci native dot orps
underscore fib lid dot H get done and
now I'm going to get rid of this get rid
of this get rid of this so all I'm left
with are the same function signatures or
prototypes that have done before except
that now I'm actually going to provide
the bodies of these two functions so
here is you know our first function the
fib and our that takes in a pointer to
the environment a reference to the class
and then the n now the pointer to the
environment is going to come in handy
later you will see exactly how the class
is given to us so that we can reference
this fib Lib class had this been a
non-static method then we would not have
be given a reference to a class would be
given a reference to the object so this
would have been called the J object
ordeal would have been of type J object
and finally this is the N itself so just
to show you back here remember how this
film NR takes an N well here we get that
end now why is this N J long ok well the
thing about J and I as you will see the
Jana is generally meant to mostly not
implement a lot of logic but other
java datatypes on to see data types that
we can invoke code that is written just
natively with a without any regard to
Java or the Jana so essentially that
means that we have to map from one data
type space into another in Java and
dalvik as a result the data types are
fixed we know exactly what they are
regardless of the underlying
infrastructure or architecture so we
know the boolean is essentially on site
ADA happens to be unsigned 8-bit a byte
is always signed eight bits that char is
unsigned 16 bits short is always 16 bits
into int is always 32 bits long is
always 64 bits
unfortunately in C or C++ something like
for example long will depend on the you
know our underlying architecture so if
you're in a 64 bit platform long is
going to be 64 bits if you're on a 32
bit platform long is going to be 32 bits
in Java that doesn't have work that way
it's always 64 bits so because of that
we can't really use c pipes without
worrying that we may actually you know
for example overflow our values or
truncate our values so and so basically
instead we're going to use j logs so we
know exactly what type this is and this
is really nothing more than a little
type that where does this come from well
notice how here we are including the
scatter file well that header file is in
turn including the J and either H J
neither age as you will see defines a
number of things including this j'ni
environment the J class as well as all
these other data types that we now see
so let's go down here I'm going to do
the same thing that I've done you don't
name these parameters here I'm going to
do the same thing over here and so now I
just a matter of me implementing the
code so for example for this version I
could just be lazy and copy the Java
version so I'm just going to boom copy
this code in fact copy all of this go to
the c p-- limitation and literally paste
it the only difference is that now this
becomes a j long this becomes a j long
this over here becomes a J long I so I
can't this is not quite c99 so I can't
declare this inside of the for statement
for lo statement
this becomes a J long okay
this becomes a basically same as before
nothing too exciting move this over here
in fact let's use same kind of
indentation as I did do in Java so it's
consistent and now I just provide the
result okay done so again this is just
the same code but written in C for the
other pub one which is this function
well the problem is I don't want because
this is recursive and you know recursion
is involving if you will because you're
copying stack variables what I'm going
to do I'm going to create a helper
function this is going to be a little
static which means you know internal J
long say fib just fit that takes AJ log
of N and simply goes and returns you
know the people not cheap like this and
this so this essentially is equivalent
to what I have in Java the only
difference is that I'm now going to call
into that function from here and say
return fib of n so essentially the
reason why I did it this way as opposed
to having making this into a recursive
function is because I don't want to copy
these two arguments every time i recurse
into my own function but i should now be
essentially done appearing of course any
sort of typos or or mistakes this is
where we are now we've written all of
this okay the next step of course is to
build the make file and once we have the
make file we can produce our final
result so let's get that done
okay so I'm going to go back in here and
create a new file I'm going to call it
it's just a file I'm going to call it
Android dot m'kay that's it it's here
and what I'm going to do is in this file
I'm going to put the create a number of
entries will actually talk more about
this file I just want to get it working
first and then we'll come back to what
exactly you know do all these things
mean and what else can we do here so
first of all I'm going to say local path
is oops is and I'm going to call into a
simply a new macro called call of call
my my dir which sets up the local path
variable to the current directory then
I'm going to say include and I'm going
to say clear VARs what that means is
that Italy clear all of the variables
that start with local except for the
local path if any exists this will
become more interesting later then I'm
going to say local source files I only
really have one and this one file is the
com-pubs
Maracana Android Fibonacci native
underscore fib lip whoops and dot C
that's the source file and finally I
have to define a local module what is
the name of the final shared library
going to be well I just just for
consistency reasons I'm going to call it
exactly this of course - extension now
this just defines the necessary
arguments into the final part and that
is include build shared library what
that does is essentially execute think
of it as a function that says what do I
need to build and where do I need to
store it so it builds this code
odhh as a shared library by this name we
will see the final name and what it
actually is set to now what we're going
to do is actually execute a bill to test
it out and then we'll move on to a few
more things to build like for example
the UI so let's try it out and the Kay
whoops NDK - Build if I hit enter it
everything works correctly it compiled
by default an ARM based shared library
that I should now be able to load into
my application and start using it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>