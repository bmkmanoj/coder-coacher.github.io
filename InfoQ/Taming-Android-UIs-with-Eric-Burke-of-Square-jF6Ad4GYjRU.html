<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Taming Android UIs with Eric Burke of Square | Coder Coacher - Coaching Coders</title><meta content="Taming Android UIs with Eric Burke of Square - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Taming Android UIs with Eric Burke of Square</b></h2><h5 class="post__date">2011-12-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jF6Ad4GYjRU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so obviously my name is Eric Burke I
lead the Android team at square when I
started at square was March of 2010
there were just two of us those me and
crazy Bob Lee working in st. Louis back
in Bob's house so we spent the first
nine months working in his office and
his wife was amazing she would bring us
lunch every day and and treated us
really well but that was an amazing
experience we've grown our team we're up
to about five people and I just moved to
San Francisco actually the first of the
month I've been living in an empty house
all month and my wife and kids just
moved out Friday so it's been a busy
time for me but I'm here in San
Francisco now doing Android stuff
Foursquare and it's awesome so let's get
started
this is our card case application so who
in this room didn't realize that Square
was available on Android one two three
four five six maybe for being shy but I
run into a lot of people who don't
realize that we have Android software we
actually have supported Android all
along we have iPhone iPad and Android
applications this is our card case
application on Android this is you know
I helped write this this is another
screen in the card case application so
when you tap in the upper-left corner
it kind of flips over to the payment pad
and it lets you accept payments one of
the things I really like about this
screen it's a little hack I did so when
you're doing iPhone applications it's
really easy for the programmers and the
designers because they know exactly what
the screen resolution is gonna be so the
designers always give you the One X and
the 2x assets right so you get bitmaps
you just drop them in and it's awesome
it works perfectly well not not so much
so on Android right we got a million
different screen sizes so if you look at
the top it's a little fuzzy on the
projector but there's this torn paper
effect
so the way I did that is I have a custom
view that draws a series of lines and
when the view is created we create a
random instance just seated with the
current time and it basically marches
over a few pixels and then up and then
down and over it just zigzags picking
random X&amp;amp;Y Delta's to jump across so it
looks like a torn sheet of paper and
what's really cool about this is when
you tap clear and it rips away that
sheet of paper I pick a new random seed
so it looks like another random tear so
it looks like another sheet of paper so
that's the kind of detail I like to put
in the user interface it's better than a
bitmap because it's scalable to any
screen size it looks crisp and clean no
matter what device we're on unless we're
on a projector then it looks a little
fuzzy and you can't even tell their
story but if you get the application and
look really carefully you'll see that
tear effect but the random seed is kind
of a nice touch because it's different
every time another screen and another
screen and let's actually look at some
source code so we're gonna start pretty
simple with a custom view so is anybody
written a custom view from scratch on
Android handful of people depends on
what I mean by scratch
right okay so he's done custom views not
from scratch like you might extend
button and add a few attributes or
extend view group or our frame layout so
here I'm extending view which doesn't
give me much of anything so all I want
to do first is to keep this view
perfectly square no matter what screen I
drop it on so this is called an editable
photo and we'll see why it's called
editable photo in a little bit but to
make it square I / I'd on measure and
then there are a series of methods you
can call that are built into the view
class so all I'm doing is calling
existing methods from view so I'm
calling get default size get suggested
minimum width and then taking that width
measure spec so the width and height
measure spec are passed in from Android
and those are integers that have the
width and also like a constant saying
like at most or exactly and then you
break it up using this measure spec
class anyway it's kind of tedious kind
of weird weird code but ultimately I'm
getting the measured width and height
and then I take the minimum of those and
then call set measure dimension okay so
this is a first tiny step to making a
custom view I'm overriding on measure
and I'm making sure that the thing is
completely square all the time so here's
what it looks like when I draw an image
so the bitmap is square not terribly
interesting yet one thing I do want to
show that we've got different sizes here
so we can make the bearded man any any
size we want and it's always going to be
square and then at the bottom we have a
placeholder so the top two images are a
bitmap that we've set through code we
call set set image and give it a bitmap
the bottom one is a drawable that's
embedded in our android APK file okay so
when a bitmap hasn't been set it uses
that placeholder photo when i zoom in a
little bit though I want those corners
to be rounded I don't want perfectly
square corners so we want to soften it
up a little bit so you may notice from
the slide don't do this and the
wrong way sign that this is not the way
to do it
this looks really simple though right we
create a path and we can use that as a
clip so from the path we add a round
rectangle you can actually add any shape
you want you could make a shape where
you're curving around I'm making like a
picture of the Android robot or whatever
and then you just say canvas clip path
and then from then on anything you draw
to the canvas is going to be clipped to
that path so it won't exceed the bounds
of the round rectangle then we restore
the canvas back to its original state
so anytime you clip the path you want to
restore so that subsequent calls to the
canvas are not affected by the clip path
that you just set so this seems really
easy and it would make the corners
rounded but you get these ugly jagged
corners yeah you can see that even on
this projector you can see there's stair
stepping and little pixels on the corner
the problem with this approach is that
no matter what you do Android doesn't do
anti-aliasing when you use clip path
it's just a fundamental platform
limitation so even if you set a paint or
set flags and say paint anti-alias flag
and then you clip the path it doesn't
work okay so you have to have a
completely different approach to round
the corners in Android or to apply any
other shape to a bitmap
alright so lazy bitmap why do I say lazy
bitmap what I'm doing here is I'm gonna
create a brand new bitmap that is a copy
of the original
so the original either have the image
which you set in code through set image
and that's a picture of the bearded man
right or I have a placeholder which is
the default silhouette that you saw on
the bottom picture on a few pages back
when we had the three pictures and then
we have this third bitmap the framed
photo so the frame photo is the one that
I'm gonna generate in code it's an
off-screen bitmap that I have to create
to have those rounded corners so I don't
want to create that right away because
in the oncreate method of a view you
don't know the width and height so we
have to wait until later when the view
is actually drawn to compute the bounds
so in the ondraw method if both the
placeholder and the image are null we're
just gonna ignore it in return because
there's nothing to draw so that's kind
of an uninteresting edge case but we
need to do that to avoid null pointer
exceptions so next step if the frame
photo is null then we need to lazily
create it now on draw could be called
over and over and over again if you're
animating a view so you don't want to
create a new bitmap every frame of that
animation right you'd very quickly well
you'd make your app really slow and
potentially run out of bitmap memory so
you want to create the bitmap once
lazily when it's first requested and
then after that you reuse the same
instance over and over and over again
until the view resizes okay so I call a
method create frame photo and I pass in
the the minimum of the width and height
technically that's not necessary to call
math dot min because I also ensure that
the views already square so I could just
take the width or the height
I guess the code just looked a little
more clear to me doing it like this and
then I call canvas draw a bitmap with
the frame photo at the upper left-hand
corner zero zero and then it passed a
null paint object so creating that frame
photo that's creating the off-screen
bitmap that has the rounded corners
that's where the magic happens we have
to use a technique called
alpha compositing so if you go to google
and you search for alpha compositing
odds are the first hit or two is going
to take you to this great Wikipedia
article and this Wikipedia article has
this image on it so all we're trying to
do here now I don't really get into all
the math of this you don't have to
because Android gives you ap eyes to
work on this without getting all math e
and technical but the general idea is
you start with a transparent canvas and
you draw one image and then you set this
transfer mode and then you draw another
image on top of the original image and
then depending on the inner
section of the pixels and those two
images you'll get a third resulting
image that is the composite the
composition of the two so this diagram
attempts to show you the different modes
like a over B a n-b-a out etc okay so
it's almost like you're taking two sets
and you're trying to get the
intersection or the union of the sets or
whatever
okay so there's different modes to
tinker with and that's how we're gonna
add the round corners to the bitmap so
the create frame photo method takes a
size that's the width and height because
we're making a square image first I
create a drawable so remember I have
either the bitmap image that you set in
code which is the bearded man or we have
the placeholder drawable which comes
from a drawable that's embedded in your
app so we've got either a bitmap or a
drawable two different incompatible
classes so what we need to do is take
the bitmap and wrap it with a bitmap
drawable that's what this first line of
code is doing it's kind of like
housekeeping code once we've got this
now we have a drawable regardless of
where it came from well we can work with
it in a consistent way so then we create
the off-screen bitmap so you say bitmap
create bitmap you give it a width you go
to height and then you give it a bitmap
config so the config I pretty much
always use is a RGB 888 okay all that
does is create a bitmap that has an
alpha channel so it supports
transparencies then another little bit
of housekeeping I have to create a
rectangle that matches the size of the
bitmap and then I compute the outer
radius so the corner radius in this case
I take the size of the bitmap and divide
it by 18 okay is anybody know what's
magical about the number 18 when you're
dealing with graphics like this any
guesses something related to a nine
patch ok 9 times 9 times 2 is 18 okay
that's a good guess
absolutely nothing right half of 36 no
still absolutely nothing is still the
right answer what this was was based on
the width of the image I need to pick a
corner radius as the image gets bigger I
want the corner radius to be bigger
because bigger images have bigger
corners and as you shrink it down I want
proportionally smaller corner radius
radii and whatever so this was me typing
in a number compile deploy look at it
nope that doesn't look good let's try a
different number compile deploy it just
so happens 18 happened to look good to
me okay so the point is here you know
I'm kind of teasing you guys a little
bit but there's nothing special about 18
other than I thought it looked good but
the point is I don't use
device-independent pixels I don't use
pixels instead I pick a ratio of the
width and/or height and then base the
radius based on the size of the view the
reason I do it like this is because this
is going to scale to any Android device
it's gonna work on the Galaxy Tab the
Dell Streak you know a hero without me
having to get in there and tweak pixels
on every single phone okay so you're
never going to completely get away from
pushing pixels on a UI but whenever
possible you want to deal with ratios
and percentages of overall sizes that
way your your UI is going to be flexible
to far more devices with far less work
on your part okay so that's where that
18 comes from is trial and error
so a creative paint object at this point
we can specify anti-aliasing and what
anti-aliasing does is gives us nice
smooth corners and I set the color and
then I call canvas draw round rect give
it the rectangle the radius and the
paint and then I have this beautiful
opaque red round rectangle with nice
smooth round corners okay and if I
stretch that to any size the corners are
gonna stretch along with the image so
it's a little strange to draw an opaque
red rectangle but remember we're going
to use this alpha composite
so the technique is to draw the
rectangle first on a transparent
off-screen canvas then we draw the
bearded man the drawable on top of that
and then because we're using Porter Duff
mode source in any any pixel that
intersects will be kept in any pixel
that falls in those transparent corners
is gonna be dropped so we're gonna be
left with this beautiful round rounded
image with the rounded corners so in the
previous slide I drew the round
rectangle with red it doesn't have to be
red it can be any color it just has to
be an opaque color I like to use red
because when I'm testing it's this
vibrant in-your-face color and I can
tell immediately what's going on if I
had made it like black then I load it on
an Android device the default background
is black I wouldn't be able to see
what's happening so I just make it an
obnoxious primary color whenever I'm
testing things so we set the porter duff
mode we set the bounds of the drawable
this is important if you remember we're
dealing with drawables instead of a
bitmap so whenever you paint a drawable
and Android you have to explicitly set
the boundaries of the drawable otherwise
it defaults to zero by zero and then
when you draw it you get nothing and
then you're banging your head against
your keyboard wondering why isn't it
drawing so you have to set the size and
then I save the layer temporarily
because again because I'm drawing a
drawable I can't apply a paint directly
I have to assign the paint to the canvas
so this is a little little trick you
save the layer you give the paint as a
second argument I'm kind of gesturing
towards my screen I don't know if that's
all that helpful to you guys maybe I
should point to the slide there I draw
the bearded man on top of the round red
square rectangle whatever and then I
restore the canvas to its original state
and then we're left with a nice image
that has nice smooth rounded corners
with anti-aliasing so we get nice nice
round corners okay so we're getting a
little closer to the editable photo that
we want what we want to do now is add a
photo or a frame to the photo
so I'm not going to show you every line
of code like we did in the previous step
because it's essentially the exact same
procedure so first we create an
off-screen bitmap and we create a canvas
that matches the size of the bitmap then
we draw an opaque round rectangle in the
middle so we're inset in it a little bit
because we're we're gonna punch this out
as a whole fee to see through and then
we set the mode to source out which is a
slightly different mode because we want
to remove the area that's in the red
rather than keeping that area and then I
draw a larger round rectangle with
partial transparency right on top of the
red and then that Center X section
actually gets punched out and removed
because of the reporter duff mode and
I'll be completely honest when I do
stuff like this I usually guess the
wrong Porter duff mode and I just keep
trying until I hit the right one it just
you know it takes a while to sink in I
guess so we draw this round rectangle
then we have another bitmap we've got
the original bitmap and now we have this
round rectangle bitmap we draw them on
top of each other and then I draw the
text edit on the bottom and then we have
this nice custom component that we can
use that's why I call it editable photo
because when you see this you can tap it
to edit your profile picture in our
applications ok so that's basically the
steps I followed to create this custom
view in Android now in Android it's nice
because any view you can register an
onclicklistener you don't have to do
anything special for that so you just
register an onclicklistener and when you
tap it it gets an on click event and
then you can go into the the photo
selection or whatever okay are there any
questions so far
am i changing the state of the image on
click like showing it like pressed or
whatever so I'm not doing that no if I
wanted to I suppose you know one thing
you could do we're doing this elsewhere
actually is we apply a partial
transparency like we set an alpha on on
a component so when you press it it kind
of looks dimmed out a trick in android
though is
didn't add the set alpha capability
until something like Android 2.3 so the
question is how do you set an alpha on a
view on older Android releases and
maintain compatibility does anybody have
an idea how you would do that yeah
overlay a view on top you could that's
just going to kind of add a darkening or
a brightening effect actually the way
you can set an alpha is you can create
an animation that you they have an alpha
animation right so you can set the the
an alpha animation with a duration of
zero and you can set fill after to true
so when you apply that animation it
instantly turns transparent or
translucent and because fill after is
true it sticks so once you press you
could set the animation and then when
you release you could clear the
animation and that would set an alpha on
your component and that actually works
on any view or you could do it on a view
group that has a bunch of children and
we're actually doing that in the next
version of our card case when you tap on
a card we're applying an alpha animation
to make it partially transparent so you
can drag cards around and it looks
really awesome so that's just a little
Android hack you can use to apply an
alpha to older SDKs even though they
didn't add set alpha until Android to
three or so all right so this is a
doctor evil on an edit screen dr. evil
is one of my go-to characters when I'm
testing my account I'm always either the
bearded man or dr. evil or Oprah
occasionally gene Simmons also so it's
just a good way to know I'm hitting the
test server and not production data and
actually charging myself ten thousand
dollars I did come home once and my son
had been playing with my phone and I
noticed in the payment history there was
a 1 million dollar payment and
fortunately it was on the staging server
so that really happened and it's still
in payment history you can scroll way
through my payment history and
eventually he hit a 1 million dollar
payment like oh my gosh so
this screen is kind of fun so the
background right now is solid gray so I
want to jazz it up a little bit so if
you were to look at pretty much any
modern UI if you zoom way in you're
gonna notice that almost every screen in
OS X or Windows or whatever they apply
gradients to everything so first thing I
want to do is apply a gradient to this
screen now this is not the real gradient
I mean this is way too dark and way too
ugly what we really want is a very very
subtle gradient so you almost don't
notice the gradient but it does add
texture and depth to the screen so the
reason I make it dark is again the same
philosophy as the red rectangles when
I'm testing I want to pick bright dark
colors so that it immediately pops out
at me yeah you're doing the right thing
because when you create a gradient like
this you have to choose an angle I know
now this is 270 degrees but when I first
coated it I'm like okay does it need to
be 0 90 180 or 270 so you make it nice
dark colors and then it jumps out right
away and you see if you're doing the
right thing so the gradient just goes
into resource drawable would create a
plastic background XML and this is a
standard Android draw well there's
nothing custom here whatsoever
okay so just create a shape drawable
gradient you give it a starting color
and ending color and an angle I'm going
to extend linear layout I call it
plastic linear layout because we want
this this screen to look like a sheet of
plastic so in in our applications most
of our screens look like paper but then
when you go over to the settings side of
the application they look like plastic
okay so extending linear layout in the
constructor I call set background
resource and are that drawable plastic
window background that's the XML file
from the previous page so all that does
is apply a very very subtle gradient and
you can't even tell it's there on the
slide I probably need to make it a
little more adjust the colors a little
bit I think it's a little too subtle
but to really make it look like plastic
we want to add a shiny effect so again I
pull out the primary color so I make it
pink just so I can see what's happening
we want to draw this triangle on top of
the background but behind the children
views so it goes from the upper left
corner down to 80% of the height and
there's a gradient going from top to
bottom in that triangle the way we do
that is in that plastic linearlayout
class I have a private method called
create shine path and I asked the View
for its width and I asked the View for
its height and then I multiply that by
0.85 just because through
trial-and-error I found that 85% of the
height is a good approximation of the
the mock-up that the designer gave to us
okay so the designers are not going to
give you a separate design for the Dell
Streak and for the Galaxy Tab and all
these other devices they're going to
give you one design and then you have to
interpret it for all the different
Android phones so it makes your job
really awesome so once I have that
height and width I create a path object
and then I don't know if you work with a
path before but you basically move to a
starting point so zero zero is in the
upper left hand corner and then you have
a series of line twos so I draw a line
from the upper left corner to the upper
right and then down and then close the
path and it makes a triangle okay in the
triangle I now need to create a linear
gradient this is a case where you need
to create the gradient in code because I
don't know what the height is so I'm
creating the gradient starting from the
upper left hand corner zero zero going
down to x equals zero and y equals the
height so the gradient is going straight
up and down and then from the starting
color to the ending color and then you
give it this last parameter called clamp
which means the gradient stops when it
gets to the bottom okay so you need to
set this in code because you need to
know the dimensions of this gradient so
once it's finished the shine path is
you can't even see it on the projector I
can see it on my screen it's really
there you can see it on a phone too it's
just this kind of path that goes here
and it makes it look like shiny shiny
plastic okay I had this idea I haven't
done this yet but what I really want to
do is hook this into the accelerometer
so that when you rotate the phone the
angles changing I can just adjust the
the brightness of the colors so it looks
like a shimmering like a reflection I
think that would be really awesome and
I'm either gonna do it or I'm gonna make
Demetrius do it where are you Demetrius
he's another programmer on my team he's
in here somewhere
he's cringing right now no not more work
okay
so plastic linearlayout this is the the
class so we've got a private paint
object that has anti-aliasing set so I'm
drawing a triangle but I'm still using
anti-aliasing the reason I'm using
anti-aliasing is because the triangle
goes diagonally down the screen and if
you didn't use anti-aliasing you would
see little stair-step pixels going
across the screen so use anti-alias seam
to smooth it out one of the few times
that you don't use anti-aliasing as if
you're drawing like a straight line or a
rectangle then you can get away with
avoiding it but usually if you have
angles or curves you want to
anti-aliasing anti-alias just about
everything in your drawables so on the
constructor I set the background
resource we already saw this code all
we're doing is extending the example to
override dispatch draw dispatch draws in
the base class we're overriding it here
this is called immediately before the
children are drawn so this is your hook
it's your opportunity to draw custom
stuff either before or after you draw
the children or you can actually not
call super you can just take over
drawing yourself and do some really
interesting kind of amazing things to
children which I'll show you in a few
minutes so we're overriding dispatch
draw because I want to draw the shine
path behind the children so this is
another example where I'm lazily and
wising things so I can't create that
path in the constructor and I can't
create that path in oncreate because I
don't know the width and height of the
view yet once on draw or Dispatch draws
called though I know that the view has
been assigned dimensions so I can go
ahead and create the Shine path at this
point only do it once though and hold on
to it after that to avoid creating the
gradient object over and over again then
I draw it a path and then I call super
dispatch draw if I wanted to reverse
this order I would simply move dispatch
draw up a few lines and then the path
would be drawn on top of the children
instead of behind the children okay so
this gives you a lot of fine-grained
control over when you draw things
relative to your children this would be
useful for you know like if you're like
beta testing an app you could like draw
like the word beta on top of an app or
whatever you could do some some kind of
creative things with with dispatch draw
I think and and some transparency so
whenever layout of curse this means that
the bounds of the component have changed
so what I like to do is anything that
needs to change based on the dimensions
I just reset it back to null so here I
just say shine path equals null and then
the next time on draw is called it'll be
lazily created once again because I
check for null and I create shine path
every time on draw or dispatch draw is
called and then this creates shine path
so what we saw just a minute ago okay
are there any questions about this all
right I've done an amazing job
explaining because there are no
questions obviously oh yeah okay so the
question is he saw a demo where they're
doing a like a look like a WYSIWYG kind
of layout editor where you could see
this stuff on screen
so here's the deal we don't use any of
the those tools at square the reason is
we have a very complicated application
and the clips tooling and all that no
longer works so some of the issues we
face is we have two applications we have
card case and we have square okay
there's a ton of code that's shared
across both applications so all that
code goes into a project we call core
the other thing we have is we have beta
versions of our applications so we have
card case beta and card case production
square beta and square production so on
an Android device you cannot have two
applications installed on your device at
the same time with the same package name
so they have to have unique package
names so for us to compile our
application the other piece of this is
there's a bug in Android that they
haven't fixed there's no way to create a
library project that has custom
components that have custom XML
attributes because when you add custom
attributes to a view you have to have
those in a package name that matches
your app and then when you you basically
can't bundle that core library project
in a jar file and just reuse it you have
to actually take those XML files copy
them to your project rename the XML and
then we also have to rename the XML for
our beta versus production apps so that
they can coexist on the device at the
same time so you can imagine for a
non-trivial project our build is very
complicated and unfortunately it's so
custom that none of those tools work so
I can't really answer your question the
good news is in our 15 of the
development tools they are allegedly
going to fix this issue with library
projects and custom attributes so that
you'll be able to develop custom
components and put them into a jar file
and just share that jar file into your
applications so once that happens
hopefully we'll be able to use more of
the standard tooling and get that
that kind of real-time layout on all
that but right now we just hand hand
code over all over XML you had a
question
yeah so the question is compositing our
compositing and anti-aliasing
hardware-accelerated they are if you're
on honeycomb or Ice Cream Sandwich and
you've enabled hardware acceleration so
we haven't got there yet with our apps
we go all the way back to API level
seven so you know we're really looking
forward to honey art Ice Cream Sandwich
but even so we're gonna have to have
conditional logic in our app at some
point or we're gonna have to have
another special build so okay so
takeaways use gradients all over the
place it makes your UI look great when
you're testing use bright primary colors
and only invalidate your drawables when
the boundaries change you don't want to
reallocate bitmaps and gradients and all
that in ondraw because those are called
over and over and over again you're
gonna use a ton of memory and you're
going to make things really slow so
tools that I use constantly are digital
color meter because you can just zoom in
and pick out colors in Lion though they
took away the hex so kind of made it
useless so you can go buy a tool called
X scope which unfortunately is $29 but
it does essentially the same thing as
digital color meter so if you want to
add custom attributes to components like
that you put those in our ES values at
our XML in that XML file you would
declare a styler ball give it a name
like editable photo in this case the
photo editable photo matches my java
class name and you list the attributes
so these are name value pairs the value
is the format and you have string
dimension reference I guess the way I
learned how to do this is just to grab
the source of Android and study adder
XML for all the stock components and
kind of just learn how they do things
there are a few gotchas like once you
define a caption format equals string
like if you have another custom
component later in the file that also
uses a caption attribute
you have to omit the format if you list
format equals string twice then it blows
up it doesn't like that so it's almost
like these going to a kind of like a
global namespace or whatever and they
collide with each other so it's just a
little gotcha to reference the component
in your XML file you have to give it a
namespace like XML namespace Square and
then you use this schema stat Android
comm and then the last part comma dot
square up matches your application
package so this is where when we build
the production versus the beta version
of our app we have to copy the XML files
and replace these namespaces with com
square up development or comm square up
beta so that we can have two versions of
the app coexisting on the device at the
same time it's loads of fun and then to
reference these you whenever you have a
custom view it's a Java class and odds
are it lives in a package so your XML
tag just becomes the class with the
package so comm square up editable photo
is the tag name and then the custom
attributes are using your namespace like
square colon caption caption size
placeholder and then these are just they
look like normal Android attributes
except they're prefixed with your
application namespace ok the really
nasty code that I'm not going to get
into much detail on is in the
constructor of editable photo that way
you get to those custom attributes is
you obtain styled attributes from the
context that gives you this typed array
class and then you have to grab like all
these attributes from the typed array by
calling methods like get drawable get
string get to mention all these lines in
bold are generated as part of your
generated our file so you know in
Android whenever you have XML like
colors and layouts they generate our
Java and that has r dot layout dot
whatever our that color it also has
these custom attributes are not Styla
below us to match xml attribute it goes
in
that are not Java so that's where these
all come from again this code gets kind
of nasty so you just I think the best
way to learn is to study the source of
Android and check out how how they do it
in the stock components all right small
things are really hard to touch okay
what this means is if you have a really
small UI component and the user picks up
your phone they're like why isn't this
thing working makes your app feel broken
it requires far too much precision to
touch that tiny target well you don't
necessarily want to do those make big
goofy DUPLO box
Duplo you know what Duplo blocks are I
can't say it you know they're like the
giant Kitty version of Legos they're
there they look terrible you don't want
big DUPLO UI components so instead what
you do is you make an invisible
component behind the smaller component
and you create something called a touch
delegate so that way it looks small and
awesome but when the user touches it
there's this slop factor they can touch
anywhere in the nearby region it hits
that touch delegate and it makes your UI
feel more responsive the thing that's
kind of nasty about touch delegates
though is the API is a little awkward so
when you create the touch delegate you
have to know the width and height of the
parent view so normally when you're
setting up your layout you do it in the
oncreate method right well the problem
is on create you don't know the
dimensions of your components so the
typical workaround for this is to call
you know like my button dot post you put
something on the event queue and then
post gets processed after layout occurs
and then the dimensions are known so
it's kind of kludgy so all we did is we
have this helper class called views and
we have a static method called expand
touch area and it takes two arguments
takes the big view and the small view
that's another thing when I was working
with a touchdown
get directly it was always confusing to
me which of the two is the delegate is
it the small one or the big one or
whatever so I just made this static
method and I called them big view little
view it makes it really obvious when you
call it so all I do is say big view dot
post-new runnable and then big view set
touch delegate new touch delegate and
the touch delegate is built into the
Android API right and you notice the
first argument as a rectangle sets the
bounds of the larger component and then
the second argument is the small
component so that expands the touch area
makes things easier to touch this is
actually based on a well-documented
theory called fitts's law again if you
search for fitts's law you're gonna be
taken almost directly to a Wikipedia
article that lays it all out in great
detail again it has a bunch of math
behind it it's very well documented
it's basically talking about a speed and
accuracy trade-off so the takeaway is
make targets big and close so fitts's
law says that in a user interface if
something is far away this is usually
not a problem on mobile so much but if
you have a mouse and a pointer and you
have to move your mouse all the way
across the other end of the screen it
makes you slower right
also if targets are really tiny it also
makes you slow because now you have to
be very precise when you tap on it or
when you click on it so if you make
things bigger you can go really fast if
you're on a Mac you have something up
against the top of the screen you can
just fling your mouse up and just
anchors at the top and you can tap and
there's this sloppiness to it and it
makes you super fast so this is called
fitts's law and in the context of mobile
I guess in general it just means use
touch delegate whenever possible to make
your touch areas larger okay so another
screen in our application we've got a
map view this doesn't show it here but
when you first come up to this screen
the map actually animates and moves
around and then zeros in in your
location so we wanted to make the
corners round
like we did before with the photo of the
bearded man but we didn't want to deal
with off-screen bitmaps because that map
is animating and if we had made an
off-screen bitmap for every frame of
animation that would have kind of been
really slow so instead I extended frame
layout call it round corner viewport and
in the dispatch draw method again of
this frame layout you can wrap this
around any child now because a normal
frame layout I save the layer and then I
call canvas clip path this is exactly
what I told you not to do a little while
ago right I said don't use clip path
because you get jagged corners this is
not an exception I call super dispatch
draw so this draws the map view that's
contained with round corners and then I
restore it to the original state but you
definitely get jagged pixelated corners
you can barely see it there it's it's
definitely there though the way we fix
that is we draw round rectangle on top
of the jagged corners and we used a
border line paint which has like a six
pixel width stroke so it's kind of a
hack all we're doing is we're drawing
the round rectangle then we're drawing
on top of it to cover up the nasty
jagged pixels but the end result is it
looks amazing and nobody knows what's
behind the curtain but me and you but
we'll keep it a secret
I don't know if there's any profound
lesson to learn to be learned here but
basically you know sometimes you just
resort to stage magic I guess to you
know wherever it takes to make the UI
work input method options kind of
jumping around here but this is really
important I noticed you know people get
this wrong a lot in Android it's a tiny
easy thing you can do anytime you have
an edit text in your UI you should
always set ime options so there's a
variety of them like action done action
next what that'll do is it'll control
the text on that button on your keyboard
in the lower right hand
corner and it just makes your UI a
little a little faster and easier to
work with
not every phone honors this though I
don't know if they fix this or not but I
think HTC Sense ignores this for action
done so it doesn't turn it into done
they may have fixed that in newer
releases I'm just not sure but that's
why we have the done button in the upper
right corner because we can't guarantee
that it's going to be on the keyboard
the best you can do is set the IME
options as kind of a hint to the
platform to hopefully make it into a
done button other another thing you do
is when when the user taps that done
button all it does is dismiss the
keyboard but what I wanted to do on this
screen is when you tap done I want it to
actually click that do the same thing
that tapping that button does so it
actually dismisses the whole screen so
all you do is you add an editor on
editor action listener to your text view
and then if the action ID is IME action
done then you can call your done click
method so that's all you have to do to
tie into the done button on the keyboard
is add that listener so some other
things you should definitely look into
is using action next so whenever you
have a series of fields that people have
to edit they can just tap the next
button and it moves focus to the next
field in your UI input type is important
also when you set the input type to
phone or person name or cap words that
controls what kind of keyboard appears
so in the case of a phone number you get
the phone keyboard and when you set the
input type to text person name text cap
words as you're typing it capitalizes
the first letter of each word and
there's another option where you can
capitalize every character so we use
that when we're editing the state so you
type CA both are capitalized
automatically so it just speeds people
up a little bit does anyone in the room
thinking of using view flipper yes you
are thinking of using view flipper
awesome
I love view flipper view flipper is a
great
component what if you're not familiar
with it what it is basically is it lets
you show one child at a time so it's not
it's not actually flipping like a 3d
flip or anything like that
instead what it's doing is more like a
card layout in swing where you show one
card of the time but what's great about
via flipper is that lets you animate
between views really easily so we use
that all over the place in square we
want when we want to slide a panel to
the right or left or we want to when we
want to crossfade between views we use
view flipper for that sort of thing
however view flipper has a nasty bug 61
91 so anything prior to honeycomb it
would occasionally crash your
application we ran into this because our
old version our original version of
square way back in 2010 we started
seeing exceptions on the market from
view flipper and what it was when people
would change the orientation of the
phone between landscape and portrait the
view flipper would just occasionally
throw an exception it's not the kind of
thing you're gonna notice during
development because it's very rare but
as you start getting 500 users and then
a thousand and then 20,000 and then
300,000 users
you'll see this exception all the time
so the fix is override basically extend
view flipper so I wrote a class called
safe view flipper and it's on we've got
the URL there but the slides are gonna
be available on the user groups website
and also if you just google safe view
flipper you'll find this all I do is
override the method on detached from
window I call super undie catch and just
wrap it in a try-catch block so when the
superclass occasionally just randomly
throws the illegal argument exception I
catch it call stop flipping and then I
ignore the error now normally you don't
want to ignore errors but this is a
platform bug and there's really nothing
you can do so you just ignore it
and then that way your application
doesn't crash
you're gonna miss I'm not exactly sure
what happens when you call stop flipping
abruptly like this I suspect just the
animation is going to abruptly stop but
it's better than crashing your app okay
so use safe view flipper and set those
animations on it and make sure you I
look great I love the component but it
just has this kind of nasty glitch that
you need to know about this is our card
case app what I'd like to do is kind of
describe how we implemented this now I
kind of faked this out a little bit for
keynote that card in the middle the font
doesn't match exactly this because I
tried to get keynote to show what
happens when you tap a card what happens
when you tap a card it slides up out of
the pocket and then it slides down to
the middle of the screen and the back of
the screen Gray's out but I didn't get
that working in keynote so basically you
just imagine that's happening you tap it
comes out slides down so that was a
trick because how do you get a card to
slide into a pocket in a UI and then
once it's at the top it comes down now
it's on top of everything else okay so
the way we did that was first I override
a method called get child drawing order
okay now the whole thing is just a
custom view that extends view group and
then I just override a series of methods
so get child drawing order all it does
is normally when a view group has a list
of children Android just draws them in
order from 0 1 2 3 4 and whatever get
child draw in order to let you return an
array where the indices are all shuffled
around so when a card is when they're in
the pocket they're drawn into order but
when it slides up and then down we alter
the drawing order so that card is drawn
on top of everything else that's the
first call it technique I don't want to
call it a hack but it's a technique that
we use to implement this screen a second
thing is we override the draw child
method every almost everything else in
this screen is done in the draw child
method
so canvass cliprect is a key example
each one of these cards is a child view
that has its own layout and buttons and
all that so when the the over the
overall panel draws the children right
when draw child is called we override
that we call canvas cliprect to set a
clip boundaries our boundary that goes
right along the the pocket here so the
clip rect is like basically up here so
anything drawn outside of this rectangle
will not be drawn so then we just call
super not draw child it draws this card
and then we call canvas dot restore and
then that's how we get the cards to
slide into the pocket now when we're
animating the card we really don't have
to do anything special we just set an
animation and tell it to go and then
Android automatically keeps redrawing
things and each time draw child is
called we just set the clip rect and
regardless of where the card is it's
clipped right on along that that pocket
boundary we don't have to worry about
you know the jagged pixels and the
corners and all that here because we're
clipping a rectangle it's a straight
line okay so in a lot of respects we
kind of got lucky that the design
happened to be supported by some some
key api's in Android and then the last
thing we do is combination of canvas
translate and canvas rotate if you
notice on this last pocket this has four
cards in it or yeah so the first card is
drawn straight the next one is
translated up a little bit the next one
is translated but also rotated a little
bit and then the next one is rotated the
other direction so it looks like they're
kind of shuffled and kind of jammed in
that last pocket we call this the
overflow pocket so again in the draw
child method we override that we call
canvas translate canvas rotate then we
call super dot draw child and then we
call canvas restore which undoes the
translation and rotation and it makes
the cards look like they're shuffled and
kind of jammed in that that last pocket
okay so that's how we implemented this
so my parting advice for Android
developers in general is first of all do
not crash I haven't really covered any
special techniques so the most important
technique for do not crash is when
you're testing your Android app hold it
sideways and then rotate it and then
rotate it again and then rotate it again
so maybe make like a you know one of the
things we ought to do is make like a
Lego robot that just rotates the phone
all day long that's got to be the number
one cause of exceptions in Android apps
so tests that don't crash the other
thing I think is just details matter I
think just in general one thing that's
been unique for me working at Square as
opposed to my previous life where I was
in corporate America for many years this
is the first time I worked at a company
that's actually driven by design and
it's not like yeah we hired a designer
and he tells us what his great ideas are
and then when we programmers just ignore
it
no the designers run the company so
every time we implement a feature we
have to go to a Design Review and they
sit there and they look at it and they
nitpick it and they throw it back at you
and then when we're done with the design
review before we release we have a jak
review where we go sit down with Jack
Dorsey and he does the exact same thing
and that's really awesome but what has
taught me is that details matter a lot
and I always thought I was good at UI
design and then I just realized no I
sucked I wasn't doing nearly enough you
need to you know use that digital color
meter tool because it lets you zoom in
and look at every little pixel just
obsess over making sure that picked
things aligned if they're off by one
pixel you'll you won't necessarily
consciously notice it but it makes your
you I feel sloppy and kind of broken and
chintzy so just obsess over details like
that and I use little subtle animations
leave plenty of whitespace things like
that and above all I think
I think a lesson is to really do as few
features as possible but to do those few
features really well that is almost
always better than a long feature list
of poorly implemented functionality okay
so you know no matter what your users
are gonna complain they're gonna say
well you don't support feature X well
the worst thing you could do is just
throw in feature X just to shut that
person up because then it's gonna be a
poorly implemented feature X because
you're so busy throwing in features that
you don't have time to make it really
amazing so anyway that's just some some
random advice take it or leave it
we definitely have time for some
questions so the question is how do we
display with how do we deal with
multiple display sizes with okay so so
I've already mentioned our our apps are
just complicated enough where we can't
just use the visual layout tools right
so you know like one of the things on
the round corner I in the the triangle I
try to do things in terms of percentages
of the size when possible one thing I
look for when I'm doing code reviews is
if I see that people are using and we
definitely use DPS like
device-independent pixels all over the
place right but usually I use hard-coded
dimensions as padding between components
if I'm doing a code review and I see
that you've created like the width of
the entire button as like 300 pixels or
180 device-independent pixels that's a
red flag for me that you're probably
doing layout wrong usually you don't
want to use dimensions for large regions
of space in your UI instead you want to
use it for gaps between things instead
you want to really become a master of
linear layout relative layout and
potentially even writing your own custom
layouts from scratch I think the key
there's no magic formula for this other
than you really have to learn the layout
managers well the thing that served me
really well also is almost every UI you
can break it down into one area that's
stretchy and everything else is fit
like you'll have a title bar at the top
that's fixed and then you have a
ListView that fills the remaining space
so kind of the go-to technique for that
is to use a linear layout that's
vertical you set the title bar to be
like rap content and then the rest you
set the height to be equal zero DP which
is a little counterintuitive right you
said to be zero but then you give it a
layout weight of one so it takes a
hundred percent of the remaining space
and just stretches or you could do that
with a relative layout where you attach
it to the top and you attach it to the
bottom give it a height of zero pixels
or whatever but then it just becomes
stretchy because of those attachments so
there's no like silver bullet answer to
how you get it scalable to any screen
size but picking a stretchy area really
helps and just watching for cases where
you're using dimensions for big regions
instead of just for little gaps and
padding I think it's kind of a red flag
you might not be using layout managers
right so I know hopefully that helps a
little bit so any other questions so the
question is have we built a tablet
version of our app and if so did we use
fragments no we have not built a tablet
version of square on Android you know
someone that gets into talking about
what our company plans are and all that
I think I think as I think the Android
team wants to get into the tablet space
to be honest there's a couple things
holding us back so far as one is just
resources we haven't hired enough people
we're just really busy the other thing
is there hasn't been a compelling
Android tablet that has a big enough
market share a low low enough price
point you know to really justify that
for us I mean that equations can be
different for everybody so I I suspect
somewhere down the line we'll get in
that space but we just haven't done it
yet and I know we're not using a lot of
fragments we are starting to move
towards dialogue fragment we are using
the compatibility library there's some
good stuff in there
not regular fragments yet you know
honestly so far I've been able to use
safe view flipper for a lot of the stuff
that fragments can do and it seems
sufficient yeah I'm glad someone noticed
that where did we get the Helvetica font
from so we we did license that font I
don't know where we got it from because
I wasn't it was a guy named Randy
reading he licensed it yes so the way we
got Helvetica is we license the font you
put the font in - aha what's the
directory assets or whatever and you
unfortunately you have to write a custom
view inflator so all of our activities
extend from a common base class called
square activity and in the base class
activity you can create a custom view
inflator and we intercept all view
inflation and if it's a text component
we check for that and then we set the
font on it and it was a huge amount of
work and we still find cases where we've
messed it up and we're it's just very
time-consuming and it's kind of an
amazing hack one of our guys Patrick did
that during hack week he got Helvetica
working on Android you know with with
Ice Cream Sandwich coming out with a new
Roboto font I'm debating you know I
haven't talked to our designers about
this but my thought is we might just go
to Roboto because we'll just get it with
Ice Cream Sandwich but then for all the
older phones will we'll be able to match
our general direction is to try to
evolve towards more of an Ice Cream
Sandwich look and feel on all Android
levels we haven't got there yet but yeah
how many yeah how many devices do we
test against a lot a lot of that is
because we do you know we have the the
reader and we do audio processing so the
way the square reader works is it's
essentially a mag stripe reader and a
resistor and it's basically treated like
a microphone so the audio turns out
be very different on motorola vs. HTC
versus samsung so we have to actually
sit there and plug this in and take
hundreds of test swipes on every phone
and do a lot of regression testing on
that so yeah we've probably got at least
30 to 40 Android devices that we test on
yeah yeah so questions about assets do
we use bitmaps or do we use vectors so
whenever possible we use vector graphics
on Android our app hovers around three
megabytes right now and at one point it
was over four megabytes and you get
people complaining about it they're like
why don't you support move to SD card
well the reason we don't is because when
you take a payment we use background
cues and when you move to an SD card if
the user plugs in that wire and mounts
the the drive all your background
services are instantly killed and then
when you unmount or whatever you're not
restarted automatically until you run
the app so what would happen is people
would lose payments so as a payment
processing company we can't do that so
basically okay I'm getting way off topic
there but basically the answer is we
have to make our app as small as
possible so you really want to whenever
possible avoid large bitmaps and do as
much vector graphics as possible all
right thank you for having me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>