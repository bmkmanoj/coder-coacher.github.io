<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java EE 7 &amp; WebSocket API with Oracle's Arun Gupta | Coder Coacher - Coaching Coders</title><meta content="Java EE 7 &amp; WebSocket API with Oracle's Arun Gupta - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java EE 7 &amp; WebSocket API with Oracle's Arun Gupta</b></h2><h5 class="post__date">2013-01-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QqbuDFIT5To" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Gupta I said and I was
working with son now with Oracle for
about fourteen years so I was part of
the team that started that j2ee
that time it used to be called j2ee the
very first release that we did was in
December of 99 so since then you know I
mean the very first alpha release we
released in March of 99 April of 99
since then I've been with the team in
different roles and capacities you know
in past six years or so I've been doing
primarily technology advocacy means
different things to different people
I'm primarily more on the side of
Technology I'm now selling you know I'm
getting a commission for selling my
product even though I have a product I'm
more about technology so I learned the
technology by holding it by the gut and
I bought a book on Java EE 6 I blogged
pretty excessively this is my blog URL
and I'll show the slides on my blog as
well I got about 30 150 blogs over past
six and a half years tons of technical
content on my blog with that so the way
I'm gonna structure the talk today given
that I have about hour and a half or so
well one hour 25 minutes so I'll cover a
broader overview of the platform of Java
EE 7 in the first 20-25 minutes and the
last 1 hour I will keep it for the
websocket api which is a brand new API
that is getting added to the platform so
we'll talk about what that API gonna
offer how many folks are familiar with
WebSocket concepts ok now that's about
the number I expected so what I'll do is
first 25 minutes about Java EE 7
overview and I'll quickly run through
some of the slides I'll not go through
as I originally planned so you'll see me
skipping some slides then in the next
hour or so I'll give I'll split that
between giving WebSocket primer and
talking about the web socket API that is
coming as part of jsr 356 how many of
you don't know what a jsr is ok very few
of you well jsr is Java specification
request that's
way we create brand-new standards in the
Java land and each jsr is given a unique
number
jsr 356 being the API by the way we were
defining web socket API in the java ee
platform alright let's get started
one thing that Oracle makes us do to put
this legal slide in all our technical
presentations simply ignore it
just ignore it all it means is the dates
here are only indicated they are not
definitive you know you can sue Oracle
or me for saying the dates anyway so
Java EE 6 the platform itself which is
the latest version of the platform that
is in production was released over three
years ago tons of features in there but
before we get into the features itself
you know there are tons of vendors that
have Java EE 6 compliant application
servers you can see pretty much all the
names that are in the Java EE land they
have a compliant application server so
open source offerings commercial
offerings all sorts of plays are in
there in the game so you can have you
can build your application to Java EE
and deploy them on a Java EE compliant
server there's plenty and plenty of
choice that is available in the market
today ok in terms of the features I
won't dig deeper into it but there are
lots of improvements that were made in
the Java EE 6 programming model we
actually did a Java EE 6 hands-on
workshop in the San Francisco Java
meetup I think about a couple of years
ago yeah we did a hands-on workshop for
two consecutive days there were three
and a half hour long sessions it's about
seven hour of hands-on workshop and we
can come back again
you know when Java EE 7 is released
which is a cue to of this year we'll
come back to the Java EE 7 hands-on
workshop giving you a lot more taste of
what's coming in the platform lots of
features in Java EE 6 in general
simplified EJB deployment you know
though typically when you say EJB people
just push back oh no this is bulky heavy
weight single class no deployment
descriptor packaging in water file
that's how would you find a GP just -
just a POJO just an annotation on it
that's about it that's what egb gives
you standards-based types a dependency
injection in the platform that is CDI
or jsr $2.99 that gives you full
dependency injection which is type safe
not string bass unlike other proprietary
frameworks huge improvements in the
JavaServer faces platform itself which
allows you to use faceless as the
templating language let's see what else
several other improvements in Egypt
again I won't get into those but you
know this is sort of my top ten list
what else
web profile you know we talked about
Java EE being heavyweight so we define
something called as Java EE web profile
which is a lightweight version of Java
EE and so GlassFish which is a reference
implementation of Java EE comes in two
flavors there's a web profile download
and there's a full platform download the
web profile download is 30 megabytes in
those 30 megabytes you get a subset of
the specification of the platform with
which you can write a modern web
application so you all the components
like you know servlets EJB JPA all those
components you know typically your
database middle tier transactions web
services all those components are part
of that 30 megabyte download tested and
supported for you by all of these
vendors now with Java EE 7 the earlier
path that we took was are we gonna have
we're gonna provide a standards-based
pass platform no but that means you will
be able to write applications using Java
EE 7 api's and then you can deploy it on
any Java EE 7 compliant container that
would run in the cloud so kind of
providing through cloud portability
using Java EE but then we realize you
know after talking to our customers
partners vendors that is too early
there's still a lot of standardization
that needs to happen in the cloud world
essentially more importantly innovation
that needs to happen in the cloud world
so we kind of pulled back from that
based upon the feedback from the
community and we said ok you know what
the focus of Java EE 7 is going to be
productivity and html5 and how are we
going to give you those well in terms of
HTML 5 you know we are providing a
standard API to do WebSockets JSON API
you know html5 data at
we're gonna support those in terms of
productivity jsr is like JMS I've been
going through major overhaul allowing
you to write very simplified code and I
time permitted I may be able to show you
a small sample of that so it shows
exactly how 18 lines of code just to
send a message could be easily crunched
to just a single line of code basically
leveraging you know dependency injection
and the language features that are
already available in the platform there
is no support that is really required to
be done as okay the question is when you
say html5 are you supporting css3 as
well there is no additional that needs
to be done from the platform for css3
support that comes as part of the
browser itself there's nothing that
needs to be done in the platform per se
but when I go back here when I say html5
forms what it means is mapping those
html5 forms natively to our JSF to form
and kind of defining a correlation
between those two now this is what we
call as a pancake diagram for Java EE 7
now you there are different ways you can
interpret it but the basic idea is
they're different there are tons of
specifications in the Java EE 7 platform
and the color legend you can see at the
bottom for example JMS jax-rs and
expression languages those three are
going through major updates as part of
the platform and if maybe I can show
some quick updates on that as well
several other specifications are going
through minor update and the one on the
far right are the brand new additions to
the platform itself so think about
building a standard based web socket
driven application and I'll show you why
it is important to build a
standards-based application think about
instead of depend relying upon or dot
JSON or a third-party jisan library that
being available as part of the platform
itself wherein you don't need to bundle
the third-party JSON library where you
know portability is guaranteed you know
across your different application
servers similarly Java caching API that
will give you a simple key value pair
for scaling your applications very
easily
we also have batch applications that is
coming as part of the Java EE 7 so the
point being there are lots of existing
content that is being revamped for
productivity and html5 and same thing
same philosophy with the new set of
specifications that are coming in well
today we go to click on Java API for
WebSocket which is jsr 3 57 56 so we'll
double click on that and provide a lot
more details on that now in terms of
jax-rs 2.0 which is sort of the big
update that is coming as part of Java EE
7 platform tons of new features that are
getting added now if you realize how
many folks are using jax-rs today ok so
a few well jax-rs is a standard way to
build a restful web service and
effectively in jax-rs first version what
you could do is take a POJO
put an annotation on it and say I want
to publish this Pocho as a rest endpoint
everything else was done by the jax-rs
runtime so then you could say oh what am
i marshalling on marshaling concepts you
know what are my different sub resources
or what are my HTTP GET put posts delete
methods how do they map to my resource
methods all of that was defined by
jax-rs in a standard way now if you
realize it was all server centric so one
of the new features that we're adding as
part of jax-rs 2 is to do client-side
API what that means is using similar
concepts you can invoke a rest endpoint
using a client API again giving you
portable applications effectively let's
see a quick sample of that so today if
you want to invoke a rest endpoint now
let's say you want to use your only
option is either you use a proprietary
API or you use the one that is bundled
as part of JDK so you have to really
create your new URL HTTP URL connection
set the metadata and go through this
nasty loop it's kind of hard to
understand but you have to go through
that loop with jax-rs 2.0 you can just
do a clean API
all you say is I want to create a new
client with the client I want to set the
target this is the URI that I want to
invoke I
resolve the template that this is my
variable part of the URI I wanna set up
a query parameter which is question mark
name equals value I'm gonna set those
I'm gonna build the request I'm gonna do
HTTP GET and I know that I'm gonna get a
string response back so very clean very
simple API I'm not digging into it but
that's one of the areas where we could
talk a lot more extensively on how we
can use it so for example here instead
of get you can say put post delete and
all of those different verbs are
available you could start getting fancy
where you could say you could define
what type of data payload is going over
the wire you could even start putting
your HTTP except header
oh I expect you know application slash
JSON mime type coming back as part of
the response so you can start getting
fancy with all those things filters and
entity interceptors a new concept that
we're adding as part of jax-rs itself
that allows you to have request
processing hooks or extensions
effectively which you can do for request
and response typical way is you want to
do logging or any cross-cutting concerns
or you want to do auditing or security
for a jax-rs request now there are
several implementations of jax-rs
which were actually having those
features in there already this is again
a standard way again promising the
portability promise to you so the idea
is you could write a standard filter'
which is primarily looking at the HTTP
headers or you could say I want to take
start looking at the body and maybe
start modifying the body itself so for
example if you know that the requests
coming from the client side is gzip
encoded you can dynamically plug-in gzip
intercept interceptor for example which
would know exactly how to read the
request or if you know the client can
understand you know gzip encoded content
then it can dynamically put it on the
server side gzip response handler which
would allow you to gzip your response
dynamically so your business logic
doesn't change but you're cross-cutting
concerns just simply sit right there as
an interceptor and this is completely
dynamic by the way so the question is
using this in Jersey already today what
about backwards-compatibility Jersey is
the reference implementation of jax-rs
so now jax-rs of course the lot of
feedback came from Jersey per se that
how these features need to be built into
the platform but the features that
you're using for Jersey they continue to
be our eye specific they may be
supported some of them may be supported
in Jersey 2.0 but the the definite
guidance is to move towards standard API
one of the features little nifty
features that we're adding is part of
jax-rs is how you can do server-side
content negotiation well today in the
content negotiation what you what that
means is the client is saying oh you
know what I'm sending a request
I want a response back now what kind of
response do I want back I'm a browser so
I want HTML response back or I'm an
application so I want JSON response back
so you can actually define that by using
HTTP accept header now if the request
goes to a server and server don't care
you know what is the response goes back
it could send anything now with this
what you're doing is for example here
you're defining if the client does not
say what response should come back the
server is defining a priority he's
saying application slash JSON by default
the priority is one so saying by default
I'm going to send JSON payload and if
the client says text XML explicitly I'm
going to honor that as well but by
default that's a lower priority so small
lifti features but hopefully we'll have
a bigger detailed talk on jax-rs by
itself
now JMS JMS was revamped or last revised
in December of 2003 long back long back
so well we're 2013 so almost 10 years
ago effectively by that time DDK 1.4 was
not released so there are lot of changes
that have been made in the Java platform
itself and the goal of JMS 2 is really
to catch up with all those features or
the improvements that have been made in
the Java platform and incorporate those
features as
part of JMS 2.0 API so if I were to
quickly run you through this code now
this is all the boilerplate code that
you need to write as part of just
sending a simple message and what are
the problems with this code if you take
a look at it there is lots of
boilerplate code over here your goal is
to send a text message to a message
producer but all of this boilerplate
code Summa needs to be written there are
tons of api is that needs to be honored
because that's how JMS is defined you
know you have to do the exception
handling you have to close the resources
you have to inject the resources you
have to create these resources so
there's tons of stuff that is happening
just to send a simple message now see
how that changes as part of Java EE 7
this is the updated code as part of Java
EE 7 and I didn't walk through all the
slides but the idea is we're just using
CDI first of all we are saying just
inject a JMS context JMS context will
have the encapsulation of the existing
api's that are available like producer
ends consumer then I'm gonna say ok
inject my queue here you know on this of
course this is your specific u so you
gotta be defined this by itself and then
in terms of send message all you're
saying is from the JMS context that is
injected for you create the producer
send to this demo queue and the payload
no boilerplate very clean api so
effectively there is no exception
handling that's happening here
there is no resource handling that needs
to happen that is because JDK 7 defines
how if a resource goes out of scope it
is automatically collected so
functionality that like that now have
been used or incorporated into the API
to make it much simpler and easier to
use now that doesn't mean that the older
API is going away because it has been
into existence and usage for such a long
time this is a new API that we are
defining so that means your JMS 1.1
programs will continue to work as is but
the idea again is to kind of start
migrating towards JMS 2.0 yes sir
so here what you're doing effectively is
you're just creating a JMS context in
the terms of JMS context you're creating
a producer now in the JMS context what
I'm not specifying here is what is my
cue or what is my JMS connection factory
that I'm using effectively now depending
upon how you have configured your JMS
connection factory it might be creating
new producers or new consumers every
time sorry the question was what is the
performance impact of this code up over
the previous code but there are dials
and knobs that are available by which
you can control that
now Java API for JSON processing that's
the brand new API that we're adding as
part of the Java EE 7 platform this API
will allow you to parse or generate a
JSON object using standard API and just
like Jax P or Java API for xml
processing and Jax b or java api for xml
binding there is a Dom model and there
is a data binding model that is
available here effectively
so actually in Jax P for example there
is a streaming API in a Dom API so in
the first version what we are defining
is a streaming API and a Dom API for
JSON subsequently we will have J's on
binding API we're on a Java object you
could specify annotation and it will
assume defaults and automatically bind
that POJO to json or vice-versa but for
now it's only streaming and Dom API in
terms of streaming API so think about
this is how your json fragment looks
like you could if you're familiar with
jax p how streaming really works so all
you could do here is i want to listen to
the event so the first event is fired is
start object or key name or key value
string or value number so on so forth
you could actually act upon those events
as they're being fired and do the
relevant thing a short code that
basically says you know this is my
entire fragment on the i get from the
parser I get an iterator I just do next
next next and then eventually these are
the events that are being fired on each
particular event big validation this was
a new specification that was added as
part of the Java EE 6 platform now the
beauty of bean validation is it allows
you to specify validation constraints on
your beams so think about a POJO which
is what you're using or a JPA entity for
example which is what you're using to
persist to the database now or think
about backing beam for a JSF page where
you're capturing results from a web page
now you could do the validation in the
JavaScript you could do the validation
when you're capturing the data or before
you are persisting the data to the
database
the beauty of beam validation is on
being itself you can define the
validation constraint and the way the
integration is defined across the
platform is a beam validator would
automatically kick in and would try to
validate whatever constraints you have
defined for example let's say you have a
JP entity in the entity you said I don't
want the name to be more than 30
characters now when you are trying to
persist the JP entity to the database it
will say oh let me make sure the
validation constraints specified on the
beam are actually being honored if not
the validator will kick in and it will
throw a validation constraint exception
now either you do that in your
application or you rely upon the Java EE
6 runtime to do the validation for you
if you don't do it it goes to the
database and it throws an error back as
well so the idea is the cost you know if
you don't do it in your application or
the beam validation doesn't do it for
you it anyway goes to the database and
the error comes back to you so but this
certainly makes it much easy something
that they're doing as part of being
validation 1.1 that's coming in the Java
EE 7 platform is how you can start
putting those constraints on your simple
methods so for example let's say you're
invoking them you have a POJO in which
you have a place order method and the
place order method you want to make sure
that if the product name that is being
passed is to be used to be not now
instead of saying at not now in your
application code which is in the place
order method you could start checking Oh
if product name equals null then throw
some exception or some things like that
or you could say if the integer quantity
is not 10 then throw an error back here
it improves the semantics readability of
your code just by putting those
annotations effectively what you're
saying is oh I don't want this to be now
I don't want this to be you know I want
this to be a not null but the maximum
value should be 10 the one at the bottom
for example says if I'm returning a date
from the existing function I want it to
be in future based upon the current JVM
timestamp so it's getting fancier and
fancier effectively improving the
semantics readability as I said earlier
of your code and allowing you to focus
on your core competency which is writing
the business project itself
this is jsr 303
this is GSL 303 so bean validation 1.0
was js is it an extension of jsr 303 so
jsr 303 was bean validation this has
been validation 1.1 the next version of
it exactly now one of the points that I
want to highlight here is these
constraints for example not null max
those are built-in but you can define
your custom constraint here example for
example here I'm using add customer I
want this customer to be of a specific
type and I have my own constraints
around it so instead of putting you know
at not null at max add this add that I
can put all the constraints together in
my simple class again it's a separation
of concerns I put my all my constraints
in a separate class and I put that class
as a constraint here on the customer
itself much simpler new functionality
that is getting added to the Java EE 7
platform is how you can write a simple
batch application I won't dig into the
details here but just to kind of give
you a overall concept there is a job
repository where which is where all the
jobs are stored which is where all the
metadata is stored a job operator can
look at the job repository prettier the
job a job effectively consists of one is
to star so multiple steps now a step as
they have defined is has two different
mechanisms it could be either a Bachelet
which is sort of a one-time job that you
want to fire like upload a file or do
something or more typical a more typical
and recommended design pattern is
chunked processing which is where you
are doing read your writer read your
processor and writer so let's talk more
about that a little bit so this is the
chunked and the Bachelet processing but
a more typical design pattern is chunk
step so what that means is effectively
you are reading an item and processing
an item you're reading an item
processing an item and you're probably
doing that n number of times and after
you have done that n number of times
then you're saying oh I'm gonna now go
right the items right the items
literally does not mean writing the
items it could be Oh for example here
I'm gonna calculate the balance of the
account and I'm done read the account
calculate the balance read the account
calculate the balance and I'm gonna do
that for ten of those accounts together
and then I define what my chunks trap is
and once I've defined my chunk step
after those ten accounts have been read
and processed now I'm gonna shoot an
email to all those you know hey your
account statement is ready for example
these back steps could be scheduled
could be ad hoc and all kind of things
and we're trying to figure out while
we're working on exactly how this batch
API could work very well for example
with egb schedules you know you have an
EJB cron based job how would you trigger
it automatically from that so that
integration is still being defined the
central point where and how the job is
being fired is really defined using job
XML so if you guys have used spring
batch this concept is actually taken
from there for example so here what
we're saying is oh I have a job this is
the ID my job has two steps here this
step the ID is in it it's a chunk type
this is my reader writer processor I can
define the sequencing if fail happens do
this and then this is my Bachelet which
is saying okay process an email one-time
job
so the job XML itself is pretty
comprehensive but the concept is
actually being borrowed from spring
batch if I were to correlate the job XML
with the actual pojos which is how my
application is being structured so I
have in my chunk for example account
Reader account processor and I email
writer I would define a POJO
which would say oh this is my well I
have the annotation read item here but I
will define a POJO which will say item
reader on the class in the class the
moment I say item reader it has to
implement certain methods and then one
of the methods is called as read item
which is saying okay I'm going to read
an account this is where possibly you're
using JPA
talking to the database and getting a
pound back so you see this is an account
that is coming back to you here now then
you are saying okay what is my account
processor then you're saying you're
defining a POJO which is account
processor in which you have ADD process
item annotation on a particular method
which is where you are probably
calculating the balance and finally you
have write items which is where you are
processing the list of account while
you're not passing is automatically
getting passed by the concept that
you've defined a chunk over here and
this is your using Java mail to send
email so purely within using Java EE
standard concepts you can do all of
these batch processing concepts very
easily yeah the question is is that are
the jobs stored somewhere so the job
repository is where all the jobs and the
metadata of the jobs are stored now if
the container crashes are the jobs it
assumed after that that is still a TVD
yeah now as I said only job xml is
borrowed from spring batch that's not
the best batch implementation though job
xml yes now Java temporary cash question
you could have multiple pojos but a
chunk would define only one reader
writer and processor so you cannot have
multiple of those you can have multiple
of those methods but then they would be
corresponding to multiple chunks
effectively so for example in my wor
file what I could do is in Mara F I
could have multiple batch dot XML job
burned out XML job two dot XML job three
dot XML each of those jobs could be end
of the day job or end of the month job
things like that or mid night job and
then those jobs are automatically
scheduled maybe say using a JB's at
schedule annotation in the job so you
will have a job operator dot start
method over there which is referring to
that job dot XML in that job XML you
have multiple video writers and
processors which are corresponding to
multiple pojos which have multiple
methods so that's our the structure of
how the
back Wharf I will be fine question no
there is the Java API is there a Java
API for batch applications yes I prefer
the annotation route much simpler but
you can go the interface route as well
so you could say extends or implements
and all that concepts are able oh no
instead of gluing them together in XML
can we do them together using Java
no there is no Java API as I understand
the first version of batch only has the
job XML as sort of the primary entry
point would that be useful well and I
raise that point as well to the spec
leader as well I think about couple of
weeks ago my and the reason I got back
was because if you take a look at the
job XML specification it's pretty
complex you can do parallel jobs
serialized jobs you can define
dependency on the jobs so it's a pretty
complex DSL by itself capturing all of
that in the java language would not be
easy as a matter of fact we have already
kind of parked that issue we're not
gonna deal with that in batch 1.0 but
probably in a future version
this is a standard concurrence sorry
simple standard caching API that we are
defining as part of Java EE 7 we'll dig
more into it but we have this concept of
a cache manager which has multiple
caches caches as multiple entries is
effectively a key value pair so we are
defining how that semantics is going to
work and again there is an annotation
driven approach over here or interface
driven approach both approaches are
available here if I were to show you a
simple sample so for example what you
would do is you would obtain a simple
cache manager's we say cache manager dot
get well first of all you get a cache
manager by using services mechanism or
automatically identified from the cache
manager you get a cache so what is my
test cache for example and then you know
you can start playing around with it you
know you can start configuring the cache
how the cache is going to look like what
the values are gonna go in this is how
you put a value in the cache so you are
just doing a simple get me the cash give
me the integer cache not put ok this is
how you can get a value from the cache
or remove from the cache and now let's
take a look at the annotation driven
examples so let's say I have a POJO
which is where I've already implemented
for example a blog manager how would I J
cache enable it for example well all you
do is you start putting ad cache put
annotation where the entry is being
created you just define what the cache
name is gonna look like and the J cache
runtime will automatically kick in and
create the cache for you every time
you're creating a title with a blog you
just say what is my key what is my value
you start sprinkling your annotation and
those values are automatically stored
for you in the cache it's a key value
pair there are both the distributed as a
distributed or local they're both the
versions that are available as part of
jsr 107 there are several
implementations that are being planned
there are six or seven implementations
that are being planned the local version
is required as part of jr7 distributed
is optional so we expect some
implementations will offer both some
will
only local now similarly the way we have
create an entry we could say get blog
entry then you can say just add cash
result from this cash this is my key
just give me the value or I want to get
cashed entry only so you could pass a
random or in this case by default this
is only one parameter that is the key in
this case if I'm saying a specific
method then I cut past a random art and
I can even tag it what my key is so
those annotations and convenience are
all there
similarly I can say a remove blog entry
and remove all blogs their corresponding
annotations for that so cache enabling
an existing POJO is pretty
straightforward
one of the new features that is being
added to JPA 2.1 or java persistence api
2.1 is how you can take JP energy and
generate schema from it now if you
realize java persistence api works on a
pluggable persistence provider mechanism
so eclipse link or hibernate or
persistence providers now most of those
persistence provider define a mechanism
or if your JP entity says at entity add
column there's this this we canÃ¡--
generate a DDL or a DML from that this
is effectively standardizing that so you
could say you know what if my JP a or my
entity is gonna look like this then I
could specify certain properties in
persistent or XML and that would
basically allow me to generate my DDL
and where is going to generate is it
gonna be just in to the database or I'm
gonna generate actual SQL script all
those options are available to you
one of the new features that we're
adding as part of servlet 3.1 which is
again the update for servlet 3.0 is how
you can do non-blocking i/o very
standard methodology in the sense that
while today if you have to do I owe or
in a traditional way what you would do
is in a do get method you say I'm
getting the request from the input
stream
I'm gonna read keep reading it until it
says okay I'm done so this is blocked
effectively you're blocked on reading
the input until the stream is closed
from the other side so the workaround is
you know which is which is a very
standard way we're defining callback
handlers here take it
minor Apache minor I don't know what a
patch of my well I know what a patch of
mine is but I don't know what to do
possibly yeah it's a very standard
approach though yeah so here for example
what I'm saying is on the input stream
I'm just sending a read listener what is
my new read listener and then my read
listener actually has on date available
method so whenever you know data is
available it just called that read
listener its runs in a separate thread
and it says okay input is ready I'm
gonna keep reading it till the data is
available to me and I just loop through
it so it's very standard you know very
stereotyped concept this is yet another
API that is getting added new to the
platform is I know it's jsr 236 it's
kind of old working been working with it
for a long time but finally getting
included as part of the platform one of
the limitations so to say people feel
for the Java EE platform is they cannot
create new threads you know that's not
required or permitted by the
specification although some of the
containers do permit it now with this
you can actually have managed executor
threads the idea is you can ask the
container to create threads for you and
the container will manage it for you so
that's sort of for this concurrency
utilities for Java EE will provide you
the idea is you know you can define in
your jndi resource references oh this is
my managed executor service what is my
reference type and this is how where I
one gonna have a my batch executor so
you you inject a batch executor
effectively using J and you I reference
then from that batch executed you can
say start spinning up new threads for me
so here for example I'm saying okay
inject my batch executor which is my
manage executor service on the executor
I can say submit but they were here you
can also define how many threads you
want to be available in the pool so all
those parameters are configurable
one of the improvements that we're doing
as part of the Prada Java II platform is
how we are taking for example EJB has
this core concept of each method is
inherently transactional for example
unless you explicitly call it that okay
it's not transactional now that concept
is relevant to the broader platform as
well so what we're saying is let's take
that concept out of EJB and make it much
more widely applicable so for example
this is our transactional annotation
that could be applied to a pooja now
what that means is this the semantics
are defined by eg B or the semantics are
defined by JTA which is draw our
transaction API will revving that part
of them as part of the platform as well
JTA will define what add transactional
will do but you can actually put it on
any POJO and the way it works is because
Java EE 7 has context and dependency
injection which by the way introduces
you know your transactional interceptors
over there or at least interceptors it's
basically leveraging those concepts for
making it you know seamless for you the
idea is it need not be an EJB if it has
to be transactional you can make your
pojos as inherently transactional by
just putting this annotation if you put
it on a method the method becomes
transactional you put it in a class all
the methods in that class become
transactional
all right now most of the API is that I
talked about other than say concurrency
utilities badge and J cache those are
the three big ones that are not there as
part of download today but most of the
api's are already integrated and
implemented as part of GlassFish 4 so
you can download the latest promoted
build here build 70 was done on this
January 3rd
which is what I'm running on my machine
today and I'm going to show you some
sample code with WebSocket and so all
those api's are integrated you can try
it you can play with it you can provide
feedback on that and I think that's a
good segue what's something I'm gonna
talk about how many of you are familiar
with the adapter jsr effort one two
three four okay excellent good audience
then and I can explain it well adapter
jsr was an effort that was originally
started by a london java group they
started looking at different GS ours in
terms of oh let's take a look at JMS 2.0
and you know as a jog we're gonna meet
together and have a hack day and we're
gonna download the specification we're
gonna read the Javadoc see if it makes
sense see if there are any typos we're
gonna build any application using JMS
2.0 things like that now
what they did is they sort of formalize
the program where other drugs could
actually take that same concept and they
say are we gonna adopt a jsr not just a
jsr you could adopt a bunch of j source
so now what happens is Java EE 7 is the
one Java EE 7 J SARS or the ones that
are most active today so as part of that
we formally launched a Java EE 7
adapter.js or program so for example
somebody in San Francisco Java user
group or in this meetup for example
could say oh you know what I really care
about JSON API being done right so I'm
gonna build an application or I have a
use case I'm gonna use that API to
implement my use case and see if that
API fulfills my need or I'm going to
talk about web socket API now and you
feel excited about the web socket API so
I'm gonna adopt that jsr as part of the
web sock of the San Francisco Java
Meetup and I'm going to
playing with the API but that could mean
is you can download the spec look at the
Javadoc
build an application you can even start
contributing to the implementation or
you can even provide a proposal to the
specification oh I know how web socket
and servlet and EJB should work with
each other and I think this this is
critical enough that it should be
specified in the specification so there
are whole tons of activities that you
can do as part of adopt a JSON effort it
could be as simple as just understanding
the specification talking about it with
your friends and your company giving a
presentation at the Meetup could be
writing a proposal to the specification
could be implementing it talking at a
conference any sort of activity can be
done as part of add a purchase or effort
so how do you get started that's the
typical question people ask me okay fine
I'm Sol I want to get started so what we
did is on GlassFish dot org slash
adopter jsr we work with different
specification leads and we said okay
what are the areas where you are looking
feedback for so on this URL I have this
list of specifications so the ones that
are in black they don't have a specific
list so there we have general areas of
feedback that are recommended but
otherwise for most of the api's you have
specific areas where the specification
leads are looking for feedback now you
may wonder who is doing adopt a GSR so
today there are 15 Java user groups
around the world that are actually doing
adaptive jsr so for example this is
Hyderabad Java user group what they're
doing is they are building an
application using different Java EE 7
component and literally there was this
one girl in Hyderabad I met her at
JavaOne she reached out to me Arun I
care about JPA
and I wanna adopt a jsr the jug leaders
are not responding so I went from the
other side I know the jug leaders that
gonna cook them in I connected the dots
and now they're working together to
build an application using Java EE 7
they're actually organizing hack days
for example B jug which is Belgium jug
these are the guys who organized a box
for example they have adopted jsr 356
the websocket api so what they're doing
is they have actually given
contributions to the are I already you
know they're actively participating in
the RI list not only that but they're
already planning to organize hack day so
they're gonna build a tic-tac-toe kind
of an application using WebSocket so
Java they are actively contributing for
example Java server face is 2.2 they
have contributed a JSF application
already you know in earlier days before
adopted jsr and they're continuing to
enhance those incorporate JSF 2.2
features London Java community these
guys are very big big big on GMS they've
already a great organized JMS hack days
I believe it's Cologne jug that have
started contributing to J's on
performance issues so there's a tons of
activity that you could do here you know
it would be great if one if you could
take a leadership and I'm local here so
I'm happy to kind of do a hangout with
you or you know come back again kind of
organize a hack day oh let me give you a
quick overview of all the Java EE 7
technologies help you define the
application and then you run by yourself
you know I'm here to help it facilitate
the key point being Java EE 7 is
scheduled to go final in q2 2013 so all
this work needs to happen pretty much
now so you know somebody needs to kind
of while driving back to your home the
world needs to light up and say I'm
gonna do it send me an email or send
Sasha an email and I'm happy to kind of
coordinate that effort with you guys
let's switch the slides
let's talk about HTTP HTTP has served us
really well so far the purpose of it is
really well you know and all the web is
resting on it but effectively it's half
duplex in the sense you know you send a
request
no client can send a request and then
once the request is received that's when
the response comes back is chatty
it's very verbose just to send a simple
hello world you have to send like about
two kilobytes of data is exchanged
between client and server just look at
the amount of HTTP headers bare minimum
that is required so it's very chatty so
it's not really effective for real-time
communication that you want to do on the
web at least so it doesn't scale for
that so people started hacking around
HTTP server push comet different
technologies that are coming along as
part of it but again those stay to be
hacked so there's no standard mechanism
up until now so that's exactly where
WebSocket come to the rescue
now originally WebSocket was proposed as
part of html5 standard but html5 itself
is not going to be a standard until 2014
until next year so what they did is they
pulled WebSocket out of it and they said
okay it's going to be a IETF document
which is a fully well-known body and a
standard basically HTTP is a IETF
document effectively so there are two
things that are defined as part of
WebSocket first is the wire protocol as
in how the wire protocol is going to
look like this is still a concept of a
client and a server so when the client
and the server are talking how does the
handshake happen how does the on the
wire message look like how do we get a
way of the chattiness of HTTP and things
like that and then the second part to
WebSocket is the JavaScript API you know
if we're talking about web JavaScript
being the lingua franca of the web we're
defining how a JavaScript API is going
to look like so JavaScript API is
defined by w3c it's in candidate
recommendation which is a fairly
advanced stage the next one is pretty
much recommendation and IETF is already
a defined protocol so just Google for
RFC 64
45 and that tells you exactly it's a
fairly well written document it's not
one of those geeky ones so you can
easily read it and still understand it
so what's the basic idea no well let's
slip the spider I think these two more
details in there but the basic idea
really is you know you have a client and
a server
okay now client and a server they are
talking HTTP on HTTP you can actually
define the upgrade mechanism which is
defined as part of the HTTP
specification itself that upgrade
mechanism was defined say you want to
upgrade from one version of HTTP to a
newer version of HTTP or from HTTP to
secure HTTP and things like that so if
you're doing HTTP communication already
WebSocket defines how you can use that
upgrade mechanism to upgrade from HTTP
to WebSocket and that is called as
handshake so there's a client and a
server client sends a handshake request
and the server understands the request
and says okay I'm talking WebSocket
handshake response or if it's not
talking then there's no handshake
response effectively you break the
communication right there
how does the handshake request look like
so let's look at these headers now these
are the bunch of HTTP headers that go as
part of the handshake request you're
saying I want to do a GATT which is a
standard HTTP which is going to this URL
using HTTP version 1.1 you've got a host
these two are the critical headers that
go as part of the request so you say I'm
requesting an upgrade to WebSocket and
it's connection type upgrade and then
there are a whole bunch of you know
metadata that goes along with it you
know origin security etc not really
relevant now if that request goes to
endpoint that understands or knows how
to talk back WebSocket it responds back
like this oh yeah I got the request I
know you are trying to do a connection
upgrade upgrade to WebSocket so I am
switching protocols now I'm switching
from HTTP to WebSocket this is a very
important line that you must see in the
protocol response back response coming
back and that is you know it responds
back with the metadata as well so that's
sort of the hand
request/response now remember this runs
on top of existing HTTP so you make the
initial connection using HTTP you send a
request and the connection gets upgraded
to WebSocket none of the HTTP semantics
are valid after that on that connection
so once the handshake request and
response let me go through this flow
then we'll take questions now once the
handshake
request and response is done that means
my client and server are connected now
the important part to realize is the
client is only client from the
perspective that it is initiating the
connection and server is only server
from the perspective it is receiving the
connection once the two are connected
they're both peers they're both equally
capable of sending as many messages as
many times and terminating the
connection that's why it's full duplex
client and server can send any messages
any time can initiate that termination
any point of time we'll get to that what
is the role of browsers to it so we'll
get to that so now once the connection
is established
now imagine even though I'm using the
words client and server they're
effectively peers
so once the peers are established there
is a callback handlers that are on both
the sites client and server open open so
you can do some processing over there
now client can start sending messages 1
2 3 as many as it weren't server can
send as many messages there is no
predefined that--okay client has sent a
request the response has to come back
client could send as many requests is
these are unidirectional request the
user unidirectional messages so to say
the client can send or this peer-to-peer
on the left side say can send as many
requests and similarly the peer on the
right side can send as many requests
there may be an error no I don't like
the data format for some reason and
finally one of them if the client or
server could initiate the termination in
which case the connection is terminated
and all that state is lost
so that's sort of the flow basically you
would see now remember the number of
messages on the client need not equate
the number of responses on the server so
effectively you get a very very low
level protocol here where client can
send as many messages server can send as
many messages to each other you build
your message exchange patterns on top of
that now whether is request response
whether it is one request five response
you define that and there are
well-defined mechanisms on how you can
do that within the WebSocket that's the
concept of sub protocols will not cover
that today but that's how you can define
it and there are connection negotiation
mechanisms that are defined on how those
sub protocols kick in now you are asking
the question above what is the role of
browsers in here
well the browser's we said javascript is
the lingua franca now effectively if
you're writing a web application that is
talking to a WebSocket endpoint so
you're using JavaScript API
now this is the JavaScript API which is
a candidate recommendation that is
defined by w3c and if you take a look at
it it says this is a web socket API this
is a URL where you are connecting to
there are some steady steady state ready
state variables these are my callback
handlers so for example if the WebSocket
connection is open then call this if
there's an error call this you know
these are my extension this is my
protocol here I can actually pass my sub
protocols that I care about which we
talked about briefly and these are the
methods by which I send a request from
one peer the other peer and I can here I
can send for example string data or I
could send binary data now JavaScript
has native binary arrays and you can use
all of that my browser compatibility
what we really mean is does the browser
you can't take this JavaScript API
bundle it as part of application so by
browser compatibility what we mean is is
this API supported natively in the
browser that's the key part
it's a very detail-oriented protocol in
the sense it exactly defines how your
data frame needs to look like well if I
you send a WebSocket message it goes as
a frame now it defines exactly how the
framing should look like and you can see
by detail I really mean is it really get
down to you know 0s bit first bit second
bit these are bits so really in terms of
chattiness where we're talking about two
kilobytes of messages being exchanged or
two kilobytes worth of data being
exchanged between client and server here
we are really talking about a 2 byte 2
byte of overhead for each message
exchange that is basically the framing
byte everything after that is data now
of course the connection negotiation of
course is little bit chatty because
that's relying upon HTTP but after that
it works pretty clean much much less
verbose talking about a little bit more
about browser so you can go to this
website call as can I use comm slash
through WebSockets let me ask a trick
question how many of you use ie Internet
Explorer as your primary browser one
hand and the reason I ask that is this
chart was updated in literally December
23rd of last year up until then
IE did not had the WebSocket support now
they finally have say for example IE 9
is your primary browser do not expect
WebSocket from it it would just not work
as a matter of fact Firefox Chrome
Safari Opera they have had this support
for a while of course Firefox and Chrome
have it have had it for the longest time
effectively now one thing that I fail to
understand is why Android Browser
doesn't have that support I don't know
but if you download Chrome on your
Android phone then it has that support
just the native Android browser doesn't
have it
ie download for what I I don't use ie so
I don't know what's happening in the
Gila hand I'm gonna Mac so I'm
thankfully away from that virus now we
saw there is a JavaScript API for
building the WebSocket applications what
happens on the server side so on the
server side there are a whole bunch of
frameworks that are available by which
you can build a WebSocket application
and these are some of them this is only
some of them and that's exactly the
problem that the Java API for WebSocket
is trying to solve so jsr 356 is going
to define a standard API for building
WebSocket application now as part of w3c
we have defined how the JavaScript API
is going to look like 356 or JSON 356
will also define how a Java API for that
would look like so it's defining not
only the server programming model but
the client programming model as well
Tyra's is the reference implementation
name it is already integrated well into
GlassFish 4 and i'll show you some demos
on how the code would look like for that
script through that yeah
so there are api for client and
endpoints we'll cover these a little bit
more WebSocket has this concept of
extensions you know which is sort of
defined in the protocol itself now as I
said WebSocket is a very low-level
protocol and it's text and binary
supported both what if you want to do
multiplexing on that you wanna kind of
take it a notch above that so
multiplexing you know that's a tip or
compression for example on your web
socket protocol that is being supported
using extensions in WebSocket so now the
WebSocket protocol defines that but
that's still in a very early stage there
are some experimental work going on
around that but that's not gonna be
supported as part of the Java API and
that's the reason that was originally in
the scope but we cannot ruled it out
that is too aggressive to support that
specifically given the state of
extensions in
WebSocket protocol yeah
so one of the security issues around
WebSockets specifically with denial of
service now just like you know your
standard HTTP that can happen here as
well
now and I also talked more about that
once you establish a connection you can
establish a connection using plain WS :
protocol so instead of HTTP : protocol
you make connection using WS protocol WS
: protocol or you can make it using WS s
which is secure so you can get away with
that that ki handling and all that is
not defined as part of the protocol so
that is done exactly the way HTTP is
doing it so it's exactly leveraging that
those exact concepts and extending them
to WebSocket
is there a way by which we can switch
standard java servlets to WebSocket
model no that's not that's that's not
how we expect it to work and hopefully I
mean I'll jump into the code soon and
then you'll get a better understanding
of how we expect it to work just a
warning that's my legal disclaimer by
the way so this is how I define my
WebSocket endpoint for example so just
read the code that is in the black for
example I'm saying public class hello
bean simple say hello method take a
parameter hello name that's it right I
want to convert it to a WebSocket
endpoint so I say okay import Java X
WebSocket package and host the WebSocket
endpoint WebSocket is effectively an
endpoint this is which is where my
client is talking to so you're saying
host the WebSocket endpoint ad slash
hello so you just provide the annotation
put the path in there the WebSocket or
JSON 356 runtime kicks in automatically
hosts it for you that means it
understands the requests that are being
made to this end point using WS :
protocol all of those it will understand
all the semantics protocols etc
connection negotiation it will
understand all of that you're saying
whenever a request is coming to this
endpoint invoke this method you're
tagging it as a WebSocket message now
there could be multiple methods that
could be WebSocket message and I'll talk
about that but this is your simplistic
most trivial hello world example for
getting started with WebSocket message
or WebSocket in point there are lots of
other annotations as part of Java X
WebSocket star package we looked at the
first one if you want to make a client
you know then you can just put an
annotation at WebSocket client
annotation now of course there are
packaging on how you do the packaging
how do you bootstrap what URL is
listening to and I can cover that if we
have time but that's sort of the basic
idea here no you do a WebSocket endpoint
on a POJO
it becomes a WebSocket endpoint you make
at WebSocket client then you have
mechanisms on how it can connect to
server and then become peer to that
network effectively there are callback
handlers like open-close open-close
error you can define path parameter just
like jax-rs that if you know let's say a
request is coming in as part of the uri
you can say this is a variable part of
the URI map it to this particular
parameter of the method all that is
possible within the WebSocket endpoint
there are four attributes that are
available today well first of course is
a value which is defined the URI at
which the endpoint is listening now as I
said the WebSocket endpoint itself can
receive text data or binary data the
that one of the lingua franca of the web
is for example JSON format so now does
that mean every time you receive a JSON
object or a JSON fragment it's received
a string then you use a third party JSON
API to process it and then you kind of
play around with it and then finally
convert it back to string and send it
back no well that's how people do it but
what we expect is you would define
encoder and a decoder and that encode in
that encoder and decoder again going by
the separation of concerns design
pattern in that encoder and decoder is
where you will specify that oh string is
coming in I'm going to convert the
string to my POJO oh that's my decoder
right now going out you will say oh I
have our deal with my POJO but
effectively on the wire what has to go
out is JSON so and decode rebels or
encoder will do from my POJO to J's on
this this is exactly what you specify in
encoders and decoders so try to get
whole to the concepts and I'm going to
show you a much more comprehensive
sample covering all these concepts in
the code question
is there any integration of GMS with
WebSocket not at this point of time and
that's exactly the point for our next
bullet for example sub protocols now as
I said Jamie WebSocket is a very
low-level protocol any messages that
goes on top of it you define the
semantics for it so there are four
predefined sub protocols that have been
summary and there's a formal process on
how you can define a sub protocol as
part of the sub protocol you need to
define Oh what is the request response
message pattern and how those responses
need to be dealt and how those requests
needs to be dealt etcetera etcetera so
the one of the message exchange pattern
is for example how you could do JMS
style messaging with that so that may be
something that you can take a look at
but I think that's a very bleeding edge
area very gray area more than welcome to
take a look at it I've looked at the
proposal by itself but I don't know if
there are any implementations I think um
vamp is W a MP is what you may want to
look at it talks about a little bit
about how that protocol is implemented
within them
so we were talking about how I can
convert you know from JSON to my PO Jo
and POJO to my JSON you define those
encoders and decoders and you
effectively put them right here in this
annotation how would the code look like
well I have a public class my message
I'm defining decoder dot txt I know that
this is going to be a text message
coming to me and I want to encode it
back to the text so I'm gonna implement
decoder text and encoder dot txt and all
I'm doing is in the decode well first of
all bill decode that means in terms of
decoder if the string is coming to me
string is the payload coming to me and I
can maybe read ahead in the string and
return true oh I can process this
message so I return true otherwise I
return false now this is how the jacks
are WebSocket runtime or jsr 356 runtime
will decide whether the encoder can
handle the message from one format to
other that's one and then there is a
decode method here which says okay I got
the string now I'm gonna convert this to
JSON object and there got that goes
right here so that's sort of the
decoding part of it similarly encoding
you can say Oh take the my POJO object
which is my message in this case convert
it to string so just simple methods
similarly you can do that same thing for
binary as well so you can start playing
around with binary data convert an
encode and decode from binary to your
pojo
right well the question is if you're
writing this Java WebSocket code is that
part of the war file yes it is part of
the war file that's right the excellent
question is the URI of the WebSocket
endpoint relative to the context root of
the application yes it is so again I'm
just going through the concepts quickly
then I'm going to jump into the
application there we can now see lot
more details on how this is actually
being implemented it's again oh I know
my time don't worry you want me stop now
this is how we would write a very simple
chat sample for example I have a chat
beam I'm gonna say in the chat beam I'm
gonna collect a set of session now
session encapsulate s' how a client is
making a request to the endpoint and
that's the list of sessions for example
I'm gonna just maintain that list of
session so the way I would write a
simple chance blank chat client and this
is a full fully operating operational
chat server for example here I'm saying
on open by tagging add web socket open
annotation on it I'm just adding to the
set over here on clothes I'm removing
that from the set and then whenever a
message is being received
I just broadcast a message to everybody
very simple chat server fully
operational and it's not fancy but it
does job very well so let me show the
sample now
so I have a simple whiteboard
application okay let me show the
application first then I'll walk you
through the code the directory structure
and the calls and the flow etc so right
click run it this is running on
GlassFish build 70 which is the most
recent one that was promoted January 3rd
I think the idea is this is a
collaborative whiteboard you know
whatever you draw on one browser gets
displayed on another browser so this is
what I'm using it's Chrome let me open
up a safari window here and I can use
Firefox as well by the way so let me
refresh this guy here
so I just refresh the page so let's
focus on the left window first okay so I
can I'm looking at the developer tools
here I can click on WebSockets here this
is gonna show me only the WebSocket
connections that are happening as part
of this network traffic now if I take a
look at that so it says okay I'm
requesting the URL which is on WS colon
now remember I said this is not HTTP
colon this is WS colon you are out so
it's making a request to this URL white
board is the name of the application
WebSocket is my endpoint where is being
hosted the question that we were asking
earlier so the headers you know the
response that I'm getting back is HTTP
101 switching protocols and these are
the request header so I'm saying
connection upgrade this is the origin
host version etc and there in the
response I'm same connection upgraded of
the type WebSocket okay so that's that
so let's keep it minimal for now so the
way this application works is let's say
I
correction close frame okay
let me restart my server because I think
it was running already and once I come
here I join a different network so it
gets confused by the IP server's IP
addresses let me run it once again now
in terms of how the application would
behave is
okay that's nice and quick so the idea
is thank you so whatever I type you know
whatever I do this is a collaborative
whiteboard the idea is imagine you
running the show and whatever you're
typing on your whiteboard you wanted to
be reflected across the different
browsers now in this case I'm just
running two separate browsers but if you
have access to this network then you can
actually access this machine on your
iPhone or whatever it is and then you
would see the exact same replica for
example right let's look at the
application first then we'll talk about
that okay let's try to understand the
basic WebSocket concepts here first so
now if I show you the developer tools
for example here once again refresh it
here refresh it you just look at the
WebSockets
soomi the websocket
Oh
what happened I did my cellar day
operation timed out okay let's try it
again
raishin timed out
so let me show you the index dot JSP
page in the meanwhile so in the index
dot JSP page all I have is a html5
canvas and I have some radio buttons on
you choose the color you choose a shape
and then you could do transform in the
tenth the transfer in the sense you
could transfer as soon as I click on the
browser up or not yet
we're still starting
oh I just started to sew but I didn't
run the application itself okay
let me walk you through the application
first so the behavior effectively so
here for example whatever I click here
that gets shown over there I could
choose a different color that gets
instantly transferred now I say you know
what I don't want to do instant transfer
I want to go offline when I do some of
my own work so then I say don't do
instant transfer select some other stuff
here other shapes other color play
around with that and then I say now send
a snapshot so the use case here is every
time I am clicking effectively is
capturing the JSON coordinates well this
is a predefined template right both of
them are accessing the exactly same web
application so every time I'm clicking
on this browser is capturing the JSON
coordinates send broadcasting it in just
a chat server it broadcasting it to all
of my clients that are listening to it
and that's how they're getting reflected
over here the moment I say don't send
instant transfer that transfer is not
happening and when I say snapshot
effectively is taking a snapshot of this
html5 canvas and it's sending a binary
snapshot not text this time is taking a
binary transfer and sending it to the
other browsers so for example let's say
if a third browser now joins in I don't
know what the timing timing our problem
but let's try this so let's say I start
a third browser
I go he go here and here I say for
example snapshot again so the same thing
is sent instantly again now it's a very
simple sample but the concept it conveys
is you can do a multitude of things with
this application let's take a look at
the code with this so this is my instant
box so as soon as I say instant is
sending the JSON coordinates back to all
the clients and actually I'm saying
instant is false that means I'm sending
a binary data here okay and see how
that's being done so if I take a look at
my web socket j/s here in web socket dot
JS is where I'm actually making a
connection to the backend instead of
using HTTP colon I'm saying WS :
location host location path name and web
socket which is where my where my
endpoint is hosted so if I take a look
at my endpoint for a second
so this is where my WebSocket endpoint
is hosted okay and in this all I have is
WebSocket open/close and I'm saying
broadcast figure this is using figure
now figure is my POJO which is where I'm
sending my JSON coordinates and then
here I have byte buffer remember I said
you could have multiple WebSocket
messages the first one is what takes the
text version of the JSON coordinates the
second one is what is taking the binary
snapshot and broadcasting it to all the
different servers or all the different
peers second if you take a look at
figure for example up here that figure
is supported using these encoders which
are defined in my WebSocket annotation
itself now if I take a look at figure
encoder it says it's in code
implementing encoded text figure so
that's our the algorithm it says oh let
me take a look at all the encoders
decoders you have specified as part of
the WebSocket annotation if any encoder
serves that then I'm going to take
string map it to that particular encoder
converted to the POJO and dispatch to
the appropriate WebSocket message method
now these are my simple coordinates this
is just a there's nothing fancy here if
I take a look at my figure object itself
and figure it effectively all I'm doing
is storing the JSON coordinates okay and
if I were to show you for example my
whiteboard rjs which is where my
application logic is in there again
there I'm just using standard HTML or
JavaScript syntax I'm just using you
know get me the element by ID get me the
context which are standard html5 API is
I'm defining the image you know based
upon my radio buttons that are being
selected and this is my defined image
binary again I'm using html5 API is here
or JavaScript API is from the context
I'm getting the image data creating my
array buffer and sending it over okay
this is my draw image text which is
where I'm directly transmitting all the
JSON coordinates of the image for
example you can see it did it required
me a lot of experimenting to get this
code working but this code is all
available I mean a full blob which shows
exactly how this application should work
in terms of GlassFish bill source code
all is available already published on my
blog now if I go to for example files
here whiteboard target take a look at my
whiteboard dot war file now this is
generated with mavens of course it has
some additional classes but if I take a
look at my vibe we have enough classes
effectively those are all my classes in
there so there is no servlet no EJB
nothing of that sort in there just my
WebSocket endpoint classes and in terms
of web and if Lib jerison and stacks api
are bundled in there but i could
actually move them into the provided
category and they won't be required as
well this particular version again I
think I should be able to move it to the
provided category and that should work
too
caution
I tried it with my iPad my iPhones and
across Windows well not well yeah Chrome
on Windows and Mac and some of the
machines and it did work
yeah the main requirement being the
compatibility with the web socket API
you know you need to have the web socket
API implemented as part of the world
browser that is the only dependency
because the endpoint is hosted by the
GlassFish runtime you would need a web
socket container directly some sort of
web socket container so for now I'm
using GlassFish which actually has the
Tyra's implementation integrated in
there so you need some sort of web
socket container that will understand
that you know ws protocol be able to do
connection negotiation handshake all
that stuff right yeah how does web
socket scale effectively I think the way
we see it is HTTP is about horizontal
scaling this is more about vertical
scaling WebSocket in terms of that you
know HTTP you can easily add more
processors and say you know what I'm
gonna run scaling that way in WebSocket
you are definitely limited by the number
of ports that are available on your
machine so for example if you're opening
a WebSocket connection on one web socket
endpoint you know you can open as many
as you want but that is again restricted
by the number of ports that are
available so it is the scalability
concerns I have not studied myself well
and I've not started playing around with
it yet so I don't have a conclusive
answer but that's how I understand yeah
the question is is there any analysis
that is being done in terms of either
using HTTP and WebSocket in terms of how
much chattiness is actually being
reduced so if you take a look at the HT
the one of the non normative WebSocket
documents that means a sample a
WebSocket document itself says how a
simple hello world takes over two
kilobytes of data that is to be
exchanged between client and server with
WebSocket that can be done in about
about I think about 150 bytes or so so
there is definitely a huge performance
improvement and that's actually a code
coming from Ian
and who actually authored the very first
version of the WebSocket specification
itself the question was now that this
Java API for WebSocket are there plans
for Java API for web RTC real-time
communication take a lead you know run a
show run a jsr by all means we take
contributions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>