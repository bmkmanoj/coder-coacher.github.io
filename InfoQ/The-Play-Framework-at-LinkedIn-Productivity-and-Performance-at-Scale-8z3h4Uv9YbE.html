<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Play Framework at LinkedIn: Productivity and Performance at Scale | Coder Coacher - Coaching Coders</title><meta content="The Play Framework at LinkedIn: Productivity and Performance at Scale - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Play Framework at LinkedIn: Productivity and Performance at Scale</b></h2><h5 class="post__date">2013-06-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8z3h4Uv9YbE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you everybody for coming this is a
talk about the plate framework at
LinkedIn and let me set the context a
little bit here so your developer and
you're using Java to build web services
this is your life you spend an awful lot
of time just waiting waiting for a
service to redeploy there's numbers that
show that some Java developers spent a
quarter of their time waiting for their
server to redeploy you hire four guys
three of them are actually working it's
mind-boggling how many of you spend time
tailing Catalina Dowd or some other log
file
digging through just enormous stack
traces that are incredibly hard to parse
you know you think you use I know the
Java language I know Scala I know
JavaScript you have to speak stacktrace
as well to really be effective in Java
we spent a lot of time in XML soup
probably not too visible from back there
but spring files config files and just
mountains and mountains of XML without
any really good tooling to make any
sense of it you deal with classes like
this this is one of my all-time favorite
classes I think ever it's part of the
Spring Framework it's called the
abstract singleton proxy Factory beam
and the description makes it awesome
it's a convenient proxy factory being
superclass for proxy factory beans that
create only Singleton's love it so
awesome you occasionally run into thread
pool hell for some reason or another you
start running out of threads the latency
on your server goes crazy and that's
really what it's about that's what Java
web development has been for a very long
time
it has just been pain so there is a
better way and it's called Ruby on Rails
Nam's good
we have some real work to do here so now
it's called play framework which is a
modern web framework for Java and for
Scala
that I think just lets you have all the
stuff that you're used to with Java the
type safety the IDE the performance the
JVM with far less pain so I work at
LinkedIn world's largest professional
network with 225 million members there's
more than two people joining every
second so by the time I'm done rambling
here seven thousand two hundred or so
people will have joined so it's pretty
good scale so we've been using play in
production for about six months so we're
still pretty new to it we're learning a
lot but we kind of are excited about and
we want to share it with all of you guys
and a few of the apps you may have seen
from just a few months of work we
launched channels which is part of our
influencer platform all sorts of
important people are blogging and
sharing things on LinkedIn and this is a
great way to kind of break it down by
category and follow the channels that
you're interested in one of our
monetization products premium
subscriptions is built on top of play
and they have all sorts of cool
visualizations polls the front end in
the backend polls and groups and a few
other places was built on top of play
and we have a ton of internal tools that
have just popped out of nowhere just
because it's so quick to get started and
just get something up and running this
is an internal tool to search our
internal restful services and figure out
how to call them and get data from them
and things of that sort so that's just
from a few months of work they'll be way
more in the future i'm janie brooklyn or
i go by the nickname jim for people that
have trouble pronouncing evgeny and i'm
part of our service infrastructure team
i'm leading the project that's bringing
the play framework to LinkedIn and
really this talk it's going to be about
building web services at massive scale
using Java and Scala while maintaining
performance reliability and developer
productivity and this is a very tricky
balance to kind of achieve very few
frameworks are really able to do it
successfully usually they give you one
or the other but rarely all three so
this is kind of an outline of what we'll
do I'll give you guys a very quick
kind of getting started with play I'll
do some live coding which should be
interesting show you what it looks like
Tex you use the framework error handling
I'll talk a little bit about plays kind
of evented or reactive model for
handling IO I'll talk a bit about Scala
talk a bit about performance and the
community so a lot to get through let's
get started so those of you guys who
want to try out play it's really easy
grab it from play framework calm it's
really easy to install it to create a
new app you just run play new and then
give it the name of an app to set up
your IDE with all the dependencies and
classes and jars and everything that you
need there's just another command play
idea or play eclipse depending on what
your IDE is
and to actually run the app it's just
play run and it'll fire up and by
default listen on port 9000 and if you
hit a page you get this nice intro page
if you've used rails if you use the
bunch of other frameworks this should
feel like a very natural way to start a
new app if you're used to other
frameworks maybe not so much so this is
actually very easy it takes just a few
minutes and you're up and running so I
did this I have it running in the
background here you can see some console
stuff and the app is running and I also
have it loaded in my IDE so I'm going to
be able to do now is actually code for
you guys a little bit and if the demo
gods are kind hopefully show you a
little bit of what it's like to actually
use play so play is uses kind of an MVC
pattern Model View controller again many
frameworks do the same thing if you've
used anything like rails this should
feel right at home so we'll create a
controller which is just a Java class
we'll start with a basic hello world
example and to get some nice helper
methods it can extend the controller
class from play and inside of your
controllers you basically have actions
that return some kind of a result not
the most original class name apparently
and so in here we need to return some
sort of results the simplest one is a
200 okay and you can do that using this
OK method that's in the controller class
so this actually is kind of the hello
world example we can put some
extend it just to make it a little more
interesting so the only thing we need to
do besides this is just expose it at
some kind of a URL so there is a routes
file in here and the syntax for the
routes file is the HTTP method that
you're interested in get put post etc
the URL pattern so we'll just put this
at hello and then quite literally the
code to execute so in this case it's
controllers dot hello world index that's
it if you now go to your browser go to
this guy's slash hello hit enter you can
see in the background it well it's
already done but if you scroll up a
little bit it compiled all the stuff on
the fly reloaded the server I have a
bunch of plugins in here that I'll start
it up but basically you get your hello
world example we can make this more
interesting let's read parameter out of
the query string so maybe we'll read the
name out of the query string just add it
to the routes file and this just gets
passed to your action as a function
parameter or sorry this should be called
name so now we can do something hello
plus name go so now I can just add that
guy onto here you can see I've tried
this example before we hit enter give it
a second and now it says hello gem and
so now we have a slightly more dynamic
example and we can change this to Bob or
whatever we want we can also play have
some really cool routing stuff if you
like kind of SEO friendly URLs you can
actually make the parameter part of the
URL as opposed to part of the query
string so this is kind of the syntax for
saying the thing after hello slash call
it name so now instead of doing it as a
query string parameter I can do slash
let's change it to Steve so you can
actually see something happen so it
reloads and now it says hello Steve and
it's reading it out of the URL
parameters have types master all we're
using a type safe language we should
take advantage of it so we can add
another parameter may be the age and
it's an integer
so now we can say hello name you are
aged years old so now let's add another
another part or URL here fix spacing a
bit and so I wrote here just name but
this is really just shorthand for
something that is a string if you
actually want these things to be to have
different types you just specify the
type after the parameter this is you can
see now it's all compiling and IntelliJ
is happy
technically the syntax on this right
side here is Scala but you don't really
need to know much scholar to make use of
it so we can now say that Steve is 55
years old and it will reload the changes
and now it says hello Steve you are 55
years old and this has type-checking so
if I put in some garbage in here that's
not a number it instantly tells me it's
not a number just very handy using our
type safety to our advantage
okay let's one more thing we can do I
showed you guys the giant blobs of XML
all over the kind of servlet universe
play for its config system uses typesafe
configs which are the in these con files
and essentially these boil down to json
but it just gives a couple extra
features on top of it so you can include
other files you can reference other
configs you can use this key almost this
properties file syntax or you can just
put JSON in here it's kind of up to you
so where am i I am at Jack's conf and so
in here to this example I will read a
config and you'll see that it can hot
reload config changes as well so my
location is get string location as the
name of the config and you are at
location you guys still see that
hopefully you guys can read that refresh
the page it's going to reload the config
changes when this thing comes up and
there we go you are at Jack Scott
so really end-to-end hot reloads Java
changes Scala changes config changes
whatever you're working on yeah so first
question I knew you were going to ask it
if you actually look at my slides don't
worry about static setup okay so play
has a philosophy with controllers that
the actions should be static because
there's really just one controller it's
kind of like a switchboard operator if
you don't want to use it you can
instantiate the controller on every
request you can do injection if you
really want to you can use play with
spring with Google juice whatever you
want to using static here is just the
fastest way for me to give you guys a
really quick demo so don't panic you can
still have ioc and all the kind of stuff
that you're used to your other question
was as annotations right I don't think
so I think the default routing framework
uses the routes file that said removing
the default routing framework is one
line of code and then you can swap in
your own literally there's a method
called on route request it gives you the
request the default implementation uses
the routes file if you want to do
something else you absolutely can and we
actually did that for some of our
backends we have custom restful routing
it's a framework called Pressley that's
open source and so we actually use that
on top of play it by doing exactly that
so it's actually pretty easy to do to
swap that out so configs are hot
reloaded which is awesome but let's
let's render review I'm tired of
rendering things inside of my controller
this is kind of not so cool so let's
create a view play built-in has these
things called Scala templates we are use
play at LinkedIn with dustiest happy to
follow up after the talk if anyone wants
to know how that works so we'll create a
new template here and in here I mean
just like any templating language you
can put your usual markup the difference
is play will actually compile these
scala templates into a function so these
are also actually typesafe which is
pretty interesting and you can take in
parameters in that function using this
syntax at the top so let's say I want
the same name and I want the same age
parameter so now those are going to be
parameters to this guy and now I can do
something like hello let's put it make
it bold name you have autocomplete in
here as well
ooh our age years old and I don't know
let's put a picture in here as well just
so we know it's really a view being
rendered so it's play has really nice
typesafe generation of URLs as well but
I'll demo that if we have time at the
end okay so I have a view that's just
going to have a logo and say hi you are
at you are so many years old so now we
just have to actually render it from
here so you do that by doing this oops
views render and you pass it the name
and the age as parameters I haven't
compiled this view before so right now
it looks like an error but as soon as i
refresh intelligence should pick that up
correctly and it should render in the
browser if the demo gods are kind to a
there we go so play logo hello Steve you
are 55 years old can obviously tweak
these parameters Steve just got really
old and you can see in my IDE if it
updates there we go so now it recognized
that everything is compiling
type-ahead everything is just very
nicely integrated so that's a really
basic intro to working with play I'll do
a few more demos in a bit but this is
kind of this MVC architecture one of my
favorite things I showed you guys a
really brief demo of it is play has
amazing error handling so that I don't
have to sit there and tale logs all day
long so let's say I forgot a semicolon I
mean obviously intelligent shows me but
pretend you have some silly compiler if
i refresh the page play shows me
immediately in the browser what the
error was
what file it's in what line and the
actual busted source code right here I
don't have to go digging for it and some
console it's also by the way in the
console if you do need the full stack
trace but in most cases you just see
there and the browser and you go and fix
it so I can fix it and this applies
pretty much everywhere if I mess up the
name of one of these variables in here
again IntelliJ is smart enough to show
me but if I miss that for some reason
play will show me in the browser where
that mistake is and so this applies to
templates the job but you can say
again end-to-end the errors show up in
the browser you do not have to
exclusively understand how to read mile
long stack traces to know what's going
on in your app really powerful feature
okay
so that's a really basic intro by the
way I had a bunch of slides here just in
case the demo decided to blow up in my
face so I'll skip all of those guys and
we'll go to the next topic here so
besides being very developer friendly
play does something else quite a bit
different than most Java frameworks that
you're probably used to most people are
used to what I would call threaded
servers by the way this is a very
high-level overview I'm obviously
glossing over a lot of details but bear
with me so most people are used to
threaded servers what I mean by that is
a request comes in and the server will
pick out of a thread pool of thread
assign it to that request and it's going
to process the request until it's done
ship the response and then put the
thread back in the thread pool so one
thread per request and it usually also
involves a lot of blocking i/o and this
is almost every common framework out
there today
so spring MVC Grails django PHP rails
you guys know that was Tomcats logo that
weird cat looking thing I've been using
Tomcat for years I had no idea that
weird thing was loaded anyway Tomcat all
of these things are threaded blocking
servers and so the code typically looks
something like this you have some kind
of method do get and you have a for
example the Apache HTTP client and I'm
going to make an HTTP request to
example.com and when I call that execute
method method literally the thread is
going to shoot out that request and it's
just going to sit there blocking and
idle until the response comes back that
thread doesn't do anything else until
the response comes back and when it does
then the next line of code executes
which has some downsides that I'll
discuss in a minute so the alternative
to threaded servers are evented or
reactive or there's many names for them
non-blocking kind of server
architectures that are they're not new
they've been around forever but they're
gaining popularity for kind of
mainstream web services I'm sure all of
you guys have heard of nodejs
it's completely non-blocking play is
built on top of akka
nettie although you can use obviously
those pieces by themselves both are kind
of ways to do reactive non-blocking code
in Java and an example so from like the
node Reyes world here's a typical
non-blocking case this line down here
HTTP request that's kind of the
equivalent of HTTP client you're going
to fire HTTP request to some server but
it's completely non blocking that
happens almost instantaneously in the
next line of code executes before the
response has actually come back the
response is not available until
somewhere at some point that callback
function is executed so the code doesn't
really read top to bottom but there's
also no blocking so the thread can go
and do other stuff so why do we care why
especially at length n do we really care
about this threaded versus invented
trade-off so the reason is we use a
service-oriented architecture what that
means is that our code our website is
broken down into a bunch of standalone
services you can write the code for them
separately they can deployed a separate
hardware you can scale them separately
iterate on them completely separately
and they talk to each other through
usually some kind of remote call to
maybe a JSON you know restful endpoint
and so as you can see front ends talking
to backends backends talking to data
stores is obviously an enormous amount
of complexity that's being glossed over
here with mid tiers and caches and lots
of other stuff but at the end of the day
servers spend an awful lot of time just
calling other servers so this is maybe a
typical front-end servlet we would have
and most of what it's doing is it's
going to call our profile service to
fetch a profile data it'll call the
company service to get company data the
skills service to get skills data and
every time it does this it just sits
there and waits for the response and
that thread can do nothing else the
entire time and of course you can do
some of this asynchronously even in a
threaded server but to do that you have
to set up another thread pool and you
have to submit work to it and then you
have to block until that work is
finished and you have to manage
concurrency so again nothing that I'm
saying here is impossible to do it's
just a lot harder and here's the thing
this is an awesome chart by the way
those numbers at the end the four
these are references at the end of the
slide deck which is on SlideShare afia's
want to click through the links this is
a great website latency numbers every
programmer should know this gives you
kind of order of magnitude comparison
between how long certain things take so
something like an l1 cache reference
versus reading from a hard drive are
many many many many orders of magnitude
different and how long they take and
what you'll find is almost every type of
i/o so for example a round trip in the
same data center that's that giant blob
of green and the third column that's
what is that 500000 nanoseconds or a
single disk seek you know the hard drive
spinning is 4 million nanoseconds any
kind of i/o is multiple orders of
magnitude slower than anything you're
going to do inside of the service itself
so any kind of memory lookup CPU branch
anything of that sort it's many many
many orders of magnitude bigger so hyoe
is really expensive and what it really
comes down to is because i/o is so
expensive in this massive concurrent
service-oriented architecture
architecture that we have the threads
spend most of their time just waiting
there just idle there doing absolutely
nothing but waiting on something to
respond and that's problematic so you
end up in this really weird dilemma with
threaded servers you don't want to
create threads on the fly it depends on
the JVM and the OS and all sorts of
other parameters but generally speaking
just pumping out new threads is
expensive there's a lot of overhead with
it so you usually use a fixed size
thread pool ok so now you have to pick
the size for your thread pool well if
you make it too big you run into a lot
of overhead with memory I think the
default stack size for a JVM thread is a
megabyte so every single thread you just
lost a megabyte of memory hasn't done
anything yet you also get a lot of
context switching overhead and a few
other trade-offs ok but if you make it
too small then if you have too many
requests that come in at the same time
you run out of threads now all new
requests just queue up and there's they
just wait and they're blocked and your
latency goes up but even worse and this
is a real nightmare is threaded servers
are very sensitive to downstream latency
let me show you an example so we go back
to our architecture diagram and let's
say we have a database all the way over
there one of hundreds of data stores
that we have what's the latency goes up
somebody forgot to add an index on a
query the traffic went up a little bit
latency one up appreciably now ideally
the only consequence of this will be the
requests that directly depend on that
guy become a little slower not the end
of the world in a threaded world though
it actually become much much worse
because here's what happens latency goes
up in that guy
well now the threads that are just
blocking and waiting on this guy they
get backed up because they just have to
wait longer and so as you know
especially if the traffic just took a
little spike now of a sudden all the
threads are eaten up and so now new
requests get queued and the latency goes
up on this guy well now since his
latency is higher guess what threads
start backing up on this guy as well as
that guy maybe that guy too because he
calls him as well so now all of these
guys are starting to have their thread
pools kind of run out of threads latency
is shooting up across the whole site
eventually everywhere latency goes up
and before you know it's a minor
increase in latency in one database
somewhere and your whole site's down and
this is thread pool he'll this just
sucks
you're basically trying to determine the
size for a fixed size thread pool based
on something that's very dynamic which
is traffic patterns and i/o patterns and
concurrency patterns it's a really
annoying problem and it's very hard it's
easy enough with one server talking to
one other thing but when you have
hundreds of servers talking to hundreds
of other servers it actually gets very
very complicated so play is built on top
of Neddie and it avoids a lot of these
issues the i/o calls are completely non
blocking the thread will fire the
request and it will go and start
processing other things in the meantime
that requests that isn't really done it
doesn't really cost much it basically
costs a socket and a tiny tiny bit of
memory but it just kind of puts it aside
does other things when that response is
available picks it up again keeps
processing it until it's finally done
and so your threads aren't locked if you
write the code
directly just pretty important and so
you don't run into these issues where
just because some downstream service got
a little slower your whole site ends up
with this crazy cascading latency effect
so as I said much less sensitivity
downstream slowness if something
downstream is slow well than anything
that directly depends on it just becomes
a little slower but not everything it
also makes it much much easier to do
things in parallel so if we're making if
we're fanning out to ten services to get
our data with blocking calls we have to
do some magic to make that happen in
parallel like I said you have to set up
another thread pool that you have to
manage you have to submit work to it you
have a lot of extra work to do with with
non-blocking i/o if I put five calls in
a row they all happen in parallel
because none of them block it just goes
to the next one almost immediately so
it's much easier to do things in
parallel and because it's so cheap to
keep connections open not just the
downstream services but also incoming
connections from the browser now we can
support things like WebSockets commet
server sent events basically all of
these things that are starting to power
the real time web they're very hard to
do in a threaded like one thread per
request environment you really can't do
it very effectively you can with
non-blocking i/o and this is coming in a
big way I think node more than any other
framework is really bringing this up
being able to do this on the JVM is
pretty nice okay so let me show you a
quick example of some non-blocking i/o
in the play world so let's create a new
controller we'll call it proxy and it'll
extend
controller again just as before let's
steal something from this guy really
need these parameters all we're going to
do is take in a URL and what we're going
to do is we're going to make a
non-blocking call to the URL pass then
to this action and we're just going to
proxy the result so we can do a
non-blocking HTTP call in play using a
library called W
I think it wraps Ning's httpclient you
give it a URL and you can call put post
or in this case we just want to do a get
and what we're going to get back in this
case is not just an HTTP response that's
this guy but we're actually going to get
a promise of a response if you've worked
with Java futures this is a little bit
similar this is an object that will
eventually contain the result you're
looking for the difference from Java
futures is the pattern you use with Java
futures is at this point you would just
call you know you would do whatever
requests you want to and then you say
get at that point you're blocking until
that future is available here we're not
going to call get you can if you really
want to and you just want to do a
blocking server and play you can just
give it a bigger thread pool but if you
want to do something non blocking you
just tell it something to do when the
data is available and play inside of
play it knows how to deal with with
promises so if you remember we need to
return a result play has a class called
a play of the source code loaded there
we go a thing called
async result which extent which
implements result and this is just
something you can create by passing it a
promise of a result so if instead of
handing plague directly a 200 okay you
hand it something that's the promise of
a 200 ok it'll know what to do with it
will kind of take it put it aside and
when that thing is ready it'll pick it
up again and send the 200 okay to the
browser so that's what we want to do at
the end of the day we want to produce an
async result to do that there's a nice
method called async which you can see in
the return type it'll give us an async
result all I need to do is give it a
promise of a result that's it how do we
get a promise of a result well we have a
promise of a response and we want to
transform this into a promise of a
result if any of you are familiar with
functional programming this is a bit
this is something you would typically do
with a method called map flatmap there's
a whole bunch of ways of doing it if you
want to learn more about that I wrote a
whole blog post that builds the
intuition about why map and things like
that makes sense
but long story short we call map and we
pass it some
code to execute when the data is
available and IntelliJ will generate
most of that code for us yay
okay so in here I have my response this
is actually the HTTP response to that
call and at this point I just need to
return a result from that and so we can
do that by returning a 200 okay
putting the body of the HTTP response
inside of our 200 okay and we'll set the
content type correctly for this requests
that's it this is a fully non blocking
proxy in play in 15 lines of code most
of them are curly braces on the next
line which are probably annoying a few
of you so let's expose that thing at a
URL and it's let's see controllers proxy
dot index and it needs a URL as a
parameter so we now go here and we proxy
linked end comm it'll reload all that
stuff in the background we'll wait for
LinkedIn to respond and tada my local
host is now proxying linkedin.com
and this is fully non-blocking at no
point is this server blocking a threat
waiting on that HTTP response so we can
leave these connections open and do all
sorts of great stuff so it's actually
pretty easy there's not a whole lot up
to it but I also mentioned that you can
do things in parallel so let's build a
slightly more interesting example we'll
do one more controller call it parallel
once again it'll extend controller just
to give us a few handy methods to use
I'll steal this guy okay so what do we
want to do in parallel we want to now
call several websites in parallel in
this case I kind of want to measure how
long the websites take to respond so I'm
going to do a little race between a few
websites so we'll use the ws library
again we'll pass it a URL so how about
we'll race a few search engines against
each other so we'll do Yahoo get oops
and if I just do this right here this
calls Yahoo in a non-blocking way if I
add a couple more guys in here let's say
Google and Bing this is three
non-blocking
HTTP requests that happen in parallel
but like I said I want to measure how
long they took so let's set up some code
to do that so first I'll record when we
started this whole thing so be a long
okay and now what I'm going to do is I'm
going to create a function that
transforms the HTTP response basically
throws it away and just records how long
it took to get that HTTP response so we
create another function probably which
one of these that's the one and it's
going to take one of those response guys
and it's going to return just a long
that says how long that thing took we
need one of those and we'll store this
in a variable called timing okay
and so in here the only code that we
really need is just to basically say
this took that long to process so
whenever this thing is called take the
current time subtract our original
starting point so let's transform these
things so if I you know put these guys
in a variable right now you can see I'm
getting a promise of a response but I
don't really want a response I just want
the timing so to transform it I just
give it that timing function and if I do
that
this one's Yahoo now as you can see I
get a promise of a long this is
something that will eventually contain
how long it took to make the HTTP
request to Yahoo so do the same thing
for each of these guys put him in some
kind of a variable
this one's Google this one is Bing okay
almost home
only thing we need to do now is actually
do something useful with those numbers
what we can do is we can compose these
three promises into one that will
when all three are available and there's
a handy function to do that it's called
weight all again it doesn't block it
just it's another promise that we'll
just redeem one everything inside of it
redeems so you just pass those guys to
it and really what we want to do again
is use that async function so we get a
async result out of it
and let's let's build this as a JSON so
play has some nice built-in support for
JSON here's what we'll do we will put
the data into a hash map from the name
of the website to how long it took and
let's just put the data in there so is
missed one detail here Java of course
that's interesting ideas about closures
so dated output yeah who took this long
and I'm calling get here but since this
is inside of basically this guy's map
function we know it's already redeemed
this won't actually block in any way so
we'll add the other two in here here's
Google as Bing let's give them the right
labels and play has this nice function
or class I should say called JSON that
one that'll just convert objects to JSON
for you and it will set the correct
content type everything else so this is
it this will fetch three websites in
parallel record how long it took to
fetch them and return it as JSON as
usual we need to add a URL for it okay
and now we hit this guy give it a second
to reload to fetch the three websites
and hopefully spit back some JSON at us
if I did everything right hey there we
go alright let's refresh one more time
because obviously this includes some hot
reload overhead actually no the overhead
is I'm connected to VPN sorry about that
so you can see Google seems to be by far
the fastest followed by Bing and a very
very distant third is another company
there and this you'll see has the right
content type this is JSON did it all in
parallel didn't have to set up a thread
pool didn't have to do anything terribly
fancy to make this work so this is kind
of the non-blocking story in play in a
very very quick kind of demo hopefully
that made sense to some of you guys
alright move it along let's talk a
little bit about scallop how many guys
use Scala not too many cool so play has
native support for Scala built right in
there's nothing you have to do to you
know make it work you just create a file
with a dot Scala extension so just very
quickly
we'll do a hello world Scala and just
like the Java controllers it'll extend a
controller class to get some nice handy
methods just like the Java version there
will be actions in here and you also
have an OK method you can call to say
hello world
Scala so this is your hello world Scala
example add one more URL call it Scala
there we go so now if we go to scholar
it should reload that guy and you'll
just see it's a hello world scholar so
there you go so there's nothing really
to make it work it just works if you put
a scholar file in a play app it will
compile it scholar files interoperate
with Java files Java files interoperate
with Scala files kind of a beautiful
seamless experience there we go and
we've got
showed you that by the way I think I
mentioned this earlier this whole slide
deck is on SlideShare if you guys want
to pick it up just search for play
framework at LinkedIn so one of the
really nice things about using Scala
inside of play is Scala has support for
a lot of nice functional programming so
first-class functions closures sequence
comprehensions and a few other things
that can actually result in a more
concise and more composable api and this
especially applies to async coding so
the async coding in play with Java as I
showed you guys it's pretty easy but you
still end up with that syntactic
overhead of an anonymous inner class and
the reason for it is simple to do
something asynchronous you need to have
a way to say execute this code later
execute this function later Java doesn't
really have a way to pass around a
function you can really only pass around
a class so you usually do an Autumn
Center classes Scala does have
first-class functions so the code
becomes just vastly simplified which is
pretty cool Java eight may even things a
little bit here we'll see it about six
months hopefully but so the API can be
nicer on the scala side another really
neat thing I can show you guys if you
know Scala is this is the app running in
the background I can shut it down
there's an interactive console for Scala
which you can fire up and so in here I
can run you know commands like two plus
two very exciting but much more
interesting is I can import any of the
classes in my project so I can actually
import my my controller for example and
I can execute it I forget what it needed
name and age and there we go and I get a
200 back and there's a way to read the
result out of it so I'm literally
interacting with my server on the fly in
the scala console really useful i spend
a lot of time here to learn how things
work or to try something new but you do
need to know Scala how to use that you
have to know Scala in order to be able
to use this because this uses Scala
syntax so oh boy here we go again
hopefully that's the last time I exit
the presentation
note to self don't use google docs in
the future not very good for big
presentations okay
and you'll also find that at the core
play is written in Scala this is from
their github page more than half the
code is Scala Java is only about 16% now
they have very nice idiomatic Java
support for everything but you're going
to keep bumping into Scala here and
there so it's really nice if you do know
Scala
so you saw the templates kind of using
Scala syntax the routes file uses a
Scala syntax one piece I haven't talked
about yet is SBT that's plays build
system that's entirely in Scala
so does help to know Scala you can be a
little more a little closer to the core
of play the less good part about Scala
is really not so much Scala as it is one
particular usage of Scala and this is a
thing called SBT this is plays build
system it technically stands for simple
build tool but I think there's some kind
of a rule where something as simple in
the name it isn't is really powerful so
to be fair to SBT is probably the most
powerful build system that I by far that
I've seen it actually supports a lot of
plays awesome features like hot reload
that console a lot of other things just
come just because it's on SBT it has
things you can't do with other build
systems like introspect the build itself
and execute it on the fly and other
really cool stuff the problem is it's
got a really really really steep
learning curve if you don't know Scala
first of all you're in a lot of trouble
because the code looks like this which I
don't know if abusive skull is the right
way to put this but they use every
possible trick in the book to really
shorten things up I don't know how many
of you can guess what any of these lines
are actually doing but believe it or not
these are like function calls and you're
passing higher-order functions to them
and there's operator overloading and
there's I mean implicit slike crazy yeah
it's a good quote very good question so
good Scala does not look like this SBT
in my opinion went a little bit off the
deep end with abusing the syntax so this
is really hard to get started with again
the stuff you can do here is awesome but
I mean honestly like what the hell is
less than plus plus equals some sort of
fish rocket thingy I and you can't
Google it you can't Google less than
plus plus equals you're completely
screwed so this is really rough to get
started with I if you're doing simple
things like I just need to add a
dependency to my app some jar file I
need name the app all of that is very
easy you can basically do it in a minute
but when you need to do like serious
build work with play which we have to do
as an infrastructure team at LinkedIn
you're going to dive into the bowels of
SBT and it's it's hard okay now let's
chat about performance so I get a lot of
questions of is play web scale and I
think there's actually a few interesting
ways to look at scalability and I really
do think you're going to miss the
picture if you don't look at all of them
so I think there's kind of a graph of
scalability for web frameworks there's
kind of raw horsepower concurrent
horsepower scaling for how fast the
single developer can do things and then
how fast a team of developers can do
things so here's what I mean by each of
those raw horsepower that's like the
theoretical maximum if I set this
framework up in ideal conditions and
just hit it with requests
how many key PS do I get what's the
latency how many errors and this is
largely a measure of the language and
the framework overhead more than
anything else
concurrent horsepower this is kind of a
more real-world scenario you have lots
of i/o you have Layton sees that vary
all over the place conditions are not
ideal this is more of a measure of how
does the framework approach concurrency
in general and both of those matter by
the way no one of these is necessarily
more important than the others there's a
very strong trade-off between them
single developer one guy coding how fast
can you get things done how quickly can
you get started a lot of frameworks
focus on this and get this right but a
lot of them forget
this one that most things are built by
teams of developers a bunch of people
working together on the same codebase
the codebase grows it gets huge it ages
how much code rot is there how
maintainable is the code doesn't matter
if one guy can go fast if three months
later you're totally stuck so here are
my ratings based on my experience try
not to get offended your mileage will
vary spring MBC if you hit this guy with
a bunch of requests and kind of like an
in memory scenario really fast many many
many many thousands of QPS without any
without breaking a sweat
type safety does help code reduce code
rot for large old projects but it's not
developer friendly it's a real pain to
get even the most basic thing done and
as I discussed before this kind of
threaded approach to these large
concurrent IO scenarios can be
problematic to scale so if we plot
spring MVC on a chart represent it
visually really good in one quadrant
less good in some of the others
how about Ruby on Rails this thing in my
opinion kind of set the standard for a
single developer in terms of
productivity just amazing how quick and
get started get going and get things
built the open-source community is
incredible there's a plug-in for
anything you'd ever want to do with
rails but Ruby is really slow like
really genuinely honestly slow and it
doesn't have real multi-threading it
doesn't have a great event at
architecture so it won't handle
concurrence in areas particularly well
and it's a dynamic language which can
make it harder to maintain a large code
base not impossible if you do enough
tests you do enough work it's certainly
possible to have a really nice Ruby on
Rails app that's big but it's hard it's
just genuinely harder so if I were to
plot this one it's a little bit of kind
of rotating spring MVC it gets really
good in this quadrant really not so good
in some of the others
how about node we actually use node.js
at LinkedIn as well for our mobile
servers so v8 if you throw a bunch of
requests that it does pretty well
probably not quite as good as servlets
but pretty damn well
it's non-blocking so the concurrent
story is really good in these heavy kind
of iOS IO bond scenarios the open source
community there's really good
it starts up really fast so you can get
things done pretty quickly but it's a
dynamic language and it's a very
immature framework or actually note
itself is becoming more mature but all
the plugins the ecosystem around it is
constantly making backwards incompatible
changes almost every release and the
result of it it's a dynamic languages
you run into this when you run your app
which is a little bit too late you kind
of want to know about it earlier on but
still it does pretty darn well in this
chart it does well in most areas maybe
not so great for huge large projects
that last many years and so finally play
if you bang on play with just kind of
like your ideal scenario the hello world
case I did this on a laptop you can get
like 60,000 QPS with absolutely no
tuning nothing just run it through a
request that it not a very useful test
but again it does find for kind of the
raw throughput non-blocking i/o means
for concurrent scenarios again it does
very very well not very sensitive to
downstream latencies hot reload means
one developer can get things done pretty
quickly I was able to write Java code in
front of you in a live talk that's
impressive eyes and I've never been able
to do that before play and strong type
safety I'd argue actually much stronger
type safety than even you get in like
spring MVC because the templates are
type check the config is type check that
everything is just you really know about
errors very early on in a very easy to
read way down sides I'm not going to
claim that it's quite as productive for
a single developer as something like
rails interpreted language just
inherently faster to reload and it's got
a rails has been around longer so much
bigger open-source community yeah it's a
fair question yeah that so for a large
project where somebody else dropped
something in on you and things blow up
on your face rails can actually become
less productive for me working on my own
project alone I'm still probably going
to go a little faster with rails and
this one actually what I would say is
play is just new and once its community
gets bigger and you have plugins that do
all the work for you it's actually going
to just keep getting faster and faster
but it's a very fair trade-off it always
is with dynamic languages yeah I don't
know if that applies to the JDK but if
you're upgrading scholar versions yes
you need play to have upgraded first
that said play type safe is kind of I
don't know if they own play or at least
they provide all the commerce
support they're going to be the very
first folks to upgrade Scala long before
you ever did and probably Java 2 they've
been running Java eight preview builds
forever now so that's not a concern
video yes you own it now thank you
there we go perfect answer so they're
going to be first that that shouldn't be
as concerned that said the binary
compatibility issue with Scala is a
problem you upgrades are inherently
harder but at least the play part is not
what's going to block you it's going to
be your own code so if we plot it on a
chart this talk is about play what did
you expect it's obviously gonna have the
big the biggest orange box it's probably
not the best at any one area but it's
really good at just about all of them
it's a pretty effective system yeah if
it's not obvious this doesn't take into
account many things I can't possibly
cover every aspect of how a system
scales and performs build systems so
there's trade-offs so as an app gets
bigger compiled languages like Java take
or an especially Scala take longer and
longer to build on the other hand you
also get something in return
right it's actually checking and
catching a tremendous and I'm aware of
errors that otherwise you would have to
just manually write unit tests for so I
think there is a trade-off there for a
large team I don't know who wins I
really think it comes down to the use
case but you do get something in return
for the heavier build times can we save
questions just for the end I just want
to make sure that I don't go over time
so the folks I want to take off can take
off I just have one quick section left
which is just a little chat about the
play community plays open source it's on
github all the code all the pull
requests all the bug tracking very
active project they're updating it very
quickly very responsive to pull request
we've actually submitted quite a few of
our own from LinkedIn we'll be
submitting many more really active
Google group so if you have any
questions this is the place to go
and ask and it's got the mailing list
behind it and all the links again at
their end of the slide deck popular on
Stack Overflow so you can actually
Google things and find answers there's a
directory of open source modules there's
actually more than one I found out today
this is growing it's not quite as big as
it was for play one but
growing we've contributed a few of our
own but we have a whole bunch more
coming that will be open sourcing in the
next few months and it's supported
commercially by typesafe we actually did
work with typesafe to help bring play to
LinkedIn so it kind of has the open
source part of the world and the
commercially supported part of the world
which is very helpful especially for
large deployments and the types of guys
are genuinely awesome so that's the
recap that is the story of play at
LinkedIn it's easy to get started it's
easy to work with it really quickly
the error handling is just phenomenal
there's no more crazy stack traces the
evented the reactive pattern is
extremely useful for large deployments
Scala can make your app just really nice
the performance is great the community
is awesome
that's our story so far to be perfectly
accurate as I said we're just getting
started
we are also new to play but we're
excited we want to hear feedback we want
to see what other folks are thinking
about maybe if you haven't tried play
give it a shot and see if it works for
you
last piece our engineering blog will be
blogging and talking about our open
source code and all that engineering
darlington calm and you can also follow
LinkedIn edge on Twitter for all the
latest updates that's it thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>