<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>AnDevCon IV: Getting Native with NDK | Coder Coacher - Coaching Coders</title><meta content="AnDevCon IV: Getting Native with NDK - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>AnDevCon IV: Getting Native with NDK</b></h2><h5 class="post__date">2012-12-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sMcF08p5Maw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm just gonna find out all of it how
many of you are Java developers okay
what about C C++ developers the last
time or how many of you have written
basic android apps or hello world type
ok got it cool alright so today we're
going to talk about 10 DK what it is
what it isn't when you should use it
when should you should care about it
that sort of thing so so that's
basically what we are going to cover
just before we get started I'm just
going to a little bit about myself so my
name is Marco garganta my background is
in Java actually stopped doing see when
Java came out it wasn't Java back then
it was a project at son called oak and I
got really interested in that because we
were going to program all the embedded
devices with it so that was kind of the
selling point so I kind of jumped on a
Java bandwagon back in 96 and and
started developing in that but as we
know Java sort of moved from the browser
to the server side and most of my
development job has been with the big
enterprise systems until I knew it came
out so that's why I can I get back into
an Android when when it came out because
that was my original interest in belly
devices but I haven't done a lot of C
C++ development ever since the mid- I
used to do it before that that's a
little bit what my background so good so
I've been doing extensively a lot of
Android development the last couple
years one of the first things they did
is a developer course or Americana call
Daniel in boot camp which is about AB
development and since then i thought it
course all over the planet and then I
Riley asked you to essentially bottle it
into a book so I wrote a book called
learning android that's been translated
in many languages and so on but that
book is all about app development most
of the stuff that they do nowadays has
to do with Android internals so
basically not so much building apps with
building rafts like building natural
custom and with devices so that's kind
of like what my passion is what I do may
and so antique a nicely placed into that
because ndk sort of a nice little subset
of actually working with the platform I
frequently speak at conferences this
mitered third year at time def con is
Kip tonier and it's my second talk today
so some of you might have been my
previous talk on architecting android
apps so that's a little bit what myself
in this module in the stalk what you're
going to talk about is we're going to
talk about basically what NDK is why you
would care about it I'm going to mention
Jane I but I'm going to refer you to
another document that no dirty rotten on
Jay and I i'm going to i'm going to give
you an example how to use MDK so
basically we're going to build a actual
working example with ndk through the
next are from scratch or nothing and so
that's basically what the talk is about
now just to kind of start nice and easy
with some pictures so basically in a
typical end with that I draw android
apps is this kind of like vertical
stacks right each app is a process it's
a linux process each app may have one of
the activity services providers the
receivers right so app is basically just
a container for those components so I
use an activity as an example because
it's the easiest it's some kind of you I
something that you can interact where
you can press the button right in often
you you may want that button to actually
do something that has to do with lower
lever stuff right so what you would do
it for example you is you you want to
access a library a native like a live as
so to do that so in my world the blue is
Java and the green is native mostly see
right so basically to access this piece
of C code here what we would do is we
would wrap that piece of code using a j9
acknowledge right and then we're going
to use NDK to help us do so right so
basically that library would now access
for example device driver
else that may not be available to you in
a channel length right so that's
essentially the motivation for this
that's because we are trying to do here
so we're going to basically learn how
you can have a standard java or more
specifically an android components such
as an activity a screen talk to a native
library that then may do something else
in CC possible one thing that i wanted
to on point out is that I find people
find sometimes confusing is that you
know who runs actually a native code
right if you're talking about an
application right yes you can bundle
your native call you I so library into
your native code but ultimately that
code is still executed by Dalek so keep
in mind that it's not actually runs your
your library right so for example you
know your your Java code that you write
is going to get converted into Dalek
executable into about Dex file class
right so that's what's natural to dalvik
that we grunts you Dalek Java code
essentially compile Java code right but
it's and so you if you have some native
library that native library is loaded by
the very same process that very same vm
and it actually facilitates the
communication it's a common
misconception that the communication
kind of happens directly and it doesn't
it actually goes to the vm to the end
it's actually kind of bridging the gap
between what java land as well as the
native life all right so just wanted to
point it out it's going to come in handy
later um so let's uh let's let's talk a
little bit about what NDK is and what it
isn't so for one NT k is a tool chain
right so I've done this work before
antique APIs existed so having native
code inside of your Android app and
basically what that meant was because
you could always do it from very first
day no vendras shipping you could access
native irj not the problem was cross
compiling your your C code on in my case
my mac for in my case arm
right so you need a cross compiler you
need the linker you need all those good
things and it just happens that those
things setting up the dose those to us
is actually pretty painful there's a lot
of work that needs to happen to you for
you to get the tow chain right indicate
serves the tool chain and silver platter
it's really easy to use that's that's a
single that's the second one of the very
important benefits of authenticate right
it saves you probably a good day you're
just setting on the toilet and the key
also provides a way to bundle your your
library into your APK okay that's kind
of like the bitter probably the biggest
benefit of it so when I did this before
and decay existed sure you can you know
set up your own tooling and cross
compile your code and you get the
library and sure you can call that
library from Java the problem was for
java to loaded like all right i don't
know how much you guys are familiar with
the was just with the file system of a
typical android device but just kind of
like really quickly refresh you your
your memory in that um in a in a typical
android device the your rom you're
basically your operating system is under
/ / system that is where everything
happens that's the you know the 100 to
300 megabytes gorilla that actually
contains a majority of your operating
system right of what we call engine so
so instead of that a partition there is
a folder called lip and that along with
those fresh vendor / lid is actually the
only place that the LD library path
points to that's the only place that
we're going to look for libraries okay
but the problem with this is that this
is mounted read-only this partition
right to assist resolve limits to use an
app developer or user for that matter so
to basically shirt if you're any of your
platform developer it's easy you just
stick your library and dare you call it
today you're done right but what if
you're not developer you don't you can't
right so where do you put your libraries
would gets loaded again so so that was a
hard part before nvk
I actually did not have a good solution
before i decay people companies I worked
with back then they actually CADAL
actually of shipping the entire Android
ROM so we kind of repackaged it into /
system / lab with indicate what did they
what they came up with is basically a
way to package it into / data the / date
is the partition where user data is
stored so as the user downloads you know
start using the phone you download apps
and play with the apps and all that all
those apps go into what the apps the
actual application is going to hear but
the applications data goes into / data /
data so this is where every single app
gives its own proprietary private all
sandbox or the file system right it's
just managed by you you know you I
decent gid so the linux lab just put it
straight for but inside of this these
every single application actually has a
little now they're almost always empty
but but all the apps are going to have a
web folder web folder Lib folder and so
all right so as you can see they don't
have all right so basically what we're
going to do is we're going to package
with the NDK we're going to package our
SL library so it ends up in this folder
of our particular application okay so
that's that's the gist of on the
packaging part of it um another thing
that indicate does it standardizes
native platforms so sure you know you
can access native but what libraries are
going to be available on that path right
so Samsung we had some different
libraries than motorola than HTC right
so ndk basically says look this is the
small set of libraries we guarantee or
that'll be there more specifically the
gathers right so they include things
like lipsy lib am lipsy live blog Jane I
graphics spoken GL Jane I standard
headers and some minimal C C++ support
all right so you can always there could
be more but this is what seems
guaranteed to be there from a
manufacturer to manufacturer but that's
what it means to be ended about right
now if you look at this set of libraries
they included you may get an idea what
they're trying to solve what kind of
problem we're trying to solve an MD
right so they're really hearing this
toward games at a lot of these libraries
get together with computational stuff or
graphics right so it's really for the
games developer game developers the most
what this is designed for and then the
chaos includes you know the sample code
and such um so why would you care about
them again so now that you know what it
is why would you care about well number
one reason is probably performance
certain pieces of code run fast donated
we're going to we're going to see that
today all right so that's good reason
the second reason is legacy support so
sometimes you just have a library that
you wrote of the year so it's C C++ and
you just don't have time to recompile it
or rewrite the whole thing in Java right
so you basically just want to wrap it up
in J&amp;amp;I and bundle it in and you know
call it today right so that's a good
reason as well sometimes you just simply
don't have access to low-level I burbs
the good example this was actually Bluto
right we get bluetooth in Android
devices from day one but we didn't care
of java api we cut it in 0.9 and then
they ripped it out before one point okay
mark the first standard ivelisse because
they didn't like the specification
luckily that was a good choice because
it wasn't very good right so we had to
wait until two point oh we have to wait
four years to get bluetooth available to
us in job but all along we can live the
bluesy library in the stack right so a
lot of people just basically bypass Java
went directly to native to get a
bluetooth stuff done so that was a good
example of using low-level libraries on
we another example is cross-platform
development I was actually pretty
puzzled by this one ah but you know I
kind of you know adopted job early super
early on thinking that you know it's
like portable language you write once
run anywhere right that's a big promise
of job and now what I'm seeing is a lot
of companies are actually writing brand
new code in C for mobile like wow I told
Java is portable right the reason why
they're doing that is because see they
can re compile for iOS or you know
different by the platforms like that so
certain companies
are using it for cross-platform
development nonetheless one thing I
wanted to point out is that using Jay
and I just because you prefer C vs Java
is not necessarily a good reason it will
make your application substantially more
complex more complex debug as well
alright so so be mindful that Jay and I
or ndk adds a level of complexity so you
gotta have a good reason to use a thing
to begin with on Java offers much richer
API offers memory protection all p
productivity all those sorts of good
things so you should you know just
because you only know see and you now
want to program in c on android and you
heard you can that's not necessarily
good motivation in the long run right
it's doable but but java usually has
advantage that but these other
motivations are usually good reasons to
to go with with a C or indicate for that
um so what I'm gonna do now is I'm gonna
kind of explain the process and give you
a demo of how we're going to do this so
basically it how do you use NDK well
this is sort of my block diagram of how
I would do it do it so basically what i
would do is i would write a java library
alright start there i would compile the
java library using Java Sea get a class
file then I would rerun the Java library
using pass it through something called
Java H there's Jay and I a job age is a
tool that ships with jdk and basically
what it does is it works for native
methods in your code and analyzes them
in figures them out and spits out a dot
H file header file alright so you get
the scatter fun right then you have to
basically implement your header file you
write a little make fall with pretty
much a boilerplate on a template and you
basically run ndk build on it this is
the torching and that creates the dot a
sofa right and then basically once you
have that you you're done with the
library now you will basically just
write some kind of code that actually
uses this library so we can see things
working now this is the implementation
using
she's right we can also use Jay and I
using C++ it's slightly different the
difference is that will receive right to
library we'd still compile it but this
time around we actually Donny together
fun you don't need a dot H bar instead
what we do is we use an approach by a
something called Jane I unload so Jane I
unload the special function that gets
called when dalvik loads your library
first time okay and then we would
basically implement that using a seat of
C++ file and and then what we will do is
basically compile it using the NDK built
the same tool chain so everything else
is basically the same so so basically
these are the steps that you would go
through building or adding native code
to your app I'm going to walk you
through both of these that steps in
detail and so you give an example in
this example is also available and
github and you could pull it down and so
you know you can see all the all the
steps if I'm walking through there
basically specified here now as instead
of just kind of going through a static
page I'm just going to open up my my
eclipse and actually write this example
to kind of and talk it through so you
guys can actually see this in action so
I'm going to start a new project so I'm
going to build an end with that and the
add that we're going to do is as an
application it's going to calculate
Fibonacci number right so the reason why
I picked up a notch is because it's it's
a nice little elegant this final
algorithm but it also gets really a much
slower really fast YouTube it so it's
basically it's an exponential algorithm
right so it gets you can see the
performance in performance differences
between C and Java so basically what we
are interested in is which one performs
that ok so I'm going to put you create
an app about 15 ated
acknowledge both fit short project i'll
say this is a marathon affair I'll take
matter on some some stuff here waiting
just a pillow world type of application
right we're going to assure have an
activity do I really need to pick up
image I'll skip that you guys know how
that works and then we're going to
create a blank activity we're going to
need some kind of activity just kind of
drive our code people it as a test for
us I'll just keep calling me so so far
we got a hello world write some code
can't really done much at all so on in
the past so I'm gonna rewind here to the
picture in the past I would start with
the CPC implementation but the tooling
the tender it provides for ndk as a
recent is actually much got much better
but really are 20 especially 21 release
of adt and in developer tools for
eclipse provides a lot of integration
for ndk development instead of eclipse
that wasn't the case before so a lot of
stuff before we have to do manual steps
command line that's why I usually lose
people right so what that c++ version
actually becomes quite easy in simpler
to implement so I'm going to start with
a simple spots but then i'll rewind to
see so I kind of show you both
implementations and one thing I wanted
to point out for I don't know if any of
you are doing platform level development
actually building underground messing
around with the actual not app level but
more deeper than app level on so the
Technic the things that what steps are
the same right you're using the same
technology same same everything and when
you look at it you're going to see a lot
of C++ you'll see a lot of simple
suppose files more specifically but not
a lot of C++ language okay android
platform so I'm not talking about an
atom talking to the entire operating
system they like sequels post but only a
tiny tiny tiny subset they used mostly
for namespace so you're not going to see
off much
object-oriented suppose was right you're
not going to see classes or anything
like that right so it's it's a it's much
more rudimentary sort of using the
language so I'm going to start with it
so basically number one is to define our
library so I'm not gonna so what I have
is the activity right now this is what
boilerplate code gave us I'll leave this
for later right so for now I'm just
going to start in the library so what
I'm going to do is in my source for you
know my java code i'm gonna create a new
class just a plain old android class and
i'll call it phablet so this is going to
be my java code which is really quickly
make the font larger so you guys done to
make mixed easier for you to read it so
so why not all right so that's a little
easier um so what I'm going to do is I'm
going to just define a function for
Fibonacci public public long tip and I'm
going to do a java version or native
version remember we want to compare the
speed so Java version takes a long end
right and for those of you who Tony
membership a notch it's basically if you
have if n is zero then you read simply
return 0 if n is 1 you return 1
otherwise you return people nochi java
of n minus 1 plus fifth of end times two
that's just how it's defined right you
can look it up on Wikipedia it's going
to picture that so that's that's the
java version now if i want to define a
native version this is where we're now
going getting native with this rate
we're outsourcing stuff from java to
native land it would look like this
public native long thin man of one half
and just terminal done right there's
nobody to it because we're going to
implement it in C or C++ um so that's
basically that's basically what
would look look so I say this file that
compile C so basically you know if you
look at a picture done with this press
save Eclipse compile it I got this file
right now what I would do is do
something that that basically showcase
is quite Eclipse integrates with
indicate so these steps before you would
have to do manually but check this out
in a clips now what you can do is you
can right click and so Android tools and
say add native support and simply asks
you what's going to be the name of your
library and I'm going to say it fine
we're going to call it Phillip Tessa
right oh and the key location is not set
up for some reason it always forgets the
NDK location this is a final bug when
you change workspaces when I do that all
the time so it's basically under android
and BK you simply get a point to your
NDE location which for me is MBK yeah so
why and that's not fixed so if i do step
these steps again and the native favor
finish now what just happened is the
following it's in professor still go to
properties Android NDK there's only one
thing to set and that's the location and
by the way I'm screencasting the small
talk so you'll be able to see this video
of words so just you guys know you guess
you need something um so so basically
this would happen the Eclipse gave us
some new boilerplate code and this is
that right so it's not much i'm going to
open each other so we get this fifth dot
CPP file and all it does is includes it
includes the J'naii dot H right and it
also gives us the make part right and by
the way you have these things also
specified in here me so basically so you
know this is the this is spelling out
into the same thing right so this is the
implementation you suppose was so what
I'm going to do now is employed to i'm
going to not worry about this file for
now the other states so what I'm going
to do is I'm going to implement the c++
version now the sequel is plus version
so like I said they use namespace right
and it's usually the name of your
package alright so my packages come or a
counterfeit it become Maracana fill and
you open it up right so now instead of
your namespace you define your function
so we have a function called coach fit
or Fibonacci right I can just kind of
come up with it I'll call it long fit
right long end right and I will just
define it i would say same thing is in
java if n is 0 return 0 if and is one we
turn one else return hey both n minus 1
plus tip of my skill alright so that's
basically our we learn so that's
basically that's right now one thing
that I wanted to point out is in my
Phillip you know just a little bit of a
Java there's an opportunity for
improvement namely this these functions
don't need to be dynamic they can be
static they don't depend with any of the
state of this library right so this
would actually be better if this was a
static long and similarly I can do it
make it static here all right so
basically that's that's an alternative
way to do that so so basically what and
then in Java what I could also do is
make this static I mean in silk start
now this is your pure see version right
so pure see right there's nothing
nothing Jane I ish about it however what
we must do now is we actually gotta wrap
it in j not ok so j9 because a funk
oh like i'll call it save me let me see
what would be the best way to call it
out fit pant for native so static now
Jane I has a special data types and I
did not include this in this talk
because it's it's a very long
conversation everything about Jane I but
we have a reference document on that and
basically we just kind of its public
it's available on our site i'll give you
a link later on but basically in Jane I
we map all the data types from Java into
a see equivalent and the reason for that
is that in see the size of an integer is
not known it depends on a platform right
so Jane I basically what it does is it
spells out the length of each pipe all
right so it's not arbitrary how long in
linq azure a long or short and so on so
basically my long becomes a J long in
the world Jana right so J long is going
to be the return type and so I'm going
to cap j long as input right now Jane I
also has two arguments that are always
there okay the first one is Jane I env
write properly okay the second argument
is either a class or a file about the
class or an object so since our input is
declared static and we are basically
this is basically a class property not
an object problem so the second argument
is actually a pointer to the caller so
since the caller is a class not an
object this is going to be a j+ you
typically we call it applause all right
that's a typical sort of naming
convention tourism so that's basically
my my
nine ish right so this is now Jane I
dapper okay and that's one is simply
going to call my secret my return babe
right now eclipse may complain about a
whole bunch of things here and if and
that gets do with the fact that it can't
find Jane I age and often this problem
is so very reading eclipse I'm serious
so let's see if I'm right but this is
one of the bugs that have seen before
and basically certain environmental
variables are missing when you add
native support so any the behavior is
different from Windows to Mac on this
one but as you can see the problem is
just gone alright no more prominent
those these mystics so basically it
can't find this jane i dot h and that is
where you have all the J'naii to like it
stops it's super important so so cool so
I have my header I have my pure c
function what we need to do next is we
basically need to provide a table that's
going to map an external type to it from
Java to an internal see Greta or Jane I
representation of this right and this
table looks like this I'm gonna actually
as opposed to typing it i'm just going
to copy it and adjust it because this is
sort of what you often do you don't
normally write this from scratch so let
me fix this and let me fix this alright
let me explain what this is so basically
this table maps what is going to be
known in java to what we have in c so
this is a pointer to that guy right and
this is how it's going to be no ninja
now this thing here is a funky signature
of this function so this business this
here means that our fibonacci n' in java
takes as input along and returns as
output along ok so this becomes so
basically because we defined it MC as
long pin and long ok the long translates
and you wouldn't know how transits until
you saw the table but there's a table
that we have ascended know it this is a
balloon to Jaina information it's
actually a Jane I documentation this is
actually because Jane I reference is
doesn't even come from our Android
course it comes from our Java course
because it's it's the same but basically
these are the mattox where you know a
boolean is Z by this be but there are a
couple ones that don't make sense like
a.j for long and so on and then some
become really funky right like if you
kept string so if you have a string
array then you get this business of like
l java /language livestreams kissimmee
column it just becomes like this crazy
sort of encoding of the signature of a
function you might have seen it before
and there's actually a way to have this
automatically printer figured out using
java p so if you do a job at p on your
code you can actually have it print out
the proper signature using this
convention but it doesn't make a lot of
sense this way you sort of go to a table
and try to map it to a table and that's
you could be going to use the reference
documents figure out what is what but
basically in my coat in our c++ code
this means this is basically the java
signature input this n is long output is
long the name of the function or method
is they ban right and this is the
pointer to this now we're almost done
with this there's one more thing to do
and that thing is to basically create
the so let me just going to show you the
table where we are so we are
here right so what we now need to do is
we basically need this Jane I onload
function this.j I on what function is it
gets called first time the library is
loaded and it's almost always exactly
the same that like two lines of code you
change so as such you usually copy paste
it so I'm just going to do that because
that it's not it doesn't doesn't change
from a project or thought so so
basically what I have in here is Jay and
I unload ok so I'm going to just
probably paste it from the course
material and and I'm going up for live
in here so let me explain what this guy
does and I there's cut one thing that
I've forgot i need to say that i'm using
using namespace on my panel right so if
i'm using that name space and then i
need to specify the path so basically
here what i'm doing is i'm saying for
this java library so in our case is
going to be this is just fit i'll use
this method table and the metal table is
this to basically a reference tough so
we are registering said the load time
we're registering a table of mapping
from the world of java to the olden see
that table is really here this is a
table it would grow right for each
function that you want to map you would
have a line item in here and it's
mapping a java type to a native type but
we need to register at some point and
we're doing that registration during J&amp;amp;I
on load which is a sort of a you know
it's a system call back gets called
initially when everything is loaded up
so my code is pretty much done in this
case what I can do now is as a matter of
fact you can't actually see it so my
code is pretty much done I just want to
explain the make file Android uses a
make system as you guys may or may not
know right this is twist to the platform
as well and so this make
all in nbk is no different than
gazillion make falls that you find in
android open source right of the end of
the entire platter basically every
single make fall in android starts with
the very same two limes why well because
they don't use a recursive make they use
a make that basically built a gigantic
main file right so they do a lot of
including clothing clothing clewd and
the reason why they do that is because
as such they may existing lends itself
nicely to parallel compilation because
it takes hours to build android anyway
so this kind of helps with you know map
reducing the project right there the
build so that's why you can have the
first two lines the last line basically
says what do you want to produce is the
out and it's always going to be there
the only difference is you may have a
different something here so build shared
library produces in s so file build
executable produces a bin file build
package produces a nap you know etc
setter they're careful of this kind of
target and then this is simply saying
compile this and stick it into that this
is the name of the module and whatever
you put in here is going to be a little
that dot s oh yeah so that's basically
what make follows so I'm just really
quickly now gonna so basically at this
point it's not gonna insert this tab at
this point what we have is we have done
all of this right almost a couple of the
things that are left for later now I'm
going to just work together this really
quickly so that you can actually see
this in action so I'm going to just
build the world's simplest you I bye-bye
basically deleting this here we need a
place to put a number right so number
BAM put a number here I'm going to
change its ID to input I'm going to put
the button so we can click it and so
sonic apples ID going to be go and I'm
going to add a text field for the output
which is going to dump the output you
know you know text right here and I'm
going to make that the large intestine
and i'll call this up and down so
that's going to be our UI to test these
things and only one minor thing that I'm
going to go do is I'm going to wire the
button so what I'm going to do for the
button is I'm going to save and drew it
on click on click so basically when you
click it call sign click so now our Java
code is going to be super simple as well
the activity right so I have edit text
input that's pure output okay organized
imports and meet this and basically a
public void on click gets cold with gob
on the buttons click so I'm just kind of
really quickly finding guys so into it
is going to be adding text right and
find you by ID are all those on the dot
input except i text you find you by dr
dot the dot output fine so organized
imports things good so what they need to
do is I need to part me to get me input
so long and is going to be long arsalan
of sparse long from input dot get text
alright so just really quickly together
that user typed in some number alright
so now we're ready to actually drive
this code right so basically what i can
do is now let's go java version first
java right so in java what i'm going to
do just testing so working so result in
java is so just long as elton dollar is
going to be fifth lip
dot if J of them right and I'm going to
print out so i'll say output go top and
i'll say string got format and i'm going
to put something like backslash n 50 a %
d is going to be % d and we're going to
put n comma result j right so just kind
of putting some output out there and
going to do the same for long resolved
and he's going to fold actually are
coming to south first big m okay so i'm
going to comment this out for now yeah
looks run distance it pours so this is
going to crash well it's going to work
for java but it's going to crash for see
so if i put some number 23 then there's
my calculation of energy for 23 right 26
damn there's a number right comparsa
good now if i enable my job is my native
stuff because that's exactly what you
want it be the first place right so I'm
just going to recoup all this view on it
see what happens so 23 go BAM crashes
there is why didn't trash anybody can't
find the library right so although I
have a library I never loaded it so
you're going to see this notorious
exception when you do anything like this
unsatisfied link here basically that we
can't find the library that's not
library it can finally bad as a matter
of fact it costly then right here but
then it doesn't resolve it talking now
its function table and can't find it
right so what I missing here is actual
loading the library now we typically do
this as a static which means that it
only happens once ever when java
libraries so when your java code is
loaded it then do does
this and what we do here is VA system
dot load library and then the name of
the library ok so now the name of the
library that you want is going to be the
name of the file not late 50s so another
common misconception that it's going to
be the name of the module which is a fit
yes the file is going to be a lip fav
daughter sir but we're loading a module
out of 5 so keep that in mind so if I
just say fig here ok by the way I don't
know if you noticed but there's a now a
new file here on their lives that has
look they've got this up right that's
our that's our ISO file that's what we
created so far on this now let's see
what we get 23 go I crashed again so
this climbing on I don't want my gosh
let's take a look it's not coming from
the winery I have any idea why fresh nah
I'll give you a hint i'm running an x86
version of the emulator so the library
that i compiled or the default library
delegates compiled is actually arm five
right so that's what what isn't here so
there's another file that you can throw
into your jni place jenna is where you
keep all your native work right that
file is super simple it's basically a
whole line file I'm see where we care
this template it's a one-line file that
specifies the seeming like this so it's
called application the 10k so what I'm
gonna do is I'm going to create a new
file here just a plain old file I flick
it up you gotta spell it properly
application thank a capital e ok and
this is the file where you can drive the
behavior of the toolchain so you could
for example say I want to build for x86
arm-in-arm 7 for example
or you can just save all and it's going
to compile for all known to change that
you have in you and decay now you may
have only one but you may have like four
for example so if i run now notice
what's going to happen in my lip folder
actually have now the same library
compiled for maps x86 on five on our
seven different architect right so i
applied three different 2 chainz which
is pretty amazing so so that's that's a
pretty cool little benefit right so if I
rerun this 23 you go all right there we
go I got the number 40 native any job
now you guys never cared about the
actual how you know the number right of
course they're going to be the same
because they're the same all director
night we care about the performance so
let me just really quickly find this so
I'm going to say a long time is going to
be assisting the point I'm milliseconds
time is going to be system I'm illus-
time and I'm going to print out here %
dms on a time do the same thing here on
this reverse and be honest all right and
let me do surround this with a primer so
this is native right all right so let's
now run this again and see what kind of
time difference we go so 23 then this is
a pretty pass section 23 Lloyd 27 now
keep in mind i'm running a uber
accelerated version of x86 device so so
it's you know it's it's pretty fast to
begin with 33 yeah so as you keep
getting you know that's what i like
about this algorithm the numbers become
fat you know increasingly slower as you
add
a little bit so as you keep running this
you can you kind of see you start seeing
some patterns right so you know these
little patterns right so you start
seeing about in order of magnitude
difference between C and Java in this
particular order okay but but this has
to do with the fact that it's a
recursive if I actually did I don't have
time to do this but if I I'll because
everything recursive can be done
intuitively if it did this iteratively
the numbers you would have to time it in
nanoseconds because the difference is
you know their way faster right but the
numbers become much much smaller less
less of a difference right so doesn't
mean that Java is always 10 x 2 x width
DX lower right it's just concern
although this one may work better than
the others yeah you get a question oh
yeah it's going to be different yeah
it's going to be different in a better
way to if you if you guys earned if
you're familiar with the DBMS but if you
if I touch DDMS to this and I start
tracing profile in my app and around the
same thing I'm going to go with a much
smaller number because this is going to
run slow to begin with the reason why
it's not as extra slow is because i'm
actually doing analysis on it as we keep
on going to dalvik is actually
collecting a ton of data to begin with
so that's not it's a small number 27
that's flow before right but now because
of the tracing its actually we were slow
and now it's done i'm actually going to
let's see what we get as the as the
trace ball on this one but it's going to
be quite interesting to see the
difference between the two algorithms
once once pops up eventually just take
some time to analyze this all right so
here's the trace information so
basically in what every once in a while
I don't know why as basically the
graphics disappear so you can't really
see the you can't really see visually
what I'm talking about here that's a
bargain but there's my call I guess if
you click on it it kind of hints were at
this but basically between those two
points where I did my execute
50a took basically ninety percent of the
time right so C was like loved one less
than ten percent of the time and in for
that number whatever the number was I
forget it executed we basically had one
call + 260 9000 recourse except calls
right so that that's kind of like why
you know Java is not naturally not good
with stats it's better with registers
it's the opposite for arms so that make
us may have to do with that but that's a
little bit about you know the
performance difference on so you
remember performance is one good
motivator motivations why you would care
about anything just really quickly to
give you guys the sense if I was going
to do this in a simple spots it's not
that dear friend but they don't but it's
a little bit a little bit manual so what
I would have to do is I've got to go to
end that corn Fibonacci yeah that's our
project so this our project so i'll get
to run java age java aged FJ night to
get that header file and and because it
doesn't know my classpath on the here
any to specify my class that which is
going to be in classes because that's
what I clubs keeps it keeps your classes
with a compiled and i would need their
like the output to Jane I folder because
that's where we keep all the app so the
file that I want to process is calm all
right Ron not file by the class favor
1151 right so so what this does if I
didn't mistype it is this tool basically
goes and opens up this java file and it
basically reads through it looking for
only the keyword native when it sees
keyboard native it actually creates a
signature for me but if you notice that
now there's a new file which is the
header file for see okay so this is the
file that Java age created for you
now in this file which you really care
about is just this signature so if you
were doing this you see you would copy
paste the signature you would create
another file called Java you know let's
go it tipsy so it's going to be my sefa
okay this one I'm going to implement
this I'm gonna eat fun include the comm
Maracana tib fib fib glib dot dot page I
forgot my quotes okay and done and then
what I would do is basically implement
this algorithm here since you ready
gathered implementation is going to copy
paste it so remember our algorithm was
in pure see just this pretty
straightforward so then the suppose the
sea version would simply call that file
when we reformat this and return we'll
turn table off and write three four
months now it doesn't know about your
private or names so you have to kind of
give you a name so he and B this is
typically class and this is our and okay
so that's my c version now i just need
to change in the make file not to UCB p
but do you see version it's actually a
lower that way and if I rerun this now
we have the same out same thing but this
time around it's in using the C
implementation versus the civil civil
was awesome there's a difference between
three the difference is slight in c plus
in c version keep in mind so the main
thing the main you kind of magic behind
this is Jane I that's the card part
right I'm just telling talking about MDK
which sort that wrapping the packaging
it's an eight development kit it's a kid
around Jane I if you only want this
really well you gotta understand jayna
so Jane eyes a naming convention so
basically how does your Dalek Java fine
your dalvik see right that's what is
going on so with C version it
looking when you say I want to call fib
n it looks for java underscore your
package underscore your for your
class underscore you've method it's a
naming convention so it finds in every
single time via this naming convention
right so every single time there's a
lookup based on a convention yeah so
you're paying a price tiny price but
twice nonetheless every single call okay
now with a c++ version it slightly
different there is no look up every
single time because it's a pointer we
define a poner table but we pay the
price up front because we had to
register the table by Jane I on work so
we are paying the smaller panel you are
paying a penalty up front but getting a
2d benefit every single subsequent call
sort of ready so Android platform tends
to use C++ this approach this very
approach like you could copy-paste this
Jane I unload that's what is in handling
everywhere right do they tend to use
this quite a bit as the approach to
basically load load the bit of the
closet and so in this code is executed
when you do this guy when you basically
when you do this call here it only
happens once that's what causes Jaina
mot okay so so that's basically the this
example the Fibonacci example I just
gonna want to wrap it up with you know
Jane doing stuff in Jane I can be a
performance boost for your app it's not
always the case and it's kind of like if
a project is really small you're going
to pay the penalty of not owning more
complex development time so not only you
know is your your carbon cycles but also
in terms of the silicon cycles with
computer cycles you're going to pay the
penalty in terms of the bridge the J&amp;amp;I
bridge this local right so it's kind of
like outsourcing right if you have a
tiny little project right like if I get
a bigger project it makes sense to
outsource to india china someplace where
they're more efficient than getting
stuff done right but if i give a tiny
project like writing an email
the overhead of outsourcing that project
but you know is big enough that it
doesn't make up for the difference in
efficiency way on serves it though so
don't alter small projects to see big
projects make sense make sense like for
example drawing you know big graphics or
like you know it keep using angry birds
as an example Angry Birds uses this kind
of you know let there's lip Angry Birds
s so I don't know if you ever looked
inside but there is and they use it for
there you know physics engine for
calculating the trajectory of the bird
and other kind of computational stuff
like that so in that sense in that case
and became Jane I make sense so that's
basically the gist of this that we
covered all the source code is in here
and that's the summary I posted this
article online and I'm going to provide
a video of this article as well as the
stock later on just just so you know you
guys know and just one think that wanted
to mention make sure if you're looking
at this also look at the post on jane
eyre jane i reference for which i'll
give you the the shortener which looks
like this right so that's also super
useful so you know how to obtain I works
yeah you had a question the question is
can you have a seat call back into the
view itself so the sea has access back
to Java via that either J class or J
object so basically you would again yes
you can call from see back to Java but
it would need to go to the wrapper right
so you need you you would provide you
know how to call that couples in
actually in this article we talked about
that there are examples of how SI falls
Java it wants through introspection so
basically see now needs to find a class
than in the class needs to find a method
and so on and so on one thing to watch
out for is when you updating the UI is
that you gotta do it on the UI thread
but in this case everything is actually
running on a UI thread oh let's see I'm
running it from my thread from from the
main threat so there's no tradition with
what's all right but keep that in mind
in general it's not
which is C updating java you I or
Android UI it's more of a which thread
is updating the UI thread so yeah well
well thank you guys I'll make the video
available afterwards so slides available
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>