<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Adventures in Single Page Applications | Coder Coacher - Coaching Coders</title><meta content="Adventures in Single Page Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Adventures in Single Page Applications</b></h2><h5 class="post__date">2012-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BqDJqKGfIiE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody my name is Nikita Takara
um I'm here to talk about on the topic
of single page apps with this title
let's get started and I'm not gonna like
start going over all right what is a
single page app I'm just gonna assume
that you guys know what that is it's
been out there for quite a while
technology's been out there and just
start off with like the reasons why we
write single page apps I mean obviously
the first one is just rich interactions
because if we don't have any J s running
on the client side we're not gonna
actually have access to the arm to the
events that we would like to have such
as like a mouse click down like you can
access that I mean you could have links
without J s but otherwise it would be
impossible responsiveness so the speed
of light imposes a certain limitation on
latency if you do your rendering on the
server and obviously that's gonna be up
to hundreds of milliseconds and that
becomes kind of unacceptable even if we
could do things without writing like
single page applications finally like
the third reason I think we write single
page applications is reuse at least
hopefully this has been the promise for
a long time that we can avoid
duplicating logic that we can write or
we can describe our views once we can
describe our business logic related to
views and models once and then we can
just use that both with note both on the
server and on the client side at the
same time there are some reasons why we
avoid single page applications right I
think the first one is like lower
productivity so as I said like I said
that reuse would be one big component
but but at the same time with the
current approaches that we're using it's
still kind of more like right once on
the server and then once again for the
client and that's well I'll get into the
details a little bit later testing is
also harder as Frey says not sure if app
runs perfectly or test framework is
failing
the when we have single-page
applications often they only run on the
client-side on the browser so then you
end up using something like headless
webkit for for actually running your
tests and that's just not like a
seamless way to interact with your test
code or with your code because you're
not gonna know why is it failing and
you're not gonna get that API access
that you might want the time to
interactivity is lower so even though we
can respond to like user clicks faster
by triggering a render on the
client-side and updating that
information the time it actually takes
to load a single page app is still some
somewhat of a barrier like you think
about Gmail and you know you see a
loading bar and you see any any other
like fairly large single page
application there's always going to be
some amount of time involved where where
you're just waiting for the application
to load up its resources load up its
data and stuff like that so the time the
interactivity kind of suffers and
finally the pages can't be crawled so if
you curl a single page app you'll often
just get like an empty page and nothing
is gonna get rendered and that's not
necessarily a problem if your clients
have JavaScript enabled but but many
search engines don't or if they do
there's really no predictability whether
they're gonna occur whether they're
gonna be able to crawl any of your
content my starting point here for the
talk really is current best practice so
you could think of backbone and jQuery
or you could think of like ember or
angular or any of these other frameworks
which are very good and which solve
certain sets of problems but at the same
time as I mentioned there were some
weaknesses that we currently experience
with single page applications and in
order to actually move forward and try
to address some of those issues we
really need to get rid of some things
that are considered current best
practice like MVC namespaces templating
and I'm just gonna present a few brief
arguments on that and then in the second
part of my talk I'm just gonna talk more
about some of my more recent work
which has been related to solving those
issues that I mentioned earlier by doing
server-side rendering by doing
snapshotting by doing using various
techniques so what's the ideal codebase
I've been kind of trying to think about
this for quite a while and and well I
mean we're somebody said we've built
things that are more complicated than
the apps that we're currently building
we've built like bridges and we've built
aircraft carriers and things like that
and the difference between these like
really physical things and the the
applications that we often build is that
the failure modes are independent and
that the different functionality of of
real-world things are not usually
interrelated like if you build an
aircraft carrier
if the toilets overflowed you're not
gonna launch the missiles because the
missile system and the toilet system are
two separate systems they're not
interconnected in any way and this is
not necessarily true of like a lot of
applications where failure modes can be
linked and where different modules are
quite tightly coupled so they fell in so
they don't fail independently and really
this is about complexity right it's it's
it's a and I define complexity just
simply as code that has remote inputs or
remote effects the idea being that if
you're running a piece of code and then
you depend on something that happens
somewhere there and you're not really
sure what the connection with that
somewhere there is then you're you're
gonna have either remote input or a
remote effect and with like a good
codebase ideally we need things to be it
was it should be possible to load things
independently it should be possible to
test things independently and it should
think should break independently and
this is kind of a prerequisite in some
ways to to solving some of these
problems related to times interactivity
related to being able to pre-render and
package things in a smart way so so
that's kind of why I consider some of
the so-called best practices
perhaps not ideal or
at least worth re-evaluating a little
bit so what's wrong with NBC here in the
diagram well you'll just see like the
basic way we describe MBC right so
marbles are the single source of two
truth views observe the model changes
and then we have controllers that
receive events from the Dom render
templates and keep using models in sync
and all this is kind of uncontroversial
right so we have MVC right we have model
which is data and view which is
presentation about what is the
controller is it something that routes
URL fragments to methods it's something
that coordinates a set of views is it
something that coordinates a Model View
pair is it something that handles arm
Dom events for one view
I really don't know the word controller
has gotten like way too many different
meanings we're very familiar with the
with the acronym MVC because of all the
work that's been done on the server side
but that doesn't really mean that it's
productive to actually describe
everything as MVC you could say that a
that a horse is a type of car because
you know you're familiar with them with
horses or we are familiar with cars and
not familiar with horses either way but
that doesn't mean that that that
terminology is necessarily like makes
sense in that context so I mean this is
quite a few responsibilities right you
receive events from the Dom you render
templates and you keep views and models
and sync I mean what does this exactly
even mean and well I mean I understand
why we want to have MVC it's because
when you say MVC people are like oh yeah
MVC but like it's not necessarily
applicable to this to the the
client-side problem and here's my
definition of a controller it's an it's
a it's a familiar word that makes
writing glue code sound like a design
pattern so you know you take controller
code you replace it with the word like
glue code and and you'll be pretty good
and and the reason for this really is
that client-side is more like having a
lot of models having a lot of views and
then when you put in the controller it
becomes
of confusing your it'll have many models
and many views interacting on a single
page and they'll be interacting for a
long time and having those controllers
between the model and view they be
easily become like magnets for
housekeeping code for glue code
basically because it's it's easy to get
tempted to let's add another method that
knows about these two models and these
two views into the controller it seems
like a good place since you know and
it's MVC and we should have all the
three different components but that has
a lot of disadvantages because it makes
the code harder to separate into
different parts it makes it harder to
test because now a lot of your code is
in one thing that depends on like a lot
of different other things so you end up
having to write like integration tests
where you would have been wanting to
write unit tests so I think controllers
must die like when you have one request
in one response it's fine because it
doesn't really matter what kind of mess
you create when you're like writing ad
hoc like I almost think of it as like
writing CGI scripts like where you just
get a request and then you can do
whatever and the main thing is that you
return some HTML back but with single
page apps we have a persistent state so
we're not we're not just trying to like
run a one-off task
we're trying to set up the world in a
particular configuration and then we
want to keep interacting with that world
through like user events so we might as
well try to replace controllers move
that code away into different places and
try to rather have like generic
mechanisms that would arm that would
solve at least some of these problems so
I mean you can't avoid having glue code
right but you can't at least move
towards the direction where where most
things are mediated by mechanism rather
than mediated by I will write this this
case specific code for this specific set
of Model View and controller
and this is like what I called our
modern-day Lego we have a thing the
thing has a public API and the thing
emits events and this is like just a
basic building block that we can use to
build almost anything and if we start
thinking in terms of these reusable
things rather than a one-off scripts
things get easier we can put those think
pieces together and I'll talk about how
in a while but the general idea being
that basically you just have one stage
where you connect these two things and
then they interact with each other
through events and through their public
API s and that basically means that that
that the model doesn't have to know
about the view the view knows that it
can take one model or X models but
doesn't need to know what the specific
models are and so when you get like an
user event like a click that becomes an
API call on the model and then that
returns an event on the model that's a
change and that updates one or more
views which then is reflected in the Dom
so forgot API is and events and then
we've got bindings for those things and
the benefit of this is really that then
our code base becomes more separable
into different pieces so we can test
unit test reviews we can unit test our
models separately from each other and
there is no like sanctioned place for
code that like collects different
dependencies so you're not gonna have
like a place where you'll get tempted to
to add more knowledge about oh this
specific view and this specific model
with these specific names will be
connected like this instead you know
you'll have things that will be
connected to each other through events
and through API calls namespaces
probably if you've ever read anything
about JavaScript organization you'll you
have run into the recommendation of
using namespaces
I'm here somebody's saying you know it
keeps my global scope clean it enables
namespace a you know provides a nice way
to separate public and private methods
and fields and I say no
the problem with namespaces really is
that choice is about privacy have to
meet on a global have to be made on a
global basis so you only have basically
two choices one is so let's look at this
code so we've got my app food up bar
which is something it's got a public
function called do bar and then a
private utility function and in this
case you know you're just assigning it
to my app foo bar so so the private
utility is globally public or you can do
this one which is basically you've got
an a closure again wrapping that module
and private utilities with in that and
now it's globally private so it's hidden
from every other possible user of that
piece of code but what we with but what
this means basically is that with
namespaces we need to we start exporting
things into the global scope because
that's the only way we can like have
this thing here and this thing here
reuse the same functionality or reuse
the same code and that creates
complexity because now this guy knows
the name of this guy and this guy knows
the name of this guy and now most of the
code has like remote inputs and remote
effects and there really isn't any clear
structure right so you run into timing
conflicts where you oh we didn't load
this thing before this thing because it
depended on whatever these kinds of
issues so so that's what I see is the
problem and what I'd really want with
with as a replacement for a namespace is
something that would actually enforce
information hiding so in all P terms we
have public and we have private and we
have like globally public globally
private okay but what I actually want is
protected so I would want something
where code that is related to the
private you to can access that and by
related I mean it's in the same
subsystem whatever that means for your
application
and code that isn't related to it has no
access to it at all
and this is of course modules and you
may have heard of common Jas and AMD but
I'll just quickly define what modules
are I mean modules are basically it
dependent pieces of code that can be
loaded and this is the key part in order
to hide the implementation details
behind an interface and that's the part
that people usually miss nodejs has its
own built in module system so my
approach to this has always been just to
write for nodejs and then have like a
packaging solution that makes that same
code available in the browser but so
what is a module really basically
basically a module is something looks
something like this right you have a
thing that is a module you have some
dependencies like jQuery you're
requiring it through a require statement
rather than accessing it by like through
a global namespace or something like
that you have something that's defined
there might be maybe a class might be a
set of functions and then you have a
single export statement that takes that
thing and returns it back so basically
by default everything within this module
is is private except for the thing that
you assign to modules are exports so I
mean it's a convention it's a convention
for saying oh these are the things we
depend on and it's a convention for if
we have one thing that one thing only
has one public interface so isn't this
the same thing as a namespace well not
even close first of all the default is
privacy so you have to explicitly say oh
this is my public interface so you don't
really accidents
things don't have global names and all
of the dependencies go through require
so you can actually have policy that are
that that is in force on the require so
you can impose privacy and most
importantly modules can be composed into
packages so even if you're familiar with
them AMD you might not actually have
seen the whole packaging part so when
you're moving from modules to packages
modules without any hierarchy are
basically just fancy namespaces right I
mean they do impose more structure than
namespaces they do impose the discipline
of using a required statement
and only having one export but but
packages are really the where it's at
packages are like hierarchies and
modules so think if each module is a
file you put them in a directory you
decide that one of those modules is the
index for that directory the thing that
determines what gets exported out of
that directory that is a package so it's
it's a set of modules behind a single
public interface so several modules
behind a single interface but also
several modules behind a single HTTP GET
so I mean a package is just a concept a
structure that you could load with a
single arm HTTP GET and when I'm talking
about index.js it's basically just
another module this time just a module
that exports something out so it might
export the foo and it might export
another function and everything that's
not exported is private it's only
accessible to modules within that same
package and once the package concretely
so it's something like this it's a
closure right it's something that
defines a require statement so that you
can use that requiring your modules
it'll contain the code for several
different files and finally it'll have
like something that assigns something to
a global so window dot my packages
modules index j s the idea being that so
we're taking the the exports from from
the index j s and then putting them on
accessible underarm window dot my
package as a single global so what you
go into that index j s well ideally very
few things it should be possible to load
the package without anything happening
and what I mean by that is that the
modules within the package should be
should only define things not create new
states so if you think about an object
definition right and then you have an
instance of that object you should only
define the objects but not never create
instances of those objects any code that
creates instances of objects or alters
the global stage should go into an
initialization script which I call init
and in it is like the guy who sets up a
particular stage
it creates variables it creates
instances of objects within that module
it sets up the module for sets up the
package for for use it might let's say
that the package contains some views and
some models it'll initialize those
models it'll render some views and then
it'll say oh the UAE's waited to model B
and then once it's done it just gets out
of the way doesn't it's not involved
with any of the interactions after that
it just initializes those views and then
gets out of the way and this means that
you could have like a different kind of
setup right because the views the views
themselves don't have any global state
so you could set up like different kinds
of arm test scripts that would actually
set up a different kind of interaction
like for a unit test or for a different
kind of interaction integration test and
the idea here is really that we isolate
the side effects or the nasty bits into
one place so everything that creates new
variables is in one place if you need to
figure out how does this package work
how does what happens when I initialize
this package you just read the init
function and you're not gonna be
surprised by something that you know
creates an instance like every time you
access something it creates a new global
variable or something like that like
nothing that should happen and this
makes possible to create our unit tests
and that do different kinds of things so
it's all about information hiding rule E
and this is something that a lot of the
packaging solutions haven't gotten right
that the most important part relays the
information hiding so packages really
exist so that you can hide the
implementation details behind a single
interface and you can still share that
code within the package so all I can say
is make sure you use a system that you
know actually creates packages and
enforces this kind of information hiding
and there's more on this topic on my
book as well
bluejay s is one a packaging system that
I wrote
just gotta like simple command-line
interface you just include a set of
files you'll say oh I want the output to
be this filename
I want the global to be called my
package and then if you do require
jQuery I want that to return window dot
dollar and it creates a package out of
these different modules and then make
sure that that the output gets exported
under this global my package and it's
based around basically just like having
normal common jas node based modules
packaging it really isn't about
performance it's about maintainability
so so it's really important it's not
something that you can just say oh we
won't do any packaging because well we
don't care about the performance right
now it's more again about hiding the
internals and there are other options
you can use AMD which there's probably
been a talk at this conference about and
definitely there's info online as well I
think it's mostly a bike debate
the real thing is really just organize
your code using modules and packages
so templating was one of our good ideas
instead of rendering things on the
server we'll have a set of templates
that when you give them some data they
turn into a string of HTML and then
later on we know we'll manipulate that
HTML through the Dom or jQuery and I
mean this is the basis recommendation I
think backbone gives you right there
they have a very very minimal view that
doesn't really say anything about what a
view layer should do they've got their
models but um and and so this is where
you end up often you'll just write some
templates that manipulate HTML and then
you have a controller that does like a
one-off tasks that are that manipulates
that HTML in some way and you so you
think about a a web page or a single
page app as a series of string
processing tasks but the problem with
templates really is that you can't Lin
ask them and there's a lot of manual
work involved in in rendering them in
passing data to them in actually binding
Dom events and making them interactive
so I think declarative views and
bindings are actually the way to go and
I'll talk about those a little bit more
later on so here's the state of the art
and I'm hoping I didn't go too fast you
have entangled controllers so you rely
on controllers that coordinate very many
different things that run days one-off
kind of tasks which leads to kind of
having big integration tests you don't
you end up using namespaces where you
don't hide in front you don't hide
information like the implementation
details of views or models so the code
is hard split into small pieces hard to
unit test separately and it's hard to
load independently you have templating
that requires a lot of housekeeping so
the views can't be rendered on the
server or if they can it's it's a
one-off process again it's it's setting
up some templates it's setting up some
namespace it's setting up some
controllers and it becomes kind of quite
tedious so
having covered some of that base stuff
basically controllers must die
namespaces replace them with packages
and templates are like force you to
write too much
housekeeping code I'm just gonna have a
look at like where I think we're gonna
be going hopefully towards a brave new
world where we'll be maybe applying
these concepts constructs differently
and trying to solve again some of these
basic problems so again I started off
with the reasons to avoid single page
applications right the the ones I listed
were lower productivity testing is
harder time to interactivity is worse
and the pages can't be crawled and I
think there's like a benchmark for all
of these for lower productivity
basically I would be a happy man if
writing a single page application would
be as simple as writing an HTML page a
basic HTML page when it comes to testing
I'd be very happy if I could use mocha
or just like run things run simple tests
from the command line have them complete
fast not have to worry about like
running a headless webkit or some other
browser emulator in terms of
interactivity basically static pages the
best we can do right it's something that
we've written the HTML in advance
there's no JavaScript running the page
just returns and you can immediately see
the results of that page and then in
terms of quality well that's actually
related to the whole static page thing
where where static pages work would curl
but single page applications don't view
JSON is basically a view layer it's very
alpha quality it's not public yet that
I've been working on it works with
backbone it works with something called
a bundle model which is just an
alternative model layer I've been
playing around with the rest of the talk
is really about the ideas behind it
which you should steal as much as the
library itself that's not quite yet
public it uses a bun
- already public modules that I've
written for support including gluteus
and some other things so what are the
problems that I'm trying to look at here
when I'm thinking about how are we gonna
do rendering for single page
applications hopefully in the future one
is productivity just basically just
trying to get to that HTML benchmark or
that benchmark of the ease of writing
HTML page across environment rendering
or testing so I would like to be able to
run my views in node and just have them
return that markup that I wrote before I
would like to be able to test them in
any environment so I will need to have
run a browser separately and I would
like to have instant interactivity so I
would like the page to load as quickly
as it can and I would prefer if that
page would also be armed crawlable by
search engines in other words that it
would actually show something useful
even without JavaScript turned on not
necessarily worked perfectly but well
enough for a search engine and now
there's a lot of components here to
cover and I can only give you like a
like a brief overview of these different
kinds of things but I covered these kind
of things on the on the Left earlier
there's an init script there's a Marvel
there's a view you've structured your
code so that these things are reusable
and then there's a set of mechanisms
that lives around that that actually
makes it possible for us to have fast
render times to have fairly productive a
fairly productive environment to work in
and these I'll talk about in
individually so productivity again you
should feel as productive as HTML the
approach that view Jason has taken is
the one that many other frameworks have
taken which is basically uses
declarative views and bindings a
declarative views basically you say what
the computation that should be done is
and not how to compute it in other words
you say oh I've got
this piece of HTML I want it to show
this model and that's it you don't tell
it how you will show it you just say
alright I want this piece of information
to be shown here instead of the way in
which you do it if you dried it with
jQuery which would be you know when X is
at a creative element assigned value
blah blah blah like you tell tell it all
the steps and that's just because like
in most cases we can just kind of use a
few fairly simple patterns to to show
information and we don't really need to
be writing all this housekeeping code so
the idea here is basically that you'll
say specify binding between the data and
the HTML using some sort of names so
you'll have a view right the view will
refer to a model by name there's going
to be a name resolution bit that takes
that specific model and then it creates
an event registration on that so the
thing on the left basically happens when
you instantiate a specific view and then
the model data changes while the model
runs triggers that event and runs the
registered code and then the view gets
updated it's quite simple but in by
reducing the interactions to between the
view and the model to this it becomes a
lot easier to actually do rendering on
the server side as well as on the client
side here's an example of a declarative
view right there isn't really like that
much to add the idea being you know you
bind some name here it's - dues it's a
collection and you want the title of
that of the models within the within the
- dues collection to be shown and that
will render like a list with the items
that you want it to have there so you
don't really have to go into the details
of okay well if a to do is removed if
we're to do is add it what are you going
to do it'll just update itself based so
that it reflects the content of the
collection and again this is not really
cutting-edge stuff right it's it's
something that has already existed in in
other view rendering or view layers it's
just that being able to do is on the
side and there are like three kinds of
declarative views that you can reduce
things to so one is you know I have this
thing that reflects this data so I just
need to render you know the name the
title whatever and there's I have this
group of things and I want to show that
collection in this place so you have a
collection view and then the third one
is you know you have an if statement
basically you have a piece of logic and
you want to show different things based
on the result of that expression and so
a lot of problems really reduced down to
these which is kind of obvious since
it's like a variable a for loop and a if
statement right and that's what we use
the program so so declarative views can
definitely go pretty far in representing
like the different kinds of things that
we want to show in single page
applications mutation does some things
differently so it's fairly node oriented
or it's fairly JavaScript oriented
really a you can just take something
like a a template and compile that down
and and the result of that is not
actually a a function about a actual
object or an actual object prototype
definition that is instable so what you
get as the result is basically an object
that you can say alright new view and
it's got a render method and it's got a
few other helper methods but beyond that
but beyond that that it's just a normal
object like a normal neck es3 prototype
object rather than like somebody's
interpretation of what class inheritance
should be and you can run it inside node
so you could actually just instantiate
it and then console.log it and it'll run
in either the server or on the client
and the general idea being you know you
have some markup you've got a view
compiler the name view JSON really comes
from the idea that all the views compile
down to JSON which is like used as an
intermediate representation and then
that JSON compiles to actual j/s objects
this is basically mostly so that if you
want if you want to like add new things
to your view markup or declarative views
like new expressions or
internationalization or things like that
you can't you have a place where you can
do that so we want to do cross
environment rendering we should it
should be easy to test the code and it
should be easy to render a view as a
static page so and the same code should
run everywhere so the way i'v approaches
this basically to reduce Dom
manipulation directly and instead use
these declarative views that have like
fairly well-defined
interactions and then use shims that
change the rendering environment and
allow you to run the same code in
different environments so your the code
that you write stays the same but the
code surrounding it changes now what is
a shimma shimma is just a small library
that transparently intercepts an API and
handles calls appropriately so in the
case of view JSON you'll have like you
have like a jQuery shim and not old I am
which is basically a jQuery les frame
requests view that basically just uses
like some of the newer api's that are
not available on all dieese and then
translates those into Dom operations
you've got a node shim that allows you
to run those same views on the node side
and a debug shim and just to get an idea
of alright what is happening how long is
this taking and so on and so the
rendering basically just proceeds from
getting in events that's intercepted by
a view the view has certain a certain
API that calls calls of shim functions
and the shim functions translate that to
an HTML updates on the server or on the
client side and just by swapping the
shim you can just get we can render the
same view in different environments
whether it is in the browser or on the
server
finally like this instant interactivity
so we should be as fast as loading a
static static page again it can't change
the speed of light but we can think of
two questions the first being what is
the least that we can load and the
second being was the least processing
that we can run this is where the
packages stuff that I talked about
earlier comes kind of handy because once
your application is structured like that
you can basically say oh okay I have
this core and then I have my current
activity I have my current view that I'm
that the user wants to see based on the
URL that we're getting and then you can
say oh okay well the core will probably
contain like jQuery and maybe your model
definitions and then the package for
that specific thing that the user is
viewing will probably contain like a set
of views maybe some model data and some
stuff like that but you can load a very
minimal amount of the code because you
can just say okay well as long as I have
the core and I have the package that I
need for this functionality that's all
that's really needed so you reduce the
loading times from having to load like a
full application - okay I've got this
neat partition where I can just load
this part and then if I need to load
like additional functionality I can do
that in the background later on but from
a user perspective the experience is
better because there's not just that
much data that gets transferred the
other part is state snapshotting which
is again something that's provided by
the framework something that's available
as a separate module as well the idea
being basically that you can run some of
the processing you can render the views
or you can fetch model data you can
serialize that model data and then have
the results continue running on the
client side and then pre-processing or
pre-rendering again currently a lot of
the the frameworks ship a templating
compiler to the end user they might
support precompilation but then still
there's a lot of housekeeping involved
a lot of the like the load time that
that a single page application spending
when during the initial load is really
not just like loading the framework but
also realizing oh this model depends on
this thing so I have to fetch more and
more data from the backend before I can
actually render anything
so by pre rendering and by using Snape's
state snapshots you can just send that
data directly and you'll be confident
you can do the initial render so that
you have the base set of data that you
need
so with snapshots you can start running
the code on the server and then say okay
well I'm gonna send this as a snapshot
and then continue running that on the
browser and with pre-rendering you'll
just sort out the the HTML part where
you take that view you render it as an
HTML page and the result already works
even if you don't have JavaScript
running or even if you are a search
engine that's crawling those pages
you'll still get that HTML and it'll
then then the the time to initial render
initial interactivity becomes a lot more
predictable so again an init function
that sets up models and views this
happens on the server side the models
can get or the model data and the models
themselves get put into a snapshot and
then they get on the client side they
become just J's variables and the view
you use as shim your render it as HTML
you send that HTML with the initial page
load so it'll look something like this
right so you'll have like a core that's
jQuery and framework and whatever you'll
have the current package that defines
you know the views that you're using
here then you have the snapshot of that
data or the of the code that you were
running on the server side and then
you'll have the current HTML that you
rendered on the server side meaning that
the initial render time goes down quite
a bit
now when I say pre-rendering it's not
just like oh we've got a template and
we'll render that thing it's also the
just just like a full emulation for
those for those view interactions so you
can actually interact with the HTML
elements you can add new things to
models and all that gets reflected in
the HTML so it's not just like sending a
precompiled template it's it's sending a
real HTML and then the viewstate
associated with that HTML so you can
really continue executing from where the
server left off and snapshotting I'm not
talking just about JSON rather like a
more comprehensive serialization where
you know if you create a data object you
get a data object back you create a
regular expression you get a regular
expression back you have models and
collections you don't get like JSON that
represents those but you actually get
instances of those models and
collections on the client side and you
can have references to different objects
and those will be stored as references
so if you've assigned an object as a
property you'll get that property back
so there's it's it's it's kind of like a
more comprehensive way of serializing
this kind of data which allows for this
seamless oh okay server left off here
client continues here so I've looked at
all these different parts a little bit
but I can't I don't really have enough
time to actually go into like a lot of
depth but so how big is this thing how
bad is it
the view layer is 400 lines of code
which is kind of surprising but it is
really possible to to implement a lot of
this functionality using a smaller set
of a smaller amount of code and that's
been something that's been like a
designer objective for me to keep the
runtime for the single page app
framework fairly small and also to avoid
trying to reinvent things so you know
almost every I guess pretty much every
single page app framework today comes up
comes up with their own this is my own
class system which is which I think is a
problem because then you know you get no
interoperability so I've been trying to
just avoid reinventing things that do
exist
things like the inheritance systems
because it really doesn't matter I have
my own model layer yes but that is fully
events compatible API compatible with
our backbone and then the compiler that
creates these views is larger but it's
only used during the pre compilation
stage so it never gets shipped to the to
the browser and it never runs there so
in terms of like an app developers
perspective you're only dealing with
this view layer code which is a few
hundred lines of code we should be
fairly nice so in summary did I the
direction I think or I hope or I
speculate I mean predictions about the
future usually wrong where we're going
is we're gonna be going more towards
treating the users objects rather than
treating them as strings or templates
because that just reduces the arm the
overhead of like connecting templates to
view objects to whatever moving slightly
away at least from this CGI inspired
idea of like one-off scripts one-off
controllers towards having just event
registrations and public AP is moving
away from being only able to run your
framework on the client side to being
able to render your views in your
application anywhere so anywhere where
you have the capability to execute
JavaScript you will be able to render
your views which basically means that
multiple page applications become like a
special case of single page applications
where you oh well we'll do all the
renders on the server side instead of
having frameworks that really require
Dom in order to work you move towards
frameworks where the Dom is abstracted
out you interact with it through a shim
or limited set of things and this is so
that you can render anywhere
and then we'll just move towards better
serialization better loading so that
again we really used that time to
interactivity with single page apps and
we can have them behave more like normal
web pages that load quickly rather than
like feeling like oh okay I've been
waiting here for 10 seconds for this
thing to start up some links so single
page app book it's less about all this
Future II stuff it's more about what
currently exists it's got some
half-decent chapters on like modularity
in packaging which I feel like is one of
the big points view JSON I've got so I'm
iterating on the documentation right now
it's kind of the the the hard parts are
technically are kind of solve but the
the part that really I am most concerned
with is how does it feel to actually use
that for use the framework right now
there's just not enough defaults the API
is a little bit too verbose and things
like that so I'm really just trying to
get the experience right before
releasing it also recommended is radar
Zendesk comm which is a new real-time
framework that I wrote a while back that
we're now open sourcing or my employer
Zendesk is open sourcing but thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>