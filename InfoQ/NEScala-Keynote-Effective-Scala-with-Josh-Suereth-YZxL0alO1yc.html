<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>NEScala Keynote: Effective Scala with Josh Suereth | Coder Coacher - Coaching Coders</title><meta content="NEScala Keynote: Effective Scala with Josh Suereth - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>NEScala Keynote: Effective Scala with Josh Suereth</b></h2><h5 class="post__date">2012-03-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YZxL0alO1yc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so today we're going to be talking about
effective Scala which is a fun fun thing
so Who am I why should you listen to me
well I am a software engineer I've done
a lot of Scotland over the years I'm
also a blogger and author and a nerd but
more importantly according to clouds I'm
a unicorn expert so reasons why you
should listen to this talk now alright
so first let's talk about what is
Scarlett what is effective scholar right
and what I optimize our use of Scala to
solve real world problems without
explosions broken thumbs and bullet
wounds right so in any language you can
write terrible code skyla does not
prevent you from writing terrible code
that's not the kind of language it's
designed to be it's designed to help you
write really really elegant code right
but in so doing you could potentially
right terrible code if you wanted we
don't stop you okay so effective Scala
is trying to write nice elegant code
avoiding pitfalls knowing where they are
and succeeding in your daily work so
let's start with a few basics okay by
the way this talk is going to be a whole
lot of different concepts and a whole
lot of hey maybe you should go look that
up somewhere else because I can't talk
about it in 45 minutes all right so just
bear with me here it's gonna there's a
few of these all right first off in
Scala this is this is the most basic
principle write expressions not
statements in everything Scala is an
expression right everything in scholars
an expression everything returns a value
you can make use of this here's some
code it's imperative right I want to get
an error message for a given error code
all right I create a ver result I match
over my arrow code assigned to the
result at the end I returned it what
does that look like Java it we're not
java okay what we can do in Scala BAM
don't do that that was explosions right
what we can do in Scala is we don't even
need that extra curly brace right we
don't need all of that set up we just
have
a single simple function that is one
expression when you get into the groove
of Scala you end up with lots and lots
and lots of small functions that are one
expression that one expression might be
several lines like in this case but
small functions that are one expression
are very very very easy to maintain very
easy to figure out what's going on all
right another basics use the read of Al
print loop in SVT we call it a console
in in maven I think they also call it a
console some people call it an
interpreter like the Ides and stuff it's
the same thing right when you are
developing Scala code go into the
interpreter and play around with what
you're doing you'll get a good feel for
what types of api's you're writing how
elegant it is what the type system is
doing behind the scenes for you the
repple is going to print types for you
it's going to tell you what's returned
from functions right experiment
experiment experiment in Scala this is
the first level of testing is the repple
after that you can start writing your
tests and write your code that sort of
thing it's a great way to learn new
libraries all right finally stay
immutable right mutable variables have a
lot of things that you cannot do with
them for example I cannot share them
safely across threads right I have to
lock locking is slow I can't really hash
on their attributes because they could
change right that's that's no good
equality is really painful with
immutable variable right because it can
mutate I'm not guaranteed it's going to
be the same for two objects in fact the
Equality itself could mutate the thing
right it's shaped safe to share internal
state of an object if it's immutable so
I can grab pieces i have an object and
share them elsewhere how do we do this
in Scala they're called closures if I
write functions against a mutable object
and I pass mute a table state over to
another thread it's the most common
threading mistake with mutability in
Scala I think there was a threat
about that on about akka recently right
don't do it limit your mute ability to
where it makes sense right and then use
immutability expose things as immutable
one thing you can do is you can actually
mutate locally with a mutable variable
and you can only expose an immutable
interface right and that actually is
still thread safe as long as the only
time another thread sees the variable is
the immutable interface right so avoid
mutability don't fear it necessarily
although healthy amount of fear is fine
okay all right finally Cohen
contravariance you cannot make a
covariant or a contravariant type that's
mutable it's impossible now if you're
going to cast and cheat the type system
that's fine but expect to run time
explosions later right you absolutely
cannot so that is why all the scholar
collections generic ap is where we want
nice CO and contravariance what kind of
interfaces are they well the default is
immutable okay finally runar is going to
give you free candy if you keep things
immutable he looks a little surprised
alright so again using immunity doesn't
mean a lack of mutation right I can
still have local mutable state and
expose things immutably to other threads
and you'll still be fine but please do
not close over a mutable state it's
dangerous okay next up use option don't
use no all right if I if I'm taking in
user input for how to connect to a
database or sorry this is this is
authenticating a user on a web sort of
web framework right I can if I take in
options have my codes still be nice and
simple using for expressions right I can
pull out the user name from the option
pull out the password and authenticate
if possible only if these things are
there and if they're not there something
else happens well I can delay explosions
and I can you
get or else to delay my explosions I
think that should have a yield sorry
anyway so flat map it and NP is not for
me right let's use option to avoid null
pointer exceptions in Scala there should
be no reason to use null for a non
initialized value right okay finally
style you'll know it when you have it
right but we're not java we're not Ruby
we're not Haskell okay style that I'm
pulling from Java I need to analyze what
parts of this are because of random java
gotchas that don't really make sense at
all in Scala right what parts of that
style don't apply to scala and throw
those away because they're not going to
help you out at all same with Ruby if
i'm coming from Ruby and I have Ruby
style that I make use of obviously
scholars a static language so there's
going to be different styles that we
need to apply same with Haskell right
Scala is not Haskell finally with style
the most important thing is you get your
entire team to agree or you're going to
have mismatched style right personally I
would say find some automated tool like
scelera form that you can enforce and
then just call it quits there that's
usually the best way to enforce style
otherwise it's a constant battle and
lots of bickering and it's not really a
useful conversation to writing programs
right ok so that said let's talk a
little bit about style hey all right use
def for abstract members why do we use
def for abstract members right well
because def can be overridden by Val def
can be overridden by lazy val def can be
overridden by VAR right so when i'm
making an abstract class if i don't know
or care whether or not it's a valve air
just use def default to using deaths in
your traits even if you think it's going
to be a value use a deaf why because i
can optimize later right it's a decision
where my implementer not for me death is
good enough for everyone annotate
non-trivial return types for public
methods so you don't have to annotate
return types on methods but there's two
things that this gives you okay by
annotating them if they're public one
its documentation so when I go read your
code I can figure out what's going on
especially if you're using some really
really complicated types right that will
help me as somebody else coming into the
code figure out what's going on the
second reason is I it limits the ability
of accidentally exposing some sort of
structural type or some sort of refined
type that is not the abstract type I
want to return so if i have a factory
method that's returning several of
different implementations of some
abstract interface annotate with that
abstract interface so you make sure that
abstract interface is always returned if
you don't you could potentially wind up
with a common supertype that's not the
abstract interface right I might expose
more details than I want to expose so
don't expose yourselves all right and
after that we're going to switch into a
little low again the talk is sort of
flowing hope you don't mind all right so
composition can include inheritance in
Scala right I'm going to find a logger
trait and then I can define a companion
trait called has logger which just says
that I have a logger notice it's a def
and not a vow that way if I want to
override it in an implementation with a
lazy val I can if I want to override it
with a vowel I can it's fine ok trait
has awesome lager now I'm composing
using the has awesome lager trait I'm
mixing it into a class and I get an
instance of awesome lager that is a
delegate it's a composition right so I'm
using inheritance to express my
composition this is something that's
completely possible in Scala this is one
of the two paradigms that we blend if
you're in 00 this can make sense
FP that might not make sense at all
we'll see okay finally that's that's
actually finally 400 so those are some
basic oil rules right abstract depths in
abstract members you can compose with oh
oh and make sure you annotate your
public return types okay to avoid
exposing implementation details now
implicit this is Harry last year right
limit the scope of your implicit you
gave a talk on this last year and I'm
going to reiterate the same points okay
so your implicit scope in Scala starts
by looking at implicit Stu find in your
current scope explicit imports and then
wild card imports right that's the
shadowing rules if I find a type in one
of those areas I immediately succeed and
they are all kind of you know looked at
at once so if I find more than one I get
an ambiguity after I look at that scope
then I start looking at the parts of a
type and this is where putting implicit
sin companion objects can be really
handy right I can throw implicit sand
companion objects and not have to
explicitly import them or put them in my
current scope when you write code put
your implicit sin the companion objects
put them in the parts of the type
because if you don't it's really really
really hard for someone to come back
later and override the implicit that you
added and we can all assume that our
code is perfect and pristine but in
practice I really want to allow my users
to overwrite the things that I screwed
up I don't trust myself right so again
let your user customize as needed avoid
implicit views these are overused thanks
Daniel hey so so Daniel just so you know
I am wearing shoes apologize all right
anyway avoid implicit views right these
are the most overuse thing when you
first start in Scala they are
ridiculously handy there's going to be
times where you need them but avoid them
in general
are usually there's usually a better
mechanism that you can use instead of an
implicit view and then when you
absolutely find out you need it use it
right it should be the last thing in
your toolbox as opposed to the first
thing and watch out for the implicit cat
okay so next implicit SAR great really
really really great if you use implicit
values some examples type constraints
type traits there's going to be a talk
on type traits later you should go
listen to it here's a little a little
helper well first we'll talk about type
constraints right okay so if i have a
generic buffer and i want to expose a to
Java byte buffer method and I only want
to expose it if my generic buffer is a
bite I can use an implicit constraint
there to say is mighty an instance of
bite what that's actually doing is the
compiler is looking up and implicit that
has to abide by some type system
restrictions decided to use bite yes
there's a way to do this without
implicit is that your question oh I am
miss how am I missing the parameter name
oh right right right yeah sorry there
should be an X colon T yeah so here if
you saw that there should be a parameter
name there sorry sorry for that slide
anyway I hope that you get the idea
though implicit can be used to enforce
type constraints so i can have really
really really rich api's and again is
that an implicit view no but it's on the
class and it's still safe it's still
type safe right okay oh and for examples
of these you can look at the collections
at library if you've seen the flattened
method right flattened takes an implicit
to determine if the underlying type
parameter is a nested collection and
then it can work so your type safe
you're using implicit stew help enforce
type safety okay type traits here's an
example
I'm going to find an abstract trait I
can call it encode a bowl and it's an
encode abul for type T right it tells me
how to encode tease so I have deaf and
code that takes a tee and returns an
array of bytes I have a decode takes a
byte buffer and gives me back a tea
right then in object in code because
that trait might be annoying to look up
and use i define it in code method with
this funny colon after the type that is
a context bound it means there has to be
a typed rate available for tea so I need
to be able to find on implicit scope and
in kota Belov tea right and then I just
implicitly look up that encode abow in
the implementation and calling code so
now i have an encode method that can
take any generic t if there's an
implicit encode abul available how do i
make implicit encoder bowls available i
take a companion objects for incredible
and i add defaults for staying at the
standard library right i define you know
int and co double as an implicit object
that extends in co dab'll and i give it
an implementation and i can do the same
thing with Tula notable the way I do it
with tuple is I actually chain my
implicit i define an implicit tuple
incredible a baby right I taken in a
coda bowl of a and incredible of be
implicitly chain and then I can design
my incredible of tuples of maybe I can
do the same thing with sequences I can
do the same thing with option either
right and now I have a way of encoding
generic types and as a user if I make a
new to awesome right if I have some
awesome domain object that I want to
save I can in my companion objects
provide the implicit trait for how to
encode it and that will be the default
one used and you know it's gorgeous
about this right what's really gorgeous
about this incredible method if I don't
like the way something is encoded I can
in my local scope override the implicit
in kota bowl for that type
so I can change the way things are
encoded in my application if I don't
like the default for some sort of
optimization right I need to make sure i
use that when I decode but it's a very
very beautiful very very expressive
thing ok this is this is another way to
kind of mix and behavior that's really
really really flexible alright so that
is typed rates another thing they are
external to your class hierarchy right
I'm monkey patching on existing classes
I don't control if I need to add some
behavior to the scylla standard library
this is how I do it it's far better than
implicit views ok Oh write a book on
site I separate my extractions one class
can have more than one implementation of
a given type trait and finally you can
use this to denote roles in methods so
if i have a synchronized method i have a
source and sink and I want synchronize
things from the source to the sink the
type class source and sink to note the
role in the method right now let's say I
have a file which is my source or
directory and I have a directory which
is my sink right directory will support
both sources and sinks but depending on
where i put in that method determines
what role it takes so type classes can
enforce roles and inside of this generic
method with F&amp;amp;T I can only pull things
from from I can't put things in there
even though a directory implements the
source and the sink type classes because
f only accepts source I can only use f
as a source right so I'm enforcing roles
with type classes beautiful beautiful
things one of the most important things
I think you should learn in Scala all
right in the type system you should also
try to preserve specific types I'm going
to go back here do you notice in this
synchronize right I can take a generic
F&amp;amp;T and return an F of T that's the same
concept here we want to preserve
specific types because the type system
will help us out more if it know
specifically what we want we won't have
to resort to reflection the more we keep
in the type system the more it can do
for us
an example if I have a method that takes
a collection a returns an instance of
the same collection right it's better to
actually try to preserve the original
instance this way Skylar knows if i
start with the vector i will return a
vector and it won't accidentally give me
a list because it thinks it can because
I've lost type information right so this
is important the other side of that coin
is if you if you're not returning if I'm
not returning that T and the result of
the method then I don't need the type
parameter there's no reason for it right
but if I am returning something and I
know that it could be any of a subclass
of the thing right make sure you
annotate with the type parameter to
preserve that specific type it will help
you out the long run a little bit about
collections you should know them we have
a nice collections API ok we have
traversable traversable is all about
internal iteration if I want a
collection where the collection controls
when to start and stop traversing and he
knows when it happens that's traversable
beautiful thing about traversable i can
have a traversable that opens a resource
pools things in from the resource and
closes it when it's done with traversing
and it's safe because traversable knows
exactly when all that happens right he
controls his own iteration iterable is
when I want to let someone else control
my iteration I give them an iterator
okay that's also really handy there's a
lot of performance you can get from just
dropping down to iterator sequence set
map hopefully those are transparent and
then we have index seeking linear seek
these are two I like to point out index
seek is supposed to have efficient
indexing linear seek is supposed to have
efficient head tail decomposition if you
want to index do not use a list a list
is a linear sequence a list is for head
tail decomposition don't use list as
your default collection if you're coming
from Java we would always type array
list and then you go to Scotland you
drop the array part right oh I'm immune
great no you're still using the wrong
collection most likely use vector okay
also know your collections api's right
so this is I just use reflection and
grabbed all the methods on sequence and
printing them out I didn't type that by
hand in case you're wondering so yeah
there's there's a lot of goodness there
I think Paul has kept us pretty pretty
happy with random things he adds that
are really ridiculously useful so almost
anytime I need some method it happens to
be in the collections API usually right
already there's very very rarely do i
have to add anything to it so all right
now we're going to skip over two actors
a little bit okay with actors you want
to create scheduler and failure zones
that's what actors are all about right
let it fail but don't just let it fail
control the area of failure right things
that are talking to the web and my
internal indexing service I want to keep
those things separate right not only do
I want to keep them separate I want to
have a different thread pool for one
versus the other so one can't starve the
other piece of my system one of the
beauties of actors is all about topology
it's about the topology of your system
you want to make sure when you design
that topology that you pay attention to
which pieces of the system could starve
the others and keep them separate okay
actually use different schedulers
actually prevent one system from
destroying another on that JVM or you
know send one unto one machine and one
on to another that sort of thing but you
should still have n plus 2 replication
anyway same so it's the same it's the
same as scheduling and failure and they
might be different you might have a
different supervisor hierarchy then you
have a thread pool hierarchy right for
these zones that's perfectly acceptable
and totally reasonable but please make
sure
that when one part of your system dies
the rest doesn't die or you're not
really getting the most out of actors
okay dynamic topologies don't be afraid
to have an actor change state that's
kind of what they're all about right
don't be afraid to instantiate new
actors that provide extra behavior
around your actor don't be afraid afraid
to get rid of actors actors are all
about dynamic typologies expanding and
moving based on what you need to do to
handle the current input to your system
right move things around change your
topology to optimize at runtime it's
actually that code becomes really really
simple in an actor system finally just
use akka right Acas pretty much the best
actor system on the JVM and that's not
just because I work at typesafe it's
because I've actually tried to use all
of them and yeah ik is amazing
especially with the 2 point 0 release
finally we're going to talk a little
tiny bit about functional programming
okay functional programming has a bunch
of Awesome patterns from category theory
okay some of them are really useful use
them all the time some of them if you're
running pure FP you will use all the
time not all of us are writing peer FP
all the time but I'm going to cover the
ones that are actually useful i would
say in almost all your code here's an
example using applicative if i have a
bunch of options again right I can use
this funny little symbol from scalo said
you could also define your own
applicable ders that don't use funny
symbols if you don't like funny symbols
anyway this is essentially taking those
three options and joining them into a
tuple right that I can apply to that
function so driver manager get
connection takes a user name a URL
username and password and I'm taking
that what's in the option and sending it
to it and giving myself a new option ok
that's all that code is doing that's a
big simplification the beauty of this
is that it does it in parallel so if you
remember with four expressions if I had
that for expression example if URL
doesn't exist right then it's never ever
going to look in user name right it's
never ever going to look and password it
stops when it finds out that URL doesn't
exist so there's something in Scala Z
called validation to people of there's
something Scala code either that we can
do this with two if option is instead or
sorry lift has what they call box right
it's the same thing if instead of an
option I have something that could be a
value or an error message this will let
me group my error messages and save them
for later so that when I discover
there's an arrow state I can print all
of them to my user at the same time
applicative are like four expressions
but they're parallel right I'm doing all
of these things we're trying to make
sure all of them can happen all right
applicative are the parallel version of
monads and you have to say that word
sometime right anyway for expressions
are how we express monads in Scala
applicative well you use this funny
operator from Skylar said if you want to
use them now all right now you should
learn Scala said why do I say that the
validation class the applicable you can
use them in lots and lots of real life
code you don't have to go crazy and pull
in all of scholars head for it to be
useful in your program here I just threw
a bunch of the funny operators of why
people are scared of scholars head right
so if you take two concepts apply some
magic and rich it and then join it with
love flat map some awesome you'll
achieve harmony right that's what that
says okay and so I also just described
what those operators do right so the
little star there by the way is the same
as this operator but I can never type it
so I had to cut and paste anyway so when
scholars said there are some useful
things right there's some useful thing
we can learn from functional programming
Scala is about a blend it's about
knowing when to use oo knowing when to
use FP joining the two together right
classes functions methods expressions
that's Scala that is the beauty of Scala
it's a unifier we're trying to blend
okay when you work in the blend that's
when you're achieving the optimum use of
Scala the type in furniture is going to
work better for you your code is going
to look very clean right if you go too
far to one extreme you're going to start
to fight the compiler alright so that is
effective scala at the end this all of
these concepts if you were to purchase a
book called scotland depth these are all
covered in far more detail in there and
i know that this was kind of a firehouse
so to be a fun keynote I thought maybe I
would open it up to questions a little
bit at the end I yeah so if you guys
would like to ask any questions feel
free yes so the question is will
concepts and scholars said make it into
the standard library right I so the
answer to that is actually that we have
in we have a skylit incubator so
scholars ed puts things into the scylla
incubator the scylla incubator is what's
meant to go into the standard library
right now we're being very very
protective of the standard library
because we want to make it binary
compatible and so that's why very little
has been able to make it in in the past
yeah right so the question is with
collections and preserving specific
types and I want to use say a map method
that has all sorts of other things to
pull in and it's it's kind of hard to
make it preserve specific types or the
map method right where it could change
the type in my book I have an example
where you aren't preserving necessarily
the type you got in your preserving the
most specific type map can return right
so you're preserving the most specific
type that you can keep so the reason why
this is important i don't know if you
guys know this if i have a bit set
what's a bit set
to set events it's compressed right so
I'm looking for bite positions and
that's where i put whether or not it
exists it's great for little
enumerations to make them smaller memory
however if I call map on a bit set and I
call underscore to string what does
what's returned right a of string no
longer a bit set it escapes it goes to a
lease specific type because I can't have
a bit set of strengths so that's the
uniform type or return type principle in
Scala if I'm going to write a method
that's generic and I want to accept bit
set and I want to return the most
specific type of the collection there's
a little bit overhead I have to do and
again well I wish I had an example here
anyway but that's a really good question
and it depends on what you're writing
right so the question is it can be
overhead to write generic methods across
all collections right there's there's
overhead involved there's some implicit
magic a lot of type parameters and in my
day-to-day life if I only need a vector
all the time why not just explicitly say
vector right so the response to that is
if I'm writing a method right or if I'm
writing my data access layer right I'm
going to annotate vector because it's
the most specific type and I want to
preserve that through the type system if
I'm writing a generic method that needs
to go against any possible thing in the
whole world that could be a collection
that's when I have to go to the extra
effort to try to preserve the specific
type if I'm writing a utility library if
I'm writing my data library where I know
it's a vector and I know I can just
return things that are vector then I
don't have to go to any extra work
because I'm still preserving the
specific type no it's a vector want it
to be a vector and state vector so
there's there's a dichotomy there right
it depends on where are you writing the
code am I writing a library I want
everyone to be able to use or am I
writing my specific domain right once
i'm in my domain I should have specific
types and I should just never have to
worry about it but to be able to do that
all of the generic stuff has to be able
to preserve those specific types
otherwise you start running into
problems you start having to call you
to vector I don't know if to vector
exists anyway yeah the question is is
there going to be more attempts to use
type classes in the standard library the
only two instances right now are like
ordered in something else ordering sorry
and another guy like that can build from
happens to be a type class it happens to
be a very funky looking type class so if
you want to learn the type class pattern
look at ordering in the standard library
yeah so again this goes back to the
whole we are very being very very
cautious about we throw in the standard
library very very very cautious so I
would love to see a type class library
try to go through skyla incubation hint
hint I would love to see that right but
it has to go through the approval
process and and and all that to make it
in and right now I would say the odds of
things entering the standard library
without going through without you having
seen them as a library for a long time
and work out bugs and prove that that
design is viable is low so if you want
such a thing in the standard library
that it needs to it needs to go through
some stabilization process right so
existing projects that are stable that
people like and don't complain about in
Scala that they consider canonical have
a good shot of potentially making it in
if they're if they go through incubation
versus just some random untested library
so what's currently in Scala incubator
is the question so we have Scylla arm
Scala I oh I think I think technically
anti XML is considered it in the
incubator right
so so well well it's at least getting
proven out there so yeah that's right so
we that's the other thing right the I
don't know if you saw the community
extension library for Scala that's kind
of where the incubator has sort of moved
so incubators like a place where you can
add scallop projects and then the scylla
community extensions library is our way
of we want to expand the standard
library but we want to make sure these
libraries prove themselves before making
it into core so I think with SBT 0-12
will be able to have the scylla
community extension library be built and
deployed for you for every version of
scala and that is just going to include
projects that we consider core
fundamental in scala anti XML is one
skyla I oh it's got an arm I think we're
just going to pull in all the testing
libraries but i can't i can't say for
certain there's a committee of a few
people one person the epfl one me martin
and then a few external contributors
that decide what makes it in there and
how how that happens so that's the
commune extensions library so so scala x
ok the question is is this called Scylla
X all right skyla x and skylar said our
scala community extension libraries that
were generated by people out you know
not necessarily inside of the Scylla
project ok they're just libraries this
this is going to be something that's
sponsored by us under Scala right it's
sponsored by EPFL it's sponsored by
typesafe to have a set of libraries that
we consider we would love to be in the
standard library but we want to validate
them first so it's going to be something
different and also it will just use the
name of the original library so again
skyla x or scaleo skyla arm anti XML
we're not going to make those libraries
change to bring them in here we're just
going to be promoting them as hey we
consider these core we'd like to have in
the standard please test them more right
all right thanks guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>