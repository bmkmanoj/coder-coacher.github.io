<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>DDD and Microservices: At Last, Some Boundaries! | Coder Coacher - Coaching Coders</title><meta content="DDD and Microservices: At Last, Some Boundaries! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>DDD and Microservices: At Last, Some Boundaries!</b></h2><h5 class="post__date">2017-08-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sFCgXH7DwxM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I know that maybe a lot of people do
know who I am but just in case I wrote a
book called domain-driven design and
domain-driven design is really about
complex business logic approaching it
with domain modeling techniques that
really focus on like how we use language
on the project and within our code and
so maybe people are thinking now what is
the connection between that and micro
services now that a lot of the interest
in micro services does come from the
scaling abilities it gives us in terms
of being able to handle really large
numbers of transactions and and that
sort of thing
that is not what interested me in it
although I occasionally am involved with
that kind of problem most of the time
the problem that I'm dealing with is
that the logic or the the business
itself is so complex the problem that
they're trying to work on is so complex
and perhaps tangled together that it's a
challenge to just make that work or make
it work in a in a sufficiently clear way
that people can continue to evolve it
and that's really what domain driven
design is about but the thing is that
one of the biggest problems and I I
would have to say and my book is I think
12 years old and I would have to say
that the the number of projects that
have really succeeded with this kind of
approach is a little disappointing it's
not that of course there are a lot of
them that have really gotten a lot of
mileage out of it
but I see an awful lot of failed attempt
valiant attempts that failed and one of
the most common problems is that there
are not good ways to establish
boundaries around parts of systems not
the kind that we really need and so as I
started to see the micro services stuff
being presented I thought ah now there's
a real boundary
so now a couple years later there it is
it's come to a point where I mean I feel
slight embarrassment talking about
micro-services because it's become such
a buzzword and all but you know just
because something becomes really popular
doesn't mean that it's bad and in fact
you know when you really think about the
source of our expression you know jump
on the bandwagon I mean you know who who
wouldn't want to jump on a bandwagon
that's a pretty attractive thing I think
so but of course it matters to exactly
what we mean by micro service so I'm
going to just briefly say what it is
about micro services that interest me
acknowledging that a lot of people use
the word a little bit differently and so
one of the most important aspects to me
is the autonomy it gives to the teams
and the isolation of the implementation
I would say that that is the part that
most attracts name I mean we don't allow
a database to be shared between micro
services and that's something that oddly
enough I've been preaching for a long
long time but this is the first time I
saw anyone really really do it actually
I say you know I can hardly think of an
exception and suddenly it's like
mainstream so that's a cool thing
there's something about microservices
too that acknowledges how chaotic and
rough-and-tumble an enterprise really is
any kind of big organization so that you
know you can have all these different
now sometimes they're talking about at
the actual deployment level you know
that you're deploying these services all
over on many servers and some of them
are going down and you're bringing them
back up but there's a corresponding
complexity in the actual development
world where you have many teams and
these teams are developing stuff that's
supposed to fit together and but also
supposed to actually work and so I think
there's a pragmatic quality to it
you know like cattle not pets and all
that sort of stuff it really breaks with
the past and so I see that it's been
helping people think fresh and maybe it
can help us think fresh about domain
logic as well but again I say different
people mean different things by
micro-service so if some of this stuff
that I'm saying doesn't seem to quite
match what some other people are saying
you know that's okay I'm just talking
about my particular conception of it now
I want to give an example here a sort of
abstract example and I'm going to talk
about services as just things that can
consume messages and produce messages
messages come in messages go out and
hopefully something interesting happens
in between and so a very simple micro
service application might have a couple
of micro services and they send messages
and consume the messages from the other
one now the question that arises for me
and this is been a question that I've
asked since ever since messaging really
started is how do they understand these
messages I mean if you just say well you
know I'm developing an application and
I'm publishing what's happening some
events in the form of messages and over
here I'm subscribing to that and I am
trying to understand those messages they
must be in some language some schema
that we both understand and so how does
that happen
well one way of looking at it is that
whenever we understand language it's
because we know the context in which
that language is being
uh turd so that even the words I'm
speaking right now are only meaningful
to the extent that people you know know
the context in which I'm saying them and
the same is true within our software
systems when you receive a message from
another system or if you are reading a
line of code the only way to understand
what it means is to know the context the
way we usually understand the context in
our normal conversations is extremely
complex and we infer context and we
weave contexts together in a way that
works great for human to human
conversation but is terrible for
computer to computer communication so we
need something much simpler and that's
what I call a bounded context where you
can actually draw you know
metaphorically draw a line around some
part of the system and say within this
part of the software the word customer
always means the same thing and here's
what it means and you can't always do
that sometimes software systems get into
a mess and that's no longer really true
but when you can then you can start to
make sense of what's going on now domain
driven design introduces a technique
called a context map in which we try to
get a big picture of a system by saying
there are many of these bounded contexts
in which a specific language is being
understood we're going to just draw them
on the map so these two services that
I've drawn a and B would correspond the
to context in our context map and they
have a relationship between each other
which we'll call partners because we're
going to assume that this is a
collaboration that's been worked out
between the two
and that line also represents a
translation between the two as necessary
so that they can understand b and b can
understand the a because remember these
two teams are very autonomous that means
that they are not necessarily going to
use the exact same terminology if if you
and i have to use the exact same
language then our we're certainly not
autonomous in our design work
so now let's complicate matters a little
bit the messages that are being produced
by a are also now being consumed by C a
new service C did not work with a to
work out the that protocol so this is an
asymmetrical relationship where C is in
a follower or downstream position
relative to a and there are various
kinds of relationships like that but in
a context map well there are a few that
we use so in this diagram the arrow has
an arrow the line becomes an arrow and
it points toward the context where the
power lies that can be a little bit
asymmetrical or extremely asymmetrical
but we just kind of simplify it and we
say that in this case C is conforming to
a that means that when C is actually
consuming these messages that the work
that they've done in their context
inside their service is actually
following that language as well so they
have given up some of their autonomy in
order to make integration with the
message stream from a very simple and
this is a common thing that people do
when they're writing something that is
using messages from more maybe a more
complex system let's throw another one
in there now D is also going to consume
those same messages but D needs to
do something more complex and they do
not think they can do it while
conforming to see they want to a they
want the autonomy so they build a more
complex translator we call an
anti-corruption lair and they now can
have their own language so a has its own
language B has its own language D has
its own language C might have in some
areas but to the extent that it is using
things from a it conforms to a slang
guack now let's throw another one in
there a needs some data and that data is
being provided by this new context of
this new service called e but it's being
provided in terms of a zone messages so
that means that even though the data
flow goes in that direction that the a
still is the one in the driver's seat
so for example if you were submitting
tax returns electronically to the well
to the tax authority of whatever country
you're in you're going to have to submit
them in a defined format right there
will be some very specific schema that
you have to use and this would be an
example of that now D also wants to
consume the a messages that are being
produced by e and since D can already
understand a messages this does not
actually modify the context map at all
because the context map is although
until now it has looked exactly like a
you know it looks exactly like the
whoops sorry until now it's looked
exactly like the diagram of the services
but it isn't really the same it's
mapping the relationship of those
languages and since D already knew how
to interpret a and since that's already
on our map we don't change the map
and this starts to show how certain
things can be abstracted and simplified
at the level of a context map it's not
just another way to draw a picture of
some services sending messages let me
add another one into the mix this new
one f is going to consume messages from
be in that same B language that a can
consume and it's going to emit messages
in F and what they've decided to do is
that F needs perhaps needs or at least
once the autonomy of having its own
language so they use an anti corruption
layer to transform the message is coming
from B into their own language but then
C conforms to them now you'd say well
you can't conform to more than one
context that's true if they are sending
you the same sort of information if I
were getting customer data from F and
customer data from a I couldn't conform
to them both but if I'm getting customer
data from F and and vendor data from a
then I can conform to both two different
ways of two different sort of categories
of information so on it goes now one
point I want to make is that in any
system there are multiple models not
just that I think there should be
although I do but that there are and if
nothing else you have your legacy system
you have your new system yeah the
external systems that you've had to
integrate with but usually multiple
teams will develop multiple models and
so microservices kind of embraces this
with that team autonomy and the
alternatives to having multiple models
are not good things they actually
undermine the goal of modeling
see I think that because people have
gotten so into trying to create a single
model for big scope of a software system
because they've focused on the issues of
integration through a schema or
something they've lost sight of the
power that a model can give you to
actually solve logic problems but a good
model doesn't need to be big it needs to
be very clear those are actually kind of
pulling at each other in opposite
directions you want things extremely
crisply defined and to do that to define
something very clearly you need to be
explicit about context so another thing
that tends to make models powerful is
that they can make assertions I can say
that there are no customers who are that
there are no customers who have never
ordered anything I could make an
assertion like that is that assertion
true of all software systems of course
not it might be true of some part of my
software system and if I have bounded
context I can say yes or no is that
statement true about a particular
context so this is again why we need
boundaries in order to do good domain
modeling and to actually get any benefit
from it and I think that the lack of
those boundaries as I was saying earlier
it's one of the things that undermines
us so often as we try to accomplish that
and that's why to have a more practical
more a way that seems to actually be
working to create boundaries is
something that I value of course another
thing that happens is that things start
to go wrong that is I don't mean in the
usual sense that microcell you know go
down and have to be brought back I mean
that the design will start to go wrong
so as people are are refining and
changing their designs sometimes they
make mistakes I mean sometimes they
couple things together or they you know
all the usual design mistakes so let's
say this has happened in eff the people
who wrote the team that wrote f
micro-service have made some fatal
mistakes this might be the same people
or it might be different people who have
taken it over and didn't really
understand the intent of the design and
started tangling things together in a
different way one way or another this is
very common and what happens in a
monolithic system is that this kind of
corruption just metastasizes throughout
but when you have boundaries what
happens when you have a when you have
some part of a system become well as we
sometimes call it a big ball of mud so
or maybe it's a small ball of mud if
it's a micro-service but at any rate
well one thing that happens is that C
becomes a ball of mud because C conforms
to F and if you're conforming to a mess
then you become a mess
so that's inevitable but it doesn't
spread any further than that
so we've contained the mess now e here's
a trickier one he has started to create
a mess and the particular thing that's
affecting that's making this worrisome
is that remember they were conforming to
a they were emitting messages which were
in the language of a very tightly
conforming and now they are tainted
they're kind of well they're like a mess
but not quite so I'm calling them AE
messages and this happens all the time
now what's going to happen next well
first of all this context map no longer
describes the situation it says that E
is conforming to a but it's not so we
need to do something about that we need
to make the map realistic because
realism in a map helps us to make
strategy and figure out what to do I'm
just going to put some warning markers
on those saying that there's some risk
of corruption around these particular
relationships now I had to put a
connection between E and D because I
don't understand anymore what's going on
exactly and then what can be done about
this what are we going to do to try to
you know get back on track with this
well one thing before I talk about that
I want to make the point that not all of
a large system will be well designed and
one of the reasons I think that we have
so feud well designed systems is that we
don't really really accept this and we
try to make everything well designed we
don't really do triage and so we spread
our energies too thin so thin that you
can barely see the effect of the design
effort sometimes so I'm going to be
quite prepared to you know say well
maybe this part doesn't matter so much
and in this particular case we're not
going to try to fix e now you could try
to fix a and that would certainly be
nice but suppose we can't do that well
one way to mitigate the effect of this
is to put an anti corruption layer in
front of a and D now notice that it's
basically shifted the power direction
this is the people in a and D saying hey
we've got to protect ourselves from the
that the e people have made they're no
longer conforming to us and we are going
to pragmatically build a little piece of
software in front of whatever was
processing those messages that
transforms the things we were getting
into what we actually need
now we're protected there could be other
ways a and D could both share the same
transformer or something of course it's
always possible you could fix e but we
can't make saving a and D dependent on
fixing e a at least we know a is this
very central kind of system so let's not
let idealism get in the way of you know
keeping a system that's still basically
in pretty good shape so at this point I
think that I've gotten across I hope
that I've gotten across that the that
micro services as they're usually
described as I what I'm hearing anyway
in the description make good context
boundaries and often people say you know
one team owns it they have a lot of
autonomy about how they design it and so
on and this allows us to have that
specialized model that solves the
problem that that micro Service is
supposed to solve of course lots of
micro services do relatively simple
things and they're being broken off for
reasons of performance and that's not
what I'm talking about here I'm talking
about a micro service that's doing some
fairly rich behavioral thing another
thing is that by having these sort of
breakers in there we can keep design
mistakes from just spreading through the
whole system okay now what about though
and this is one of those things which I
think people have started to talk about
more as you get a whole lot of micro
services you know a lot of the
interesting stuff is
happening between the services and not
within the services so what about that
part how does the design of that come
into it and here's worth I think that we
can look at this and start to see a bit
of a problem because look at all those a
messages look how many different
contexts are conforming to a or have
translators to a and basically what's
happened is that the language of a the
language that they developed for their
own internal logic remember the original
motivation for that was for the logic
that they were creating but then they
published some messages that said this
is what's going on inside or these are
the results of the transactions we've
done or whatever it's become a de facto
language that is used between the
different context in fact in one case
between E and D it's even being used
between two contexts that aren't even
currently talking to a this happens all
the time of course in in terms of
natural languages you know you have you
know a Chinese person and a German
talking to each other and these probably
speak English and it works I suppose but
the trouble with this here is that it's
it's going to have an effect on a first
of all this language won't be optimal
for the purposes of E and D talking to
each other but secondly and more
importantly now that all those different
uses of their languages are in place
they can't change it that obviously
doesn't apply in natural languages where
people do whatever they want but a can't
change their language anymore because if
they did it would break everything
so I think that recognizing these
interchange languages is important and
maybe creating explicitly and
interchange context so suppose instead
or maybe at a later stage when we
recognize that a is emerging as an
interchange context and we say well
let's make an explicit interchange
context identify what is it that makes
that language so important to so many
different contexts it isn't everything
in a a lot of what's in a is very
specific to their needs so we could
devise a new language probably simpler
and easier to integrate with an a and we
can use it and so now when a is so now
if you look at the arrows up top they've
been changed to be little eyes instead
of A's and what that means is that E and
D and C and a are all interacting
through that interchange context this is
not a physical thing in the system
they're still these messages are still
being published and subscribed to in
just the same way as before the only
difference is what how is the content of
the message to find out what is the
semantics of it and notice that a
probably is still producing its little
AAA messages and they're going through
that new anti-corruption layer to be
turned into AI messages so that other
people can consume them but see likes to
conform so they just change things to
conform to AI and sit at a and so on now
this might be quite a difficult change
to make you know you know in a system
that has a lot of interconnections like
this we might get halfway there
we might say well hey we'll publish both
a's and eyes because the eyes will come
out of that translator and then c will
continue to consume the a's at least for
the time
because it's too hard to change it but D
is going to change so they've got an
anti corruption layer it's pretty easy
for them to change and E is going to
change because they need to do that
well now an interchange context I think
is something which sometimes emerges on
its own but would work a lot better if
people were more conscious about it
and it's a good way as I was talking
it's a good way of kind of giving you a
language for some of the commonly
exchanged data but it also is a good way
a good place to work out protocols of
interaction between services which is
something that some people talk about it
I think should be talked about more is
that an awful lot of what's interesting
is happening at that level and so and
and we should be applying our design
tools there and not treating that as a
technical integration level so this
allows us to tune a language to that
purpose and it might be two different
purposes by the way so just to be clear
at this level when we have terminology
we're expressing it in terms of you know
messages service interfaces so whereas
when we're inside of one of those we
might be talking about objects or
functions programming language
constructs it's very different in its
physical manifestations but but the same
principle applies that we're trying to
have a clearly defined language or a
language with very clearly the client to
find terms that's expressed very
explicitly in whatever constructs that
were making so I you know so when some
context emerges in a dominant way like
aided and becomes the de facto common
language between a law
a lot of context well we can prevent
that from sort of strangling their
ability to change if we can make a shift
to a to an interchange context and as we
get a whole lot of services another sort
of interchange context can allow us a
place to actually reason about how they
interact in the same elegant way that we
do and that with with in a context and
that brings me to make saying very
explicitly I think that you know I'm not
talking about a single interchange
context this is not the replacement of
the enterprise model it's bigger than us
I mean it's outside of services and
we'll be in that space where they
interact but it isn't like we have to
have one of them obviously you'd start
with one and so the interchange context
is going to be a logical boundary at
this point microservices does give us a
really nice explicit and and concrete
boundary around the logic that one team
is creating within a particular service
but it doesn't really do much for us in
terms of the service to service
conversation so we will have to fall
back on kind of you know more
documentation kind of ways of keeping
track but while on that subject I'll
bring up the a lot of the people that I
know that are you know say yeah you know
domain modeling is important and I see
that we have to have boundaries and they
agree with me on all these things but
they don't like the idea that you would
use a micro service with this intent and
they'd say well it's a lot of overhead
which I'd agree it is quite a bit of
overhead you know if all I wanted was
logical partitioning
so why do I find that so compelling and
I'll tell you the simple reason because
we have been trying it the other way for
as long as I've been in this business an
embarrassing long time and it just
hasn't worked the logical partitioning
it isn't robust if there isn't something
in the system you know that people can
see then it just doesn't hold up
it doesn't tolerate the chaos of a real
development project where people get in
a hurry it's too prone to attempting to
unify everything you know it if you have
a monolithic implementation then
monolithic modeling feels very natural
and it almost always slides in that
direction the the boundaries aren't very
clear so someone in a hurry just reaches
and grabs something they need from over
there and uses it as is that's not so
easy in micro services right it's not so
easy to just say oh well I need that
piece of data and it's right there in
that other database so there I got it
well you know that's easy to stop in a
micro-services environment but not so
much in a monolithic system with logical
boundaries so I think you know we gotta
just sometimes just accept things that
come from experience and one thing that
seems to come from experience is that
the other approaches we've taken are
just too subtle
they just don't usually hold up I'm of
course talking about the sort of most
projects there are always exceptions and
I've been on some of them where are we
managed to make the bounded context work
pretty well without really physical
boundary now as I said the interchange
context won't have a really explicit
physical boundary so you have to
describe it in some other way and so
you're back to the to the old way on
that alright well just to kind of wrap
up my real motivation in all of these
things is always that I I want to do an
elegant design aimed at some really
tricky business problem that's what
really turns me on to take on a problem
that is so convoluted that everyone
thinks it's going to always be a mess
and then we tease it apart and we have
an elegant and subtle model and the
problem just kind of just goes away
right just becomes seems to become
simple that's great I'd love to do that
it hardly ever that it's so often goes
wrong because that kind of model is very
fragile and so it takes a real boundary
to make that work
it also takes acceptance that not
everything in a system is going to be
like that and in fact to even embrace
that and say why would we apply those
techniques to something straightforward
so I love the environment that a micro
service can in principle create for that
kind of work though it doesn't
automatically happen and then the other
thing is the proliferation of services
brings back some of the same old
problems once you have hundreds of micro
services talking to each other in all
sorts of ways you can easily create you
know spaghetti of a different just a
different level of spaghetti code and
I'm sure this has happened already
so this is where the context maps and
come in to start to say look this is
what's happening here's a picture of how
these different relate languages relate
to each other you know maybe these
people should be conforming rather than
creating yet another language and then
use of interchange context I'd say
modest use of interchange context
because this is a sort of thing that
people can get a little carried away
with but still using these things to
create coherent sets of micro services
that actually know how to talk to each
other but without saying at the same
time that every thing that the services
do inside themselves has to follow the
same language or logic so that's pretty
much it one last not all of us large
system will be well designed and then
I'm ready to to to basically close and
take a few questions I think
have you actually seen any example of a
company or a team or set of teams where
this has been applied to micro-services
and actually work could you say have I
seen a team or a company where this has
been applied to micro services and
actually work oh yeah a couple I think
that now the most interesting ones by
the way have that I've been involved in
personally have not been wholesale
adoption of micro services across the
board they still have their monolith
monoliths and multi lists anyway
they still have them but as they're
trying to migrate away from this legacy
you know there is the old way which is
basically let's create another
monolithic application that will take
responsibilities away from the legacy
system and instead of that what I'm
seeing in some places is to spawn a much
you know initially like just one little
micro service that takes away one well
or that parallels one important business
responsibility that and and chosen
because this one is one where the
business really wants to innovate you
know so they don't want to be
constrained by the way it was done in
the legacy and yet in the legacy because
there's so many dependencies and so on
being monolithic they just can't make
the changes they want so they create a
another system but a small one and then
another one and then another one and
once you have a few of these now that
was done in a kind of a I saw that I've
seen that for at least five years done
in a kind of you know ad-hoc way but
since the micro services thing has
emerged the people who are doing that
use the micro services architectures and
then it works much better it's it's
cleaner you know they have a pattern to
follow
and so yeah I think that's that's how
I've mostly seen it because everywhere
that I work there's a huge legacy you
know I I haven't been involved in many
places where they're sort of starting
from scratch so it's usually like that
but it's really been helpful in those
places so if I remember correctly if two
contexts have part of the domain that
they share you call it a kernel is that
kernel yeah yeah
so do you have any thoughts on that with
regards to micro services because so I
have the I was a bit I've always been a
bit skeptical of the shared kernel in
terms of I think it's one where you
wouldn't want to use it too often and I
think my skepticism has just steadily
increased over the years and if I were
using micro services I wouldn't do it so
regarding back to the I mean whatever
you call it the kernel or land context
that emerged just to give I mean the
interchange context does it have to
confirm to one of the original context
and your example does does I have to
confirm two A's terminologies no okay so
that's a good point
yeah if you went through the story that
I just described chances are it is gonna
look a lot like right right because
everyone's used to that and so people
tend to follow that pattern ideally you
would look at the problem fresh and say
the problem of of these four or five of
course the numbers in your real one
might be a bit larger than my example
right so it might be more than four or
five the the problem of the interactions
of this set of services is distinct from
the problems being addressed
inside the services right and so let's
look at that problem and think what kind
of message is what we really want to
have if we were just talking
about you know that problem they're
trying to solve and so often it would be
you'll find for example there's a lot of
stuff in messages that come out of a
specific service that are first of all
made it just be more detailed than
anyone else cares about and secondly are
expressed in a way very much
around the problem that they're trying
to solve there and so yeah I would
ideally like to see it be a bit distinct
so in this case that's my next question
don't we need in that case an anti
corruption layer between the contexts
themselves themselves between a B C and
D and I on the other hand yeah
yeah and let me just go back to that
last picture since and you see there are
each one that uses the interchange
context either it conforms to it or
hasn't any corruption there so each the
the particular choice each one is made
is declared explicitly so if you say
well you know what whenever I talk about
these things because the thing I'm doing
maybe I don't need any really
specialized domain model to do my
business logic I'm just kind of bringing
some stuff together and consolidating it
or whatever then I'll just conform but a
obviously can't conform because it
predates by any way you know they'd have
to transform everything they do it just
and anyway a has a model that that was
designed to solve some complex business
problem not just to use to talk to
someone and D likewise but C and E have
decided to just conform good yeah thank
you so much
as usual provocative provocative well
that's good
yeah I think that's a good word though
because it is a bit of a different you
know it's a different take yeah any
other
oh so in my experience trying to convert
messages there's still only so much you
can do I mean if if a field is optional
in one system it's really hard to make
it required in another system so so I
mean the first system that gets built
sort of like defines how the data model
looks and of course you can make small
changes but I mean if it looks like so
I've been doing for instance financial
systems and the way the data structures
looks in the mainframe it's just really
hard to not sort of looks very similar
to that in in all the other systems as
well so it is true that the way things
usually go if you start with like in
this case a and you carry it as far as
went here that you're going to end up
with an interchange language that looks
a lot like a even then it might be
valuable because let's suppose that
we've reached the point where a is
having a hard time continuing to evolve
they can't change things as freely as
they would like because they have you
know their own languages the basis of
the interchange of a whole bunch of
stuff so even having an AI that's just
kind of a cleaned up version of a would
still be an advantage I think but
another thing that could have happened
is you might have recognized it earlier
you know yeah sure while it's just a and
B talking to each other this is
superfluous and and when it was just C
consuming a few a messages it would be
overkill but when you see another one
start to join the bandwagon and you
start to say oh you know maybe there's
mmm this might be place for it another
thing is that I think that I was talking
about the protocols of interaction and
you know there's some larger goal here
right or a few larger goals that is it's
not just well a does some business
and seed us some business things and so
on there's some kind of interaction here
that is getting a bigger business
process done and we might say I want to
be able to be explicit about how that's
done I want to be able to model that and
show how the different services talk to
each other to accomplish it and so that
would be I think a very powerful
motivation to create a interchange
context between a specific set those
services that are in that our key
constituents of a of a whole business
process you know and and that's one
thing I think is sometimes hard to see
in very decoupled systems it's hard to
see how the how the whole thing fits
together without having some kind of
rigid talk down orchestration so that
would be another reason that I would
perhaps choose to do it relatively early
before it's become so entrenched the
story i told i partly told it just to
illustrate how these these interchange
languages they do emerge on their own
just in a non-ideal way you are gonna
have these you know everyone's going to
just kind of start using a because it's
just that's how it works it makes sense
but and i'm saying let's do that maybe a
little more consciously so that's one
thing but there's the other thing of the
you know to try to have a really
explicit approach to the protocol of
interaction between some finite set of
services that we've defined if that
makes it oh okay there's one more and uh
i guess that'll be all the time so one
more be hard yeah do you talk loud i'll
bet i yeah
yeah yeah okay so to repeat the question
just because he didn't have a microphone
would I so there's sort of two things
I've been talking about one being the
protocol of interaction but one being
this easier way of exchanging data that
a lot of different contexts need to use
would I start out with a kind of
canonical model Tower of Babel was the
was the phrase you used and and then
that way early on a new service that
wanted to send messages would send it in
this form and I would actually probably
not want to do that because it seems to
me to be too much on the slippery slope
to the to the enterprise model to saying
there will be one model for all of these
things and because it does too much
upfront decision-making at the very
beginning I don't really know what
messages these services want to send to
each other that kind of is emerging you
know as they as they're built and once I
see what kind of messages a and B and C
and D are all sending to each other then
I can look at that and I can say I can I
think I can now devise a nice somewhat
clean not perfectly clean but somewhat
clean schema that will be good for
conveying this set of messages between
these particular services but if I
started out at the beginning I would end
up with something that didn't quite fit
and you know it and I don't even know
like since I don't intend to use just
one interchange language for everything
I intend to use it for sets of services
that are talk to each other a lot for
example because they really are like
little clusters
coherent services you know and so I
think yeah I think I would avoid that
but be on the lookout for these clusters
emerging and saying rather than wait
until we have the de-facto ones so
firmly in place that we're not going to
be able to get free of it let's then try
to come up with something nice and clean
free of so many of the things that they
were using just to get there a little
problem solved and it does look a bit
like canonical models and such but it
it's not the same thing it's another
model used for a specific purpose we're
not using internally yeah si decided to
use it internally they conform but that
was a compromise they made it isn't
being imposed in any way and people
doing complex things I would encourage
not to use it so well I see that I'm out
of time - two minutes well thank you for
your time and our your attention and I
guess the conference is basically over
but maybe I'll see some of you outside</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>