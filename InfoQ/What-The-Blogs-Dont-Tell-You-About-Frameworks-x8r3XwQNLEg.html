<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What The Blogs Don’t Tell You About Frameworks | Coder Coacher - Coaching Coders</title><meta content="What The Blogs Don’t Tell You About Frameworks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>What The Blogs Don’t Tell You About Frameworks</b></h2><h5 class="post__date">2014-08-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/x8r3XwQNLEg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Sara May I'm really happy to be here
today I just got in yesterday from
London so I'm pretty sure I'm here on
the right day but I'm not entirely sure
hopefully after a couple of nights to
sleep I'll be able to figure that out
again I am Ruby and JavaScript developer
here in San Francisco this is me on
Twitter and github and this is my
consulting company that I run I do a lot
of nonprofit work I founded a nonprofit
called railsbridge that teaches women
how to do Ruby on Rails and other
underrepresented groups I'm also a
director of Ruby Central which is a
nonprofit that runs all the large Ruby
conferences like Ruby conf and railsconf
and in addition to that I also run our
local Golden Gate Ruby conference which
is our regional one that we have here
and you may wonder with all this Ruby
stuff why am I here and it's a good
question
the answer that is that over the last
few years like a lot of people I think
my work has undergone a pretty
significant transition circa 2006 this
is kind of what it looked like I did a
lot of Ruby I did a little bit of
JavaScript when I had to but otherwise
tried to avoid it as much as possible I
actually started doing JavaScript in the
90s which was not a good time to start
doing JavaScript so it's pretty much
always under duress but like a lot of
server oriented engineers I think over
the last 10 years as full-stack
quote-unquote has become kind of a thing
and his javascript has become more
important obviously to a modern feeling
out the patient the proportion of stuff
that I do is shifted and these days it's
pretty much more like this it's pretty
much half in half or more sometimes
JavaScript and in the gap there I've
learned how to write it idiomatically
instead of like a ruby developer I've
gotten a little more involved in the
JavaScript community I enjoy it a lot
more than I used to but I am here a bit
as a bit of an outsider because I
identify mostly within the Ruby
community
and I feel like that actually happens a
lot in the JavaScript community people
come in and their PHP people or their
dotnet people and that's what they
identify as but it's shifting it's
shifting for me anyway and I've been
doing for the last five years or so I've
been doing consulting through various
companies and it's not the traditional
like take a project and do it off-site
kind of consulting but basically what I
do is I go in and I embed myself into an
engineering team for a couple months I
go to their office I pair program with
them I work on stories we level up and
these are teams that are working on
fairly complex projects they typically
have as a minimum these sort of moving
major moving parts they have a server
most often not javascript-based because
that's sort of where we are these days
at least at the moment they've got a
mobile app or a couple mobile apps right
the interface with the server and then
they've got a browser experience that's
a mix of
client-side JavaScript and server-side
rendering typically and I found this to
be an incredibly common set up among
small to mid-sized companies at least in
San Francisco and so what I'm talking
about today is mostly this stuff because
I've seen lots and lots of different
teams tackle this piece of an
application using different client-side
JavaScript frameworks and mostly what
I've seen is that people who don't do a
lot of JavaScript sort of going down the
same road that I did in which they start
doing more of it I started noticing some
patterns I didn't think too much about
it though until I went to the fluent
conference earlier this year anyone here
go to fluent a few people it's a it's
the O'Reilly front-end technology
conference it's pretty big I think it's
three or four thousand people which
feels really huge to me given that I'm
used to things more like this O'Reilly
is a fairly large I was as you know
technology company here's one of their
official pictures they released ticket
prices for fluent ranged from 1500 to
$3500 which I thought was kind of
hilarious and that's how you can tell
it's a it's a
the conference right because they sprang
for the super expensive like they don't
turn over nametags with two connectors
just pretty cool you know the other
option would be just to print it on both
sides like we did here seems like also
an equally workable option but you know
you pay three thousand bucks you expect
fancy write that and I think a keynote
from Brandon Ike so that's what your
3,000 bucks gets you but I it's an
interesting it's an interesting
conference because the job as JavaScript
conferences go it's fairly conservative
it is one of those conferences that
people whose companies will only send
them to one conference a year go to a
lot and it's it felt like a more
realistic cross-section of people who
actually do JavaScript and something
like one of these smaller community
conferences because you do a conference
like this and you end up with sort of a
small audience of really enthusiastic
early adopters which is great and that's
what I feel familiar with that's what I
feel comfortable in but I don't think
necessarily that we are a representative
cross-section in many ways of the larger
set of devs who do javascript so fluent
was interesting for that so while I was
there actually spent a reasonable amount
of time hanging out and just talking to
people that I didn't know which is hard
for me as an introvert like I would go
up and talk to people that I didn't
recognize and feel like hi tell me about
yourself and why you're here because I
was interested in finding out what they
were there to learn and I meant three
types of people for the most part I met
back-end developers I usually might
expect trying to become more full-stack
whatever that means these days and they
came from a variety of backgrounds there
was a subnet folks actually quite a few
dotnet folks more than I expected
java PHP Python Ruby and then there were
the the visual UX folks and they were
coming at it from the other direction
right they're trying to learn more about
front-end development from a in many
cases and on developer background and
then of course there were a lot of front
end developers already front-end
developers who were there to just learn
about new technologies so these are
three groups of people with varied
sense of past experiences right and what
surprised me about it is when I talk to
them about specifically why they were
there
they all pretty much told me the same
thing here's some quotes I wrote down
you can see if any of them feel familiar
my group has started an ember project so
I'm going to every ember j/s talk on the
schedule which fluent has like six
tracks right so there's pretty much
always any given time slot it's pretty
much you could you could find one my web
app has an old jQuery code base and I
need to figure out what to do with it a
lot of that surprisingly I guess there's
a lot of it I want to learn about
angular I think I can raise my rates
almost certainly true and finally we
have an ancient background j/s setup
that desperately needs a rewrite but I'm
not sure in what and I think by ancient
she meant about six months old but it
was fascinating because no matter what
direction these people were approaching
front-end development from they all kind
of had the same question that they were
knocking around and that was which
front-end JavaScript framework should I
be using and that was the first time
that I realized that some of the
patterns I was noticing in my projects
might be useful to surface in a more
organized way but I want to talk a
little bit first about why we have this
problem and why it seems so daunting
right I mean why we have this problem is
at one level very straightforward right
I mean not embers fault right but this
this this is the problem there we go
in many ways this is of course a really
great problem to have we have a lot of
choices there's a lot of projects
addressing different facets of
JavaScript organization in different
places in our stack it does seem like we
have a few front runners but it's still
early right I mean react has gotten a
bunch of traction in the last I would
say six weeks it feels like a very short
news cycle here right
ionic just got a bunch of funding a few
months ago so it's pretty early it's
pretty early and you're looking all of
this and you're you're a developer you
have a specific project in mind and it's
really hard to tell what the right
answer is and that's where we come to
blogs right that's where we turn
the Internet has a ton of information
about this stuff and everyone wants to
tell you about it but it's really really
hard to sift through and find the little
bits of actual useful information in
fact I tried this last night if you
google how to pick a JavaScript
framework and you limit it to the past
month there's still more than 10 pages
of results which is crazy
that's crazy and what all this adds up
to is something kind of like this so
have a look at that and tell me whether
you can park there at noon on a Tuesday
and you know the different posts that
you find when go looking for other
people's opinions about frameworks give
you confusing and sometimes
contradictory information this is also
true of fluent one talk would be like
Emperor J s it's the best thing for data
binding and then in the same room and
the next time slot was an angular talk
that was like angular is obviously the
best for data binding and your job right
you've got a project you've got a
deadline and your job is to synthesize
all of this into some kind of decision
no pressure right but it's important you
know really important because the cost
of being wrong can be very high it's not
just are you parking illegally might you
get a $30 ticket if you think a
JavaScript family isn't suited to your
project to your team it can be anything
fort of mildly inconvenient to
disastrous depending on when you figure
it out house down the road how far down
the road do you go right before you find
out that there isn't any more road to go
down so my goal for this talk is to help
you pick frameworks with your eyes open
we're going to talk about a system for
evaluation that I've synthesized from my
experience and also from data that I've
collected from other developers about
their decision-making processes because
ultimately our goal is to get better at
these large-scale decisions but
unfortunately we don't make them very
often it'd be awesome if we did right
because one of the most effective ways
for our human brains to learn something
is repetition and I'm sure you know that
I'm sure you've heard that before we
have a particular meme in our part we
like programming pop culture about that
that it takes 10,000 hours of practice
to get great at something right playing
an instrument or programming
um or whatever it is this person is
doing I don't want to do that for ten
thousand hours to tell you that right
now this is a huge oversimplification of
how human beings learn but the kernel of
truth in it is that repetition actually
is great for your brain your brain loves
it when we do things over and over we
get better at them the key though which
I think that this meme obscures for many
people is that it's not just the time
spent it's how you spend the time you
can spend 10,000 hours on something but
if you're not doing it right those hours
are wasted so to really learn by
repetition what you have to do is is do
the action analyze the outcome repeat
the action changing it a little bit it's
the key part changing it to see if that
changes the outcome and feeding that
back into your loop and even once you
think you got it even once you think you
got that perfect cursive letter L you
need to keep experimenting keep trying
new things and that's that's where
learning actually happens so the problem
with this though is that if we're lucky
we might over the course of our entire
career make large-scale technical
decisions as many times as there are
letter Elle's on that worksheet maybe so
one way to get better at them is to wait
10 years 15 years to accumulate enough
experience for this type of thing
another thing we could do though is make
an end run around this time based
limitation by analyzing decisions we do
make all the time and then bringing that
intelligence back to our framework
choice so that's what I did I just did
this talk in England and I had to spend
five minutes explaining what this slide
was
I totally forgotten about that anyway so
our technical decisions happen at very
different frequencies and very different
scales so language and framework choices
are the most infrequently made decisions
that we have however there's a few more
things that we do more frequently such
as I decide whether to use some random
code you found on github or write your
own
and even more frequently than that or
all the technical systems we make every
day which are things like where does
this code go what should I call this
variable is it time for me to write a
test or should I go play ping pong and
what's interesting about these decisions
at every scale is that even at the
smallest most frequent level things we
do every day
the process we use to make these
decisions is pretty opaque if you ask a
programmer why they named a variable a
certain thing or why they put that
function where they put it often you get
a somewhat unsatisfying answer like well
it just seemed like the right place to
put it
or sometimes you get something like
experience intuition gut feeling when I
ask programmers probably like amber over
angular or the other way around I get
very similar opaque responses I get
things like it feels more natural hear
that a lot and I've heard that said
about both amber and angular from
different people but as a scientist I
find that very unsatisfying obviously
we're collecting data obviously we're
doing something with it so I wanted to
investigate a little bit about what goes
into that feeling hook us into our gut
feeling what goes into our intuition
what data are we collecting how do we
organize it what do we do with it so
ultimately my goal was insights into
these so I took a look at those because
as it turns out I know a lot of people
who evaluate libraries off github all
the time and in fact I'm sure you do too
so I asked a bunch of my colleagues to
introspect for me and describe how they
evaluate code they're considering using
in their project and the first time I
did this I started out by talking mostly
to my Ruby friends
I expanded it I asked some net folks I
knew I asked some Pearl developers
massing JavaScript folks and it was
amazing that actually it doesn't vary a
whole lot it varies a little bit but it
varies fairly minimally and so my list
of things that they told me about like
how do you evaluate a piece of code is
huge I would have to put it in very
small font in order for you to see it
all so we're not gonna look through it
in detail I'm gonna put it up here just
long enough for you to not just long
enough for you to feel frustrated by not
being able to read it and then we'll
we'll go through it by category start
categorizing and stuff so yeah
ridiculously small font and that
actually is about 2/3 of the stuff that
I got I sort of had to edit for length
but it turns out that all this stuff
basically falls into four broad
categories let's talk about those rather
than going through the list one by one
and these are the four categories first
we're gonna look at his interface
interface is technical data about the
library this is things about its
features its functionality it's usage
what does it do and how do you use it
this information is easy to find usually
on the readme if it's a good hub project
these are the bits that are interface
this is basically what everyone starts
with everyone starts to read the readme
is a time-honored tradition here's one
from 1936 about how to use the telephone
and it's pretty awesome because it's
basically like every readme on github
here's all the bullet points how to
operate how to answer how to clear how
to make calls great right all it's
missing is installation instructions
because that comes in the five books
supplement later so here's a more modern
version slightly more modern version
readme tells you what it is and how you
do it and so when you're considering
interface you're basically trying to
figure out the question you try to
answer is will this code be sufficient
for what I needed to do and most often
and most projects comes to readme in
some cases you may need to drop it in
and mess around for a while if the
documentation is particularly poor
that's one category of evaluation the
second activity this is things like
looking at the number and recency of
commits on github you don't want
something is abandoned right looking at
the github issues and pull requests how
long have they lain dormant it also
includes things like when was last
release how up-to-date are the official
docs in general with this category
evaluation we're trying to figure out
how often is it updated how likely I
might get help from maintainer I got a
pull request merge things like that it's
this stuff activity is this project
sufficiently active that I can depend on
it next category is popularity meaning
amongst other developers how easy will
it be to find help when I run into a
problem can I hire somebody who's used
it already how likely is that someone
else has already fixed a bug by the time
I get there to figure this out we look
at things like how many tutorials and
blog posts are there when I google it
how many Stack Overflow questions are
there and have any of them been answered
we also ask other developers we know
either directly or in kind of a meta way
through hacker news or reddit or Twitter
or something like that we look to see
whether it's been mentioned on news
sites podcasts things like that and
these things are basically popularity of
a project and we're left with a couple
of outliers evaluating the code directly
and evaluating the tests these are
things that I call accessibility and
it's this one's a little weird the other
three categories are pretty
straightforward and they have pretty
well known sources of data you could
probably write a script that would give
you some kind of relative score for
those other three things right interface
activity popularity relative to other
libraries but what we have left is a
little fuzzier it's really about how
familiar things feel to you is this code
idiomatic does the maintainer share my
test strategy how much does the code
match up with what I would write if I
were gonna roll my own how much does
this code feel like other code I've seen
how does it feel to use it
are the author's ideas about programming
the same as mine essentially there you
go those are our four categories and
these are the types of things we
consider usually unconsciously when
we're making a smaller scale decision
now at the level of like should I use
jQuery cookie it's probably not worth
explicitly going through and thinking
about all of these things instead what
happens right as you poke around at
github and then you kind of make an
intuitive quote/unquote intuitive
judgment one way or the other and move
on with your life it gets interesting
though when we start applying these
categories to the larger scale decisions
like frameworks
first let's do a little bit of meta
categorizing because we can actually
start drawing some lines here you ready
we're gonna make quadrants quadrants are
very exciting apparently this is a thing
so first of all you can draw one line
here the two categories on the top the
accessibility and interface are both
about you interfaces about whether the
code can actually do what you needed to
do for your project and accessibility is
about whether your team feels
comfortable with the metaphors the
project uses in its code it's called the
internal stuff on the bottom these two
categories are about the people in
project outside of your team it's a
popularity and activity measure external
factors so we have that divided and then
of course we have another one on the
left side accessibility and popularity
both have to do with the people around a
project accessibility is whether or not
your people can use it popularity is
whether or not other people are using it
and on the right side interface activity
are both information about the project
itself the interface is whether the
framework does everything you need and
the activity while it's of course
generated by people is ultimately about
the project it's about whether or not
you can count on bug fixes and
improvements down the line so you go
there's my four quadrant system for
making technical decisions I was showing
this talk to a friend we got to this
part he was like this is awesome because
you know consultants are supposed to
have a system they're selling and your
consultant now so you've got to have one
you should definitely use this one it's
got the right number of quadrants
everything's going to be awesome
and I thought if I'm gonna own this I
gotta own it right I got to give it the
super narcissistic title here we go
whoops there we go people project the
may system thank you very much lazy goin
this really makes you want to throw like
500 bucks an hour at me then you know
let me know otherwise I think I'm gonna
stick to my pair programming approach
that's okay with you
so you know so far what we have is
interesting but maybe it's not useful
we've captured the practices people
actually do into categories and you know
categories are pretty awesome
I like these categories but the
categories really only become powerful
when we apply them to the higher risk
problem so let's look at how you would
apply these to a high risk problem like
picking a framework I mean I guess we
could pledge and we could try applying
these but let's apply the other ones
these would be an interesting separate
talk so start with interface interface
is pretty straightforward right the
interface of a framework is what's in
the angular ravine it's what's in the
amber readme it's what's in the intro
tutorials these are the bullet lists of
features that make up most the blog
posts that talk about picking a
framework next we have activity largely
the same also as at the smaller scale
you can get this where the kids a github
project you look at the release schedule
look at the docks popularity also
largely the same Stack Overflow content
percentage of hacker news arguments
number of recent blog posts so these
three again pretty straightforward once
again the interesting one is
accessibility because in client-side
JavaScript land where we are today
anyway there are quite a few frameworks
with a sufficient interface sufficiently
popular and sufficient activity because
we've got this huge crowded field but it
feels like in the mainstream today we're
kind of looking at that we've got a
we've got backbone we've got angular and
we've got ember and all three of these
can do what your application needs it's
do they're all reasonably popular
they're all reasonably active the only
way that we as developers can really
distinguish them from each other is
accessibility
but it's pretty hard to untangle what
accessibility means with a framework and
this is why we fall back on things like
it feels more natural when people ask us
why we like one or the other but over
time with the projects I've done I've
seen lots of developers try and in some
cases struggle with different
client-side JavaScript frameworks so to
explain how accessibility plays out here
I want to start a little bit of history
about how the Java programming language
and JavaScript have historically gotten
along I took it off my resume but I
actually used to do Java back in the day
in the late 90s and early 2000s which
was really really not a good place to be
if you were a JavaScript developer at a
time for a long time the Java
relationship with JavaScript was very
sad despite the name confusion and the
state of the art for a while was
something called Java server faces
I don't know if anyone remembers those
I've tried to push them out of my mind
as much as possible they are packaged
front-end widgets usually with a really
old version of jQuery and to put one on
your page just put a little directive in
your markup and it spews a bunch of
JavaScript into the page and it hooks up
automatically to your back-end and you
never have to write any JavaScript and
that is considered a feature and in that
way and in many other ways the Java
community has over the years put a
pretty intense amount of effort into
avoiding JavaScript entirely as much as
possible and there were other efforts in
this direction I don't know if anyone
remembers gwit Google web toolkit right
which was like write Java compiled down
to JavaScript never have to write new
JavaScript that way there are more
modern approaches things like Dart
they're basically all efforts to allow
Java developers of which there are
hundreds of thousands to write
JavaScript without actually having to
learn it however in the Java world these
days there's a new contender
that of course is angularjs written by
Java developers and featuring a
dependency injection structure eerily
similar to those found in modern Java
back-end web frameworks
so if you come from the Java back-end
world or the dotnet back-end world where
dependency injection frameworks are
standard practice and goes gonna feel
pretty familiar
it will feel accessible right and this
is a huge step forward for the Java
world because it's real JavaScript this
time which is great super excited about
that however it has a structure layer on
top of it that makes it less risky for
them to adopt because they can do
JavaScript without having to learn an
entirely new development paradigm and
conversely for those of us who don't
come from Java or.net the dependency
injection in angular feels pretty
disorienting at first it's fun it's neat
to get your head around but it's
disorienting a little bit and that makes
adoption riskier because we have to take
on the cognitive load of understanding
the framework and understand the
concepts that it presents in addition to
trying to actually get done and of
course there's a learning curve on any
JavaScript framework for any team but
finding a framework that fits the way
you already think makes the adoption
less risky in some ways and so that's
what accessibility measures at its core
it measures how steep learning curve is
likely to be for your team give you
another example we have ember Jas with
the mascot that is a hamster apparently
someone told me the other day it's
called a Tom stirrer because Tom Dale
has glasses that look like that or
something I don't know anyway I don't
find the hamster quite as creepy as the
Go gopher I don't know if any of you
have seen the gopher this is the most
freaky conference logo I've ever seen in
my life
I think Co is a language as fascinating
but they really got to do something
about that because that is super creepy
anyway hamsters back to hamsters Tom
stirs whatever so amber Jas was built by
rails developers and it features at the
center of all ember app legations a
router which is a piece of code that
takes in a request URL and decides what
code to run as a result of that URL now
this is eerily similar to what you find
at the center of all rails applications
and this concept that the routes coming
in determined what code gets called
flows from rest which is a relatively
new idea or rather relatively new to be
popular let's put it that way so if you
come from a web framework that matured
in the restful era something like rails
or Django emerge is will feel very
accessible it'll feel easy feel natural
on the other hand if you come for a Java
or.net or another web framework that
matured before rest was a popular thing
then you are used to having much more
control over what happens exactly to a
request and because of that ember may
end up feeling a little bit overly
constraining and finally a last example
backbone which is the oldest of this set
was graduated out of a server-side app
in the 2008-2009 time frame I know it's
hard to think back that far at least is
for me but that was before the idea of
single page apps was really a thing I
think there were a couple people over in
a corner doing like cappuccino somewhere
but pretty much most people thought
about javascript is something that
decorated a server rendered page
so you'd render a view you'd assemble
some JavaScript you'd shove them down
the pipe together to the client and once
they got there the JavaScript would add
a veneer of interactivity over the
markup and so if that's the kind of web
application that you're still building
yeah
it's at 4:20 yet so that usually means
so if you still think about web
applications as a a some markup and a
veneer of interactivity on top and if
your web application is still thinking
about pages in that way then maybe
backbone will feel natural it'll fit the
way that you already think about things
and it may not be convenient sometimes
but it does have a bunch of descendants
that might be more convenient but if
you're one of these kids today that
thinks about a web application is a
bunch of JavaScript that runs in a
browser like create some markup and then
goes out to the internet to get data
once in a while then backbone is going
to feel completely wrong it doesn't fit
that type of project so for this
framework the accessibility judgment
flows from the types of projects you've
done rather than necessarily the
technologies you've done them in that's
with angular and ember and accessibility
is a judgment that comes from a lot of
different sources when we're talking
about frameworks and just because they
are more complex than something like
jQuery cookie so one source ARRA is the
set of technology stacks you've worked
with over the years and other source of
the type of projects that you've done
what industries you've been in and so on
and oftentimes in a single project you
may have more than one thing that's
that's that's contributing to this
judgment so for any given decision
accessibility is kind of the most
difficult of these to figure out it
because you know it's not like the
angular guys have a bullet point in
their read me that's like by Java
developers for Java developers right
because everyone who's building a
framework thinks they're building it for
everyone but they're all wrong what
they're actually doing is turning the
way that they think into code they are
codifying their assumptions into code
and so I guess the question is how do
you see that besides coming here and
listening to me make quadrants for a
half an hour and the answer to that
really is as fun as it is to talk about
it you probably don't actually need to
know what their biases are when you're
making a decision because you'll be able
to feel how well they line up with yours
you'll be able to notice the amount of
ease or the amount of money
you feel when you're working with a
framework and the last thing to consider
is that even once you're explicitly
thinking about accessibility it may not
always be the most important factor in
it in your decision sometimes you have a
team is over tax and you need a way to
adopt a new technology that's as close
as possible to what they already do but
other times you and your team are ready
to do something challenging and new and
different sometimes you want popularity
because you know you're gonna need to
hire five people in a tight timeframe
sometimes to pick something totally
unpopular because it has that one
feature you need right but the key here
is to remember that when you're making a
decision make sure that you're
explicitly thinking about each of these
four quadrants of things because when
you're doing a large-scale technical
decision it's more important to make
these things explicit than it is when
you're talking about jQuery cookie so
finally I want to close with something I
saw in hacker news a couple of months
ago or actually I didn't see it Steve
glad and excited and he reads hacker
news so I don't have to and the context
here is a blog post about Nimrod which
is an obscure programming language and
one of the commenters talks about all
the great features it has how great the
interface is and he says the only reason
Nimrod isn't popular is because people
don't evaluate things logically and it's
clearly very frustrated and I actually
sympathize at that point of view because
the decisions that other people make
really do look mysterious if you think
that like this is all there is to think
about when you're evaluating a
technology and you see this a lot
especially online maybe perhaps
especially on hacker news you see things
where people think that considering the
other three options considering the
other three quadrants rather is just
illogical that really all you should
care about is interface which is an
interesting point of view I mean Nimrod
is failing to catch on he's quite right
about that part but it's not because
people are illogical it's failing to
catch on because
he's here but we're at the top right
there and we can see a little bit more
expansive view than you can from down in
the valley so even though we can't
repeat the language or the framework
decision more often enough to learn from
the repetition you can take these
categories and at least let them expand
your Vista a little bit when you're
thinking about large-scale technical
decisions and a very wise man once said
change of perspective is worth 80 IQ
points and I would say with this stuff a
change in perspective is where the ad IQ
points and possibly about maybe five
years of experience or so that's all I
got thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>