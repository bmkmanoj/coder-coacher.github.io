<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Performance Checklist for the Mobile Web | Coder Coacher - Coaching Coders</title><meta content="Performance Checklist for the Mobile Web - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Performance Checklist for the Mobile Web</b></h2><h5 class="post__date">2013-04-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0UNWi7FA36M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're gonna go ahead and it started
because we have plenty of time and
there's tons of stuff to cover so hello
everyone awesome my name is Colt McAnlis
I'm a developer advocate working on at
Google on the chrome developer relations
team and my primary focus is actually
web games which means that while the
rest of Google is off trying to make the
internet a better faster safer more
social place I get to kind of go off in
the corner and play video games all day
so it's a really tough life that I live
what I won't actually talk to you guys
today about is I performance checklist
for the mobile web and everyone in the
right classroom right you don't need to
go down the hall if you're in economics
101 or something right fantastic before
we get started I want to point out this
fantastic little hashtag down here perf
matters how many of you work in a
situation where performance the
performance of your applications matters
to your company's bottom line in your
job that's not every hand in this room
I'm going to tell you to get out
fantastic if you see something today
that inspires you a statistic you didn't
know something else that just makes you
go wow that guy's not as bald as I
thought he was take to the interwebs
take to your social media use the perf
matters hashtag it's a fantastic
opportunity to socialize also below it
you'll actually see the the shortened
google google Oh anyhow that shorten URL
is actually to the G+ web performance
community and don't worry about these
will actually be on all of the slides
with the Google+ web performance
community is actually a great place
there's already a ton of very smart
people they are posting content about
web performance you'll see posts from
guys like myself from Steve who gave the
keynote this morning Ilya Grigori Paul
Lewis tons of the big heavy hitters uh
so make sure you check that out and join
because it's a fantastic place even
though google reader isn't around
anymore so let's get started here um I
got I got to be honest with you guys I
actually pitched this talk a couple
couple months ago mainly because I was
angry I was super super angry because
this was the web that I was getting on
my mobile device just constantly and it
seemed like more and more and more the
websites i would go to will be trying to
convince me to go and find
their native version right so I go to a
website listen guys I just want to know
if you guys are serving teriyaki chicken
tonight I don't want to download the
native app for you know ty Bangkok
orchard restaurant down on camden street
just just tell me if you guys are
serving good food and so I realized
after after interviewing so many people
in so many companies like why are you
doing this what is the what is the
reason what is the plan is it engagement
it is all these other things the number
one thing they kept coming back to me is
saying it's all about performance that
that they tried to get the right
application and the right experience for
their users from their web app running
on mobile inside of the browser and they
just couldn't do it and I got angry
about this like like Hulk angry like I
flipped the desk in like Housewives of
New Jersey was actually pretty funny the
first time I failed and then like
someone came in is like no you have to
flip it this way and anyhow don't try to
flip a desk on without stretching first
is what I'm getting at anyhow the whole
point of this was to come to a
conclusion about you know what we
actually can get the performance that
you're looking for but you have to look
at it a different way you see any of you
in here who have worked on multiple
technology stacks know that what works
on one platform doesn't always translate
to the other platform right i mean
memory models are different call stacks
are different the amount of taxation
that the underlying operated operating
system takes away from you is completely
different you have to approach things
with a different mental model and what
we're going to talk about today is the
mental model in the checklist that you
need to be embracing when attacking
performance for mobile web now the
interesting thing about here is isn't
and now everyone raised their hands so
this should be completely obvious to
everyone so let's talk about user truth
especially for mobile so these
statistics has been around a while that
one in four users or depending on where
you go to forty percent of the users who
visit a site will abandon it or bounce
if it's not loaded in three seconds
everybody know that's that it's a nice
little haunting stat right the if your
company does what you know three million
a year in revenue because pages load and
people buy stuff and you know one in
four actually leaving because it's not
loaded that's tons and tons of money of
that forty seven percent eighty percent
of those people said that they would not
come back to that mobile website that's
pretty haunting right so not only did
you lose them the first time you've lost
a massive majority of them for every
time after that and here's the scary one
of those 80
sent that said they would not come back
fifty percent of them said that they
were very very enthusiastic about
telling their friends not to visit your
website the rage of these people which
is actually pretty interesting right so
if you if your page doesn't load in
three seconds not only have you lost
that user but potentially all of their
friends as well right this comes back to
that little hashtag performance matters
and it matters at every stage of it to
not just loading of web pages so if you
guys have actually watched the videos
from edge conference London which was
back in February anybody familiar with
that one nobody awesome new data
original content on the Internet so at
edge conference Facebook had a fantastic
statistic and they actually said in yo
face book of the html5 conference you
know obviously they have a lot of weight
in that game as well they said hey we
ran a proposal we actually took our
native application which was running at
60 frames a second and we arbitrarily
slowed it down just to screw with our
users more importantly they wanted to
see how user engagement and attachment
rate would fluctuate based upon the
experience of the performance of their
native application now they were in a
native app so they could actually
arbitrary slow it down so this was
actually a pretty cool test so here's
what they actually found out was that it
60 frames a second everybody was happy
rainbows were flying through the world
everyone saw unicorns when they checked
the like button it was good times for
everybody when they artificially
throttled it to 30 frames a second they
actually saw user engagement drop they
saw happiness drop they saw a user
return rate drop most of the people
would actually they said they actually
got a bunch of emails from people
emailing Facebook and saying hey your
app all of a sudden got slow please fix
it I won't come back until you do the
shocking part of this was actually when
they throttled it at a variable frame
rate between 30 frames a second at 45
frames a second at this point they
actually saw user engagement dropped
through the floor they had people with
pitchforks and torches and marching on
the main building because it was it was
just it didn't feel smooth and it didn't
feel right with these two statistics
actually tell us is something very
important the people are misusing the
term web performance most of the time
when you talk about web performance
you're just talking about this first
statistic over here how fast is your web
page load but obviously it's not just
about that it's also about the
experience that the user gets while
using your applique
which is also directly related to
performance so what we're going to talk
about today then is that it's not just
about network but it's also about your
compute performance while the user is
using things right how your garbage
collector is being managed how long
you're taking in your inner loops how
much are you touching your dom for that
matter right it's also about render
performance with all the fancy new stuff
going on with GPU optimization tiling
software rasterization scrolling and
every other 50 buzzwords right you can
actually get things very very very wrong
by doing some simple CSS which seems
easy and should seem fast but actually
you know throws a wrench in your entire
pipeline so these are the three pillars
of performance from now on anyone in
this room when you walk out of this room
and you talk to someone about web
performance you will use these three
terms right I love the random thumbs up
that's cool i wanted sure it's just got
a bunch of thumbs up and like I went to
colts talk so anyhow let's get to this
checklist let's start with network
performance because this is obviously
the old school so let's let's start at
the top here so why is the mobile
Internet a little bit slower than your
desktop internet well let's take a look
at things here if you have a mobile
device some random arbitrary device I
don't even know what form factor that is
and you have to ask yourself how does
this thing actually communicate to the
internet and download all my wonderful
pictures of cats well of course we
already have an existing infrastructure
of cell towers that have been in use for
a lot of time the funny thing is your
mobile device actually comes with this
nice little piece of radio chip in there
and any time you actually want to access
your data your phone will send data
through the radio chip to communicate
with the cell towers which then actually
goes to the intertubes finds the cat
send its back to your phone so here's a
really interesting thing is because the
fact that we're not using sort of modern
technology the stuffs been around a long
time we're limited on what types of data
transmission rates we can get through
these older towers so of course you know
most of America is actually sitting
nicely on really fancy 500 our phones
and 3g internet right well 3g will
actually do about three mega bits per
second at its max capacity that's
actually not what you get you get 3
megabits per second when you're standing
under the cell tower right like bashing
your phone against it trying to download
that new rihanna song or something right
to give actually to talk about that so
that'll actually download a 3-minute
song in a
15 seconds just to kind of put that in
perspective now to take a step back when
I connect to my neighbor's Wi-Fi I
actually get about 16 megabits per
second right now that's actually going
through a concrete wall a restraining
order and then another concrete wall so
obviously obviously there's some some
ground that our mobile networks needs to
make up so if this isn't all right so
you have to understand that as the users
are pulling data off these wireless
networks is obviously going to be
Explorer experience for them but here's
actually the kicker is that that radio
has three states it's got active pending
and idle when that radio moves from idle
to active it takes about one to two
seconds for it to turn on and negotiate
transmission with the cellular network
now this this should scare every single
one of you in this room that you didn't
know that because I just showed you a
slide that said if your web page doesn't
load in three seconds you lose 40
percent of your users two seconds are
gone if the users radio isn't turned on
that means you got one second good look
so you have to take this into account
especially when you're doing and
never-ending sites delayed low content
infinite scrolling write these things
very much matter on the fact that you're
loading content over time and if this
radio goes into the idle mode you have
to pay that to second connection every
time it pulls new data if you're lucky
right and only about 15 seconds elapsed
then it'll just go in sort of the
pending mode and maybe you get half a
second delay but if you know they check
their mail and then almost didn't say hi
to their friend or you know watch
Louisville beat Duke yesterday which
made me cry a little bit you know and
then they go back to the phone they got
to pay that time again which is not
necessarily a deal so this actually
leads us to a huge big problem
responsive design anybody responsive
design yes lots of hands on there we've
got what seventeen thousand different
resolutions that you have to make a
mobile website for now right so the
popular thing to go out and do is
actually say hey let's do responsive
design maybe a handle big images small
images lots of resolutions high DPI low
DPI androids I phones smartphones
watches shoes and Google knows which was
announced today as well if everyone saw
that april fools
so the problem with this is that you've
got a lower band network and people are
actually just snapping pictures off
their cameras and sharing them with each
other through social networks and other
sorts of things so this image on the web
right here is actually about a 1280 by
720 very very small by modern smartphone
capture standards right here's the
interesting thing if you actually just
save this as most standard camera
captures do as a PNG that's about 2.3
mex right now remember with 3g standing
under the cell tower you get about 3
megabits per second so obviously this is
going to take some time to download if
you compress that with JPEG it actually
drops down to about 297k now this is
fantastic right it's a it's a fully
opaque image you don't need transparency
data so you actually get a lower
resolution but how many people in here
have actually heard of the web p
standard right so web p is a new
compression technology because people
have actively stepped back and said wait
a minute sixty percent of websites are
made up of images especially those going
to mobile we're spending tons and tons
of time for users to download image data
most of these pixels aren't needed or
their high resolution but effectively
you're downloading a 1280 by 720 image
down to a small device and doesn't need
to happen interesting fact too so
actually before came to Google actually
spent about ten years as a game
developer so I bounced around between
studios that did lots of fun games that
I won't mention here on camera but you
can find me afterwards and one of the
most important things we found were that
human beings were really bad at
compressing texture data we would have
an army of artists sitting in a room
making textures to fit on a bullet right
and this bullet would only occupy like
three pixels of the screen but they
would have this huge 512 by 512 texture
on it right like if you put that texture
on the moon you can see every little
divot on side that bullet and the thing
was that you know that he wanted the
data there they thought the data needed
to be there but it just wasn't needed
and then we found that we could compress
ninety percent of the noise away and the
human I wouldn't notice in fact if you
actually look at this image this is
actually post web p compressed and
upscaled about four times who noticed of
course there's a projector you can blame
it on the projector but on the slides
and it's really cool so the point here
is that when most people actually
capturing about five mega five megapixel
images on their phones and uploading it
up to the internet you know the size of
your image
have it has a huge toll with everything
yeah number two this is actually a
pretty simple fix for any of you server
programmers in here you're just going to
facepalm ago OMG i can't believe we're
talking about this but the fact is that
your content is really too large right
so with ATT roaming rates inside of
europe as of today may you know may
change in the future they're roaming
rates charged about nineteen dollars per
megabyte downloaded right which means if
you want to load microsoft com that user
actually has to pay ATT seventeen
dollars to load a homepage here in
america we actually sit pretty well on
nice prepaid pant plans with unlimited
data but when you start looking at these
other cultures and how much they pay for
internet access you start to worry about
what your page weight looks like so
let's say you actually have a 256 KJ s
file right which is actually small again
sixty percent of your pages is mostly
image data well that getting transferred
to every single mobile device is not
necessarily ideal it's actually pretty
easy today with most modern web servers
to enable some high high data traffic
protocols for example just turning on
gzip compression or actually turning on
speedy how many people have messed with
speedy awesome near my bro's turning on
gzip compression in speedy is analogous
to actually sending a 36 k javascript
file to these clients now again you're
sitting on a slower mobile network
that's already dominated by image data
that's oversized and over compressed
actually crunching these extra bytes out
of your javascript files is pretty
important rex we should all be
minimizing and on few skating our
javascript as much as we can to send it
to the mobile web we should be doing
these things on the server side as well
and most of the time they're just simple
switches or simple configurations you
have to turn on they can actually yield
huge and significant performance
benefits for your users so for those of
you who are new to the network
performance arena and would like to know
more about it there's actually some
fantastic tools inside of google chrome
and elsewhere to actually take a look at
this so if you have a hypothesis that
the network is your problem for your
users i highly recommend stopping by the
chrome devtools network tab just load
your site take a look at what's going on
this is a fantastic little Timeline view
that will actually show you what assets
are being loaded how long it's taking to
load them and then how long it takes to
actually process the data more
importantly you can see how this scales
over many devices because hopefully
everyone knows in here that all of
chrome devtools actually work off of
these android devices so you can
actually reload your site on your
Android and actually do analysis on
Chrome on your desktop and actually see
how your device is responding with the
network conditions you have it set to
that's fantastic if you want to dive a
little bit deeper into technology stack
there's a great tool called PageSpeed
PageSpeed is an amazing suite of tools
that will actually do some suggestive
analysis for you PageSpeed will actually
well page sweet is kind of like your
your older brother who's a little bit of
a jerk to you right and he's like yeah
that's a nice website but how come you
didn't compress that image fifty percent
but you could make a better website
there you know or so basically it'll
actually go through and actually do this
analysis and tell you hey if you
compress your images using a forty
percent reduction in PSN are you can
actually save about fifty percent in
transfer time your site or if you concur
you can compress your JavaScript more or
here's some JavaScript function that you
really shouldn't be loading anyhow it's
a fantastic little tool that you can do
that will run suggestive analysis on
your page if that's a little too deep in
the stack for you you want to bubble up
you should definitely check out
something called webpagetest org
hopefully everyone in here already knows
about this this is another fantastic
site that will actually give your
webpage a grade so you can actually go
in there type in your web page and
they'll actually give you great so
actually just just to mess with and the
other people who run this conference I
actually typed in html5 dev com schedule
and this is the results it got right so
a for first time to bite this is how
long how long it took the bite to get to
the screen after initial request
keep-alive enabled compressed transfer
so they're actually using some data
compressed transfer from the web either
gzip compression or speedy which is
fantastic they got addy and compressed
images so obviously there should be they
should go to actually try to compress
their images a little bit more maybe
down res them and f on cash static
content so this means that they
obviously weren't setting their cache
headers to infinite or some other time
out so this means that over time the
user would have to redownload a lot of
this content with these three tools you
can actually not only find where your
problems are find suggestions for
improving it over time and actually get
to work immediately so everyone in here
who raised your hand that said
performance matters to your job this is
going to increase your bonus next year
good sum up get that guy t-shirt Peter
t-shirt
this is the bonus I saved our company 20
billion dollars and all I got was this
lousy t-shirt so let's talk about
rendering performance so hopefully a lot
of you are using really high-end web
browsers on these mobile devices which
means that most of you will actually
have a GPU path in your browser does
anyone know that does anyone actually
looked at them cool new information on
the Internet so what this means is that
for those of you who don't understand
how a web page is actually rasterized to
screen what happens is all of these
little things that you specify and dom
and in CSS actually go through what's
called a software rasterizer what this
is going to do is take your content
defined an HTML and other portions and
actually push each of the pixels into a
separate bitmap that bitmap is going to
be stored in memory and with some paths
like the hardware accelerated path
inside of chrome it will actually push
that data to the GPU and then the GPU is
actually responsible for rendering these
bitmaps on screen what this means though
is that you actually have a software
rasterizer running on the backside of
your browser that's creating all this
content and effectively touching this
massive palette of pixels in memory
here's the cool thing all those CSS tags
and properties that you're using to
actually modify your page they have
implicit costs or they have explicit
costs that may not be implicitly
noticeable to you so for instance I ran
a little test I said hey I want to know
how much the paint times are for every
single CSS property that exists so I
wrote this really big harness that would
spit out probably about 80,000 web pages
each webpage has a single Dom element
with a single CSS property on it right
so with this I can actually run through
all these cool processes and figure out
exactly how long a web browser was
taking to paint each one of those CSS
properties it was haunting what I found
so first off what you should notice is
that the same property with different
inputs can have drastically different
performance so what you're seeing here
is box shadow with one pixel one pixel
actually performs medium right one two
three black actually gives you the best
performance why I don't know but if you
put box-shadow one two three four gives
you horrible performance right because
something is going on or the hood you
have to remember we're doing software
rasterization and some properties are
easier to rasterize than others right
taking an image and bleeding it to
another image is actually pretty fast
but if you want to add an arbitrary drop
shout to a concave object you know paths
have to be created they have to be rear
aster eyes they have to be clipped they
have to be alpha transparent gradient
eyes tons of stuff happens to happen
what gets even more haunting about this
is that when you actually start seeing
that combinations of CSS properties have
a non-linear time or non-linear cost so
if you add box shadow and border radius
stroke both of these actually take about
the same time if they were singular on
the element when you combine them
together you get a 3.2 X increase right
so it's not just a linear thing it's not
just a plus B equals C it's actually a
plus B equals three point two x 3.2 c or
whatever so this is actually really
important right because this means that
you have to start evaluating what your
page render weight is based upon how
much time is being taken from your CSS
property during the rasterization phase
if you'd like to go even deeper into the
rabbit hole who wants to go deeper in
the rabbit hole yes I want fireworks for
you guys like if you want to go deeper
into the rabbit hole how the hardware
compositing inside of chrome works is
that it will actually dice up your web
page in a 256 x 256 tiles and then we'll
actually render into each one of these
256 tiles and then store that in a CPU
LRU cache as you scroll vertically on
your page you will actually run tons of
heuristics evaluating memory footprint
overhead time to fill those tiles and
actually you'll dump some out right so
it actually keeps sort of a static
memory footprint and then it'll actually
update to the GPU so if you scroll to
the bottom of your favorite Pinterest
page because there's a really awesome
recipe for apple cider down there and
then you scroll all the way back to the
top chances are those original tiles
aren't in the cash anymore and have to
be rear aster eyes which means you're
once again paying the additional
overhead to re rasterize those tiles
it's pretty kooky after a while main
point of this slide understand what your
pages render weight is moving forward
the trouble with images part 2 so this
is the same image that you guys saw
before it's fantastic and this is the
device that you're sending it to right
that's not cool right you're sending
this nice high resolution image is
actually showing up on a very small
screen obviously we talked about this
before responsive
web design but here do you understand
why that's actually a problem it's not
just a problem for network bandwidth you
actually get double taxed when you send
images that are too large let's take a
look at this so this is actually a
timeline that was captured during
rendering of one of these tiles that I
was talking about last a couple minutes
ago so what you're seeing here is this
is actually a frame so three images were
on the screen one of them was small one
of them was super large and then one of
them was medium-sized okay all of these
images were dynamically resize to 128
pixels by 128 pixels this big bar here
is the scariest thing I've seen in my
ten years of professional performance
development this is 51 milliseconds to
decode that image so that 51
milliseconds isn't is not small right if
you consider your page needs to be
running at 60 frames per second that
means you get 16 milliseconds per frame
while the user is moving their mouse
around right at 51 milliseconds you just
blew about four to five frames here's
the cool part after you've decoded this
monster 1680 x 1050 image you have to
spend in an additional twenty nine
milliseconds to resize it down to 128 x
128 and again this happens every time
that tile that the image is touching has
to be rear asteroid in contrast you can
see that this image that's actually half
resolution of the one up there only
takes 22 milliseconds you're going from
80 milliseconds to to decode and resize
an image when if you actually made it
closer to the standard native resolution
it only takes 22 milliseconds yeah
that's kind of haunting right anybody
haunting no I see three people asleep
I'm gonna wake you up number three here
so if imagery paints and sizes and all
this stuff wasn't haunting enough for
you let's talk about reflows again we
all come back to dynamic risa dynamic
response right because everyone says hey
only where I don't want to write my code
once and have it run everywhere here on
the internet so I want to do things
right so let's take a look at this code
seems pretty innocent enough right so at
the top we're actually getting some
container divs and then we're actually
going through and getting some some
children dividers that will be existing
inside of that and then we're going
through for each of our child
and setting its width equal to its
parent container dot width right seems
pretty innocent right you just kind of
resize your thing everything matches in
there well what's actually going on is
that this is one of the worst performing
pieces of JavaScript code that you can
write okay here's why every time you
modify the property of AD of the Dom you
cannot read from that Dom until
everything's been recalculated because
you may inadvertently change something
which modifies the position rotation or
timing of something else on your web
page so what's going on here so once you
actually write to style dot width okay
it'll actually set a dirty bit on the
Dom the next time your attempt to read
any property from any element that's in
the Dom it says hold up brother I got to
go recalculate some stuff it'll run off
in the corner and actually spend some
unknown amount of time 5 milliseconds 15
milliseconds 30 milliseconds you don't
really control that since it's based
upon the size your Dom in the complexity
of your dog and then it will come back
to you and actually give you that that
two pixel value that you actually wanted
in the first place so what's actually
going on right here is that you're
actually doing an initial read from
container offset width and then you're
doing a right into style dot width when
that loop comes back around you're going
to try to write you're going to try to
read again it's going to go hold on
gotta go reflow come back right you're
going to come back around through the
loop hold up gotta go reflow and so what
happens is every for every single object
inside of this Dom that you want to
touch you're gonna pay the cost of going
off and recalculating where everything
in the Dom is and for those of you in
here are actually writing large infinite
scrolling delayed loading websites this
can actually destroy your performance
more than anything a better way to look
at this is actually to batch or cash
this data out right so instead what if
we actually queried container down
offset with once and then we actually
went and assigned it after that now this
is fine because what we've effectively
done is we've read the value and then
gone right right right right right right
right right right and then when this
frame is over when the dawn comes back
around and actually needs to be
rasterized for whatever tile you'll
actually pay the toll or the taxation to
configure the Dom positions at that
point in time not during your high
performance JavaScript code so making
sure that you're modifying your code and
understanding where everything is coming
from is critically important to minimize
these Dom reflows
tooling so for those of you who think
that your problem is in the compute
layer there's two amazing tools that I
can't spend enough time ranting about
first off go to open up a new tab in
chrome and type in chrome colon
backslash backslash tracing there's
gonna be a big fat button that comes up
and you're gonna hit record then you're
going to go to your website you're going
to do to some stuff and come back to
that tab you're going to hit stop and
where you're going to see is a timeline
like the one I showed you before and the
one you're seeing now that actually
shows you where all of the processing
time inside of chrome is going from what
your web page is doing so you can
actually see how long that oversized
image is actually taking away from your
frame time right another one is actually
the devtools timeline this is really
cool because the devtools timeline is
everyone in here should hopefully no it
actually show you where your paints are
occurring and actually if you hover over
it will show you what part of the page
was actually invalidated that caused
that paint to occur so with these two
together you can actually see where
you're sort of creating these sins and
and taking too much time away for
rendering and then also see what part of
the page was causing that so between
these two you actually get a good
insight and everything compute
performance this is actually my favorite
part I'm a compute performance guy at
heart if you get you can ask and in the
back out there if you guys ever seen my
Udacity class on html5 game development
I constantly rant about how performant
runtime code is the most important thing
you can do beyond anything else if you
treat the runtime code correct it just
kind of trickles out to the rest of your
mental model so this is this is I'm just
going to rant a little bit so has anyone
ever had a memory profile that looks
like this I say I cut the couple hands
that went up were like yeah hopefully my
boss doesn't know I'm here so what
you're actually looking here is it a
memory profile now javascript is a
garbage collected language which is
fantastic for for you programmers who
don't want to free your data because you
set it to null and then sometime in the
future magical fairies show up into the
inside of the virtual machine for your
data and then you continue on well the
problem is each one of those dips there
in the overall memory is actually where
the garbage collector is running now the
garbage collector can be invoked any
time javascript is executing so this
means it can occur inside of a mouse
move an on-click event inside of a raf
inside of a
a WebSocket receive any time javascript
is executing it can halt and then the
garbage collector can run off for 35
milliseconds completely screwing up your
16 frames per second time right your
goal should not be to have a memory
profile that looks like this your goal
oh sorry so this is actually actually
captured over 44 seconds and you're
actually seeing that we're losing 23
milliseconds that's about two frames of
time during that where you're getting
these stutters your goal should have a
memory profile that looks like this now
here's the interesting thing is that all
of you in here have some understanding
of what the upper limits are for your
application even those of you in here
who are writing infinite scrolling
infinite loaded delayed loaded
applications have some mental model
about how many things you can
realistically do on your client if you
know that number that there is no reason
then you should have dynamic spikes in
your memory where the garbage collector
is taking a lot of time instead you
should actually be pre allocating those
objects like you're seeing on the bottom
here and moving towards static memory
JavaScript right anyone no one's
Emscripten I'm scripting Emscripten is a
really cool technology that will
actually take C++ code compile it with a
clang compiler through llvm and actually
generate JavaScript from that the
javascript can actually just be loaded
right into your DOM and executed and
it's actually running amazingly fast
you're actually seeing some some C++
games running at 30 frames a second
inside of html5 because it was cross
compiled from C++ through llvm and into
JavaScript the key to em script in
actually making these performance gains
is that it takes an assumption of zero
or static memory JavaScript what we'll
actually do is actually bri pre allocate
a massive binary typed array and then it
emulates all of the standard assembly
level operations that are coming in from
llvm so it doesn't allocate any new
memory at all it completely gets rid of
the ability for the garbage collector to
take any time away from it by
effectively assuming itself as another
vm on top of a vm inside of web browser
but it works and that's what's important
so um here's an interesting poll for you
guys so it's some other innocent code
that we have running here so let's say
we've got object equals new object we've
got a list where we create a
a contiguous array of a hundred elements
and then we call array dot add how many
people in here know what happens under
the hood because we have a hundred
contiguous elements right so you would
think that maybe you would add one more
but it's supposed to be a contiguous
array interesting enough what happens
under the hood inside of the javascript
vm is actually what you would see in
other native applications if you run C++
code and you the same thing you'll get
the same performance what happens is
instead of actually a pending this at
the end inside of the code it'll
actually resize the array by creating a
brand new array of double the size so if
you got 100 elements it'll create a 211
array here's where it gets awesome it'll
then copy all of your object references
from your original ray into the new
array and then change the references
that you're now pointing at this new 200
element array under the hood doesn't
sound that bad but what happens when you
get to 201 elements or 401 elements what
actually starts happening under the hood
is you start adding these items in here
you get an exponential growth of memory
that's just being taken up not to
mention every time that array resizes
you now have a huge collection of
objects that the garbage collector has
to go back through and touch right so if
you don't understand your native
footprint and don't actually
pre-allocate for it you're actually
running into this scenario where you're
just burning tons and tons of processing
time and garbage collector time because
you're just unknowingly creating objects
what you should be doing instead is know
your growth rate right again you should
understand right run your application
nine hundred a thousand times print out
the max number of elements or the max
number of types that you're actually
using right this should give you an
understanding of a max footprint once
you have a max footprint pre-allocate
that number of objects start there right
there is no reason really for any of you
in this room who are writing
applications to ever have to resize an
array during your JavaScript web
performance application it shouldn't
exist right even for those of you who
are doing awesomely amazing infinite
scrolling no your growth rate no your
Mac footprint and pre-allocate to that
as much as possible now for those of you
truly bold and aggressive and
disgruntled in the audience hands up
bald and disgruntled
you're not bald no no take his shirt now
you're not bald either anyhow for those
of you who would like to dive deep into
the belly of the Dragon and see the sort
of stuff that we work with all day on
the performance team over at chrome dev
rel there's two fantastic tools you
should be looking into the first one is
actually the devtools CPU profiles
you've opened up devtools inside of
chrome and take a CPU snapshot it'll
actually show you where all of the
performance for that snapshot has gone
right so actually tell you that if you
look at this that you know 75% of your
time was actually or twenty three
percent of your time was actually an
animate right this means that's where
the bulk of your time is actually going
if you'd like to say just a puss step
further you can actually also in that
same tab hitam take a to memory heap
snapshot now the memory heap snapshot is
a little bit weird but it'll actually
show you the type of all of the objects
that are still existing on your page and
there's this really cool feature where
if you take a snapshot wait a couple
seconds and take a secondary snapshot
you can change it to tell you in report
only the objects that have been
allocated between the two snapshots so
you can actually see your Delta over
time this is cool because it actually
tells you how many objects you're
leaking how many objects you're creating
and what your overall memory turn is
remember the whole goal here is to
reduce the ability for the garbage
collector to run and screw up your
ability to actually hit a true 16 frames
a second for your user so I'm actually
finishing a little early that's okay I
saw some hands go up while I was talking
so hopefully we'll have tons and tons of
questions so here's your checklist
number one use advanced data compression
for image transfer if you haven't
checked out web p yet go check it out
there's a fantastic client-side hint
proposal that goes along with it from
ilya gregorich i highly recommend you
take a look at that number to use proper
transfer protocols for fast as possible
speeds make sure that you're using
server side compression gzip speedy take
a look at these technologies understand
them know that flipping a couple bits
can actually save your users a ton of
money and you a ton of money as well
number three bachelor network
connections through the radio remember
every time that radio goes idle you're
going to pay one to two second costs to
reactivate it so you got two options
here number one keep transferring data
or number two grab as much data as you
can and let that thing turn off and then
don't touch it unless you absolutely
need it sometime in the future that by
the way for those
you who are actually concerned about
battery life for these mobile devices
that's actually the number one thing you
could do there was actually a funny
story the guys who made phonegap tried
to add an api in there they would
actually tell you what the battery life
was right but it turns out actually
calling the API to figure out what the
battery life was cost 3x what it should
have reported in terms of battery life
so like they would call this API like 12
times the battery would disappear right
so battery matters and this stuff that's
a different that's a different hashtag
we've perfmatters battery matters as a
different hashtag focused on reducing
your page render weight understand what
your CSS properties are taking from you
in terms to actually rasterize your page
this is probably one of the most
important things I think web developers
need to come to terms with is that your
your general browser is not a magical
utopia of unicorns and pixie elves right
it's actually highly highly modified
aggressively optimized C++ code that's
running a virtual machine a network
stack and tons of other stuff that none
of us know about right you have to
understand that anything you do inside
of JavaScript and inside of your Dom
have ramifications in that world and
your page render weight is one of them
reduce your image resize times by
scaling down your images for mobile yes
it is a pain but guess what that pain is
worth it because it's going to reduce
how much you're paying to send those
images right I think if you look at the
the latest CDN transfer rates if you
actually have a scalable network it can
cost you hundreds of thousands of
dollars to send images that are way too
big for your mobile devices batch your
reads and writes to the doms reflows are
the devil stay away from them just try
to avoid them batch your reads then do
your rights and then noah make sure that
you move towards static memory usage
patterns this is really really important
because you want to reduce the ability
for the garbage collection to tax you
over time and take away all that 16
milliseconds you need so with that I am
done a couple resources for you guys
here if you haven't already seen them
devtools debugging on android chrome if
you do not know how to set up devtools
debugging for your android devices visit
that URL right there this will change
your development life and also there's a
great thing on captioning capturing a
trace capture so if you actually want to
do about tracing on your phone that
second URL has a fancy little Python
script you can run which will do all of
that for you for that please
follow me on your social media network
of choice gaming emails and I believe
that's it for me now let's open the
floor to questions thank you a great
question so other techniques and
strategies for pre allocating with your
app because you don't always know how
angular j/s is using memory or jQuery or
anything else yeah so that's a little
tricky first off you should be sending
those guys emails and asking them what's
going on right put pressure on the
people who are doing that number two
though is is sometimes pre allocation
doesn't always work right sometimes you
hit that limit and you're just going to
expire it like you dynamic stuff happens
for that I actually rec actually
recommend a data structure type so
instead of actually using a standard
JavaScript array actually recommend
using something called a linear growth
array so effectively you write this nice
little framework that every time you
exceed the current capacity of your
JavaScript array instead of
exponentially growing you go under the
hood and actually create a smaller known
size contiguous array so instead of
actually doubling in size you may only
create a hundred new elements each time
right so this means that your growth is
never exponential it's actually it's
actually owe to the one of a hundred
elements each time right and then when
you start doing some crazy stuff like
slicing and removing things get a little
crazy but at least you know that your
upper my phone told me I was wrong but
at least you know what your growth rate
pattern is at that point do you have
tips for making the JavaScript engine
behave in a more static memory manner
said again I'm sorry so you you
mentioned using more static memory yep
tips for manipulating the JavaScript
engines to do that yeah so object pools
is another big one so anyone object
pools a couple people fantastic wow it's
like a treasure trove of awesomeness in
here so so object pools are this
fantastic data structure that
effectively instead of going back to the
JavaScript heap to allocate a new object
you instead allocate a bunch of them
over ahead of time like let's say 90 Dom
elements or something and then you put
them in a pool instead of actually going
to the heap to grab it you actually go
grab it from this pool and use it and
then when you're ready to get rid of it
instead of actually setting it to know
you push it back into the object pool
it's what happens is over time is that
your actual memory allocation
growth rate to actually go to zero
because you're going to hit that max
limit and you're never actually going to
hit the heap to grab more data you're
going to constantly be grabbing it from
your free pool and of course that's just
you know a linked list or doubly linked
list or even a contiguous linear growth
array but this is actually one of the
really important things because when you
couple linear growth away plus object
pools and the mental model of that
you're trying to get to static memory
JavaScript you can't lose right this
gives you all the data that you need to
actually get there do you do you know of
any resources that we could go look at
to look at for these sort of memory
management techniques unfortunately
there aren't a lot of good ones right
now I have six blogs in my queue right
now that I'm hopefully to put out this
quarter so keep your eyes on h5 are
rocks for this quarter and we will also
be talking about this at Google i/o a
little later this quarter and also on my
blog as well unfortunately there's not a
lot of good stuff out there because some
of these techniques actually come from
C++ land and native application land and
any time I come to a web developer and
I'm like you should do that like we do
it in C++ like I have to get my hands up
really quick before their acts comes
down so unfortunately there's not a lot
of good documentation I mean so you
mentioned some problem with the error
implementation and things like the
garbage collector don't you think that
the browser or the VA engine could do a
better job optimizing instead of us
having to change our codes Oh the
definitive argument for web technologies
so I only heard a couple pieces so your
question was and don't you think the v8
and the browser could should do a better
job of optimizing memory instead of us
doing ourselves yeah like for example a
better garbage collector that doesn't
know it well yeah so um v8's garbage
collector is top notch period I've
played with them all Java C sharp all of
them right v8 is actually pretty much
one of the best ones out there it has an
incremental model so what'll happen is
it'll actually free data in multiple
phases of how old it is right so you
never actually get all one big punch you
actually get gradual punches over time
but you're still losing that memory over
time constantly this is this is the ebb
and flow of a garbage collector write
effectively you have to think of it this
way is you're paying at
your tax is like I would like to not
have to care about memory and what
you're paying for that is 15
milliseconds sometime in the future
what's missing from a garbage collector
and this is my personal opinion not that
of any representative companies
organizations or secret societies that I
may or may not be involved with it any
time in the future okay PR and legal is
happy so one of the big problems though
with garbage collected and manage memory
environments is that it misses intent
right you're the programmer you know
what your application is trying to do
you know the goal that you have in hand
this is all context that you have in
your hand and in JavaScript we have
absolutely no way to hint to the
underlying virtual machine or the
underlying garbage collector about what
our intent is right so you can't tell
the garbage collector to do anything
specific or say hey I'm about to go idle
for 15 milliseconds so if you'd like to
go run your garbage collector that would
be a great time we don't have that
ability so because we lack the api's and
the and the control to change these
things we have to resort back to
actually doing things manually who knows
maybe in JavaScript 7 or HTML 5 9 our
HTML 9 or whatever we may get some of
these controls until then we we have to
attack this with solid computer science
understanding right nothing nothing that
I've presented today isn't taught in
computer science undergrad right I mean
we're talking about data structures
we're talking about batching calling
we're talking about moving your hot
spots to different locations
understanding your underlying
architecture this is this is all
standard computer science techniques we
just have to take that viewpoint when
we're looking at web development because
right now we're kind of caught up in
personal opinion we're kind of caught up
in this dogma that you know everything
should be handled under the hood for us
and that's actually leading us into some
very dangerous places because it means
that we're we're not allowing ourselves
to hint to the vm it means we're not
allowing the garbage collector to get
better instead we're telling the garbage
collector hey go look at my code harder
to figure out what I mean again personal
opinion not that of any representative
body or organization i'm a secret
society i may or may not be associated
with all right just just to add to the
gentleman's question yeah i just want to
put out there also that there are people
still getting PhDs for garbage
collection at this time yes absolutely
it will be for the next 10 to 12
years absolutely garbage collection is
not a trivial subject oh no no there's a
great book in fact if you actually go
get garbage collection the definitive
guide it's a fantastic book in fact
actually just posted a great book list
on my G+ go look at that book list
garbage collection is on there it will
blow your mind it's amazing to see what
these things do and I'm highly happy to
have it going all right to my question
here is the beginning there you you
presented some really awesome examples
of metrics that we should be looking at
when developing our webpages and of
course because of the talk you don't
have time to share everything with us do
you have others that are posted on your
blogs or other places that we can
because we don't I can't read everything
that comes out in the news source so can
you can you address that a bit standing
right here the best thing I can tell you
to look at is follow steve who gave the
keynote talk this morning follow Ilya
Greg auric fantastic guy join the the
Google+ web performance community I'll
go back to slides you can see that join
that little short link URL there follow
perf matters there is not a really good
community for web performance right now
the reason i was asking this because i
was considering doing the exact same
talk that you just did yes and i know
because i've talked to hundreds of
developers and they're all under the
solution that will just throw some more
cpus on the back end it will fix this
and then ain't going to happen so thank
you for doing the talk first and put
something on your blog that tells us
where to get all this other stuff too
please will do thank you thank you ok so
the question deals with and dev tools
and it's like connections like Android
chrome so ok I've been using that reason
via net I love it but the things that ok
usually my problems are not with the
kind of Android chrome but the other web
gets any chances of kind of like
connecting the same tool or the similar
tools for like being able to really
memory profiling on say I don't know iOS
there's a matter webkinz do so I I don't
know about that because everyone's
proprietary technology stack has the
stuff that's that they view is the right
way to view the world I will say this
though if you actually go look at the
chromium source code inside of the tools
directory there's a great little library
called telemetry and
telemetry is a nice little automation
framework that actually built a lot of
my CSS paint timing on top of telemetry
is actually kind of intended to be
browser agnostic as sort of like a
front-end into continuous integration
set up so you can actually say like hey
go launch every browser on every device
that has happens to have a USB
connection to this machine and then load
this web page and do some analysis
through devtools communication there so
if if we're going to grow as a web
perfume performance community moving
forward I would hope that it would start
with something like that because right
now it's too hard to do testing on 900
devices right okay we'll have a look
thanks you made a great sales pitch for
web key format awesome yeah but the
comet that is Chrome's the only one that
uses it hmm so what is your
recommendation then for our friends and
ie and Firefox though great question so
web p is awesome great sales pitch thank
you I worked hard on it what do we do
for other browsers so there's a couple
problems with web p and the fact that
it's only supported in one browser right
now so the first thing is everyone in
here as developers should be talking to
whatever representative you have at
every browser and beating on their door
for a better compression format for
images even if it's not web p just ask
for something better I mean God the
amount of bytes that we're losing in the
amount of money it's costing us is
really just embarrassing I mean we've
solved all these other problems hell I
google we got cars that drive themselves
we should have a better you know image
compression format that runs around so
number two is if you're actually in the
situation and you want to adopt web p
there's a couple things you need first
off is you need some sort of client-side
hint to your server side compute right
because eventually you're going to get
to a point you're gonna say hey you're
not running IE or you're not running
chrome you're running IE and use a
different set of data right that has a
great proposal by ilya Grigori again
Ilya is an awesome guy I work with him
he actually has a set of code on his
github account as well as a proposal
that he's trying to push through the
standards bodies to actually introduce
this as something that the web
development community moves forward on
so basically right now what you have to
do is you have to say hey if you're
running in Chrome we can save you a lot
of bites and a lot of time and it's
going to cost you less money as a
developer and a lot less money for the
person using it you know and then you've
got sort of these permutation
for other browsers unfortunately that's
kind of where we're at it's not just a
WebKit thing it's actually just purely
Chrome i believe so right now although
Steve is Steve still in here Steve no
Steve left good that's probably a good
thing I believe right now it is chrome
only okay hi so I batched my questions
to be efficient I had three so the first
question is if you do our own heat
management Siliga if we do our own heap
management or our own garbage collection
like you mentioned do you find that
you're spending a lot of time nullifying
objects like in a clearing stale data
resetting the objects to Mt okay so
there's three questions we'll ask you
answer that one first um so everything
you do with a performant application
should be validated by performance
analysis right so I can stand up here
and give you a fine checklist but you
should not adopt anything I've said
unless you've proven with your own
analysis that it's worth the time if
your if your memory growth never goes
above 200 items there's no reason to
adopt any of this right but if you're
dealing with the high performance stuff
the stuff that's taking you know nine
hundred a thousand Dom elements that are
getting touched with text nodes image
nodes all this craziness you know your
memory is jumping up to 180 Meg's per
frame things along these lines you need
to go and take a look at this and I bet
you'll find and this is what we found in
native coding for years and we're now
starting to see a trickle into the
internet is that you know managing your
memory results in better performance you
know so that means the overhead of
managing it is still going to give you a
win you also mentioned that we should
batch on network connections to optimize
on the radio connection time what are
the techniques for that oh great
question so this is this is again so web
performance as a community is still
budding we haven't had a lot of
solutions for this right so my view of
web development over the past 15 years
has been designers have said let's make
it more awesome and then we made it more
awesome and it's like oh crap it runs
slow and we're kind of backpedaling now
trying to fill in all the gaps and
unfortunately we've got standards bodies
that are in the way to change all these
things down plus browsers all disagree
to do it so um I would say this is that
the best thing you can do is judge and
prefetch right so if you know that you
know 15 tweets are going to come through
or 100 tweets are going to come through
either again fetch them in increments
pull them down save them in a cache
right try to grab maybe a six megabyte
block of data push it into a cash-only
to show the user you know 15k at a time
make sure I know that there's a great
talk out there by Jake Archibald about
app cache and and how people feel about
that but definitely taking advantage of
app cache offline storage these types of
things will allow you to actually cache
data so you're doing more of the
management of your data turn on the
client device as opposed to continuously
hitting the network toll so again you
know try to grab a big block of data
cycle through it on on the backside and
if you can try to do a sort of a an
overlaid IO model right so if you can
actually do rendering and network
traffic right so if you can prefetch so
let's say you grab a six megabyte block
you save to disk you're showing the user
1k blocks of data and you get about
halfway through that you actually kick
off your next network connection to grab
a 6k block well the cool thing is that
you haven't actually eaten up your
initial six meg block and your next six
meg block comes in so you can actually
just stream through and it's a
continuous seamless experience for the
user this is this is not new to java
script it's not new to web dev it's been
around for 20 years of stream computing
and so adopting those principles to how
we're doing our web pages is really
ideal last question is there a way to
know about the connection type is so
were they on a 3g or Wi-Fi network so
you can give a different experience
you're preaching to the crowd preaching
to the choir there brother unfortunately
I don't know of a proper thing to do
this usually what a lot of the networks
will or a lot of lot of developers I've
talked to will do is much like speedtest
net it'll send a quick packet back and
forth and try to estimate time usually
that round trip time is fast enough to
get a detailed information to understand
what type of resolution and asset load
and render weight you should send out of
the client unfortunately we don't have a
good solution right now thank you thank
you
okay all right hey thank you for time
everybody appreciated
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>