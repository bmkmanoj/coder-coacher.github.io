<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Realtime Applications with Ember and Xmpp | Coder Coacher - Coaching Coders</title><meta content="Realtime Applications with Ember and Xmpp - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Realtime Applications with Ember and Xmpp</b></h2><h5 class="post__date">2015-02-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0Y-JhA3joZ4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Javier Vega we are from practice
Fusion and tonight what we want to do is
tell you a little bit about what we've
been using how we've been using ember
along with another technology which
we're going to tell you a lot about
tonight to really make our ember app
shine and I think hopefully we'll have
some time for questions afterwards as
well but we've got some exciting things
for you see Javier's a UI engineer I'm
more of a full-stack guy myself but we
work together on the same team and the
things are going to be telling about are
things we've built in our electronic
health care record application which
we've built over at the practice Fusion
to help doctors run their practices and
also give a world-class care to their
patients so a lot of ways feel like
we're doing some doing some good while
we're doing good things so it's good so
I'm going to let how the air go first
year and I'll be back and then all right
cool so this presentation is going to
start with a little bit of introduction
about the real time web then tom is
going to give you a real deep dive on
XMPP and we're going to wrap it up with
a demo of a nice instant message
application that works with XMPP and
what's built on amber Jay yes all right
so first of all how many people here
have heard of XMPP before raise your
hand oh wow that's that's quite a bit
you know that's that's great so then
this is definitely gonna be interesting
for you guys okay actually one sack so
the real-time web is basically the
concept of building an application that
can distribute data in the browser with
very low latency so think in terms of an
application like an instant messenger or
any type of collaborative type aboard a
document that means we edit unsure among
a group of users or think of it like a
multiplayer game you know any type of
publication which clients are producing
a lot of information and these needs to
get distributed very fast and very
quickly to all their clients so building
these type of applications in the web is
actually hard because HTTP wasn't really
built but you know originally to support
this low latency HTTP is a protocol that
every time that you want to get the
latest data you have to
you know fetch these data from server so
if you're right you're building that
client that needs to be querying the
server every second to get the latest
data is that's that's not really the
most optimal way to do this right um but
however people have been building these
type of applications on the web we see
them in multiple places yeah earlier
because people were you saying you know
different type of technologies like
never-ending loading iframe or sway for
different type of polling techniques
bosch or low point on and lately we're
being introduced to the technology of
web sockets that we can use their
applications but though even if you can
solve the problem of pushing data from
your server to your clients when you're
building a real-time application that
has a lot of users you're still left out
with the with the complexity of a scalar
you know think in terms of any type of
application in which your clients are
talking to other group of clients that
can be hundreds of users so into other
users thousands of them or what about
hundreds of thousand you know generating
data on saying city in packages back and
forth that problem you know it's not
really a browser problem that's more
look at it an infrastructure problem so
that's when XP become related to give
you an alternative an open opportunity
to solve this problem because XMPP is a
technology that was originally built
around 1999 to be a replacement for
instant messaging like an open open
source alternative for it and ever since
then has really evolved to become a much
more about your system they can scale
support this type of step of publication
so let's have Tom now give you little
bit more of that information about XMPP
and what it can do
you know you see the picture of the most
interesting protocol in the world up
there he's got it's a little dose XMPP
bottle ready to go yeah we want to tell
you a little bit about how we use this
technology in our application but let me
tell you a little bit about the
technology first I think that's a good
place to start again some of you are
familiar with it it formerly known as
jabber it was originally as Javier
pointed out intended to really be an
open replacement to some of the
proprietary protocols that were being
used in the various chat at apps AOL and
what have you and so the XMPP was sort
of born out of that the standards
foundation is now that a sort of
governing body around XMPP and as you
can see there I've got links will be
able to have access to some of these
things to the RFC's the standards that
are defining the core of X is X MPP we
need to say that about 300 times tonight
so we're used to it so starting with
some of the core concepts of XMPP first
of all understanding that XMPP is a
stream based protocol each of the
parties that are involved in the
communication initiate a stream for
sending and a stream for receiving XML
the XML is primarily a carrier for
whatever the content needs to be the
payload within XMPP packaged up as
stanzas of various kinds typically as
XML but can be JSON and other types of
encoding as well in those payloads one
of the difficulties you have if you were
to build this type of application from
the ground up is dealing with all of the
integration types of issues that come
with that type of a solution so
authentication in authorization all
built in part of the standard itself
it's a sazzle based authentication model
the authorization is built into the
structure that is maintained in the form
of rosters and you
and groups the messages themselves in
the form of three different types of
stanzas you see their presence messages
themselves and IQs which are information
queries or more of a metadata type of a
message to kind of help maintain and
carry on the conversation the thing
that's very interesting about this sort
of triad of messaging is that each has
it's defined purpose and when you start
thinking about how would you like to
really liven up that Amber app that
you're writing bring it to real time
imagine the charts that Alex had in the
last presentation updating in real time
as the data is flowing through to your
amber app that's the type of solutions
the types of use cases we'll talk
through in addition because of the
extensibility that's built in to XMPP
you have standards such as pub/sub which
have come on come along and further
prescribe how to build certain types of
message flows and applications we'll
talk about a little bit more so just a
note about rosters and groups you could
imagine if you're trying to build a
peer-to-peer type of a nap in a browser
how complex that would be how difficult
it would be to have every single client
every single ember app talking to every
other ember app in to exchange real-time
information very difficult to imagine
how not only what that network graph
would look like but how would you
actually even facilitate the delivery of
that message how would you ensure that
it gets delivered and only delivered to
the parties that are authorized or
intended for that message the complexity
graph of a peer-to-peer model grows
exponentially as you start as you see in
this sort of illustration spreading that
across multiple domains and starting to
federate that out as your user base
grows again the complexity grows very
quickly and that's one of the reasons
why we think XMPP gives us a tremendous
leg up on this type of real-time
capability to our amber application did
that one already
okay so how do you actually get XMPP
into the browser have you ever mention
that web sockets is really where we're
headed WebSockets isn't final yet and
all the browsers don't support it yet
and even the protocols that are defined
the sub protocols that are defined
within web sockets including an XMPP sub
protocol really aren't quite released
yet they're not quite there yet so in
the meantime we have a very effective
technique called Bosh again part of the
standards body that's maintained within
the XMPP world you see the
specifications there it's a very long
mouthful we just call it Bosh you can
see what it stands for there but it
effectively is a long polling technique
that is a gear to build and optimize on
what we know to be sort of the
optimizations of that carrier way of the
HTTP that's running underneath it and so
in these two illustrations you see what
classic polling looks like or standard
polling within a web application where
it's up to the client to initiate a
connection to the server the server then
checks its current state and replies
immediately back to the client typically
with that I don't have anything for you
right now you can imagine there's a lot
of dead space relative to the number of
queries that you might need in order to
keep an application anywhere near
real-time current so that's a very
chatty very inefficient way to do that
then the polling interval is maintained
on the client at which point whatever
the length of that polling interval is
the client that needs to go through and
re set up that entire handshake set up
the HTTP connection send the request
it's a very sort of heavyweight not very
scalable way to deal with current data
in the browser so the long falling
technique takes a slightly different
approach still very much HTTP client to
server in fact in the initial request it
looks very much identical to the first
drawing but the idea is that the wait
time is actually agreed upon by the
client and server and is maintained on
the server for some amount of time say a
minute the server will hold that
connection typically in a non waiting
state so it's
very lightweight in terms of the server
resource and then the instant that the
server has something to say back to the
client it sends it in the form of a
stanza over these streams that we talked
about a moment ago then the client
having received that will immediately
issue a new request the benefit of that
is really twofold number one there's no
waiting if there's information to be
delivered it gets delivered immediately
number two if HTTP has been configured
between that client and that server with
the keeper lives and the infrastructure
that is going to be on the network
you're very likely to reuse the pathway
that have been set up on the prior
request and so it becomes a very
efficient way to make for real time
delivery it also allows for the client
having if you will waiting in this sort
of server wait to initiate a secondary
request effectively terminating the one
that's waiting if the client has
something to tell the server so there's
really no waiting on either end of that
handshake which makes it again very
effective very efficient compared to
traditional client-side polling as I
mentioned it's a standard rather than an
implementation and that gives us then
the leverage that there actually are
many implementations of the standard
there are many XMPP servers as well as
many clients and as well as many
libraries both client and server that
know how to deal with various parts of
this protocol it's very highly it's very
highly extensible meaning it can be very
easily customized it's also very
scalable meaning that in a combination
of being able for example to combine the
benefits of non-blocking i/o with the
benefits of clustering in the server
with the benefits of federating across
multiple clusters and you can get to
enterprise internet scale very quickly
and be able to maintain that type of
scale as your as your application as
your solution gross now the one we've
been using is a open fire open fire is
an open-source Apache License XMPP
server in full disclosure I
actually one of the core committers on
this open-source project in github just
so you know that's going on they don't
pay me for that plug by the way I'm not
sure what the deal is on that but but it
does support as i said the non-blocking
i/o of the federation the clustering it
is very easily extensively because it in
addition to fulfilling the attendance of
the XMPP protocol also has a very robust
to plug-in API that allows us as an
engineering team to very easily extend
and integrate open fire into our overall
stack in the effect of this is that in
the traditional web server which is that
is serving up our amber application and
all the data and all the crud and all
the rest requests this is now another
channel through which we're a deliverer
real-time data and push it directly to
the client this is the slide i think is
the most important one the deck because
there's so many interesting things that
you can do once you open up this
real-time capability in your ember
application what you want to be able to
do is have your application go get the
data that it needs when it needs it
that's what it does today but when that
data changes for effects that are
happening outside that ember application
you want that delivered immediately to
you you want the effect of it delivered
immediately to you in order to provide
the best experience for your user so
just a few thoughts on that the first
use case presence and context so I've
already touched on what presence is
within the group your roster you imagine
your contact list your presence that is
to say that your existence or your
current activity within the app is
already being exchanged that's part of
the core protocol now on that carrier
wave if you start to put little hints of
what's actually going on in that ember
application imagine how the other ember
applications that are in that same
context can then begin to collaborate
for for example one of the things we're
exploring in our application is a follow
me type feature a doctor is working on a
chart it would like to consult with
another doctor in the practice that
other doctor can simply see the user in
the app right click and say join me and
they're on the same chart working
together so that context can be shared
through the presence in addition to am i
available am i working do not disturb
I'm with a patient those sorts of things
that can be delivered immediately
distribute events I think this one's
very interesting as well you may not
normally think of your amber application
of being able to receive events that are
actually being triggered by other users
in other browsers but that's what this
capability would be imagine being able
to notify a user in another browser
context within your shared group in our
case a practice that an interesting
activity has happened and being able to
update the embryo in real time in
response to that distributed event so
very compelling interesting things there
I mentioned peer-to-peer we can't really
do peer to peer in the browser it just
doesn't scale but when you use this XMPP
carrier wave as a way to sort of govern
or constrain that to deal with all the
complex routing to maintain the present
state the delivery state again very
powerful I put s to see on there that's
server to client and this is where it
starts to get interesting with some of
the other types of abilities you can
bring to the table once you put data
push in the mix one of the things you'd
like to do with your ember application
for its performance and to make the
experience the best for your user is to
be able to have the data you need in the
browser all the time right you don't
want to go to the server if you can help
it what's the problem with that once
you've got it on your client it's
immediately stale as soon as you fetch
it it's effectively stale well not
anymore because one of the things you
can do with this carrier wave is send
cash and validation messages so I've got
a patient loaded three different doctors
are looking at it in their various
browsers one changes it wouldn't be
great to have that
tell the other two hey the one you have
is now stale because if you don't get
that message then the one you have is
good you don't need to go to the server
anymore and imagine how complementary
that could be with Amber data and with
the ability to very aggressively catch
the pieces of information that are very
critical to making your own app very
responsive so we think that one's super
compelling various other kinds of
abdication optimizations that is to say
being able to use this to be able to
actually get real time feedback of
what's really going on in the client app
would that be great I mean we've tried
all kinds of other solutions for this
right for sending different kinds of
logs and instrumentation information to
all kinds of third-party care services
why not just bring that right back to us
we can see how the application is
performing in the browser and send that
information back in real time many other
things and then this last one just very
briefly again even thinking about some
of where we're going with ember and the
modularity that the packaging some of
the things we're going to be able to do
to be able to distribute code package it
up and resolve dependencies on the fly
one of the things we're looking at right
now is using the same signal to be able
to send software updates to the client
through push in various ways so whether
you're talking about here's a here's a
reload command for a particular
component particular module here's a
here's an update for a feature that's
actually loaded up you don't need to
wait for that client to log out or to
time out or to have some sort of edge
cash expire you can send that
immediately to the client the client can
come get the new capability so we're
super excited about I think there's a
lot of other interesting things we can
do this is just a screenshot of our app
this is the messaging within our app you
can just see some idea of what we're
doing here in terms of you know little
lights that show up when you get a new
message the immediate drawing of
messages when they're delivered from
others this is effectively kind of a
combination email i am within our EHR
that is secure protected private within
the
within the practice so just a little bit
of a sense of where we're going what we
have when I hand it back to a Javier who
is actually going to give you a demo of
some of this capability all right Thank
You Dom that's awesome now sure Nicole
so now I'm going to switch mode to
mirroring so I can easily show you you
know our demo okay so let's say you
wanted to get started with uh with XMPP
the person that you would need is access
to an xmpp server you can access one of
the XMPP servers are open sort or openly
available in the internet or you can
actually run your own if you wanted to
run your own you can just go on google
for open fire download and i'll take you
to the download page for open fire you
can quickly set it up and your local
machine and once you actually have it up
and running you will have access to this
web console in which you can log in and
manage your xmpp server so i'm going to
log in this is how how the web console
looks like so after you log in you have
access to configure the server for this
demo what I want to show you guys is
that to use XMPP first you you you need
users now you can have support for
anonymous users or razor users in this
case we're going to use raise their
users I'm going to create two users come
hold this one user 1 i'll switch also
it's going to be easy can you guys guess
it ok and we're going to create pass
user to ok so now i have to users in my
system another thing you can see here in
this in this console is actually you
know the sessions there's no sessions so
our demos an instant message application
built in a member case of course and
that allows users to actually connect
and send each other messages so if you
won't actually get the demo application
you can get it from github is open
source and you can use it to get started
with with XMPP so once you download this
repo you you know it's an ember CLI
application you
npm stalled and you about where bowring
style as well you and then you actually
have to run it I have done that already
here in the console so I'm he's going to
run it once your application is running
you can actually connect go into local
host for 4200 okay so what we see here
is our application now since we're going
to have to you sir sending each other
messages and cheering presses I'm going
to open another tab here in which I'm
going to have another session okay all
right so in the left I'm going to login
as user one so when you're using your
working with XMPP you need to use like a
fool dead which is called you basically
the username at the domain of your
accessing okay and I click connect all
right great I'm connected live demos are
fine i guess it's all going to work so
i'm going to login as user to on the
right side too oh cool so this these
obligations basically gives you an Amber
component that is your buddy list on the
right side right so since these are new
users they don't have any any friends
anybody list so one of the things the
first things that you can do in an XMPP
application is manage your roster your
your buddy list so one of the options
you can do here is add a user so here in
user 1 i'm going to add user to
localhost so when I click Subscribe I'm
sending an excellent XMPP message
success I want to subscribe to this user
right and I see it on my roster on the
right side as user too but I don't see
their presence because this user's
hasn't really accepted me yet so I can't
really know whether they are logged in
or not I can't really know their present
I can do I can't know anything about
them until they assembly now as you guys
can see on the right side user to got
the request from user one so this now
that i got a request from that user i
can see their presence because he wants
to establish a connection with me but
what I can do first is either accept or
deny disconnect
in this time this example I'm going to
accept this connection when I click
accept you guys are going to see that
the others user is going to become you
know available is going to show green
and so online and we're going to see the
presence of the user so click accept and
you see that that happened automatically
on the left side in discipline right now
we're in the bug mode so we're actually
seeing the raw input and output of the
XML packages are going back and forth
with the server so that's the first step
so I guess in this application I build
my roster I added my buddy list you know
so these two users are connected that's
one thing you can do is up this
application another thing that you can
do with this demo is update your
presence let's say that you want to say
user ones wants to notify anybody less
than there in you know in the Emir meet
up so I wants a number meet up and then
send an update presence as you can see
on the other user that got immediately
updated on the right side very very
simple stuff and last but not least one
what you can do these applications
actually establish send each other
messages us in a chat application you
could totally use this demo to implement
an instant messaging you know
application in your Emperor app very
easily integrated so click on the user
and then I get this chat box I'm going
to say hello that sends a message to a
server to sort of send it to the other
client and we see on the right side we
have a little badge with a number one so
I clicking here and I get my message now
these juicers have these little you know
dialogue engage in which they can start
talking I say hi how are you as you can
see these data is being transferred from
one client nor client almost in
basically in real time you know these
data is being pushed to these clients is
not being poor so that's our demo all
the code is out there is very simple
it's no different than any other stuff
that you're already doing but with ember
is just using the x and p p4 for
handling these data any questions so far
now ok so let's go back to this light oh
sure
no that's actually using an Embera
mirror data model no adapter because
used to actually when you receive the
package you just add this record to to
the store and then and your dumb gets
out automatically updated so it's pretty
straightforward I'm going to go next
into explaining a little bit about this
application alright so I already show
you how to set up over fire how to get
started now the important parts that you
wanna you want to know about you know
this this up is basically you know first
how do you connect on a two from your
ember application to this xmpp server
for that you can use a library call
strophe jas which is basically wraps up
all the connectivity that you need to do
to do with XMPP servers basically
establishing a connection sending a
package receiving a package building and
packets as well because you have to
speak the XMPP protocol to send messages
back and forth so here the last line we
see like when we we first create a new
strophic connection right there and then
we you know of course connect some
things and we basically call this
function call connect in which we've has
the username the password and I a
function that we want to bind every time
there is a change activity in the
connection so connecting to the XMPP
server is really really straightforward
next every time that there is a message
sent from the server to the client that
gets there's a function call that gets
executed in your JavaScript so you can
pretty much do anything you want and
that's kind of like the hook that we use
to connect or ember data and barrels to
the messages that come from xmpp server
in disk in this case we have basically
two two models one of them handles the
presence and the list of users and they
only want the messages that go back and
forth so rhythm that a message comes in
you say okay what kind of message is
this you parse it properly and then you
say you decide what you want to do with
it where you want to you know add it to
a store you want to ignore it you want
to update whatever part of your UI I say
ready set you know thank you for that
question member data models are very
simple
you don't have to use number data you
can use any type of ember object to to
store your data and to interconnect your
bindings but there is straightforward
nothing that you have not already seen
with number before and then finally you
know to send this message to the server
you also use the connection that you
establish with with this trophy that
JavaScript object so use strophe gives
you a lot of helpers to building this
XMPP packages that you need to send
after you follow the specification you
build your package all you have to do is
this connection don't send pass a
package and stuff library will take care
of you delivering this message to the
server okay you know if you want to
learn more about XMPP the protocol
specification this is some important and
interesting links of course xmpp the org
is where your main research to get
information about the protocol then
that's the next link is the link to this
trophy the JavaScript library the
handles all the connection there is a
really nice project that's an instant
messaging application built in
javascript is not necessarily built in
ember.js but it's a full chat chat
system allows you to have multi-user
multi move to chat rooms and all sort of
like nice nice things and then if you
want to download up and fire you have to
go to ignite real the org projects open
fire and you can get you know copy know
from your fire there's a very
interesting book as well it's called
professional XMPP programming with
javascript and jquery these book covers
a lot of these topics and very in a lot
of deep interesting samples that they
give you and it's not really doesn't
really use ember jes but uses javascript
and jquery and it is very easy to port
applications from that to to to ember
alright cool that's how confirmation
thank you very much thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>