<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scalaz 7 with Lars Hupel | Coder Coacher - Coaching Coders</title><meta content="Scalaz 7 with Lars Hupel - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scalaz 7 with Lars Hupel</b></h2><h5 class="post__date">2013-03-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KzoqOVD7mvE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">oh hello my name is Lars and I'm going
to talk about scallops at seven and you
and polished features in that version
and the title of the talk is seven at
one blow that's actually a pro group
from a German fairy tale it's called a
Reliant little tailor and I have no clue
what's that got to do with the topic but
it has seven in it so yeah okay so some
people might already know me so my name
is Lars and I'm studying computer
science and my first contribution to
scala said was in december two thousand
eleven and i've been committed became
committer shortly afterwards and in
october i picked up like call
maintenance or maintenance of this stuff
and just a side note so i did not
actually invent any of this stuff i'm
going to present today so most of it was
already there and some of it is coming
from miles and some other phone Jason
and Paul and yes so I did not invent any
of this so please don't credit my myself
for that okay so who have you uses scala
set in production or for hobby projects
so okay who uses specs to for testing so
you also actually use color set because
specs to depends on scholar said no
scholar said is a solid ivory for
functional programming and it contains
purely functional data structures and
also it mirrors the type classes which
are from which came from Haskell
originally so like functors and mono
it's and monads and all that stuff and
the current stable version is 604 and
yeah the successor has been a
development for over a year now so it's
compatible with Scala to nine and two
cents so if you're still stuck with 28
or even two sevens you're out of luck
you have to use something older but if
you're starting a project now I'm going
to argue that you should be using
scholars at seven and it should work out
all pretty well so here's my agenda for
today I'm probably not going to cover
everything in
30 minutes so let's just see how
everything works out first of all a la
carte implicit so if you're used to
scala set six you know that if you want
to use any of the functionality you had
this so-called all-you-can-eat object
and you import it from that object so
you making a wild card import and you
got all the features you got most of the
increases and stuff like that so here's
an example so first you import our
namespace then you import this
all-you-can-eat object and then you can
obtain all instances so Mon it for
option and you also get this applicative
builder syntax and yeah everything's
just there at your fingertips now
install a set seven there's it's a bit
more complicated we distinguish between
different kinds of implicit first of all
we have type class instances like this
thing here is a type class instance and
that's also another separation so we
distinguish between type last instance
of our own data types and of instances
of standard library types now the second
part is in fix operators at what we call
syntax now but this is all this fancy
stuff you read syntax that student text
because that's not usually there and
this sin seem annoyed addition operator
yeah and there's also there are in fix
operators for type class instances and
also additional syntax for standard
library types like you have seen here
for a integer we provide some separate
syntax and also the third time it's not
really implicit like the function to no
data type sets are just bare functions
to construct our own data types and yeah
this is also a cert category so what do
you have to do now in order to import
that stuff so first of all you use the
name space as you do previously and then
you can say okay I want the instances
for
or option so we have the sub package
called STD and in this sub package
there's an object called option and in
this object all the increase its reside
so if you import this you get the Mona
instance for option and as you might
have noticed you don't have to write
implicitly here so all our type classes
now have companion objects with an apply
method and so you don't have to actually
write us implicitly and you just call
the apply method and get your instance
okay now to the second example and now
we need a bit more imports and that's
actually quite nice example because now
we can actually see that this line of
code contains so much of stuff from
scarless yet so let's break it down the
first thing to notice is let's start
with the syntax okay we have this
applicative builder syntax here so we
have this fancy operator and it's
defined not a duplicative but and apply
but that's just a technical distinction
so you have to import the syntax for the
site class then you use this addition
operator so you have to import a syntax
semigroup also you use this syntax on
standard library data types and you have
to import a tually it lives under syntax
SED dot option so this is the syntax to
create options so that's the first step
now you have all the necessary external
text and now the syntax has to know that
it's actually that all the type class
instance are there so now you have to
import the type class instances you do
that with importing stuff from option
and stuff from an evil because here you
need the obliquity of incidents for
option and here you need to mono it
instance for integer and those live in
an evil ok you know you might argue that
these are quite a lot of imports and
that's not really nice so we've also
provided some common imports which
provide you with all the syntax and all
our library enrichments so that makes it
a bit shorter ok why is this better
let's start with the disadvantages so
obviously you need more import
statements yeah that's true and also it
makes compile time debugging harder why
because if you are referring to the
syntax so if you write like X and then
this operator and then why and the
compiler complains that it couldn't find
any implicit instance so now you have to
think did I actually import everything
we just needed or is to influence just
not there or what happens here so it
takes you a bit of time to debug this
kind of stuff so mad they are also
advantage so you can use the syntax but
you don't have to so if you decide to
just use to type class instances and
write everything with type class dot
append or add and then two parameters
and if you choose to not use the syntax
that's fine you can just import to type
class instances and everything works
well and also it improves readability of
the code so if you have your source file
and in the header you list all the
imports and someone reads your code he
or she could simply look did this person
import scholar said syntax if yes I have
to watch out there might be operators
around here which I have to look up and
if you don't import syntax you
immediately know okay everything's from
the standard library here also it makes
compiled I am debugging easier so this
is with tongue and cheek because your
implicit sculpt is much smaller you
don't have all those hundreds of
thousands of implicit in your scope so
if you get in divergent implicit or
stuff like that you can just remove stay
import statements one by one and see
which one was the offender so you
couldn't do that with this
all-you-can-eat object you just had to
import it and if something didn't work
you were out of luck also it increases
compilation speed I don't have any hard
numbers on that but the thing is the
implicit scope is smaller so the
implicit search will be faster
okay so the second thing which improves
the usability of scala set by far is so
called an apply so who if you have have
have shot of that so i'm not talking
about the case class and apply but about
type level on a place or just for me how
many people do you know this concept ok
so this concept was originally invented
by miles and then refine by jason so
what's the problem just take a second to
have a look at that code snippet we
define a function with to type
parameters where the first type
parameter is actually a type constructor
and then we want to take a value x which
is of type type constructor applied to a
and we just for the sake of example we
just return exit self so what will you
require is that if you want to call f we
need to know that it has a type such
that can we d structured into this type
constructor and an element apply to it
yeah like list of in or vector of string
or something like that so what happens
if you call it like that anybody know
what happens does it compile as it not
compiled all this actually print to type
error because we put in a function from
int to int in here but we could pry out
this type constructor thingy and the
compiler is not able to figure this out
so now you could say ok well why doesn't
the compiler figure this out isn't it
smart enough the reason is it's very
hard to do so and why is that because
now assume you were a compiler and I'd
ask you to do this kind of inference
which one of these candidates what you
choose well this type constructor cut we
could be fixed on the input it could
also be fixed on the result it couldn't
be fixed at all or it could be fixed on
both of them so you don't actually know
which destructuring you should choose
because it's ambiguous and this is no
limitation this is also filed as a bug
and
this is a back number less than 3,000 so
it's a feature request and I'm not sure
if this is ever going to happen so let's
go to the so in the last year I would
have probably said let's go to the
fundament of the problem but then
someone said to me that fundament
doesn't mean what i think it means so
let's go to the foundation of the
problem and we use math for that this
problem is known as higher order
unification so if some one of you have
already used prologue or data log
prologue does unification so it takes
two terms and tries to find a mapping
between them such that they look the
same thing so that's what we do here so
we try to find a mapping from this thing
do this thing so that these constraints
are satisfied that's basically
unification and now scala head subtyping
so why is this bad because everything is
subtype of any any is always treated as
well client it and that's instantly
ambiguous so no matter how hard you try
any is always a candidate so you get
ambiguities all the way down and even
without subtyping higher order
unification is undecidable even second
order unification is undesirable so yeah
that's pretty sad yeah so in fact
scholar c is not stupid or the
implementation the people who
implemented it were not lazy it's just
impossible to do in the general case so
ask good programmers what do we do we
approximate oh that's what we do all day
so we have some heart problems if we
consult it directly so we have to use
some kind of approximation to get rid of
those limitations and like find the
solution which just works and it's close
enough so first thing to notice this is
the same code example and we know that
this type constructor here is is rarely
used it's not actually uselessly you
cannot actually do something with the
structure you require that this type
here is structured in a certain way but
you cannot actually do anything with it
you you cannot transform it in some way
so the whole thing to note is
if you have a type constructor you
usually have also a type class so you
want this to be a functor or mon it or
something like that so this is a more
realistic example you have a function
again with this type contract and you
say okay I want my type contracted to be
ammonia and then I can do some
operations I can map the type of
whatever I want and now we have more
information and this piece of
information can guide type influence how
yeah we can use dependent types for that
what we do is you define a proof object
which contains the type constructor the
you know type and the type class
instance and now we have to create that
kind of proof object somehow and we do
that with implicit and lots of implicit
and now we have to resolve those those
ambiguities and we do that by the usual
usual mechanism of prioritization so you
know if you have a hero key of classes
or traits or whatever and you define
implicit sin all those trades and now
you ask for an implicit value and
multiple of those increases would
qualify then the compiler always chooses
the one which is at the bottom of this
hierarchy so that's one mechanism so we
simply say if there are two
possibilities just choose the one we
deem more likely and also availability
of type class instances so if you have
two possibilities and you say well you
could be structured in two ways but in
only one way I have this Mona instance
available then I will choose just that
one which has Simona instance available
because the other destructuring wouldn't
make any sense at all okay here's a
short demo
oops so okay
so let's have a first have a look at how
its implemented so this is quite a lot
of boilerplate so you don't have to
actually understand that these are like
500 lines of boilerplate which comma
which cover some type shapes so the most
important thing is the definition of
this proof object which is here so
here's the straight unapplied and you
see here you have all those different
members like the type constructor and
the type A and type class instance and
we can use that we can just ask for this
proof object and the implicit search
will give it to us and this looks like
the following assume we have this file
and now we want to have this class which
does something on something else and we
want to create such and such a such an
instance we simply say okay just give me
anything I don't care what type that is
just something and then I require such a
proof object and say okay this tea can
be structured in a way that we have a
type constructor and this type
constructor is classified by a functor
so we need a functor for that type cloth
and then you here where the dependent
types come into play we can say okay we
instantiate our frog nakade class with
this unapplied em on the plight of a so
these are the type parameters and then
just some technical details we have to
convert a bit and then here we get the
type class instance okay and that works
pretty well so if you have this code you
can actually call that and it will
compile without a problem so now that
invokes colossi load so let's hope this
won't take too long
yeah so it comprises all the problem it
was able to infer that the shape of the
type constructor despite the fact that
we passed in a function which is like
function one and has two parameters and
it was able to underplay in such a way
that everything works out beautifully
so does it work well yes in Scala said
six we had we used to have conversions
for each concrete type so we had
conversions for I is 0 for function one
function too and all that stuff and now
we have a general mechanism for common
shapes so we say okay we have a
conversion for type constructors which
take two parameters and then we have a
type of conversions for type constructor
which shape three parameters and stuff
like that so in many cases type
parameters can be omitted and here's the
thing so if you want to traverse lists
thankfully so I don't know who a few
uses the state thingy from Scala said
previously in scholars said six you had
to use a very hideous type lambda here
to actually tell the compiler how this
should work out and now we have this
Traverse you method youth stands for an
apply and the compiler will figure it
out and we also have the old Traverse
method still lying around because in
some cases on apply won't work so you
can still specify it like you used to do
it so um but it's not so bright because
we have those amount of boilerplate and
we need one implicit / type shape but
they are infinitely many type shapes so
we are doomed anyway but I don't know if
any one of you uses type contractors
with 20 parameters so if you do you
might be doing something wrong and
there's I i I'd say there's only a
finite number of interesting type
constructors so yeah we are not true at
all also the compile errors can get a
little funky and yeah it needs dependent
types so with Scala 29 you have to
specify a command-line switch minus y
dependent method types or something like
that and but this is enabled by default
in Scala to 10 so you can enable it
anyway you won't get any compatibility
problems at all it's enabled with 210
and yeah you should be safe to use that
okay so let's get to the shirt point
loss in skala said six we had all those
type classes and instances and the
problem was that you could implement
your own instances and nobody actually
ever checked whether your instances are
lawful so you could just define a
functor and nobody ever checked if this
was a valid functor we did change that
so first bit of motivation so we are
programmed so we usually don't program
against classes we program against
interfaces and in Java lend we used to
specify a contract in the Javadoc
comments so this is object on equals i
am sure every one of you loves that
method and we have this kind of contract
here and it says well the equals method
and blow up and it should be reflexive
so x should always be equal to x and if
x is equal to Y then why should be equal
to x and yeah we we do we do rely on
that on a daily basis so if you
implement some sort of sets or stuff
like that we do want these we do want
subclasses of object to satisfy that
contract and I assume everybody of you
is completely convinced that every
subclass of object edges to this
contract so we have the same problem
with type classes so type classes
abstract / types and they offer common
functionality and users of those type
classes expect similar behavior and once
again we do not program against the list
functor we program against a functor and
we have a method and we do not know
which you don't know which kind of
functor the user puts into it so we need
to have some hard and fast rules for
that and those rules need to be
formalized so yeah I mean academic I
want to formalize everything why because
if you put it just in your comments
nobody can check it and everybody will
ignore it and also comments will rot so
you have like
your implementation and then like two
years ago somebody wrote a comment and
the implementation doesn't even know
about an old comment anymore so yeah we
need to do something about that and this
is a quote from Toni Morrison the
scholar said IRC channel I think this
was from a traitor project and he was
wondering whether this is actually a
lawful moaner it so whether it satisfies
some loss and we don't do not want to
run into some legal problems okay so how
do we do it in scholarship we have this
type class hierarchy and in this type
classes we embed loss so for example the
class monette contains a trait called
monette law and this trade monette law
extends functor law and funk the law
itself is defined in fact oh yeah
nothing too specific and then we have 1
message below and we call those methods
with scarlet check so is everybody of
you familiar with scala check so this is
just the tool which produces random
input but here's the thing it's not the
fear improver so in an ideal world we
would just define our instances in
theory improver and then click on a
button export to scala and then we have
trust full code we do not usually do
that so if the if Skylar check safe okay
it's not a guarantee but it's better
than the usual unit is because in usual
unit tests you just test some cases
which you thought would be common or
ever and Skylar check is good at
creating corner cases and usually the
corner cases are more interesting and
our binding stood Skylar check can be
used by other project so if you are
defining instances of funk tour stuff
like that you can just add another
dependency it's called scala set scholar
check binding and then you can simply
call all those functions and we call
this check also if you if you call check
all with an instance it will
automatically get check everything and
in all cone codebase we have 332
occurrences so we take this pretty
seriously and yeah the test
of scholar said seven is much better
than north scholar said six so we didn't
you didn't do that checking previously
but now we do and now we are pretty
confident that everything is in order
okay I have another demo so let me just
show you how that looks like for example
for our any little instances we just say
check all the laws for the unit instance
and check all the laws for the bullion
and character and stuff like that here
is also on a bench marking stuff but
that's not important and this file just
contains all those check all calls and
if you were about to execute that so
this called SPT I hope it doesn't
recompile everything
so yeah that worked out well internally
it uses x2 and it generates specs to
fragments from those scallop check
properties and now you can see if you
want to check this short instance you
see all those laws which is checked for
that so that's pretty awesome I you just
have to call check all and everything
will be done for you okay so if you want
if you want to know more about loss and
you can watch taught by Nick Partridge
he gave it in the past week at the
Brisbane FP group and there are also
slides available okay since I think I'm
running out of time so I'm just going to
skip type level programming and if you
want to know more about type level
programming ask miles and I'm going to
skip to the last point and when I want
to point something out about our
community so what actually happened in
the past year I've told you that scholar
said seven has been under development
for quite some time and wiki says it
should be released expect and released
in april 2012 well we are well overdue
and but we got tons of contributions so
about 200 issues opened and pull
requests we got quite a number of
Awesome contribution for example we got
new data types and some classes which do
not have any loss associated removed and
I'm still on the crest to remove more of
lawless classes and lenses which have
been some new concepts which have
imported from their house cleanse
library and stuff like that that's
pretty cool and I'm going to pluck a
shameless plug here this is something
I've been doing so some people say
validation is the gateway drug to scala
set in a set I thought to myself so if
it's a gateway drug let's make it even
cheaper and the problem with using
validation is that sometimes in encode
you have all those fancy operators and
nobody knows how to call them or
whatever like space ship operators or
stuff like that and yeah
so what I did is create such a diff else
actually you can say okay I create such
checking object and they put some value
in it and then I can say okay verify all
those properties and there's a library
which with some of those properties
readily available and it will track all
failures and give you a list of all the
failures combined and then you can also
convert that stuff and at the end you
can get a full fledged scholar set
validation out of it and if you would
run net you would see okay this thing
has actually only 15 characters so you
get wrong length and it's also doesn't
satisfy this check sum function so you
also get this error and yeah I hope
that's useful and this is not actually
in scholar said seek in scala set code
base it's in a separate project so this
is this enables us to move forward
quickly so what can you do if you're
using scholars at six please migrate to
the latest milestone which is 700 m 7
and please tell us about it so there are
some things which you have to adapt for
scholars at seven so there will be a bit
of pain but please tell us about your
pain so we can ease it for the next
people to do that transition if you're
not using scholars at seven or scholars
at six at all please try to adopt it in
your project so if you're starting a new
project just put it in your built SVG
and see what happens and also please
don't be afraid of asking questions I
know that the scala set community is
kind of in famous for like yeah some
people and please ask questions on the
mailing list and yeah I'm sure somebody
will give you a helpful answer so what
are we going to do we will release the
final version soon probably this still
this year and every also promised to not
break too much until then and also on
the point on my agenda is to rewind the
website so we all have still this google
code wiki and stuff like that and i hope
to replace that by something more
beautiful
okay that's it from me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>