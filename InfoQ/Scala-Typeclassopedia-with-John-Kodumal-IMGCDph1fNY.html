<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scala Typeclassopedia with John Kodumal | Coder Coacher - Coaching Coders</title><meta content="Scala Typeclassopedia with John Kodumal - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scala Typeclassopedia with John Kodumal</b></h2><h5 class="post__date">2012-05-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IMGCDph1fNY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey guys thanks very much for coming my
name is John Kota mall I'm a team lead
here at Atlassian so I've been working
on a project called the Alaskan
marketplace and basically what we've
been doing is we've been basically
making an app store for last siient
applications where you can purchase
add-ons that third parties have made
from within products like JIRA and how
that becomes relevant to this talk is
that as part of that project we launched
a new site called marketplace Atlassian
comm and we're actually gonna be
announcing that in our big user
conference next week and that we we got
to pick a new tech stack for that I
chose Scala with Mongo on the back end
and one of the things that we wanted to
do is try to be as functional as
possible we're big into pure functional
languages and you know big haskell fans
amongst us and we decided to use
scholars ed which is a library that
tries to bring some of the concepts from
Haskell into the scholar world and we
use scholars ed pretty heavily in this
new marketplace at Atlassian comm
project this was also a huge move for us
because traditionally Atlassian is a
java shop
and so we were just getting started with
you know getting a new set of developers
acclimated to scala we had a core set of
developers three or four of us who were
already pretty familiar with Scala and
wanted to take it to the next level -
Scala zedd and then when we you know
came out of a room a couple months later
into the project and tried to and
launched it on everybody and we were
like hey guys Scala is awesome and they
looked at the code and there were monads
everywhere and monad transformers all up
the wazoo people got a little
intimidated and so what I what I thought
would help would be a little training
for the team and I started looking you
know we started you know on chat when
people would ask for help I'd be like oh
yeah just read this tutorial and it
would be something for Haskell and there
was like a lot of cognitive dissonance
there because people would be like
reading stuff and you know saying okay
you know it works like this and in the
Haskell concept wouldn't apply very
cleanly to Scala and so that that level
of indirection I think was really
problematic for people so one of the
things that I wanted to do was ditch
that ditch that level of indirect
so I took one of the better tutorials
that I found one of the better pieces of
documentation that I found from the
Haskell world which is called the type
class uh pedia written by this guy named
Brent
Jorgy and I decided to port it to Scala
and interestingly enough I thought I'd
just be sort of porting making syntax
changes and showing what the syntax
would look like in Scala and there was a
lot of that to be quite fair but but
Scala and Haskell are very different
languages and they're they're they're
different in ways that really matter
when you're explaining this material and
so I found that I had to sort of read
redefine how things worked a little bit
Scala Zed defines some of the types a
little bit differently there are
historical mistakes and Haskell that
have been corrected in Scala zedd and
mistakes introduced in Scala said
because of the way Scala works and I
tried to kind of sort all of that out
and present as a more unified document
about this stuff so so this is the type
class of PD this Scala version and this
is basically only the first third of the
type class of pedia so this is going to
be a little bit of a short talk so
hopefully we'll have a time to chat
afterwards I'm intending to continue
this and maybe do the second the second
and third parts at some point in the
near future so let's get started yeah so
the first thing that we need to talk
about is what a type class is so how
many of you guys actually are Haskell
refugees or okay so a couple people so
this is gonna feel like a warm and fuzzy
blanket for you right it's gonna be
pretty easy and I hope that that doesn't
put you off I think that hopefully this
will still be interesting to you how
many of you guys are heavy users of
Scala Zed or you have used scholars ed
at all in your code cool so there's some
people and so this will this will be
hopefully bringing some of the concepts
in scholars it and sort of documenting
them for you has a lot of scholars it is
it's it's pretty hard to learn I think
anyway type classes so the first thing
we need to talk about is type classes
but but this is kind of just
prerequisite material I'm not actually
gonna spend you know an hour explaining
what type classes are actually Dan made
an awesome tutorial on type classes and
I would highly recommend going on
checking that out if you want a little
more detailed material dan says it's on
YouTube so it must be on YouTube so so
let me just give you the brief 10 minute
primer on type classes and we'll move on
from there
so type classes are kind of like I call
them open world interfaces and they're
kind of akin to Java interfaces at least
to a first approximation but they're a
little bit more flexible and we'll see
how that works in a second so if the
main thing that I want to get across
here is that I want to define a set of
behaviors that a class or something like
that must implement right and in Java in
the Java world I would do that with an
interface the sort of scala level
version of that would just be to declare
a trait so like something like this in
this particular example I'm going to
declare a trait called Show and it's
going to work kind of like to string so
I'm going to apply Show to anything that
I want to say print out on the repple
something like that now in the Java
style of things I would declare this
show trait like this with a show
interface like this where I would define
the methods that I that I want my
interface to implement and then I would
just have it just defining methods
that's it really
but in scala with a type class there's
going to be a slight distinction and
it's gonna look like this so instead of
just having Show I'm gonna parameter add
a parameterised type here so this show
will take a type parameter a and I'll
define the show's method as taking a
value of type a and returning a string
but really what I'm doing is the same
thing I'm defining a set of behaviors
that's the type class that I want to my
code to implement so after I define the
type class I need a way to say that a
particular type belongs to that class
that's the second step here so what I'm
what I'm going to provide is what I like
to call a witness it's an instance of
that type class for any particular type
and the way that's implemented in Scala
is to basically make an anonymous class
specialize to the type that you want to
add to the type class so in this case I
want to say that int should belong to
the show type class how do I do that
well I make a new show int it's an
anonymous class and I implement the
show's method and in this particular
case all I'm going to do is call to
string that's it
so now I've got two things I've got a
definition of the type class so I have a
set of behaviors that I want to
implement and I have an instance for
every type that I want to define as
being in that class the third thing that
I need is a little bit more boilerplate
and that is I need to I need a way to
call that method and the way that's done
in Scala is by and implicit so I'm
actually gonna declare another copy of
the show's method and it's going to take
an implicit parameter the implicit
parameter is the witness so this is
saying this can only compile if there's
a witness that says that the type that
I'm calling this on belongs to the type
class makes sense it's a little bit
confusing because I called it shows as
well but that's kind of a convention
thing that's pretty common there's
another way to write this using
something called context bounds in scala
scala loves syntax so it provides an
alternative syntax as well so what you
can do is you can say a colon and then
the type class name so I can say a must
be a show there must be a witness saying
that whatever the a is it must be a in
the show type class and then I can ditch
the implicit parameter the downside to
this syntax is that I need a way to
actually materialize the implicit
parameter out you can't it doesn't have
a name in the second case so I use a
method a utility method in pre-death
called implicitly to pull that out and
then call it but it's really the same
thing okay in scala zed if you're using
the scholars ed library there's a nice
thing that they do there which is that
they pimp a lot of the common type
classes for you so you can actually use
dot notation so you can actually just
say three dot shows if you're using
scala scholars that that is okay so that
seems like a little bit wonky there's
three things that I had to do there I
did declare a type class I had to make a
type class instance and then I had this
extra boilerplate of the shows method
but actually I've gained some kind of
interesting things here the first thing
that I want you to notice is that I
declared this behavior on a type that
was already defined it's part of the
standard library it's int write in knew
nothing about this show guy that I just
made up but I was able to add int add a
new behavior to int and that's actually
really powerful
I call that the open world assumption
it's a it's a distinct difference
between the type class style of ad hoc
polymorphism and subtype polymorphism
that you would normally have with with
interfaces another thing that you can do
in Scala with type classes is you get a
little bit more flexibility in Scala you
can actually override the type class
instance in a limited scope and then
have that alternative definition apply
so what I can do here this little
snippet of code here I defined an
alternate instance for int for show and
in that alternate instance I'm counting
just by or I'm displaying the integer
with a set of vertical pipes kind of
like I'm counting in unary and if I have
that thing in scope and call shows then
what gets what gets used is the the
other implicit and so I can essentially
tailor the the specific implementation
of show for any particular type wherever
I want and that's actually a pretty
powerful thing
I actually don't you guys are how some
of you guys know Haskell pretty well I
don't think you can do that in Haskell
can you yeah you cannot do that in
Haskell so it's so Scala's type classes
via implicit is slightly more powerful
in that regard so another thing that I
want to point out is that type classes
aren't quite equivalent to subtype
polymorphism there's a lot of
flexibility that you get from type
classes but there are certain things
that are a little bit harder to encode
with your traditional subtype
polymorphism and so here's a little bit
of an example this is some hybrid
combination of Scala and Java I don't
know quite what it is but you guys get
the idea so I've declared my show
interface here like Java style with an
interface and then I have two classes
that extend show and then what I do here
is I just make a list of show a list
whose elements are of type show by
making a new ArrayList and putting foods
and bars and they're kind of willy-nilly
and then I can iterate over that list
and just call show on each of the
elements and that'll do the needful the
problem with this is can anybody see the
problem with this if you try to encode
this with implicit and some and type
classes any guesses well if you think
about it the problem is that each of the
types of the elements in here is going
to
need its own type class incense and
there's there's really only one
available for this container the
ArrayList right so there's no way to
kind of pair the list each element in
the list with the correct type class
instance actually you can do it and in
fact I posed this question to Dan and
and he actually came up with this
ridiculous example if you look at the
slides offline that that not easily at
least part is linked and you can
actually look at an encoding of this but
the point is to say not that it's you
know not expressible but rather that
it's extremely awkward like most of the
things that Dan does we're yeah yeah no
problem
so so yeah if you find yourself trying
to do something funky like this you'll
find that that this this encoding
doesn't quite work very well okay so
that's type classes in in a few minutes
and now we can move on to the meat of
the talk which is actually the type
class uh pedia so what the heck is the
type class uh pedia it's basically just
a set of you know related type classes
that have proven extremely handy for
structuring functional code so when
you're a functional programmer these
type classes just happen to be really
useful and you'll run into problems when
you're writing functional code and
oftentimes if you're using these type
classes you'll find yourself able to
code your way out with really elegant
solutions the way that you should read
this diagram so I should say that I
pimped this diagram totally from the
Haskell Docs so there's some artifacts
in this diagram that are artifacts of
the way things work in Haskell
but the idea is that the solid arrows
represent the is a kind of relationship
so every monad is an applicative is a
functor every traversal is a traversable
is a functor and so on the dotted lines
are used to indicate some other kind of
relationship some other being undefined
and not really relevant to this talk and
then the greyed out things represent
things that aren't actually in Haskell
standard libraries but I believe that
most of them are in scholars that so
apply for example as in Scala Zed so
like I said these are kind of like
functional design patterns you know I
think if you look back if you weren't
using this stuff you could probably look
back at a lot of the functional code
that you've written and see how this
stuff applies in
clean ways and the other cool thing to
note about this stuff is that there's
nothing magical about these particular
type classes I think in general people
kind of get overwhelmed or discouraged
when they read these tutorials because
they it seems like they're more
complicated than they are I mean
literally functor is just an interface
with one method applicative is an
interface with two methods and monads
it's three methods right so what could
be easier right furthermore there's
nothing really magical in the language
about these type classes so when you're
dealing with them like you can actually
use these in any any language that's
sufficiently expressive there's nothing
preventing you from doing that there's
an asterisks there because there's
there's one exception and that's around
monads and the syntax for monads I'll
talk about that a little bit later but
basically when you're using monads
extensively in your code monads tend to
be a little bit infectious so they tend
to propagate around in your code and the
syntax the raw syntax for for calling
for accessing the monad interface is
kind of ugly so a lot of languages will
have special syntax for for dealing with
monads and Scala that's a fork on branch
and in Haskell that's like doing
notation so like I said these are
provided in scala zed which is an open
source library and all the examples all
the code snippets in here are there
mostly compilable and they work against
Scala's at seven if you're using Scala's
at six there are some slight differences
but but they should be pretty easy to
pick up on and like I said this is how
the house Haskell standard libraries to
find this stuff there were some mistakes
that have kind of been made in the way
that things work in Haskell and so that
this is this doesn't represent represent
perfection yeah anyway so in this talk
I'm actually only going to cover three
pieces of this type class of pedia I'm
gonna cover functor applicative and Mona
and so on we're just going to go right
down the line here those I think are
some of the most interesting interfaces
to talk about and hopefully in the
future I'll be extending these slides
and talking about I think the natural
extension from what I'm going to talk
about is going into monad transfer
and then I'll probably cover monoid and
some other things after that okay so
let's talk about functors a functor is
is really simple like I said it's an
interface with or it's a type class with
one method and the only method that it
defines is called map so what could be
easier right so the map method looks
like this so this is this is the way we
define so remember go back to the type
class stuff that I was showing you this
is the definition of the type class so
there's this trait functor it defines a
single method called map which has two
type parameters and two arguments it
takes an FA which is a functor of A's
and it takes a function from s to B's
and it returns a an F of B a functor B's
so this is very simple and very simply
doing something like turning on a list
of strings into a list events that that
would be an example of this thing so
right we declared a type class now we
need to say that certain types belong to
that type class and we'll do that by
providing instances and so here's an
instance for option so we just need to
implement map so we declare a new
functor option and we implement map as
follows so let's just follow the types
here we have an option a a function from
ace to B's and the result needs to be an
option B well there's really only one
way to implement this and there's
actually some mathematical death in that
statement there really is only one way
to implement this correctly at least in
a way that applies that that is a true
functor and so what we do is we look at
our option we kind of take it apart if
it was a sum then we just call F on the
on the on the on the value within that
sum and then wrap it back up in a sum
otherwise it's just none and the result
is an option B that's it
one of the nice things that I like about
Haskell even though like I said I'm not
a Haskell developer really is that in
Haskell that the type signature is
actually different so first of all the
type the function name is called F map
instead of map but also the arguments
are reversed
so you're actually going to get the
function first so it takes the airs B
parameter first and then it takes an F a
and returns an FB and I actually really
like that because it gives you kind of
an intuition into an another kind of
intuition into what a functor does right
so so think about it this way just read
the type signature I hand you a function
from Ace to B's right hand the functor a
function from Ace to B's and it hands me
back a new function which takes FAs and
returns F B's right so it's basically
lifting the function into into this new
world from a normal old function into a
special functor i's function does that
make sense a little bit ok so a little
bit more about functors it's kind of
interesting this is this is an interface
with one method and we're going to talk
about it for a little bit here so the
idea that this is a this gives you the
ability to map over things that idea
leads you to some obvious examples right
any idea give me throw some out
right there's lists what else what else
can you map over trees ok you can map
over maps yeah so that leads you to a
bunch of really obvious examples but
let's look at something a little less
obvious functions you can actually their
functions are actually functors as well
and this is where the Scala gets mildly
hideous mildly to slightly hideous so I
actually had two so so function has two
type arguments so I had to partially
apply the function type constructor and
so I have a type lambda here to do that
but pop quiz okay looking at this
definition I defined I defined this in
kind of a slightly funky funky way but
there's a very very simple concept that
this is expressing can anybody see it
can anybody tease it out from the crappy
Scala so I think somebody said it yeah
exactly it's just function composition
so so functor as function is just
function composition and again the
Haskell version is way better at
elucidating this point right so here's f
map here's F nap and it takes your a
here's just the definition of f map
and I'm just gonna substitute in the
function type are arrows a for FA and
then you can see it right there right
like there there's your composition I
given an R this can turn it into an a
chain it into this guy and you'll get a
function from R to be right and so this
idea functions as Fung is it's it's it's
actually going to be very useful it
leads to a very useful monad extension
so so functions as monad will be the
reader Mon head and that's going to be
very useful we use that all the time in
our own code base I'll talk about that
in a little bit ok so so as an aside if
you read a lot of these tutorials online
there's like sort of a cottage industry
around building tutorials around monads
and functors and applicative functors
I'm pretty sure there's a company there
that somewhere that just makes monad
tutorials anyway they all use words like
box and you know computational context
and and I think that's a good way to
start so you can you can start with the
the analogy of okay these things work on
like a monad is a container or a burrito
or whatever the hell else the tutorial
is working with but but go from go from
the intuition and sort of ditch this
sort of like this works on containers
and try to expand your horizons beyond
that as quickly as possible the analogy
is good for starting out but when you
ditch it things will start making more
sense more quickly ok
more on functors I just I love map it's
a great function if I can talk about it
forever so there are additional
constraints on functors that actually
you need to have in order to have a
valid functor so let's let's think about
this
let's take a list this functor right so
I need to implement a map let's say I
wanted to implement map for lists a
valid implementation of that in terms of
the types strictly in terms of the types
would just be returned the empty list
right that would be perfectly that would
match the types up perfectly but it
wouldn't be very useful and certainly
you as a developer wouldn't you know
want to pass something to a function
that was expecting a functor and expect
so always keep the empty list back that
that wouldn't be nonsensical so there's
actually functor laws that prevent
ridiculous definitions
of map the first is that if you map the
identity function over a functor you get
you get the original functions my
ridiculous empty list definition and
then also mapping over a compose
function is the same as mapping over
each function you can look at these
afterwards I don't really need to harp
on them the important thing to note is
that these laws are not enforced by the
type system obviously there's really no
way to enforce this as a type level so
typically what people do is they'll make
an instance for whatever type they have
and they'll write a couple tests
demonstrating that the functor laws or
are held up to and as an aside I want to
talk about this concept called
parametric City how many of you guys
know what this is you guys have ever
heard of parametric City cool theorems
for free anybody ever read the waddler
paper so there's a cool paper on this
and I highly encourage you guys to read
it because I'm really not going to talk
about it very much but I'll give you the
brief idea so Benjamin Pierce is a great
type theorist and he actually didn't say
this but he would if you if you watch
more Spider Man with great weakness
comes great power where a great poet
once said no power no problems but but
here's the idea you can actually based
on a type signature if the type
signature is generic enough you can
actually determine behaviors of the
functions implementing that type and so
let's imagine we're in a purely
functional world and I have this
function called fun it takes an A and
returns an A so what what is this
function any anybody identity well what
else could it be
successor and no it couldn't be
successor right because this is a
generic type you don't know anything
about the type so there's no way to know
yeah that's actually true so that's
there you go
so actually yeah nonterminating
functions match this type signature as
well as the identity function but
actually that's kind of awesome because
all i've done is i've given you a type
i've given you a type nothing else and
you can tell me that there are only two
possible implementations that match this
type signature and that that idea
generalizes quite a bit so so the idea
is
the weaker the type sinker the weaker
the the type class the more you can
reason about its behaviors and that's
actually pretty awesome so here's an
example with functors so imagine I have
a list of intz and I have a function
that uses the functor interface use the
functor contract and it takes in my my
my list events or my functor events and
i forgot to say that it returns it as
well it's a bug in the slide but what's
what's the what's foo of X is length
anyway
exactly right it has to be the exact
same thing why because a functor can't
do anything to the length of the list
all I can do is map over the elements
right so all of a sudden you have a
pretty damn powerful theorem a pretty
damn powerful proof that you can say
about this foo method and that's all
because the functor interface is so weak
and this is kind of a useful thing to
think about so when you're you know
we're going to be talking about
applicative functors and then monads but
you're going to be using this in your
code and you'll have a choice do I need
do I need functor do I need a monad will
an applicative functor suffice and when
you're making that choice it's often
better to just stick with a weaker thing
partially because you can reason about
it more yeah so I'm imagining so I'm
restricting thing I'm cheating a little
bit so I'm not dealing with a language
where you can have like null or have
side-effects so in a pure functional
language there's no constraints on this
type a so therefore there's no way to
say materialize a new a or do any kind
of transformation on A's there there's
nothing you can do right all you can do
is return it you can get pretty far on
map alone so we're finally going to move
past map isn't that awesome you get
pretty far on map alone but sometimes
you need a little bit more power and I'm
going to motivate this with a pretty
simple example and the example I'm going
to kind of have run throughout the rest
of this talk but here's the idea imagine
we're building some kind of like
web-based calculator right so how is
this going to work well the users gonna
input some strings and then the back end
is going to want to parse the strings
and then add them up and return them
back so you're gonna want to do simple
things like parse the string and here's
a reasonable signature for a parse
function it's going to take a string and
it's gonna return option int Y option
int because the string might not
correspond to a valid option and we're
good programmers and we realize that
null is a terrible idea so we're gonna
use option instead of null right cool
okay so let's try to use this with a
functor idea right so we're gonna try to
add two parsed integers so we're gonna
parse three and all we have is map right
that's the only thing we can do with a
functor so if i try to parse three i'm
gonna want to feed it into another
function and I'm eventually gonna want
to add so this is probably a reasonable
idea of what I want that to do but the
type of this expression ends up being
wrapped in option right so I have option
in Terezin and so so here's what I've
got basically I want to add another into
this thing I have an option in Terezin
so I have a function wrapped up in
option in Tara's int and then I have
option int my the other option that I
parsed or the other in that I parsed
what can I do with that you can play
around with map all you want but you're
not gonna get anywhere it turns out you
actually need a slightly more powerful
map operation to deal with this and
that's where applicative functors kick
in so let's add the power that we need
to functor so remember that there's an
is a relationship between all the type
classes that I'm going to be talking
about today so every applicative functor
is a functor so it defines map as well
right so in addition to map it defines a
new method which I believe is pronounced
to app because it's from apply so
there's an apply type class which sits
above applicative which is sits above
applicative and just has excuse me just
has app but not map anyway this new
method looks very similar to map but
there's a subtle difference right so
just as before it takes the functor of
a's but the F that it takes is wrapped
up in a functor right so it takes an F
of a or as B and then it returns an F of
B seems a little bit funky but we can
actually use this to clean up our last
example clean up in quotes because it
looks hideous I think so yeah we can use
app we can parse our three parts no map
over that with a func
that adds the the X&amp;amp;Y and that'll work
I'll get an option int as a result and
it'll do what I want but that looks
pretty hideous Haskell things look a
little bit better so this is what this
might look like in Haskell if that still
looks a little odd to you then think
about it this way in Haskell you can
call a pure function just by you know
function name with a bunch of arguments
trailing so if I have a three argument
function f F takes XY and Z and I can I
can just call it like that but here's
the idea and this is this is where I
think the Haskell syntax makes things a
little bit clearer what we're doing is
we're going from call we're taking up
here function so a function that works
on pure arguments and we're turning it
into a function that works on effect
full arguments what do I mean by that
well instead of XY and Z just being pure
they might have side effects right so
they may fail they might not be valid
integers in the case of option or
depending on what other what other other
applicative you're using you might have
some other effect that you're talking
about so basically in the same sense
that as before we were lifting a
function from being a pure function to a
function in a funk to our context here
we're going from calling a function on
multiple arguments to calling a function
on multiple effect full arguments and I
think that's a good intuition for
applicatives when you need an
applicative it's basically when you have
a multi argument function where multiple
where many of the arguments or some of
the arguments have effects so that's
when you need up like it is and Scala
said there's a thing called an
applicative builder which makes the
syntax a lot less awful frankly so it's
still kind of backwards in my opinion so
what you do is you have the arguments
and then you have you trail it with the
function which I think looks backwards
in my opinion and you use this operator
here and on my team we we started
running out of names for these things so
we're like what the hell do we call this
thing
it's pipes with an at in the middle and
we decided now we call it the macaulay
culkin so so our chat room is often full
of it with we've actually named all the
weird Scala Zed symbols
so we'll be like oh yeah just you need
to Macaulay Culkin's on a big burden and
Bob's your uncle or whatever so moron
applicatives so what if some of the
arguments aren't options so let's say
some of your arguments are affect 'fl
but not all of them there's a useful
addition to applicative which basically
lets you take a pure argument and lift
it into into an effect and that's called
point in scholars at 7 and it's called
it's called different things that's
called pure sometimes or return I think
so yeah that's that's this guy here and
what that lets us do is say let's say I
had three aunts that I wanted to add
together to were coming from the web and
one was the constant 3 I could use an
applicative and then lift that pure
constant value into the applicative with
with a point okay there's an exercise
you can define the implicative instance
for option that should be pretty
straightforward ok so now we're gonna
get to monads everyone's favorite topic
so like I said I think there's a cottage
industry on creating monad tutorials and
and I'm gonna try not to fall into that
trap but then at the end of the slides I
probably will fall into that trap
because I think I I think I have no
choice oh but the problem is basically
this you'll see everyone that writes a
monad tutorial hopefully understands
what a monad is and they got to that
point by reading a lot of other
tutorials and eventually that some
combination of those things clicked and
the intuition made sense to them but I
don't think any particular monad
tutorial is like one single monad
tutorial is just going to be the light
for you including the one that I'm about
to give you so yes it is a trap there's
a link here it's to it somebody talking
about why monad tutorials are bad so
that's so let's go talk about monads and
I'm going to try to do this in a
task-based way so I'm going to take our
calculator example and I'll try to
motivate the use of monads
with the same calculator idea so again
we're gonna start with our parse example
and let's change the game a little bit
so what if our input string happened to
be an optional query parameter as well
right so instead of taking a string and
passing that to parse we have an option
string and we need to pass that to parse
okay so if all you have is a map hammer
everything looks like a nail I don't
know oh no how to finish that sorry but
if you just try mapping a parse function
over this guy you'll end up with
something that looks like option option
eight and you can't really do anything
with that either so once again we're
stuck there's a couple alternative
definitions for monads so you could
define this in terms of a method called
join but I'm going to do it in terms of
a method called bind so I'm going to add
one thing to applicative so again this
is my type class definition a monad is
everything in an applicative plus this
method which is often written like this
and it's pronounced bind again it looks
very similar to map or or even app for
that matter but there's a slight
difference in the way that in the nature
of the function that we take in in this
case we're taking in an A and returning
an F of B why is that useful well we can
we can do exactly what I wanted to do on
the previous slide that makes it useful
so in the previous example so that makes
our previous example look like this you
can do params that get X and then bind
parse and that will give you an option
int if you wanted to change these
together you could but it looks kind of
ugly so I can do params get X bind parse
bind X arrows and make a make up
function here another bind map
and we're all good but that looks kind
of unreadable unless you're a robot
maybe but there's some syntactic sugar
so remember at the start of this talk I
said there was nothing magic about
functors applicative functors or monads
this is the one exception I think
without syntactic sugar monads kind of
kind of look a little bit painful but
let's see where the syntactic sugar
comes from yeah so this is a fairly
typical pattern where where we have a
bunch of nested binds and then a final
map I can actually reformat this all
I've done is added some line feeds and
we can kind of see what that looks like
lined by and map right and that's
exactly what a Scala for comprehension
is right so so this is just this is just
syntactic sugar for this in many
interesting ways so this is much nicer I
think so interesting thing can anybody
can anybody kind of explain intuitively
what the the difference in expressive
power is between applicative functors
and monads based on what you've seen so
far yeah that's the start of that's the
start of the argument applicative does
take it takes multiple arguments and
then applies them to a single function
but of course if I if that was the only
V and if that was the enemy explanation
then I could counter that by saying
here's my you know I could do f of X Y Z
here and that would work fine so what
there's something else that's that's a
little bit different anyone yeah that's
not not quite what I'm trying to get at
is look at this what can you do with
with this in Scala right what is this
arrow mean in Scala like throw away all
this crap that I've just talked about
but imagine this is just some Scala code
that you see right you can actually use
X on the right-hand side of the next
generator this thing is called a
generator in Scala right so you can
actually chain computations with monads
that's the difference in expressive
power with applicatives you're you you
have one computation at the end but the
computation of the individual arguments
to that function can't depend on each
other whereas with a monad XY and Z
could actually be involved like I could
use monad I can use X in the computation
of monadic Y and that's totally
because I have X available to me within
this cool makes sense so here's where I
get into trying to do a monad tutorial
which is which might fail so here's my
stab at providing an intuition for
monads so consider the following monadic
code it's just a four with two
generators monadic X and monadic Y and
then it adds them up what is this code
do well it's kind of a vacuous question
because it really depends on what monad
I'm talking about here right but the
code here looks almost like imperative
code right when you look at this it
almost looks like you know imagine that
this just means semicolon and you have
almost something that looks like a
imperative Java code and that's that's
that's another intuition for a monad you
can think of monads as being a kind of
embedded programming language where the
the monad itself defined that the type
class instance actually defines the
semantics for that programming language
sounds kind of weird but but I can make
it a little bit more concrete so let's
think about some of the Munez that we've
seen option so imagine that this that I
told you that this monadic X and monadic
Y were we're working on the option monad
what would this code do well it would
basically execute X sorry we'd compute X
and compute Y and yield X plus y but if
X was none then the whole result of the
expression would be none right what does
that kind of have the flavor of well
it's kind of like an exception right
it's kind of like exceptions an
imperative code the only difference is
that I haven't actually stored a value
with the error so it's an anonymous
exception the reader example
so what reader does is it lets you defer
passing in an argument to a for
comprehension effectively it kind of
looks like a global environment so you
can say that there's some global
variable containing the environment and
you can actually instantiate that on
some particular environment later it's a
little sketchy because I haven't really
talked about the reader monad but
those of you that are a little bit more
familiar with reader already can kind of
maybe you can kind of see that we're
validation validation is it's part of
Scala Zed and it's kind of like a
pimped-out either type but what it gives
you or if you're not familiar with
validation just think of either what
you're getting there are descriptive
exceptions right so you're actually
throwing exceptions but you're able to
actually store an exceptional value
along the way so validation is kind of
like the validation monad or code that
monadic code that uses the validation
monad is kind of like a little
programming language because scope is
defined by the for comprehension where
the semantics are exceptions or a list
there's an interesting intuition for
lists as a non-deterministic computation
so imagine that monadic X and monadic Y
or lists then what this will kind of do
is imagine that instead of a computation
that yields a single value it yields
multiple values because it's not a
non-deterministic computation then X
plus y will kind of pairwise compute the
results of all those non-deterministic
commutator computations so list is monad
the intuition there is kind of a
programming language with
non-deterministic commented computations
and that's that's kind of actually all I
have is I know as a short talk I think
this kind of sets us up for this kind of
bag this slide kind of begs an obvious
question which is what if you want a
programming language with multiple
effects so what if you want
non-deterministic computations plus and
on a plus anonymous exceptions or a
global environment plus exceptions and
the answer to that is going to be monad
transformers and that's that's where I'd
pick up next if I was going to continue
along these slides so that's that's all
I've got I want to thank you guys for
being a captive audience and take some
questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>