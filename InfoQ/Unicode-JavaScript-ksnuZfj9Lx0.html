<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Unicode ♥ JavaScript | Coder Coacher - Coaching Coders</title><meta content="Unicode ♥ JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Unicode ♥ JavaScript</b></h2><h5 class="post__date">2014-05-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ksnuZfj9Lx0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm going to be talking about JavaScript
in Unicode and how the two go together
so first let me introduce myself this is
me I'm a web developer from Belgium just
like you guys well most of the audience
anyway I recently joined the Opera
developer relations team and it's funny
that I got chrome sucks because chrome
socks is actually our company slogan no
not really actually you work on the
chromium project as well so yeah exactly
anyway my spare time I also like to
collaborate on various different source
projects one of which is chess birth
which I made in 2010 has anyone used to
yes / let's do show of hands okay some
people well if you don't know what it is
it's basically it's just a website and
you can go there and get this form you
can enter a few JavaScript snippets that
are equivalent so they do the same thing
but they're written in a different way
and then Jasper creates a test case for
you that you can run in any browser that
you care about and it will tell you
which snippet is faster and what the
difference is so it's really useful for
performance testing in JavaScript I'm
also a member of the core dev team for
the html5 boydle paid project which is
something you may have used I can you
hear me probably because ok so anyway my
twitter handle is just my first name
Matthias so if you happen to have any
questions and you're too shy to ask them
afterwards just ping me on prayer and
I'll get back to you now does anyone
know who this guy is yeah it's JC of
course the famous rapper but a
little-known fact about him is that at
some point he decided to write a
JavaScript program so we installed node
and NP have many started programming
away but at the end of the day had
written a song about his frustrations
with the language instead
program and actually you may have heard
this song before it's called 99 problems
now I'm making fun of JavaScript here
but don't get me wrong absolutely love
the language I think it's a great
language but just like with any other
programming language whenever you're
writing code you know it can happen that
you're confused sometimes by a specific
feature or behavior of the language and
this happens for all languages for
example for a PHP there's even a
dedicated website do these kinds of
things called PHP what the org and
we have the same thing for JavaScript
which is called what the GS and it
kind of collects these strange little
nuggets of weird and surprising behavior
in the language now of course all these
things on these websites can perfectly
be explained if you just look at the
manual or with the specification or look
at the implementation but still if a
behavior in the language is confusing to
a lot of people then it's a bit of a
problem right so that's why I'm going to
go ahead and say that Java scripts in my
opinion has a bit of a Unicode problem
and I'll show you why in a second now
why should you care about this because
at this point you may be thinking okay
this is probably going to be talked
about hk's issues that I will never have
to deal with in my lifetime but that's
not true well let's do a quick show of
hands have you ever used JavaScript
before okay almost everyone is raising
their hands keep them up get them up
okay drop your hand if you have never
used the string in Java Script before
okay nobody dropped your hands actually
some hands went up which is weird okay
so have you ever used string and
JavaScript that came from user input or
from a third-party API or any other
source that you do not directly control
yeah well still the same amount of hands
you can drop them now but the point has
been made whenever you want to support
arbitrary input and arbitrary strings in
your JavaScript application there are
some things that you need to do and that
you'd need to keep in mind and most of
these things are in my opinion really
surprising so
that is what this presentation is going
to be about now I started looking into
this behavior a couple of years ago when
I was working on a buena goat GS library
does anyone know what Buena code is I'll
give you a hint it has nothing to do
with the Hulk making fun of your lame
programming skills or anything like that
unicode actually well traditionally it
was only possible to register domain
names that had a ski symbols in them
like you all know that you cannot use
certain symbols in your remaining
directly and the entire web in fact has
been built around this fact and
technically even today it's not possible
to register a domain name that contains
a special character like a special
unicode character for example but puny
code is kind of like a workaround for
that so buena code is an algorithm that
converts and an internationalized domain
name like the one you see there mañana
come to an esky only representation the
same goes for cafe de if you actually
register the domain name on the right
hand side you will end up with the
internationalized domain name on the
left hand side so browsers automatically
do this conversion for you yeah that's
actually a real domain name bubala I
wouldn't you just go in there but it
exists anyway so all the browsers and
all the other programs that need to deal
with URLs have appt Unicode encoder and
a decoder built in and basically they
just implement this algorithm and that's
what i wanted to write in javascript
just for fun so that's buena code and
i'm going to spare you the details of
how the algorithm works exactly but
internally at some point i needed to
look over the internationalized domain
name string and go over it character by
character and that sounds really simple
that part but it's actually really hard
especially in javascript and this
presentation will explain why and it
will also explain how you do it properly
so for me by working on this library
that's when I started to see all these
issues in the JavaScript language but
before I get into all that let's talk
about unicode
self because there's a lot of
misinformation about Unicode and what it
really is so first off unicode is not an
encoding it's actually much easier to
think of Unicode as sort of a database
that maps any symbol that you can think
of to a number the unique number for
that symbol and a unique economical name
for that symbol so the whole point of
this is that this way you can refer to
any symbol without having to use the
symbol itself which is really useful so
for example the latin capital letter a
that's the canonical name for this
symbol has the code point u + 0 0 for 1
and the code points is usually formatted
in this way it starts with the U plus
prefix and then it's followed by some
hexadecimal digits and these are usually
0 padded up to four digits at least four
digits so another example is the latin
small letter a of course this is a
completely different symbol so it has
its own unique canonical name and it has
a completely different code point so
that's the basics of Unicode really I
think you get the idea now each symbol
simply gets its own unicode code point
now there's a lot of weird symbols in
Unicode like the Unicode snowman for
example this is a real character I'm not
sure why you would ever need this in
your English text documents but it's
there if you want to use it and the code
point is you plus 2603 and then there's
everyone's favorite unicode character
the pile of poo so I'm not making this
up this is actually the canonical name
for a character in the unicode standard
it's pile of poo as you can see the code
point is one F for a 9 which consists of
five hexadecimal digits so at this point
you may be wondering okay what how many
code points are there what's the highest
possible code point value well in
unicode the code point values range from
0 to 10 ffff so that's over 1.1 million
possible symbols now not all of these
code points have been assigned a symbol
yet in Unicode but this range has been
reserved so that in the future whenever
they want to add a new symbol they can
just pick any
those code points that haven't been
already used and just assigning the
symbol there now to keep things
organized to Unicode divides all these
things all these code points into 17
planes that consists of about 65,000
code points and the 65,000 symbols for
each plane and the first of these planes
is probably the most important one it's
called the basic multilingual plane or
the BMP and it contains all the most
commonly used symbols so whenever you're
writing a text document in English or
even in Spanish or French or whatever
chances are that you won't need any
characters or any code points outside of
the BMP and just like any other plane as
you can see it's about 65,000 symbols in
there and then there's a group name for
all the other planes combined as well
they're called the supplementary planes
or the astral planes so code points
within a plane or called astral code
points or asshole' symbols you get the
idea now these astral symbols are pretty
easy to recognize because if you need
more than four hexadecimal digits just
to represent them that means it said an
astral symbol okay so that's all you
need to know about Unicode to deal with
strings in Java Script correctly so
let's move on to the javascript behavior
that I was talking about so now that you
have a basic understanding of Unicode
it's easy to see how it applies to
javascript strings for example you may
have seen stuff like this before it's in
a string you can have a backslash
followed by X and then followed by to
hexadecimal digits and these are Scott
this is called hexadecimal escape
sequence now in this case it gives you a
way to refer to the Unicode code points
that's what the digits refer to so it's
a way to refer to a symbol without using
the symbol itself so in this case this
is just a string ABC it caps but
represented using escape sequences now
this is useful in some cases but it's a
bit limited in its use because you are
limited to just to hexadecimal digits so
we can only use this for the code points
in the range from 0 to FF now what's a
bit more useful is the so
call to Unicode escape sequence it
starts with a backslash followed by you
and then followed by four hexadecimal
digits instead of two so this gives you
a much bigger range of code points that
you can escape this way so again this is
the same string ABC but now that you
have four hexadecimal digits to use you
can also escape characters like you plus
2661 which is the Unicode white heart
symbol which looks like this so using
this type of escape sequence you can
actually escape all the characters in
the BMP in the basic multilingual plane
which is useful but as you know there's
still these 16 other planes the astral
planes so what do we do about those we
cannot represent them using just four
hexadecimal digits because we need more
than four digits so what about those
astral code points or another way to
phrase the question what about the pile
of poo and other equally important
asshole symbols of course so remember
there's over a million of these estriol
symbols in total and the answer is well
we can actually represent them using
escape sequences but it's a bit
complicated in acma script six the
upcoming version of JavaScript this will
actually be really easy because you can
just use the Unicode code point escapes
these are new and they start with a
backslash followed by you followed by
braces and then between those braces you
can use up to six hexadecimal digits so
that is enough to represent all possible
unicode code points so this is really
useful and like as you can see you can
just escape the pile of poo by using its
code point and then you get the correct
string that you would expect sorry for
the beatboxing there now for backwards
compatibility when a conscript fire so
for existing implementations we actually
need to use surrogate pairs so if you
want to represent the pile of poo using
escape sequences today you actually
needs two separate escape sequences
which is a bit confusing especially
because the code points for these escape
sequences are probably not what you
would expect they don't look anything
like the original code point so in this
guy
for the surrogate pairs each circuit
represents the half of the symbol and
it's only when their combines together
they form a single symbol and there are
formulas that can be used to calculate
these surrogate halves based on an
actual code points and the other way
around you can go back to and this is a
JavaScript implementation of those
formulas you don't really need to look
into it too much but again this is
something that you need to keep in mind
whenever you're dealing with strings in
Java scripts because often you will need
to use these surrogate bears yourself
and sometimes you will even have to
calculate them yourself using this code
now this whole concept of using just the
single escape sequence for BNP symbols
but then using two separate escape
sequences for asshole symbols is really
confusing and it has lots of annoying
consequences in the entire JavaScript
language so let's say for example that
you want to count the number of
characters in a string it sounds fairly
simple right well my first thought would
be to use the length property that any
string has so for example if you have a
string with the capital letter A and
there and with the code point for one
you can tell that length is B is just
one right and this can be explained by
using escape sequences if you represent
the string using nothing but escapes you
see that there's only a single escape
sequence needed to represent it so it
makes sense that result this one the
same goes for the capital letter B but
what's important here is that this is
not always the case the length property
of the string does not always reflect
the number of symbols or code points in
the string for example let's try some
slightly different characters they even
look a bit similar these are the
mathematical bold capital a symbol in
Unicode with the code point 1d 400 and
mathematical both capital B and as you
can see they have a length of two
instead of one even though there's only
one symbol there in the string I thought
it was really confusing behavior but it
can be explained because if you need to
represent it using nothing but escape
sequences you can see that there's two
escapes needed for the one symbol of
course this is really really confusing
because we're just humans and we
generally think in terms of Unicode
characters rather
in surrogate halves or anything no one
things like that only computers do now
similarly if you try to wrap the pile of
poo in a string and then get its length
you will get to the number two and
there's a very obvious joke to be made
here but I'm just going to skip ahead so
here's a practical example of where this
causes issues this is a screencast that
I made on the Twitter website once upon
a time as you can see they have this
character counter at the bottom that
tells you how many characters you have
left and in their back-end to do the
right thing and if you use an asshole
symbol or any other symbol they don't
care it just counts as a single symbol
however in their front end they had a
book that would just use the length of
the string and do the calculation based
on that so as you can see here for each
pile of poo you enter the number
decreases by two instead of one so while
this book was there you could only post
tweets with 70 piles of poo in them
instead of 140 yeah now luckily they fix
the bug since but another example is the
countable yes library which you may have
seen before basically what it does is
you hook it up to a text area or an
input on an HTML page and then it will
count the number of characters and
paragraphs and words that you enter into
there and then it will list those
numbers elsewhere on the page that's all
it does really so the first thing i did
when i saw this demo page for the
project was to enter a pile of poo of
course and unsurprisingly it counted as
two characters rather than just one now
i reported work and it has since been
fixed but the bottom line is this is a
really easy mistake to make but if
you're writing a javascript library or
you're doing anything in javascript that
involves strings especially when you
don't control the input yourself you
have to make it work with all kinds of
symbols you just don't have a choice you
have to so consider astral symbols and
not just the symbols in the basic
multilingual plane and really the
easiest way to verify this is just to
test it with some astral symbols like I
did here just throw some piles of poo in
there and see what happens so getting
back to our question how can we
accurately count the number
symbols in a javascript string you can
use something like this so getting back
to life punic OTS library this is not
its main functionality the main
functionality is to convert between the
different domain names but to iterate
over the internationalized domain names
symbol by symbol I had to implement some
helper methods that would do this and
that would account for surrogate pairs
and I decided to expose those methods so
that other people can use them in their
own code so in this case you can use
Unicode UCS to decode you pass in a
string and it will return an array of
Unicode code points so it will have only
one item for each code point in the
string so then if you get the length
property of the resulting array instead
of on the string directly it will get a
more accurate result one more note the
Buena gorgeous library that I was
talking about it's included with no chi
has by default so if you want to use it
in node you don't have to install
anything just require it require Unicode
and you get get it going with it so in
equal script six this will be much
easier and you won't need a library for
it anymore you can just use array dot
from you pass in the string there and
that will create an array containing a
string for each symbol in the string so
this is similar to the previous solution
in the background this uses the string
iterator that is also new in equal
script 6 and this string iterator is
defined so that it only loops over whole
symbols so it automatically takes care
of these circuit pairs for you and as
you can see the result is much more
accurate this way I've also created a
tool that takes a string as input and
then shows the escape sequences for any
special characters within that string so
it's a bit similar to a hex dump except
the output is valid JavaScript which is
sometimes more useful and with this tool
it's really easy to tell what kind of
unicode symbols the string contains even
if the symbols are non non printable or
just white space symbols as you can see
here
now if we're being pedantic and this
depends on your use case of course it's
actually a bit more complicated so now
we know how to count code points
correctly but sometimes you know the
string looks visually like it contains a
number of symbols while in reality it
contains more symbols so how can we have
come for stuff like that for example in
this case javascript seems to be telling
us that these strings are different but
they look the same to us right so what's
going on here well as to tell you what I
did I took these two strings and I
pasted them into the tool that I just
showed you and then it gave me these
results so as you can see the first
string contains the character f1 which
is an M with a tilde on top of it and
then the second string is different it
has a separate and character and then
followed by the character with code
point 0 30 tree which is a combining
tilted and a combining mark always gets
applied to the previous symbol so
visually they look exactly the same but
if you look at it this way it's obvious
that they're not the same string the
first string has length of 6 the other
has length of 7 and they use different
symbols so there's no way that it can be
the same so how can we fix our solution
so that it even accounts for this sort
of thing for these look like symbols in
this case if you want to get the length
of the string we probably expect the
result of six for both strings right
well in a conscript six this will be
really easy because it introduces
unicode normalization you can just call
the normalized method on any string and
then pass a normalization form in there
and do it this as a result will take
care of most look like symbols like the
one we've seen earlier and that after
that of course you still have to account
for astral symbols and circuit pairs
like we did before and you can actually
use this today in chrome and opera this
is already landed but if you wanted to
support other browsers as well which you
should do you can use a polyfill called
you norm the link is there at the bottom
I'll also put the slides online
afterwards and this is a completely
respect compliant polyfill for the
normalized method now still this is not
exactly perfect just like your ringtone
yeah for example if you have a string
like this well I count nine characters
here but if you feed it to the function
that we just created you'll still get a
result of 116 even with our pedantic
version of the function so this is
probably not what you expected but if
you need to support stuff like this you
can solve it by using a regular
expression that takes care of all the
combining marks and the grapheme
extenders you can basically just remove
them from the string and then count the
number of code points just like we did
before and that would give you a better
result but i'm not going to show you the
regular expression here because it would
scare you and you would start bleeding
from your eyes and stuff like that I've
seen it happen before it wasn't pretty
now another example is reversing a
string in Java Script it sounds really
simple and in fact the most common
solution to this problem looks like this
you just take a string you split it into
an array of symbols then you reverse
that array and then you join it back
together into a string and this works
fine for a lot of cases for example if
you have a string ABC it reverses into
CBA which makes sense now let's try
another one if you take the string
manana with the end with the tail on top
of it it still reverses correctly now
let's try the other mañana where the
end and the till there are two separate
characters in this case the combining
tilde now gets applied to the round
character it's gets supply to the a
instead of the end which is probably not
what you would expect and then finally
let's try to reverse a pile of poo or
any other estriol symbol and the result
here is that you will get the surrogate
halves but in the wrong order sort of
Paris now in the wrong order and this
means that you basically lost some data
there the string won't be really usable
so this is probably not what you would
expect and you somehow need to work
around these issues now luckily for us a
brilliant
puter scientist named missy elliott's
came up with a bulletproof algorithm
that accounts for these issues the
algorithm goes I put my thing down flip
it and reverse it and indeed by first
swapping the position of the combining
marks with their original characters and
then also reversing any surrogate pairs
before further processing the string the
issues are avoided successfully so Thank
You Missy and I actually wrote a
JavaScript implementation of her
algorithm called s River so if you ever
need to reverse the string in Java
scripts you can just use that and as you
can see it will account for these issues
correctly now this behavior affects
other string methods do it's everywhere
in the JavaScript language so for
example if you try to use string up from
character code this is a function you
can pass in a code points and that will
turn that code point into a string
containing that symbol for that code
point which is really useful but it only
works the way it would expect it to for
b-and-b code points if you pass it an
asshole code point it will still give
you a result but it probably is not
going to be the result that you would
expect so this function is slightly
broken it only works for BNP characters
now the solution here is to use
surrogate pairs and in this case you
would have to calculate the code points
for the surrogates yourself which is a
pain of course what you could also do is
use another library like for example of
Unicode GS which has a helper method
where you can just pass in an array of
code points and then it will do the
conversion for you that's slightly
easier because you're gonna have to
calculate it again anymore but what
would be even better is the new function
that is coming in akwa script 6 it's
called string not from code points and
it's it's pretty much exactly the same
as string up from character code except
that this one actually works not not
just for code points in the bmv but for
any code point and you can actually use
this today if you want to by using the
polyfill that I'm linking to at the
bottom now another method is string of
prototype character at it is similarly
affected by this behavior so if you use
character add to retrieve the first
symbol in the string containing the pile
of poo symbol you won't get the entire
a pilot who you just get the first
surrogate half so you get half the pile
of poo which sounds like a good thing
but actually it's not what you want now
this can be fixed in actionscript 7 none
at echo script 6 this is a proposal that
i wrote a string dot prototype at and it
would allow you to get the symbol at a
given position and it would
automatically account for these
surrogate halves and combine them
together for you another example is
strangled prototype built character code
at which has a similar problem if you
use it to retrieve the code point of the
first character in the string with the
pile of food you would only get the code
point for the first surrogate have not
the entire character again this is
really confusing now I conscript six
fixes this by introducing yet another
method which magically does the same
thing but it works correctly even for
astral symbols now another fun toy
exercises how do you iterate over all
symbols in a string now you may remember
that I needed to do this for the Punic
ogs library so the thing to keep in mind
here is that we need to account for
asshole symbols and in equal script five
this looks something like this and this
is actually a simplified solution it's
not perfect you actually need more code
and this which is terrible enough
already so you need a lot of boilerplate
just to account for those annoying
surrogate pairs to combining back
together into a single character now
with Xcode 6 it will be much easier
because you can just use the string
iterator you can use for off to iterate
over each symbol in the string and it
will automatically take care of the
surrogate pairs for you it's much
cleaner now I didn't mention all the
string methods one by one but string dot
prototype about substring or slice or
basically anything else involving
strings in java script has similar
issues so look out when you're using
them now another fun thing to think
about is regular expressions for example
the dot operator and regular expression
only matches a single character but
because JavaScript consider
surrogate has to be separate characters
it would never match an astral symbol so
in this case you might expect the
regular expression to match and the
result to be true but instead it's false
because the pile of poo consists of two
surrogate halves as far as javascript is
concerned so let's think about this for
a second what kind of regular expression
could we use to match any unicode code
points well we cannot use the dot
operator as we've demonstrated besides
it wouldn't match line rate leader if
you wanted to match line breaks we can
solve that problem or just using this
sort of regular expression where we
basically match all the whitespace
characters and then match all the non
whitespace characters as well and then
that matches any character but still it
would only match characters in the
different in the JavaScript definition
of the words so only surrogate halves it
wouldn't match asshole symbols so does
anyone know or have any idea what a
regular expression to match any Unicode
symbol would look like ok we look
something like this yeah my thoughts
exactly so what's happening here is that
the first part of the regular expression
matches any BMP symbols that don't start
a surrogate pair then the second half of
the regular expression matches surrogate
there so an asshole symbol now of course
this is not the type of regular
expression that you want to be writing
by hand let alone debugging it that's
that would be crazy so what I did is I
use the JavaScript library called
regenerate to create this regular
expression for me dynamically and it
looks something like this so you create
a new regenerate instance you defined
range in this case I just add the range
of all unicode code points and then I
call the two string method on it and
then it will return a string that
represents a part of a regular
expression that I can use it returns the
string because it's supposed to be used
as part of a build script so you can
dynamically insert the result in regular
expression into a JavaScript file and
use it from there now another slightly
more advanced example would be to create
a new regenerate instance at all the
possible unicode code points and then
remove
range of symbols in this case all
symbols from A to Z then remove a single
symbol in this case the pile of poo and
then create a regular expression that
matches all those characters in the set
and then it would look something like
this so again this is not the type of
regular expression that i would like to
write it by hands let alone debug it so
if I have the choice between maintaining
the regular expression directly or by
just maintaining those five lines of
code right about there I definitely know
what you choose so the whole point of
this library is to just create a build
script that generates these complex
regular expressions for you and that way
it's much much more maintainable now
getting back to our problem it can also
be solved in akwa script 6 by using the
new regular expression you flag in that
case if you use this you flag the dot
operator will match whole code points
instead of just surrogate house so this
magically fixes the behavior that you
were after another example is character
classes in regular expressions for
example if you do a to see in a
character class you probably expected to
match a B and C right well similarly if
you create a character class when astral
symbols you would expect it to match all
the symbols within that range but this
is not exactly true this doesn't work
the way it would expect it to in fact as
soon as you execute the first line of
JavaScript there it will throw a syntax
error because in this case it will say
the range is out of order in the
character class so what is going on
there well as far as javascript is
concerned this regular expression looks
like this because each asshole sim will
consist of two separate characters right
so what javascript is trying to do here
is to create a range between those two
characters between the last surrogate
for the first symbol and the first
circuit for the second symbol which is
not what you want and it's also
impossible because the range is in the
wrong order so even if it would work it
wouldn't do what you want so the way to
fix this in equus crypt six is again
just introduced the you flag and then it
magically starts working the way you
would expect it to however if you need a
solution that works today
you're back to using a tool like
regenerate for example so you just say
regenerate and then you add to range
that you want and then you turn that
into a regular expression and it will
look completely weird like the one here
but it will work the way it would expect
it to end it will match only the symbols
that you defined so in summary I think
it's fair to say that javascript has a
Unicode problem but rather than complain
about it like JC did I think we should
be doing more of this instead yeah we
should just deal with it and really work
around these issues because once you're
aware of them which you all are now it's
not really that hard to work around them
and remember the pile of poo tests I
think this is really important so
whenever you're working on a JavaScript
library or you're using a JavaScript
library and you're looking through a
unit test and you see that there's no
pile of poo in there just submit a pull
request with a pile of poo and to really
help them so thanks that's it for me the
slides can be found there
we have time for some questions we don't
have another mic yeah you could create
look at for example use regenerate to
create a regular expression that only
matches astral symbols then you can
apply that regular expression to the
string see if it matches if it matches
then you know you have to do some extra
work that would work yes yeah exactly
yeah so the question was why do they
introduce new methods in Echo scripts x6
rather than wow that would be a fun
language so rather than fixing the old
ones that are broken well the problem is
backwards compatibility there's a lot of
existing code on the Internet today that
relies on the broken behavior of these
functions and if we were to magically
fix them all those scripts would
suddenly be broken and that's something
we just cannot do we cannot break the
web so instead we have to introduce new
methods good question ya know for the
same reason we're practically stuck with
them forever because there's so much
existing content that just relies on
these things yeah this point was that
the old functions could be useful if you
want to know the exact amount of bytes
that the string consists of and that
really depends on the encoding that
you're going to store the string in a
JavaScript uses ucs-2 internally which
is also what dumb strings use so
browsers use that internally to but if
you're going to save a string as utf-8
for example it will be a different
number of bytes for each string
depending on the character that use so
it it all depends I don't think the old
functions are all that useful to be
honest but for a long time we just
didn't have anything else yes yeah so
there's a lot of different encodings
utf-8 utf-16 ucs-2 which is what you
have script uses internally which is why
we're having this behavior well for most
purposes utf-8 is probably the best
encoding to use because it's optimized
for example if you use a BMP symbol it
will take one two three bytes only and
only if you use an asshole symbol which
are not that common honestly then it
will take up four bytes so it's a
variable length encoding which is really
useful on the other hand if you use
utf-16 as you can see here you have
either like two bites or four bytes that
are needed which is not as useful
because a lot of well the most common
characters are being V symbols so for a
BMP symbols they would take up twice as
much size storage space as you give it
would so it depends but for most things
i would say use utf-8 when you can
actually i have an entire blog post on
that goes on between the difference
between ucs-2 and utf-16 and the end
result is that javascript is more close
to ucs-2 than it is to utf-16 because
then you GF 16 you cannot have loan
surrogates and javascript palacios and
there's some other reasons as well but
i'm happy to discuss this after yeah
what over beer or something yeah yeah
well for the examples that I showed in
my size double equality versus Triple
equality didn't really matter because
there were always at the same time in
general I tend to use double equals
rather than triple equals I know that's
an uncontroversial move my hands but I'm
of the opinion that if you know that the
types are going to be exactly the same
there's just no point in using triple
equals like for example if you use type
off and then a variable you know that it
will always return a string so in that
case I think it's useless to add to your
triple equals but that's personal
preference really ok let's have some
beers
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>