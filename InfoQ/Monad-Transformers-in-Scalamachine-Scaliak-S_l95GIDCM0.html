<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Monad Transformers in Scalamachine &amp; Scaliak | Coder Coacher - Coaching Coders</title><meta content="Monad Transformers in Scalamachine &amp; Scaliak - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Monad Transformers in Scalamachine &amp; Scaliak</b></h2><h5 class="post__date">2012-07-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/S_l95GIDCM0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so as you probably know I'm
going to talk about mon at transformers
today it's kind of a follow-up talk from
meetup we had at last and a couple
months ago along the way so some
examples of using mana transformers from
some a stack mobs source code as well as
a couple open source projects we work on
one of those projects is scollay ack
which is a react wrapper around the
reaction i a'n't using a lot of its a
scholar rapper it uses a lot of scholars
ed and using my dad transformers what
that library can be useful so some of
those examples will come from there
another one is Scala machine which is a
port of Bosch shows web machine
framework which is a HTTP application
framework over to scala and both those
projects you can find on the stack mob
github org so github.com / stack mob and
if you want I do have a bunch of code on
this slide so if you prefer sort of
following along on your computer you can
grab the slides up there it's just
speaker com / you / junior west / p /
mon address transformers if you need the
link let me know and then lastly before
we get started just a little bit about
me so I'm a developer here at stack mob
both spend most of my time in Scala a
little bit inner lying a little bit in
Ruby my background is primarily Ruby and
erlang and now Scala been doing Scala
for about a year now actually a year is
this this weekend at stack mob so
scholars sort of somewhat new to me
relative to some of the other languages
I've worked with so as I mentioned back
in May there was a meet-up john from
atlassian gave a talk on the type class
of pd a-- which is this awesome
reference for you know functional
programming that elasti and hosts and
there's one there's one for Haskell but
it's nice to have something for scholar
cuz we don't always have good
documentation for us and you kind of
have to go learn the haskell syntax so
how many people were at that meet up ok
some of you guys and the content itself
so you know some of the basic type
classes functor applicative maanta at
how many people here are
recently familiar with that in their
minds okay so I have a little bit of
review I'll kind of go medium speed and
if you guys have any questions feel free
to just shout out and interrupt me
anytime so John talked about a lot of
things one of them is he talked about
this type class you I'm assuming
everyone's kind of familiar with the
type class pattern right okay so talk
about one of these type classes called
the montague and it extends this other
type class called an applicative so
every monit is a duplicative and i'll
kind of just hand wave over that for now
and more importantly there's this method
flat map which and I've tried to sort of
smooth it out in these slides but it's
sometimes called bind it's sometimes
sort of written as greater than greater
than equals except for places where i
actually have compiling code i've tried
to use flat map everywhere but so
there's sort of this and really there's
these three important methods that are
going to be sort of key to the rest of
this talk so the first one is point
which comes from the implicit of type
class and that essentially lets us lift
a pure value into some monitor into some
context and then we have map from the
function type class which lets us lift a
pure function that operates on a type a
and returns the type be lifted into some
context or into some mana and then we
have flat map from the Montana type
class which lets just chain these
operations together where one may depend
on on the one previous so everyone kind
of good so far cool so a couple quick
examples in Scala said seven we have
this nice way of sort of explicitly
grabbing the type class instance for a
Mon ad and calling one of the functions
on it so this is an example of that so
we're you talking about the the option
that you know the option is an instance
of the monotype class we're talking
about an option here pointing the value
one into it or we can we can map over it
we can hear is buying the same as flat
map in Scala they call it bind in the
type class and then there's syntactic
sugar for flat map and this is kind of
that syntactic sugar although flat map
to be honest is defined in the standard
library but you can see point here which
which comes from the scholar said seven
syntactic expressly sort of extensions
there so we have more of the
object-oriented looking feel to our to
our code
and really what I think was kind of the
core sort of thing that leads to this
talk is how how Jon left his talk at the
end and he presented sort of one and
it's important this is really only one
possible intuition form on ads but he
said that a magnetic for comprehension
is an embedded programming language with
semantics defined by the Mon ad so we're
working in this for comprehension we
kind of have this little mini
programming language that has you know
these sort of semantics of depending on
what our types are and any sort of left
it with showing 1 mod ad wrapping a
value like option or something like that
and mentioned that as we start to
compose these or stack them it gets much
more interesting and that's where my dad
transformers sort of comes from so at
the simplest level right we maybe have
something like a value which may or may
not exist and really quick before I move
forward John had actually called option
like anonymous exceptions and so one
thing I think that's important about mon
ads is the semantics you have some
choice over i mean the types do
communicate something but you know
option can mean this value may not exist
somewhere maybe i don't care about
exceptions you sort of depending on your
code are sort of choosing those
semantics to an extent another example
is often debated in the scholars dead
room is whether or not validation
similar to either is a Mon add in some
people's mind it's only in applicative
because of its semantics whereas at
stack mob we kind of tend to bend those
semantics because we found that success
and failure is easier to reason about
then left and right even after using it
for a while so it can be dangerous but
you also sort of have a choice so
anyways so that optional value we may
need to perform some side effects to go
get maybe you know it's a value that may
or may not exist in the database and we
need to go out and communicate over TCP
to talk to that database to get that
value and maybe along the way there are
some exceptions or you know something
that may happen that we do care about
that we don't want to be anonymous or if
I'm sort of choosing option to mean
exist or not exist that specific
exception these are all the other
exceptions that may happen but I've just
chosen throwable kind of arbitrarily
there you can pick whatever you want is
the arrow type and then lastly you know
maybe we want logging in there also so
now we have kind of this big beefy monta
that at some point yields this value a
when we get deep inside of it but we've
got a whole bunch of sort of composed
effects there so that's what we mean by
stacking effects but there's kind of a
problem with doing this practically so I
can you know show you the types but it
doesn't mean you can work with them and
from a theoretical perspective the
reason is that Monta adds do not compose
so to sort of fully understand that we
need to talk about composition and what
compose means I'm going to do that kind
of by example so a type class that does
compose our funk doors and actually
applicative Zahl so and so it's a quick
reminder of functors this is the the
function type class we have this method
map as I said previously it you know
lifts this this pure function into some
context lets us operate in that context
and what we want to do is we want to
compose two of them and encode what that
means is we want to write some function
that given any two functors M&amp;amp;N and in
Scala we take those implicitly to say i
want the instance of those two type
classes we need to define a new function
and at a right but we're still taking
our pure function and so we want to
write this function and if we can write
this function functors compose and in
fact that functions really really simple
to implement you map over the outer
functor map over the inner functor and
then apply the function to that inner
value so everybody cool all right and so
an example of how that works in practice
we can use that to write if we have mna
after we've done composing things we can
take a third functor and compose that on
top and we can kind of keep going but
one thing that's nice about scala said
is if you're just working with two
functors and you want to compose them
quickly it gives you this map to
function that does that so you can see
an example here I have this function
which i think is it takes the length of
a string and I'm using that same
function to map over an option and a
list of options
using map too so I'm composing those two
functors and so you know alternatively
what I would have been doing is mapping
over the list and then mapping over the
options or a for comprehension or
something like that which is just a
little bit it's the same thing it's a
little bit noisy it's repetitive write
that code is encoded in here calling map
twice so there's no reason to type it
everywhere twice so the problem again
from a theoretical perspective as my
dad's don't compose and what that means
is we can't write this function taking
any to my dad's give us this new bigger
mounted so if you try to implement in
this fat map method you won't be able to
get it to compile it in any form and
really i'd suggest trying it just you
can go take it down like that's kind of
where it clicks for me is why i suggest
it is like you're kind of like I don't
really get it and then you go to type in
you're like oh this is impossible
there's no way I can get to a compiling
piece of code like there's no like trick
you can do nothing you're just screwed
and if you want to find a little bit
more about it a lot of these slides are
sort of examples taken from Tony
Morris's blog as a blog post called
Montez did not compose and there's a
nice just up there you can clone and
actually try out it's all compiling up
to that method so you can try to
implement that method yourself so that's
great from a theory perspective I but
you know we hear kind of are on the cusp
of using functional programming a lot
but it's not necessarily the core so for
us it's always about what practical
benefits we can get so I kind of want to
talk about how this problem presents
practically and for me it really results
in nasty code which I call
stair-stepping so two example of that or
i call most people call let's say we
have a couple values here again you know
we're talking we want to get some data
out of somewhere that value may not
exist to take some side effects to get
and on this my data fictional type we
have this merge method where we can put
two of them together and magic happens
so we want to write some nice code that
deals with that and maybe we take a stab
like this right the problem is data one
and data two aren't my data their
options right so we have i oh here when
we strip it off data one is an option
data to as an option so that doesn't
work so maybe we try this don't do that
calling on say perform io like that is
bad
so this is wrong I mean it functions but
it's wrong here are a couple other
examples that also function that are
just awful this one has some nasty
pattern matching this one has nested for
comprehension which really kind of gets
loose if you're familiar with some of
the other type classes you may notice
that I'm somewhat have a contrived
example and this is a semigroup and you
could basically make this a lot simpler
but let's say this was a little bit less
of a contrived example I tossed this in
things just got more complex and so
you're not saying right now
here's an example from stack mobs code
before I knew about mono transformers
this makes me want to cry a couple
reasons eh it's just super hard to read
B I'm sort of like folding down
validations than folding down options
just to create the same validation out
to deal with the error because I haven't
dug into the Montague properly yeah so
we have a service called Barney actually
I guess we joked at one point we're
going to have to say Barney out in
public but yeah so we have a service
called Barney and it throws exceptions
called Barney exceptions so or I guess
well it doesn't throw them rather it we
use the exception type as our error type
although we don't throw them instead of
building custom error types for
everything we just use the throwable
hierarchy so okay so that's a problem
but right the whole point is to kind of
figure out how to deal with these things
so there is a solution and just to point
out this is a solution not the solution
and we'll keep working with that IO
option example and we'll sort of build
two mana transformers and again please
feel free to stop me on the way we're
going to get kind of into heavy code at
this point so what we're going to do is
for the IO option we're going to make a
new type that boxes that value and I've
chosen to do that with a case class for
brevity but you can do it however you
want it doesn't have to be a case class
but we box that value and then what's
important is this new type here we can
define an instance of the modded type
class for and so you can see four point
we essentially point the pure value into
the out into the option mounted and then
into the i/o mod for map that
essentially is our that's
composed functor method just less
general and flat map we flat map over
the outer I oh and then we essentially
based on if the option is a summer and
done we apply the function or we don't
so with that implemented we can take
that first nasty example and we can
actually write our nice floor
comprehension and the reason is is now
our i/o options are boxed by by this new
type and the only real difference is
down here at the end when we want to get
our our value back we have to call we
have to you know access the run field so
that's how we get back our i/o option we
unbox the value another quick example
how do people are familiar with the
State Mont ad ok I'll do it quickly
basically the state mounted gives you
the ability it gives you sort of the
facade of a mutable state or of mutable
state in your programming language is
actually in fact all immutable but it
sort of looks like an imperative
programming language you can say get and
set and maybe you know plus equals and
those kind of things and so when you and
it's essentially a 2-tuple and when you
fix one of the values to a type or when
you fix one of the types of the two
tuple you have a Mon add and we call
that the State Mont add and so we can do
the same thing if we have instead of i/o
wrapping option if we have my state
wrapping option we can box it in a value
and we can define the the instance of
the type class again what I've done is
left them side by side i'm not going to
react splain the implementation because
they're the same but if you can I don't
know if it's kind of hard to see but the
lighter yellow are the only differences
in the implementation are the types so
one takes in my state and one takes I oh
so that's an area where we can
generalize and that's how we get to mana
transformers so what we do is we pull
that type instructor of a single type
out into a new type definition so now
we're generalizing on that M that wraps
option ok and we haven't really said
anything about em besides the type
instructor of one type so to restrict em
to a functor naman add in the
appropriate places but i guess let me
take a step back for a second instead of
defining the type class instance the way
i have been before i'm going to find the
map and flat map methods on this case
class this is how its defined in Scala
said
I think it makes a little bit easier
kind of once you get to this point so
we're doing the exact same thing it just
looks slightly different and so the way
we restrict in this case M to be a
functor for map and mana does we take
the implicit instance of the type class
just like we did in previous examples
and then we can implement those methods
right and this looks pretty much exactly
the same we have the map method this is
the generalization you know slightly
less general than the second example not
as generals the first one I showed you
and then the flat map method looks
pretty much the same also and side by
side you can see we basically
generalized that just wherever we had
the you know the specific type before
we're dealing with the the general Mon
ad we may be working with everyone
feeling good so far all right cool how
we do it on ok so a couple examples this
comes from scholar machine and in this
case this is determining if the e-tags
of a request to match the e-tag of a
resource a quick caveat i think this
codes a little bit old it doesn't
exactly match RFC 2616 right it doesn't
deal with EE quoted strings so don't go
use this code in in production please it
won't work but the important part of the
highlighted parts the the monitor and
former part so you can see we have an
optional value an e-tag that may or may
not exist and we lift that into our
statement add which I call flow state
essentially rec refs data has state
about the request and response like
headers and their support west body and
response body and then we wrap that all
an option t so the value e is a string
out there you can see in the comments
where JP is a string and that in the
next generator we're looking for the if
match header so we're looking for the e
tags that the client has sent down and
we're wrapping and that is from scholars
edits lenses and stay and we essentially
get a state action back that returns an
optional value and optional string or
yeah an optional string we wrap that an
option t so matches is also a string and
then you can see we we do some stuff
with both those strings to figure out if
the tags match and then at the bottom
this Gator else is actually on option
tea and I'll explain how we get that
gutter else here in a bit but it sort of
got a maybe get you guys excited you can
see that we can sort of use the old
interface that we're used to with mana
transformers so another example from
some of the same code here we're talking
about determining the content type of a
request given that there is a
content-type header I guess so we're
parsing some media types and then we're
taking the first one out and again we
wrap those an option t and we get you
know we can work with those enter values
in the yield so that's a decently simple
example one last example changing pace a
little bit to sort of hammer home the
adding effects to embedded languages so
John talked about lists being non
deterministic computation right so we
don't know when this computation is
going to complete there may be more
values that they kind of keep going and
what we may want that we want to
semantic we want to add some semantics
that allow us to halt that given some
condition at some point and we can use
either t for that and you can use a
couple other things also this is an
example from a haskell article I saw so
if we walk through this list and we
print the items out you can see that
even if items were just a simple list
this code really hasn't changed right so
we haven't changed the semantics of the
code at all but what we can do now is we
have this extra ability to halt by when
we return the left so the either T is
right biased so when we return the left
we don't continue down with the
comprehension so if we reach a number
greater than 4 we stop the string fail
doesn't really matter and if it's less
than four sorry less than or equal to 4
we keep going and we don't really care
about that value that gets generated and
so what that does is it only prints 1 2
3 4 so the second we get 25 it stops so
we've added this ability to our language
our embedded language all right so
enough of examples for a bit talk a
little bit more generically about bonad
transformers so we're going to talk
about it and in this fictional instance
of with this awfully name my ma dad
right so
we have some type and so the naming
convention for mana transformers or at
least what you'll find if you're using
scholars said and what from what I've
found in Haskell though I'm not
admittedly very familiar is it's
essentially the name of the monett
instance with atty tacked on at the end
so you have option T validation tea
either T so on and so forth and what
that new type does is it boxes some
value which is that inter mounted looks
like I forgot a bracket there awesome
editor mana had wrapped with some M we
you know in our sort we the
implementation restricts that M to
actually be an instance of the Montana
type class and the convention is to call
that run in Scala said seven and six it
sometimes switches between run and value
depending on who wrote it so run if
you're using seven and at this point you
really milestone one of scales at seven
was released so everybody use it yeah
cool so the other cool thing and this is
I guess sort of the point right is we're
talking about stacking multiple of these
is that a mana transformer is also an
instance of the mount ad type class to
be a little bit more accurate but so
that allows us to do some cool things
which we'll talk about in a moment but
quickly we can show just the the actual
definition right and so we already had
map and flat map defined on option T so
that's really easy to do and point is
the point from before we point into
option and then we point into whatever
the modded wrapping our option is so if
that's IO we pointed to IO that state we
point in the state and the last sort of
cool general part about a Lana transform
as well there are a couple other things
that I've left off but for what I'm
going to talk about is that the mana
transformer the option to the either
tease have an interface that's similar
to the underlying Mont ad so option t
has a similar interface to option I've
there t similar to either and that's
actually kind of something special to
scala because we sort of have this mixed
oo FP world so that's it's one sort of
convenience at the cost of you have way
more type ceremony to do when you start
doing this stuff I guess so so here's an
example of that so on option t
we have get or else or else which are
the you know very similar except for or
else takes another option tea instead of
an option but get or else is pretty cool
you have you know em option a and you
can call Gator else and you have ma so
you're doing get or else working inside
that mounted which is nice you know if
you're doing I oh so you're doing IOU
lazily you don't actually have to
execute the IO to work in to work with
that option so with all that we kind of
get to the the most important part which
is we can go more than two levels deep
right so we've done io option but that's
really you know not all that practical
you're going to get much deeper sort of
type signatures and and the reason we
can do that is because since the
transformer is the mod add the M that
were that we're talking about is is
something we can wrap also right so we
can keep going n levels deep it doesn't
matter how deep we go so quick again
contrived example so we have this
validation T so we have an IO validation
throwable a weave wrap that in a
validation t we boxed it and then we
have this function do work which I don't
know why I left the parentheses on
that's not good anyways that returns one
of those and in this bottom line here we
wrapped it all in an option T so if we
were to map over that we would actually
be working on you know the inner int
right so we could you know add three do
it or something like that so we've got
option T wrapping validation t well but
it but it's not signed affecting because
the IO is lazy so it just returns the
action itself but I think that is what I
liked was thinking in my head yeah and
so here's an example of that from some
of we do we host some static files and
so we allow you to register you know
aliases which are usually see names I
guess sometimes they're a records we
call them see names and in this case I
am fetching data out or react so this is
actually using scollay a call so so I've
got a reference to a bucket in Rio cuz
everyone kind of familiar or know a
little bit just essentially a key value
store
in the dynamo sort of style and so you
have these buckets where you can put in
data which is I guess not really
equivalent to a database for the purpose
of the discussion fine and so we're
getting some values out of the bucket at
some key and that you know it may throw
exceptions and it may not exist and we
want to actually get work it with that
value so we wrap that all in transformer
stack and then we get that domain and we
delete some keys although actually to be
hundred percent honest I'm not totally
sure what this code does anymore but I
think it reads values and it's
essentially part of our delete code I
believe when we unregister so you can
kind of just keep on going right and
that's what you want to do is that I
showed you now like a three-level deep
you can go four levels deep you know the
first example also had you know the
writer mounted and they're also or you
may have some state or something like
that so you can kind of keep going and
and build whatever you want but one
caveat is the order in which you stack
my dad's matters and basically by
changing that order in in many cases
you're changing the semantics of your
language so an example of that is say
the difference between option T wrapping
my flow state or the state t so state
also has them on a transformer wrapping
an option and if you it's a lot easier
to see actually if you strip off the
boxing value right so I have a state
action that when applied to some initial
state may return an optional value may
return a value or I have a state action
which may or may not exist the latter is
probably not something that makes sense
in most code so the order of which the
transform we use is important you need
to remember that when you're stacking
books in a couple cases it doesn't
matter for the most part though always
consider that all right so changing
direction sort of the last major topic
at the talk tonight is the mono trans
type class so we have type classes we
can be happy with even more type classes
and the reason we have this type class
is there's there's been something
repetitive which maybe you've picked up
on in some of the examples and you know
we can we can remove that with a little
bit more abstraction and that's what
this type class does so here's some of
that repetitive code and what it is is
often we need to we need to lift some
values into our stack so maybe partially
lifted into our stack but it may not be
inside of let's say the validation mount
ad yet and we tend to have this pattern
where we map over this inner part of our
stack and point the value into a monitor
then wrap it all and we've done that a
couple times these are examples from
this is code from previous examples on
my slides and this is basically what
we've kind of done right is we have some
ma and and we want and then we want em
ma so that's where the map and the point
come in and then we wrap all that in
some transformer for for N and so we
want to abstract that away and the mono
trans type class and specifically this
lift em method will do that for you so
the type signatures kind of get a little
bit crazy here but essentially we make
an instance of the mana a trans for our
transformer so that that type
constructor there is for our mana
transformers so for option T or
validation T fixed to an exception type
or either T fixed to a left type we
define it for that and we're talking
about essentially taking some GA lifting
it into that transformer so we're gonna
lift it into the underlying ma dad wrap
it in a transformer and so for option t
I've left out some of the definition
because honestly the type lambdas will
explode you can't fit them on the slides
but this is basically invitation of that
method right so we have our we have our
map and we have our point and then we
wrap that all in an option t and scholar
machine has dismounted called res which
is similar to option but it allows you
to essentially halt the processing of a
request and respond and either an error
or a specific response code with a
response body and this is the
implementation again we have our map and
we have our point and we wrap it all up
and when we're done we get some nice
syntax extensions from chow said when we
import the monett sentence extensions
that let us use it so those are those
three examples before you can see a
they're shorter be what you're actually
doing right is going to be
on the left of the for comprehension so
you're kind of looking down the line you
can see what everything's doing there's
no noise on the side so that's really
nice and that kind of results in this so
this is preparing some things from a
response and checking the
accept-encoding of a HTTP request and
then either sort of continuing on with
the flow based on the results or or
stopping and we're using lift them here
just the clinic clean things up
beforehand i cud I put these on the
slides before they literally just went
way off you couldn't get them to fit so
that's pretty much it but so kind of in
review stacking about ads composes the
facts right so we're talking about this
one intuition form on ads that is an
embedded programming language in our
code and when we stack these ma dads are
our programming language gets more more
features or more effects that we can
perform but we can't compose any 2mon
ads M&amp;amp;N generically and that poses a
problem so what we do is we pick one
mana at em and then we say we can
compose that with any other mount a ten
right so there was no other restrictions
on am besides it was an instance of the
Monad type class so it can be any other
end that we choose not all makes sense
obviously right in the order matters but
once we've done that we can keep
wrapping these transformers we can stack
them we can build an end level deep
stack of transformers on language gets
more features and then we can use mana
add trans that type class to sort of
reduce some of the repetition that's
involved with doing some of this code
right because we don't want really noisy
code just for it to be pure we have to
write this stuff and read it on a daily
basis and then you'll have less nasty
code because you won't stair steps and
that's always awesome so thanks guys so
thanks to stack mob and for you guys for
for coming out and you know listen to me
blab for a while thanks to mark on offer
for hosting it and setting all that up
my buddy cause me and who so hopefully
you guys found the slides and the fonts
kind of nice and he set that all up for
me before they looked really awful and
to the stack mob team for having a
listen to this twice now so thanks
everybody
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>