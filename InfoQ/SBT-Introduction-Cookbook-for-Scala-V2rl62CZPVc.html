<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>SBT Introduction &amp; Cookbook for Scala | Coder Coacher - Coaching Coders</title><meta content="SBT Introduction &amp; Cookbook for Scala - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>SBT Introduction &amp; Cookbook for Scala</b></h2><h5 class="post__date">2012-01-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V2rl62CZPVc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm Josh threat I'm one of the Nerds
at typesafe that works on Scala I wrote
a book on Scala that should be released
soon
it's amazing how long it takes to
release a book it's called scale in
depth it does not cover SPT but that's
what we'll be talking about tonight so
this talk is geared to give you an
introduction to the concepts behind SBT
how it works why you have keys while you
have these initialize and tasks and that
sort of thing and the general concepts
behind how you construct a build and SBT
and then we're going to go over a few
examples of cookbook like things for how
you can do some complicated stuff in
your own build so the basics first off
in SBT you define a build by creating a
Scala file in the project directory you
import SBT and you extend the build
class inside of the build class you
define a whole bunch of projects the
projects can be local or they can be
remote SBT can actually materialize
projects from git and build them inside
of a sandbox for you and you can depend
on them and add settings to them and all
sorts of craziness I actually use this a
lot it's not a it's more a more advanced
thing but it is very handy projects are
a sequence of settings so again if we
look at this build project projects are
made up of settings a setting is a key
and initialization care right so a key
is a name an initialization is
you know like a value or something that
computes a value so we'll get into that
more but this is the essential structure
of SBT everything in SBT hinges on this
basic concepts build projects settings
okay here's an example build I might
start pointing this way yeah nice I like
that all right so here I define an
object my build I've defined one project
called Scala awesomes this project is
located if I move this in the current
directory so although my build file is
in a project slash build Scala file the
root directories consider the root of
the project that's what that dot refers
to and when I define a project there is
a settings method that I can call on
projects to add settings to the defaults
ok SBT comes out of the box the whole
bunch of default settings that should do
the right thing for a lot of open source
projects it may not do the right thing
for you or it might not have enough so
you have to add configuration and that's
what this method does what I'm doing
here is I'm setting the organization in
the name for those of us from maven but
like me organization is group ID and
name I believe is named so anyway you
can also specify version and things
there this next method call here is it
depends on method call I'm using a
little bit of simplified syntax to make
this phone to slide well so this is the
opening part of that settings call
here's the closing part just so you're
aware of how that flows anyway so I'm
depending on another project arm this is
a project this is a subtle hint that I
wrote another project that is actually
useful anyway Scala arm it's there's the
github URL right I'm defining this as
root project root project is a special
class in SBT that denotes that this the
the URI that I reference here
or the file that I reference here is has
its own build and when you pull this in
you need to pull in that other build as
well so I'm literally pulling down
things out of github compiling the
project for arm and then I am attaching
this as a dependency to Scylla awesomes
project I can even do more things like
you know append settings and change the
config that I've pulled in but that's
that's more advanced the basic is that
if you want to depend via source and SBT
it's possible the the yeah the whole
system kind of scales that way the core
of SBT is is the setting a setting is a
key and an initialization you saw
earlier in this build that I set name
and then I have this funny colon equals
method and then a value right so keys
are objects in Scala
I am referencing name from the SBT keys
object here I have imported SBT keys
that underscore name is a member of keys
I'm calling a colon equals method which
takes a key and it takes an
initialization value on the right hand
side associates them and becomes a
setting okay so an SPT all settings are
I have a key I have some sort of
assignment operator that determines
exactly how I'm going to associate an
initialization value and then on the
right hand side I have an initialization
value okay that's how everything in SBT
operates there are several types of
these there are bajillion types of keys
and initializations are up to you know
what you write so key types we have
three key types we have a setting key
it's confusing that we call these
settings and we also have setting keys
but anyway setting keys are things that
when the build loads and we resolve
dependencies and run the initialization
then that setting is done it's kind of
like defining a value in Scala right
that value is initialized and doesn't
change
unless we reload the build so settings
are things like name version
organization and they're supposed to
stay the same tasks are things that are
recomputed every time you run them in
the build so a task is something like
compile when I run compile I need to go
look at your source figure out what's
changed compile compile that code and
then you know return some results and
then there are also input keys for
example SBT has a run main input key run
main basically takes user input in the
SBT console uses that to generate a task
which then runs okay so an input key is
a task generator and I hope I'm not
going too fast with some of that stuff
it hopefully in a little bit this will
be a little bit more apparent when we
hit assignments as far as how I can
assign things I have a direct assignment
for for the name key which is a setting
I can use that colon equals and have a
value on the right hand side that
assigns to the name right so that's a
setting that will set it to name no
matter what was there previously name
will now be foo after that setting takes
place okay I can have a dependent
setting this little dash dash equal is
less than less than equals operator is a
defendant setting so what this what this
says is set organization to a value
where you take the current value of name
and run this code this function or this
function against the value that was in
name so I'm taking the existing name and
I'm adding combat J sûreté and then
the name right after that so the combat
chase write something and that's what my
organization should be right so one
thing you notice is that organization is
dependent on the value in name
so in SPT a project is made up of a
sequence of settings okay if we go back
to that build file
i define a setting here and I define a
setting here now in organization I can
depend on the the value of name and then
have an initialization that depends on
that using that less than less than
equals what SBT does is it will actually
discover that organization has a
dependency on name okay
when SBT starts up it takes all of your
sequences or all of your sequence of
settings it kind of tries to compress
them all down as much as it can okay I
can have the the name actually depend on
the previous name using the syntax so I
can say name less than less than equals
name apply right and so what that what
that does is it looks for the previously
set name in this my sequence of settings
and changes the value okay so the the
settings in the build our kind of SBT
falls through them okay and and figures
out values and does things as you make a
build it's a little bit complicated to
think about right but essentially things
flow down right we get this linear
sequence of settings SBT figures out all
our dependencies and then it can tell us
what our dependencies are so when it's
done with all this initialization SBT
can tell me that hey name depends on our
organization depends on name name
depends on something else that sort of
thing and it does so because of how this
setting works write this name down apply
alright another thing I can do when I
assign things is this library
dependencies key write library
dependencies is a sequence of libraries
to depend on so there are two special
operators I can use called plus equals
and plus plus equals where I can put a
library on the right hand side or a
sequence of libraries on the right hand
side and it will append them to the
previous value so remember how I said
you can have less than less than equals
on a previous value this code is akin to
it's uh sorry
she had this come on
so if I were to write can you guys can
you guys see what let me make this
scroll down okay so if I were to write a
setting of library dependencies of
library dependencies right so I'm
relying on the previous version of
myself
actually it's apply and then I'm adding
a new library right so let's say L was a
library what this is doing is I'm taking
I'm setting the new version the new
value of library dependencies to be
equal to the old value of library
dependencies and I'm applying this
transformation function on it okay that
transformation function takes the old
sequence and adds a new library that is
shorthand for or that is longhand of
this the plus equals operator all it's
doing is it's taking the previous value
of the setting and it's appending
something to that sequence the plus plus
equals is a pending an entire sequence
to the previous value so it's a handy
way to to append junk two sequences
there's a lot of sequences in a build
tool yeah
library dependencies happens to be a the
key is a sequence of projects right so
when I define keys I don't think I
showed this setting keys task keys input
keys keys are defined with a type and
that type is the value that's returned
when I evaluate that that setting right
so the name key has a type of string it
expects the string on the right-hand
side that it's going to compute the
library dependencies key is has a type
of a sequence of library dependencies
sequence of library dependencies right
that are the actual type in s PT is
module ID so yeah when you define a
setting you also define a type associate
with that setting when we get to the
examples in the cookbook
that will become a little bit more clear
so that that's actually the basics of
SBT everything is we define a build with
a set of projects we define a big
sequence of settings SBT falls through
and tries to collapse all these things
and figure out dependencies for us and
then when we type something into the SBT
command line it is one of these key
names so name you can inside of SBT type
name and or actually I can type show
name because I have to type show to have
it return stuff this is the xbt extras
plug-in is the setting for name right I
can I can show any of these settings if
I type show compile it's going to look
kind of stupid but it's going to compile
the project and then it's going to show
me the output of compiler of compile the
output of compile is this analysis
object of like what changed in your
source code and it doesn't have a two
string method so you're just going to
see like analysis you know at and then
some hash code because it doesn't have
anything useful to it actually no it
looks like it might yeah okay so it
wasn't useless there we go
it told us how many Scalla sources and
classes and things changed right so any
any setting we can type in the console
show and then that you know key value it
will go execute it and tell us what the
result of that value was okay SBT has
scope keys can have different values in
different scopes so this is where things
get a little bit more confusing
before I had name and I can set name you
know equals instead of SVT extras I can
set it to Josh and now if I type name I
see Josh right there are scope scope are
things like I want to take a set of
settings and I want to define how to
compile Scala code right how to compile
Scala code doesn't change whether or not
I'm building my tests whether I'm
building the actual project when they're
not I'm building my unit tests or
integration tests unit tests
whatever it's the same building Scala
code is the same for all of those it's
just a matter of getting the right
settings into that you know sequence of
tasks that run so an SPT we have
something called scope where we can take
a series of settings and move them into
a scope so in SPT there is a definition
for how you compile Scala code we take
that that sequence of settings and we
move it into a compile scope and that's
how we compile your main projects we
take that sequence of settings we move
it into a test scope the exact same
sequence and now it can build your test
code so the way that we reference this
in SBT is there's a syntax it's in so we
would call sources in compile refer to
the sources sequence of files that will
get compiled when you compile the main
project sources and test are the
sequence of sources that are compiled
for your unit tests it's so scope is
essentially a way of scoping these keys
so they refer to a particular you know
flow and you can define different flows
scope should be reserved for big flows
right like if I'm compiling Scala is an
excellent example there's a lot of
different settings and things for to
configure Scala you need to do your
Scalla c options you need to pick a
bunch of sources you might have compiler
plugins you have library dependencies
there's a lot of settings that go into
that so you can define in your build
once one sequence of settings and reuse
it for every every time you need to
compile Scala code if ok the other thing
is that configurations can extend from
other configurations in a sort of Loa so
the test config I believe extends from
the compiler config so if I define a
setting that relies on something in the
test configuration and that doesn't
exist it will look for something in the
compiler configuration before giving up
so that's what extends does it will go
down that hierarchy in the config
looking for keys yeah
so right keys can also be scoped by a
task so this is a very interesting
addition in SBT the one that I know
that's specifically done with this SBT
will generate a jar file for your
sources will generate a jar file for
your classes the binary and it will
generate a jar file for your Scala Docs
right and those are those are the
package command can do that there is a
mappings key a mappings key in in SBT is
a sequence of file to string tuples
right so mappings is essentially I have
a set of files and I have a set of
locations that I want them to exist in
in the resulting jar file and I want to
reuse that key every time I need to do
something relating to mappings right or
where I map things to go into a jar so
to do that SBT actually can scope things
by a task as well package bin is a task
that is the task that will package up
your jar and all your classes so
mappings in compile comma package bin
refers to all of the class files that
will go into your jar and the resulting
location in your jar not just your class
files it's also your resources right
it's everything that gets packaged in
your deployment jar mappings in compile
package dock refers to all of the HTML
files and CSS files and things that end
up in your Java doc or sorry Scala doc
jar which I believe is called Java doc
because mavens fun they don't want us to
rename it if I want to look at these
things in SBT if I type mappings it's
going to tell me that I don't have
anything I don't actually have any
mappings but I have something defined
for compiled mappings
actually hold on yeah I don't have
anything defined for compile mappings
either because it's defined specifically
for package bin so if I show my mappings
for package bin it's going to resolve
the internet and then build my code and
then it's kind of hard to see here but
these are tuples this is a class file
the late build project class file and
then where it's supposed to be installed
so here's a decent example here that's
hard to see template build tap class
goes under template template build tap
class that's the the key value pairings
for mappings and you can see how I
reference it inside of the SBT console
is the config comes first
then a colon then the key and then the
task it's scoped by so if I run this for
package source we'll see a different set
of files it's a lot less because there's
only like two source files in this
package right so so scope is possibly
that one the most confusing thing in SBT
applying you know values to keys once
you get the feel of it is really easy
scope is where the complication comes in
because when I'm trying to figure out
how to add something into like the
resulting jar file I need to set it in
the right scope so it's not just enough
to add it to the mappings key I have to
add it to the mappings in compile
package bin key right so how do I know
what which which key to use an SPT there
is an inspect command anything I do in
SBT I can inspect the inspect command
tells me the compiled task returns the
type SBT Inc analysis that's the value
that it returns when you run it it
provides it has a description it tells
you where it's defined right so who who
provides this this task and tells you
what it depends on so it only has two
dependencies compiler inputs is a key
that actually aggregates a whole bunch
of information about compiling so that's
not just your sources it's also your
flags and that sort of thing and then
stream streams are your that's your
logging in SBT anyway if I if I need to
deconstruct what settings I need to
configure I can use inspect to look at
where everything is yeah streams uh okay
so SBT whenever you run a task any sort
of task SBT will log everything that
happens and it won't necessarily show it
to you
like when I brand that you know it
showed show the result when I ran
package it showed the result of mappings
but it didn't actually show me the
output of the Scalla C compiler so in
the target directory of SBT there's a
streams directory that has all of your
logs the streams class or the streams
key and SBT is a way to access the
logger so inside of a task if I ever
need to access logging I can depend on
streams and I will get an instance of it
and I can make use of it we'll cover
that later later I think right the other
interesting thing about inspect is I get
my reverse dependencies so these are
things that depend on me so if you want
to know who's using a key to know if
it's safe to change it you can check
your reverse dependencies and it will
show you for example compile products
depends on compile so compile products
is the thing that it's sorry discovered
main classes is the thing that SBT uses
when it sends you a prompt of like when
you type run and it asks you what main
class you would like to run discovered
main classes is the key that computes
that and it makes use of compile so if
you want to inspect what's happening in
SBT there's an inspector command to dig
into all these keys and their
dependencies yeah so that is scope we're
going to talk a little bit about
initialization so
a setting key has a type associated with
it right a name is associated with
strengths names can only take instances
of strengths there is a class called
initialize initialize is a it kind of
wraps a function of no arguments that
generates a T okay
task keys take and initialize of a task
so what SBT does during startup is it
takes all of your settings it takes all
of these initializes it looks at all the
dependencies it calculates this huge
dependency graph from these initialize
and it will actually grab values for
settings remember we said they're
calculated once on when the build is
loaded we actually get the raw T and
place it into the setting for these task
keys we generate a task the task is a
function that will be computed later so
yes initialize is a function that
generates a function that would be run
later so deferred work any key reference
can be converted directly into an
initialize so if I want to set the name
to the value in organization I create a
setting like this so keys automatically
become initialize initialize is an
applicative functor will go into those a
little bit but if you notice in this
code we've been showing there's an apply
method on here apply is from initialize
apply allows you to take and initialize
of a certain type and transform it using
a function so name becomes an initialize
of string right so I have something that
will give me a string and I am
transforming it by a function into
something else you can think of
initialize as a pseudo collection of one
thing right and I have all of my apply
map those sort of methods on it what's
weird is that initialize tasks of T it
is very inconvenient to have to have to
nest inside two tasks
so SBT has a way for you to map directly
on
tea rather than having to know that
you're dealing with tasks and not just
initialize of tea right so SBT uses a
concept called applicative functors to
allow you to access T or initialize or
task T the T inside of initialize tasks
T similarly in the build to construct
these initialize values that get applied
to settings so here's a little
digression we're going to cover a little
bit a very base level of applicative
functors for you so imagine that I have
a method called get connection it looks
very similar to what's on driver manager
and imagine I have a bunch of options
that I've got from user input that may
or may not be there so I have an option
of string for URL user and password is
an array of character so what I would
like to do is I'd like to make use of
URL user and password to create a
connection right however each one of
those is inside of an option and gate
connection takes the raw type so it
doesn't take an option of string it
takes a string for user right I need to
get inside of there so one option I can
that's kind of a pun I can use is I can
use a for expression and I can rip the
values out of URL user and password
right so the for expression will pull
each value out and then I yield to get
connection of those values and I will
have an option of connection so using
for expressions in Scala is a way to
pool those values out of the container
right
that's what four expressions are all
about the downside is that this is not
applicable and there's a reason why we
care about applicative for expressions
are sequential okay I have to pull the
value out of URL first if it exists
right then I'll put the value out of
user if that exists that I'll pull the
value out of password but at at at the
top level I don't know
until I've pulled the value out of URL
if I will run any of the rest of this
function right so if I were to inspect
dependencies of the resulting option
right if let's say I had something that
calculated dependencies I wouldn't
actually know that user and password are
dependencies of the resulting connection
because that function these functions
that run here underneath only happen
when I try to extract from URL so it's
unsafe to try to discover the
dependencies I actually have to run the
code because of the way that those
methods are defined essentially a four
expression in Scala this code this four
expression turns into this code we're
calling flat map on an option and we
have a function that takes the location
of the option and performs some value
right that's all that this guy knows he
he has no way of knowing that there are
other dependencies involved here right
he just has a function that returns an
option and he's going to flatten that
sucker out inside of there I have a user
flat map you know that doesn't actually
this this user flat map never gets
called if URL was was available so flat
map is not ideal for a build tool right
when we're talking about initialized
values if I'm talking about making a
dependency on compiling my tests and
compiling my my source code actually a
better example is if it's running my
tests and running my integration test
and I want to do those two operations in
parallel right flat map will not let me
do that because I have to extract the
results of running the test first before
I can run the function that will extract
the results of running my you know
integration tests right so I can't do
the two things in parallel they have to
be sequential you have to get the result
of the one before you can run the other
so for expressions flat map these are
sequential type operations so what we'd
rather do is we would rather use what's
called the
like a functor concept so that we can
get this we can figure out all the
dependencies initially and we can pull
their values in parallel right that's
that's a key to SBT is that when it
evaluates tasks that we'll try to do
it'll try to paralyze everything it can
so we need a dependency graph we can't
have a sequential thing of things to run
so what we do is we take the get
connection method and we curry it if
you're familiar with Karine we take we
take a function of many arguments and
instead of instead of taking in many
arguments we take one so we take in the
first string and we return a function
that will take in the next argument and
return a function that takes in the
third argument and finally returns the
connection so we're defining a function
that returns a function that returns a
function that returns a function however
many arguments we have that's how many
functions we end up returning and that's
kering in Scala there's a very easy way
to do that you take whatever method you
have use this little underscore operator
to turn it to turn a method into a
function and then you call the curried
method on the function and it will
automatically give you this you know
function that returns a function
transfer function etc okay so we now
have this this crazy big function now I
have I have my curried connection right
it it does exactly what I want i define
the first part of my transformation as
taking the URL and mapping this curried
function so what this does is I take a
function that takes a string and returns
this big old function and I map it
against the URL so now I've passed in
the first value to that curried function
and I get back the rest and I end up
with an option of the rest of the
function right so I have an option of a
function so the the continuation of the
get connection is inside of this option
what's handy here
is because I called map here
this this option can remember that it
was created from the first URL object
right I can remember my dependency now I
would love to have a way to take this
option of a function and to take to take
my user which was a string and take the
string in the user option and put it in
here and do it in such a way that I can
remember that that string came from the
user option right the way that I do that
is through an applicative functor so an
applicative functor is a very simple
interface I have a holder of some type
and I want and I want an apply method on
applicative right so this is the
application it will take a value of the
holder it will take a function that's
inside of the holder and it will apply
that function to this one or turn me a
new holder and it can do it in such a
way that I can remember where I came
from and keep track of my dependencies
right I can paralyze the computation of
a and well yeah of a and B essentially
it later alright so if I define this
applicative and I make use of it I'm
simplifying here I'm pretending that
I've implicitly enriched option with an
applicative method that just calls
applicative supply okay so that's that's
a simplification here but now I can say
I can take this first option of the
continuation I can call user applicative
first now since I have I have user and I
have first this resulting option can
remember that it came not only from URL
because up here we're using map it can
remember that it came from user right
it's not hidden at runtime this this all
happens at during the initialization I'd
never have to extract any of these
options to at to call this applicative
method I can remember my dependencies as
I change
through okay there is no point where we
have to look at the result of one of
these transformation functions we can
just make use of them directly yeah so
we do the same thing with password and
now we have we have the exact same
result so what's the big deal right they
kind of look the same password
applicative user applicative URL map get
curry or we use flat maps and maps well
the big deal is the fact again that
these are functions that I need to pull
the value out of URL to figure out what
the rest of the dependencies are I can't
do it I can't paralyze the computation
an SVG that's that's critical so that is
why we use this applicative style and
that's why you're going to see like
apply and some interesting things in SBT
right so flat map is runtime dependency
yeah so here's a fun one inside a flat
map right I can write and is and I can
return one value of an option or another
depending on this is prod and there's no
way for me to know what the dependency
for the connection initialize is without
knowing what is products right if I run
that function I get if I run that
function with is prod as true or as yeah
this should be a boolean sorry if is is
prod is true I'm going to get back one
version of this dependency tree where it
relies on prod URL and if it's false I
get a different one that relies on dev
URL and the only way that I could know
what all the dependencies are ahead of
time is to exhaustively send every
potential value of is prod into the
function get all the results and look at
all the potential dependencies right so
SBT supports flat map on initialize we
do support it okay you can use for
expressions however
you can't parallel eyes with them we
can't figure out the dependencies ahead
of time we can't do dependency analysis
and warn you if you have any sort of
missing that missing initialized fields
we can't parallelize your build it's not
a good idea to use flat map in SBT
unless you have no choice there are some
cases where you absolutely have to if
you run into one of those cases please
email me because I'm really interested
to know what that is
I haven't market seen one and I have not
seen any okay so SBT has an applicative
DSL now I showed before this this simple
you know password user URL applicative
applicative map that's all well and good
but there's a lot of magic behind the
scenes that make it somewhat hard to
make use of in SBT we have it right on
two poles okay from any tuple I can put
all my keys into a tuple and call apply
and then give it a function and this is
an applicative functor it will take all
of these keys it will know what those
keys are keep track of the dependencies
and create me a new initialize where it
runs this method against the values
inside of those initialized and creates
a new initialize so this is the that the
applicant of DSL for SBT again you
really want to use this all the time
because you will get parallelized built
SBT has actually really good ability to
paralyze how it computes things now
here's the the annoying part is if we
have initialized of tasks write apply
will work against initialize T's map
works against initialized tasks of T's
so if I want a task that will generate a
connection instead of generating one at
build load I have to use map instead
this is a common point of confusion in
SBT if I'm dealing with tasks and I have
dependencies I use map if I'm dealing
with settings or setting keys I use
apply okay
it's frustrating but there's a there's
some type inference issues where if we
didn't do it this way you would have to
apply a lot of type parameters and
that's not
nobody likes type parameters so here's
here's a cookbook we're going to cover a
little bit of features and how you do
things within SBT and hopefully this
will clarify some of the points I made
earlier
all right so if I want to test in SBT so
I take my awesomes project everything
has to have a Z in it by the way when
you use SBT just so you know has to end
in a Z library dependencies I can I can
throw this library dependencies key plus
equals and then put a module right this
is the module ID syntax and SBT it is it
is a maven dependency this is the group
this is the name and this is the version
and then this percentage here defines
the config where that dependency will be
made available right so there is a
correlation between configurations and
library dependencies and it's somewhat
loose so this test means when I run
tests compile that library will be
available it will not be available when
I run compile compile right for my
production code it will not be available
when I run integration compile unless
integration extends from tests ok so
that whole config extends thing is is
somewhat important here and that's what
this last percentage equals if you don't
see a percentage test everything
defaults to being available at compile
time so by default that that would be
compiled the last thing is there are two
there are two little squiggles there
percentage signs SBT has the ability to
cross deploy against multiple scholar
versions it added this when Scala had
binary incompatible releases for every
version not just major so this was a way
to get around that so if you wanted to
release
for Scylla 282 and 2.81 you had to
release in this fashion nowadays if you
want to release 4 - 8 - and 291 that's
what you use this for as well because
Scala has binary compatible in - 9
x-series you can make use of things
compiled into 9.0 into 9.1 so it gets a
little more confusing to do that to make
things work now that should be fixed
shortly but that's that's what the
little % % is yes provided provided and
a little cools yes ok so provided is
similar to I'm trying to remember I
think it's the same in maven provided
means I need you to download this jar I
need this jar available to build but
where I'm deploying that jar will be
provided so if somebody makes use of me
do not download this jar so it's
actually a handy way if you want to have
support so let's say I'm making a new
testing library and I like Scala tests
so I want to have Scala test support in
my new testing library I can depend on
Scala tests with a provided tag here and
then when I deploy my code people can
make use of my library without needing
to download Scala tests but if they
explicitly declare it then they can make
use of all that Scala test code I have
in the jar so it's it's a handy way to
have like extensions inside of your jar
that people can make use of if they have
the right dependencies granted if they
try to instantiate that class and they
don't have Scala test it'll blow up so
be warned but that's what provided means
okay that should not bhai be highlight
anymore if I want to define functional
tests what I can do is they're going to
find a new configuration called fun
because functional tests are fun and I
can extend the test configuration right
so I will get all of my testing
libraries in my functional testing
settings and then here's the special
syntax right here in config fun test
which is
same value here as that fun config grab
the SBT defaults test settings if you've
never seen this in Scala before this is
how you take a sequence and use it in a
variable arguments method it's just a
little bit of sugar that you have to
memorize right so in config fun test
this takes all my test settings and
moves them into the fun test config so
now I will have fun : test that I can
call inside of SBT and it will run
everything it will compile everything in
fun : sources and run them okay I can
depend on specs and put it in the fun
configuration and it will only be used
for my functional tests so I can use
Scala tests for unit tests and specs for
functional tests that really should be
skylit check because I like Scala check
for functional tests anyway right so
library dependencies plus equal specs
source directory in fun tests here is
where I'm setting a different source
directory in fun tests I'm making use of
the default source directory and need a
functional to it right so what that will
do is you know how there's a source main
Scala that by default has all of your
Scala source files in maven well it's
also the true and SBT and there's a
source test Java that has all your unit
testing by doing this I've changed the
functional testing code to be in source
functional Scala because I've moved the
source directory for functional tests
and that's what this in does it changes
the scope of that setting that I'm
applying and I'm making use of a setting
in a different scope so yeah
so the one thing because you're defining
a new context that extension test then
automatically shouldn't want to have all
of the test settings so why they're
being react well yeah so the there's a
difference they if I extend from test
and I try to make use of a setting and I
can't find it it will look in test
settings right but the setting doesn't
exist so the setting doesn't exist but
if I look for the setting I will look in
its parent if I can't find it so in the
console if I were to write fun : test
just from doing this that that setting
doesn't exist right if I have another
setting that depends on fun : test it
can substitute test : test okay so that
that's that's the difference there is
you actually have to if you want the
task to be available at runtime they
have to be you have to move them and
copy them right they have to be exist
but if this default that test settings
has dependencies on things that
dependencies on keys so if it turns like
let's say sources is not part of default
test settings it's it's defined in
another default when I go to look up fun
: sources it will look up the task it
won't find the task so it will look up
the task and test : sources right and
tests : sources happens to depend on
fubar that sort of thing so you have to
be careful but the way that SBT defines
these defaults they're they're pretty
complete you know so if you if you move
default on test settings you will get
all of them or anyway so I hope I
answered that too good right all right
so if I let's say I want to generate
some code and I want it to be included
in compilation right so code generation
is fun there's always times where you
have to generate a little bit of code in
it's handy in this case I define a
template of objects properties def name
and the name so let's say I want a Scala
properties object
I can put you know values into at Build
time and then rely on them in my build
to make use of them instead of using the
properties file I want it statically
enforced so I create my template I
create a generate properties file method
this is just Scala code okay I'm making
use of some SBT api's but this is just a
scala method I take I create a file
object that takes the directory and but
underneath the directory will create a
build properties dot scala file ok the
directory is passed in here i write the
file to the file i write the string
where i replace all instances of that
name with the name that i'm passed in ok
so if i wanted to have a bunch of other
things in the property i'd have to have
a bunch of other methods that might
maybe I have a map of things that I
write anyway the point is I'm generating
a Scala file and I'm using i/o dot write
to write it and I return a sequence of
files here generate properties file is
going to return that sequence ok so now
in my project in the configuration of
compile write I add a source generator a
source generator is a key in Scala of
something that will it's it's a it's a
task that generates a sequence of files
ok so what I'm doing is I'm calling plus
equals and adding a new sequence of
files to the existing sequence of files
so source generators by SBT are
automatically run before compiled before
Scala compilation so if I if I need to
do any sort of cogeneration I can attach
a new source generator by taking my
dependencies here using my applicative
map call because this is a task and
passing the values of those settings
into this method ok
so this is all just Scala code right now
if I wanted to change the source
generators used for testing let's say I
want to automatically generate test
files the only thing I would need to
change here is two source generators in
test plus equals okay and that would
generate test source files that only are
used in test situations okay so that's
that's kind of a advanced hook that's
automatically provided for us from SBT
we didn't have to write any of that any
of the magic to make sure that the
source is generated and added to the
sources list SBT will use the source
generators appropriately yes oh right so
that's that's old-school you you
actually only need plus equals here you
don't need the less sorry in SVT zero
ten we had less plus equals which was
the exact same thing as plus equals
except one work on settings and work on
tasks now you only need plus equals so
just just pretend that that's plus
equals sorry okay
yeah and so source generators I'm adding
a task that will generate a properties
file right this is a function that takes
in some inputs and generates the
sequence of files this here is an
initialize all the sequence of files and
I'm adding that sequence of files to
there that task sequence of files to the
source generators tasks okay it's a
little I should have written out more
types for you but you know it's Scala
anyway okay I can define setting chains
so let's say I wanted to find coverage
tests I want my coverage tests to be
different than my my tests I want that
that entire flow to be separate I can
define a new config for coverage but I
can have it depend on all of the sources
that are in my regular old tests so I
automatically make use of all my unit
tests in my coverage tests but if I
needed something else if I needed some
more sources or some other different
settings I can append
to that setting right so the first thing
I have to do is make sure that my
sources and coverage rely on the sources
and tests and then I can append values
to it afterwards and so this will take
the final value of the sources and test
and then add stuff so it's it's a really
handy way to actually where I make use
of this I have a native packager plugin
right so I want to define a way to
deploy software on Linux so I define a
base set of things like put this shell
script in the user bin file there it
user bin directory
put these jar files under user share
Java or wherever the heck it is right
and I defined those in mappings in Linux
right then I have specific extensions
for a boon to and for debian where I can
add like a DB and change log file I can
add like a rpm file for Red Hat that
sort of thing and it makes use of the
defaults for Linux and then I have
extensions for the specific configs that
I'm using later right it's a very very
slick trick to have some sort of base
config that people can extend and add to
alright now let's say I need to find a
new task in SBT this is a lot of people
want to make use of this one thing I'll
say I'm covering this late in the talk
because normally you don't need to
generate new tasks if you need to
generate new tasks you might be doing
something brand-new and SBT and it might
be plug-in orthey ok so first thing I
have to do is define a key to define a
key there's this task key objects with
an apply method and I give it a return
type the return type for this task is
going to be unit and I give it the key a
name and I give it a description if I
were to actually use name I'm going to
get an exception at runtime SPT is going
to tell me I already know of something
called name and it doesn't return unit
so you can't construct this because
we're going to end up with type issues
at runtime right but I can call it so
something like perhaps fou convention is
if I define a new key the name here
which is the one used in the console
should be the same okay so when I look
at the console and I type compile which
just compiled everything that is the
name of a task key and I if I go into
SBT dot keys file I will find a
configuration that looks like this
and it's called compile right so I can
reference these directly all right so
after I defined my key I defined a
method that will execute my task and has
my dependencies now someone asked about
streams most tasks should take in this
value task streams that has a set of
logs you're going to make use of okay
SBT defines a setting that just gives
you access to stuff they have there's a
bunch of them and SBT if I want to know
what SBT version I'm using I can depend
on the SBT version key if I want the log
files I depend on what's called streams
and then I can write to any log file I
want yeah so if I'm defining a task
where I want to log I depend on this
task streams so that's what do foo here
is and I'm also taking in a name then I
wire my dependencies with my function to
create and initialize and I put the
whole thing into a setting okay so here
I'm taking name and streams the keys I'm
using that applicative syntax to take
that to then push them into the method
and this will generate a unit and
initialize of unit will initialize of
task of unit which I then apply to the
foo key okay so this is how I'm defining
tasks this right here is how everything
in SBT is wired if you're going to look
at SBT defaults that's how it all works
all right so let's say I want to create
a zip distribution so I have a project
and I want to zip up a whole bunch of
stuff to send to people and they can
just you know open it up and run
something I'm going to make use of the
Pinsky first thing I'm going to do is
create a config for it from so that I
have a new namespace
the next thing I'm going to do is create
a method called make zip dist this zip
disks takes and mappings which is a
sequence of file to string pairs right
this is that hole mappings concept I
have a file and I have a location in the
zip that that file should reside and
then I take a directory where the zip
should be be generated so first thing I
do if the directory doesn't exist I make
it right next thing I create a new file
object for the location so this is going
to be called my products release latest
and then I use SBT zyo class and calls
zip and I pass in mappings and the
resulting zip file and it will zip
everything up for me and then I return
the zip file so now in in the disk
config configuration I define a set of
settings I set my mappings to sequence
empty first so I have an empty set of
mappings I set my mappings in package
bin compile sorry I take the package bin
compile result so package bin is a task
that packages up my jar and the result
of that task is a file which I then map
to the main jar file right so I'm taking
I'm taking the the task that generates
the file running the task getting the
resulting file creating a tuple of that
file to the location on disk right and
then I'm appending that to my mappings
so it's a little bit a little bit
complicated but that's essentially what
this line is doing is I'm appending one
mapping I'm appending this jars should
be called main dot jar I do the same
thing with my Doc's right and I call
them Doc's jar and then finally I I
define my package bin in the dist
configuration to take those mapping
to take the base directory the base
directory is the the directory of your
projects and then I call make Zip disk
the function so it's going to get those
mappings of sequence of files from this
setting and apply it there okay so in
SBT the the confusing parts right are
the fact that you're dealing inside of
these initialize tasks the fact that
when I write a method I have to know
what all these existing keys are in
there types so when you use SBT I
recommend writing helper methods for
everything you want to do so I know that
I want to do foo I'm going to write a
method that takes in some inputs and
does foo then I have to look through I
have to run I have to look through keys
that scale and look for the appropriate
keys I figure out how to map the
settings in the build into my method to
make the thing run right then I can
inspect those settings and figure out
who has configured them whether or not
they're there and set them if they're
not set and finally there's a thing
called console projects console project
will dump you into a scholar repple that
is live against your build file so that
you can run all the methods you've
defined in your build file you can call
all your keys and interact with SBT
calling methods directly against the
core of it and the most important thing
is if you need help with SBT you should
ask it takes a while to get into it
because there are a lot of default keys
a lot of default flows happen in an SPT
and if you want to do something odds are
that flow that you need to accomplish
already has a hook and you just need to
find the right place to put something so
the simple build tool at Google Groups
comm has a lot of people who are really
into this build tool and can help you
find the right location I may not be one
of them I'm usually one of the ones
asking but after a while you learn
you learn where things are and to be
honest once you learn this build tool
you can take your build and turn it into
a plugin that others can use in almost
zero time so it's it's amazing how
flexible it is and how efficient your
code becomes for your build it does take
a little while to get into figuring out
what all this means how to use it that
sort of thing so I will I mean obviously
from this talk you can see that it's the
code is somewhat terse and there's a lot
of meat behind it there's not a lot of
code behind it it's a very very simple
system once you understand the
fundamental concepts but those concepts
are not the easiest to grasp initially
so if you're if you're interested in SPT
you know feel free to go the website you
know email me ask we'll help you out
with whatever whatever questions you
have it's a really great build tool once
you get into it so I encourage you to
try it out</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>