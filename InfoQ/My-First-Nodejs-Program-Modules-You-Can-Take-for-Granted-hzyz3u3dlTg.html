<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>My First Node.js Program &amp; Modules You Can Take for Granted | Coder Coacher - Coaching Coders</title><meta content="My First Node.js Program &amp; Modules You Can Take for Granted - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>My First Node.js Program &amp; Modules You Can Take for Granted</b></h2><h5 class="post__date">2012-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hzyz3u3dlTg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I also contribute a little bit to court
here and there when I get time I also
run note comp which is a conference
about nodejs so happen in July and
tickets should be on sale towards the
end the month and yeah you can ask me
questions about that later if you like
but let's get started this is a talk
about the first note program that I ever
wrote and actually how that changed over
time and this talk is really good at
showing you where nodes priorities are
and how we think about how to solve a
lot of programming problems so let's get
started so in December of 2009 this guy
young learn heart whose great friend of
mine ran a conference he brenna
comorants called JS conf you which is
the european version by european he
means berlin version of jazz calm and
that was a ryan villa gave his first
kind of public talk about nodejs and
where most people first heard about it's
where I first heard about it and he had
already posted that video and I was
really interested and Young said on
Twitter has anybody written in actually
to be proxying note yet I kind of want
to play with this idea that I don't want
to write the proxy from scratch and I've
written this thing in Python called
windmill I'd spent about three years on
it it's a competitor to selenium that
didn't win it's why you haven't heard
about it but it but it was a it was very
very smart
it had a proxy inside of it that would
actually trick the browser into thinking
that I never left the same domain it
would return forwards to content at the
same domain and figure out where it
should actually be proxying was crazy
it's been a lot of time on it and
because we wanted our tests to run fast
I spent most of my time optimizing it by
the time that I was done it was over ten
thousand lines of code it used better
HTTP client in addition to that I had a
bunch of fixes on top of it to make it
thread safe I had thread two so that we
could maybe try to kill Python reliably
and we even had a special socket server
so that we could do SSL
fanciness so I knew a little bit about
running an HP proxy and I figured this
would be a good thing to try out this
node.js thing I already know JavaScript
I was working in Mozilla at the time so
it's kind of a requirement and so two
hours later I had some code and this is
what in December of 2009 an HTTP proxy
looked like a node the first half of
this slide is pretty much just parsing
URLs because we don't have a neural
parser yet nobody's written one so
that's what this code is about it's a
terrible or a parser but it works then
we instantiate a client object which is
an HTP client object we pull off the
headers we add a host header to it and
then we we call a method on that client
object for the HTTP method that's why we
do this client request on that side to
lower case so that we can match the
output method from the implemented and
then we give it the path in the headers
then we listen for these body events to
give us chunks and then we call this
send body thing and then we give a
function to this finish call this is not
an event this is a special call that
takes a callback for finishing and we
also have to do a lot of stuff around
encoding in the early days node had to
deal with stringing coding up not as
much as you have to in other platforms
which is to say a lot and we we had this
way to do the way that you did binary
and node was actually through these
binary encoded strings so you had to be
really careful about when you use them
when you didn't use them in the really
early days back then there were actually
bugs where the data wouldn't you Tate if
you changed it to a binary encoded
string and even if that was the input if
the input was asking you for any binary
so to string and then run it out that
way it would be different
it was very bad bug so that's what we
have this very fancy encoding handling
here then we listen for complete and we
call the Finnish guy and then we're kind
of done that's not a lot of code that's
significant in this code than my Python
proxy it can't possibly be faster
because this isn't include all the crazy
network optimization see that I know
that you can do I know that this returns
the requests iteratively which is one of
the bigger optimizations that I
but this is literally about a third to a
half of the amount of code that took
just to do iterative responses in Python
this isn't you know keeping a nice pool
around of connections so I assigned to
play around and test it a little bit and
it turns out that it was way faster than
my Python proxy likely by several orders
of magnitude and it was it also used way
less resources I mean way less memory
room in the CPU if I left it there on
for days at a time
it wouldn't eat up my CPU randomly like
my Python proxy did and it was much
easier to understand and reason about so
this was about the time that I decided
that I wasn't gonna write Python anymore
I love the Python it's one of the
biggest advocates of Python I love the
community and I loved everything about
it but my problems the problems that I
was dealing with Python was not
interested in solving and we're node
already was showed that they were more
interested in that so I made a decision
that I just wasn't gonna write Python
anymore which was problematic because it
was kind of employed to write Python so
had some discussions but it worked out
and in February of 2010 we had a new
release of node and all of a sudden this
proxy starts to look like this so hey we
have an aroma rule isn't that nice
that's way less code now that's like a
half a slide done we we also have a
request method on the client which is
much easier because now I can just pass
a string as the method rather than
calling a method method we that really
bad encoding bug in binary encoded
strings is gone
so we don't have a lot of the really
really fancy handling around encoding we
can just set the encoding as binary and
use binary encoded strings everywhere
also the body event is gone and the
finished call is also gone and you have
a more enough IDE unified interface here
around the client request object and the
HTTP response object so if you see here
like there's they both have the same
data event and they
and they all have right methods and they
all have closed methods so things are
just getting a little bit more unified
around how you deal with things that
emit enclosed data okay one more thing
that I want to cover in this slide the
string encoding although we fix this
binary encoding did that binary encoding
problems this still sucks like this just
way of dealing with strings is really
bad because what would happen is we
would get data off of a socket we would
convert it into a string which is like
this binary encoded string and then we
would end up just writing it back out to
another socket half of the time or
running it to a file descriptor or
something that we actually need to take
it and then copy it again so and then
the the two string conversion was big
enough much less like dealing with that
also at the time v8 had a max heap size
of about a gig so once you've hit the
heap limit all bets are off
it just spends up to 100% CPU and it was
really terrible
so after this release in the next
release this kind of goes away we
deprecated this binary encoding of
strings and we moved to what are called
buffer objects and so buffer objects are
an object in JavaScript that is
basically a pointer to a static
allocation of memory that's outside of
via teep so we don't convert to string
anymore when things come off of the
network and come off of file descriptors
we stick them into this allotment in
memory that's not in via teep and then
we pass around a reference to that and
it's much faster it guys have a lot of
heat problems and we don't suffer extra
copies when we're just taking things
from one file descriptor to another okay
so July of 2010
Ryan had Brian Doyle the creative node
I've been talking a lot about um
unifying the interface around file
descriptors and sockets and even system
processes there are all these things
that we deal with that sort of
iteratively emit data and you can write
data to them or sometimes you can so you
have these readable objects and these
writable objects we have them all over a
node why don't we when we unify the API
around them so that you can just write
this function like it should probably
look like this and there's just this
function and it can take to to these
objects and just send them so in this
release of node I put in
code into cysts this was a module where
we just put stuff that we didn't really
have a good place for and and this is
this method takes to stream object it
takes a readable stream and then a
writable stream and it takes all the
data from one and sends it to another
when one finishes it calls end on the
other object so that removed all of the
code in this proxy that had to deal with
listening for write events and calling
it all that's gone now because we have
this much more unified interface awesome
stuff Wow
we're getting rid of so much code that
we can do like comma first and we just
have room and fits on a slide that's
beautiful so one of the nice things that
you see at the top here is that we don't
have that create client call anymore in
this release of node we actually got rid
of the create client call and just
switch right to getting a request
because it was kind of silly you would
create this client object and then you
would create another object off of that
for the client request which is just you
know that's not do you care about why
don't we just get you right to that so
this gets smaller here and also we
deprecated the system module it turns
out that if we can't think of a good
place for it there doesn't belong in
note or we have enough nowhere to play
it so we put a pipe method it's now a
couple pipe instead of pump on all
readable streams so every readable
stream and node has this method on it
called a pipe and you pass in there
write a blog come into it much easier
this is all getting very very small so
then in July 2001 another release of
node came out and I got in one line in
the core release which is probably like
the best line ever in node all that line
does is at the end of the pipe calls it
emits an event on the writable stream
called pipe and it passes in the
readable argument so now when streams
are piped to each other each one knows
about its input and output because one
of them the method is actually on the
readable stream object so it can
intercept and and figure out what the
writable argument is and the other one
gets an event so we know
it's readable argument was so now we can
start to do really fancy things about
the input and output of streams they
don't have to be opaque they can
actually mean something so in my library
request which is this high level HTTP
library client that everybody's using I
just added in proximate so now if you
create a request object to an Earl and
you pipe in a server request object and
you pipe it to a response object or you
can just do one of them or the other
actually it'll inspect the inputs and
outputs and actually call the right
methods and take the headers and the
method and all the other information
from the input and output and do what
you want to do with it so now the proxy
is down to three lines and that may seem
unfair comparing it to the old Python
proxy but remember I was actually using
a third-party HTTP client in that
library as well so then in November of
2011 we added one more thing into node
that was the last thing that's affected
this code all the way till today it's
that pipe returns the destination stream
so when you pass in a writable stream to
pipe it will return that same writable
stream at the end which means that now
this one this proxy is actually one line
so we went from two slides down to
essentially one line in a couple years I
mean it did take a while but this is
these are the problems that we're
focused on like we're not focused on
using all of your cores to do Fibonacci
we really don't care like that's not a
thing that we worry about what we worry
about is how do you write better Network
programs how do you remove boilerplate
how do you make things more predictable
and simpler to read and that's what
we're doing so that's the end of that
talk on the other talk now cuz my talks
are very short all right this is the
module to earth this is what was
actually on the program so this is what
you paid for all right
that's me again and what am I gonna talk
about third-party modules so most I know
that I just spend a lot of time talk
but advances that we make in core but a
lot of the value that vast majority of
the value really in node is being
created by the community and third-party
modules so it's more important to know
about the really good modules the
modules that you can take for granted
not necessarily the really opinion in
modules or the ones that you know like
are gonna get replaced in a month with
something better or you know are gonna
get abandoned because Tim Cassell wrote
them like this is just this is like I'm
just gonna talk about the modules that
are solid enough now that you can just
take them for granted okay so yeah NPM
everybody uses NPM it is the best
package manager ever really it is I've
used package managers in every system
and I've never seen one that's nice
I checked today we are over 8,800
packages in the registry we grow by
between fifty and a hundred a day and we
get about two to three hundred updates
of packages of the day ok so really
simple stuff like yeah you can do NPM
install Express that's really simple but
there's some other stuff that like I
didn't know about it until Isaac showed
me so let's do NPM explore request oh by
the way like this is my slides directory
and I have some node module is installed
in here so NPM Explorer ok well ok so
what this does is it runs a new shell in
whatever directory resolves to that
module so wherever you have that module
installed if in your note program at
that same level you can require it this
command will drop you into a new shell
that's in that directory so this is
really nice because if the request
module has the same dependency that I
have the top-level and they're two
different versions it'll actually be
getting two different versions of those
because we don't have global versions in
packages so in this directory if I
wanted to know and I could actually now
require something did request has no
dependencies
whatever I could check Li you know what
is that dependency and if that have a
bug in it and all that kind of stuff and
know what I'm done I can just control B
out and then I go back to my old shelf
so that's really useful this is cool so
there's a ton of hidden little config
gems everywhere and this is one of them
you can set your viewer to browser and
then if you do NPM help that's cute
okay NPM the list this is one of the
most useful ones ever so this is great
none of them are colored like let me
okay pretend that you didn't see any of
this code okay awesome so this is much
cooler this is like all of these crazy
dependencies look I have an unmet
dependency in there I have a bunch of
dependencies that are actually aren't
necessary because they aren't dependent
on anywhere else in the tree they're
just installed probably because they
were installed back when I didn't
require it the known doesn't require
than that could JSON anymore it's like a
really really useful tool and you see
here this is like just really simple it
shows me all the dependencies of my
dependencies as well so you can see the
socket item actually requires quite a
bit of stuff I mean it requires its own
client which in turn requires a couple
different modules okay that's enough NPM
oh no wait I lied so this is actually
it's okay I wrote this in like a weekend
so bear with me this page kind of sucks
you can search for stuff though like
hello give it a second maybe it's broken
probably broke all right so yeah that's
probably actually because it's a big
cash to be view and nobody uses search
so every time that I hit this I'm like
the first person in a week and it has to
regenerate the view okay you can't see
the most useful thing is probably this
guy here this most dependent on so these
are the modules that like for all
intensive purposes everybody's using you
can see that everyone really does use
underscore it's incredibly useful not
like 500 packages are written in
CoffeeScript so 500 packages require
CoffeeScript that number gets a little
bit skewed because like everybody who
ever does anything n copies good past
requires all right moving along optimist
all right
this is optimist this is written by sub
stack most modules you will you end up
being written by sub stack he is
somewhat prolific it's a very simple
option parser it does all the things
that you need in a really simple package
you can see here that you require
optimist and then it's just gonna
automatically parse the process that are
but it's not going to overwrite the
process dart because that would be evil
all that's doing is providing you with
the Nuart be and we can see there that I
didn't pass it anything so it doesn't
get very much stuff but then like oh I
can actually get stuff and then like
there we go seeing lots of useful
parsing and it sort of handles like
every weird
parse case you want to do like I do
think this works yep see that works okay
you can write your own usage which is
very nice and you can also demand that
certain things are required so like
what's wrong - yes okay that console
that lug call never happened and it
printed the usage and the required
arguments because I didn't give it some
of the required arguments very very
simple stuff if I go ahead and give it
it'll actually run to that very simple
all right we can also set default the
same default around options so okay this
is a really simple script this counsel
lines in the file it demands that you
give it a leases at the file which is
incredibly useful and then it will
describe the option for you and don't
give it it's actually really really
useful it uses information so it
describes the file thing it says that
it's alias to this other guy and says
that is required so if I give 17 wonder
in the file very interesting
okay okay so I wrote this library I
think it's awesome some other people
seem to think so it's very well used and
depended on no it has a very very good
HTTP client in it already it's very good
it's very complete I know I've worked on
a lot it's just a little bit verbose and
it's a little bit hard to do really
simple things you end up writing a lot
of lines to do things like buffering the
response and there's just a lot of
little tiny features in HTTP and the
client that you just want to support you
know like cookie
you want to do like proxying like we saw
earlier so I'll show you some of the
things that you can do with this
higher-order HP client so let's get
Google just gonna take forever
and then we're gonna print the entire
body which comes in as an argument to
the call back and we're gonna wait for
AT&amp;amp;T all right there we go
there's lots of minified javascript all
over google.com so that was really easy
and useful show me more okay all right
here we go
here where we're gonna take the URLs for
the Google Doodle hilarious and we're
gonna write it to a file so all we do is
we request that Earl and then we type
that object the request object to a new
FS rate stream it's just a core file
writer object okay make sure that it
works yes it does you don't care about
the continental breakfast at the caterer
that I'm thinking about all right okay
that was great all right here we go now
we're gonna take the doodle that we just
wrote to the file system and then we're
getting this this new guy here this new
file and then we're gonna write this
little HTTP server that opens a write
stream to Google - and writes whatever
the input is to a file and then at the
end of the file that's going to do this
response this is a standard sort of node
HTTP server stuff and so we create a
read stream of the google doodle and we
pipe that to a request dot put call so
this is actually taking the body of the
image
to the server the server is just gonna
rent it out to a file so we can make
sure there worked correctly everybody
get that good okay awesome
you were all Network programmers oh I
also printed this stuff hey it works
everything's fine
another nice thing you can see here is
that I just closed the server after the
end of the the first call here note
woulda stayed open indefinitely if I
just would have listened did not closed
it but also when nothing is left and
nodes of n system it just exits cleanly
it's really useful okay especially if
you really hates it okay so this is
similar but what we're gonna do here is
we're actually gonna get the Google
Doodle link in from Google then we're
gonna pipe the call that we get to a new
request output object to that same bit
of code that was writing to the file
system this is useful in node because
like you'll notice that all these
objects are stream objects they're all
gonna get data as it comes off of the
network they're not gonna keep more than
one chunk every memory like because
we're piping all this data as soon as
this chunk comes in and gets emitted
it's just gonna get written out to
wherever it needs to go this is how node
handles so many in-flight connections
it's not just that you know it's
asynchronous and that uses Ipoh it's
that in your application you don't keep
around more data than you need you just
pass it off to the next file angular
alright that's number eight I'm sure you
believe these word but I'm just gonna
run them anyway so you know watch it
fail okay
see this is a very interesting thing
about this one this had way more headers
in it because what we ended up doing
here was taking this get call and then
we piped the request object to another
request object that's doing a put so it
actually took all of the response
headers and use them as right headers
which is super useful because this means
that if you take data from a web service
and then you write it to another web
service it's gonna keep the content type
intact and it's gonna keep the content
link intact and all those other nice
good headers that make everything I got
a sign now know how much time that means
how much time five minutes five minutes
okay you believe this one's really cool
oh okay this is the one line proxy that
we showed earlier but you can see that
it actually works one three three seven
really you're not flying boats you can't
talk to localhost you were started all
right there we go see look we can talk
to Google this is all being proxy
locally awesome stuff good times
okay now we're on to new cool hotness
socket IO socket IO is the new hotness
cuz real-time to new hotness this is a
really nice trick you take an idea that
already exists like bake sales and then
you had real time to it and then your
real time bake sales and then you go to
VC you can we should look at this code
that's actually kind of complicated okay
so we have this HTML page and this
javascript this is our server all it
does is it serves up this ten dot HTML
as the index if you get on slash and
then
it's also sets up a socket IO that
listens on that server and for every
connection that comes in
it actually takes the process that
standard in output and writes it to the
WebSocket so that's some crazy magic and
then here all we do is we set up a new
socket IO client we take all the data
and we read it to the console and we
also write it to this element right here
okay there we go come on guy did this
last time well there it goes see now
it's sending the actual data I don't
know why there was oh there's a leg in
process done in handling that's what's
the problem is hey I wrote it and it's
really happening in real time I promise
okay it's really hard to show on one
screen everything that's happening oh
you know what I could just do this this
is what windowing was made for
oh look at a vest that is okay now I
have about 40 seconds for questions so
you can ask a question but the answer
has to only take 40 seconds you okay so
the question is can he take a response
pass it to a function and then pass that
to another web service and the answer is
yes but there's one caveat so and I'll
the examples that I showed we didn't do
anything in between taking the data and
just sending it off like we inspected
the data and did stuff with it right
away they wrote it if you're taking in
input in a stream and then you want to
go off and ask a question over IO like
you want to ask a question to read us
that stream is already emitting data
it's already gonna be emitting data and
you need to buffer that if you want to
send enough to another web service often
the future whenever that other callback
happens from that IO action so that's
the only other complexity when you add
in a callback like an application
they're coming I assume that the
callback is to go off into IO because
you've been just had a callback for no
really but yeah that's that's a problem
that we're actually dealing with in a
future version of node streams will when
you open the stream it will open an
apostate and when you posit it will
admit it won't admit data so they'll be
able to just pause that stream and a
whole lot of the data until you give it
off to the next player so we're working
on making that easier so you don't have
to buffer by hand but all of them really
popular web frameworks right now I mean
my friend work taco Express like most
people that have to deal with this
problem they have some sort of buffering
built in production high performance
load balancing
I mean I use it in production some
statuses and production all of nodes it
says hosting platform uses node for the
in production I mean you get different
order you get different performance
depending on what your load looks like
no jitsu proxies it's all open source
but they do a lot of fancy stuff I mean
they do a lot of rewriting of headers
and so they don't get as many concurrent
connections as I do my I have a pure TCP
proxy that sits behind Studd and just
round robin to all of my like everything
behind the scenes so I get like 10 times
as many concurrent connections they do
yeah I mean you definitely can do it
many people do do it in production</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>