<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>AnDevCon IV: Android Binder IPC Framework | Coder Coacher - Coaching Coders</title><meta content="AnDevCon IV: Android Binder IPC Framework - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>AnDevCon IV: Android Binder IPC Framework</b></h2><h5 class="post__date">2012-12-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hiq3mGfLOtE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's start off with white hopefully
you guys are here
what can you can cook to get out of this
and then we'll talk about what you will
actually be able to get out of this so
one is you know you when you want to
simply understand how Android works
specifically you want understand for
example how intense or messenger or
content providers or system services or
access to system services or security or
how lifecycle callbacks are implemented
as you will see all of that actually
happens over binder you may simply won't
understand how fire itself works because
it's an interesting IPC framework or you
simply want to take advantage of binder
and essentially have a more direct IPC
essentially connectivity across a suite
of applications you guys may be creating
and you know you may have to just have
nothing better to do so that's why I'm
here
but hopefully we'll go over some of
these objectives so we'll go over what
binder is what eyepiece is very briefly
advantages of buying there compared to
other forms of IPC comparing binder to
other forms like actually on Android
forms like intents and quanti provide
there's a messenger and whatnot some
brief intro to binder terminology
because it will kind of come across it
over or and over and over again the
communication model this covering model
a IDL a kind of a way of describing
services you will see how the object
reference mapping works we're going to
talk about binder through essentially an
example application or or clients or
service applications we're gonna talk
about asynchronous nature of binder
memory sharing some limitations with
respect to bind their security we'll
talk about some other features like that
notification and reporting as well now
just a little bit actually before you
talk about you know Who am I and why I'm
qualified to talk about this I just
wanted to tell you that there's a lot of
information and binder in particular is
one of those topics where we can go very
very wide or we can go very very deep
and unfortunately we have an hour and 15
minutes so we're not going to be able to
you know do both I'll do my best to go
over
now I'm not gonna expect to have you
guys read all the slides or to even
necessarily go over every point whenever
all those slides so think of slides as a
resource that you can go through later
on in your own but let's focus on more
important concepts and hopefully we'll
touch upon the ones that are in fact
more important and maybe you know not
necessarily touch upon everything that's
in the are in the slides so in terms of
who I and myoglobin ian mcculloch
alexander garganta or nickimja sasha i
happen to be a one of the android
instructors at Maracana we focus on open
source training but i specifically focus
on android or even more so internals of
android and as you can imagine Android
finder is very you know poor part of
that I also happen to run the same
participant a user group values a group
I also co-host or co-founder the html5
years ago if I speak at other
conferences and whatnot I used to
actually do a lot of enterprise Java
development prior to coming to Android
but I also worked on you know old-school
mobile technologies like you know web
portion and that sort of stuff so anyway
that's about me
now what is behind there just kind of go
over the basics and then we'll talk
about why we need it so binder itself is
essentially a think of it as a framework
it's not just an IPC you know mechanism
but it's more of a framework and that
enables us to develop essentially an
object-oriented OS like experience now
we're not talking about an
object-oriented kernel we're talking
about enabling essentially an
object-oriented service environment on
top of traditional kernels like Linux
and as you will see binder itself is
obviously split across the entire stack
you know they're poor of it being the
binder driver isn't the kernel itself
and traditionally actually should just
tell a little bit about you know the
history of binder and binder comes from
open binder which was originally
designed at be OS it was supposed to be
part of their you know next generation
released back in the day in BOS was the
new or being was acquired by palm we was
then essentially firstly implemented as
part of the COBOL to release of palm
on first their microkernel then palm
switch to Linux it was you got ported to
Linux as well
and at some point 2005 ish then I born
was basically she was one of the key
contributors to binder who she was
snapped by by Google and kind of brought
into the Android team and so Andrew it
the very first release of Android was in
fact based an open binder or actually
said the very first bring up of Android
but then very quickly it got rewritten
from scratch to essentially suit the
Android needs now open binder and binder
somewhat related in terms of the
concepts in of the terminology but they
are distinct they cocoa bind there is a
fork of open binder and open binder is
more or less dead in terms of future you
know development now why we're here is
because binder is essential to Android
as you will see and in fact if you focus
on just this image over here which is
like this these are by the way SVG
graphics so if you're trying to access
this over say ie you may have trouble so
this basically gives you an idea that in
Android we have the kernel at the bottom
we have a bunch of demos like service
manager media server system server
surface flinger you might have heard of
these things and then we have
applications in fact these as you can
see right through this diagram all
running separate processes and that was
one of the you know core concepts behind
in fact IPC on Android and because of
that binder is essentially used as a
transport mechanism to enable this sort
of architecture and we'll see exactly
why this is needed so what is IPC so IPC
is essentially a kind of framework for
exchange of signals if if you will and
data across multiple processes or
threads but in this case we're gonna
focus on processes it is really used for
message passing synchronization sharing
memory or you know essentially an RPC or
remote procedure calls now we
specifically when we get out of IDC we
get information sharing we get
immortalization of our code we get
isolation of the processes which leads
to better security models better
stability models and whatnot because
essentially every process runs in its
own sandbox memory space so if you work
misbehave or say they died because it's
poorly written it doesn't affect
anything else in the system there are
many IPC options that we could have been
using on Android like for example files
you know signals sockets you know fine
unix sockets or tcp/ip sockets pipes
shared memories semaphores message
passing like message queues BD bus and
then of course on Android we use intents
as a form of IPC as you will see in DES
themselves are based on the icon finder
and then the binder right so Android as
you will see mostly most of it is most
of IPC is based on binder with some of
the EULA of what you see being based on
sockets
now why specifically binder so basically
Android apps android from the get-go was
designed so that its apps and
applications as various services I
should say system services line separate
processes and this is a mission before
Bice's security by the stability biases
memory management so for example as you
guys know an Android if an application
is no longer needed what happens it's so
literally two processes killed so we
can't really do that if that application
is embedded inside of another process we
cannot just easily kill it whereas the
Linux takes care of all the cleanup
ports so my stability has already
mentioned if an application misbehaves
it doesn't affect anything else and
that's also using portal for security
perspective now IPC is a great way of
providing these features but the problem
is that their additional system five
based or POSIX based IPC isn't supported
on Android so there's no support for
semaphores shared memory message queues
and so forth now why not well one of the
one of the actual reasons is something
you can read more about here in fact you
can see a proof of concept the system
system v IPC is prone to a resource
leakage in case applications don't
properly clean off clean up after
themselves so specifically if an
application to say two applications were
to share a semaphore and one of them
were to get killed the other one may in
fact end up being dead blocked or in the
you know the OS resource may in fact end
up being just left in the kernel and
never cleaned up and in Android it's
actually not on call
for an application to die without
cleaning up after itself in fact that is
one of the models that Android uses to
essentially manage memory right the low
memory killer environment so that is you
know that alone gives us a reason to
think of a different solution than the
traditional IPC mechanism that are
available so how is binder better well
one of the features of binder is that it
has object reference counting built into
it and something called death
notification
so these two features plus others make
it very unsuitable to environments where
things just go boom for no particular
reason basically they die with other
knowledge so this makes binder basically
you know address the very concerns of
system 5 a stack you see in addition to
that we have a much neater programming
model so some some people refer to it as
thread migration meaning when you are
invoking an operation in a remote object
the ideal world it'll appear to you as
the programmer that that object is local
you will not know that essentially the
operation may execute elsewhere so you
will not even feel this being so much an
IPC or just get a reference your vocal
method and magically things work as
opposed to you having to worry about
threading pain to having to worry about
low-level file descriptors messaging you
know buffers and whatnot so it'll appear
like your thread jumps to another
process and continues executing your you
know the method you invoked on the other
process this is very very important
binder actually means it's possible
through a couple of things for example
it can managers thread pools for us on
the remote side so the remote side
actually is implemented just by the
virtual callbacks as opposed to having
to manage any threading or
synchronization or anything like that
and the remote methods essentially feel
like I said they're local
that said Android also supports or
binder also supports what's known as
asynchronous operations where it'll
invoke an operation and then just simply
return right away without waiting for
the remote side to complete and this is
actually very important in some cases a
couple of other features we get
automatic essentially a drone
I should say information about the
sender is automatically embedded in the
messages sent between the parties
communicating so the receiver can
actually use this information to say who
area who the sender is and basically I
decide whether or not the sender should
be permitted to execute the operation
there they wanna execute and this is
actually very core to Calandra does
security as we will see later on also we
also have the support for unique object
mapping across process boundaries so for
example if I go and you know create an
object that I want others to be able to
remove remotely reference I can pass
that object to some other process that
other process can then pass that object
or that reference to yet another process
and that other process can still use it
that object is essentially the reference
that or that object is unique unique
across the entire system again and enter
its binder driver takes care of
rewriting essentially as you will see
the references as necessary to make
local references become remote
references when they cross object or
process boundaries we'll talk about this
idea of tokens and whatnot later on and
binder also supports this idea of
sending file descriptors across process
boundaries and this is actually very
important and Android to avoid memory
copies so for example on Android when
you're let's say displaying something to
screen to a bad buffer you're not
writing into your own memory and then
giving that memory to surface flinger
served by coffee so surface layer can
going to play it on to the on
essentially the frame buffer rather the
surface flinger gives you a buffer as a
file descriptor reference that you can
membrane that you write into it and then
you signal to the surface flinger that
you're done surface finger things that
in foreign says ok this represents the
byte the bits you want me to display the
screen let's go into it and all along
you essentially are writing into memory
that is managed by the kernel or even
accessible to the display stack directly
so this is very important because
without it we would have had to
essentially copy memory around and bind
there means as possible also supports
the invoke a essentially very much I
should actually go back a few things it
has a very simple a IDL based language
or an interpreted finishing language to
make it fairly simple to subscribe
services with their clients it has
built-in support for
marshaling of very common data types so
you don't have to worry about how do I
write an INT should it be you know this
fight order or that byte order you just
don't think about these things or how do
I write strings across a process process
boundaries and one thing I should
mention is that binder doesn't favor
apron to binder driver as you will see
there's a favored languages so you can
your clients and/or your services could
be written in Java C or C++ it doesn't
matter the the semantics are the same
and there's building support for many
common data types the transaction model
is basically simplified by
auto-generated stops in proxies that
I'll show you later on and supports
automatic inclusion across processes so
you can process a can call process B
which can get called back in to process
a and they can essentially do recursion
and the if a process a were to call what
it thinks is a remote object but it
happens to live inside a processor it's
not remote binder short-circuits the
whole thing and it just essentially
calls every you know locally so there's
absolutely zero overhead now that said
by there is not an RPC it's not about
remote procedure call so it does not
escape the system on which it is running
so the actual transactions are limited
to the same OS and it is client service
based messaging oriented so basically
there's it's not very well suited for
things like streaming and it's not
defined by any sort of API is white
POSIX or standards so that gives you
hopefully an idea of why binder now you
might have been already doing IPC before
and you may think well why do I care
about binder I already taught using
tense and in fact intense content
providers are a simple form of IPC on
Android that most applications are
encouraged to use anyway so for example
if you consider this diagram over here
you could have an application a with say
a products you see your application B
with an activity of an agency with
another activity some application with a
service another application with a
content provider and so these in fact in
could talk to each other using either
intents and or essentially content
providers are more direct access to the
other
components now isn't this IPC and it it
is in fact this is like I said they're
the recommended approach for most
applications but it is somewhat limited
and specifically it's not very object
oriented you're sending intents intent
is just a payload that contains the
information about where what you want to
have done in kind of if you know the
parameters of that intention
it is very asynchronous so basically
when you're making calls to remote side
you are you don't really you don't know
when or even if that call is going to be
completed and it's kind of like the way
you use it is slightly clunky now
content providers are more synchronous
but the problem with content providers
is they do not you know they have a
fixed API so you're really limited to
the model they for something ultimately
all of it is based on on finder so all
of the communication in Android is
intent and/or content provider based
underneath the hood if you were to look
through the Android source code you
actually see that ultimately all boils
down to the point and so why do we care
about binder if this is available well
if you want to have low latency you know
synchronous execution where you can you
get to define your own API you're not
constrained by essentially the clunking
is so intense and your content providers
if that's not what you essentially maps
well to what you're trying to do then
binder is a more direct approach to IPC
that's why we're going to look at it now
in terms of how intense work this is
kind of you know just a short example so
it let's say you had an activity that
wanted to do a product lookup say by
scanning a barcode but he doesn't want
to do the scanning of the barcode
because it's a hard thing to do well
what he may do is create an intent and
ask for example the Google barcode
scanner to do the scanning so it would
create an intent specify you know who's
supposed to handle the intent specify
parameter of the intent send the intent
that intent goes to say the barcode
scanning activity which then goes and
asks you know turns on the camera that
does whatever it needs to do and then at
some point in the future it goes and
saves the contents of saying that you
know the barcode is devil's can into
some result
then the that content the result comes
back by an asynchronous callback and if
the code and the result are what the
application or the client expects the
client can pick up the unessential
response data again from this coming you
know this intent and then say doing my
actual IPC lookup or something like that
or UPC logo so this works but it's
somewhat clunky like I said it's
asynchronous the api's or someone you
know not always in 250 years
another form of IPC or Android that you
might have come across which also works
really when implants is this idea of a
messenger so a messenger basically is a
reference to a handler in a remote
object so you guys are hopefully
familiar with handlers if you're not you
know well look him up we're from we're
not gonna have time to go over it but
basically the idea is handler is a
handle onto a message queue which the
local looper thread goes or reads from
and processes messages to do something
with it so for example let's say you
wanted to build an application it's
probably better to just for me to
explain why an example so you had an
application that wants to request a
remote service do a download of some I
don't know some URLs and some data and
then send it back you know progress
information about how the data is being
downloaded right you want to get stream
of callbacks from the remote service as
it's doing the download for you well one
way you can do this is for example to
create an application that creates an
intent again intent Indian specify the
URL you want to have downloaded and then
create essentially a messenger which
wraps a handler the handler is where
you're gonna get your callbacks so we
did then let's say start a service what
happens there is on the other side this
is the kind of a service assuming in
another process you would handle that
intent again we're back to intent based
communication and then what you can do
is you can loop through all the you are
eyes presumably do the downward and when
you're download the URI you can then go
and get the message from the intent so
notice we just send in and across
process boundaries you know using
the simple IPC mechanism once you have
that messenger you can obtain messages
put the data you want you know to
respond back to the client into that
message while into a bomb into a bundle
then into a message and then you send
that message once that message is you
send a message once the message is sent
on the other side back in the client the
client essentially inside of its handler
gets the message he then extracts the
data that it got and then presumably
let's say updates a progress bar or does
whatever something useful with that so
they're essentially same you know
ultimately all of this is still based on
binder and in underneath the hood is
completely worse than binder but it
gives you a more synchronous you know
communication channel it's not quite
synchronous because what happens is that
when the message is received it receives
a message it receives it on one thread
but it then drops it on to the message
queue of the handler through the handler
on another thread the UI thread where
the message gets hammered so a lot of
this you know what decisions are you
know taking away from you and you
essentially you know just use the API
and it fits your needs or it doesn't but
that's about all you have now that's
those are the options if you don't want
to use point like those are abstractions
or binder if you will now let's say we
do want to use point you mean you're
sold on the idea by there we need to
kind of go over first of all a few terms
that we're gonna encounter to the rest
of the talk first of all binder binder
itself refers to a lot of things when I
say binder oftentimes refer to the
binder framework which includes the
binder driver which exists inside of the
kernel and it's accessible through
essentially in I octo based API if you
don't know what that means don't worry
the binder protocol which is essentially
how we communicate with the driver and I
bind their interface which essentially
defines the basic set of methods that
you can invoke on any binder object can
a IDL is a interface definition language
we'll talk over it in more detail in a
moment which allows us to define our
business operations on top of the IDL
interface because they I bind their
interest because I
generic we the whole idea of using
binary so we can define our own api's
binary objects or implementations or
basic implementations of bar I bind
their interfaces but they don't have any
business value they don't actually do
anything other than represent a remote
object sometimes they're used as tokens
to essentially define who the client is
and I'll show you why this is
interesting but on their own dinner
actually are not really meant for IPC
per se because they don't really have
any operations that we know of by
default a binder token is essentially a
handle onto a binder object that's how
we think of it binder service the binder
service is a binder object except that
it typically implements some sort of an
a IDL based you know interface so it
implements you know the business
operations that we care about that's
what we actually want to use as clients
most of time binder client is the side
actually wanting to make this binder
invocation or this binary transaction so
it wants to take advantage of the
services offered by the binder serviced
by the transaction is essentially you
can think of it as a method invocation
so every time we invoke a remote method
were essentially submitting a what's
known as a binder to ins action which
can be synchronous or asynchronous if
it's synchronous it comes back with a
reply as we will see parcels are
basically the data structure that that
essentially contains our parameters that
we send in binder transactions and
returns and the return value is received
from binder transactions as you will see
at the end of the day parcels are
nothing more than glorified byte arrays
with the metadata attached to them but
they're very key to kind of how we send
it across the binder channel
marshalling is a mechanism of converting
essentially say rich Java data types
that you want to send to the other side
two parcels so that they can be then
boiled down to something that binder
understands and on marshalling is the
reverse process you basically
unflattering you're going to take a
parcel which is very generic and you
read from it the data and you
reconstruct the original parameters
let's say the client wanted to send to
the service
the proxy and stub are in some cases
automatically generated specifically to
help with parceling necessary with
marshaling and unmarked sling as well as
transaction invocations that is
something that will be auto-generated
for us if we use Java for example
because Java has like slight advantage
over C++ in this department and then
finally the context manager or some of
you might have seen it as a service
manager is a special binder object with
a well known address that helps us
discover other binder objects so that is
the the starting point for all binder
communication getting access to the
service manager as we will see so those
are just the terms the other question
sure yes yes so we'll talk about custom
marshalling and marshalling so I don't
know out of the box binder supports
marshalling inter marshalling for many
common data types as you will see but
Maps lists primitives and whatnot but if
you had a custom data type save some
classified foo you could go and find how
that class gets essentially marshaled
and our marshal think of it as Java
serialization
right so you can it works across
complicated and data structures as you
said however you know only if the all of
the elements of the data structure are
in fact Marshall Lobo by default
otherwise you have to end up doing the
marshaling yourself we'll get to that
when we discuss a idea but good
questions now we get to the corner of
cardizem binder actually work okay so we
understand that binder is hopefully we
understand the binders used everywhere
and we really the entire Android system
would literally fall apart if we were to
Yannick binder away simply because all
of the communication across all
applications to system services and
across you know other application
boundaries happens over binder you want
to be able to draw a single pixel on the
screen if there was no binder right so
ultimately when we talk about IPC
generally the client just wants to use a
service right that's kind of what they
want you have a client process you have
a service process each had their own
threads in this case I'm kind of
assuming binder has one I sorry the
client is one thread service may have
many and you want to make make a remote
unfortunately or fortunately you get a
one process you know just randomly
invoke an operation another process or
read or write it's memory it's you know
out of out of its essentially it's just
not not allowed to put because of the
sandbox in there Linux kernel enforces
but the kernel can do this which is why
we need to bind their driver so
ultimately this is what it typically
looks like you know as you will seem a
service that wants to be involved by
remote clients will generally make a
request to the binder driver and a wait
enter essentially a looping mode where
it waits to receive requests from the
binder driver it will essentially create
a pool of threads waiting for requests
at that point something like in the
future
a client will submit a request it will
submit request not a service because he
can't but you the driver the driver will
somehow convert a request from what the
client wanted to submit into what the
service is expecting propagated over to
the service at that point what the one
of those threads one of these threads
that was blocked will unblock
handle the requests produce some sort of
reply the reply will be sent back to the
binder at that point that thread will go
back to waiting for the next request and
the reply will then go back to the
client now how does the client to get a
reply well the original request that the
client submitted was essentially
submitted to the binder as a blocking I
octal call so all along while the
service was doing its thing the client
was waiting essentially on the binder
driver at the end of the request the
binder gets a response at that point the
binder you can or doesn't have to go
back to the binder to do more things but
the service will go back to being
blocked on the binder waiting for new
requests now because and this is kind of
these three lines are meant to indicate
that there could be more than you know
one thread in fact by default binder
supports up to 15 concurrent threads on
every process and so what that means is
that there could be many concurrent
clients talking to the service at the
same time and it would be up to the
service to ensure that it's protecting
its state from concurrent notification
right so the same old training you know
paradigms apply here as well now the
Apfel driver is exposed to a simple
slash dev slash binder handle or note
and he has simple API fairly simple for
drivers open release all map and memory
map flush and mores most importantly I
octo so how does it actually work well
every and this is the most important
kind of command against the binder drive
most of the commands are an i octo this
is a special system call for
communicating to drivers gnu/linux where
after you opened a binder driver so you
have a file descriptor you pass to it
this readwrite command and you pass to
it a pointer to this memory which is of
type bind the readwrite find the
readwrite are to buffer arrays of
particular size well the first one has
its size to define the second one will
have its eyes defined and you
essentially posit that to the binder
driver what does the binder driver do
the binder driver goes through this
write buffer and he goes and reads from
it the commands you are trying to submit
to the binder driver there could be many
comments like for example this you can
say I want to watch some object for that
notification or I want to increment a
reference to something I want to
decrement the reference and so on and so
on but the last command generally is a
transaction event that's the the one
that you care about well everything you
care about but that's going to be the
juicy one when the talk about is
actually moment when the binder returns
from say it actually invoked a command
on the other side you've got the reply
from the other side and now binder comes
back to you
so basically the binder returns right
here at that point the read buffer will
contain couple of things more
bookkeeping commands for you to do work
from that binder driver tells you to and
then the the last part is a reply either
the reply to the original request you
submitted which was the thing over here
or another request for you to go and
perform because like I said binder can
support recursion across processors now
what's inside of these transactions so
every transaction so that's that's what
you know that's the last requires so
every transaction will contain a binder
token that is the thing that identifies
which actual object inside of that
remote process you want to talk to and
as you will see each and every one of
these binder talkers are unique across
the entire system okay so that
essentially think of it as up as a
memory address of an object that you
don't know which process it lives in
yeah you then specify code now code is
just an integer but as you will see code
is essentially a designator of the
method you want remote site to execute
now it is up to the clients and service
to degree and what code really
represents binder doesn't care but
generally it's used to designate a
method with him that object is just an
integer starting from like more um you
then include the raw data buffer that
includes the data that you want to copy
to the other side in binder and almost
everything is sent by copy with a few
exceptions as we'll talk about and
finally the transaction will include
your sender PID and UID that's
information you actually can't change
that's kind of the information that gets
automatically embedded by the drive and
this isn't used for secure businesses
will say that a question
absolutely not right well not even so so
I thank you for bringing that up I
should have given this a little
disclaimer this part you absolutely
don't have to worry about this is us
talking to the colonel this is me going
down to the very very very low level of
the binders driver which you will never
encounter unless you are actually
working on some low level which most of
you I'm assuming or not and this is more
of an FYI feel free to ignore if you
want to snooze for five minutes feel
free to do so sorry in fact which brings
me to the next interesting point mostly
low-level operations so we talked about
this raw data buffer well we don't want
to think in terms of raw data buffer we
actually want to think in terms of these
parcels we've now back to parcels think
of a parcel is essentially a glorified
byte array with metadata attached to it
and we actually don't want to know
anything about these transactions
because they're too low-level that's the
part of the binder protocol so most of
their applications written in or
userspace codes are written in C++ or C
uses what's known as the label binder
that's what does that work on its behalf
now it's in fact in Android even system
services and definitely application
developers really don't want to know
anything about that binder about the
binder protocol they didn't want to know
anything about transactions invite the
race and they don't even want to know
anything about Lib binder so in most
cases all of that work is abstracted
away from us through something known as
proxies and stubs so now what's a proxy
we kind of explained it already but let
me kind of explain it here in the
context of this diagram so when a client
wants to talk to a service what it do
typically does is submit it an
object-oriented request a method
invocation against what it thinks is
this service but in fact is a proxy will
see how the client gets fooled the proxy
then submits a request through J and I
and live binder to the binder driver the
binder driver submits a request or
returns I should say back to not a
service but to what's known as a stop
stop receive that receives that means
action from the bank
the stub goes and converts what was
low-level binder request or transaction
into what is now an object-oriented
request excuse me and then evoke certain
service so basically here we're
object-oriented in here we're
object-oriented but in between you know
right between these two lines we're very
very low-level right so proxy and stop
completely shield us from non knowledge
that this is actually even happening
when the service submits a response the
response is going to be an object
because you are off to Turing developers
and that object is not something you
want to really even know how to write
down into parcels so the stub will
invoke the appropriate methods to
marshal the response back into what is
essentially suitable for binder the
parcel the blind the driver will pass
that object or that I should say parcel
through the binder driver over into the
proxy the proximal now unmarshal it back
into the object representation of what
the service returned and other client if
the response so basically this over here
is what the client cares about this is
what the service cares about everything
in between is completely you can ignore
and you can still benefit from by them
now one thing that I haven't explained
is how does the client even get a
reference to the service right so this
is all very nice but how did the how to
actually get started I mean this kind of
implies that the client knows which
service he wants to talk to and this is
where we use what's known as a context
manager or binder closet a context
manager but actually the user space
process it's called a service manager so
how does that work actually I'm sorry I
just jumped a little bit height skip one
one section but let me just go back one
one diagram before I call the service
manager in fact most clients don't even
want to know anything about services
especially when it comes to system
services for example man most of you I
would assume has have written
applications that he used activity
manager front package manager location
manager sensor management education
manager search manager download manager
the list goes on guess what all of those
managers live inside of another process
how did you talk to him through
did you know the new doctor intro binder
between call of any proxies probably not
what you did is you said yet system
service and you got something would
appear to do what you wanted to do how
does that work well what happens is that
when it comes to specialist system
services what you're actually given as a
client developer you're given with what
is known as an manager so manager is
actually a another proxy that completely
shields you from the knowledge of binder
so you don't even not to know about the
actual proxy and you don't have to know
about the lookup of how you find the
objects you want to talk to and you
don't have to worry about any low-level
binder specific exceptions you just use
it to you
your location manager feels like a local
object and it is a local object but what
it's doing a very the hood its invoking
a proxy which is invoking
to bind their a remote service so in
Android for most services you will have
manager in a service for example there
will be activity manager activity
manager service location manager
location manager service the service is
the remote part the manager is the local
part that completely hides the binder
complexity from now coming back to this
idea of discovery how do we find the
thing that we want to talk to again if
you're just using system services this
is magically confirmed but if you are
saying interested in how that works well
let me kind of go through it so when
binder is loaded early on by the kernel
the thing that awaits is your
registration from what it thinks very
first was a context manager context
manager basically is a special binder
object at position or handles 0 ok some
known address it's kind of like think of
it as 4 1 1 everyone knows without 4 1 1
if they need to find out somebody's
number I guess need to search for
something right it's burned into our
memory that's how you know handles 0 is
burned into everyone's memory so what
happens early on
this is context manager in Android is
called the system service service
manager it registers with binder the
binder says ok you're good to go then
the context manager goes to
okay I'm going to wait for you to give
me requests at some point in the future
our service comes in registers with the
binder our service goes to the binder
drivers as a binder driver I want to
wait request from then the service goes
through its service manager proxy which
is yet another proxy which is part of
this and it goes and says hey I want to
find out where this manager is like in
what she wants to talk to so now the
service becomes a client for this and
this context manager becomes a service
why does he want to talk to it well
let's actually talk about hi gets it
once it doesn't want to talk to it this
is the binder driver says I know where
that is
I'm gonna give you address to the to the
service manager then the service goes
over here says ok I want to register
with it so it submits another request
through binder which goes to service
manager service manager says I'm gonna
allow you to register your you win and
then the binder driver goes back to the
service proxy and back to services ok I
registered you why is this necessary
well this is how services essentially
register make themselves available to
clients so if any of you have ever done
whoops sorry
this adb shell service list you will see
that there's something like in this case
fifty-seven services that are registered
by name of a particular implementation
with a service manager so it's just like
table cam this is what cow you basically
discover your service system services
starting from activity manager which is
needed for everything the client that
now wants to talk to the service like
they ultimately the client wants to talk
to this service but how does it get to
it well the first thing it doesn't says
okay let's get to the binder and ask the
binder to give us the address of the
context manager find the repo replies
and then we go to the context manager
and then we say okay give us the address
of the service and then the they're
called was back to the client at that
point the client has access to the
remote service okay so the context
manager is this essentially registration
process
in between and handles all the lookups
and and storage of the or essentially
key value pairs this is the thing I've
mentioned about the service list now
this diagram kind of goes into more
detail on how this all works I'm not
gonna go through all these steps you can
kind of read it on your own the idea is
you know here's some sort of a service
that you know girls have registers
registers itself with a service context
manager it goes in basically starts
listening on the binder driver
here's a client the client submits a
request goes through a proxy to live
binder to the driver wakes up the you
know the other side live binder goes
back to stuff goes to service service
replies and so on and so on so it's
actually just me captures what we talked
about another already yeah now ensures
of just making this feel a little more
tangible here's an example of how
location works on Android some of you
might have seen the slide before I've
kind of given this you made one of my
previous talks this is essentially car
location services work on Android here
is an application say that wants to
access and get access to its say
last-known location on the device what
it will do is it will ask the system for
a location manager location service and
what do you'll get is a location manager
when he gets the location manager while
the location manager needs to talk to
their remote service so what does the
location manager do location manager
goes down to the colonel and says or to
the drivers ask a driver who is your
context manager and he gets reference to
this then the location manager goes to
the service manager says hey service
manager where's the location service and
now the service manager replies now how
would a service manager know where the
location service is well inside of the
system server which got started early on
during the system boot one of the things
that happened is that this thing called
system server created instantiated the
location manager service location
manager service is one of us buying
their services what it did is it then
basically initialize a bunch of its
providers and other things which are you
know not important to us but then
they're lucky the system server went
through the service manager and says hey
service manager would you be so kind to
remember this location service under the
term location
that's it service manager says yes and
from this point forward anyone can talk
to the location service assuming they
know to search for it by location and
that's what you will see over here if I
go back here and I you know search for
location you will see shows up somewhere
here location there we go so that is the
location service yeah anyway so that's I
don't want to go into a details of how
the rest of it works it's not even
important I just kind of wanted to tell
you this is in fact how you know most
services work there's some exceptions
some services use you know like for
example phone application uses UNIX
sockets to talk to the radio radio
daemon but outside of a few exceptions
like that almost all communication
happens over time now I mentioned that
services bind their objects are useless
on their own they need to have business
operations well how are those business
business operations methods described to
the clients well we use a language
called a IDL this language since we're
in Android the first official language
and it's similar to other ideas you
might have seen like Cora and whatnot
but obviously simpler it looks and feels
like Java for those of you that know
Java so shouldn't really come as a
surprise so let's say you wanted to
create a new service we wanted to define
a new service for the clients to use you
start off by thinking of what you want
to call your service you typically you
know call it I some name of the service
service dot a IDL just a common naming
convention you stick that serve that
file inside of the AIS or inside of the
source directory and you package with
like any other Java source inside of
that you burn to find the service notice
that the service has a package name
space will they're very much like Java
would it can import what appear to be
Java classes and it defines an interface
like Java woods and inside of it has one
or more methods which look and feel like
Java methods what's different from Java
is that this is all by default public
there's a public or private or protected
or of corn obviously no statics and one
of the other things is that these these
parameters appear to have these special
flags which we'll talk about in a moment
now once you do this
one of the things that androids ADT or
developer tools would automatically do
is they will extract from this file a
Java class and stored into a gen
directory their clips uses a command
called a IDL which is built into the SDK
assuming you're a IDL file is correct
it's not you may not even see errors it
just may not ever create a file what is
this inter now Java class hi
well this Java class is a proper Java
interface which has the same name as the
original file and it also defines the
very same methods that your original
interface defined but now you have
dominant in addition to that it has
internally a stub and a proxy we'll come
back to them and kind of talk about what
they do we take a look at the details of
what they do anymore but they get
auto-generated if your clients and/or
services are using C++ then you don't
have any ideal tool that creates a
closed class code for you at least not
by default you have to end up
essentially creating your proxies and
stops you're on your own now what are
the types to come back to your question
so what are the things you can actually
put into parameters and return values
for these methods you define using area
well you can obviously pass in any knows
but that's in the pipe you can just pass
it off you can put any primitives and
arrays of primitives you can put char
sequences and strings which are
internally passed to C++ as utf-16 you
can pass file descriptors this is
actually what I said earlier he to being
able to pass pointers to memory areas or
memory structures from one process to
another this is how memory sharing
what's in Android one process gets a
handle onto us a memory block whether it
comes from the kernel or it's internally
managed doesn't matter or it's actually
a real file of this but it has a file
descriptor to it it can in big the file
structure write it into a parcel buy and
send it via essentially the binder
channel to the other side the other side
gets the same file descriptor and now
has access to the very same resource
they are written the file descriptor
itself is duped
it's copied but it points the same OS
resource in same position within that
resource you can also pass in any
serializable but that's not very
efficient because Java civilization
concerns itself with essentially long
term storage as well as to some degree
efficiency whereas binder is extremely
concerned about efficiency so you should
never take essentially a parcel which is
what again is the unit of binder
transactional data and store it to disk
or store it anywhere long term because
it doesn't include enough meta meta
information to be able to reread it
properly so serializable czar supported
but not efficient is the boredom as much
as you can Maps so anything of type map
can be passed as long as the objects are
supported or that values of the maps are
off one of the supported types same is
true for lists and object arrays so you
can put an arbiter a but you have to be
a supported type you can pass in bundles
bundles are essentially wrappers for
maps they're just more just glorified
they only allow you to store or put into
them one of these supported types and if
any of you guys have used bundles inside
of events the very same bundles you can
also pass in sparse arrays in sports
boolean race but that's kind of just
more specialized essentially arrays and
finally finally two more things you can
do one you keep passing instances of ID
binder remember I find their interface
anything you pass to the other side is I
bind the reference is not copied rather
it's past as a find the reference so the
other side will now have a essentially a
pointer back to that object that object
may might have been your local object or
they might have been an oddity that you
got from somewhere else but it points
the very same object and finally give
you hat custom data type something
that's not on this list let's say we
have a bar whatever bar may be then
basically what you do is you pass in
something you need to have your bar
implement parcel of all which is like
Java civilization or serializable except
it be parcel bubbles you end up having
to implement the strategy for parsing or
marshalling and are marshalling yourself
and so what does that look like let's
say this bar that's a private data like
an integer in a string and now you
implement parcel work well that requires
the implement
eken ISM for perverting this object into
a parcel using the primitives that bind
their supports out of the box that I
mentioned as well as the rereading that
object of a parcel meaning updating the
object on a parcel and finally really
creating that object from a parcel which
is kind of like feeding you're
essentially creating a brand-new offer
from a parcel so who will ever call the
right to parcel the proxy so when this
bar needs to be sent to the other side
well because the binder chen-wong
supports parcels isn't or anything about
bars the proxy will convert your bar
into a parcel the other side on the
other hand the service that wants to say
react to a bar doesn't know anything
about product parcels doesn't care about
buying parcels he cares about bars so
will happen on the other side the stub
will recreate the original bar from a
parcel so essentially parcel is a
mechanism for you to flatten your object
into something that binder driver if you
understand and then these methods are
mechanism of you know converting them
into parcels and recreating them from
parcels another I'm going to add these
details you can read more about them
later it wants to do the find however
any of your custom data types you're
gonna have to declare in declare them in
their own a IDL file and make them are
syllable and one more thing is you end
up having to go and import and this kind
of seems redundant for having to import
something that's in the same package but
you end up having to do that anyway if
using custom data types so that
essentially is how you start off
creating these these you know custom
types in how you create your interfaces
now one couple more things I should
mention is that parameters in a IDL can
take zero or more parameters but they
must return something even if it's a
void all of them require a directional
flag except primitives because they're
by default in in only so what's a
directional flag well here in out
basically means that this instance of
bar will be copied or parceled into the
service that is very receive it and then
when this call returns
it'll be impartial back and sorry pasa
parcel by the other side and aren't
parceled on the client so basically
we'll be caught
both ways if you say in there means it's
just copied one way or if you say out it
was copied you know that to you but
you're the state of the object is never
copied towards the service the integers
like this one you know because it's a
primitive of course you know you cannot
directly it's an integer and so
therefore it's only it's you know only
copied so therefore it's always an in in
terms of the exceptions you cannot use
you cannot use any of the exceptions
well your interfaces cannot throw
exceptions they cannot declare
exceptions to be thrown and if your
objects declare throw exceptions those
exceptions basically have to be one of
these so security and all point they're
illegal argument and that sort of thing
so hopefully that makes sense for what a
IDL is now how does this form mapping
work this is where it gets slightly
tricky I'm not going to go into too much
details other than five you know you can
just trust that it works but let me kind
of give you an idea so when a client
builds an object let's say this way when
a service builds an object right then
become did we wants other clients to be
able to use and he wants to register it
with a service manager and the point
where it submits that that a binder
object to a service manager their local
reference it's translated into a binder
handling the service manager remembers a
pointer think of it as a pointer back to
that original object as via this binder
handle if a client now requests this
binder handle you know because he once
thought that service it gets the very
same binder handle but then the binder
handle when it reaches the client
becomes a local clot you know law and
especially a local address to its own
local memory space when the binder now
submits a transaction the transaction is
going to essentially what appears to be
a local variable but their local
variable is this that we mapped inside
of the kernel driver to the remote
remote you know which then when it
reaches the service its remapped from
that remote handle back into the
original
local object of the service half of the
actual service they all do that it wants
clients to use
so the binder driver automatically you
essentially you rewrites any binder
references that you are talking to or
any binder references you put into your
parameters and or return values and
internally the binder object may order
the binder driver maintains a mapping
between local references and essentially
it's virtual or abstract binder handles
you don't have to know that this is
happening except that you benefit from
it because he means that if you share
and reference to it will appears to be a
local object to some other process well
that other process will point if it
submits transactions are get against
that object it will go to the very same
object because again these references
are you are unique across the entire
system okay I'm not gonna go into
internal it's you know the binder driver
has like a this binary list or binary
three I should say of these you know
mapping of references we don't have to
go into how that works it's not even
important except that it doesn't work
now
let's you know we all don't have a lot
of time left so let's take a look at you
know a couple of examples let's say you
wanted to build an application that you
want others to be able to use
essentially I should say a service do
you want others to be able to use now
let's say you're not building a system
service because if you're building a
system service you actually your job
would be slightly easier in say if you
were building a system service you could
then use the service manager to directly
remember the service you know the
clients want to talk to you but in this
case actually you wanna be able to let
me give you kind of explain what this
does in this particular example we're
gonna have a client they'll just have a
UI the UI will collect some sort of an
input from the user the user will click
on a button that will generate a request
the request will go from this client
activity into a service and from that
service into some sort of a library they
will act on the request which will then
return the result and essentially the
result will go back to the client that's
what the client wants to be able to do
in this case the request is to people
you know do a Fibonacci calculation and
you can specify what sort of
what type of people are calculations you
want do you want to do now because these
two things are separated they can't
directly talk to each other so instead
what happens is that the activity the
one system talk to service actually
talks the proxy via a live binder I
should say goes to the binder driver
this service previously essentially went
and here and said hey I'm waiting for
requests the actual service didn't do
that the framework took care of it when
the service is essentially waiting for
requests when this request comes in this
thread now wakes up it gets unblocked
the recruiter request makes its way into
the service via stub the stub takes care
of translating the original request
which basically was you know I mean the
process of sending it through binder
converting to these parcels that their
services are guaranteed wanna know
anything about the service then goes and
gets the request and does act on the
request by taxing the request is not an
important because what it does it's at
that point is up to the service so what
is the purpose of the stub to unmarshal
the request from that from the receives
the through binder what is the purpose
of the proxy to marshal the request
before he goes to the binder now one
particular challenge that we have when
we're dealing with application binding
services is we need to somehow make
those services available to our clients
how do clients find their services well
you may think well we talking about
service manager doesn't they just
register there the issue is the service
manager only permits registrations from
trusted sources so specifically it does
not allow third-party applications to
register themselves with it because if
they could that could lead to all sorts
of security implications so instead what
happens is slightly more kind of
roundabout way of registering
basically what you end up doing when
you're creating a binder service is you
end up having to create a normal service
one of those Android component services
whose job is just to provide access to
this service so then how do we how does
this actually how does the lookup work
well though the way will work is that
the client will submit an asynchronous
request to the activity man
- one of binary mode servers that
becomes a binder call to the activity
manager service again another binder
call which then uses the package manager
to figure out which application actually
has the service that we want to bind to
and the package manager somehow figures
out that we have because we map we
somehow register we'll talk about how we
register services I mean at that point
the package manager service goes to this
service and says okay time can build you
once the service gets instantiated this
again simple service goes in builds an
instance of that I could go not to
service that's the one that the client
wants to talk to and then we take this
object and we essentially send it back
here so now the client has essentially a
remote binder hands along to that object
seems very convoluted and it is there's
never I wish I didn't have to draw them
in your lines in the screen I know it's
you're looking for complexity yeah I'm
trying to sell you and binder and yet he
doesn't look that easy but once you get
a hang of it once you know once you do
it you know once or twice actually
becomes very very simple because it's
mostly boilerplate code now and that's
why the way the reason why we have
things like messenger because they take
care of some of that boilerplate code
for you know how how does this all work
so here let me kind of give you a couple
of ideas first when you're creating
binder services one of the first things
you want to do is you want to create
these common interfaces that will be
shared across clients and services now
because you want this interfaces may
contain you know custom data types right
like we talked about like say air bar
class well because the dis custom data
types are going to be used by both
service and the client you generally
don't want to copy their code between
different projects so the recommended
approach is to use what's known as the
library project so in this case I would
create a Fibonacci common as essentially
a library project people not too common
would be a very simple you know Android
project they will just define the
interface in this case the interface is
called AI Fibonacci Service a IDL file
and that interface defines five methods
these are fitness right so given some n
give me the Fibonacci of n and you
couple of different algorithms this
particular class can do calculation
using inter iterative approach or
recursive approach or using Java or
using the C++ how you need it and then
there's a custom class or another method
called fit which doesn't take in a
simple perimeter that takes in a request
object and returns a response object
these are custom classes so here's what
we actually have to deal with these are
still in business so what is this
request and object look like by the way
all this code is available and gets up
later should you want to look at it so
don't worry about you know me skipping
orders so what does this look like this
are syllable sorry this request
you know Fibonacci request may for
example include two types or two
parameters or two pieces of or two
fields I should say some end that you
want to get a Fibonacci off in some type
of the algorithm you want to use which
is just an enum
well yes we could have written is as two
different parameters of our binder
parcel but in this case we wanted to
have a single class to kind of
encapsulate this request so we imported
parcel one wants to implement first
level you end up having to describe how
you write this to parcel so here's how
we write an integer for long to a parcel
here's how we would convert essentially
for example and email me into a parcel
right we write it as an integer and then
on the other side we need to have a way
of recreating that from a parcel so
given a parcel recreate the original
request so again you just have to read
it in the same order in which we wrote
it pretty straightforward kind of like
Java civilization except you don't get
it for free you end up having to do it
yourself similarly here's their natural
response he were not response basically
he's all simple in sparse level has two
longs for example the result of the
appropriate Bonacci operation plus the
time it took to perform the operation
say we have been stood in for whatever d
but your business and again implements
parcel and again he has to go and
implement a right to parcel and create
from parcel okay so that's essentially
like serialization except it's your on
your new to do it once you do this
basically it will happen next is that
the a ideal to automatically generate
this i fibonacci service so i think
we're not reservist again will include
five methods but this time is dominant
that's it so that's how you define the
common interface now you want to
implement it right in this case to build
another class or another project call
Fibonacci service what that does I'm not
gonna go into details of you know how I
did it I just focus on the code that is
the actual implementation that
implementation extends from that stuff
remember how we said there to stop the
stop takes care of the low-level
unmarshal data and so what is this what
do we have to do we just have to
implement the business methods this is
the beauty of binding you really don't
have to worry about you know fitting and
I sort of thread or a sort of looping or
any kind of selecting you just implement
a bunch of callbacks that business
methods you want others to be able to
use so what is our fib ji look like what
we call some library to perform
operations it doesn't matter what the
operation is you know what does this
look like again we just don't care about
it it's just we're just implementing the
methods here's the fit method this is
the one where we actually reading from a
custom object you know we're just
reading the information from the object
as a pure Java object oriented you know
programming model and once we're done we
just return the response this is it as
service developers as essentially we're
creating a binding service right here we
just have to create you know work with
y'all objects the only you know the only
thing that gives away that this has
anything to do it binder is the fact
that we extend from stuff but other than
that it's pure job there are so no
matically they're not try protected so
there this any of these methods can in
fact be involve a multiple concurrent
threads it's up to you into it to
protect the state that's a multinational
previously so they're not these do not
run in a you know some current there are
some sort of a unique lock in fact there
could be up to fifteen concurrent
threads I talking to you at the same
time now how do you actually expose this
to the air to the users to the clients
well here's that law service the window
this is a traditional service that
extends simple service and all we need
to do is that on the method called on
point or in demanded we just return the
service this is the actual service the
client wants to use here's the activity
manager
asking us to give a reference to the
service to the client and we just want
to build a service over here and then we
return it at that point but only at that
point does the binder driver learn about
our service because of service right now
on the oncreate is just local nobody
knows about it except this process only
when it actually hits the binder channel
will the binder driver learn about it
and start to mapping it the rest of
these methods aren't important they're
just here for you know so you could kind
of debug what's going on and I'm not
gonna go into the details of how this
works so here's you you know your date
your service you've registered you just
register it under a custom intent right
you specify an intent filter should say
there has a custom action and now the
clients can find it yeah how do you
write a client well the client again
keeping all the all the basic stuff
here's some of the UI stuff for the
client I'm not gonna go into the car
though that's supposed to work the
client is in this case nothing more than
a simple activity so here's how the
client wants to use the service by its
interface where does interface come from
the a IDL told generated the client even
know that is for the most part doesn't
even know that it's a IDL case the only
thing we'll give it away is one the fact
that has to deal with with exceptions
get a question no I mean that's a whole
idea if the client in this case we want
to have it and be in a separate location
and the fact that both client and the
service can see this call my interfaces
because they share that common library
project with Purvi you started with okay
so instead we ended up having three
different and replicated projects the
common library project which has
essentially our interface and common
data types the service that implements
interface and the client that wants to
use the interviews okay so now what do
we do so the client wants to use the
service let's see how the client uses
the service okay I'm just going to
scroll down to write to that here's
where the client uses the service it
builds the request and then down here
inside of an async task which you should
never go and create a successful for
this but it's it goes and says service
dot fit notice how simple this it's a
simple object-oriented call
the client has no knowledge that this is
actually a remote call except for the
fact that the client needs to handle the
remote in his action if the service were
to fail halfway through executing the
call while they will fail with their
with an exception so outside of having
to handle this remote exception you
really don't even know this is a binder
call the one thing that does affect
other than this remote exception give
that away is that is the difference the
process of binding to the service to
begin with so how we use a service is
extremely straightforward we just use it
as if it was local object we block until
the service returns to us how we find
the service is the part is slightly
convoluted so here's how the client does
it in this particular case in this case
remember the service is just a bloke
already defined by an interface so how
do we initialize it
well when the client resumes it asks the
activity manager to bind to the service
we bind the service by essentially
saying hey look for some some service
that implements or acts on this intent
and then use it to bind to the actual
service you want now when we do this
what we pass to this bind method we pass
in the intent we want to bind to but we
also pass in a reference to in this case
this this being a service connection
essentially it's an interface that we
implement on ourselves which essentially
forces us to have two callback methods
on service connected and all service
disconnected this is how we find that
when we in connected right so this is a
asynchronous call that's the part that's
different from binding to system
services which when it comes to system
services you just directly ask the
service manager hey give me the service
and you get it right away either get it
or it doesn't exist that's it and it
happens instantaneously where's my list
in this case you submit a request and
then down the road you receive the
service now how do you receive a service
you basically receive a services and I
bind their object now that's all very
nice and dandy but you don't know know
how to use ID binary objects this has a
wrong type
so what do you do you essentially ask
this stub to give you a proxy over that
object this is where the proxy comes in
play now you don't see this as a proxy
but behind the scenes what this will do
is will actually give you a proxy which
matches the type you're expecting which
is this type over the service what is
the proxy do remember the proxy will use
this generic object and submit to it
generic transactions with parcels you on
the other hand you don't want to think
in terms of transactions of parcels
you'd want to think in terms of
essentially method calls with Java
objects so the how this works
you can take a look at the actual
generated code the code it will generate
a ideal we're not understand it right
now I'm just kind of telling you this is
false and so that's it when you want to
disconnect in this case like for example
and on bind you simply say I wanna
unbind for the same service connection
and at some point in the future you're
gonna get a call back that you've
disconnected in this case you can for
example make this object in all this bro
you can kill the process no I mean
doesn't even matter you no longer have
reference to it that's it and basically
if you were to try to run this the rest
of this is by the way just you know XML
code and whatnot generic plumbing so I'm
not gonna go over it the client looks
like this essentially in fact I have it
running here you can come in and say you
know 43 or 46 43 products for people not
to you of ji you keep this and it will
give you the result it will tell you
what is the overhead of producing the
result for transferring over binary
whiskey zero milliseconds it's actually
binders extremely efficient to prove
this is actually happening you can do
you know any shell you know PS and
you'll actually see that I have two
different applications that are talking
to each other right so the client
doesn't have a need to keep ability of
producing to burn arteries and results
the service doesn't have a UI so they're
communicating over long enough I can
assure you this is happening by the
showing economists we bind the reports
this was actions but we don't have the
time so in the last couple of minutes as
we're gonna run out of time I just
wanted to mention that binder also
supports what's known as an asynchronous
motor motor operation asynchronously
simply is slightly different let me kind
of give you a quick overview there in
this particular case what you do is you
you create typically a listener so you
can receive the response from the client
and as opposed to getting the response
in the original request submit a favor
request you get a tip response you
basically create an interface they would
have a callback with a response
now our original Fibonacci service very
clear interface now as opposed to
returning something it returns nothing
but it takes in your listener so what
makes this one-way array synchronous is
this one keyword called one-way this
keyword essentially becomes a flag that
tells the binder driver that the client
doesn't want to wait for that response
because there's nothing to wait for
it's avoid anyways you basically
immediately return from the call what
happens is that when the response is
finally produced by the client the
service the service will send the
response via this listener so here's
where the service will now look like
just let me just show you service
basically has a fib method which now
returns void but takes in a listener
this listener is implemented by or
defined by an interface again a Java
interface what the service doesn't know
that this listener is now a proxy to the
actual listener who lives in the client
so how does that service use it he just
goes and calls listener
here's your response and it sends the
response back right doesn't return
usually just do every third night sends
it back via a coma the benefit is the
decline that I wait for the service
while this was hyper the client you know
the client could have done the
submission all right so UI thread or the
loop retiree without having to kind of
use async bindery async tasks or
anything like that now the the binder
the one thing one challenge whether you
have to deal with when you're using
listeners or I should say asynchronous
binder is when these calls come back to
you to binder or any calls that come
back to your binder they actually come
back to you over a binder thread not on
one of your UI threads so what does that
mean if the client were to try to read
on the listener callback and update the
UI to display how much basic weight you
know the response people fail because as
you know I mean Android the non UI
threats cannot touch the UI so what is
the challenge was how do you resolve the
challenge well typically what you do is
in your listener you don't update the UI
but rather you create a message and then
use a handler to drop that message the
actual response you got on to handler
which then casts puts that message on
there on the message queue the UI thread
picks up that message sometimes in the
future and then reacts to it and we can
then update the UI if you don't know
about message accusing handlers and
fortunately we don't have the time to go
over it but I'm just kind of you know
ask you to look at it for yourself in
terms of I'm just gonna wrap this up in
the next two minutes if you don't mind
sticking around for that long
sharing memory there's not there's no
built-in mechanism for sharing large
memory buffers in Java in blue binder
but at the same time you cannot send
through binder transactions more than
one medical data so you cannot just take
them trying to blob up there and just
send it across so unfortunately you have
to be split observe the memory sharing
but that's only available in C++ how you
do this is through something called ash
mem which essentially gives you file
descriptors of remember images that you
can share I'm not going to go into
details you can look at it on your own
intrusive limitations I already
mentioned there's only up to 15 threads
per process and only up to 1 mega for
the any concurrent transactions you have
between you know client and the driver
in terms of security I'm not going to go
into the details and I do invite you to
look at this later but basically finder
doesn't directly secure anything but one
of the things that it does enable is
that it provides the information about
the sender to the receiver the receiver
can then use the information about the
sender to determine whether the sender
has the right set of permissions to make
that call and most of Android security
is enforced this way so binder doesn't
enforce security but it provides
information which is critical importance
for enforcing security this kind of
shows you how they're works the code
down below
this actually gives you the coal
permissions how you would go and make
your say services secure and I'm not
gonna go into the details of it I'm just
going to ask to occur yourself on your
own in terms of other features there's
the death notification mechanism which
is also very interesting you can kind of
take a look at how how it's used as well
as a reporting that's built into a new
binder that's about it hopefully you
guys got something out of it I apologize
we have to rush through a lot of things
there are a lot of additional resources
if you're interested that you can look
at a lot of these have to do with
internals and then androids own
documentation has guides and how you can
use it in the application space the
video from this as well as the slides
will be posted in their URL and if you
have any questions I'll be here for a
couple of more minutes and actually I'll
be leaving and we can talk as they leave
outside so thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>