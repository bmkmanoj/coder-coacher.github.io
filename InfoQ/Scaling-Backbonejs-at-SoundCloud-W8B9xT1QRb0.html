<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scaling Backbone.js at SoundCloud | Coder Coacher - Coaching Coders</title><meta content="Scaling Backbone.js at SoundCloud - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scaling Backbone.js at SoundCloud</b></h2><h5 class="post__date">2013-05-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/W8B9xT1QRb0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so yeah the name of this talk is
remedies for back pain scaling back when
Jesus soundcloud caveat is obviously not
going to solve all your problems but
it's kind of a look at how we solved
several problems and just some kind of
like best practices and things that
really helped guide us build our large
single page app so yeah I'm Darryl
Darryl Stephenson I'm a front-end
engineer at soundcloud we most of the
engineering is actually out of Berlin
and as far as professional credentials I
guess I had enough to work on a
production app there so that's more than
I guess the necessary if you guys have
any questions just you know I asked me
on Twitter or I'll be around so yeah so
some quick assumptions about this talk
is that you already know it back when j
is is this is it it's not going to be a
talk that really is introducing the kind
of standard patterns or what a model or
collection of backbone is so if you're
not sure what backbone is you're
probably in for a bit of a weird ride
and I'm hoping also that you have some
kind of awareness of single page
application patterns maybe you've been
kind of keeping up to date with
different blogs and you've looked at
kind of competing libraries and code
bases so what are the what are the pains
that we're going to talk about here that
the first one is this boilerplate issue
that a lot of people come across
backbone the pain of using a public API
I think this is this was specific to our
case but I know this is kind of like a
trend in a lot of companies who are
using single package applications and
and when n gets big enough to deflect
tables or cause frustration or however
we pronounce this characters so current
scale it sound glad we have 30 million
registered users and growing 10 hours of
audio or uploaded every
so we have a lot of activity on the site
and this iron single page app has been
our default production app since
December 2012 obviously it's been a lot
of work before that probably about I'd
say about a year of development first
with a proof of concept and then after
we had a beta program for about six
months and finally when live with it on
December 12 so yeah and as far as lines
of code it's about 37,000 lines of code
currently and which I guess in the scale
of really large apps is actually quite
small but for JavaScript apps great
large and then eighty percent of that is
jeaious so just to kind of give you a
mental picture of you know what kind of
things were interacting with a lot it's
really heavy on JavaScript so this is
what our home page looks like who here
has used SoundCloud or know what it is
okay awesome so I don't have to do too
much explaining but the purpose of
showing a lot of these views is that we
can see that these are all kinds of like
different views within soundcloud all
within the same app and so this is a
stream page so if we're logged in users
they get basically a newsfeed of sounds
coming through my Play account is super
sad so check out my tracks and also we
have these kind of listen detailed pages
so first this is like the obvious
question when people always ask like
what's your splits your stack like you
know what woody would you what are you
building on so Sam Sann manager to I
guess is really like the core of sound
God currently I mean you can't have
stamped out without sound obviously this
is an open source library it is
basically a bridge between flash and
html5 audio it uses you can do a lot of
different configurations to save choose
html5 or choose flash
and you know given a lot of the the
current standard of html5 audio it's
really good to have this kind of flash
ball back because certain certain pieces
just aren't there the the triumvirate of
jQuery backbone an underscore we use
handlebars for our templating with a lot
of helpers one of the really great
things about handlebars is that you can
write helpers for it it required jsuis
use in a development environment so
basically to keep code fresh to keep
line counts exact so when you have you
know in an error or you set breakpoints
you know exactly where it is and then
there's almond ge'ez which is a
lightweight loader that we put into our
build when the app is getting built out
to production and they're both like said
these are links to them you can check
out in these slides later yeah and of
course we use node.js but only for our
building tooling so really to compile
there's some a bit of kind of like a st
walking and some other fun stuff but
yeah there's no kind of production
servers hitting notes just really for
tooling and then we have homegrown
deployment tools I really wanted to
include this bar because I think is just
as important to have super strong
deployment tools when you're doing a Jas
app and to keep these the kind of
feedback cycle when you're working you
know really fast and you kind of can get
fixes out or you know respond to user
feedback as fast as possible if you want
more info about actually like the stack
implementation we wrote a blog post
think about six months ago it's called
building the SoundCloud and there's a
link there and I'm just google for it as
well it's got a lot more of these like I
said these implementation details about
what is kind of going on at a
foundational level yeah so on to the
first one
boilerplate so here's a quote this
boilerplate is the product of much
research and frustration this is a get
blame from the readme of backbone
boilerplate which is actually an open
source repo that is kind of aimed at
solving this issue that you know is a
common problem to people using backbone
is that they feel that there's a lot of
boilerplate it takes a lot to get
started building an application on top
of it and you know this is like I just
wanted to have this quote in here to
really show this is this kind of common
issue to building an app on top of
backbone so what exactly is the
boilerplate though well first of all
backbone is the small compact library
and it has a couple heat concepts in it
but like I said it's a small library you
can actually sit and read the code and
put most of it in your head in a single
reading so a lot of this is actually
just building a nap I mean when we think
of boilerplate it's not stuff that has
to be repeated this is stuff that we can
actually you know automate away and
abstract away as well so a lot of this
is just building an app on top of a
library this is not a framework that is
going to put you out and you're going to
be writing apps in you know five minutes
and you know everyone will be happy then
there's also the workflow an environment
which is build tools file creation file
watching these are super important to
have as a really strong base in your
project obviously you need to be able to
iterate fast and you know the better
your development environment is the the
better kind of code you'll write because
you're not struggling against some extra
thing and then there's the kind of some
boilerplate that comes from application
internals which is basically sharing
model instances across views especially
when you keep your coat modular sharing
these models between views is a problem
that you
backbone doesn't offer a solution for
and really writing a modular view system
backbone is least opinionated about
views so basically the models and
collections the the kind of what you get
there is this pretty tight it's pretty
kind of simple to use and understand but
there's a lot of ways to do views so
most people I think when they go to
build a nap and they see that they have
all this like weather played they're
like oh shit like now I have to do all
this work you know I have to actually
like work on an application I can't just
pull different github repositories and
you know have something out tomorrow and
you know in hindsight this should be
really obvious right it's like you're
building an app on top of a library and
you're building an app with a lot of
user interface elements on top of a
library that isn't really giving you a
lot to deal with views so clearly you
know this is kind of thing I think it
frustrates a lot of people and maybe
they go running to another framework
really quick but what you really should
be like is like that where you're just
kind of like all right you know the main
reason is because you actually get to
make these opinions for yourself based
on the specific use case requirements of
your application so you know there's two
ways to look at it really it is extra
work but it's work that pays off in the
end because you have a system that is
more for your own use case and it
doesn't really get in your way at all so
if we were to look at the balance of how
models collections and views in our code
is about thirty three different models
48 collections and around 200 views so
clearly i mean you show that when you're
writing one of these apps with a lot of
features and a lot of different elements
it really trends towards a lot of views
you're going to be working the views
more than anything else
and actually writing kind of the
interaction in the view a lot you know
and this makes sense if we look at how
an app breaks down you know in the in
the red I've highlighted what kind of
separate views are so play button is own
view badges are titles or its own view
waveform the way from comments etc
basically everything that can model data
can respond to change data or can
basically have any kind of interaction
this constitutes of view so you know
also because many will represent the
same model or the same collection we
start trending to really kind of project
is it gets loaded up on view code so
modular views you know this is clearly
the I think the most important thing
that you need to stress about scaling
one of these apps is that you really
need a strong modular view system and
you need a modular view system with a
lot of opinions because also the library
that you're using doesn't make a lot of
them so really they need to do a lot of
things modularity is not necess you want
it to be self-sufficient really and
within this kind of system they have to
do a lot of different stuff they have to
render their templates mutate data
before rendering in case what you're
getting from the server needs to change
a bit or you may be your plural izing
things or whatever before it goes out to
the template they need to establish a
data source communicate with the model
of course manage their own visual states
this is important to you know we have
maybe applies CSS classes to the view or
alter the view and some other way to
respond to state and setup and teardown
event listeners recently this is kind of
made easier in backbone of the last two
versions really version changes and but
yeah you can also set up other views or
other events yourself and that you'll
need to tear down later
caching template elements this is really
important so we're not doing expensive
Dom lookups all the time and we need to
respond to of course the DOM and other
events and last we need to add or remove
sub views so we really want to have a
composable system where we're adding or
removing sub use this is super important
again and the really the goal when
you're writing your view code especially
your foundational view class is to make
it modular in our project a bit hard to
see but the including of view is really
as easy as including a handlebar helper
and a template with a file path and a
resource ID and really I think this is
this is as simple as it should be
because any other kind of view
instantiation if you're doing it in
different ways as your project grows and
people do this in different ways your
code starts to get really messy so
strong opinions here are super important
so obviously this is how you would
include one this is kind of an
implementation of a simple view we're
writing in common Jas module style which
gets converted later during a build step
but again it's very simple we require
group which is our model we require the
base view class that we're using and
then we apply a class name we include
the CSS from the the view include the
template from the view declare our model
class so that our base view class can
instantiate it automatically and then we
have required attributes and these are
important
so these two here are important because
views need to know when they have enough
data to render and so automating that
away or making that kind of interface as
simple as possible is super important so
we can declare an array of different
properties that we need to check after a
fetch has been made to to make sure that
you know this is all we need for this
view let's render if the model changes
and say one of these observe attributes
changes then maybe we re render and
sometimes we don't even put required
attributes but we'll have an observed
attributes say for something that's
empty and then the this property comes
in then we will actually put the view
into place so really given this this
kind of shift where your app gets
heavier and it adds a lot of views the
view really is the most important class
for code growth it's going to be the
most used but it's the least built out
already by backbone solidifies a huge
amount of shared behavior this is also
super important done properly this is
going to save you bytes in the long run
and keep your application thinner
because you're not reduplicated you have
kind of your foundation it's providing a
way to avoid repeating yourself I think
this is really the most important thing
about this as your project grows is that
how you include that and how you program
that base view class is really what
codifies convention and having
convention and strong opinions is really
what will help your app grow there's not
if you have these conventions in here
and you have these really strong
opinions at this level there's not a lot
of kind of you know concern when you're
working a team with other developers
about how to implement something the
patterns are strict they're easier to
follow and it removes a lot of the worry
of those kind of things so just to sum
up this you know boilerplate is really
building an application foundation
especially when you're building it on
top of a library focus time and energy
on getting the base view class right and
really as much as possible yeah that so
on to using the public API so dogfooding
this term in the kind of exists I guess
in the tech industry and if you go to
Wikipedia you can kind of see this this
like this history of dogfooding where I
guess there was a commercial about
someone feeding food to their own dog or
something like that then it became some
buzz words circulated in 80's Microsoft
and you know I heard this a lot and
we're sure you all have and what this
really means is like using your product
the same way a user would and this is
really about you know if you use your
product the same way user would you can
experience the same frustrations but you
also have the power to go back and kind
of solve these first these frustrations
but it sounds weird right like what if i
told you a dog food i mean this this
idea they were eating dog food i think
is it's kind of bizarre and i think that
you know if the goal of this is really
to ensure like high product standards
and it surely there are other ways other
than doing exactly this way and this
kind of a funny story that i know it's
like my second day of working at
soundcloud and i guess we had had a
phone conversation with dan webb from
twitter and he was like the single I
page application approach like it's not
working out you know and this is like
six or seven months into soundcloud
building of the single page app using
the public api and he's like just not
it's just not going to work we're
transitioning a bunch of stuff back to
the server
and you know like doing so we found you
know we've got a lot better results so
of course there's that worry and you can
read the blog post about it but again
like you have to think what is your use
case in these scenarios and and not get
like so cargo cult dish about these
things as well like really think like
why would you dog food why would you use
your own product in the same way are you
really using it the way other people
would I mean clearly there's other ways
to maintain high standards like metrics
I mean attaching metrics to your app is
a really great way of course contractual
agreements if you really want to have
you know a highs you know basically
standard legally binding is pretty good
motivation face-to-face with builders
understanding your users so talking
about the good things about public API
the data is there in a lot of cases like
you're already offering it to public the
people so when you start going down the
approach of a single page application
you're not being blocked at all there's
no services to build it's already
handling a large amount of traffic it's
there it's usable and it has probably a
lot of what you want you know
concentrates common business logic as
well so if you have a you know the
desktop site and the mobile site and
then maybe you have your Android and iOS
clients or you know different clients
can consume your API in the same way and
of course is once you start putting this
into production it demands high
availability low latency all the kind of
features there are things that you
expect from a reliable service but the
bad stuff is really that it's far too
generic to be performing in scale and I
think this is this is a really huge
thing and also it's inflexible because
of external obligations once you have
built something like this and you have a
public API and people start using it you
want it to be stable you want it to be
fixed you want you can't you know
mess around with the properties as much
because other people are depending on
this as well so you have this kind of
unspoken contract most the time to serve
people a quality API so for an example
this is a standard playlist JSON
representation that our API would serve
and you can see really that there's a
lot of a lot of properties on here I
mean we're we're giving basically any
consumer of this API all of the data
because we're not actually sure what
they're going to build with it right I
mean you're serving a bunch of stuff so
that people can actually use it so we're
including other kind of sub models as
well you know so like I said that idea
it's too generic so what we really would
like is actually I think that my slides
go to sing so huh
there we go so what we really would like
is a playlist representation that looks
like this that is short succinct it's to
the point it's what we're going to need
for our basically our app chrome that is
in the client and you may think okay
well these this JSON representation the
difference is probably not that big
especially when you factor in latency
and going to the server etc but if
you're doing this thousands and
thousands and thousands of times and
even you want to load hundreds of these
into the client then it does make a
difference not just in sheer data or
share through throughput of JSON but
actually parsing the JSON as well into a
backbone collection so it's really good
to get specific with these things so
yeah so again when your data sources
isn't flexible you start running into
problems and what happens is the client
code gets the brunt of it because you
can't shift the code on the API but you
know we have this client app out there
that we can actually put some kind of
logic into but you start adding more
complexity into it because you have an
inflexible data store and you start
doing more expensive operations in the
client which is really bad you don't
want to do a lot of complex sorting
filtering maybe you want to to kind of
have a shuffle feature for example you
don't want to like over fetch hundreds
of models to just shuffle a couple you
just need you want some service that
will give you five shuffled and
ultimately you're also start making more
request to the API which is really bad
in terms of performance we want to make
as little request as possible obviously
so for an example of this this is a user
profile in the top we have a spotlight
section which is basically a it's an
editable section that a user can adjust
based on their disease that their
desires maybe they want
showcase a couple latest tracks etc and
then below that we have just the kind of
normal stream so ideally in in backbone
world this would break down into a
single collection maybe where the
variety the the actual representation is
different a little and we could say okay
put the spotlight items on the top and
the rest of the items going to the back
or at the bottom of the stream but the
problem was that they were actually do
different noticed data endpoints so
functionally they work as a single
collection the design is to be
functional as a single collection but
remotely they're completely different
data so you start running into a real
like problems sorting out how these are
going to work on the client examples of
this so like like I said the cleanest
implementation is really a single data
object / view / functional view the
design treats items functionally as a
single collection but the server
providing end points for each collection
you start getting into complications in
is this collection ready is this
collection ready how do we know into
Wren render what happens if one has an
error etc and then you start really
freaking out you're like this is not how
this backbone abstraction is supposed to
work at all and this is supposed to be
really kind of simple actually in that
server provides the data it's a source
of truth for our application and we
present that
a really nice way so obviously you know
you have to you have to get flexible
tree services here's an example of a
place where we have a completely
separate service actually serving the
data now so we release a feature where
pro partners and SoundCloud can
customize the backgrounds of their sound
to offer some more brand awareness all
those images and that data is fed by a
totally separate service and it was
really easy to work with similarly did
the same thing for recommendations it's
actually through the API to avoid
caching but it's not like a public route
or anything and again it we were able to
from the star map this into a really
cleanly dividing representation from the
server again for the explore page and so
after working with these like three
examples of situations where we were
able to decide what the format of the
data works with and be flexible and have
fast iterations you know it was like ah
this is this is a joy again the you know
like this is really pleasurable to work
with and this is really where the
abstraction shines if you're doing too
much complicated filtering an
overcompensation on the client your app
is not going to scale very well you're
going to really run into a lot of
problems so in summation I really think
that using a public API doesn't work
well at scale I know you know if your
app is on it I would definitely say you
know try and move into flexible services
that don't have external Ella gatien's
as soon as possible and it's really it's
all about having that flexibility being
able to bind or to kind of set up your
roast presentation and feed your client
out properly so comments on soundcloud
are a very special thing
this user saying soundcloud user
comments attached to songs are iconic
and life-changing and this one says a
special corner of internet hell the
inane comments on soundcloud tracks and
like I understand you know it's
commenting it's in its commenting on the
internet but you know between those two
mixed positions is like you we have to
support this and obviously it's
something that a lot of people are using
and so that leads me to this point is
when n gets big so n is just a kind of
random thing and n might be big at a
certain level based on your use case but
for us we've seen like when n gets big
really in relation to comments so this
is Skrillex he's a really popular
dubstep artists electronic musician and
this is just like three sounds from the
top of his stream if we look at the
counts for this you know we have like
1000 10 65 almost 2000 1612 on a
waveform that respond to time as well so
if we think of these set up totals we
have about 4,800 comments just on those
three sounds and then so like just to
kind of you know complete some
arbitrariness not all of them were going
to show right away of course we have
about say fifteen percent percent
replies and you know a bunch of
off-screen things so in the backbone app
kind of model you have this collection
of comments and a template maybe a loop
on a template that would render these
out so the initial template based
approach with this it worked fine on low
counts obviously we was using a list
item you know it seemed like kind of a
standard implementation and we have
actually this list view class within
our code base that helps manage lists
and insert things the correct place and
you know each list item say make about
four nodes in the Dom you have a list
item say maybe a link and a legion a
span maybe to shower hide text so now
we're at 16,000 320 nodes and we're just
showing three sounds so thumbs these
days are pretty good they can handle a
lot of nodes but Skrillex has 50 sounds
and we have infinite scroll so as we're
heading there now we have if you were to
scroll from the top of his page the
bottom we have 272,000 Dom knows just
from commenting alone so common symptom
of this is I'll snap browser crashes or
if it didn't crash and you were somehow
able to hang in there it was really
incredibly unresponsive scrolling was a
real pain and that whole user experience
is ruined basically that the whole
reason we're building these single page
apps is to really have a concrete
awesome user experience and we've
totally wiped it out just you know
putting comments on the Dom so of course
you can do some kind of limit enforcing
where you say hey we're only going to
show 200 comments / sound but we still
end up with about 40,000 comment nodes
and it's in a stream and of course
there's you know some other tricks of
hiding these things but one of the
problems with this implementation is
that even if you didn't get the all snap
which sometimes you would I mean we're
dealing with computers that have you
know higher amounts of RAM lower amounts
of RAM some people have other processes
running that are picking up things and
it still is not performant and what's
worse you've actually ruined the reason
you're showing comments in the first
place which is some kind of visual
indication of the popularity of a track
basically all tracks over 200 comments
now we're going to look exactly the same
so you know you've done this you've
actually ended up with a still poorly
performing product and you've actually
ruined the kind of design a motivation
for doing this so you know there was a
lot of thinking and we decided to go
back we started to say back to the
canvas we don't need templates for this
like a dong based approach is just not
going to work here so we went with
something which are actually loading all
the comments onto the canvas the beauty
of this approach is now we have one node
force / sound that can handle an
arbitrary amount of comments and the
initial memory profile barely changes so
you know it's kind of a really efficient
way I mean it's hard to get more
efficient it's in the way of Dom nodes
of having more than one person or just
one percent so there's obviously no
template in this view there's just a
reference to the canvas context so we've
kind of changed it a bit but it uses the
same patterns for collection events
which is super nice because actually
working in that that way you're still
within the backbone framework of
handling data and handling events on
data so how it works we actually just
preload all avatars create different
objects for each one and put them into
an array and have a we have a win all
method and so when all the comments are
loaded in a single quick loop we write
them out to the campus and then because
canvas is not that great to work with
for interaction you have to start
testing mouse points etc we have some
separate views that sit on top that are
just very light ways to actually
interact with the comments but of course
like you know you're still making tons
of requests loading thousands and
thousands of comments in this situation
which is also kind of crazy so we were
like well let's let's go even further
here
we're going to limit this to the last ex
comments the most recent whatever it's a
it's a configuration variable that we
can use we're going to draw the last
comment avatars and then we're going to
draw the actual amount of lines that we
have in a repeatable way on the waveform
and so which is helping us solve the
problem of you can still get that visual
information about which ones are ultra
popular by looking at the the waveform
itself so this is a before and after
it's a little hard to see in the slide
but the top one is actually loading all
the the comment avatars and drawing the
lines out and the bottom one is a the
optimized version where we just generate
the lines to draw to create that
information based on a single count
property and then the avatars are set in
the bottom so obviously there are some
slight differences they're definitely
not as recognizable if you're not
attending a talk about optimizing a
canvas and how this whole thing is
explained but generally this really
serve as well in getting us list to this
point where now we have an optimized
implementation of comments on the
waveform and so you may be thinking like
oh well that's just a trick you know
like I you know this is this is just a
kind of a visual trick and my sponsors
yeah it is and and I'm okay with that so
obviously in this case you know canvas
is not some magic bullet for performance
at all and in fact like you really need
to decide where it makes sense in our
case it works super well I mean this is
a point where a template and a backbone
kind of collection and template thing
just couldn't meet up to basically a
scale need of having tons of nodes but
they're also kind of special in this
case and that they're in a high density
in kind of a small space and it's highly
visual so there's no text you know and
the information is pretty easy to grab
as well from just loading in the images
so i think the lesson here really is
break out of the standard pattern where
it makes sense and and you know that
module review system you set up again
when you have it set up like this you
can break out of this pattern and it
actually doesn't take much effort at all
to break out of this pattern our our
campus view is really basically setting
the tag of the backbone view to canvas
and then we had chained that the context
after we render it and the great thing
is is that this backbones view opinion
is flexible enough to support this kind
of thing later on down the road and it's
really a kind of unexpected thing so I
mean when you have something in the base
that doesn't make a lot of opinions
about how views are refreshed to be
rendered you really have the flexibility
to kind of think outside the box and
solve solutions in different ways so a
little more trickery this is a playlist
of 2012's best subject dubstep tracks
it's 10 hours and 14 minutes long it's
composed of like a hundred and seventy
different songs or sets and it's hard to
tell in this photo but there's actually
dividers in between every wave form the
design idea of this is to view sound not
as you know of a list but actually it's
kind of like a single wave form you know
this is one of the things that we're
known for and we really want to keep
that kind of brand and recognition alive
so our standard way of loading waveforms
before was actually to load an image and
then draw that image of on the
canvas and then recently we change this
over to a flexible service that actually
just gives us basically a large array of
1800 amplitude points for the waveform
so now we just have a JSON array which
is by far a far more efficient object
when we want to just write things out of
the canvas but we're still in a use case
like this making a hundred and eighty
fetches or whatever 180 requests to get
these waveforms but if you look closely
at these waveforms there's actually
these are all the same waveform or at
least these ones here are not the same
so those are the ones you can recognize
actually this whole wave form in itself
is composed of pre-selected kind of
random ish looking waveforms and then we
just write that out from only five files
or so so don't tell anyone that but
obviously it doesn't make a difference
in that sense if we draw the whole
waveform out right I be people can't
tell that's not the point to analyze the
wave farm in such a small context anyway
so really if the view is compressed into
a very small space just draw a fake
choose from a pool of pre-selected ones
possibly cached on the client the page
is much faster at that kind of level you
can't tell any way everybody wins so the
lesson learned here is really illusions
can go a long way and I think that I
mean it sounds funny it sounds like hey
we're tricking people but if we think of
so much of our best practices in
front-end development there's actually a
lot of that I mean and it's not just you
know substituting out waveforms we're
loading HTML into the
the window so we can have something to
render before the JavaScript loads in to
bind it and a lot of what we're doing is
kind of hacking visual perception and I
think at scale a lot of these things
work incredibly well and you know the
whole reason we're doing this is really
for this user experience so yeah
conclusions a strong modular view system
is really I think one of the most
important keys to growing your code base
gracefully especially when you're basing
it on a back one library public api's
are inflexible and they can put the
burden on the client use flexible
specific services for your production
application instead don't be afraid to
ditch the standard view canvas solve
certain problems extremely well and
sometimes an illusion is as good as the
real thing so thank
my questions about the when you were
building this view system did you look
at any of the these other third-party
libraries that build on top of backbone
and draw any conclusion to see any
promise in any of them yeah i mean i
think that when we first started I mean
it was one of the first things that you
have to build when you build these
applications and I think that at that
time there wasn't a lot of like super
well-developed ones well I was writing
this talk I recently went back through
and I looked at marionette and it looks
like it has a lot of the same ideas I
haven't haven't used it so I can't say
if you know how well it works but it
seems like it has a lot of the the kind
of pre-built modular view kind of
composable abuses in the place I have
two questions first is how are you
handling internationalization and second
is are you rendering on the server or
are you sending out empty pages to the
client yeah I'm so first question of
Internet say sure that we're not
actually doing anything for
internationalization right now which is
not really an appt issue it's more of
like we want to be able to support and
have customer support and community
support for people in different
languages before we actually introduce
that into the code obviously so it's
more of an issue of having that piece
first and the second one was sorry
server-side rendering yeah so we're not
doing any server side rendering for the
staff right now which is something that
we will have to do eventually but this
app is grown out of basically an older
app which is a rails app which we still
serve two crawlers like perfect instance
Facebook we want to have the Open Graph
tags so we serve that to them for Google
actually has been interesting we've seen
if you google soundcloud results and
look at the page preview they're clearly
on the single page apps and they are
actually caching and indexing them some
quite well and some not so well so i
think that we want to explore some so
Lucien in the future where we can render
these just for for BOTS but right now
we're not doing it okay thank you yep hi
thanks the talk was really good it's
very helpful especially for coming from
backbone and getting started one of the
questions I had was the view that you
showed as an example was had a very
declarative syntax is it really that
declarative or do you have a bunch of
functions under there for responding to
events and then also I saw your
packaging CSS and templates in there
yeah that's something you do every where
and how does that actually get bundled
in when it gets deployed yeah sure um so
as far as the declarative I mean it is
pretty declarative yeah I mean like a
lot of the if like for instance if you
have a collection that you've included
and set up you already get some events
bound and then the prototype would have
on click on whatever or the standard
events hash the backbone uses so most of
it is pretty declarative we also have a
mix in system that I didn't go into but
that helps kind of make some of that
transparent and for the second if it's
the second question yeah it's a
packaging the CSS so yeah it's requiring
it there right so we have this in our
dependency graph so we can actually look
and see which the SS you know we need
and then we just bundle this together in
order and and put into the DOM and we
also have a build step that makes
basically a base CSS file out of
everything before it goes out so yeah
putting it like working with CSS and
that way is really nice actually I would
say like where you have each of you has
a JS file for the actual view
constructor of the view class and then
you have you know the template and the
CSS and they're all kind of in the same
they live in the same place and their
concerns are very much only about that
exact view so that's that's how it goes
there's more information on the CSS
actually in that blog post about
building the next sound gud
thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>