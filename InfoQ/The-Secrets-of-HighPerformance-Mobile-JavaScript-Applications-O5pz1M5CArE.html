<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Secrets of High-Performance Mobile JavaScript Applications | Coder Coacher - Coaching Coders</title><meta content="The Secrets of High-Performance Mobile JavaScript Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Secrets of High-Performance Mobile JavaScript Applications</b></h2><h5 class="post__date">2014-09-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/O5pz1M5CArE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks everyone for joining me in this
session about
I'm really excited to be here in forward
jazz because I believe that JavaScript
is shaping and will continue to shape
the future in that future there are no
kind of network of websites it's a
network of things or a network of
applications so to speak it's kind of
contradictory to what Christian heuerman
said in the keynote but it's going that
way so that's why mobile is so important
in that feature and you as everyone in
this room is a part of that feature and
it's kind of really exciting to be in
that kind of transitional area or in
that kind of transitional era but let's
rewind back from the future and go to
the present time so picture this you're
in a line just trying to buy some snacks
and your movie is just about to start
soon what will you do next
chances are that you'll pick up your
phone and start playing flappy bird or
poking poke someone on Facebook or I
don't know do it checking on checking on
Foursquare which has been so warm right
now so it's ridiculous but anyway or do
any bunch of other things that it
doesn't take too much time or too much
attention the thing is there's some kind
of hidden anxiety in this situation
because you don't know when the cashier
will call you next so this kind of lack
of time and lack of attention is really
exactly the reason why mobile
development or creating a fast intuitive
simplistic and responsive mobile
application is really off premium and in
start I'll try to emphasize on why
creating or developing for mobile
environment is harder than it seems what
are the typical challenges and
limitations of mobile and what we can do
to overcome them but before that let me
briefly introduce myself my name is
Vulcan and I'm a mobile engineer at jive
software and jive is a platform that
does social business collaboration so to
speak or you can think of jive as
something that makes Monday morning suck
less so my website is seen in here my
github handle is this one you replace
all with and
because there was a namesake that is not
me and you can find all the slides and
source code of this presentation in my
personal website so you don't have to
appreciate the excretion or copy down
everything but feel free to do so
there is no you know disclaimer or
something basically and having said that
in this talk in a nutshell we'll try to
figure out whether it is still possible
to create a little fast and intuitive
and snappy JavaScript application in a
mobile context given that we are limited
by every possible constraint imaginable
in a runtime environment that's not so
friendly to us so javascript is kind of
a different beast and when you dive into
it you know be it on the server side or
the on the client side it's all the
debugging and closures and callback
hell's and memory leaks and all the
stuff and being in a limited container
as in mobile just amplifies that kind of
pains in the rear basically and we are
trying to we'll try to see and figure
out how to solve those kind of issues
but before starting the session I'd like
to emphasize that whatever you hear is
is totally dependent on the context so
don't take anything for granted just
know that the important thing is not the
tips and tricks that I share in here
it's the process it's how you approach a
problem how we solve it things might
have been totally different in your
situation and the only way to know that
what's working for you or not is to
actually test it measure it and
benchmark it
given your particular setup or scenario
having said that let's dive into the
challenges and limitations of mobile as
a platform Mobile has several
constraints one of them is the network
communication the other is the lack of
battery or the power usage the other is
the memory and the other is the
processing power when it come when it
comes to network communication and
network is really expensive in more
in terms of legs and delays and
connectivity issues and also battery
consumption is a major issue because
everybody knows if you have an iDevice
the battery dies in a day that's that's
what kind of sucks and you have to be
really cautious about what kills your
battery and you have to take special
precautions against them and also memory
is not as much as a desktop browser so
in a typical mobile device you have if
you're lucky you have a gig of ram in an
Android device you have half half a
gigabyte of RAM that's shared with all
the applications that's that are active
on the device so it's not too much and
the other thing is processing mobile
processors are not designed to do fast
computations instead they are designed
to dissipate as little heat as possible
and also they are designed to consume as
as less current as as possible which
makes them slower than their desktop
counterparts basically so we have those
kinds of limitations we'll dive into
each of them as the time goes on so but
one important thing is the battery
because all of those constraints are
kind of tied to battery consumption as
well the more network you use the more
you consume your battery the more
complicated your javascript is the
faster your battery dies and no matter
how pretty your application is or no
matter how you know useful your
application or simplistic your
application is if it sucks the better
like a sponge then the first thing that
the user does will be uninstalling the
application and the second thing that
the user does will be swearing at you
publicly on Twitter and I have seen that
so it's not my company but I have seen
people just shouting at other companies
in Twitter because they are draining
battery too too fast basically and there
are a bunch of factors that kill your
battery one of them is network requests
because your phone is nothing but they
you know shiny than the radio antenna or
radio radio basically and the radio
communication takes a lot of power so
the more network requests you do the
more Ajax calls you make
the more kind of power states changing
your mobile application the faster your
battery will drain so a way to overcome
this will be to either cache stuff or
bad stuff and send instead of sending
five requests sending a batch request
and receiving the response in a batch
way and the other would think that
consumes your battery is JavaScript
because javascript is processing and the
more JavaScript you have the faster your
batter will be drained and there are a
bunch of issues to it one of them is the
complexity of the JavaScript so the more
kind of object oriented to your
structure is or the more objects you
have around or the more interaction in
it so if you have a really complicated
pops up pattern that does some elegant
architecture chances are that it might
be consuming your battery that you might
need to revisit that
architecture in the context of mobile if
it's really it's for a desktop
application it might not be that kind of
an issue but in mobile you have to be
you have to learn to be frugal and the
other thing is images as a rule of thumb
you should not display any images that
are not inside the viewport and secondly
you have to use as little images as
possible the ideal I don't know in an
ideal and there should be no images
everything is like boxed and there's no
shadows no gradients but we don't live
in such a you know scenario so you use
your own judgments the less images the
better basically and the the last but
not least piste is done because dumb is
a really big monster to compute with or
compete with and as a rule of thumb if
you have more than 5,000 nodes in a page
or in a viewport or if you have more
than 12 to 15 levels of Dom lasting then
your applications performance will
gradually degrade so you have to try to
keep the number of Dom nodes constant on
your application when we consider all
those constraints we tend to see that
mobile and desktop are although kind of
looks similar they are different they
serve four different purposes mobile
this kind of more lightweight more
general-purpose and desktop or contra is
more powerful basically but it doesn't
mean that you cannot create a fast and
intuitive application in mobile just we
have to know your environment if you can
embrace the fact that Mobile is
something more general-purpose then you
can really create a really nice and
dandy and fast applications for it
and we have to be fast because as we
have seen before our users want us to be
fast and sometimes it's they want us to
be faster than the desktop application
because the users have really limited
time if you are on a line waiting for I
don't know some form to be processed and
somebody's calling you next you don't
want to just click the button and to
load an application or you don't want to
wait too much you have to your gestures
and your responses should be as
simplistic and as quick as possible
because you know users have limited
attention limited time and also limited
precision you know the fingers do the
fastest at the cursor and when it comes
to speed there are a bunch of dimensions
of the speed one of them is a network
layer over all network communication the
other is the performance in rendering
how fast you can render stuff the other
is the caching layer and the other is
reaction by reaction I mean half has to
use the response how how smooth the user
gestures are and the other is the
overall JavaScript execution how fast
your loops are how how optimize your
functions are and there are literally
books written for each and every single
topic of on this and in this talk I
won't be diving into too much details of
this and instead I'll try to give you
some cursors or pointers so that you can
if you're interested you can dive in
deeper or read books about it or go to
videos and watch the videos because it's
too much stuff to cover in 40 minutes
time basically and so let's start the
funnest on the network communication
network is in Mobile is
really expensive and the expansion that
is not the bandwidth is the latency
because we know that we try to create
minimalistic applications in a mobile
environment therefore we don't consume
the network a lot it's basically a plain
text JSON request or response and we
don't send too much data and we don't
receive too much data but the thing is
each and every single HTTP request you
make can come up with a latency of half
a second or one second and seeing three
to four seconds of latency in mobile
environments depending on the devices
radio communication state is not
uncommon so you have to learn to live
with latency latency is not a luxury
it's a given in mobile and you have to
work around that as we will see further
and to reduce the latency or to fight
with latency there are a bunch of
approaches that we can take firstly the
the fastest Network request is no
network requests at all so if you can
put your assets like CSS JavaScript some
images I don't know some files locally
on the device and serve them locally
that's the fastest way and if you cannot
you can utilize caching techniques and
also while you do an ajax requests use
kind of a smart caching technique with
which you don't have to do the request
over and over again if you have it in
the cache just serve the cached version
and the other thing is to decouple the
user experience from network activities
and we'll see an example of this soon so
2 pi by decoupling I mean you have to
abstract your data access layer so if
you in your mobile application code if
you see some kind of request like this
this is not not the best way to do it in
in this piece of code we are simply
doing a network request to a REST API
endpoint and it's really seems innocent
but we can do it better so instead of
doing this kind of a simple request we
can try to abstract things and
abstraction is a double-edged sword so
if you abstract things too much it will
be harder to maintain harder to read and
it will become slower in terms of
performance but certain parts of
abstract
or certain parts of code when abstracted
may be more beneficial to you and let's
see so one of the places that you cannot
abstract with the data access layer
because you will be doing a lot of
caching logic and a lot of access
manipulation and all the black magic in
the data access layer therefore being it
abstracted away will decrease the impact
of regressions and all the code problems
basically and the other thing that we
can abstract is the rendering layer
because once we abstract a render layer
then it will be much easier to spot out
Dom related performance problems if if
the jquery or the whatever done code
dump filtering code you use is spread
all over your code base then it will be
really hard to benchmark things it will
be hard to isolate things or write test
cases for it writing a test case for a
you know webview is a different topic of
its own and whether we should write it
or not is also a separate topic of its
own but abstracting Dom at least help
it's to isolate the issue a little
better and the other thing is latency
and as I said it's not the bandwidth
that's the problem
it's latency in the mobile network and
mobile network requests are expensive
and I won't dive into too much detail
because it's the real topic of its own
but you can keep in mind that the
latency and all the sluggishness of the
mobile network is due to the extreme
complexity of the wireless mobile
network architecture and if you want to
have in-depth information about this you
can visit this link and get ilya
grigorik excellent book on the subject
matter it's free to read online and if
you can if you want you can purchase it
and get a print copy if you like and
it's the perfect week I suggest if you
have time to read it and you know get a
grasp of the overall be background of
things so the bottom line is latency in
mobile is high and latency is mobile in
Mobile is highly variable and therefore
to sort things out you have to have an
offline mode as we have seen in the
beginning of
of this event offline is not a luxury
anymore you have to have an offline and
you have to plan for an offline access
because we are not always offline or
online if you are in a conference room
you'll try to fit allowed and drink
those you know wireless access code and
then pray for the conference gods that
the access code will work as its it's
supposed to be but most of the time
conference network sucks so offline is a
is a part of mobile mobile life
basically and to have an offline mode
you have to have a caching strategy also
and also you have to have a intelligent
backup strategy so you try a request if
it fails you try it once more if it
fails again you try it once more with
increasing intervals like in two seconds
in four seconds in eight seconds and if
still if the requests still fails you
just give up you don't try it over and
over again because trying to network
connection over and over again also
consumes with battery and also it heats
up the device I don't know if you I have
experienced this myself and probably you
have to there is poor network
connectivity and you see a loading
spinner in the phone's screen or at some
kind of a network connecting indicator
and the phone is literally burning in
your hand that's the reason why the net
the the phone is trying to connect to
the base tower and it's not getting a
good communication and is trying to
retry the request over and over again
and the problem is in that kind of a
scenario first phone hits and the the
the heating of the phone means that the
battery is draining and they it's it's
kind of a double device problem so the
phone is heating and your battery is
draining like a like like lightning and
it's too perfect reasons for your users
to hate you and uninstall the
application and then you know curse you
had Twitter basically and the other
thing about performance or speed is the
rendering layer and when we think of
Larry rendering CSS pain times is not
free and there are a bunch of CSS
properties that
we need to pay special attention to and
those are shadows and gradients and like
big fonts or custom phones kind of and
when we combine one or two or more of
these kind of things it might become
gradually slower so especially if you
are trying to do cool CSS animations or
cool CSS effects on a big list of scrub
big infinite scrolling list then you see
that the performance of those collection
is not as we expect so the less CSS you
have the better basically
and also it's true for animations you
can as a rule of thumb think that on
mobile the animations will be if you're
if it's JavaScript written the
animations will be around three to four
times slower than its desktop
counterpart so try to use as little
animations as you can and try to use CSS
for animation because it's GPU
accelerated and it's optimized for just
animating or moving stuff around but
this is not also a hard and cold fact
that you can do if if a you know if
jQuery based animation works for you
then go ahead with it but just test your
assumptions basically but CSS is always
faster than a script based animation
basically and the others think that we
can optimize on the rendering layer is
templates and when it comes to templates
going logic list is has a bunch of
advantages one of them is the template
is generally at the bottom of your
rendering hierarchy so the more logic
you put into the template the more
complex your overall flow will be and
probably you are repeating the tap
template in a repeater structure to
render a kind of either nested tree of
strings or list of items and the more
logic attached the slower the overall
flow will be so the other advantage of
the logical templates is swap swap
ability basically so if you have some
server-side templates and if you have
some client-side templates and then once
in a while you decide to move the client
site templates the server or take some
template from the server and render it
on the client you find out that a
logical approach which will be much more
versatile than
trying to figure out which parameter
goes where or how we can express the if
log in that template language in a
different way in the server-side
template and the other thing is try to
try not to nest your templates and by
the same token try not to nest your view
objects we will see a bunch of examples
regarding that soon so but before that
let's see our biggest enemy basically
and our biggest enemy is DOM and there
are a bunch of reasons for it one of
them is the fact that DOM is a slow and
synchronous API and when you try to
access a Dom element or when you try to
change the DOM
since JavaScript a single thread then
you're kind of tossed the unless the Dom
operation completes your UI and your few
eye freezes entirely therefore the less
you touch the Dom the better and there
are a bunch of ways that you touch it
the Dom but you don't know of one of
them is just reading an Dom attribute
even if you read an attribute on Dom
like a offset top or offset left or a
border kind of dimension who backs back
sighs the diode we a bunch of style
recalculations that will trigger layout
thrashing and which will make the things
slower so try not to read them try not
to write to Dom so what else you can do
but the thing is try to catch things as
much as you can so if you are reading
some attribute from them just put it in
their place and then use the cached
where the instead of trying to read all
it over and over again and if you are
trying to write something to Dom one way
to do it is to detach all the nodes and
do the manipulation offline and then
reattach the nodes back into the Dom
tree and the other way is to kind of
yield your operations with a set timer
so that it doesn't affect the overall
flow of things but the bottom line is
the last you touched down the faster
your application will be
and there are there are ways to measure
the effect of your dumb manipulation or
CSS manipulation and there are tools for
that so if you are using Chrome
developer tools and if you enable the
continuously paint mode then you can
take two different you can play with the
viewport you can add some CSS rules some
Dom elements change the HTML and change
and see what kind of layout combination
is faster or renders faster or has a
higher frame rate and if you want
something more granular then you can use
the high resolution timing API and in
this example we are basically doing that
too so in this example we are first
created getting an element and hiding
the element and flashing all the style
changes then displaying the element and
flashing again the style changes and
taking to timestamp differences in
between and the the difference between
those times times is a rough estimate
about how how the overall gendering or
overall rendering load or rastering
little lot of that chunk of element is
and to make it reliable as in every
statistical thing this kind of test
should be repeated over and over again
and then cut the edges should be cut out
and then the entire results that should
be averaged out but at least this kind
of approach gives you a more granular
way of controlling things or measuring
things and aside from opera chrome opera
opera has a CSS profiler and I'm sure
Firefox has a similar profiler too but I
have not tested the other profilers
myself and the other thing that while we
were discussing is not to nest view
objects and we are seeing an
anti-pattern that does it in this
example so here we are appending a child
not document fragment by calling a
render method with overview object
basically and the only purpose of test
this view object is just to create an
HTML chunk and a pantry a Dom fragment
then this kind of newly-created view
object is discarded for garbage
collection and this is too much of a
burden for our precious garbage
collector and especially if this is kind
of representing an infinitely scrolling
list or a really fast changing part of
town then the garbage collection will be
will be kind of shooting ourselves in
the foot and we can kind of create a
simplistic capital approach and instead
of using a full-blown view object that
we will be discarding and not using
adult we can use a simpler template
based solution so we can use a
pre-compile template and then put our
whatever data structure we have to just
create a tell HTML to it this is kind of
better because first we are using less
objects and the the less amount of
objects we use the the less let's force
on the garbage collector that we'll have
and the second thing is since the
template function is precompiled it will
be kind of faster and we can do better
though so instead of using a template
function if we know the difference of
what parts of the page change we can get
the Delta of the changes like this
section of the page changed and this
section of the page hasn't changed and
then for each change in our change set
we can just pinpoint and change modify
that part of the Dom this is kind of
implementing a virtual Dom approach that
that react.js and other libraries are
doing but my my point is not that my
point is the more optimization do you do
is the more complicated or the more
complex your code gets and therefore you
have to know which parts of the code
base to optimize because optimization
comes with a maintenance cost with
itself therefore if you are in a you
know world full of optimizing and
optimizing and you come to this kind of
a conclusion that you have to take a
delta and loop all the nodes and kind of
come up with a faster solution just
benchmarking
think whether it's worth it or not maybe
it's worth it maybe it's not but it
totally depends on your application and
you cannot know whether it's a
productive approach or not if you're not
measuring it the other thing is jank
busting and I don't have too much time
to dive into this as well and I strongly
suggest you to go to gentry that org and
watch all the videos and all the
tutorials there because it's a hell lot
of information there to consume and they
are really quality resources I can say
that you have two goals to hit in terms
of creating a jank free application one
of them is to create a 16 milliseconds
per frame kind of animation and the
other is to have a consistent frame rate
to maintain a frame rate consistency you
can utilize the you
requestanimationframe api and it's not
an easy task but it's not the hardest
thing at all so it's not rocket surgery
basically but it's it takes some time to
you know practice but it's an important
thing especially in mobile because the
mobile users are less patient than the
desktop users basically and the other
layer that we can optimize is the
caching layer and we have seen that we
have a problem about the unreliability
of network latency is a killer in mobile
and network requests are expensive in
terms of response times and the solution
is to batch your requests and then cache
your responses and utilize offline mode
and all that jazz but when we try to
come up with a caching solution we open
another can of worms so such as where to
cache there are a bunch of places that
you can cache and one of them is html5
application cache which sucks therefore
it's hard to you know deal with it index
DB has issues with it web sequel is not
supported anymore and in most kind of a
scenario when I bump into this kind of a
scenario my thought would be to call
with the dumbest solution that have in
hand that works so because if it works
and it's dumb then it's not
basically local storage tends to be the
simplest solution it's a simple API is
standardized
it's well-behaved it's really fast it's
just like a key value store and some
people complain about the you know io
rate of the local stores say that you
know the local storage requests are
causing a blocking i/o and that might be
slower which to my observation is not
the case because the it's not the i/o
it's the it's not a oh that's the
bottleneck most of the time it's the
rendering Saddam it's a parsing it's
layout thrashing it's much higher or
much different things that you need to
focus on and when we decide to use local
storage then we open a different problem
box which is what what caching policy
that we should use and one of them is
one of my problem is the size limit of
local storage although five megabytes
might seem like a lot we'll soon see you
soon see that it's it will it will be
eaten up in a practical real-life
application as a solution you can
partially store the data or minify your
JSON responses which is a good thing
both in terms of network and in terms of
the object footprint on your JavaScript
application and also you can compress
the data like using a zip like
compression algorithm but when you
compress the data there is also a
decompression overhead so again you have
to test and verify and validate your
assumptions in that I from time to time
I have seen that compression works great
and particularly if you are targeting
kind of more recent mobile devices like
Android click greater than jelly bean or
iOS greater than iPhone 4 then
compression works fine but if you are
kind of targeting low-end devices like
Ice Cream Sandwich and low or iPhone 3GS
and there still are users that use
iPhone 3GS on the planet then a
compression might be an old overburden
in that case so it totally depends on
your scenario
your user base your market basically and
we have seen that abstracting stuff is
useful in certain cases one of them was
abstracting the rendering layer the
other was abstracting the network
communication layer and it is also true
for caching try to abstract your cache
layer and try to have a single cache
entry point this will make it much
easier to detect cache elated problems
and the one other thing is to cap the
size of each of your cache entries
because you would not like a I don't
know a 3 megabyte blog post to or the
JSON response of a 3 megabyte blog post
to consume up all your cache and don't
leave anything behind
and when when we have cache a cache
eviction policy is also required and
most of the time last reason to use the
algorithm is the best way to go but
depending on your application structure
you might want to do different cache
eviction or cache usage algorithms and
when you try to implement that kind of
an algorithm you have to know the size
of your cache and since JavaScript
doesn't have a one-to-one correspondence
of creating a size of a object the only
way to use is to use the JSON that
stringify
of the local storage and this is not a
big kind of a burden because Jason
stringify is a native operation and it
tends to run quite fast I haven't tried
to benchmark and and attach it to the
limits of it but for all practical
production code I didn't have any issues
but while I take the length of an item
by signifying it and the next thing is
the reaction which is the overall user
responsiveness if you can't think keep
working in mind about the reactiveness
you should be considering not to block
the UI basically so if the you Eisenman
is to use it as motion it is in motion
if the user is doing a gesture like
panning swiping zooming
changing in pitching pinching in
pinching out so does the UI respond
accordingly and there are two key
metrics in here to accompany with that
one of them is the 16 milliseconds for
per frame as we have seen before and the
other is a hundred milliseconds per user
action these are the psychological
limits that the users intuitively feel
that the application is slower if they
pass the that kind of threshold so if
you tap on a button and it the button
doesn't respond to you for half a second
then it's kind of poor user feedback
similarly if you swipe something and the
UI doesn't respond and once your gesture
ends and the UI changed its state then
it's also poor user feedback when the UI
using motion when the users hand is in
motion basically the UI also should
respond to the user accordingly and
there are ways to accomplish it as we
will see a bunch of examples soon this
is also kind of an anti-pattern
so in this function we are handling an
AJAX response so what's wrong with that
the thing is an AJAX callbacks callback
has a feature of blocking a bunch of
things one of them is the
requestanimationframe loop and the other
is the main UI thread and it depends
from browser architecture to browser
architecture but generally if the user
is doing kind of some kind of a gesture
and then Ajax callback comes in then the
screen freezes for awhile and you can
see this kind of interaction or lack of
interaction in again infinite the
scrolling list while you come to the end
of the list you try to do another scroll
this the application fetches the data
and tries to put the data to the bottom
of the list while the user is trying to
scroll it and the UI can freeze for a
couple of seconds in that scenario
because it's trying to do too much as a
rule of thumb you can if you can try not
to do any JavaScript action while the
user is doing some kind of a gesture
because there are a lot of things going
on like
like rasterization or things being
uploaded to the GPU and things being
stashed away and rendered back in so the
browser is doing too much and adding a
bunch of additional burden on top of it
is kind of counterproductive and to
solve this kind of issue we can do a
simple modification so we can create a
holder flag that checks whether the UI
is in motion or not and if the UI is not
in motion then we can handle the Ajax
response so this kind of is useful
because if we are sure that user the
user is not doing any kind of gesture it
doesn't matter whether the content loads
in a second or in half a second because
most probably the user is not user is
passively interacting with the UI is
she's either looking at a at an image or
she's reading kind of a title or an
article she's just consuming the content
and it's a it's the a perfect time to
you know gather a different and
additional set of content and try to
prepare for it so this kind of a
solution for that this is not perfect
there will be edge cases but this kind
of at least gives the concept of it and
when it comes to UI and CSS and all the
stuff the next thing that comes to mind
is event handling and when it comes to
thinking about event handling the first
thing that comes to mind is to utilize
event delegation event delegation is a
pattern that has been coined I don't
know six or seven years ago or maybe
before that that that insist on using or
binding the binding events to the
container of a set of items instead of
binding to each and every single list
item in a kind of list and this is a
bunch of users or a bunch of advantages
one of them is you create lesser amount
of functions so there is less code to
deal with and hence there is less
chances of regression or bugs and the
second thing is it uses less memory so
it is friendly or the memory side most
of the time event delegation patterns
are faster there are some exceptions to
it too when we compare certain kind of
tap events on certain kind of items but
these are kind of edge cases and also
event delegation kind of helps with
generally useful the other thing that I
see while attaching and detaching events
in different kinds of codes is a pattern
that you try to attach something you and
then after a action you detach those
kind of events and the most common thing
that I see is during a swipe event you
attach a bungee a bunch of handlers and
when you do a tap live action you detach
those handlers but if we kind of follow
a delegation philosophy then leaving
those handlers intact would be much
better especially if you try to reduce
the number of event handlers and not to
attach and detach email events too much
you'll really see that the overall
application performs better especially
in lower grade devices you want you
might not see too much of an advantage
in and newer Android phone but you can
see it really shines in in all the
androids or older iOS devices and the
other thing about the events are some of
the events kind of fire too frequently
like Mouse events or device motion
events or kind of scroll events and in
those kind of scenarios the best
practice is to decouple the UI
interaction with the event state data so
in this particular example we are trying
to move a Dom node every time we get a
device motion event and this is kind of
a killer in terms of memory in terms of
performance in terms of CPU utilization
and in terms of battery so instead we
can kind of the couple of these events
state from the event action
by using a requestanimationframe loop so
this is kind of a simplistic solution to
that so in the device motion event we
add an event listener and put all the
device in for me all the information
that we are interested in in a state
pack and then we fire and
requestanimationframe loop and when when
we are sure that we can process those
kind of event information we just move
move the object as to the place that we
want to this is this can be enhanced so
this is kind of a simplistic example
just to show the concept but overall
logic is to decouple your event state
from the event application to the Dom
which also is in parallel with the motto
that touch the Dom as little as you can
so and the ideal place to touch the Dom
is generally when the animation frame
file or the animation frame ticks at
certain times because at that time the
browser is sure that it can render an
additional frame and it will be less
damaging than the than trying to render
it at abrupt time timestamps basically
this was delegating the frequent of
firing events and those kind of events
as I said our device motion scroll
anything that you feel like it's firing
like crazy is a target to this kind of
optimization but it doesn't mean that
you cannot do it in every single event
that you have it's just a trade-off that
you have to decide by measuring it and
this is how the things working and the
other thing is the overall execution
speed but when it comes to execution
which is the JavaScript execution we
have to look at the big picture first
because it's not the JavaScript that
should be optimized per se it's the
interaction of JavaScript with the
rendering layer so it's most of the time
is not the the problem is not with the
with a kind of loop or with the kind of
tree balancing I would
that you have written the problem is the
devices trying to render a big chunk of
Dom that they should not or there is
some kind of layout thrashing that is
preventing the application be snap here
or there is some kind of CSS issue or
some kind of parsing issue that's going
behind so it's the intersection point of
the JavaScript plant with the user agent
land or the browser land so no matter
how meticulous to optimize your or I
don't know your tree balancing algorithm
or your search algorithm chances are
that it it won't effect too much in the
performance of your overall JavaScript
execution but as always it's also has to
be measured to be decided for sure and
the other thing is the concept of
entropy this is taken from this flame
chart is taken from a real life
application that we were developing and
we were able to reduce the what you see
in here to half by doing tricks like
delegating complex computation stuff to
web workers and reducing number of event
handlers and joining stuff and getting
rid of a bunch of objects but my point
is again not that my point is the more
my point is the code also your code also
degrades GRA eventually and the the more
time frames you have your code will
expand to fill those time frames
available and also entropy is a effect
in the code as well as time passes by
your code becomes more random more
repetitive more redundant and less
useful therefore you have to keep an eye
on the code always to make sure that
everything is shipshape and the only way
to ensure it is to you know to measure
it or to track it or to profile it and
there is another the other side of the
coin the JavaScript engines are getting
better
for instance Chrome's shadow and
gradients rendering performance is
getting better javascript engines are
getting clever in the finding figuring
out which parts of the code are hat
and they are trying to optimize the
execution of those code the the engines
are using background classes like
special classes and using pre compiled
JavaScript execution to make things
faster and there are a bunch of
corollaries to that corollary one is you
cannot know how fast the javascript
piece of JavaScript code when you take
it out of the context of it because it's
the the performance of the code will
depend on where you put the code if it's
in an isolated test Cades it can behave
differently if it's a non production
application it can behave differently
and the other thing is that's the second
corollary the faster all this
optimization becomes the more things we
push in the device to make it you know
more elegant more shiny more dandy and
it's kind of a vicious cycle so you have
to know your frame budget and you have
to prepare for for your applications
optimization basically and there are
really great articles for v8 engine on
the developer side google chrome web
site i haven't checked mozilla and other
open source project yet but I'm sure
they have also kind of articles too if
you are into that this is kind of a
deeper part of the equation but if you
are into that I suggest you go there and
see what's going on in the background
especially the hidden classes that the
rendering that the JavaScript engine
uses is a really neat approach that the
engine takes to optimize stuff the fun's
part one of the more funnest part is
frameworks and I have a love and hate
relationship with using frameworks
because especially in mobile you have
two limited resources that sometimes
make the make using the frameworks kind
of counterproductive and frameworks are
expensive because frameworks have
economies of scale to utilize the
framework or to make the use of your
framework you have to use the utilize
all the functions that the framework
provides and in mobile most of the time
you
use the entire framework you use only a
subset of it and he also frameworks
increase your dependency and also
frameworks kind of let me think they can
make your application slower because
they increase the memory consumption and
memory footprint as well so I'm not
saying don't use frameworks because
there are good places that you can
utilize them but the thing is at least
try to minimize the framework or do you
use try to detect the parts that you
don't use and chop them off and make a
minified version of yours your framework
and also I have an example to show the
overall impact of the framework code on
your mobile application this is just a
typical setup there is nothing fancy
it's a basically a backbone jQuery
Mobile underscore setup Ponte that I did
is to add a counter to each and every
single of each and every single function
that was inside the framework code and
here are the results so when I add a
bunch of framework code back-to-back I
come up with this kind of a result so
this is just to warm things up and
nothing is rendered on the page yet
there are no jQuery widgets rendered
there are no backbone views created it's
just a warm up code and I can see 6827
function calls just to initiate a single
plain boilerplate code and this nut this
is not the end of the story as well
because you also have to add your
business logic layer data access layer
caching layer and all the helpful
plugins that you have to attach to your
shiny than the framework and then after
we add these all together
it kind of becomes like this so our
frameworks are kind of like burritos
they're delish but they are hard to
consume so you have to think twice
before using a framework and also since
we are in a mobile environment
most of the things that we use in
frameworks are supported by their modern
API counterparts so instead of getting
and using an ID selector you can use
document.getelementbyid II or you can
use query selectors you can add
eventlistener instead of biding a clink
listener kind of so you have to think
about whether to use a framework or not
and this other thing is to optimize is
memory leaks and memory leaks are not
magic it's basically as in every
language it's just counting references
from the root object to a chunk of
objects and if even if there is a single
reference to that blob of objects the
the object cluster will remain in the
memory and it will be seen as a memory
leak and there are a bunch of suspects
that causes memory leaks one of them is
event handlers or an event based
architecture so if you are using a
publisher subscriber pattern or if you
are using an observer pattern chances
are that your memory may leak if you
don't detach your subscriptions and the
other is timers some most of the time
you find forgetting dangling timer
references that can leak memory and also
cache objects that are not being evicted
can cause memory leaks and there are
some not so usual suspects of memory
leaks as well one of them is closures
because closures are a controlled chunk
of memory and you might have a you might
have a cache object inside the closure
that's growing in size and you are not
aware of it and any ear objects like
manager general controller provider can
be a candidate for a memory leak and any
object that touches Dom can leak and any
object that acts like a cache may leak
and profiling memory is really hard
because you have to do a bunch of heap
snapshots and then you have to take
diffs of those images and I'd prefer
root canal
instead of heap profiling every single
given moment in time so the usual thing
is to create a code that doesn't leak in
the first place instead of trying to
figure out what part of your code
to causes leaks and which is hard to say
you know you should not create leaks but
half and in the case that you find out
legs the technique called three
snapshots technique is really helpful
the technique is kind of you to an
action you take a heap snapshot you
reverse the action you take another heap
snapshot and then you kind of compare
those snapshots and it gives an
indicator of what parts of your code is
leaking it's not still the best way or
the fastest way to figure out leaks but
it eases as your pain at least and the
other thing is reducing Dom access since
I I'm lacking out of time I'm skipping
it they last on the less you touched it
down the better the faster and one of
the one way to you know touch the Dom
less is to use less javascript is to
delegate your heavy computational
operations to web workers and web
workers are supported in most of the
mobile platforms so you can yield your
conceptually heavy operations to them
with a with one caveat because web
workers are not free they consume CPU
and they consume processing power
therefore they will drain your battery
so there is kind of a trade-off and you
have to decide what to upload develop
workers and whatnot which takes us to
the subject of being lean and by being
lean I mean being lean in whatever you
do like reduce your CSS reduce your
JavaScript reduce or the idea
communication as fast as you can
to do as little as possible and this
article this Alistair part article is a
really nice article that sums it up and
the other thing is the overall user
perception so if you cannot make
something faster you can always make it
to appear to have been faster and there
are ways of doing it one of them is
overestimating the remaining time so if
it says you know if your application
says there it's it has 15 seconds to
download and the app downloads in five
seconds the user feel like yeah it's
really fast but if it says you know it
has a
longer time to download but it's
downloads even longer that user feel
will feel like it's it's kind of little
slow and also feedback that starts
earlier feels sooner and one think
that's not in the slides is I am kind of
against the progress indicators instead
of putting a progress indicator the UI
should feel like gradually evolving so
like instead of putting a loading
indicator down you can first create a
like a frame or like initial frame of
application then gradually put an image
some descriptive text as the data comes
the UI should progress gradually so that
you know the user feels something is
flowing instead of looking a blank
spinner and doesn't know when they when
they have the spinner will go up and
simplicity is generally a way to go
because simpler code consumes less
memory is generally faster and creates
less problems so when you are trying to
put something to the code or remove
remove something from your codebase
general choice is to remove it and to go
with simpler solutions again a pointer
to the entropy your applications
performance will not stay the same and
if you don't put effort on it your
applications performance will always
degrade and as in nature in code also
entropy always wins unless you put
additional effort to it therefore try to
I know if you're asleep cram user keep
the performance as a as a topic of your
day of your weekly Sprint's or bi-weekly
sprints and keep performance as a goal
as a task to achieve achieve instead of
something that should or should not be
done and that's I think most of the
things that I'd like to talk about and
one other thing is I'm not only one that
comes up with those kind of ideas
actually whatever what I talk in here is
kind of a combined wisdom of a community
of geeks that are bigger than me
and I'd like to suggest if you're not
following them already follow these guys
and this is not a compressive
comprehensive list and you can find more
people to follow always keeping you know
keep in contact always try to learn new
things because every couple of years
some new stuff is coming in making some
of the suggestions outdated that's why I
try to emphasize measuring and
benchmarking always because you don't
know if you have a performance issue or
not if you don't measure it having said
that I'm kind of out of my time so if
you well if you have questions I can
answer them offline and that's out of my
talk thank you for joining me
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>