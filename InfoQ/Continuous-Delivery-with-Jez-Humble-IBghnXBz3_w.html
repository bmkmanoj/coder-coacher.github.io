<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Continuous Delivery with Jez Humble | Coder Coacher - Coaching Coders</title><meta content="Continuous Delivery with Jez Humble - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Continuous Delivery with Jez Humble</b></h2><h5 class="post__date">2012-10-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IBghnXBz3_w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so it's aeneas delivery and why my
experience in full works the works
generally has large enterprise clients
and the process in large enterprise
clients is basically you have this like
agile thing and that happens in the
engineering part of the organization and
you know anyone work in a corporation or
a company of larger than a thousand
people ok so that's about half of you
and has anyone been subject to the agile
transformation then oh yes loads of you
ok so you know how this case some senior
dude decides we're going to go a j'l and
then they hire loads of certified scrum
masters and everyone goes on the 2-day
scrum course and suddenly you're all
taking orders standing up rather than
sitting down and that huge backlog of
work that you can never possibly
complete is now prioritized and
estimated and now we're agile tik yeh
familiar to anyone hopefully yes even
hands going up even just before lunch so
that's obviously resonated with a few of
you so even if you manage to do the
whole agile thing and you're doing you
know iterations with analysis and
development and testing and you know
nice showcases of working functionality
every couple of weeks what typically
happens is that stuff doesn't actually
go live or I said let's calm down
everyone what happens is when the
project is finished that stuff gets
tossed over the wall to testing and then
they go and log lots of defects and then
you have to remember what you were doing
when those defects were logged and try
and fix them and then at the end of that
process assuming you actually get time
to fix some of those bugs the whole
thing gets tossed over the walls the
operations team you then have to try and
make it work and that's usually when you
find out that it works great with ten
users but not so great with 10,000 users
which you were you know supposed to be
getting and a hundred thousand users or
a million users that you actually end up
getting and then you spend the whole
weekend trying to make the system work
and trying to take bits of it down so
the rest of it will work and so forth
and this is very common on unpleasant
experience
so typically you know as a developer in
the room and developers well oh okay
anyone who's a tester any okay couple of
people at the back I noticed yeah
and report developer testers yeah thanks
good job and any operations people ok
few view and even at the front okay
excellent
so welcome to you guys so hopefully
everyone is familiar with this as an
engineering as engineering people as
developers you try and get stuff dev
complete right that the dirty secret of
IT is that dev complete is essentially a
meaningless term what actually matters
is does it work in production with
realistic datasets under realistic load
and when things go wrong and that is
very far from def complete and this part
from dev complete to actually delivering
value is often called the last mile
which is kind of a dumb term right
because it's only at this point that
your stuff actually starts delivering
about you right that's when you start
getting a return on your investment
that's the first month that's the
beginning of the life of your system and
then hopefully if you've done something
right then your system will live for a
reasonably long time and that will be
the bulk of the consumption of resources
and worker on the part of everyone
actually building the system so I've
worked in this environment it sucks it's
a stupid way to develop software and we
shouldn't do it anymore and that's
basically why me and a bunch of other
people in Thor works and indeed a bunch
of other people in many other areas
independently came up with these ideas
can we do better yes we can do better if
you go to code or flickr.com scroll down
to the bottom you can see they're
deploying to production multiple times a
day
Facebook deploys once a day XE deploy
multiple times a day
Amazon deploy multiple times a day yeah
this is actually very common these days
for web-based systems to be deploying
multiple times a day so yes we can do
better I was kind of trying to come up
with a title for the book and I'm really
bad at names I was once in a bank all
the chutney ferrets and and so I was
kind of the year the book was published
was the ten year anniversary of the
agile manifesto and I read the ad I
manifest
you know and you know everyone knows
that this over that but there's also ten
principles and the first principle of
the agile manifesto is this and I read
this and I kind of won well yes
obviously this is this is why we all get
out of bed in the morning right whatever
we do and so this is a really good title
for the book so how do we achieve
continuous delivery this is how we do it
hopefully you're testing your software
who has automated tests that they run
they actually find real bugs okay that's
a decent proportion of you maybe two
thirds so hopefully we run those pretty
often ideally every check-in but how
many people are testing their
configuration changes if they change you
know the number of threads in their
database connection or their Apache
configuration how often do we test that
in the same way that we test our code
anyone doing that okay much fewer of you
how often are we testing database schema
changes and automating database schema
change rollout any of you okay few of
you again much less of you any change to
your system can break your system I can
bring break I can bring your system down
much more quickly by changing in Apache
setting than I can by introducing a bug
in the code it takes ages to get a bug
in the code life right but changing the
perhaps you setting bang there goes your
system down so why aren't we testing
those changes in the same way that we're
testing our code changes it's nuts
any change to our system should be
tested and validated in the same way as
code changes and the idea is with
continuous livery is that we're
performing those validations all the
time and we get rid of this waterfall II
system instead we start building what in
the and the Lean Startup movement is
called the Minimum Viable Product and
iterating rapidly and making sure that
our software is always production ready
that we can always release our software
at any point that I can take the latest
good bill press a button release it into
production and be confident that it's
not going to break anything so we never
are trying to we're basically removing
that last mile altogether that goes away
and what that means is when you as an
engineer so I am def complete what you
mean is
I'm actually ready to go live done is no
longer deaf complete done is released
into production and hopefully I learned
whether what I did was a good idea in
the first place and then what that does
is it creates this magical
transformation where instead of releases
being tied to how long it's going to
take for a change to go through the
chain Advisory Board instead we're
constrained by whether the business
thinks it's a good idea to release
business is never asking IT who are you
releasing our companies know we have to
wait two weeks for the next release
train to go out or a month or how many
people are releasing at least once a
year that should be everyone who's not
releasing at least once a year
anyone okay or no one's going to admit
to it fair enough who's that who's
releasing at least once a month okay
it's about half of you how many people
are releasing at least once a week okay
a handful how many people are releasing
at least once a day okay a couple of you
more than once a day congratulations sir
only dude in the room that's cool so
that's a magical thing because what
happens in that situation is someone
says well maybe we can try this out and
you go yes sure I'll code out something
that is a proof of concept for that idea
and you push it out there and you gather
some metrics and you find out is that a
good idea
often it's not it turns out this is the
problem with waterfall is that anytime
you have an idea we should build this
usually you will be wrong about that
especially when you get into the detail
about where you're building that's the
biggest source of waste in the software
development process stuff that we build
that's never used already used so what
happens when you move to continuous
delivery is you can get really fast
feedback on your ideas and waste all
that time that you were building stuff
that no one's going to use and actually
focusing on building stuff that's
valuable and it transforms the way the
organization works it's really magical
anyone who's moved to this way of
working nobody wants to go back to the
old way no one's like oh I wish we could
have releases once every a year ago and
that was so much better no one says that
everyone's like hey this is really
awesome and we should totally you know
well if you move from that an
organization that does that's another
organization it really sucks it's
worldly unpleasant
so how do we do that three ingredients
automation of build test deploy all
those processes that are often manual a
bunch of patterns and practices and
collaboration between everyone involved
in the delivery process that's how you
achieve continuous delivery and there's
three ingredients one configuration
management which means I should be able
to take a box plug it into my rack in my
server farm plug in the power plug in
the network and have that box serving
transactions in a completely automated
fashion I should be able to provision
that box provision that Osprey vision
the middleware configure the middleware
deploy the correct version the
application configure the router
configure the storage in a fully
automated way and have that system
provisioned and processing transactions
in a fully automated way as a developer
I should be able to take a new
workstation plunk it on my desk plug in
power network BDU keyboard all that
stuff and be able to run a single
command to check out from version
control everything I need to build and
test and deploy the system to any
environment I have access to and be able
to do that using a single command that's
all aiming for in terms of configuration
management second ingredients a config
continuous integration which I'll talk
about in just a minute and then the
third ingredient is automated testing so
here in this room practices continuous
integration your hands up okay keep your
hands up keep your hands up get more
people put your hands down if everyone
is not checking into mainline into trunk
at least once a day if that's not true
you put your hands down you're working
your feature branches that aren't merged
into mainline least once a day
put your hands down if every check-in
does not result in a build and a run of
all the automated tests put your hands
down
okay the people who still have their
hands up adding to disintegration say
congratulations to you
it's about a third of the room
continuous integration is not running
Jenkins on your feature branches
continuous integration is a practice not
a tool one of my favorite presentations
on continuous integration is by gate guy
called James Shaw he wrote an article
called continuous integration on and or
a day but he describes how to do
continuous integration using an old
workstation a rubber chicken and a bell
and it's just about I make a change I
get the rubber chicken no one else can
check in while I have the rubber chicken
I go to the work station I shake I check
out trunk with my changes on it I run
the bill I run the test if it passes I
ring the bell ding and then someone else
you get the chicken if it goes wrong I
keep the Roberts chicken I have to fix
my the the the change that I made that
was bad or if I can't do that in a few
minutes I have to revert it from version
controls that other people continue
working that's continuous integration
continuous integration the key word here
is integration which means that all the
changes are integrated into mainline if
you're not integrating your changes into
mainline then you're not drinking this
integration by definition you cannot
have feature branches that last for more
than a day and be doing continuous
integration because it's a contradiction
in terms
ok now there may be valid reasons why
you're doing feature branching and there
aren't actually that many but you can't
say you're linked to this integration
and be doing Peter branching it's just
not possible
so I've kind of describes the workflow
faculties integration I build something
if it passes I get the latest from trunk
and merge and check that my changes
don't conflict with someone else has
changes if that part is then I push my
changes back into trunk and then that
triggers a build which runs the
automated tests and if that all passes
then yay I've done a really great job
and the key thing is this what we've
just described everyone's committing in
so trunk into the main line at least
once a day
continuous integration automated testing
my favorite quote of that quality is
this one from a guy called W Edwards
Deming and he has this to say this is
applied to manufacturing but the same
thing applies to software development
and this has two really important
implications for software delivery
implication number one testing is not
something that you should do after
you've developed the functionality
testing is something that we should be
doing all the time
mass inspection in software means manual
regression testing after development is
complete and that's crap it's a really
terrible way to get a high quality
product and it's a massive waste of your
precious resources you're human beings
if human beings are doing manual
regression testing that's a massive
waste of human resources as my colleague
Neil Ford's says he was here a minute
ago he's just left for weeks he's heard
this before if humans are doing the
things that computers could be doing
instead all the computers get together
late at night and laugh at us this is
nowhere more true than if you have human
beings doing regression testing it's
stupid it's a waste of time humans are
really bad at doing repetitive boring
things over and over again we suck at it
because it's just so boring and when you
suck at doing something that's really
crucial to the quality of your product
you should probably think of another way
to do it so we should all be testing all
the time which means building a
comprehensive suite of automated tests
and the second thing is testers are not
responsible for quality everyone is
responsible for quality testers are
really important they're the people who
find the bugs that you never would have
thought of you do exploratory testing
and who helped to build and maintain the
Suites of automated tests but they're
not responsible for quality all of us
are responsible for quality testers the
job of tested is to make the quality of
the system transparent so that you can
then make decisions about what to do
about it but they're not responsible for
quality we need to build quality into
our products and that means we all need
to take responsibility for it
so I'm going to gloss over this and just
say well listen there's this guy called
Brian Merrick who invented this thing
called the test quadrant diagram which
categorizes tests according to two axes
whether they critique the product or
whether this support programming and
whether the technology facing or
business facing this basically describes
all the kinds of tests that you should
be doing on your software from you
tests that are in by developers that
test small sections of the code in
isolation the opposite ends which is all
the manual stuff that people should be
doing because it requires intelligence
and imagination and all those things
that computers don't yet have showcases
usability testing exploratory testing
and then these other quadrants
functional acceptance tests the tests
that the software delivers the expected
value to its users and down at the
bottom here the stuff that everyone
forgets until a week before release to
production which is performance testing
testing security all those things that
make sure your sigh actually won't go
down the moment it's launched or your
credit card details won't get stolen or
all these are they're kind of less
critical non-functional requirements I'm
joking
all these things you should be doing all
the time and the way you do that is
firstly you have to create those tests
but then you have to create a deployment
pipeline to run them what's the
deployment pipeline it is this you have
a process for going from check-in to
live the deployment pipeline is the
manifestation of that process it's a way
to model and get visibility into that
process to get feedback on any change
you introduce to the configuration or
code of your system and to get control
over that so that people can
self-service the actions they require
like provisioning a testing environment
the latest build or deploying to staging
or production without having to raise a
ticket and wait for a week for someone
to provision an environment so that you
can deploy to it all this stuff should
be push-button eventually automatic and
everyone should be able to see what's
going on and everyone should get rapid
feedback on the effect of the changes
they introduced so the deployment
pipeline looks a bit like this the idea
is I make a change I take it in that
triggers a build of the system and
running the unit tests and if that
breaks this should take a few minutes
certainly no longer than 10 minutes and
then I get fast feedback did the change
I introduced break something if it did
everyone stops what they're doing
someone volunteers to fix the problem
no one can check in unless they're
checking in to fix that problem or you
might revert if it's going to be
difficult problem to fix
once that has been made to work then you
trigger the next stage which is running
a comprehensive suite of unit tests so
the feedback is slower because they're
more comprehensive but it's more
comprehensive so this might take a
longer you know an hour or two large
products have tests that might take days
to run end-to-end you run them in
parallel on a massive grid and you get a
rapid feedback
Google had so I think tens and millions
of tests and they run them in
less than an hour I think in parallel my
massive compete quit so if this fails
then again everyone stops they're doing
someone volunteers to fix the problem
and then everyone else can Caroline
working and checking in but there's
someone who's highest priority is to
keep the system working and if this is
really important with continuous
delivery you don't prioritize
functionality you prioritize keeping the
system in a good state keeping the
system working and in a good state is
more important than delivering
functionality so that's you know the
most important change if something is
broken you stop the line and someone has
it as their highest priority to fix that
problem and then once you have a bill
that the automated test pass someone
downstream gets a notification
this is deployable to production or this
is deployed all to a state environment
they can then press a button and deploy
that build or any other build of their
choice to the staging environment and if
the user acceptance testing shows that
the functionality is what what actually
we wanted to do in the first place then
someone can press a button with the
appropriate authorizations to deploy
that build or any other bill into
production and the idea is this the
deployment pipeline every check-in
results in a build every build is a
release candidate every build is a
release candidate and what the
deployment pipeline is doing is testing
the build the build is like a mythical
hero in a Greek epic and the mythical
hero wants to marry the beautiful woman
but first he must pass a series of tests
he must fight the evil monster and get
the big bag of gold and descend into
Hades and have an emotional reunion with
his father and then once past once the
heroes pass all these tests then he can
marry the beautiful woman and it this is
what we're doing with the deployment
pipeline every check-in results in the
build and you're trying to prove that
the bill is not deployable and if you
can't prove that the bill is not
deployables n the build is deployed and
you can press a button and deploy and
not worry and if you have even the
slightest amount of adrenaline in your
bloodstream when you press that button
to deploy to production what that tells
you is that your validations are not
good enough and you need to make them
better
so it becomes very simple but what's not
simple is convincing your organization
that you have to prioritize keeping the
system in a good state over delivering
functionality that's the hard
conversation
I'm not going to solve that problem for
you in this talk so we're kind of
running short of time I'm just going to
make a couple more points and then skip
to the end one of the key things that
continuous delivery aims to do is reduce
the risk of release people don't like
continuous deployment because they think
it's risky this is actually not the case
what's risky is releasing once every two
months an enormous raft of changes that
you can't possibly know the effect of
over the course of a weekend and then
having it go horribly wrong and trying
to fix it or roll it back what's not
risky is releasing a three-line code
change which you validated and run a
complete suite of regression tests
against using a production like data set
into production and then being able to
revert that changed if it causes any
problems with it almost immediately in a
very simple way that's low risk and
casillas delivery aims to reduce the
risk of delivery because you have all
these validations you're running and if
something goes wrong it's super easy to
fix it because you know what the root
cause is it was this three line change
or this configuration changed actually
or this database schema changed I made
and it's really super easy to revert it
that's how we reduce the risk of
releases so you need to automate
provisioning and deployment and ensure
developers testers and operations people
collaborate throughout the process this
is the essence of who's heard of DevOps
anyone who have ops okay so DevOps
basically is this saying everyone should
collaborate and we should find ways to
automate the process to reduce the risk
of delivery the problem is operations
people are rewarded for things not going
wrong whereas developers are rewarded
for getting releases out and those two
goals are in conflict so that goes wrong
all the time because operations people
change equals risks so they want to
prevent you from making any changes
for developers you want to change things
DevOps is about saying well listen
actually these two things are not in
conflict and we can find a way to ensure
that everyone is happy and the way we do
that is making developers responsible
for it for things going you know when
things go wrong the developers take some
of the responsibility for that and it's
actually the developers problem if the
system goes down not just the operations
people so there's a whole set of
practices and patterns around this that
I don't have time to cover now and I
kind of want to skip to the end of this
point there's a lot more I could go on
for hours about this stuff but you know
it's nearly lunchtime
I don't wanna be between you and your
lunch so the last thing I kind of want
to say is that none of these problems
about implementing continuous delivery
are technology problems the tools the
patterns the practices all exist to make
this work today
however weird or hards your environment
is you can do it I'm not saying it's
going to be easy it could be really hard
especially if you're working on a legacy
code base in C++ of ten and a half
million lines you know I went to an
organization recently that had this
system and they want to see you
continuous delivery and like well guess
what it's going to be hard but
nevertheless it may be really valuable
for you to do it so all the problems
really a people problem is not
technology problems it's possible to do
this larger organizations are doing it
all the stuff we talk about in the book
continuous delivery of stuff that's been
tested and is known to work even in
really large distributed organizations
so first of all when you're doing this
you have to get everyone together at the
beginning so anytime you're planning a
new project anytime you want to make a
change the way people work a process
change you have to get everyone together
and make sure that everyone's on the
same page and they understand the
consequences of what we're going to do
and then it's going to suck for a bit
and it's going to be hard and make sure
that everyone is actually on board with
it and then keep meeting throughout the
process the most important hour to our
practice is the retrospective because
that's the heartbeat of any change of an
organization it's where you say here's
an experiment we're going to try maybe
we're going to try automating some more
tests maybe we're going to try doing
some continuous integration maybe we
going to try checking our mainline
you run an experiment and then in two
weeks you come back and you look what
happened with that experiment was it any
good was it the right thing to have done
and you evaluate it you actually don't
need any
to tell you the practices that you need
to do all you need to do is get together
as a team every couple of weeks run
experiments find out what the results of
the experiments were and then run some
more experiments and that's how you get
better what you're doing that's it
that's how you make things better all of
you could go home or go to work right
now and do that and make something
slightly better you know that's really
the message of DevOps in in some ways
that everyone has the power to make
things slightly better just by going and
talking to other people and finding out
ways you can collaborate to make things
a little bit better visibility is really
important making it easy for everyone to
see what's happening is the latest build
appliable are we able to meet our
performance requirements how are we
progressing you know in terms of
actually functionality that's
deliverable not functionality that's
definitely and then like I say Jesus
livery isn't a project that you're done
with it's part of continuously trying to
make things better at what you're doing
and everyone can do that and that's
really the essence of it so that's all I
wanted to say I know we're kind of at
12:30 but hopefully since I started five
minutes late there's time for a couple
of questions the question is what I
think about tools like lightbox that
allow for more more immediate feedback
well force is actually one of the
initial investors in lightbox it's
something that we think is a really
awesome product I mean there's a great
talk by a guy called Brett Victor like I
remember the title of but if you search
for Brett Victor be ret Victor on Vimeo
you'll get his talk and it's super
awesome and he basically says it's
impossible to create to be creative if
you can't see what you're doing you need
to be able to see what you're doing and
that essence of creating things and
being able to change something and see
the results of that change that's what
enables us to be creative and if you
have to wait hours days weeks to see the
result of the changes you made it makes
it impossible to be creative it makes it
impossible to run experiments in code so
really continuous delivery I mean
fundamentally is about reducing that
cycle time getting maximising feedback
and getting as much feedback as fast as
you possibly can and yeah absolutely
development tools where you can make
changes to the code and see visually
what the effects of that change are on a
running system I mean it basically is a
repla environment that shows you
immediately what the effects are on a
bunch of input parameters it's really
super cool
absolutely I think that's a really great
tool inventing on principle was the talk
by Brett vector yes thank you so
question is how do you address security
in continuous deployment well the
general rule of continuous delivery is
this if it hurts you should do it more
often and you should bring the pain
forward so if it's painful to get
security right you're not doing it often
enough if you're waiting until your
project is def complete and then you get
security dudes in and they tell you oh
you've got these cross-site scripting
problems and SQL injection guess what
you're not doing that testing often
enough you should be doing it all the
time so there's static analysis tools to
look for buffer overruns to look for
secret injections left across like
vulnerabilities you should be running
those static analysis tools on every
check-in as part of your CI commit build
you should be running automated tests
that test for security you can run
penetration tools they take a bit longer
to run you can run that as part of your
acceptance testing all these things
should be built into the delivery
process high security is a quality of
your system and we're trying to build
quality into the system quality is value
for someone that's how Gerry Weinberg
describes quality and security is part
of the quality of your system so build
it in find ways to bring it forward in
the pipeline to run those validations as
often as you can
some security tests you require people
to do it you should be doing that as
often as you can somewhat further down
the pipeline so you don't want to run
manual tests against the bill that's not
known to be good in other ways but yeah
but bring it forward as much as possible
and then how far you bring it forward
depends on the trade-off between the
availability of the resources you have
and the quality of the initial feedback
you get but yeah the balance your
question may you one more one more yeah
one of the things I like to say is that
if the production site was running on
the box under my desk we never have any
bugs or we'd have bugs but they'd be
eliminated quickly one of the problems
the only thing I have problem with
conceptualizing in my mind is how do you
convince how does the scrum process
break down whenever you're releasing
before sprint ends so that's an
excellent question
scrum says that your software should be
in the deployable State at the end of a
sprint
I'm saying that's not good enough your
software always needs to be deployed and
then you can choose deploy it whenever
you want
in view down in Silicon Valley they were
one that this guy caught in vehicle
Timothy Fitz wrote the continuous
deployment blog entry and I once told
him to you a few weeks ago and they
basically said well listen we do scrum
I'm like really and they're like yeah
but we don't we don't wait till the end
of the sprint to have software deploy we
deploy all the time we're still doing
scrum and the point is I mean I think I
think the world has moved on since from
was invented and we now have these
principles and practices that allow us
to do better I mean it used to be that
people thought having deploy our
software at the end of a sprint was
crazy talk you know we released once a
year and you're asking us to be
deployable once a month you're insane oh
my god become possibly be that the world
has moved on we have tools that make it
possible to do this stuff that I'm
talking about and you know we can do
better and you should do better I mean
all this stuff that there's a trade-off
it's there's a cost associated with
implementing maintainable comprehensive
automated tests with the instance
integration as a cost for all this stuff
and you have to decide is it worth it
for me to be able to do this there's
always a business's indecision that's
involved but the reality is everyone is
moving faster and faster and faster and
it's almost impossible to remain
competitive unless you're in a massive
monopoly unless you're actually doing
some list stuff and testing your
hypotheses about what to build so you
know people already proposing
modifications to scrum to say well
actually we shouldn't do this scrum can
be fine as I kind of a shell around the
planning process as a planning
methodology but I would say you know the
reality is scrum is a great starting
point if you're really immature any
practice that's written down in the book
is a good starting point Hanban scrum
whatever even waterfall can be a good
starting point if you're doing something
totally chaotic there was a Forrester
survey looking at development
methodologies and the most popular
development methodology last year was no
development methodology if you have no
development methodology Waterfall might
be an improvement on that so start with
something and then practice continuous
improvement
I think that's four yet thanks everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>