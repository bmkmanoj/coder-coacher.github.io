<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Agile Architecture &amp; Design | Coder Coacher - Coaching Coders</title><meta content="Agile Architecture &amp; Design - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Agile Architecture &amp; Design</b></h2><h5 class="post__date">2012-08-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/K905mAKDFj0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">investigate some of the techniques and
other things that we've developed over
time to handle architecture and design
agile II but I'm going to start with the
poetry of Donald Rumsfeld but very
famously at one point said there are
known unknowns that is to say there are
things we now know we don't know but
there are also unknown unknowns there
are things that we do not know that we
don't know it turns out this is the
really hard part about software are the
unknown unknowns the known unknowns are
okay because when you start a project
you kind of know there's some things
there lurking it's like I don't really
know the full details of that but you
know I can reserve some time for that in
the project we can handle that those are
the known unknowns but the unknown
unknowns are the ones that always know
you because you don't even know that
you're supposed to be looking for these
and then all of a sudden they pop up and
you never had any planning whatsoever
for them big big up for an architecture
and design failed because of unknown
unknowns there's just no way to resolve
those things because it turns out the
future is really hard to predict that's
what you're trying to do if you do a
whole lot of elaborate architecture and
design work upfront you're trying to
predict the future by saying here are
the constraints that we know we're going
to happen in the future but you're
always wrong about that and so in the
agile world we said instead of trying to
make our predictability better because
predicting the future is just flat-out
hard
my mother-in-law one point just turned
to me with disgust and said you know
those lottery numbers I just can't
figure out what that order is on any
given day it's a really hard problem
predicting the future is really tough
and so what we've done in the outer
world is say well can we design some
techniques that allow us not to have to
do all this work upfront but instead add
flexibility into our architecture in our
design
and so let's talk about that for just a
second this distinction between
architecture and design Martin Fowler I
think did a really good job of defining
this distinction in a white paper that
he released probably more than a decade
ago now but it's still available on his
website called who needs an architect
which is about the role of the architect
in agile projects and in that white
paper he identified or gave my favorite
definition of architecture and software
which is the stuff that's hard to change
later I like this definition because
it's it's vague yet precise because you
can look at any element of your
architecture and ask it are you going to
be hard to change later that's an
architectural element so your database
is an architectural element your web
framework is an architectural element
because that's gonna be hard to change
later but the way you use that web
framework is designed the way you use
their workflow class the way they're
using their validation stuff that's all
part of design and that stuff is
relatively easy to change liquor and
this kind of abstract picture captures
this concept because the architectural
elements here on the bottom and it's
hard to shuffle those gray boxes around
without making the entire thing unstable
where's the red boxes on top you can
move them around and get a slightly
different shape but not change the
overall structure I've written an
article series about this topic for IBM
developerworks which is still available
out there there are 19 installments in
this series and the series is called
evolutionary architecture an emergent
design and that's a really important
distinction because you can't have
emergent architecture you have to have
something for everything else to rest on
before you can do anything else but you
can create an architecture that you can
evolve over time design can be much more
emergent because not as much rests on
design and so you can actually do less
design and let more of it kind of reveal
itself to you from code and I'll show
you some examples of that in just a
second but notice that given this
definition of architecture architecture
really represents constraints
over the things that we can do and we
can't do and so as a corollary to this
definition Martin also said that the
architectural elements are the are the
things that are hard to change later but
you should be as little of that stuff as
possible because it represents
constraints and having architectural
elements means it's hard to change those
things out later and you know what
sometimes it's nice to be able to change
out big chunks of the system later for
something else and I'm going to talk
about some techniques for that including
how those technique kind of dovetail
into a whole continuous delivery topic
that's about architecture and components
first though I want to delve into design
and spend a little bit of time talking
about design in the agile world and
specifically I want to talk about
emergent design so I should probably
give you some definitions here Webster
says that's something that is emergent
rises or emerges out of something that
conceals it it comes to light there's
another definition from Webster that
says something that suddenly appears it
rises unexpectedly
there are two definitions here and they
very loosely correspond to the two
different aspects of emergent design
that I'm going to talk about in this
talk one of them has to do more with
existing brownfield projects that have
been around for a while emergent design
techniques there the other has more to
do with greenfield brand-new projects so
let's talk about the existing brownfield
projects first one of the aspects of
design that you've probably discovered
is that in your application there's a
problem that conceptually looks like
this and you think about this while
you're at work and you think about it
while you're driving home and you think
about it while you're mowing the yard
and when your spouse is talking to you
and you're supposed to be paying
attention to them there's still some
background threads running against this
thing trying to figure out what exactly
this thing really is a representation of
you think about it you think about it
until it finally resolves itself and
some sort of structure that makes sense
this whole process of looking at code
and deriving things out of it is really
this exercise of finding abstractions
and patterns that already live and exist
there inside your code let's talk about
that for a second now what I'm talking
about
patterns here I'm not talking about Gang
of Four design patterns notice the
subtitle of that book elements of
reusable object-oriented software what
the Gang of Four guys did would say
looked across a vast swath of software
project and said you know what these
problems show up in virtually every
project so we're gonna create a giant
catalogue of them because this will be
really useful for people building any
kind of software those are patterns with
a capital P those are not the patterns
I'm talking about here I'm talking about
patterns with a lowercase P and what I'm
calling idiomatic patterns it's my
contention that every piece of software
has idiomatic patterns in it which are
just useful abstractions you found are
useful little ways that you found a
solve a problem when that problem occurs
again you'd like to be able to use that
same solution again so it really
represents kind of a Best of Breed kind
of I've created an elegant solution to a
problem and I want to be able to
leverage and reuse that at some point in
the future I further subdivide these
idiomatic patterns into two broad
categories technical and domain
idiomatic patterns where technical
patterns are things like validation and
security or transactional data access
security is a good example of one of
these idiomatic patterns because you
probably have a very specific way that
you do authentication and authorization
within your company you probably do
exactly the same way across an entire
suite of applications or you'd like it
to be the exact same way across an
entire suite of applications you're
working toward that most other companies
don't really care exactly what the
details of how you do that are but
that's a really important thing to your
company because that's how you're
expected to handle things and within
your applications domain idiomatic
patterns are things like business rules
and shared functionality across
divisions and companies that you
discover serendipitously through code so
when used in this way when I'm when I'm
using the term patterns what I'm really
doing is describing really effective
abstractions good solutions for problems
that you've encountered before they're
elegant you'd really like to reuse those
guys and so this is the first aspect of
the emergent design that I'm going to
talk about it's finding and harvesting
idiomatic patterns that
already live in your code you just
haven't found them yet and I'm going to
show you some techniques for going and
finding those things and harvesting them
and this is primarily for brownfield
existing code bases the other aspect I
want to talk about is ones for brand-new
code bases which borrows from the lean
manufacturing and lean software movement
this concept of the last responsible
moment to make decisions about things
not the last moment but the last
responsible moment the idea here is that
the longer you can defer a decision
about something the better potential you
have for a better decision because you
have more knowledge and context that
you've built up over time over time when
you attack a problem you build more
knowledge in context and the longer you
can put off that decision the better
potential exists for decision because
you're operating in a place with more
knowledge and context this is one of the
really nasty horrible hard things and
software projects is you're being asked
to produce the most nuance piece of
information at exactly the time when you
know the least about the project you
need to come up with architecture and
design estimates before you started
working on it that is exactly the time
when you know the least you're ever
going to know about that software
project is then why to maximize this
this relationship of the worst possible
time to do it yet do those decisions
there if you can defer those things of
course you don't want to defer them too
long because then you put yourself into
a hole so that's really this idea of
finding the last responsible moment to
act on things and I can't tell you
exactly when that is a lot of that is
experienced all for agile tech leads and
architects but I can give you some clues
as to when these things pop up and I'll
give you a case study toward the end of
a project and I think pretty much nailed
last responsible moment so one of the
things you can look at is when you have
a component of your piece of software
and in terms of components now let's
just talk about kind of coarse-grained
chunk of functionality the marketing
piece of the application or the sales or
the inventory piece and over time that
has a certain complexity profile of the
amount of work that is due
or the the crowdedness of the work that
is doing and as the requirements of this
application changes over time you'll see
inflection points of where it's going to
take on a lot new responsibilities or
it's going to take on some orthogonal
responsibilities that it never had
before but now needs to take on those
new behaviors we kind of look at the
complexity over time and look for these
little up tics you can see those in
requirements as they come through as the
business people build up requirements
and whatever ways they capture those you
can kind of see some of these up tics
and complexity and that's a good time to
ask that component is there some part of
you that has reached this last
responsible moment that I need to
replace some infrastructure piece or
some piece has been acting as a
placeholder for what the real ultimate
behaviors going to be and the case study
I shows you really took advantage of
this looking at inflection points very
nicely part of the problem of doing
design up front are the the Rumsfeld II
and unknown unknowns in fact if you look
at the classic book fred brooks mythical
man-month
one of the things he suggests if you
want a really really killer piece of
software is to write it and then throw
that one away and then write it a second
time and there are several interesting
characteristics about the second version
one is that it'll be really good all the
design flaws the architectural flaws you
have in the first one almost will be the
stripped away in the second one because
you're acting now against all known
knowns there are no unknowns anymore the
second version you can estimate down to
the day of how long it's going to take
to write it because that's the thing
that makes estimation so hard are all
these unknown variables we have floating
around all over the place so one of the
things that we're trying to combat here
is making decisions when we don't have
enough information to make good
decisions because then you have to
speculate and guess so one of the
techniques that we use a lot in the
agile world are doing spikes to try to
get really quick knowledge acquisition
about things the idea behind the spike
and this is very common in the agile
nomenclature is a time boxed
experimental coding exercise
let's say that you've got a requirement
on your application it needs to do
geocoding and you've never done
geocoding before in your life and you
are correctly reluctant to just make a
wild ass guess as to how long it's going
to take you to do that because there's a
really well-known anti-pattern it's on
the c3 anti-patterns wiki called it give
me estimates now anti-pattern that says
that no matter how many waffle words you
put in front of an estimate like I don't
really know this is a crazy guess this
is just completely out of the blue no
matter how many qualifiers you put on it
as soon as you say a number you've
entered into an ironclad contract that
you'll risk your life to make that date
come true and so you want to make sure
that you don't commit to that too early
that's the idea of a spike we got
geocoding I don't know anything about
geocoding but I need to learn more
information and so I'll create a time
box maybe it's a two hour time box maybe
it's an eight hour time box and during
that time box I do nothing but learn as
much as I can about geocoding these
spikes are never meant to be prototypes
these never grow into real code they are
designed to be thrown away meaning that
you don't literally throw them away
they're typically done on a branch in
version control but you never merge them
back into the trunk because if you're
building as a prototype you're going to
do non information-gathering activities
like writing unit tests like writing
variable names more than one character
like writing pretty code that doesn't
suck in places that's not what a spike
is about spike is about pure raw
knowledge acquisition as quickly as you
can and so we do this a lot to chase
away these uncertainties particularly
when you come into things like you need
to estimate a part of the system that
you're not super familiar with spikes
are great ways to combat the unknown
nough Civ that the other thing you have
to watch out for is technical debt and
this manifests itself on a software
project in a lot of very interesting
ways this is a ward cunningham metaphor
this idea of technical debt is imagine
what your code base would look like if
you could lavish all of your love and
attention on it no refactoring is too
big or too small you want to craft the
most perfect code base in the world
the Delta between that and once you left
to come here is probably a lot of
technical depth which are externally
imposed ways that you make compromises
on design and architecture of projects
there are a couple of really common
drivers a technical debt one of them is
schedule pressure we don't have time to
get it done so you need to do it as
quickly as possible
the other big driver for technical debt
is another one of the anti patterns from
the c3 anti-pattern wiki called the boat
anchor anti-pattern the boat anchor
anti-pattern says that we bought this
really expensive piece of infrastructure
and you have to use this on every
project whether it makes sense to use it
on this project or not because we spend
a lot of money for this thing and a lot
of times that ends up driving technical
debt because now you're stuck with a
bunch of stuff that you don't actually
need or don't actually want now in fact
I've started characterizing technical
debt in this way particularly with this
kind of common strategy that's out in
the world of so if you need an
infrastructure piece and the case study
that I talked about talks about
asynchronous messaging so you need an
asynchronous messaging framework but
it's very early in the project so you
don't know exactly what capabilities
you're going to need and so there's a
there's a virtue down in the software
world of let's buy the really fancy
expensive one and then we'll grow into
all those capabilities that it offers
eventually a lot of software vendors
sell sweets like that the problem that
approach though is it ignores the
negative impact adding that thing has
with all those bills and whistles
they're not turned on yet I've started
characterizing that as technical debt
because technical debt are things that
are in your project that are not making
things any easier they're just in your
way of getting stuff done and a bunch of
bells and whistles and features on a
piece of software that you're not using
is technical debt because it's just in
your way of doing the stuff that you
actually need to get done in fact I
start categorizing that stuff as
technical debt as soon as you add it to
the project and then start discounting
as technical debt when you start using
those those various features and we'll
see how this plays out as I talk about
my case study a little bit later
that's all a bunch of stuff about last
responsible moment I'll come back to
that toward the end as I talk about some
architectural impacts but now I want to
switch over to the other aspect that I
have of emergent design which is finding
and harvesting idiomatic patterns that
already exist in your code and I want to
talk about a couple of different
approaches to this so first I want to
talk about refactoring toward design so
here's a java method what it does is not
important at all this is actually a
little method from a toy ecommerce site
that takes things out of a shopping cart
and puts them in an order using old
level JDBC the point of this is if I
want to really do some harvesting and
design it is I've got to clean it up
first because I can't tell what's there
it's just a big lumpy pile of code as
far as I'm concerned even an experienced
Java developer you don't have to read
through more or less every line of code
to figure out what's really going on
there you can't look at it until what it
does so how are you going to look at it
and tell what design is there so what I
want to do is refactor this code to get
it to the point where I can actually
read it and understand what it does and
so what I'm going to do is firstly I'll
observe that a bunch of these lines are
really just things that kind of
conceptually belong together here's a
really good clue for you look at your
Java code and look at places where
you've added blank lines and your
methods that's a cry for help to make me
my own method because you've added that
blank line there because you're saying
these three or four lines conceptually
go together why not make that a method
and so that's what I'm going to do is
take the lines of code that I don't have
any blanks in here because of tight
spacing but take the lines that are kind
of conceptually together and do an
extract method on a bunch of those and
get to here it's a little bit better
it's a little bit better from an
abstraction standpoint because now I'm
kind of an even level of abstraction but
there's a side effect of doing this in
modern tools because you're refactoring
tool has a really strict contract with
you that says I guarantee that your code
will still work exactly the same way it
did before when I'm done
and a refactoring tool when faced with
this a bunch of local variables the only
thing that it can really do is convert
those into parameters and so when you do
a lot of refactoring like this you see
an explosion of parameters being passed
that's because I mean certainly one of
the ways to do this is to move those
things to class level but they have
straighting and visibility implications
that are refactoring tools never going
to take into consideration but as a
human developer you can so I'm gonna do
another refactoring run on this take
some of this shared state and move it
out to the class level where it's safe
to do in this particular application and
end up here now I'm getting somewhere
because now I can tell it's actually
going on in this code it does them some
sense of infrastructure does a little
bit of work it completes it it rolls it
back if something goes wrong and finally
it cleans stuff up this is exactly the
code that I had before only now I can
understand what it does this the
inspiration for this style of
refactoring actually comes from what may
be a surprising place for some of you
this is basically Kent Beck's idea of
composed method from small talk best
practice patterns which is a book that
he wrote in the late 80s about our early
90s about small talk
the idea behind composed method is that
every public method reads like an
outline and the individual steps our
private method or methods that implement
those behaviors and this is really nice
and navigable in the java world now
because every major java ide if you hold
down the control key a method name
becomes a hyperlink to that method and
so you can literally use this to browse
your code look at it a really high level
of abstraction if you want to get to the
individual details you just ctrl click
on that method or drill into the details
and find out what that method is
actually doing but now that I've got it
here I can see what's going on and
notice that I can very trivially now
replace these two lines of code with
something else and what I've built at
this little transactional data access
method you couldn't see that before
because it was hidden in all that lumpy
pile of code but once you get your code
organized you can actually see it
so let's talk about harvesting one of
these patterns I'll come back to that
one in a bit and convert it to an API
but let's talk about harvesting a deeper
pattern before I go here though I need a
little bit of background I need a couple
of metrics
well first one I'll talk about its
cyclomatic complexity this is a metric
that's been around for a really long
time spin around since the 70s in the C
world the idea behind cyclomatic
complexity is it assigned a numeric
value to the complexity of a function or
method here's the formula thomas mccabe
is the one who created this metric it is
edges minus nodes plus 2 where nodes or
lines of code and edges or possible
paths through the code so if you have
this little java method like this if i
draw out this kind of nodes and edges
view of the world and then count them up
4 minus 4 plus 2 so the cyclomatic
complexity of that method is 2 it's kind
of boring when the numbers cancel each
other out like that though and so let's
look at a slightly more complexed method
in the java world I'll draw it out in
this kind of edges and nodes view of the
world and number them 8 minus 7 plus 2
so the cyclomatic complexity of this
method is 3 it's one more complex than
the one that we saw before so what I
have now in my toolkit is a way of
determining how complex a particular
method is so I can compare two methods
against one another see which one's more
complex all he's really doing there is
measuring loops and other kinds of
decisions so that's one metric the other
metric I need is one called afferent
coupling afferent coupling if you were a
class your africa' coupling numbers how
many other classes refer to you and so
in this particular case the africa'
coupling for this class in the middle is
six because six other classes refer to
this guy in some ways you can look at
afferent coupling as a measure of
importance because of a lot of classes
linked to you you're probably pretty
important and with cyclomatic complexity
we have a
that allows us to determine really
complex things so we put those together
this allows us to go hunting for complex
important things which is exactly the
category of things I want to be able to
poke around and find and my software the
really important things that are
probably overly complex so that's what I
wanted to do and I wanted to do this in
a way that you could recreate this if
you wanted so there were some very
specific characteristics I want to put
on this little experiment that I was
going to conduct it needed to be an open
source piece of software so that you
could reconstruct this if you wanted to
it needed to be an around for a long
time because what I'm really trying to
get at here is that my contention is
that every piece of software has
unharvested idiomatic patterns even in
it even it's been around a really long
time so I wanted a piece of software
that's been around for a really long
time that's been used by a lot of
developers to build a lot of stuff
that's not chose stretch it's a second
major release that's been around more
than a decade thousands of web
applications been written in this thing
the second major release you would think
that by now most of the major design
I'll have been chased out of this guy
let's see so I downloaded the stretch
source code and I ran a tool on it that
gives me my two metrics that I'm
interested in the tool if you're
interested is called CK JM let's call
that because it's running the chittim ER
and kimra object-oriented the CK and JM
means for Java so CK JM is a little
freeware tool that you can download and
run against a Java code base the way
that C kjm reports cyclomatic complexity
because it reports everything at the
class level is that it gives you the sum
of the cyclomatic complexity of all the
methods in the class there are the
results for struts and if I'm just
hunting complexity the champion here is
double List UI bead which has a WM C is
weighted method complexity that's what
CK jam called cyclomatic complexity that
66 means if you add up all the methods
in this class the cyclamen complexity
equals 66 so that's what that is that's
the sum of Sacrament complexity of all
the methods of the class so if I was
just looking for complex stuff here I
found it this is the most complex class
there but that's not all I'm looking for
I'm looking for important stuff to it if
you look across the road it's after a
coupling number is only three meaning
that only three other classes rely on
this class you get something done what
if I sort these instead by Africa
coupling clearly component is the most
important thing in the stretch universe
as being a component based web framework
that's not surprising but what I'm
really looking for here are high
combinations of numbers I'm looking for
important complex stuff and you I beam
immediately catches my eye because it's
pretty high in both those categories so
I start poking around in you I mean I
keep meaning to add the final jeopardy
music to this part of my presentation I
keep forgetting so if you would just hum
the final Jeopardy music to yourself as
we look at the lovely eval evaluate
params method and UI beam instruction my
favorite part of this method by far is
the last line of the method which is
evaluate extra params it's almost like
the developer just got tired of typing
it's like oh god I can't type anymore
get evaluate extra prints okay I'm done
so if you start poking around in struts
you'll find a whole bunch of evaluate
params and evaluative an extra params
methods and what those are there for
struts is a web-based component based
web framework in it one of the things it
does is Auto harvest some URI parameters
for you to fill in form fuels and other
things so you can intervene in that
process if you want or you could ignore
some parameters to get sent in that's
the the combined job of evaluate params
evaluate extra params as I was poking
around in the struts codebase
I kept bumping into one or one or the
other of these two methods and a bunch
of different places so I got really
curious how much of this evaluate pram
stuff will exist in struts so I did a
little bit of command-line judo starting
in the route of struts showed me all the
Java source files and within each one of
those show me every one of these that
has and evaluate params or evaluate
extra params
and there they are I have found an
idiomatic pattern instruction the way
they handle you or I parameters and I
think this is a great example of one of
these little idiomatic patterns because
a decade ago when they started working
on struts I'm sure nobody said you know
what in fifteen years the most complex
part of this codebase is going to be how
we handle URI parameters because it
seems like such a simple thing it's so
simple they solved it over and over and
over and over and over again within the
stretch code base so there's a little
bit of an epilogue to this story as I
mentioned before I'm writing this
article series for IBM developerworks
and I posted this about this discovery
I've made it stretch and one of the
struts committers contacted me and said
that he had independently discovered the
same thing that there was a whole lot of
complexity around this lurking around
the stretch code base and so he
undertook the refactoring that should
have fixed it by now basically
extracting all of this evaluate
parameter stuff is embedded framework
inside struts and by doing that removed
hundreds thousands of lines of code and
hundreds of cyclomatic complexity points
because that was the most complex thing
still in struts was that parameter
handling stuff and by isolating that in
one place he was able to vastly simplify
it so now that we've seen how to find
them we need to talk about how to
harvest them and you can harvest
patterns these idiomatic patterns in
several different ways one of which is
to just harness them as an API which is
a nice easy convenient way to do it
that's the way you harvest most reusable
code find a packaging mechanism and a
discovery mechanism with your
organization where you can reuse that
code you can also do things like
annotations which for some situations
make really good kinds of ways to
harvest these patterns because they
stick out from the code around them
particularly things like validations and
other kinds of locality based
characteristics you'd really like the
validation characteristics or to live
really close to the domain classes not
be separated over here to a web
framework somewhere by creating as an
ant
stationed in the class itself you have a
good locality for that behavior and what
it really applies to and so there are
several different ways that you once you
found these things you can go harvest
them which is all about design but let's
go back for a second and talk about
architecture architecture is this big
huge vague term in the software world
right now because when you talk about
architecture you may actually be talking
about several different kinds of
architecture one of the kinds of
architecture you may be talking about is
application of architecture which is how
applications get put together but
another kind of architecture you may be
thinking about is enterprise
architecture and enterprise architecture
if application architecture is like the
architect of a single building
enterprise architects are like city
planners because as an application
architect you can't come along in your
organization and say hey I need 80% of
the bandwidth the entire organization
because I'm doing this cool thing is my
application your enterprise architects
are gonna say no you know get 80% of the
bandwidth the entire organization just
like city planners won't let somebody
build a building in the middle of San
Francisco that has a fountain on the top
of a 50-story building and sucks up half
of the water in the city they're not
going to allow that happen so a lot of
times this is a policing function as
much as anything else and if you start
looking at things like enterprise
architecture one of my colleagues actors
has put together this mind map of all
the things that Enterprise architects
and have to think about in big
enterprises which is a huge big thing
I'm not going to talk about you need
this stuff particularly all the
political stuff that goes into this what
I really want to talk about is how we
can actually merge this idea of
enterprise architecture an application
architecture in a way that saw some
problems that we've had in the
integration world in the past and I'm
going to do that on the back of some
examples from this book Brian was
talking earlier this morning about rest
and restful kinds of architecture and
that's actually what I'm exactly what
I'm going to use here to solve this
integration problem at the enterprise
architecture level
before I get into this though I need to
talk for just a second about Leonard
Richardson's restful levels of maturity
about two years ago maybe three years
ago now at Yukon London Leonard
Richardson came up with a scale at how
to basically score different
architectural styles as to how mature
they were against the the restful scale
so his scale here is rest so he's
definitely biased toward rest but he
scores a bunch of these different
architectural styles and I'll highlight
some of these architectural styles very
briefly to point out how they have been
deficient in solving some really
important problems that we've had so
here are his restful levels of maturity
we're level zero there's actually four
levels level zero is a single URI to a
single HTTP verb this is how web
services and W star based endpoints work
you have a single URI for an endpoint
you do HTTP POST to transfer soap
documents back and forth ignoring the
rest of the HTTP verbs all the rest of
the HD metadata that's there you're
basically just using HTTP is a
synchronous firewall friendly transport
protocol for doing remote procedure
calls level one service you have many
you are eyes but a single HTTP verb
typically what happens here is that a
lot of tools support this kind of
behavior where you can point it to a
method and say hey make this an endpoint
for me and it basically just takes that
method name creates an endpoint for it
converts the parameters and the name
value pairs it gets it in this uses a
lot of you our eyes one URI permit the
name but typically only uses a single
HTTP verb get on top of that here where
you get to level two you have numerous
you our eyes and addressable resources
and a lot of people will get to here and
stop and say we're restful and you are
in fact rest of it when you get to there
I'll show you some examples of that and
then the last level of course is level
three how do switch is hypermedia is the
engine of application state and I'll
talk about what advantage that gives you
over just the idea of resource based
computing because there's been an
evolution of the thinking of this over
time and in fact the rest in practice
book talks about this evolution of these
four levels on Ritchie
scale architectural e all these guys
pretty much fall in the level zero
category you are i tunneling goes in
number one craig web services in two and
then how do this and number three so let
me show you brief examples of each one
of these architectural styles first one
I'll talk about is level zero guys
they're which are different flavors of
remote procedure call or RPC this is
actually one of the things that that was
a topic of discussion whereas we're
talking about cloud stuff yesterday is
that the idea of distributed objects is
kind of a silly idea
we don't have distributed objects we
have distributed data we don't
distribute objects you can't send
methods you can't serialize a method
send it along a wire and execute it
somewhere so a lot of the object nests
of our objects get stripped away and
they become just data containers as we
move them from place to place and so one
of the easy ways to model this is just
reduce remote procedure calls and this
is how all the soap works an XML RPC and
a bunch of other protocols basically the
idea of the client application makes a
local method call which gets translated
into an extra XML document that gets
posted over HTTP which gets picked up
deserialize and that some work happens
serialized back back with a payload at a
200 ok and deserialize back and then the
local method return there does some
useful work notice that in this case all
the application semantics reside inside
this payload it is not uncommon to send
back an entire XML document just to say
ok which is kind of a waste of bytes
when you think about it building all
this structure just to say that
everything went okay but it basically
ignores all of the metadata that's
already there in this pipe of long HTTP
because one of the things that the soap
was designed for is transport
independence so they actually built up
their entire metadata stack around it
because they're not necessarily relying
on the underlying transport mechanism to
do that really the only difference
between XML RPC and soap and traditional
remote method calls is really just the
wire protocol the wire protocol looks
different in all these cases but the
underlying architecture is pretty much
the same where you have XML documents to
have things in them and they get passed
back and
and of course their scheme is a time
what these guys look like but on the
Richards kale this scores a zero this is
a very lightweight way to make to do
integration because it basically is just
making remote procedure calls that's
exactly what the mechanism is designed
for it's almost universally
interoperable because all the tools now
support this a easy way to say click
make this a web service call an RPC
endpoint not particularly robust though
particularly brutal in the face of
changes over time which makes this not a
good choice for doing enterprise
integration it also ignores the web as a
platform because most of these protocols
were built with transport agnosticism in
mind and so they build up their own
metadata stack of their own status codes
and all that other stuff and so this is
probably it's useful for simpler
integration problems when you really do
have a remote procedure call shaped
problem you should use this approach the
next one up on richness scale is this
idea of uri tunneling a lot of tools
make this really easy just by having
wizards and other things basically it's
using uri is the means of transferring
information across a system boundary by
including it as a uri so here's the idea
you have a method call somewhere called
place order that basically gets mapped
to a method name the arguments are name
value pairs and those get serialized
into some sort of water guy and then you
execute that input the only real
difference between this and RPC is that
you tend to have an endpoint perm method
that you've exposed here which is not
all in this case and the RPC world uri
tunneling does use your eyes but only
you our eyes doesn't ease any of the
HTTP verbs or any other metadata
mechanism in that channel it's not a
very sophisticated in fact it's very
tool friendly but not particularly
architectural friendly in terms of
longevity and building things that are
not brittle this can be made web
friendly in terms of caching and other
sorts of desirable caster istic
characteristics but the problem here is
really an abstraction a fundamental kind
of abstraction problem because the you
our eyes are encoding operations here
not resources and if we're trying to get
to the restful world we're trying to
represent those things as resources not
operations the other things this does is
violates one of the rules of the web
because typically what happens in URI
tunneling is that you do everything over
to the top of get and doing something
like place order over the top of get
actually modify server-side State which
violates I didn't see your not supposed
to do this the get are not supposed to
modify server-side state and so doing
this kind of violates a part of the web
as a platform concept so let's march up
the next part of the Richardson scale
which are this idea of cred web services
and starting to treat the world as
resources in the rest in practice book
Jim Weber and Ian Robinson have created
this mythical place called arrest bucks
which is like a coffee shop but they're
using that as their integration points
integrating between the different roles
within the rest ebooks world and here
are some of the interactions that they
have defined in the rest bucks world
where you can place an order you can
update that order or after a certain
amount of time you can pay for it and
you can pick it up etc you'll notice
that that looks like a state machine
that's actually really common and a lot
of restful systems is that you're
building state machines and modeling
States because resources move from one
state to another state so that's a very
comfortable abstraction on top of
resources let's say that you are going
to piece together what the integration
api's look like for rest bucks here
notice we don't just have an endpoint we
also have a verb because we're taking
advantage now of your eyes and verbs in
HTTP and so you typically post against
order which creates a new order and upon
success it sets the location header
information in the new orders URI notice
that what you get back from here when
you call this is a tool one created
status code that has the location header
set that points to the new resource
you've created but no body there's no
reason to send back a body that says
everything went ok or has the the
location of this new order in it this is
already a header in the
in the metadata envelope in HTTP that
handles that for us and so restaurants
take advantage of all those those
facilities are already there yet lets
you specify a specific order and gets
that value back put let you update an
order and a given your I with new
implementation new information and of
course delete lets you logically remove
one of those you are eyes the idea here
and this is what i was going back to
before is that when you actually do a
post in this world of creating new order
it doesn't create it sends back a tool
one created and since this location
header but no body comes back because
there's no reason to send a body back we
sent the status back that said ok i
created a new one for you and here it is
but there's no reason to send back a
particular payload body you can also of
course get air conditions here so we
might get a bad request or something
like that there's an entire series of
course of HTTP status codes you can use
for that so this is basically now the
idea of starting to model things as
resources in our world and this really
is what he calls crud web services this
embraces both HTTP and you our eyes so
it's using the the features of the
platform that's running on taking
advantage the leveraging those it
creates a really good solution to a lot
of problems in fact any time you've got
simple kind of crud operations against
resources this is a perfect model
because you're modeling the resources
you've got the verbs necessary to do
operations on the resources so it's best
for these kind of crud applications and
in fact a lot of people in the rest of
the world get to hear and stop and
that's that's perfectly fine you can
absolutely say that you have a restful
system if you stop here because now what
you're doing is modeling things as
resources and to letting those resources
evolve over time as they the real entity
evolves over time but there's still one
thing that we haven't really attacked
that the last thing it helps us attack
which is this shared tightly couple
understanding of resource life cycles
and this is a common problem when you're
talking about integration we're talking
about enterprise integration here here's
a fundamental problem in doing that
think about for a second enterprise
integration almost as a model view
controller view of the world so you're
talking about enterprise integration so
the view part can be kind of thrown away
that's gonna be a portal or some
application that aggregates other stuff
we don't really care about that so let's
talk about the controller and the model
the model are things like data access
and business rules and other kinds of
core things that should be facts about
what your entities are and can the
controllers or workflows the way you
piece those models together so
controller says I need these pieces of
information from this model and this
pieces from this model and I'll tie them
together and make them do some work the
problem with that though is when you're
doing enterprise integration then your
models are really applications that
contain some sort of data and logic and
other stuff and now you've got a really
fine grained workflow driven from the
client the clients saying here are the
resources that the things that I need
here's what order to do them in what
methods to call on them and what that
ends up doing is coupling the client the
server together forever you can't really
make a change to one of these guys if
this guy is relying really heavily on
the details of how that workflow pers is
put together because for every one of
these workflows even if the application
itself hasn't workflow in it there going
to be multiple branch points in that
workflow as the user chooses different
options or different things there's no
the client can't really in our current
world that's not exposed to them so
basically we're saying that applications
can own their business logic but not
their workflow we're trying to extract
the workflow to the client because he
has to be able to drive the
decision-making process with
interactivity with a user or another
system what a lot of vendors have tried
to do is look at this problem and say oh
you know what that's a big problem we
got a solution for you and the solution
is worse than the problem things like
BPL and V BPM and basically any kind of
Clarke Tunes to code kind of scenario or
you're supposed to draw a picture and
then it's supposed to vomit out a bunch
of code that does work these are really
dangerous because they demo really great
and then you try to use them for real
problem and you end up with a giant
hairball effect
which is there's so many lines
intersecting that you can't anything
useful done with it and now you've
actually put yourself in a much worse
situation because now once you've got
your workflow captured in this graphical
tool it is no longer testable you can't
write a unit test for that stupid
diagram that you've got you can't really
dip it either
now underlying that stupid diagram is at
10,000 line XML document you can diff
the 10,000 line XML document if you want
but that's a job with a high suicide
rate nobody wants to do that there's no
good way to see that diff graphically so
now you're in this this XML kind of
world you can't easily refactor this
stuff and so what happens if you have
one of these diagrams somewhere and
there's another piece of behavior that's
almost the same but a little bit
different over here there is no extract
method and use commonality so you're
left with copy and paste coding you copy
this workflow and then paste it over
here and make a small change to it but
now you get this proliferation of
different almost one all versions of
these work processes so I don't think
this is even usable and it still doesn't
attack this fundamental problem that
applications on their business logic but
not their workflow that's where this
hottie OHS idea comes in and I've said
that anytime you create an acronym with
the word hate in it it's probably not a
great thing but this is just kind of
side effect it really is an acronym that
means hyper media is the engine and
application state here's the idea with
how do is that rather than doing
integration at the method level against
our models against our server
applications let's do it at the process
level instead the idea of ha dios is
that when you send things back from the
server you send back still data because
you care about data but the other thing
you send back are links and those links
lead you to subsequent workflows within
this application so let's say this
application does something about
ordering when you place an order at rest
bucks you've got two options you can
either pay by credit card or pay by cash
those are two different branching
workflows that live in this application
that models things about payments
well how do is going to do is say once
you've placed an order there are two
things you can do in my universe you can
pay by cash or pay by credit card I'm
going to send you back two links if you
follow one link you pay by credit card
if you follow the other link you pay by
cash that's going to take you to a
resource that handles the details of
what if that interaction is that's the
idea behind hypermedia is that when you
make a request to one of these resources
what you get back is data but also a
bunch of links about subsequent steps
within the workflow now all your client
becomes is the entry point to a workflow
that is defined and lives forever on
that server application that knows the
real details of that workflow the
validations the data axis all those
other things what it's doing what how do
is let you do is expose that workflow to
the rest of the world in a link based
way so that now the client can say okay
I've placed the order now the option
comes back to pay I'll take the payment
option now that comes back to I don't
there's no payment anymore but the state
machine says ok now I can pick it up and
so you're just moving from state to
state over time and the next state
that's possible comes back to you and
links every time you make a call to one
of these resources what you're really
doing here is establishing contracts
between things and so we're used to
contracts looking a different way than
other kinds of integration world but
contracts are really just combination of
protocols a protocol in this world is a
consists of HTTP it was like verbs and
metadata entry point your eyes that get
you to the beginning points of workflow
processes and then the subsequent steps
come back to you as links within that as
a hyperlink and in media types which
define what the shape of the data looks
like this is what we use dtds and xml
schemas for in the kind of traditional
integration world as the media types are
used in the hyper media world and those
media types really specify things like
schemas processing models and Howrah
linked relationships work
but it's really just the the same schema
stuff that were used to before cast in a
different light in fact you don't even
have to use media types here you can use
traditional kinds of XML schema if you
want which we end up doing a lot of
cases
but the point of this is that the core
of any contract or what formats did you
accept what's the price signal and what
kind of controls can I use so if you
take this and apply it to the exact
example from the rest and practice book
rest bucks what you see what ends up
happening is these URI map onto business
processes these business processes are
basically just a state machine because
anytime you're dealing with resources
you're really talking about moving a
resource from one state to another
mistake which is a great model for a
state machine that's really all we're
building when we build one of these
these systems is building a state
machine and defining what possible
States you can go to next this is
actually really nice architectural
because building state machines helps
you think about all the states that she
should accommodate for that resource
because resources have certain number of
valid states now you can start thinking
about you know what is the delete' state
for of this bigger resource and so the
links that come back define the kind of
interactions you can have with the
application so for example if I place an
order what I'll get back is a way to
make a payment or a way against this URI
to either get this current status on it
do an update for it or delete that order
so this is what a snippet of that
hypermedia document looks like that
comes back it has coffee information in
it but it also has these domain
application protocol links what it's
related to what the URI is and what
media type is expecting this tells you
the details about what the things going
to look like what shape it is from an
XML standpoint it's schema is DTD or
whatever that is which lets you do
validation as you make calls these
resources one of the nice things about
this as an enterprise integration
architectures because it relies heavily
on state machines it's usually if you
have a well-constructed application just
kind of lay this integration logic as a
facade over your existing system you
basically take those resource concepts
that you want to support implement those
internally for your codes and build a
state machine facade over the top of
them
and call in to those two to get it to do
work so what this gives you is evolvable
application integration what this allows
you to do is say that I've decoupled now
the lifecycle from my client and my
server because let's say that you're in
the rest ebooks universe and we're using
an internal credit card payment
processing service and when you make
place of order and rest bucks while you
get back as a link along with the media
type that says okay if you want to make
a payment you follow this link with
these data types and you could make a
payment we change at some point to use
an external credit card processing
facility we change the server to now
send a new link and a new hypermedia
type back to the client but all the
client knows is that when you want to
make pain that you follow this link then
it got changed is there relevant to the
client because the client knows I send
this link with this information and I
get payment information back and so that
allows you to decouple the evolution of
the server application and the client
application so they can evolve
independently and you can support
multiple versions against the server and
some other nice tricks like that so
remember when I was talking about this
diagram earlier I said that the
architectural elements were the things
that are hard to change later and you
want as little of that stuff as possible
because architectural elements represent
constraints so one of the ways that you
can do this is try to isolate orthogonal
concerns and basically componentize them
let me show you what I mean by that with
this case study this is a case study for
a project that I've worked on variously
for the last four or five years this is
a project that's running in our office
in Atlanta right now for a company
called Ovi comm online vehicle exchange
comm this is the wholesale version of
autotrader.com if you want a car
dealership and you want to auction cars
to other car dealerships you can get a
login on this site so they do car
auctions is what they do you and there's
a really fascinating story about how the
asynchronous messaging evolved in this
application so the very early days of
this application the
users wanted a sense of progress this is
an Auto Auction application and for car
dealerships it's not atypical for them
to upload a hundred cars at a time with
50 photos each and nobody wants to look
at an AJAX spinner for an hour and a
half so they wanted some sense of
progress or the ability to start a job
and then come back later and see if it's
done that's classical kind of
asynchronous messaging and so the tech
lead met with the developers on team it
was suggested that we should add a
message queue but they did a couple of
spikes somebody found this little thing
called background RB which basically
sets up a very simple single message
message queue backed by a relational
database and I said you know what for
the simple problem we have that's good
enough but this wasn't the tech leads
first project he figured pretty
definitively that we'll eventually need
to replace this simple mechanism was
something else and so he was careful to
put it behind the Ruby equivalent of an
interface about a year into the project
a little over a year a second kind of
asynchronous behavior popped up the
ability to do a timed events like cron
job kinds of things we built that on top
of background or be after spiking just
make sure it would still handle that and
it did so that was fine then about the
two-year mark on the project a third
requirement popped up for asynchronous
messaging which are constantly updated
things like cash values and accounts and
things like that at the same time that
came about our the background our B
infrastructure is starting to creak a
little bit in fact we've been using this
simple message backed by a database for
a long time our DBAs though it caught
wind that we're using one of their
precious databases there's a message
queue and I started making this face at
us every time we pass them in the hall
which we view is probably not a good
thing for the project for longevity and
so that was the impetus for us to switch
to a real message queue Starlin which is
a message queue in the Ruby on Rails
world but notice what happened there a
couple of things actually happen that
we're of interest notice the very
beginning of the project the main
characteristic is you don't know what
you don't know so a lot of projects just
in a knee-jerk way say well let's buy
the fanciest piece of infrastructure we
can just in case we need all that
capability later but I talked about this
before the
when you do that you basically take on a
bunch of technical debt that you don't
start paying back until you start using
all those advanced features the problem
though is you don't know which of those
advanced features you're eventually
going to use and so in a lot of cases
organizations end up paying money for
technical debt that they never justify
they never end up using that advanced
feature but they always end up working
around it every time they touch this
tool which is just the definition of
technical debt there's another
observation I'll make here as well
remember I said that architectural
elements were the things that were hard
to change later and messaging
infrastructure is definitely an
architectural element something that is
traditionally hard to change later but
the tech lead on this project knew that
background RB was not going to be the
horse they wrote it into sunset he knew
that it was a temporary it's good enough
for right now so when he put that in
place he was careful to put that behind
a facade behind an interface so that
when it came time to switch this out it
took one pair of developers less than a
week to swap out background RB with
starling by putting it behind an
interface he basically converted it from
an architectural element into a design
element and that's exactly what you want
to do convert things that are hard to
change later in the things that are
easier to change later and that's
exactly where the continuous delivery
guys are trying to go a lot of things
they're talking about building component
based architectures and so I will talk
about this in great depth on my workshop
on on whatever day I'm doing workshops a
couple of days from now I'm a canoe
delivery but this is the idea of the
continuous delivery world of this idea
of doing automatic bills this is what we
know of as continuous integration now
but as we get further and further along
these bills we're going to be more and
more sophisticated kinds of tests and
builds for things
what we'd eventually like to do though
is stop doing hyperactive bills here
stop building the entire application
every time and eventually get around to
this idea of continuous integration at
the component level if you can build
component based
architecture's what you do is make the
architectural pieces relatively easy to
swap out for other ones and you make
those architectural pieces easier to
build independently of the rest of the
application well we do ventually like to
do is get to this place where your
application consists of several coarse
grain components each of which has its
own life cycle it has its own build kind
of semantics it has its own
environmental semantics and I build a
change in this guy automatically
triggers a build and a pipeline for this
dependent application you're actually
cutting down on the amount of code that
you're doing every time and isolating
changes behind those component barriers
so that you have less coupling across
the components of your application which
is obviously a desirable architectural
characteristic so I'll leave you with
this actually back up one back in 2006 I
kind of accidentally repopulate
programming this idea that when we have
really super powerful runtimes like Java
then you can start mixing and matching
languages on that runtime and my
colleague ola beanie when I came out
with my polyglot programming post came
out with a pyramid where he suggested
that maybe you want more statically
verifiable languages on the bottom
easier to use dynamic languages in the
middle and then DSL is kind of riding on
top of all those I think this is a
really really perceptive observation but
this was 2006 and I actually think this
has changed in fact my pyramid today I
actually think the static versus dynamic
thing is kind of a red herring my
p.remove today would say that you have
functional code on the bottom because
this is programmatically verifiable much
more rigorously than any kind of static
typing is so this is a closure or Scala
or something like that
imperative languages like groovy or Ruby
or the top two do things like user
interfaces and the things that you don't
need as much hardcore verifiable
accuracy but you need productivity and
then DSL is riding on top of that still
but actually I think the DSL don't just
write on top they actually pervade the
entire stack now so you see a lot of DSL
techniques in functional programming
languages things like data access sequel
libraries that are done
very functionally and so I think you're
going to see DSL is kind of leaking
through all this stuff and the nice
thing about functional code is that it
tends to encourage this idea of creating
component based architectures with good
clean boundaries between them and so
ultimately I think my goal this is kind
of my entire landscape of the world is
that application architecture is going
toward functional on the bottom
imperative in the middle with DSL is
kind of pervading all those layers using
these emergent design techniques the
enterprise application uses the web as a
platform using component based
development and this entire thing is
wrapped in a big continuous integration
feedback loop that's the kind of idea
that we've got on what agile
architecture and design looks like
thanks very much for coming I hope you
enjoyed it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>