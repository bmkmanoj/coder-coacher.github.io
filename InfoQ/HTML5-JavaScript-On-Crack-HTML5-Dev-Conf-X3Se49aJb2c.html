<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>HTML5 JavaScript On Crack - HTML5 Dev Conf | Coder Coacher - Coaching Coders</title><meta content="HTML5 JavaScript On Crack - HTML5 Dev Conf - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>HTML5 JavaScript On Crack - HTML5 Dev Conf</b></h2><h5 class="post__date">2012-05-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/X3Se49aJb2c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so as I was saying before I'm Kyle
Simpson I'm a JavaScript architect they
do a lot of web performance optimization
things of that nature we're going to be
talking today about html5 and javascript
and i'm going to call those html5 and
friends because i actually don't really
care what label you put on it or what
spec it's in the point is html5 is sort
of assured in this open thing I have a
book that has several chapters about
things that we're talking about today
this talk goes more in depth from what
the book is but if you want to go in
reference that aldi is a discount code
will get you fifty percent off of that
book so if you're interested go grab
that all right today the talk that i'm
going to give is about building a game
this is not a talk about game mechanics
or anything like that we're going to
focus on the raw underlying html5
JavaScript api's that I weave together I
was tired even in the book I was tired
of having each of these different API is
represented by these small little toy
examples and I wanted one coherent
application that i could build from
scratch and weave in all these different
advanced api's together and this game is
what i came up with so it is not like I
said it's not a talk about how great my
game mechanics are but this game is
called we puzzle it is a multiplayer
online puzzle solving game you upload
images it slices them up into tiles and
then you compete and cooperate with each
other to get the tiles in the right spot
to solve the jigsaw puzzle get points
for how quickly you do so and so we will
later on you'll be able to see that and
hopefully if the Wi-Fi holds up we'll be
able to play it all the code that I'm
talking about today is up on github
again all you need is the orange part
but if you just go to github and search
for get a file you'll be able to find
the wii puzzle at game alright so the
first part of this talk we're going to
talk about some sort of some of the
lower level simpler api's and these are
the gateway drugs that i want to get you
hooked on html5 JavaScript get you kind
of addicted by the end of this talk so
the first things that we'll talk about
local storage session storage history
app cache
canvas all right so local storage and
such and storage persist data inside of
the users web browser more better better
than say cookies do because it gives you
a dedicated location usually about five
megabytes per website because you
dedicate a location to store key value
pairs of data similar to how you might
do it in a no SQL database or something
like that so you can see here we have
very simple API and it's the same for
both session storage and for local
storage it's get item to grab it out by
its key set item to put it in by its key
remove item to delete it it's pretty
straightforward I use this in the
application to do some very simple
things like persisting on the login form
which you'll see later when you see the
login form and you see a place for a
name and an email i use the local
storage to remember that after the first
time you've typed that in so you don't
to keep retyping that in i use the
session storage to preserve the
connection information so that i can
reestablish the socket if you refresh
the page or something of that nature so
session storage like it says it's
dealing with the session that's
happening inside the browser tab local
storage will last for much much longer
you do want to be careful with something
like local storage because if you start
storing a bunch of data there and you
never clean up after yourselves and the
user isn't cleaning up you can actually
pollute a lot of data into their system
some browsers don't clean out local
storage the same way that they clean out
temporary internet files so be careful
with that but as you can see it's pretty
straightforward on line 37 i use
json.stringify because i'm pushing in
string values so local storage session
storage storage string values but you
can do structured by json serialization
next let's talk about the history API
how many of you have been familiar with
or pissed off about those hash bang URLs
the ones like twitter has and so forth
okay yeah hash ping URLs kind of the
bane of our existence they were invented
as a hack to solve the problem that for
years and like a decade or more we
didn't have what we actually needed in
by way of JavaScript ability to manage
the history queue of your browser the
backward and forward q we didn't have
what we needed and so we invented all
these ridiculous hacks
those problems in particular what we
wanted to be able to change the URL of
the browser so that there was some sort
of state preservation in the address bar
but we didn't want that to cause a whole
new page refresh the awesome part is
that html5 came along and said let's go
ahead and pave that calv path let's go
ahead and give them that functionality
they've been needing and let's do so in
a structured way so we have a set of
extensions to our existing history
capability there is a rapper called
history jas i highly recommend using
polyfills and and other things like that
when you can history Jas is awesome
because it does fall back to the old
behavior in older browsers for you so
you don't have to think about it but you
can see online 38 I'm using their
unbinding I'm listening for the state
change that tells me when the user
clicks the backward and forward button
when when they do that I get a state
change and that allows me to respond and
load up the contents of the page in my
single page app the way I would want to
and then you can see here replace state
and push state that's how we manage that
Q so replace state does what it sounds
takes the existing entry in the address
bar the existing entry in the address
bar as well as in the backward for
review it takes that existing entry and
overwrites it so I use this in the login
page for instance login page of the app
once you have logged in there's no
reason for that login page to be in your
backward forward cash because you're
never going to want to go back to that
login page just to be redirected so I
after you're done with the login page
the next page you go to I go ahead and
replace that with the new page that
you've gone to thereby removing login
from the Q push state on the other hand
pushes it in creates a new entry and
that creates a navigable and as you see
if you play around the game later you'll
see how it's a single page app but it
does actually manage the address bar
with index HTML and other types of you
know exactly like you would expect but
it's not making full page requests the
reason I do that is because there's a
socket connection for this game and I
don't want to re-establish that socket
unnecessarily every page load so use a
single page application concept and we
use history API to manage it a lot
better next we'll talk about app cache
I'm not a huge fan of app cache and
there's actually talk that was just
recently given you should definitely go
look up
cash douchebag it's an awesome talk
going google that basically app cache
does a lot of problems it has a lot of
promise and it has a lot of problems and
I do not use this you can see in my
little to do note I do not use this yet
in the application because I'm still
under development I would highly suggest
that you not use app cache until your
application is basically done because
it's a real pain in the butt to to deal
with clearing out that app cache are
always updating a file I'm not going to
spend a whole lot of time talking about
all the problems of app cache but I will
talk about the JavaScript API that it
gives us that helps smooth out some of
those problems so that the main concern
that we have is that when an application
is AB cached it's really persistently
cached and even if you update the files
a user doesn't necessarily get notified
and even on a refresh they don't get
those files and even if you take the
extra step of updating your manifest
file which is what you have to do to
notify the brown now it takes to page
refreshes before the user actually gets
those files so like I said it's really
really persistent caching for the
offline use cases and so forth so the
JavaScript API helps us deal with that a
little bit inside of the running of the
page and I might hook this up on an
interval in my application or you may
have it as an on-demand button but
inside I can tell the browser go and ask
if the manifest file is updated and if
it has been updated go ahead and fetch
all those contents in the background and
then I can listen for when that update
finishes and I can prompt the user and
say hey there's new files would you like
to go ahead and refresh so we get those
new files so that smooth things out to
one page refresh instead of the ugly to
that users normally have to do canvas
this is a screenshot of a part of the
game and what I want you to notice it
may be hard to see for somebody in the
back but I don't you notice is the
slight grid effect that I have overlaid
on top of this image this creepy clown
that I've up they uploaded I have a
difficulty selector down at the bottom
and so if you select hard it makes
smaller tiles and more of them but I
wanted an effect to overlay the grid on
top of the image to show you where the
slices are going to be made but I didn't
want to do so in sort of the ugly way of
just drawing lines and canvas gave us a
couple of interesting advanced features
to allow us to a comp
so we'll take a look at that code the
first thing is that I can take an image
inside of an image element or you know
well basically inside of an image
element or a canvas element or video
element but I can draw that image into a
canvas using the draw image command and
it has a variety of different ways that
the parameters can be used but if you
take a look at the specification for it
you can see it's pretty straightforward
what these parameters are the original X
Y width and height and then the new X Y
width and height so what that boils down
to but we draw from an image element
into the canvas and then I get the image
data back out of the canvas as a data
URL what's awesome about this is i now
have i've used the canvases power of its
resampling and resizing and cropping off
of my image so that I have it in a in a
whatever image you've uploaded I've got
a predictable image ratio if you will
and and now I've got it right back
inside of an image tag as a data URL
without any trends you know transfer
over to the server and asking it to do
it with PHP or anything like that it's
happened right inside the browser with
two commands draw image and two day to
URL and I find in the work that idea
with canvas I do this a lot I trade back
and forth between images and canvases
back and forth and it's incredibly fast
very efficient and they these two
functions make it very easy to do the
next thing is I wanted to so now that
I've got a predictable image now I want
to be able to draw that grid so the
first thing is I can't actually use
lines because I mean use clipping masks
and in canvas unfortunately a line can't
participate in a clipping mask but if I
do a wrecked a rectangle that's the
shape of a line just two pixels wide
then it will participate in a clipping
mask you can see I don't have an arrow
tip and online 349 context clip so what
I've done is drawn the grid and made the
grid a clipping mask and then i set a
global composite operation to lighter
and a global alpha 2.7 and then I draw
that image back onto itself twice on top
of that that grid mask so it only
lightens the areas where the grid was
clipped and not the rest of the image
and that's how I achieve that effect of
overlaying the grid on top of the image
another way that I use canvas is I take
the big image that you've uploaded and I
slice it up and I didn't want to do a
bunch of JavaScript on the server
necessarily for that although there are
ways to do that in node you can use a
canvas emulator on unknown and I could
have done it there but I've got canvas
inside the browser you've already
uploaded it locally into the browser so
why not go ahead and do all the slicing
inside the browser so that's what I do
you can see here that this is these are
the tiles once you're starting to play
the game these are the tiles of the
image already sliced up but these are
all image elements they're not
individual canvas element so how do I
get all the individual data URIs for
those and unsurprisingly i just used raw
image i loop through and grab all those
tiles one at a time from the original
canvas into image elements so it's
pretty straightforward and gives you a
lot of power and then I push it right
back in creating image elements using
the two data URL as I said you do a lot
of trading back and forth and at least
in my coding patterns okay so that's
kind of an introduction to some of the
maybe more basic stuff that html5
JavaScript gives us now we're really
going to get addicted to some hardcore
stuff this is the part that I really
have the most fun life so we're going to
take a look at drag and drop that's
native dragon dog of course you can
always still emulate and sometimes you
do have to we've got local file access
that's reading local files we've got xhr
to which is a whole bunch of extensions
the one we'll talk about is actually
being able to upload the file contents
directly using an AJAX request web
sockets using socket i/o and then web
workers so native drag and drop allows
you to take an element and say this
element is draggable and I want you to
be able to drag it around the page
that's not particularly interesting and
we've had that for a decade what's
really interesting and we haven't had
for a long time we haven't had until
just recently is the ability to drag an
image off of your desktop directly into
a web application and that's what I'm
showing here I've got an element on the
page that I basically make a drop zone I
say it's okay in this drop zone for you
to drop elements and then I can drag it
directly off of the browser you know off
of the desktop onto my browser and drop
it there you can see and when you play
around this you'll see that I can
actually that that thing only turns
green when you are dropping
an image file and so I'm able to tell
what kind of file it is you're about to
drop and only allow image files and
things like that can even check the
image size to make sure it's not too big
other things like that so you can get a
whole lot of functionality that would
have been basically impossible in web
apps you would have had to use Java
applets or the things like that this is
built into the browser and it's only a
few lines of code so we'll just briefly
look at that so here I'm I've got file
dropzone line 884 file drop zone I
listen for some events i'm using jquery
just because it's helpful to not have to
deal with all the cross browser crap
although when you're dealing with html5
browsers there isn't a lot of that but
it's helpful to make some smooth out
some of the event handling and Ajax and
other things but by no means is this
jquery only but I'm binding them
listening for a couple events dragged
over and dragged enter that's the drop
zone that it can respond to when I drag
over it I then ask is this a file of the
type that I want to accept and go ahead
and change it to be a green box or the
dotted line around it drag leave when it
leaves unsurprisingly we go ahead and
take the green off and then drop is the
important one we want to listen for that
event and when you drop a file element
onto the drop zone you're going to get a
file reference just like if you've done
a normal file upload and input type
selector you know type equals file and
picked a file there you're going to get
that same file reference of what you've
dropped in so the way I tell it that
it's okay for the way I tell the browser
that it's okay for you to drop some
elements is we set the data transfer
drop effect and there's several values
copy is probably the most common one
that you'll use or you set it to none
when it's not okay so here I'm saying is
it a file drag event if you're dragging
something that's not a file I don't want
to respond to it I don't even want have
two special case the code so I just
don't let you drop it unless it's
actually a file then we have here when
you drop file except in my code when
when drop file except is called you see
I have original data transfer dot files
their online 770 that's an array of all
the files that I was dragging from my
desktop into the browser application I'm
going to pass those along to a function
and we'll see here in a moment what we
do with the references to that file
but you can see there's actually just a
couple of lines of code to make this
native drag-and-drop enabled they're
literally with no other magic involved
at all so now let's talk about what do
we do when we want to get access to
files you may grab a file through a
standard input box or you may grab a
file that somebody is drag and drop but
in either case you're going to get a
file reference now what do we want to do
with it we want to read the contents of
that file this is impossible until
recently we now have the ability first
to look at the file reference and get
other information that we couldn't get
before in this case I'm looking at it's
mine type so I can make sure that it's
in an image that I want to accept if
you're dropping in an image that
couldn't be embeddable in a web browser
that's not helpful so I limit it to ping
gif and JPEG also I can look at its file
size and make sure you're not trying to
upload some you know 12,000 megabyte you
know super HDR photo to me and crash my
server and here's the important part
file reader this is a new API that's in
several browsers it's not in Safari of
51 I hear that it's coming in newer
versions of safari but it's in chrome
and firefox this allows you to
instantiate a reader object and read the
image and read that file and get the
data URL from it why do we want the data
URL obviously because we'll stick it
directly into an image element then
we'll start messing with it with canvas
so i have this file reader i have the
onload listener that because obviously
it's an asynchronous event i listen for
the onload and then i go ahead and call
the preview now what's interesting about
this code is that you'll see here in
just a moment I don't have to change
anything about this code when I call
preview i'm calling it if i've gotten it
from a drag and drop or if i've gotten
it from an input file selector it's the
same type of file reference i can get
all the same properties and read it in
exactly the same way local files on xhr
too if the user does not have a file
reader if they're in a browser that has
a lot of these capabilities but say
they're in Safari 51 or some of the
Safari Mobile's that don't have a file
reader you want to provide some sort of
work around for them and the workaround
is that you can send that file using
Ajax and then get the image back so in
this case the only important line that's
front from anything you've ever seen
before is that when I send the file
their online 547 it's actually sending
the files binary data up to a server and
I have nothing more interesting than a
PHP file that simply takes binary data
and spits back out a data URL so i have
a data URL either from my server or from
the file reader api but in both cases
once i have that 80 URL i can do all
those canvas things we just talked about
file readers incredibly powerful and
it's the first step in a whole new set
of things are going to be able to do
with local files chrome is experimenting
with local file systems literally being
able to create a virtual file system
directly on the system on the user
system and manage files and folders and
all kinds of things like that sandboxed
away from any of the rest of their stuff
so it's secure but you really get a full
powerful API through some of these
things so local files are really getting
cool in html5 JavaScript so are we
getting addicted yet I hope you guys are
getting interested in some of this
really cool stuff and what I also hope
you're seeing is that it's not that hard
to weave these things together into a
single application it doesn't have to be
some of the stupid toy examples we see
out on the web there's a plausible story
for putting all these things into a
powerful web application not that my
game is powerful but there's a way to do
this kind of stuff so let's talk about
web sockets web sockets are what I'm
using to keep the browser constantly
communicating with the server it's a
two-way communication street instead of
having to do long polling or other
things like that now I used socket i/o
there's a number of other web socket
emulations libraries out there socket
iOS is my favorite it has a whole bunch
of fallback things you know for older
browsers even ie flash and all kinds of
crazy stuff so basically can give you
the same API and you can have that sort
of emulated layer in the older browsers
and direct web socket connections in the
newer browsers but keep your web
application constantly connected that
will allow your server to update things
that the browser has not asked for yet
so it's a two-way communication channel
sort of that push notification if you
will so I'm using it here just to once
I've logged in I've established a
connection between them and each time
you refresh your page I just
re-establish that same connection again
using the session storage stored session
ID so let's take a look at what the API
for socket i/o is looks like using here
the first thing is I make a very simple
connection I'm connecting to my server
and i'm using a namespace that I call
select site I actually have two
connections of web sockets that I make
in this app and I'll explain that in a
little bit why but the first one is site
and the other one is called ww-what
you'll explain a sec but it's very easy
to use this name spacing right on the
end of the URL and socket i/o will keep
all that communication separate in in
those namespaces we listen for events
using socket on in this case socket on
I'm listening for the disconnect event
so if I'm somehow disconnected from the
server I want to make sure I listen for
that and then we send events using emit
so socket on on suck it down on to
listen for events soccer team it to send
events this is a two way back and forth
the really cool part was seen in just a
slider to the really cool part is that's
almost exactly the same code you write
on the server because the API is the
same if you're using a course inside of
something like nodejs socket i/o also
has python bindings and PHP and some
other job i think and some other things
like that but path of least resistance
for me obviously was javascript in both
places using nodejs here's what it looks
like on the server unsurprisingly socket
that I met when I want to send we do
have some additional functionalities I
can select a particular name space using
the dot of and then dot in is actually
selecting a channel with inside of that
namespace so in this case I want to
restrict the communication that's going
out for an individual game only to the
people that are actually playing that
game as opposed to people playing
another game so I can really get fine
grain in terms of how much data is going
out and and not sending out too much
data not just broadcasting every message
to every single connected user and
finally we'll talk a bit about web
workers how many of you guys know what
web workers are let me see how much I
need to explain okay a fair amount of
you don't know what workers are so we'll
just dive I don't want to just show you
code not explain what that means web
workers are a new thing that's come in
in some of the latest generations of
browsers we are even starting to see it
a little bit on mobile basically it's a
way to solve a problem that javascript
has well some people call it a problem
javascript is single threaded what that
means is that when the browser is going
to update the page say you've moved an
element or you've changed some CSS
you've added some text or something when
it's going to update and repaint the
page it's using the same thread of your
processor on your machine as the
JavaScript execution which in some cases
is not a problem but in some cases if
you're doing an animation and you're
doing some heavy computation or you're
receiving an event from a server for
instance you can cause that stuttering
another reason why you see stuttering is
the garbage collection that happens so
you stuff all of your code execution
your CSS updating your markup parsing
all of that stuff it all happens on one
thread on the user's machine and in some
cases you can end up competing for
things and you start to see that
stuttering that happens with animations
and so forth so a solution to this is to
instantiate some JavaScript to run in an
entirely different thread and prior to
web workers we had no concept of how to
do that because javascript as a language
has no concept of threads built into it
and so we needed something sort of an
additional help and web workers or that
answer the browsers allow us to point at
another file another javascript file on
the server and say I want you to load up
that code I want you to run that in a
separate thread and that way if it's
running sort of in that thread and the
browser's doing some updates over here
this thing could be long-running and
blocking and all that and the browser is
still very smooth and you can scroll
around you get none of that jumpiness so
if you're doing a whole bunch of
communication say for instance in a game
or I've got a whole bunch of data coming
back and forth over socket i/o and i
also want for that when the user is
moving a piece around i want for that to
be smooth and graceful as possible one
solution to that is to put those in
separate threads web worker for the
soccer game communication and then the
main browser thread for making things
smooth while i'm dragging pieces around
so web workers allow you to instantiate
an asynchronous set of running
JavaScript code sort of in its own
sandbox and then communicate with it and
the cool part is you communicate with it
very much like you communicate with
websockets it's just a remote piece of
code that's running it happens to be on
the same machine and not on a server
across the internet but you're still
posting a message to it and listening
for messages back and the worker can do
the same the worker does not have access
to the Dom or any of those other things
it's really in its own sandbox but it
can send data back and forth and you can
communicate that way so we'll take a
look at what that code looks like here
we instantiate any worker I give it a a
file wjs and let me go back you listen
for messages using game were caught
message and you parse out those messages
in the same way that you would parse out
messages from socket i/o for instance
and you send messages using post message
so this is what's happening inside of my
main page ivan's I've got my main page
going on saying I want you to start up a
web worker for me and run that code over
there in that web worker I want to
listen for when he wants to tell me
things and I want to send him stuff
namely I want to send him go ahead and
get started message so that's what this
line 399 does says go ahead and send him
a start message it tells him what the
game ideas and that he can get started
and make his communication inside of the
web worker inside of wjs we've got a
couple things that are new to us first
is that we're able to synchronously
import other scripts so it doesn't have
to all be in one file in this case i'm
importing the socket i/o client library
it can run inside of a web worker that
allows me to establish a whole different
thread of WebSocket communication that's
unblocked from the main browsers thread
down here at the bottom on line 23 we're
posting messages that's posting messages
back to the main page and we're
listening for messages using on message
it's pretty straightforward and simple
now again there are poly fills and
wrappers that make these api is even
nicer but i actually wanted to show you
the underlying api to show you it's not
that I complicated actually it's very
simple to listen send and receive
messages back and forth and your code
looks the same so you don't do a lot of
mental context switching code looks the
same in both those cases similar very
similar to when you're writing WebSocket
code last thing I last piece of code
I'll show is in my particular game I
wanted to have a fallback
for some of the browsers which may have
advanced html5 functionality and cable
playing the game but they don't yet have
web workers this would be some of your
you know a couple of generation old
mobile devices that have a lot of things
like canvas and stuff but they don't yet
have web workers so this is a shim for
not having that work or API it does not
actually create a synchronous
multi-threaded JavaScript but it
simulates it using the same API so my
code doesn't have to worry about it and
in those cases those browsers would
still work the same but maybe have
slightly less performance in those few
cases were there conflicts the API is
the same so I create a worker API that
you can instantiate and I have
postmessage anon message as you would
expect yeah so so the question is do I
have an overview of the things that are
happy that our upcoming in html5 yes so
i'm actually i just started up a book
project called beyond html5 where we're
going to write about things some of that
cool stuff a number of things that are
coming up that are on the horizon we
talked about the the file the virtual
file system that you can read and write
files there's web intents a very cool
thing if you familiar with android you
know about intense but web intents
allows your web application to register
with the browser and say anytime
somebody wants to do XYZ action give
them the option to invoke my web
application even if they don't have me
loaded yet so say you're a photo editing
service you've got a person that logged
in to their site and it prompts them and
says hey this photo application would
like to register a web intent that it
can handle any kind of photo editing
that user may run across you know when
they find a photo on flickr or something
like that so then they say yes that's
okay and then they're on flickr and they
click something you know do do something
with an image the browser pops up and
says hey would you like to invoke that
photo editing application that you
authorized so web intents are a very
cool way for web applications to kind of
interact with each other sort of it's
it's distributed mashups if you will
allowing each person's web application
to handle different things shadow DOM is
another really cool thing that's coming
along it's just been kind of proposed
and it's working its way through the
browser has had a shadow Dom for a long
time and what that means is when I have
an element like input type equals file
there's actually more elements there
underneath that the browser doesn't tell
us about there's a button element
some other things like that calendar is
another example when you do an input
type equals calendar it renders a whole
bunch of Dom elements to show you that
calendar popup widget but you have no
access to any of that shadow Dom using
normal current technologies the shadow
Dom sort of proposals that are coming
along are going to allow you to be able
to access some of that stuff in some
interesting ways targeting it with CSS
and things like that but you're also
going to be able to create your own tag
types with your own shadow Dom so you
can push up a tag type that when it sees
that in the mark-up it knows that this
is the Dom you want it to build and this
is all the JavaScript code that you want
to associate with that element and then
inside of your markup you can simply say
you know tag fubar and it invokes the
fubar j/s and creates that shadow DOM
and it works exactly like native
elements do so it's giving us that very
cool functionality that we currently we
have to go and create all those elements
ourselves and then we have to make sure
it to be very careful through CSS
targeting that other things on the page
don't affect that this allows us to
create that sandbox with shadow Dom some
other things peer-to-peer WebRTC is an
API that's coming along in a couple of
the browsers right now chrome I
definitely as I think Firefox is getting
it as well WebRTC is going to allow a
direct connection between your browser
and my browser without a federated
connection to a server so we'll be able
to do peer to peer you know video to
know video chats and things like that
games like this the communication
between us could go directly without
going through a server so there's a
bunch of really really cool stuff that's
happening and I would say this it's not
particularly useful to try to put labels
on things and say well that's html5 and
that's HTML 6 that's a stupid label
that's just marketing buzz words I think
html5 signals this whole new open
acceleration of every possible
technology in the web platform it's open
that we all know what's happening we can
all participate in it so I think html5
and friends is the term to use going
forward to talk about all these things
but there's definitely a lot of very
cool stuff that we don't even fully know
how it's going to work yet but we know
it's coming we know these browser
vendors and specifications are really
trying to experiment and that doesn't
even scratch the surface of the cool
stuff that they're thinking about for
CSS for some really amazing stuff there
so there's a bright future even the cool
stuff that we talked about today which
is kind of more
we baked and you can you can actually
build applications on it'd be hard to
build an application entirely around
something like web intents yet because
it's only in a very experimental version
of Chrome but as an example the social
sharing company add this I don't know if
you guys saw but they just released you
know an update to their service that
uses web intents for browsers that have
it so now when you are on a site you
don't even have to click and add this
button it'll just say would you like to
go ahead and share this with Facebook
because it can register that for you so
there's some very cool stuff that's
happening the web applications that we
know today going to be entirely unlike
what we see even a year or two from now
so good question so just any other
questions final my final question to you
guys I do want you to you know ping me
if you have any questions find me on
online or on Twitter things like that
but I do hope that you will go away from
this believing that html5 and javascript
is something you practically can use
right now thanks for having me I
appreciate it very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>