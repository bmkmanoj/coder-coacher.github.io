<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using Pull Requests to Drive Continuous Delivery - Forward 4 Web Summit | Coder Coacher - Coaching Coders</title><meta content="Using Pull Requests to Drive Continuous Delivery - Forward 4 Web Summit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using Pull Requests to Drive Continuous Delivery - Forward 4 Web Summit</b></h2><h5 class="post__date">2016-03-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_wp8T3pu-tI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I am IQ Lorenzo I am a product manager
at Heroku and I am the product manager
for pipelines and the features that are
collectively known as Heroku flow this
is at its core it's a continuous
delivery solution that we'll talk about
here and it is in part powered by pull
requests and in large part powered by
interaction with version control system
github so yeah my name's Matt Krieger
I'm responsible for a developer advocacy
at Roku so if you have any feedback
about this product so you use it and you
love it or you hate it please let me
know you can let me know it twitter at
matt underscore Krieger or Krieger on
Heroku comm so I really want to hear
about your experiences on the platform
obviously especially as they relate to
this feature or even this presentation
so that's me
okay so first we'll talk a little bit
about continuous delivery this is
probably the major point that people
become confused about and since we are
talking about it continuous delivery
solution I just wanted to define the
terms upfront continuous delivery means
as it says here that all code changes
can be deployed and run immediately and
then made available to production it is
different from continuous deployment
where every time you make a coat a code
change it is deployed and tested like in
many cases tested in production but it
is more immediately deployed continuous
delivery the system by which when you
make code changes there's a very
organized set of stages along which you
can test and integrate and then deploy
to production and the trick is making
these many steps flow in a way that's
efficient and fast and not complicated
there's also as you guys are probably
familiar with continuous integration
this is something very different that
occurs like much more upfront after the
code is done it's really for testing the
code quality and the fitness of the code
to be built rather than testing it after
it is built and there are many CI
solutions and they integrate very very
well with continuous delivery as we will
see in the coming slides okay
so continuous delivery is sort of a big
thing now in part because computing
power is so cheap and configuration is
cheap what that means is there are
services
can spin up entire environments on which
you can run yourself we're in the cloud
and then very very cheaply very quickly
and then just destroy them and that is
something that's really new and is
driving new solutions in continuous
delivery by our company and a lot of
other companies so part of this it's
like a chicken and egg thing or why is
wire release is so frequent now it
releases are so frequent because you can
do this and you're expected to and
there's just a higher demand for release
frequency okay so oh my animation you do
not execute so this is the old state
where you can imagine throwing away one
of these metal boxes would cost you a
fortune
and now you can spin them up in the
cloud for basically nothing and so we
are in a new cloud world that is always
a line-drawing it is always blue or
purple or purple yeah alright
infrastructure-as-a-service yeah you'll
come and see commonly this turn will be
applied to the really big infrastructure
as a service companies like Google cloud
platform Amazon Asscher these are the
places that are providing the horsepower
for you to spin up and destroy these
environments but it is often very
complex to do that at the is level so
you use a platform in which to do it and
we'll demonstrate that ok so there are a
lot of companies that are starting to do
this sort of thing our friends over at
platform Sh this is a French company PHP
is a notoriously complex environment and
so what they've said is well every time
I make it get branch I'm gonna spin up
an entire gigantic PHP environment with
tons of files and dependencies and
databases and test the code on it when I
tested the code I'm just gonna throw the
whole environmental way when I merge the
branch so this is this is the sort of
tack that we have taken also with our
continuous delivery solution here you
can see that there are stages in
continuous delivery for us you'll see in
a moment in our demo how you deploy
typically your code to staging and then
you promote that code to production
and the key element of this is that you
are not building the code and deploying
it to the stage you are building the
code and then promoting the compiled
code what we call the slug to the next
stage that is an extremely fast
operation that allows you to migrate
through a develop so you had a
development stage a QA stage a staging
stage a production stage at each of
these stages you can have the code
migrate to the next stage and perhaps
run against run against what is if you
guys are familiar with 12 factor a a
very similar environment but perhaps
with production data in the end and
production and different stakeholders
evaluating each environment and at each
stage you may integrate code from other
features on the left most here column
here you'll see there is a new concept
of review apps that we've introduced for
those of you are familiar with pull
requests one of the most frustrating
things about Pro requests is that you
have the code in a pull request you
share it with other developers you talk
about how it might execute you comment
on the code and then you integrate it to
see how it runs we've backed up that
deployment process so now you can
actually run the code in a pull request
so you will see starting tomorrow when
you use github and you use Heroku
pipelines when you create a pull request
you'll see a line in the github
interface that says that you can test
that pull request code at a certain URL
and that URL is a Heroku container that
is a Heroku app that runs the pull
request code and allows you to test it
and in fact allows you to share that URL
with designers or product managers when
you merge these changes they will be
they will be part of the staging branch
you can test them there so I have it I
hope I have not spoiled too much of the
demo but at least show some context as
we go through the demo I've got a little
bit of thunder left ok just a little bit
though I promise not to ruin it how many
of you have deployed an app's are heroic
you before so about half ok ok all right
maybe I should do we'll take a little
left turn here I was going to jump right
into setting up a pipeline but I worry
that you might there may be kind of too
much magic at work
so what I'm gonna do is I'm actually
just gonna blow this app up if it's okay
with you it'll take the demo might take
a couple of seconds longer but just to
prove to you that it's really really
simple as half of you haven't deployed
to Heroku before so I'm gonna sleep that
app there goes our application so notice
here that I have a couple of production
applications
it's called jog this is the jog repo
it's on github you can clone this down
and deploy this yourself if you'd like
its job because it's Jif or gif gonna
end that debate what which one one way
or the other and the first thing that
we're gonna do is we're going to deploy
this application to Heroku now this is
the Heroku dashboard the first thing I'm
gonna do here and I just want to point
something out Heroku has been built by
developers for developers which means we
care about all the interfaces that
developers care about the CLI the
platform API and of course the dashboard
and so everything I'm going to show you
you could either do from the dashboard
or from the CLI but let's do it from the
dashboard since we're here anyway so
we'll create a new application and we'll
call this jog staging now the fact that
I'm tagging it with staging is going to
be important because this is a staging
application and pipelines is going to
look at that and it's going to figure
out where it belongs in our pipelines
which stage it belongs in so you've
created application and the next thing
that we're going to do is you can see it
brought us right to this deploy tab and
at this point we could create a pipeline
if we wanted so why don't we go ahead
and do that will create a new pipeline
so now we have this new jog pipeline
you're going to notice the first thing
that it does is it drops that staging
app or that's our staging app into our
staging pipeline stage and if we wanted
to over here on the right we could go
and find those other two that we have
jog prod Frankfurt and we'll just kind
of bring all of our apps together into
one place find out so we've got one in
Tokyo and we've got one in Frankfurt the
next thing that we want to do is we
currently have no relationship between
this pipeline and our github repo and
there's a one-to-one relationship here
we have one repo and github and we've
got one pipeline and so we're gonna go
up here to the right hand side we're
gonna connect to github and you can see
that I'm already off the indicated with
github but if you weren't this is the
point of what you'd have to so let's go
in search for that jog repo and here it
is we'll connect to it
so now that we're connected we can
enable review apps we're not going to do
that just yet I want to go into this
application for a second and we're going
to configure automatic deploys now
Heroku pipelines relies on a couple of
different features it relies on it's ok
it's ok the github sync and our github
integration and review app so the first
thing is github saying github stink is
going to take any changes that are made
to our master branch on github and it's
going to automatically push those to our
staging environment so you might imagine
a few minutes here when we merge a pull
request and it's automatically going to
get deployed so that's enable automatic
deploys and you can see here that if we
wanted to we could wait for our
continuous integration system to pass
first
so until our tests pass it's not going
to be pushed or a bit late and just to
clarify here this automatic deployment
is is to the server of your to the app
of your choice like say development or
staging and it's then within Heroku you
can promote that slug through to
production afterwards unlike typical
github deploys where you've like perhaps
deployed to production from github now
like was talking there I just quickly
went to the dashboard for this specific
application this is our jog staging
application and I just wanted to show
you how this deploy tab has changed we
can see that it's assigned to staging in
the jog pipeline it's very easy to get
to we can see that it's been connected
to github and if we wanted to we can
scroll down to the bottom here and we
can just deploy directly from github so
I'm gonna click on that and as you might
imagine if you've deployed from Heroku
in the past this is going to detect the
package of JSON that's in our repo it
knows that it's a node application it's
going to handle that build process for
us that's really the last thing that we
need to do to get this app running on
Heroku so let's leave the screen trust
me that's going to build in the
background we're going to go back to our
pipeline for a second so in our pipeline
we've got one thing left to do and we
can see here that it's building the app
so the pipeline knows what the state of
our applications are and it's giving us
real-time feedback here we can see it's
building if we wanted to we could look
at the logs but we're going to enable
review apps and you can see here that we
get to decide which so we've connected
our staging application to our github
repo and so what we want to do is when
somebody opens a pull request against
their application our github repo on
github or sorry the jog repo on github
we want to spawn a new review app so
that's what we're going to do here we're
going to say hey go to staging and we
can see we can create a new review apps
automatically we can enable that feature
and so there's currently not any open
pull requests
we should probably go and do something
about that yeah and when these put when
these review apps there's one review up
for each pull request that's created
they inherit the configuration from
their parent app in this case it's
staging so the app like knows how to
configure itself it knows what database
it has it knows what it needs to run the
code in the pull request that's coming
because no you may not want all of the
same things in your review app that you
want in your staging application or in
your production application okay so
let's go back to reap over seconds we're
gonna create a new poor class we're
going to our public directory here we're
gonna go to index dot HTML I'm sure
you've all seen a bit of HTML in your
day and we're gonna change this class
once it's loaded we'll change this to
mind-blown because that's how I'm hoping
you're feeling in a couple of minutes
you'll both be sweaty and have your mind
blown okay so we're gonna so we we've
already created a new branch and now
what we're gonna do is we're gonna take
that branch and open up for requests
because really a pull request is just
github so way of making branches way way
cooler way more collaborative so now if
I wanted to I create this pull request
and the first thing that you should see
a pop up on the screen here is that I've
requested a deployment because I have
this pipeline set up and we have this
integration between github and Heroku
we're working really closely with github
to make this integration feel
first-class we know that it's been
deployed so without even going to Heroku
if somebody on your team opened this
pull request automatically they can see
that it's being deployed and in a couple
of seconds that's going to update and if
we come back to the pipeline and we get
rid of this for a second and I'm gonna
give this a little refresh normally you
wouldn't have to but because I had the
logs up it was probably probably a
little bit confused now what you're
gonna see here on the left hand side is
the PRS being created and again there's
that integration we can see which pull
requests we're talking about we can see
that it's being deployed and why don't
we just quickly open this application so
we can see what it looks like in staging
so here's our staging application this
is the application that we just opened a
pull request against and if you send a
text message to that number right now
and voted it would go one way or the
other but I'm not leaving that up on
screen for long enough for you to do
that so okay so we're back at this
screen I'm going to give this a little
refresh right now and come back to our
jog pipeline and we can see that it's
still creating the app if we wanted to
we could look at the log and really
what's happening here is that same
process is playing out
it's figuring out that it's a note
application it's building it and it's
deploying it and in a real world
environment and the team save six people
you may have many people creating pull
requests you will see that column
populate with the pull request as people
on your team create them they may take
those URLs that you can view the review
F at and share it on slack or on HipChat
and then you'll see these things self
destroy once the pull request is merged
or closed I mean if you look at our the
one that we're using currently in her
oq4 dashboard there's tons and tons of
stuff there I'm sure there's some secret
stuff there if you take a picture of it
but I'm not gonna let you do that okay
so let's open this app in a browser so
here's our jog staging PR 28 and you can
see definitely mind blown if we compare
that here's our staging app and here's
our new PR so this is this PR that we
have right here and if i refresh this
for a second
all of this stuff is going to be real
time very soon but if we refresh it you
can see that it's been deployed and now
if I clicked on this it would take me to
that staging app so again somebody who's
on your team doesn't even need to know
Heroku is in the mix here there's going
to see that notification they're gonna
be able to click on it and hey presto
they're looking at your change and you
can see up in the top left hand side
here we've got PR 28 yeah and
additionally even for those people who
don't ever use the Heroku interface
they'll still have this URL available in
addition to the pull request
conversation to evaluate the code do a
question oh yeah so yeah and actually I
don't know if you noticed but it's both
update to PR
28 but I guess I messed that up so what
that's doing is I'm the app dot JSON
file which I can show you very quickly I
think I just went to it from well let's
go to it again
drug github will go here for a second oh
that's right
so this repository has this app JSON and
the app dot JSON is where we're
configuring what is installed what
add-ons are created in that review app
and you'll notice here that it says
Heroku app name is required and the
Heroku app name it includes PR 28 so
it's really easy to figure out which
pull request you're referring to and
link directly to it from your state from
your both your staging in your review
apps really important because you want
somebody to know what app they're
actually looking at right
so the next thing that we would probably
do at this point if you're working on a
team is someone of you're one of your
co-workers would come along and they
would say hey listen I noticed that you
been working on this and it looks great
to me so let's give it the old plus one
of course I have to do this to all of my
own pull requests because nobody loves
any of my code and so now I can hit this
merge pull request and as you might
expect when we come back two pipelines
you can see that our review app has been
torn down so it got cleaned out if we
clean up after ourselves here or
pipelines cleaned up after us and now
we've got this app being built in
staging and as you might imagine we've
merged that change in and if you
remember we set up github sync so as
soon as that change was merged into
master it triggered this process and
you'll notice here that the shot when
the build is complete the SHA will
change and you'll see that there is
different code and staging than in
production and the other thing that's
kind of important to note here is that
because this is our staging environment
and we haven't changed their
dependencies this deployments going to
happen much much faster because the
environment is the same
we've cached those dependencies we're
just going to drop them back in so the
deploy is already done and now you can
see here's the the SHA their share your
shot that should be my next that could
be the next poll yeah and so here's that
mind blown in staging right and and
somebody did somebody caught that number
and voted ok
and well done Touche ok so the next
thing that we would do is we would
promote this to production so we have a
couple of different production
environments and like just imagine for a
moment that you're sitting your desk and
this is your normal flow you've got a
server over in Tokyo I've got a server
in Frankfurt and you need to get the
code there the nightmare that you would
traditionally have to go through to make
this happen
hold that in contrast to what I'm about
to do so I'm gonna hit this promote to
production and then I'm gonna do this
very hard task of just moving my mouse
down here and hitting promote now if the
demo gods are feeling kind you can see
that we're promoting to production and
I'm gonna let Ike riff on about this but
notice that it's really really fast
despite the fact that we're going to
Frankfurt and Tokyo and this is these
are just artificial names like that's
really where these apps are being
deployed and I'll add that you are in
this particular case you're promoting to
our new private spaces product or
that is a basically a virtual private
Internet Virtual Private Heroku that
exists in a private environment so the
copy here is a very complex and slow
process if you were promoting from the
common runtime that's ordinary Heroku to
a production environment Norden Heroku
it would be like pretty much
instantaneous because you're simply
copying this logo over here that's being
copied to a data center in those two
locations in a private environment and
it still took maybe a minute I can prove
it to you
with this flag which which clearly you
couldn't just put inthe statically I
mean that has to be real and dynamic
right no it really is really dynamic but
look we've actually I think it is static
I'm not to be sure to be honest with you
but you can see here that we have a
local number in Tokyo and we've got a
local number here in Germany and just
like that we've taken a feature we vote
actually we deployed an application from
scratch took a repo deploy to Heroku
created a pipeline opened a pull request
looked at our changes I gave myself a
thumbs up and then we merged those
changes in on github regular flow it was
automatically deployed to Heroku
and the really cool thing about this is
we have this really nice layer between
us and the real world we have the
staging environment that we're lining up
with our master branch and when we
promote we're able to rollback so if I
went to one of these applications let's
go to jog prod Frankfurt for a second
and let's like there's a disaster I've
deployed something I shouldn't have I
can very easily just roll back to the
previous version and now when I open
this up you're notice that almost
instantly almost oh yeah because the
last person I deployed also had this
mess codebase but this is a previous
codebase but and and part of the part of
the purported benefit of continuous
delivery is that that happens very very
rarely that you actually have to
rollback production because you have
already tested the pull request in a
virtually identical environment you've
tested the merged code in one or two
development staging environments
everyone's you've done integration
testing and then it only then is it
pushed to production so roll backs
probably are much less likely by that
point and and there's no guessing here
because you have this sha or say
whatever you whatever you want to call
it and it's in both places it's not here
because I rolled this one back
see this was deployed two minutes ago
and it's the same codebase in both
places if we had a pull request it would
be there too yeah and additionally for
people who prefer the CLI there is a
full-fledged CLI interface in the what's
called the Heroku toolbelt which is the
console at which you can use a terminal
environment to control Heroku questions
nope you can choose whichever you want
to do like a rollout or something we
could take what we've already got that
code based on Tokyo but let's say we
looked at and we were like okay it looks
good so we're gonna X that one out we
could do it in a specific order we can
just promote back to I don't know what I
left there but whatever at Heroku some
places use this thing as a wall board
because it is live all the time you can
see what pull requests are active which
are old you know if pull requests been
hanging around for three weeks it's up
on the board maybe it should be
evaluated at the URL it should be merged
it should be closed so it makes like a
cool monitoring environment for people
who may not even be developers team lead
engineering manager product manager
designers yeah how are we on time I
don't know I have been looking I don't
even know what time this session ends
I'm just gonna go on forever yes
so you
oh sorry the the question I believe is
if you if something kind of catastrophic
happens when you merge and say staging
is totally screwed up and doesn't run um
well the first is it's staging so that's
very fortunate your code is not running
there you can you have a number of
options available for you can optionally
deploy directly from a branch on to
staging if there's a particular branch
or master that you would like to
redeploy on to staging you can back out
the build as you do for any Heroku
server there are any number of options
you can do to mediate the staging server
and that's part of why when you have
code that is running you'd rather
promote it than do a new build at the
next stage because you have real
certainty that that build works and you
you want to promote that working code
yeah so give you an example of that your
node everybody I mean we're a front this
is kind of a front-end conference so
everybody full-stack javascript e
there's a little bit right so node right
so one of the turkeys would note is that
you have NPM in the minute
and every time you deploy NPM needs to
be working otherwise your build isn't
gonna work well and there's historically
been some issues there but with this
flow that's really not a problem because
you know if the build was successful in
staging and you promote it what you're
promoting isn't something that's gonna
build again it's a complete it's a
binary right it's a slug so you're just
moving it over it's always going to work
and that's also nice when you roll back
from catastrophe because the build
process doesn't need to play out it's
already there pipelines that is the core
of this continuous delivery system goes
to GA tomorrow and you'll see the post
in our blog tomorrow so we're super
excited about it we hope you are too we
hope this makes your life a lot easier
in terms of single page stuff please
please come over check it out it's super
exciting the room is small we're filling
it up quickly but if you hang around
we'll make sure we get give you a demo
if you use ember react or angular in
your stack you are gonna want to be
there
cool thanks very much you guys thank you
so much we make sure that whistling gets
into the recording</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>