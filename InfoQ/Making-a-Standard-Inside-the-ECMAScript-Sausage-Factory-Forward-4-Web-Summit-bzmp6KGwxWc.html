<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Making a Standard: Inside the ECMAScript Sausage Factory - Forward 4 Web Summit | Coder Coacher - Coaching Coders</title><meta content="Making a Standard: Inside the ECMAScript Sausage Factory - Forward 4 Web Summit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Making a Standard: Inside the ECMAScript Sausage Factory - Forward 4 Web Summit</b></h2><h5 class="post__date">2016-04-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bzmp6KGwxWc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay I think it's about time we can get
started here I'm Alan worst Brock and I
was the project editor which I'll
explain what that means a bit more of
the echo script 2015 standard and what I
want to do today is kind of let you peek
inside what is the process of creating a
JavaScript standard and such is I'm sure
here over the course of this conference
in the classes you've heard a lot about
es6 or equi script 2015 and you'll have
to pardon the slides here don't quite
fit on the projection here and stuff but
but yeah so so equi script 2015's also
known as es6 is the new JavaScript
standard and just if you wonder where
any of these names naming comes from
whoops sorry here back back is the well
equi script 2015 comes from the year of
its publication and es6 comes from that
it's the 6th edition of the standard and
four years this was sort of the working
name for it about the time we published
it we decided we'd switch to a year
based name but it's all the same thing
whether you hear es6 or two thousand
thousand fifteen it's the new standard
for javascript so I've seen over the
years lots of confusion about what equi
script means and what's the relationship
between equi script and JavaScript and
notice I don't want to make sure explain
it FMO script is nothing nothing more or
less than the standard that defines what
javascript is so xmas script and
javascript are the same thing sometimes
I've run into people who think well
there is actually kind of two different
languages there's xmas script and then
there's javascript which is a dialect of
xmas script
you can have you can have a version of
ECMO script that isn't JavaScript and
none of that is true it's basically
they're the same thing and in your
everyday life talk about JavaScript
that's really what's the matter is
you're using javascript your programming
in JavaScript and hopefully you expect
the platform's you use JavaScript on
whether it's browsers or note or
anything else to be as current as they
possibly can with the current standard
for JavaScript that's xmas script
similarly you probably shouldn't worry a
whole lot about whether you're dealing
with the 2015 or the 2016 or 2017
version of X of xmas grip your use you
should be using the current version of
java script and you probably won't have
a lot of curious about that so it's it's
just javascript is what we're talking
about here so you can think of here of
sorry I got to get use to the buttons
here on this so you can think of the
standard up here which is the
specification of what you have to hell a
JavaScript implementation is supposed to
work what it's supposed to do and that's
the specification that everybody who
implements a JavaScript engine then
follows that and writes tests to make
sure they conform to it and stuff so
just to be to really get nerdy standard
snooty about this so so yeah quicker
standard is developed by a group called
technical committee 39 or tc39 it's a
technical committee of ECMO
International International is an
organization based in Switzerland that
hosts the development of standards and
there's all sorts of legal mechanisms
and stuff around what it means to
develop a standard and an ECMO provides
that infrastructure t 39 is the group of
technical experts who actually sit down
and and write the standard
ECMO 262 is a term you might hear
sometimes standards organizations like
acma love to assign numbers the things
and stuff and so equi 262 is simply the
document number of the equi script
standard and it goes through various
editions as it evolves and finally
something none of this process of
standardizing equi script involves w3c
that which a lot of people find
surprising I mean it clearly javascript
is a major component of the web the web
platform but it's not a standard
developed by the w3c it's developed by
by Eck ma and there is really no formal
cross-fertilization between those
organizations now in fact the same
companies are involved as members in
both organisations and sometimes even
the same people are involved in tc39 as
are involved in in development of
various w3c specification so there's
lots of cross-fertilization of that
sense but in terms of a formal
organizational coupling and there really
isn't any okay so kind of the backstory
here probably most of you heard the the
JavaScript origin myth that brendan eich
at Netscape in 10 days of May of 2095
sat down and implemented JavaScript now
I the reality is there's quite a bit of
thought went into what was going to
happen before those 10 days and sorry
and after the 10 days there was you know
kind of a standard development process
of evolving before it finally shipped
but the the S the core of the design of
javascript is what happened in those
first ten days and within a year after
that JavaScript have been cloned in
you internet explorer by Microsoft and
they called it jscript and so suddenly
the web had two implementations of this
language that for web pages to work they
needed to interoperate or work the same
and so there is a need of a standard and
the interested parties including people
from Netscape and Microsoft and and and
web some web developers got together
worked with ECMO to go start the process
of defining a standard and that created
equi script one if you will the first
edition of the ACMA script standard and
then over the next couple years two more
additions were worked on until in at
December 1999 the equity xmas crypt 3
specification was published and that
script three essentially defined the
baseline of what everybody knows up
today as modern JavaScript before a
fluke script 3 there is things like
exception handling and regular
expressions and a number of important
features weren't present in JavaScript
but kind of all the sort of normal core
java script that you expect to use every
day was kind of defined there in 1999 so
then after that I call it xmas scripts
travel to adolescents there's basically
right away right after es 3 was done
there's an attempt to do the to do it
right I think of this as the equus
script second system syndrome point the
very same people who worked on es 3
wrote sat down and created a much more
ambitious specification ahead of many
many more features and then nobody
implemented it for for various reasons
uh and and sort of the whole activity to
define a new version of xmas grip ended
and some work happened sort of XML
people came in at the time so this is a
time when XML on the web was
a kind of gaining interest and so
there's a lot of work that went into
trying to say how does XML fit into ECMO
script that sort of was finished and
petered out there is another attempt to
do an es for it went on for about three
years before that work was abandoned in
parallel with it I could have a much
smaller effort that was called es 3.1
started as sort of a tc39 side project
to clean up some things from es 3 and
kind of as a backup in case es for
didn't work out it didn't work out and
so in 2009 ekman script 5 the work that
was he has 3.1 ended up being published
and it was rebranded as es5 and it
introduced things like strict mode
jsonobject create a relatively small
number of features if it really didn't
it was very limited set of extensions so
if you look at it on a timeline and
unfortunately the scale here doesn't
work all that well but it's kind of like
there is a nice period of rapid
development of standards then everything
went off here include this black hole of
es fours and e 4x and what have you now
during that period was interesting
because one of the reasons i think the
original es for didn't get any
attraction well people are just starting
to use es 3 they really didn't know how
JavaScript was going to be used at scale
on the web and during this period of
distraction well Ajax sort of the web
two point O view of the world emerged
and so by the time we got out here to
where it's time to actually codify es5
there was an L a lot better
understanding of what the way of really
needed in terms of extensions to
JavaScript and it also gave room here
for the JavaScript performance evolution
where the performance of JavaScript
engines increased by orders of magnitude
and again this is one of these things
would this have happened if there is a
major new
of JavaScript to implement maybe not so
basically once es5 was done then the
serious effort got underway to really do
a major new revision and that ultimately
became es2015 or es6 and i'm not going
to make any attempt here to try to go
through all the details features of
what's in es6 there's other talks here
in classes that go into that but I want
to kind of give you a sense of the scale
of scope here now you can't really see
down here at the bottom here in the
black but es one was a hundred and ten
page spec okay so you kind of see how
the growth of the spec 110 pages 117
pages hundred eighty eight pages 252
pages and 566 pages so I really AM could
scale here that es6 es2015 is really a
major major major revision and extension
of the love the language and it really
is a culmination of kind of the fifty 15
years of evolution of the language from
where es 3 was in 1999 to what we have
today so one of the things people wonder
well what is how does tc39 work what
it's really like when it tc39 gets
together to meet and what goes on there
and how do people interact and those are
kind of two things people imagine which
isn't it I mean it isn't a giant formal
parliamentary style organ with hundreds
of people and very strict in formal
processes and stuff so that's not what
it's like it's also not a smoke-filled
room where you can imagine here I don't
know you can imagine you know Google and
Microsoft and Mozilla and and and and
Apple kind of getting here together if
their chips and making deals about
what's going to happen it's really not
like either those scenarios this is
a picture of an actual tc39 meeting from
last summer that's a it's a it's a room
full of people the the the people there
the actual formerly the members of tc39
are our organizations are companies and
you know so people like Google and
Microsoft and you know Mozilla and but
also companies that that have an
extension extensive investment in using
javascript which is almost everybody
these days but like you know twitter and
paypal and salesforce who recently
joined these are the the formal members
of tc39 and then they all appoint people
to to represent them at these meetings
and the people who are sent to these
meetings that's it's up to each company
to decide who to send but generally
there are people who are language
experts either at language design or
language implementation oh they may also
be people who are sip are sort of expert
users of the technologies of application
developers and stuff but everybody gets
together and what really this is
essentially the the the JavaScript
design team this is gets together and
have technical discussions about how how
the language should evolve what what
what features are proposed they talked
about we talked about the features why
the feature would be useful what use
cases that support how it fits with
other parts of the language so it's it's
getting a little large it's grown over
time but it is a very very technically
focused group of people working on
technical problems so just a sense of it
as we went in to working on equi script
6 these these are some of these are the
sorts of things we were looking at you
know what what was what was missing in
JavaScript what was holding it back and
so issues like modularity and better
abstraction capabilities how to make the
language clearer more expressive less
error-prone and some something we
explicitly were thinking about this was
six or seven years ago was this idea of
a better better compilation target we're
anticipating grew more and more use of
languages that compile the JavaScript
and so we wanted to make sure that the
the new version of equus script had we
actually considered what what transpires
or compilers of various sorts would need
and and I guess an over roading writing
thing and all this as we think about the
language is what are the things that can
only be done at the at the by tc39 by
the designers of the language if things
can be done in a library sencha Lee if
you can write a polyfill for it maybe it
doesn't need to be in the standard right
but if things that only this only the
the standards body can do is you know
define new syntax for the language
define change the semantics or add new
deep semantics into the language and and
so that's why you tend to see those are
the sorts of things there's a lot of
focus we have on so as we sit here in pc
39 and have these discussions you know
it's it's just like any other discussion
about javascript in the future of
javascript you might imagine right we
think about what kind of language is
this you know is it is it functional is
it object-oriented if it is
object-oriented what style of
object-oriented is it permissive is it
secure these are we continually talked
and we continually fight about these
things but we kind of fight a playful
way you know like our dogs here and
stuff because we really are trying to
find the medium of what what javascript
needs for for all its users it's certain
i mean javascript is really is
multi-paradigm programming language it
really is all these things and one of
our challenges is figuring out how do we
balance these if we go too far one way
towards functional or courage
object-oriented then it may
disadvantaged people who wanted to use
the language in the other way if we make
it to secure than the people who enjoy
the permissiveness of JavaScript may not
be served so we have to find a balance
between all those things another thing
we have to do is JavaScript going all
the way back to those 10 days in May has
a whole lot of baggage built into the
language and wouldn't it be nice if you
could really clean up some of that
baggage and and and get rid of some of
the error-prone features for example but
really our number one overriding
principle is don't break the web right
so there's lots of things we'd like to
do well no doubt we would argue about
exactly what those things are but
there's we would find some agreement we
there's lots of things you would like to
do to improve the the legacy baggage
that comes along with JavaScript and in
many cases we simply just can't do it
because it would break the would break
code that exists on on the web and we
don't want to break anybody's code right
so another thing we do want to look at
is sorry he really as we add new
features and stuff we really have to
think carefully about how new features
fit into the language as it exists or
say here we don't want to create a
frankan language we don't want to put
the you know we don't necessarily want
to put the you know the snazziest new
functional feature on the language if
it's not going to fit in well with
what's already there we have to find a
way to balance all the new features and
try to create a coherent whole out of it
so that in the long run when somebody
comes back three or four or five or 10
years from now
they don't see the language is a set of
kind of stratas that have have have
fossilized over time but they still see
the language as a coherent whole so one
of the things really common I call this
a minute wheat I see tweets like this
all the time somebody says es6 pick some
feature you know classes in es6 is based
on to insert your favorite language here
and there's there's a lot of I would say
misperception that what a language
design team what a standards team like
us are doing is we're simply harvesting
features from other languages and we're
shoving them in into fmo script and
we're taking them as we found them and
we almost never do that we wear as a
group we have broad experience with many
languages and many styles of programming
and we understand many features and many
different programming languages and we
try to evaluate them in depth of what
really the core of these features are
what what they provide to the programmer
and how we might integrate that if
that's a valuable feature how it might
be integrated in a coherent manner in
the JavaScript so for example gives a
survey question here is what language
had the most influence on the design of
equus script classes how many would say
java yeah fair number it's it's nothing
that surprised me is that so many people
just when they saw a class keyword
immediately assumed that echo script six
classes were based on Java classes
somehow or another or inspired from them
the answer for this is actually
JavaScript was the language that had the
most influence on necklace Creek class
definitions it in in fact if you if you
look at
javascript has always had a latent class
model it's been there since since xmas
script one it it manifests itself in how
constructor functions work it manifests
itself in terms of how the the built-in
constructors in the standard library how
they work and they all follow the same
basic model of constructors with a
prototype holding on the methods which
instances reference to prototype for
inheritance you can inherit up the
prototype chain that is the latent build
in class model of JavaScript that
Brendan I coated up in May of two
thousand of 1995 right and that is
exactly what is implemented in Equus
script 2015 on the left here you have
the code the manual wiring code that you
have to debt that you had to do a TS 5
or es 3 to build that structure what the
class model in equity 2015 does is
provide a syntactic convenience to say i
want it i can create a single syntactic
unit to say i'm defining something that
follows the standard equi script class
model and so that's what that's what
equus script 2015 classes do it simply
implements the the model that's always
been there so that's why i say
javascript is is the language that most
have the largest influence on on ESX
classes so so so basically one of the
things we're seeing here as we talk
about all these features as as you're
designing a language like this you can't
just take one one feature and add it to
the language and say oh this is cool
this is how it works you have to figure
out how everything integrates together
every feature interacts with every other
feature and you have to understand those
interconnections and stuff and so
I want to what I'm going to do here is
I'm going to walk through kind of a set
of steps here that show just kind of
kind of the reasoning of logic that
little led to a one particular set of
features in Equus rip 2016 and so we're
going to start here with the the closer
the closure and loop problem you might
see and yes three level JavaScript and
basically what we have here is we have a
four in loop and in this loop a callback
is being associated with some object and
that callback is passed as as a as a
function of object a a closure and that
closure references to variables here V&amp;amp;P
that are defined by the loop and down
here at the bottom where you can't see
very well it's basically all those
callbacks are being called and those of
you who are experienced JavaScript
programmers probably see a bug here a
bug you probably encountered the bug is
that each of these callbacks that are
installed in this loop all wind up using
the same value for V&amp;amp;P down here when
the callbacks are activated in fact the
values they use for P and V are the last
value is from the last time through the
loop where it's pretty clearly the
intent of somebody who programmed this
was thinking for each of these callbacks
was probably capturing the value of P
and V for the particular iteration of
the loop where they created the callback
so millions of millions of bugs in
JavaScript programs are created because
of this problem it's just really too
easy to do so one of the things we
wanted to fix for equus crip 2015 was to
make it to not have this hazard right to
make it so people didn't code use this
pattern that caused this sort of bug to
occur so how do you fix it how if you're
for the language design level how can
you fix it and what is the source
the problem the source of the problem is
that because even though here in the for
loop and inside the body the forest
statement there are these VAR
declarations what the semantics VAR is
really the same as if if the VARs are up
here at the top of the function these
virus are hoisted to the top right so
each time when you create this closure
what's being captured here by the
closure I reference to these function
level variables and when the function is
is evaluated it's just getting whatever
the current values were which was what
they had at the end of the loop right so
hoisting is what caused the problem and
so you might say well an easy fix of
this would be nothing let's redefine VAR
so it doesn't hoist and then if each
iteration of the loop has its own VAR
then we don't have that capture problem
but unfortunately people write code that
depend upon VAR being hoisted even being
hoisted outside of a loop they write
code patterns like this and so if we
change if we change that in the language
we would break those programs we would
break the web can't do that that's
against our rules okay so that we can't
fix the problem that way what we can do
while we can't change we couldn't change
the meaning of our we could add a new
type of declaration that added a
variable that had different sort of
scoping and so we added let and it
specifically readded let as a type of
declaration that doesn't get hoisted to
the top of the function but is has each
block that contains a let declaration in
this case eat the loop itself X as a
block has its own distinct variable that
shares the name V but they're different
variables and and when you do that then
then then each time you capture the
closure you're capturing in reference to
to the variable in that block not the
global one and and then you're
and that way it works okay so so
essentially every call back here uses
gets a distinct binding for V&amp;amp;P so that
fixes the problem but ok so now that
we've added that we've added this new
thing let and we've said it's going to
have this block level semantics but what
else whether the other characteristics
have let we have to worry about well
let's see here so it turns out that
JavaScript had a lot of legacy
peculiarities with declarations so we're
talking here about declaring a variable
well here's a little function look at
all those red x's is in essence a
different declaration of the same
variable of X and I use its it X is the
name of two different parameters it's
declared as a VAR it's used as a for
loop index it's it's declared within the
block of a loop there's a function down
here there's a function declaration
named X and at the very end somebody
calls X what's the value of x at this
point in the program okay it's well
defined by JavaScript but it is is very
basically this is crap is what it comes
out right now but it's crap we have to
live with but now we're adding this new
thing you let so what do we do with let
do do we do do we use do we give let the
same wtf's that got VAR head or can we
fix them somehow right what so I'm going
to ask myself a lot of this in the
process so so you think of you know
situations how let might be misused for
example what happens if you have to
let's in the same scope with the same
variable name sorry what happens if you
have both
nevar for the same names right so
remember these are all new things these
are things that couldn't have occurred
in earlier versions of language because
let didn't exist what happens if you
have a let X but there's also a
parameter named ex what what happens if
you have let in a function so so yeah
yeah basically there's all these
different issues that come up so so the
resolution we came to was okay these are
new things we don't want to duplicate
these errors we made them these static
errors so static error is an error that
occurs at parse time it's essentially
the equivalent what happens when you
have a syntax error so as we introduce
all these new declarations we had to
define rules for what the error cases
were and as a way to eliminate all these
issues so so es6 basically has a set of
rules is that it really principles for
declarations we ended up having to
articulate to explain how declarations
work in the language so it's like in any
scope if every every name has a unique
binding basically vahrin let
declarations at the top level you can
have both of our you have both of our in
a function declaration and they define
the same variable and you have to do
that because that's how es one through
five worked and can go down go down the
list here of these it's hard to read
here because of the clipping and stuff
but it's essentially all the new
declarations forms are much more
restrictive about duplicate def
declarations or different types of
entities being declared with the same
names and it's only in places where we
have to deal with the existing legacy
code that there are we fall back to the
rules that we had before that so I just
want to give you a flavor here of sort
of the thinking the three
the things we have to think about as we
add these new features we really have to
think about the impact the future across
the whole language so so what's next
basically what's the next step in in
equus crypt evolution if you kind of
follow history you might say well 15
years from now maybe we'll have maybe
this would have the seventh edition
necklace crypt 2030 and it would
probably be about eleven or twelve
hundred pages and between now and then
it's hard to say what would happen but
it would probably be kind of ugly so as
you know as we were as we were
developing Equus crypt 2015 was clear
that we needed to change how equi script
was developed and and well before we
released a trip 2015 we decided in tc39
that we would do incremental annual
updates so going forward at least for
the next few years the idea is that
there will be a new xmas crypt spec
revision every year the these revisions
and for the most part are probably going
to be fairly small but the idea is to
keep a continuing stream of improvements
to the JavaScript language not bundle
them all up for a very long periods of
time so and and and we also developed a
sort of a process to understand sort of
how features go new feature proposals
will go through tc39 and how they mature
to the point where they're going to be
ready to go into the specification so so
so features start here and we call a
strawman stage which is basically here's
an interesting idea or here's something
somebody thinks would be good to add to
the language they go through a process
of tc39 evaluating that deciding that in
fact yes maybe there is a use case here
that we need to support refining coming
up with actually a proposed spec of how
to approach the problem refining that
then eventually getting to the point
where there is a complete specification
and that there is a implementation
experience preferably in browsers that
people have actually tried to implement
that and only when we get to that stage
are things going to go into the actual
specification so so when you so what's
new and extra script 2016 well basically
there's only two new features there's
there's a new array function and there's
an exponential exponentiation operator
that's it that's the only thing that's
ready that's the only thing that's met
the criteria but the train is leaving
anyway now what this doesn't mention up
here is there are dozens if not hundreds
of actually bug fixes to the spec that's
also in in the 2016 edition and and
that's as important I think as these new
features is in fact we're able to
maintain and correct errors and stuff as
we go forward there are a number of
things that people thought were going to
be in xmas crypt 2016 that didn't make
it async functions SMD support some new
string functions there's there's a
number of things that various people had
had guesses about what was going to be
in equus crypt 2016 and in some cases
the the champions of those features even
promised they'd be in 2015 but they
aren't primarily because they haven't
had enough implementation experience yet
so probably showing up in 2017 but we'll
have to say you know kinda no no more
promises about when something is going
to be mature enough until it actually is
so can kind of some-some summing it up
here is kind of that's that's how we
made es2015 and that's how we're
planning on making it forward it's a
huge change the language it's it
respects the language that's gone that
as it was before and what actually
exists in out on the web I like to say
it has legs which I kind of represent
like this we've taken the baggage and we
put some legs on it and stuff and
hopefully we've made a much better
language so that's basically yet I got
here maybe two minutes here if anyone
has a quick question or anything but
yeah so so decorators decorators have
have interesting use cases decorators
are complex set of is a complex feature
that has lots of interactions with other
features of the language and it's hard
to get those right I think it's it
remain we'll have to see how he'll
decorators evolved and how they'll how
they'll proceed down the maturity chart
I think it's likely we'll end up with
something like decorators but I
personally wouldn't want to predict
exactly when and what all the details
will be ye of frontier middle yeah yeah
you you know I don't think this is very
many um no doubt or some people disagree
if you really want a function scoped
variable I guess that's a reason to use
var but I'd look really closely at you
know what your requirement is as a why
why wouldn't I want the let rules in
terms of take you know worrying about
duplicate definitions and stuff and so
I'd recommend using let and only if you
run into some unusual situation where
red isn't doing the job for you then go
to bar but okay I've done the left in
the back here oh ok a different question
I thought you're asking ah
oh gee so there's an active programming
language community particularly academic
programming languages ah so I try to
keep up on all that stuff you know I
guess if it just in the broadest sense
you just have to be kind of be a
programming language geek and follow
that stuff things new ideas take a
fairly long time to kind of germinate
and become practical to the level where
they might go in the JavaScript but they
eventually get there was one more cure I
think yeah you on the right yep I
thought yeah yeah when does it leave so
it takes it actually takes about three
months to go through the bureaucracy of
making something a standard so the idea
that it's kind of anointed as a standard
in June which means that the actual
document needs to be complete in March
and to be complete in March sort of
really all the final decisions have to
be made in January and in fact in
January there was a tc39 meeting and
that's where you know that final collina
the list was done zaz yeah
exponentiation is ready yes array
includes is ready know all these other
things are out so so yeah sort of kind
of in January of each year you would
expect determination of what's going to
be in what's going to be out and the
actual finished document would be out in
June okay we're really out of time here
but I think we're up against a break so
was there anything else any others yeah
right here in the middle yeah so so it's
actually allowed people to be exposed
and use new features much faster so
that's really good and it's actually
provided the way
some cases to actually get feedback on
those features so that's that's that's
really really good and the fact that
people are using them I think are
actually driving browsers to implement
things faster than maybe they wouldn't
have otherwise the one downside of it is
sometimes transpiler is implement
features kind of early in the cycle and
things change because you know when
things are in these early stages of
development tc39 can't make any promises
about not making changes or even that a
feature will ever ultimately make it to
the end of the process ok so I'll be
around happy to answer any questions or
anything or argue about stuff or what
have you so thanks for coming
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>