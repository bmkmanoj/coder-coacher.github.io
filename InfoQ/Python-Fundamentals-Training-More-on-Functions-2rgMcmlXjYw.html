<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python Fundamentals Training - More on Functions | Coder Coacher - Coaching Coders</title><meta content="Python Fundamentals Training - More on Functions - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python Fundamentals Training - More on Functions</b></h2><h5 class="post__date">2011-09-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2rgMcmlXjYw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're going to revisit our four kinds of
argument declaration and passing and
talk about a couple of common gotchas
and revisit zip with some of the new
power that we've got and then spend some
time figuring out how namespaces and
scoping works in Python which we've just
kind of waved our hands about so far and
not really examined particularly well
and then we can talk about the fact that
functions are first class variables in
Python and what that lets us do we'll
get into reading and writing files a
little bit parsing the command line a
little bit doc tests a little bit start
to tour some of the standard library and
I will just continue to develop our
classmates file to explore all that and
if we're lucky and we progress well
today we'll get into some sorting with
higher order functions and maybe do like
anonymous functions and closures by the
end of the day if we can get there so
that's our ambitious plan so let's go
ahead and review what we know about
functions ok so we declare functions
with a def keyword who give our function
some kind of name hopefully a more
meaningful one than that and what are
the ways in which we can specify the
parameters the function will accept that
what do you mean by designate parameters
ok and what are those kind of parameters
called positional parameters and they're
also mandatory if I specify parameters
like that a and B this is a function
that takes two arguments
and woe betide you if you only pass at
one right so positional mandatory
arguments how else somebody else how
else can we define parameters to our
functions
okay yeah we can assign a default value
and we are also implicitly giving this
argument a name these are named and
optional function arguments function
parameters and we can now call this
function and only pass at one argument
if we want to now I lied terribly
yesterday in interest of simplification
and this as long as we're clear on how
this works so far this shouldn't blow
your minds too badly we can mix and
match these two things right we can also
call any parameter no matter how its
defined in the function either by name
or positionally that's calling that's
not defining so if you notice that on
line 5 I said a equals to that first
parameter is a positional parameter so I
wouldn't have had to specify the name
and it doesn't specify a default value
but I still could specify the name how
you call the function is not dependent
upon how the function was defined in
this sense there's some limitations to
that obviously the other thing is I
could make them both be positional
parameters right so the second one when
i define the function has a name and a
default value and i didn't specify the
default value i just passed a value and
you can see this in section 7.2 and i
have it underlined in my much marked up
print out but any argument to a function
can be passed implicitly by position or
explicitly by name regardless of whether
or not it has a default value defined in
the function so our only limitations for
that are when we're calling all the
positional parameters have to come
before named parameters and the reason
for that is
I can call named parameters in any order
that I want but the order of positional
parameters is kind of crucial so line 7
I called my function foo with be equal
to 4 and a equal to 2 they're both named
i called them in backwards order from
how it's defined but you notice I still
printed out a first printed up to and
for a and then be it still knew which
value went to which parameter because I
explicitly named them in line aight i
specifically named the value for four
and then i just passed the positional
parameter and it doesn't know what to do
with that is that the first positional
parameter because there haven't been any
before or is that the second because
it's actually the second it's too
confusing you can't figure that out so
all your positional parameters have to
be first and then any name parameters so
I seem clear to everybody so there's um
there's a huge gotcha with defining
default values and it has to do with how
Python parshas your code and i'm going
to type in the example from 7.3 and
actually you go ahead and type in the
example from 7.3 and run it as well and
does it know the order yeah it doesn't
because in that case there would be no
there'd be no positional parameters and
and okay so i should say before we
actually get before jump to a mutable
arguments that's the other that's the
other little wrinkle we had yesterday
right when you define your function
there's one other two other ways you can
define your parameters remember those
new pieces of syntax star and star star
and the names are actually not
significant but the convention is always
tease args and keyword args
what does that function do any
if I could type here here it'll print
any positional arguments because it
specified star orgs is the array of all
the positional arguments that I handed
to the function and I just gave it a
keyword-based argument and it doesn't
accept any keyword-based arguments
similarly
what does that do right so star star
keyword args indicates that my function
accepts an unlimited number of named
arguments whatever their names are and
it's printing them and if i pass
positional arguments in this case it
complains and we can mix and match
I
and we can mix and match our arguments
that we pass to it and it'll accept both
you don't often see function that
defines us off with both star args and
star star keyword ours because it
doesn't really tell you anything about
what arguments that function accepts but
you'll very frequently see a function
looks like
something like that so if i had a
function that is going to move a polygon
around you have to pass it the top left
position of the polygon but then you
could define how you're going to move it
in a variety of flexible ways like you
might decide to move it based on its
relative position or its absolute
position or based on its top left
position or based on its middle and you
could define all that in your keyword
argument leave some flexibility but
you've got a couple of mandatory
arguments that must be accepted so
that's a more common mix-and-match style
okay so that's everything we covered
yesterday I think along functions now
for the gotchas from section 7.3 and
i'll do a simpler version here
okay so what does this function do
and it accepts B which is a keyword
argument that has a default value of an
empty list right so I might pass be
something and if not should be an empty
list
and that works out as you expect right I
printed an empty list the first time I
didn't supply default value what if i
change be inside my function
okay do what I expected now what's it
doing
you
it's remembering the status of the list
from function called a function call
which is not the behavior I thought I
was going to get and the takeaway from
this is Python is allocating the default
values at function declaration time when
the function is defined it creates a
default list and assigns it as the
default value for B name parameter B and
that is a mutable variable and we're
changing that mutable variable inside
the function each time you run the
function it's not recreating the default
values it's using the same default value
that it used when it define the function
so this is remembering the same value
for each round of the function and there
are times when that behavior is useful
but ninety-nine percent of the time that
catches you off guard that isn't what
you expected you thought you were just
saying hey I want an empty list by
default or you can pass me some stuff if
you made it at uppal is immutable and
you can't do anything to it you can
parse it print it iterate through it but
you can't change it if you want a
mutable variable as a default value and
you don't want it to remember it state
from time to time how would you do that
ideas yeah you'd have to declare it
inside the function
the parameter is not but the default
value is nope outside outside the
function there is no be B did not become
a global variable but what happens is
what happens when Python allocates a
variable it looks at the type whether
it's mutable or immutable it makes space
for that type on the stack and it
assigns a label to it and that label is
only visible in context of the function
of this particular function yep has a
whole different namespace it's a
different be no relationship whatsoever
yep and we're going to clarify scoping
and namespace rules in a bit but it
works as you would expect at least the
naive approach which is each function
has its own local namespace and its
parameters are visible only within the
functions own local namespace and it
doesn't remember if there isn't any
default value because it gets the value
from each function call the twist here
is the default value is calculated when
the function is defined and each
successive run uses the same default
value that you specify that yes there's
part of the function definition and that
normally doesn't screw you up when you
say default is true or default is one
there in mutable and strings are
immutable so you don't see it there
lists are mutable and it's pretty common
to say let's default to an empty list
and if you want to do that you need to
do this instead
let's see if this actually works and
here we're getting the behavior that you
know we expected so our default value is
none which is an immutable and we say
hey do we have the default value so
presumably the user did not pass us
something and if we do then let's go
ahead and initialize an empty list and
since that empty list is run every time
the function is run it works as we would
expect
so this is just this is one gotcha with
the default the default value
implementation of Python that'll that
will bite you at some point I've
stumbled on this myself even though I
know it I'm just explaining it now so
when you screw up you'll understand why
you screwed up later on and and let's go
ahead and look at the closely related
concept of calling functions now that we
understand how to define them I think
we've covered everything about how to
define them and their parameters we're
going to talk a bit today about
functions as first class objects in
Python which they are so in lots of
languages functions are kind of their a
little weird compared to other things
for instance PHP back there PHP lets you
refer to functions by name as strings at
least it used to but there was no way to
actually say this variable is a function
it did a look-up on a name based in your
namespace table yes totally as long as
what your initializing them to is
immutable then you're fine if what
you're initializing them to is a mutable
variable then you need to do the pattern
we just specified their online 28 where
you use immutable value as some sort of
flag and you could say and you can use
something like you say B equals negative
1 and then if B equals negative 1 inside
the function go ahead and initialize it
to the mutable things that you wanted
yeah so you still could pass like with
food that we have there I still could
pass presumably what you want to do is
pass it a a list and it works like we
would expect that list went to say again
nope because what we did is we said the
default value is none and if the default
value is none make it an empty list well
in this case the default value would not
be none because it's getting the value I
passed which is a list one two three and
in case in that case it doesn't run this
code it just depends a to b and prints a
and B so it's a little guard to check
your calling condition and you have to
basically you have to use immutable
values for your default parameters
unless you know what you're doing and
actually want to have essentially a
function counter ok so the related
concept of calling functions and
functions are first class objects other
languages like C lets you have function
pointers but there's some special syntax
around that that I distinctly recall
screwing up a few times in Python a
function is just a variable like
anything else if i type foo i see the
value of my function it is a objective
type function and it runs ID on it just
like if i type x is a string and
evaluate x i see the value of my
variable a string value obviously has a
nicer representation than a function
value and Python does not by default
show you the source code for your
function there are ways of getting at it
and but it is actually sort of a semi
compiled language that your source isn't
readily available for inspection but you
can see that it's just a regular
function and we've been calling
functions by opening parenthesis and in
this context parenthesis are the
operator to call a function I have to
call any callable which we'll talk about
this more later and what that means is I
could say
now what sex
yes well and functions are immutable
data types so you can see that the idea
is the same to pointing at the same
function and yes if i append the
callable operator to the end of my
variable it calls the same function so
functions could be passed to other
functions functions can be assigned to
variables functions could be stored in
data types like lists and dicks if you
want to have a list of functions to
apply there isn't any special syntax for
that just list your functions in a
regular list and there is some special
syntax for calling functions and it is
what you would expect we've seen two
cases so far so how did I call what did
I do with my parameters what's the first
parameter one here it's a positional
parameter it's just a value there's no
name associated with it and it's going
to go into whatever parameter was first
in my function and this is it's a named
parameter I could have left it off if I
wanted to i'm specifying a value and
that's completely it's related to how
the function is defined but remember
that it's not linked because i could
name both of them and I could pass both
of them positionally so it's the same
syntax for passing name parameters and
positional parameters as it is for
defining them but the one thing does not
depend on the other right you can have a
function that has all positional
arguments and you could name all the
arguments when you called it if you
wanted to make sense so the last trick
is the star args and star star keyword
args works when calling as well as when
defining functions so how about this and
again the name is totally insignificant
just convention is to use args
so args is a list the first position is
the number one the second position is an
empty list and I could say food start
orgs what is the implications of star
orgs what is my how is my parameter
handling working what is Python doing
what kind of parameters totally so I
have a list a list is a positionally
based container and Python unpacks my
list and uses each item in my list as a
positional parameter so the first item
on my list is the first positional
parameter to the function the second
item is the question Trenton I am NOT
defining the function I am calling the
function and star orgs works when
calling as well as when defining and
again it's independent of how the
function was defined I did not define my
function with star args my function does
not accept an arbitrary list of
positional arguments it accepts one
positional argument and one optional
keyword argument but I just called it
with two positional arguments and the
same rules apply
you can't do that my function takes two
arguments not an arbitrary list of
arguments and when I called it with star
args in a list that had three items it
says I'm sorry you gave us three
arguments and will only take two
arguments it is unpacking the values for
me and calling the function as though
I'd explicitly called it with three
arguments make sense to everybody and of
course
we can do this too
so what's going on what does calling foo
star star keyword args make Python do so
it's using the labels in the dict as the
names of the function of the functions
parameters and the values as the
corresponding value and that foo star
star keyword args is totally the same
thing as that's literally what it
translated out to Python unpacked my
dictionary use the name and value pairs
to call my function with named arguments
and again
my function does not accept any
arbitrary dicked of keyword arguments it
accepts two arguments one is a pushing a
little argument named a the second one
is the positional is a optional labeled
argument name v and if i pass it a dick
that has a label see it says i don't
know what this argument c is so if i say
foo keyword args I called the function
with one thing which is a dictionary
which it printed and then appended to
the second argument which is the default
value be it can't tell that I want to
unpack the dictionary if it unpacked
every dictionary at got or unpacked
every list that it got you could never
call a function and pass at a list so
star and star star is special syntax to
indicate unpacking of the arguments
contained in this complex type or
acceptance of arguments at a complex
type and again it's related the syntax
is the same you're doing the same sorts
of things but you can call a function
with star or adjust our start keyword
args regardless of whether the function
itself was defined with stars or star
star keyword args they do different
things in the calling context versus the
defining context two stars unpacks a
dictionary into keyword arguments 1 star
unpacks a list into positional arguments
and when you define a function 1 star
says I accept an arbitrary number of
positional arguments and two stars I
accept an arbitrary number of named
arguments and yesterday we were using
and some of you at least we're tackling
the unique roles in your classmates and
I was suggesting that we use zip to do
it and then when you start coding it you
see that you have to pass to zip and
I'll cheat here and just make myself a
list of tuples
we wanted the unique list of instructors
and I was saying you could use the list
and zip and set to extract that but zip
should do it none I pythonic Lee zip
takes multiple arguments where each
argument is a row so I could get what I
wanted but I had to hard code each of
those arguments and that returns me the
two columns first names and instructors
and I could refer to the instructors
list and I have all the roles and then I
could convert it to a set and I have
just the unique roles but I had to hard
code because I'm calling a function and
passing it parameters zip will take an
arbitrary number of parameters and I
might not know how many parameters how
many rows are in my list so how can i
call zip passing it all the rose in my
list without hard coding them
everybody see why that works classmates
is a list each item in it is a row when
I say star classmates it unpacks each
item in the list and treats it as a
positional parameter to zip so this zip
star classmates is exactly the same
thing as this zip classmates r 0 0
classmates r 0 1 classmates r 0 2 but
it'll handle however many rows i have
which is kind of typical when we're
programming we don't know in advance how
large our data set is going to be and so
it's nice to be able to call functions
and pass them an arbitrary number of
parameters so our question from
yesterday about unique roles could break
down to that is if all my classmate rose
give me the pizzettes into the columns
that corresponds to instructor you had
three tuples most of you so that would
be two instead of one make it a set
which throws away the duplicates and
convert it back to a list and yes you're
right and perceptive that looks a lot
like Lisp code especially all the
ketchup parenthesis at the end anybody
unclear on that thinking about that okay
in that case let's talk a little bit
about scope and namespaces and once
we've covered this which should take us
about 10 minutes and I'm go ahead and
turn you loose on the lab boys putting
up yesterday and I'll go and put up the
instructions again and after the break
we're going to talk a little bit about
higher-order functions or functions as
first-class citizens I start out with
and have you redo hopefully which you
can implement before the break so scope
scope is really important and to keep in
mind it's basically a question of what
variables can i see at any time
we already have some tools to
investigate and manage our scope what
tools do we have so far how can I figure
out what variables i can see yeah so
locals is a built-in function and it
shows all the variables that i've
defined down there at the bottom plus
there's some more that I Python supplies
how about Global's there's even more so
there's two namespaces available to us
at any one time our local namespace and
our global namespace right now I'm not
inside of a function so my global
namespace and my local namespace are the
same but we create new local namespaces
by doing lots of different things in
Python a few less things than some other
languages I there's an example 7.6 in
your book that notes some languages have
block scope so in see for instance if
you make a for loop and you have
brackets and you define a counter
variable that counter variable is only
in scope for the in closing bracket to
the for loop if you tried referring to
it after the body of the loop there
would be no such a variable C has a new
name space for that multi-line statement
Python does not Python creates new local
namespaces only on functions modules and
classes um not quite true but I lie
again for simplification purposes so our
functions if I define a function good
old foo is getting a workout here
and it prints locals versus looking at
locals outside the function their
dramatically different things right yeah
so how about this
what's going to happen when I call foo
it does no X is not in the local
namespace of the function so how does
the function CX Python follows look up
rules when it encounters a variable it
looks first in the local namespace there
are some other rules of your inside
classes and objects if you're inside a
function it looks first in local
namespace and then the global namespace
and then it gives up well built-ins are
sort of a special case how about this
what will I get don't throw a few
examples seem like they're contradicting
each other and the first one we printed
a variable it was in the global
namespace we can see it just fine and
the second one we assigned for to that
variable in the global namespace and
then we print it after the function is
run and it's unchanged so Python handles
one case differently and the reason is
because it's a dynamic language there is
no variable declaration in Python in
general so variable declaration happens
on assignment so line 76 when I say x
equals 4 python looks in the local
namespace for a variable named X if
there isn't one it creates a new
variable and assigns at the value of
four it does not proceed out to the
global namespace to do a lookup when it
does assignment because it assumes
you're doing the common case which is
creating a local variable in your
function does a local namespace for
modules a local namespace for functions
and then when we get the classes there's
also a namespace associated with classes
yes so you pass in variables that would
be in the local namespace with
parameters if I pass parameters to this
function as function accepted parameters
they'd be in the local namespace any
other variables and local namespace are
created by assignment because that's how
we declare a variable in Python we just
put a value put a label on a value and
at the top level of the same thing so at
the top level when we do variable
assignment it creates a new variable in
our local namespace which is also the
global namespace there isn't if you're
not if you're in the top namespace if
you're not inside of a function if
you're not inside of something that's
created a new local namespace local and
global are the same namespace there's no
new name space created and technically
when I'm running inside of a fun when
I'm running a side of a script like this
the global namespace is actually the
module name space
each separate module has its own
namespace but we'll see how that works
when we get to modules and packages
global variables all the way yes yes
it's sort of a special case when you
think about global variables so inside
of a function if you reference a
variable that you have not yet created
it will go back and check and see if
there is such a variable in the global
namespace and only if there isn't we
then get an error that hey this variable
doesn't exist and that can sometimes
lead to obscure bugs all bugs depending
upon global goebbels are obscure
excellent question and when you import a
module you don't import its name space
you create one new variable that points
to that module and and keep hold that
question because I'll be right back to
that
no hold that question I'll be right back
to that okay so i have a function foo if
my input parameter is equal to letter A
then it assigns X is 1 and prints one
and that works if it's something else i
get an error my input parameter was not
a and therefore x was never created and
it's not a scoping issue it's an issue
of code execution path the x equals one
statement never executed so there is no
local variable named x but if i had done
this before hand and x I take it back
it's a little bit smarter than that I
just noticed the error message by the
rules that I've described X should work
I should print the global variable
because it doesn't look up in the local
namespace Python checks for you and it's
basically for your sanity it notices
that there is a local variable X in this
function but that I'm printing it
without it being assigned to and it
doesn't even bother to go out to the
global namespace and it's kind of a good
thing that it doesn't because the
execution is function then would be
dependent upon global variables which is
usually a bad thing unless you're
explicitly looking for that
okay so your question and we're not
quite two packages and modules we will
be but it's a good question because
we're thinking about namespaces what
happens when you import a module to your
namespace do you get all the Global's of
that module in your and you don't it's
really nice Python is extremely hygienic
by default when I say import date time
what changes have occurred I have one
new variable in my local namespace which
because I'm at the top level is also my
global namespace that one new variable
is of type module and that variable
contains the module name space
everything is defining that module is
only accessible through the module there
is a way to be unhide genic we'll get to
it but it's usually a bad idea so yes
python slightly alleviates the dangers
of global variables and that very
frequently you're working with modules
and packages and at least your global
variables are only global to your own
module they're not global to the entire
program scope and that's not true of all
programming languages okay so yeah let's
let's answer that question what if i
want to change a global variable inside
my function I can't right because when I
say x is equal to 5 inside my function
it makes a new local variable instead
is that going to work what exactly is
occurring on this line am I initializing
a variable is their assignment going on
nobody wants to hazard a guess hey it's
5050 I'm not creating any variable here
I am referencing a variable and make an
assignment to its member since it's
mutable I don't create a new local
variable X and in fact that's the wrong
syntax if I try to create a dictionary
that way that didn't exist i get an
error i'm accessing not creating a
variable and that's legal this variable
happens to be immutable one so i can
change its contents but i'm not putting
a new name a new tag on anything so if
you want to change something in the
global scope one way to do it is access
a global mutable variable and change its
contents yes I could do assignment
positionally or a pin something to it
there's one other rule that's sort of a
shortcut for this and I think it's
it's the global statement and global
indicates to Python to reach out into
the global namespace upon assignment so
if you don't want to be creating a local
variable that shadows the global name
space you have to explicitly say my
function is going to reach out into the
global namespace and change it your
function has side effects we don't like
side effects in general in general we
don't want to use the global declaration
but it's possible okay let's go ahead
and tackle a little bit of a lab and
I've got a couple new Python idioms to
show you this is kind of what I put up
on the screen yesterday in case anybody
was bored as a four o'clock and was
ready to do something different so the
last thing that we had done successfully
and hopefully everybody's got to this
point if you haven't i'm going to
circulate around we talked about zip and
getting the unique role of our than
unique list of roles it's not
necessarily necessary that you complete
that and we're going to throw that
little piece of work away it was mostly
to set you up to see the beauty of star
args argument passing and their
usefulness but you should have a
classmate's up by that defines a
function print record and defines a
function get record and you're able to
solicit input and add it to your dicked
and output check and see if the users
input was a valid first name and
starting from that position we're going
to modify how our program works and
we're going to a couple different things
one is a really common python idiom that
you should use in all your scripts from
now on and here's how it works
Python defines a bunch of global
variables for us automatically and the
special ones start with underscores
wrong one here we'll get to special
methods that start with two underscores
but there's a bunch of special variables
that start with two hundred scores in
general the presence of two underscores
indicates some kind of provided or
special function or data type this is
name underscore underscore name
underscore underscore and you'll hear it
referred to as a dunder score variable
or add underscore method it's ugly to
type and look at and in general it's to
sensitize us that we're doing something
slightly unusual Python automatically
sets the underscore name variable with
the context of the currently running
program so let's see how that works a
little bit
I have a script and all my script is
going to do is print name
okay a printed name name is equal to
Maine I'm going to enter the Python
command line I can import my script by
specifying its name I do not specify the
dot pi extension and it's part of why
it's important that you named your
Python scripts ending in pi this gives
me a variable scripting but that output
line there is the result of my script
running is printing the name variable
and now it says scripting before it said
main the context in which my script is
running in this case is as a module and
it's given the module name to the name
variable the context in which my script
is running now is not as a module it's
being run as a top-level program and
it's given the special indicator main so
extremely common convention in Python
programming is checking for that special
identifier
and if and only if it is main running
the body of your program and what that
means is we've been writing scripts so
far where the body of our program is in
the global namespace it's just a series
of statements that execute and if you
import them they run but now when i
import my script nothing happens which
is probably what i want when i import
and if i want something to happen i can
specify it when i run my script directly
with the python command it does
automatically run so it is sensitive to
the context that's being used and is it
being imported as a library in which
case it probably better not do a bunch
of stuff automatically or is it being
run directly from the command line in
which case it probably had better run
and there's a bunch of other flags that
we can do we can do things like if
you're running this from the command
line run all the tests for my library
and otherwise do nothing but this is the
most common convention underscore name
specifies the running context of the
program and if it's being used as a
module it'll contain the module name yep
will I run as a top-level program or am
I being imported by other Python code so
it'll be the module name if it's
imported and it'll be main if it's being
run directly and in our case all we care
about is am I being run directly or not
and I'd like all your scripts in the
future to use this convention and as
we'll see this lets us do a few other
nice and nifty things right so this
gives us control over that all of our
code is happening within a function the
input point to our code is happening
within a function instead of being
top-level statements and we're only
calling that function which I'm calling
main but I could have called whatever
the name is again not significant or
only calling that function if I'm being
run as a top-level program so I'm
controlling the execution of my program
and saying if you run me directly let's
run all my code
if you import me let's let the importer
decide what code to run and it does mean
that we can write things that function
has full-blown scripts on their own but
other scripts can import them and use
things like their data structures or
functions and not get all the side
effects of actually running the program
and that print there is kind of
immaterial what's significant is this
statement here this is a top-level
statement it's not inside of a function
and it's checking and seeing if my name
is equal to main then call function and
else there is no else it doesn't do
anything so again if I'm running
directly it runs if I import it nothing
has happened I get to explicitly specify
what I want to have happen and I
wouldn't have to call main if I had data
structures in there I could access them
makes sense yes yes so we're actually
going to get there with our classmates
file and add argument parsing to it
today but yeah it is kind of common to
say I want to have a command-line
interface to this library that I'm
creating with these functions that do
some things and I'll handle a bunch of
command line arguments if I run it that
way and I also want to make it available
to other programs to use my functions
without worrying about kind of the main
program logic so yeah and it's it's just
a good idea it means that you can import
your code without side effects which is
polite to other programmers which may be
yourself if your program you know the
first thing it does is delete the
temporary file its going to fill up when
you import it from another program it
may do some things that don't have any
output that caused you trouble so it's
polite not to do anything whatsoever on
import and if you want to run things as
a script then hide them behind that if
name equals main check nobody should
ever import your module and all of a
sudden say hey why is all this stuff
happening I just you know I just wanted
to look at the help on this function
that's all I wanted to do and all this
stuff is happening yeah okay so we want
to use this if name equals main and I'm
leave that piece of code up the other
thing we want to do yeah no that's it ok
so our programs we have in their current
state we're going to change how they
work go ahead and put your main program
logic inside of a function you can name
it whatever but again main is kind of
the convention and it's coming from C
days anybody ever see programs have to
have a main function it's the default
execution start we're going to present a
menu of user choices instead of
soliciting input right away so we need
to handle the printing out the menu and
handling and the user's input for the
menu and then each of the things that
the user chooses needs to work and we
already have all those working except
for a number for filter by roll and I'd
like you to implement filtering by roll
with a loop and an if statement so
basically loop through all the rows of
classmates that you have and any that
have the right role go ahead and keep
and when you've got a new list of
students a new list of classmates that
have the correct role you can pass them
to your print Rose function for output
so your list all function that prints
all the records needs to be reusable and
then just for your own entertainment do
the same thing that I was doing be sure
to input your script start Python import
now let's call this one classmate 7pi
and notice that nothing happens which is
what you want and I should have
demonstrated that as well I can do
dÃ¼rer on scripting scripting is just a
variable that contains a module and it
has built ins for the built in a space
underscore underscore dock anybody want
to guess what that is
docstring exactly i told you is
programmatically accessible
there's the doc string the file which is
the file of the module probably the name
which we've already seen package which
we'll talk about in a while and one
local variable called main which is the
function that we defined so you can
introspect your script as a module and
help nicely presents all that
information the name is scripting where
the file is any local number of
variables prints the docs trained so
that last step is kind of just by way of
exploration and most of the work is
going to be in a number two and three so
let's go ahead and get there and we can
take a break um it's almost ten fifteen
so in three or four minutes we go ahead
and take a break you can stretch as you
like but go ahead and start working on
this I'll kind of circulate and see
where everybody is I like to make sure
everybody can complete this because as
usual we're doing it a little bit the
hard way and then I'll show you some new
tricks and we'll do it the easy way</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>