<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Slim down your app size (App Excellence Summit 2017) | Coder Coacher - Coaching Coders</title><meta content="Slim down your app size (App Excellence Summit 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Developers-India/">Google Developers India</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Slim down your app size (App Excellence Summit 2017)</b></h2><h5 class="post__date">2017-08-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tzeeCaAE4m8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">SPEAKER: Please welcome
Amrit Sanjeev again,
as he shares on how
keeping your app size small
will help you to scale
better opportunities
in a market like India.
Ladies and gentlemen, please
welcome Amrit Sanjeev.
AMRIT SANJEEV: Thank you all.
I am promising this is the last
time you'll see me on stage.
Anyway, for the
next half an hour,
we're going to talk
about some of the things
that we need to do in order to
keep the app size really small.
It is very important
that we do that.
And some of these things
you might be already doing,
but I'm going to, as
a sanity check, I'm
going to cover most of the
things that you should do.
The thing you should
actually notice about some
of these decks are, you
can't really pick and choose.
You really might have to
do all of these things.
They'll all add a little
bit of space saving,
and then all inches
will add to the mile.
So you really need to think of--
some of these things
are already done,
but if you're missing
something, go and add that
to your applications in
the next release cycle.
So quickly, these
things I'm going
to cover why we
should focus on app
size, how does it affect
us, and some techniques.
I am not going to discuss not
something completely radical
here.
There might be things that
you've already learned,
but what I want you
guys to understand
is note on all of them
so that you figure out
the one that you're missing
and then apply back to your app
to get that space saving.
So getting some basics
out of the whole idea.
App size, when you
talk about app size,
there are four numbers
that we look at--
raw APK size, there's
something called download size,
then there is an
install size, and then
there's an update size.
There are four numbers here.
Now, the reason why I want to
clarify some of these things
is because when you
talk and communicate
to others in your team as
well as your management
or to other developers
outside the community,
you want to specify which one
you're actually talking about
and which one, you
want to focus on.
There are teams which actually
focus on install size a lot.
There are teams which actually
focus on downloads, the raw APK
size a lot.
So it depends on what use
case you guys are actually
working on.
Some of these things might
become a little more important
than the other, and you need
to understand all these things.
Just to look through them,
raw APK size, the file
that you actually get
after you compile and build
an APK on your disk,
that's raw APK size.
There isn't an APK, by the
way, it's just a nicer file.
There are certain files-- if
you look to the compression
levels of each of
the file under APK,
there are certain files, which
are completely uncompressed.
Like the sources ARC,
they're uncompressed files.
So not everything in
APK is compressed,
but the whole file together,
that zip file basically,
is the raw APK size.
So if you actually build
using say Android Studio
and create an output file,
the APK file, that is
a raw APK size, if
you look at that.
Now, the download size
is what Play sends out.
Play compresses this thing
again so that over the wire,
the data that somebody
actually needs to get this app
is actually minimum.
This sometimes is very close
to the APK, and some of them
are kind of less.
So these two
numbers are slightly
different from each other.
The install size is
basically the size
that your app will
take when somebody
install on their device.
This would have things
like the .otf files,
which is the ahead-of-time
compilation files.
If you see before N, L
and M had that, and in N,
we have a JIT compiler now, so
we don't have the .otf files
as much as a problem.
But if you look at the landscape
of the ecosystem, as such,
you have devices on
those platforms also.
So the .otf files
will actually add.
The native libraries or
uncompressed and kept.
Again, they will add
to some size increase.
So that is the size that
is there on the disk
apart from the data
that you actually
have download like your
caches, your database size,
all these things will be there.
That's the whole size
that the app is actually
consuming on the device.
Now the update size.
Now, when you actually
update an app on PlayStore,
that doesn't mean that the user
will get the entire app again.
So the way a PlayStore works
is that it actually chunks out
and sends a patch,
which then the patch,
which is much smaller.
So if you have a 10 MB app
and you abated a few things
to it, at least
a 10.1 MB app, it
doesn't mean that the
user downloads 10.1 MB.
It downloads maybe
a patch of 2 MB.
And then that gets
patched on the device.
And then that 10.1 MB
app becomes a 0.1 MB app.
That's how Play actually
updates the whole thing.
So the update size is
always, at most times,
smaller than the
entire app size.
Now every time you
actually do an update,
this is what the user sees.
If the user goes to Play
Console and then looks
at how much he has to download,
then he'll see the byte size.
If they actually
have to install,
they see the download
size, not the APK size.
You can look at tools
like APK and [INAUDIBLE]
to understand these numbers.
Update size won't be there.
Update size, you can use
an APK size estimator.
There's another tool.
There's an open source tool.
You can take a look
at that, and that
will allow you to understand how
much is the difference if you
really want to control that.
Now, APK size out of
the way, let's look
at what's there in APK as such.
These are some of the
constituents of an API
or rather these are the
app code, resources,
and miscellaneous stuff.
If you look at app code,
that's a classes.dex, which
contains all of your code.
Then you have the
native libraries.
These are like if you're
using third-party libraries,
which are specific for
particular instruction set
or architectures, there will
be multiple .so files that you
have to add.
That will be part of
the app code again,
but that's separately kept.
Then you have resources.
All of your PNGs,
your drawables,
all those sort of
things are there
under the resource folder.
Then you have resources.arc.
The Strings file, the
identifiers, all these things
are here.
This, again, is uncompress.
One interesting thing that
I heard when I was actually
listening to the I/O this
year was that some developers
do compress this to make
the APK size smaller,
but that's a bad practice
because if you have
to read anything that has to
be read about that app, even
the app name, this file
has to be uncompressed,
which means it's a lot more
work that the app or the device
or the launcher is doing every
single time that app is there.
So there are certain things
which are counter-intuitive.
It might sound like
[INAUDIBLE] uncompressed file,
then lets compress it,
make the APK much smaller,
but it is best to leave
it as an uncompress
file because that makes it
more efficient to be used.
Now, when we look at things
under the miscellaneous,
you have assets.
You have assets.
You have things
like database files
that you might
want to write, raw
files that you
might want to use.
A lot of people actually put
their pre-processed SQL files
in there and then
loaded from assets.
Some people put
their fonts in there.
So there are files like
that which is kept in,
but then basically have
the certificates and keys
that you would use, and manifest
is the same manifest file.
So this is basically--
you [INAUDIBLE]
sense of what's done in APK
and what are sizes like.
So that is the basic spot
that we wanted to clear off
before we start into it.
Why should we focus on APK?
When we actually look
at a cost of an app,
we should look at the number.
And when we see that
it's zero, we think,
does that mean that
the cost is zero?
Is that the actual cost?
No.
The real cost is you
have to consider the cost
of downloading the app.
If you're on 4G or if
you are on a paid network
and you have 100
MB app to download,
that 100 MB downloading
is the cost of the app.
The regular updates
that you send out
is actually cost
that somebody is
incurring to get your
app to the latest one.
Again, also the data,
also the running the app.
So when you calculate
a cost of your app,
don't just look at the
sticker price of it
that you put on Play.
You also need to look
at the cost in terms
of-- like if you want to
estimate the real cost
impact to the user, you
want to estimate how much it
is actually costing them from
downloading and continuously
using the app.
And again, device storage
is another pain point.
1/3 of users run out.
This is 2017 and
1/3 of the users
in NBU countries, the Next
Billion User countries,
run out of space
on a daily basis.
And weekly, they remove
the most heavy apps,
the ones that actually
use the most amount
of disk space straight off.
So this is a real problem.
This is not like a problem
that was there in the past,
and we still have
people talking about it.
This is a real
problem today also.
A lot of people
run out of space.
And you might be thinking,
oh, my app is just 15 MB.
How is it going to just--
but you are also
contributing to that.
You have to see that
when you are not shown up
as the [INAUDIBLE] and
you see this old dialogue,
this is an older
version of Android,
but when you see that
thing and you click on it,
the first thing it says
these are the apps that are
taking most amount of space.
But interestingly in Android,
when this dialog comes in,
there's also a
broadcast that you get.
Apps can actually listen to
the broadcast and then say,
I will remove my cache.
I will clear up all my image
cache, unnecessary files
that I have stored, which makes
you a less likely candidate
to be there in the
top of that list,
less number of uninstalls
because of that.
So housekeeping, please
clear up your caches
which you use just for
the efficiency of your app
when the device is
running low on memory.
And people do actually
look at who is using most
and then clear it.
Maybe it is just that
your app is small,
but you have a lot of data.
You don't use any LRU
caches or you don't
use any time-based caches.
It's like a permanent cache
which just keeps growing.
Finally, two months later the
user sees that he's down to 300
MB.
And when you look
at the data size,
it will be 300 MB on
the list, and they
decide to remove your app.
So clearing your
caches, reacting
to some things like these
broadcasts are important.
Now, Proguard is
something most of you
guys might be using
anyway, but I just
want to call out because there
are a few things in there which
really needs fine tuning.
One, let me call
what Proguard is.
Proguard is basically
a job optimizer.
It basically changes the
code without changing
the variables and
how you can read,
the readability of the
code without changing
the functionality of it and also
optimizes to be more compact.
Now, a couple of things
it does very well.
One is dead code elimination.
If you ask a flag mini file
to be enabled, what it does is
it identifies the areas of your
code which you are not using--
It could be functions.
It could be classes--
that you are not using
and then removes them
out before building
that final app.
Which means when you add
a third-party library
and you use only a part
of the functionality
of the third-party
library, the part
of the library that
you're not using
is not added to
your classes.txt.
Because there's no
path to reach that,
so there's no point doing that.
But dead code elimination is
something Proguard does really,
really well.
It is enabled for
release by default.
So Proguard will
automatically do it in debug.
That's why your debug
release and these releases,
if you like, keep
these flags off.
You don't really need
to do a mini file enable
for debug basically because
it slows up, because there's
another process of finding the
dead code and removing them
and all that to happen.
So you don't really use
it for your debug reasons,
but you use it for
release and staging.
The other interesting
thing that it does
is obfuscation of
code, which basically
makes the code not readable.
If you actually tried to
disassemble and see, decompile
and see, you will see ABC.
If you get a crash report
for a Proguarded app,
you will get without
uploading the mapping files,
you will see AB--
A as a class name, B
as a function name,
B1, B2, this sort of thing.
So it shrinks all these large
names into really small ones
and makes it more undateable.
But it can also do something
called resource shrinking.
Resource shrinking basically,
when you say shrink resources,
it applies the same code
elimination logic down
to the sources that are
there in your domain.
Wonderful.
So things that are not being
reached, not being used,
it would automatically remove.
Now, I personally
don't prefer Proguard
to be the place where
things get removed.
The right way, in my opinion,
would be to go use lint
and realize what is
unused and then remove
all those unused resources.
If you right click
on your REST folder
right now in Android
Studio, you have an option
to say remove unused resources.
Then before it refactors,
it will tell you,
this is the files that
I'm going to remove.
You can actually
turn on lint and this
is one thing that some of
the teams that I work with
have done before is
if for certain lint
rules like unused
files, lint actually
finds those unused files.
It's a warning right now.
If you're skipping it, that's
because it's a warning.
You turn that to a fatal
error, which initially,
will become like if you
have not done it before
and you have a lot of files
and it becomes a big surprise
that the app will not
compile unless I remove
say 20 resources out of it.
But it's important
that you remove it.
And nobody intentionally adds
resources that they don't use.
Over a period of time,
you add, you remove.
There are certain functionality
which is deprecated in code,
but you forgot to remove
the assets for it,
these things happen all around.
So this is something
that you want
to ensure that lint is something
that you use to do this.
That way.
A couple of things to
think when you do lint.
Lint does not go
through Assets file.
So if you have
bundled five forms
that you don't use
anymore, lint is not
going to tell you about that.
Then also it's up to you to
keep your Assets file clean.
So if you have multiple
versions of your DB file,
you forgot to remove
it, lint is not
going to save you at that point.
So be careful about
these small things.
But having lint to
return fatal for a few
of these sanity checks will help
you keep the code clean over
a period of time.
Now, if you look
at an APK, which
basically bundles
a native library,
this is how it would look.
You have your ex-files strings.
That's the first blue.
That's needed.
Then you have the
architecture-specific native
library code.
Yes.
But if you look at most
third-party libraries,
what you would see is that they
will provide for say the 6 ARM
MIPS, ARM version 7, all
these different architectures,
they actually provide
you libraries for it.
But on a particular device,
on a particular architecture,
you're only going to use that
architecture and [INAUDIBLE]
files.
So you don't want to
list APK sometimes
doesn't make a lot of
sense if you really
want to crunch your app down.
And again, when you
look at drawables,
you have access DPI, all
those different densities.
Now, in any device,
there's only one density
that you're going to
use, which is the default
density of that device.
Three.
So you're not going
to change that.
So at the end of it,
when you look an APK,
it looks like this.
All those green points can
be eliminated, save space.
You delete all of it or
remove all of it somehow,
and the app will
be much smaller,
and the functionality
will remain safe.
No crashes, nothing will happen
because only the blue areas
are used by your
application on that device.
This is a case of
a universal APK.
Now, there is something called
a MultiDex, which Multi APK, not
MultiDex, Multi APK.
Sorry.
There you build different
APKs for different densities,
or you remove the
certain densities,
and then you say that
certain densities are not
used, which means
that you can actually
create a big case in such a
way that if an MDPI device is
asking that you only
serve the MDPI APK.
So you will have one for MDPI.
You will have one for HDPI,
Access DPI, and so forth.
When a device,
which is basically
with that density comes and asks
for that bit, asks for an APK,
you serve the right one to them.
That way you remove all
the other assets that you
add unnecessarily to there.
Very similarly,
you also have a way
to remove unsupported
architecture.
There are certain
architectures like MIPS.
In my opinion, there are not
many devices that support it.
So adding, and if you look
at your analytic sense
and track what architectures
your users are actually using,
you will be able to find
out the most common ones
and then write maybe
a filter like this,
which will allow you to
exclude anything which is not--
the library might include
all of them, including MIPS.
And you can say that this
is what I need to do.
I added to my APK.
This will still add
that way, you can even
split based on
architecture, and that there
will be multiple APKs
that will be generated.
So there's a
downside to Multi APK
approach is that you will
test the effort as well
as your maintenance effort
increases with that.
There is benefits.
There is definite
benefits for doing it,
but you also have to understand
the downside to your testing
because if you're
creating five APKs means
you have to test all the
five to ensure everything
is working fine
before you upload.
You ensure every one of
those versions I write,
all these maintenance
part of it, five of them
have to be signed all
before you upload,
all these things
have to be done.
So that is a downside to it.
The new Play sign-in that
you see when you upload
the unsigned APK, signed
by uploaded sign-in key,
that will allow a lot more
optimization to be done before
sending it to the external--
when a user asks for it.
So Play will actually read and
sign and send out your app,
and that way it will actually
be able to manage the splitting
and all that automatically.
Now come images.
Images is something
that we or use.
A couple of standard things
which most of you might have
already know, but
let me call them out.
Using the right
format of the images.
Instead of using a
ARGB 888, try to use
565, which is half the RAM usage
and half the disk space usage.
So if you're
loading a 2 MB file,
the same thing in
888 means with RGB
is like it basically
stores it with 2 MB.
And if you're loading
the same thing in 565,
it will load in 1 MB.
1 MB in terms of
1 MB of memory is
all it requires for it
because the format is more.
And visually there's not much
of a difference in there.
The loss of information
is so little
that usually you can't
find the difference.
Most of the apps that you
see and use on your devices
use 565.
Glide, by default uses 565.
Because I think you have to
set it to 565 to use that way.
Anyway, optimizing a PNG
is one way of [INAUDIBLE]..
There's a lot of PNGs that
you have in your Assets
folder or Drawable folder.
If you are using them,
then crunching your PNGs
is a easy, low-hanging fruit.
If you've not done
it, try doing it.
You will get a lot
of space reduction.
There are tools which actually
compress PNG and create
files, which are really small
compared to the original file,
and there is not any
visual difference
in the quality of it.
So try to use that compressor.
The other one is using
9-patch when it is possible.
There are a lot of things
where people have first splash
screens, where the
splash screen is
one icon in the center and a
full border around it which
is one color.
Things like that
does takes space.
And if you look at it, most
probably the splash page
is actually the most
expensive-- resource
that is there on that app,
most expensive in terms
of most space consuming in RAM.
By using a 9-patch,
you can actually
reduce that size again.
The WebP whenever possible.
WebP is another format
which is actually 33%--
roughly something between
20% and 30%, 35% more
of a compressed font.
So if you have a 1 MB PNG--
a [INAUDIBLE] version
of it would be somewhere
between 75k and 90k.
You get the point.
It's less than 30% roughly.
So that is something
that you want
to use serving from your
serving infrastructure.
The reason is this is
not just on the device
that you will actually save.
Assume you have a
million users or assume
you are in some infrastructure
on a day per user subs, 10
MB of data as images.
Now, assume you have
10 million users a day.
You have a very successful app,
so you have that much users.
But then you
multiply 10 million.
That's 100 million MB of
data served from your server.
For that bandwidth,
you pay for it.
Your business pays for it.
Would you like to make that
somewhere between 75 and 85 MB?
100 million MB?
Then you have 85 million MBs.
So the saving actually
becomes really multiplied
as you see it from
your server side.
&amp;gt;From a device side, it's
just one image which
is less, but still from a server
side, it saves a lot of cost.
But WebP has one thing.
If you're serving,
it is actually
simpler for 4.1 onwards
with more transparency.
So if you are actually
supporting devices,
if you're supporting
versions much below that,
then you need to take a call
whether you want to use it
or not.
And go on to the next one.
Vector drawable is another
one that you can actually
use to have a singular set
for multiple densities.
So things like icons
on your screen,
you should actually use an
SVG, and you should have this
backward compatibility
from build 14 and gradient
supporters from 24+.
So there is certain
vector drawables
won't solve all
type of your images,
but a majority of icons,
those sort of stuff
can be actually
changed into this.
And instead of having
five densities,
you can just put one
density that scales across.
It's Scalable Vector Graphics.
That's SVG.
So it can scale automatically
to different densities.
So this, again, one
thing to remember
when you do this is SVGs,
when they are very large,
they consume CPU and
memory because they have
to be expanded or rendered.
So very large SVGs are
not really recommended
because they take larger amount
of time and CPU to render.
So you want to ensure that
the smaller ones are SVG.
If you have really
large ones, you
have to test them
and measure them
how it is performing
on a low-end device
and see to it that's just
not too much time taken.
Pass translation.
This is a very
interesting thing.
If you look at support
library, for example,
how many of your guys
add support library
to an application?
How many of you have
used this option?
Not many.
So I'll tell you one easy trick.
And how many of--
I mean, I assume
majority of you guys
support not more than five
languages in your app?
Now, the support library is
translated to 82 languages,
localized.
In all of our apps,
those 82 languages,
all the strings are there, all
the things that you're using.
You might use an Android.ok
or from a support
library something
like that resource.
All the 82 versions are
added into your app now.
By adding this one line,
res.config with the languages
that you support,
what you basically do
is tell the system that, hey,
my app supports these languages.
Anything else of
these languages,
I'm not really
interested in keeping
in my app, which
means, in this case,
only two languages
will be actually added,
English and French,
and everything else
will be removed.
In a app that I had, I
tried this the first time
when I came pass this idea,
it was an app of nine MB.
Most of things that talked
about has being done.
Just by adding this one line,
I saved 600 Kb in my app,
right off, roughly 600 Kb.
That's a low hanging
fruit, one line of code.
Has no impact on any
of your code base.
So this is something
that you might
want to go ahead and do
tonight if you're not done this
because this will not only
happen in the support library,
this will happen.
This past transgressions
will actually
happen in every library that you
add, which have localization.
You add a third-party library,
which has localization,
you will, again,
face the same thing.
So by providing this
in your default config,
you will specify
the build system
that, hey, I only need
translations for these two
languages.
The rest of them I
have a resource config.
I can forget about it.
So this is something definitely
that you should try and do
today, if not done already.
Downloadable files, I did
talk about it earlier today.
But this is, again,
an area where
you can save a lot of time.
Like I said, assets, most people
have created custom experiences
with fonts like the look
and feel of the app changes
when your font changes.
So a lot of people
have the custom forms
that they use in order to create
a very differentiated look
and feel.
But at the same time,
these form files
have to be added into your
assets and then you use it.
Every user downloads
all of this.
A lot of times earlier I've seen
when Roboto was just launched.
A lot of people added
Roboto to their application.
Even though that's a default on
the device, they added Roboto,
and everywhere they
have added [INAUDIBLE]..
That's something about if you
had five or six font, that's
going to take an MB or two,
depending on the font file,
give or take, MB or two.
If you're using
downloadable file,
you're not adding any
of that information.
You're telling your
program to say, go talk
to the font provider,
get me this phone
because I need to
use it at this place.
These are the places
I'll need to use.
So your app will actually
go contact the control font
provider.
Font provider will go
connect to the font contract
and get the file, used it.
Sorry.
The font provider will go
connect to the front cache
or to the other provider,
external provider,
get the font, put
it in the cache,
and the next time
another app asks it,
your user is not
downloading it again.
Assume this is device that
does not have Roboto in there.
You asked for Roboto,
one app asks for Roboto
and it download it.
The next time your
app came down,
the user is actually
running your app.
Your app requests Roboto.
It doesn't go to the font
provider and download it again.
It just goes to a cache,
gets it immediately.
Your APK size is the same,
user's download costs reduced,
the memory footprint on
the devices is reduced.
This is a total
win-win situation.
This is in support
libraries today, version 26.
You should use it if
you are a patriot of 26.
You should go ahead and
update your code to use this.
Really, really useful thing.
And it has the entire
Google font catalog
to start with, with around
800 fonts right now.
Now, this is the last
slide that I have,
but this is, again,
the app AAPT2.
This basically has something
called version collapsing.
There are multiple versions
like when you have v7, v4,
v13, things like that.
There are versions in
which the behavior changes
or there are certain resources
which are declared differently.
And what happens, this
is no longer used,
but because of you are
supporting a range of versions,
this would be there
in your files.
Version collapsing will
actually bring that all to one,
remove all unnecessary things.
So this is something
you don't need to do.
Under the hood happens.
And there's a semantic launder.
There's a resource deduplication
algorithm running on it.
So this is something,
again, really useful
when you want to
reduce app size.
With that, I hope some of the
things you guys are already
doing and you've
learned a few things
like the respond config,
which you can actually
go back and apply today.
But this is always
a constant battle.
Reduction of app size is
always a constant battle,
and you always
have to assess what
you're giving in to do that
because this is a trade off.
You might have
computation increasing
because you're doing these
really low-level optimizations.
So you really always
measure against
what is actually
the good practice.
What is the trade off
that you're doing.
So be aware of both of this.
Thank you.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>