<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lighthouse, Headless Chrome, and Puppeteer (GDD India '17) | Coder Coacher - Coaching Coders</title><meta content="Lighthouse, Headless Chrome, and Puppeteer (GDD India '17) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Developers-India/">Google Developers India</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lighthouse, Headless Chrome, and Puppeteer (GDD India '17)</b></h2><h5 class="post__date">2017-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XEw_n_wsk1o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome everybody to modern tooling
testing and automation we're gonna talk
a little bit about lighthouse puppeteer
and headless Chrome's so we only have 30
minutes a lot to cover in that amount of
time so let's go ahead and get started
so my name is Eric bidelman I am an
engineer on the chrome team I work with
web developers all over the world and
help you guys build amazing web
experiences fun fact about me is I'm
actually from a state in the u.s. called
Michigan and I can literally point to my
hand because it looks like a hand and
tell people where I'm from which is
really convenient the other cool thing
about Michigan is that it has the most
number of lighthouses of any state in
the United States so it was only fitting
that I worked on a project called
lighthouse eventually and hi everyone my
name is venomoth asingle I'm a product
manager on the chrome web platform team
working on lighthouse and as a fun fact
about myself I actually really love
Bollywood dancing as a kid and this are
some embarrassing photos of me
performing at family functions and what
I've recently realized is Bollywood
dancing is actually pretty similar to my
day job as a product manager
specifically when I'm doing Bollywood
dancing I'm trying to tell a story
through physical movements about what
I'm feeling in the music and with
product management I'm telling a story
to my users about my products and so
today I'd like to tell you take you on a
little journey into the lighthouse
product itself more on the p.m. style
and less on the Bollywood dancing style
I'm sure that would be pretty great too
specifically I wanted to focus on with
lighthouse talked a little bit about the
problem that we're trying to solve deep
dive into the product itself and then
kind of take a step back and talk about
lighthouse in the broader context of web
development and then Eric will take over
and talk about headless chrome and
puppeteer so let's get started so as a
web developer you might have heard about
a lot of things that you're supposed to
do for example you might have heard not
to use methods like document dot write
that you're supposed to optimize your
images by compressing them to create
performant web experiences that you're
supposed to be on HTTP to deliver a
secure experience to your end users that
accessibility is really important and
you should have Aria labels for all
the elements on your page and that you
shouldn't use vendor blocking scripts
and so much more stuff to add to this
you might have heard about a thing
called progressive Web Apps throughout
this conference that helped you create
really great mobile web experiences that
feel like native app experiences but in
order to build a progressive web app
there's a lot of things you need to do
including serving your site over HTTP
creating responsive pages on mobile and
tablet etc etc so you probably feel like
this person really confused like what am
I supposed to be doing and all you
really want to be doing is spending time
pushing code and creating features for
your end users be more like the person
to the right I guess and that is a
problem that we completely understand on
lighthouse because we want to enable all
of you in the audience out there to
create really awesome mobile web
experiences so that's why we built
lighthouse which is basically a product
that helps you understand your website
against four different categories of
performance accessibility progressive
web apps and developer best practices
and running checks against them to
create a personalized report that helps
you understand what are the things that
you're doing well on your website and
what are the things that you could
perhaps do a little bit better so this
is a little bit hard to understand on
the abstract level so let's go into a
live demo so if you could switch to the
demo please awesome
so I'm going to run lighthouse right now
live in front of all of you and I'm
going to run it on possibly the best web
site you can imagine which is air horn
or comm for those of you who have never
seen this before it's pretty simple you
just click this button and it gives you
the sound of an air horn er so pretty
awesome so I'm going to now run
lighthouse through the chrome developer
tools but I will also talk about other
ways in which you can run lighthouse
later so I'm just going to open up the
chrome developer tools here and then I'm
gonna go into the audits panel and voila
I have lighthouse right there and so I'm
gonna click on perform an audit and I
can check whatever categories of audits
I'm interested in so I care about
everything so I'm just gonna run it
across everything
and so now what lighthouse is actually
doing is that it's emulating my website
on a mobile device specifically
X is 5x device and it's actually
throttling the network so it's it's
simulating a 3G connection and that's
why it kind of takes a little bit of
time but now you can see right here I
have my lighthouse report and things
look pretty good on my website so that's
pretty awesome
so I thought I was mentioning earlier
there's quite a few ways that you can
run lighthouse so the way that I just
showed you was through the chrome
developer tools but you can also run it
through the lighthouse Chrome extension
you can run it through the command line
with the lighthouse and PM module and
you can also run lighthouse on
webpagetest so now let's do a little bit
of deep dive into the lighthouse report
that I was showing you earlier and for
the purposes of this part of the talk I
will only be focusing on the performance
and PWA section so let's get started
with the PWA section so this was a slide
earlier talking to you about what are
all the different requirements that you
need to implement in order to build a
progressive web app and we have a handy
dandy checklist that you can look at in
order to understand what are the things
you need to do to build a pw8 and what
lighthouse does is that it takes this
baseline checklist and it basically
automates the entire process so you
don't have to think about am I actually
implementing a serviceworker correctly
lighthouse can tell and do that for you
and it tells you a score at the top that
helps you to understand at a high level
how far are you in the journey in
building your own progressive web app
and for lighthouse definition we
consider a score of a 100 meaning that
you've built a progressive web app so
now talking about the performance
section of the report before we deep
dive into the report itself I want to
explain to you how we think about the
page low and so on the Croteam you might
have heard us talk about a thing called
progressive web metrics and the idea
behind that is the way that you
understand a page load is through how an
end user perceives the page loading and
there's a couple of key moments here in
that user journey the first one being
first content will paint so what are the
first pixels of content appearing on the
screen so this could be something like a
text an image or an SVG the next thing
is first meaningful paint so first
meaningful paint is when - the first
meaningful content on my page start
appearing so this could be like a hero
image for example and then finally at
the very
you have time to interactive so what is
my page become first interactive to
users as well as continuously
interactive so that users can click on
anything and they're able to see the
page be responsive and so what
lighthouse does is it basically takes
all these metrics shows them to you for
your webpage helps you understand at a
high level how good these metrics are
and then also tells you what are ways
that you can improve these metrics with
the performance section of a report so
this looks kind of daunting so I'll just
go through it step by step with you so
at the very top you have a high level
score in this case it's 63 that tells
you this is overall how the performance
of your website is the next section is
what we call metrics so basically at the
top you'll see a bunch of different
images what we call a film strip which
is basically how did your page look at
different time intervals of the web of
your website loading and then it also
gives you values for the metrics that I
was talking about like first meaningful
paint and time to interactive the key
thing to know here is that this section
basically determines your lighthouse
score meaning that metrics like first
meaningful paint first interactive and
consistently interactive are worth five
times as much in terms of determining
your final lighthouse form and so when
you're thinking about what metrics
should I be paying attention to and how
do I think about improving my lighthouse
score those are the top three scores top
three metrics that you should be looking
at so the next section of the report is
the opportunity section with the idea
being how are ways that you can improve
your website so in this case you can see
that optimizing your images is probably
your best bet in terms of improving the
performance of your website and then
finally we have Diagnostics so if you're
interested in deep diving into
performance further you can look into
things like critical request rates so I
would like to give to all of you a sneak
peek into what's coming up next for
lighthouse so I'm excited to announce
that in the next few releases of
lighthouse we'll be adding a whole new
section of the report itself focus on
search engine optimizations specifically
about how you can make your website more
friendly to search engine crawlers and
indexers
but it's coming soon so it's not out yet
so now I want to take a step back and
talk about lighthouse and the broader
context of web development specifically
I want to start off by talking about our
adoption metrics so lighthouse has
pretty good adoption in the sense of we
have over a hundred thousand users using
the lighthouse extension we have over
two hundred and fifteen thousand users
using the lighthouse and p.m. module and
in terms of dev tools while I can't
share exact stats what I can't say is
that it's about half as popular as a
timeline panel we've also seen people
building services on top of lighthouse
specifically services like calibre and
trio I also want to talk about our open
source community because we are an open
source project and we definitely
wouldn't be here without open source
contributions we receive from developers
like you even something as simple as
changing the readme file really helps
our project go a long way and we have
over a hundred plus contributors from
all over the world you can see them in
blue on this map here from countries
like India and Brazil and Poland and
even the United States next-door
neighbor Canada so if you're interested
in being part of this contributor
community and we'd love to have you join
check us out on github or the repo is
called lighthouse and then finally I
want to thank you I want to thank
everyone for being here on behalf of the
team we really appreciate it I really
appreciate you coming out and listening
to me talk about lighthouse and if
you're interested in trying a lighthouse
we actually have a booth at the sandbox
so you can come talk to Eric and I about
lighthouse after the talk if you want to
learn more and so now that you have a
website and you have a nice little way
to audit it via lighthouse you might
want to think about you know what is the
best way that I can detect regulation
detect regular regressions and automate
some testing to make sure that the
regressions don't actually end up going
to my end-users and this is where Eric
will tell you all about puppeteer and
headless Frome to see how you can make
that happen so thanks very much thank
you thank you so let's get started we
talked a little bit about manual testing
using lighthouse which is in the dev
tools now but maybe you want to do some
testing and automation using headless
Chrome or puppeteer and we're going to
talk about both these right now all
right so what is headless browsing how
many people have heard of headless
Chrome
let's so normally when you click the
icon you know on your on your desktop
right you launch Chrome there's this
nice window there's a page you can
interact with there's a URL bar
there's the dev tools that you can open
and poke around in but we've have this
crowd then there's actually none of that
so there's no UI whatsoever right
there's no URL bar there's no address
bar to interact with quite literally
there's no chrome to Chrome and so using
headless chrome you actually decide the
future of what's going on you control it
using the scripts that you write to
launch Chrome in headless mode you
simply provide one flag on the command
line it's - - headless and this will
launch Chrome in a headless mode and
you're not going to see a window so what
do you actually do with it well the
important thing is to add this other
flag it's called the remote debugging
port flag this is where the magic
happens so what this does is it it a
launch headless Chrome but it also
enables the remote debugging protocol
the same API and protocol used by the
dev tools itself when you're inspecting
node or in vs code when you're
inspecting your applications same stuff
we can tap into using this command line
flag and so by doing this we can then
write an application and nodejs or
what-have-you
to actually control and automate
headless Chrome so if you want to know
more about headless chrome I'm not gonna
really talk about it too much today but
there's a lot of cool stuff you can do
from the command line you can launch
headless Chrome you can take screenshots
you can generate PDFs check out this
article on developers.google.com there's
some interesting things you can do but
the more interesting things are actually
when you write programs that control
headless chrome so one way you can use
headless chrome programmatically is to
use this amazing little module it's
called chrome launcher a lighthouse team
put this together because actually
launching headless chrome and dealing
with chrome on different platforms and
different systems finding chrome
launching the right version is actually
kind of complex so we just basically
abstracted that create a little NPM
module for you guys to use it's really
easy to launch chrome just with this
module you can pass it that remote to
bugging port flag in this case I'm also
saying launch and headless mode and boom
in like one line of code you can
interact with Chrome in your node.js
program now this is kind of where
puppeteer comes in the mix
so puppeteer is in library for working
with headless Crone there's a lot of
automation and testing for Emerick
libraries out there you might have heard
of phantom and selenium we're not trying
to invent the wheel and make a new one
we're just trying to make sort of an
easy-to-use out-of-the-box experience
for headless Crump you think it's really
important for testing an automation we
want that to be easy especially in the
case of chrome so the chrome team said
hey let's build a library let's build a
node.js library we'll make it a modern
library they'll take advantage of some
of these newer es6 features we're using
promises all over the place we'll see
that in the code examples I show today
the other reason for that is that it's
just the way the architecture of chrome
works so we're writing a note program
we're sending asynchronous messages to
this remote API which in turn automates
and does things with chrome that's all
that message passing is asynchronous so
promises actually lend themselves very
nicely to that and of course a sink in a
weight that cleans promises up quite a
bit makes our code a lot cleaner but
don't worry you can use nodes 6 if you
want you don't have to transpile you can
use puppeteer and older versions of node
no problem there now the other thing we
want to do is we want to bundle Chrome
with the library so one of the hard
things to do is actually install Chrome
on different platforms make sure all the
dependencies are installed so when you
get puppeteer from NPM we actually just
download a local version of chromium
which is the open source version of
Chrome so you don't have to worry about
configuration or anything like that it
just works you focus on your code you
don't have to worry about actually
launching Chrome we want to be a
reference implementation for the dev
tools protocol now the protocol itself
there's so much you can do it's a really
complex very awesome API surface but we
wanted to actually create the highest
level API possible really wrap the API
the protocol API and the most useful
things we could and so we have API calls
for probably the most common use cases
that you would use so where does
puppeteer fit in our overall testing
narrative well I present to you the
Pyramid of puppeteer so at the bottom
right we have the browser we have
headless chrome headless Chrome and so I
just want to remind you at the bottom of
this layer right we have the browser
it's all your new es6 features your
JavaScript features your new web
platform features so the fact that we
can use an
a testing library to test things like
service worker and push notifications
and some of these newer web platform
features is actually really exciting we
haven't had that in the past to some of
these other frameworks on top of that
you have the chrome developer remote API
again very very complex big API but
that's the thing that's going to
interact with chrome itself and we're
not going to interact with that directly
that's where puppeteer comes in so again
this small shim that sits on top of this
lower level stuff and at the very top is
where your scripts come in so these are
the node scripts that you're gonna write
that interact with the puppeteer API and
then control chrome that's how
everything fits together so just to show
you the difference between using the dev
tools protocol by itself and using
puppeteer two examples the same thing
we'll basically navigate to a page and
then print the HTML content of that page
and you don't really have to understand
the details of the code on the Left just
know that it's it's much more robust
right there's more stuff that's going on
I need to libraries to do things like
launch chrome and control the protocol I
have to do a lot of setup a lot of
cleanup I have to enable things and
disable things in the right example with
puppeteer it's really clear what's going
on right you launch a browser you create
a new page you navigate to example.com
and then you print the content of that
page so puppeteer makes a lot of these
things very easy to do in just a few
lines of code so what can you do well
the first thing a lot of people do is
take screenshots of their page you can
do that with puppeteers api's so of
course the first thing you need to do go
grab puppets you're off NPM you can use
yarn or NPM just install puppeteer
locally again it's going to bring down a
version of Chrome and you can require it
inside of your node application so first
things first if you want to write a
script that uses puppeteer the first
thing you probably want to do is launch
Chrome puppeteer has a launch method and
by default without it what that is going
to do is launch a headless version of
Chrome and again everything is a promise
so this is going to resolve and give us
a browser instance to then interact with
and control so calling launch a give us
a browser instance the next thing we do
is want to create a page using async and
a way just to clean up the promises a
little bit so we'll use browser that new
page to create that
we'll use page go to to navigate to
example.com and what this is gonna do is
actually wait for the load event to fire
so make sure our page is loaded up and
ready to go then finally we're gonna
take a screenshot of the page itself so
pip up here has an API for that page
that screenshot and it's kind of nice
it's got this path property that you can
set you don't have to read a stream and
read a buffer or anything like that you
just give it the the file name that you
want to create and boom you have your
screenshot on disk so last but not least
you'll probably want to close the
browser we're done with it we don't need
to do any more scripting so we'll close
out Chrome and all in all that clocks in
it like five lines of code to take a
screenshot of your web app pretty cool
so one of the other cool things can you
do with puppeteer screenshots are one a
lot of people like to create PDFs of
their sites I don't know why they like
completely print out their page their
entire site and give that to to someone
to look at well headless Chrome has the
ability to print to PDF and you can do
that using puppeteers api's as well so
very similar to the screenshot API we
can navigate to google.com for instance
emulate a media device of screen media
instead of print media so we don't get
the print stylesheet and then call page
that PDF and save the PDF to disk pretty
simple
another thing we can do is emulate
device maybe you want to test the
response of your device or of your
application this example here uses some
of the built-in predefined device
descriptors we have you don't have to
worry about knowing the viewport
settings of different devices or the
display pixels ratios or anything like
that just require puppeteered device
descriptors in this example here I'm
just emulating an iPhone 6 device and
then navigating to google.com and so
this is the end result here obviously
it's just the mobile version of Google
comm so I'm super easy to emulate a
device in puppeteer and again dev tools
can do all this but puppeteer is the
programmatic way to do a lot of these
things one of the neater things you can
actually do is inject code into the page
right maybe you want to test some
functionality of your page or make sure
some JavaScript is operating like you
expect it to so what we're gonna do here
is we're going to navigate to just my
Twitter feed we're gonna find the first
tweet on the page we're gonna
programmatically click that element
which will bring up this overlay that's
what Twitter does when you click the
gentleman and then we're gonna take a
screenshot of that Dom element so you
can take a screenshot of a page a full
page or a Dom element the choice is
yours so we're gonna run some code in
the page the first thing of course we're
gonna do is call launch you're going to
launch a new version instance of
headless Chrome we're gonna create a new
page to work with we're gonna navigate
to my Twitter stream this twitter.com
slash
a vital next one will do will actually
use page dot dollar sign eval and what
this does it's kind of like jQuery you
give it a CSS selector which will find
that node on the page and the cool thing
that happens here is to cut the callback
for this it's not run inside of node
it's actually run inside of the page so
this gets injected inside the browser
very similar to typing this in the
console and so we'll click that using
anchor click which will open that
overlay the next function call is
waiting for waiting for that select to
be available so puppeteer has a method
that says hey make sure this elements
visible before I move on and so when
this promise resolves were guaranteed to
have this Twitter overlay pop-up and
then finally we'll take a screenshot of
that of that Dom element so we'll just
grab that handle to that element and
they take a screenshot so all in all it
looks like something like this will open
the browser will navigate to Twitter
I'll find the first tweet using
puppeteer you can see they're all very
fast it finds that element and
eventually what you get is the final
product which is a screenshot so this is
my new puppy - everybody say hi to Chuy
super cute he's a wookie like Star Wars
but so we can take screenshots of full
pages you take screenshots of Dom
elements and you can take screenshots of
any portions of the page you want so
what you just saw is actually really
really powerful right in a couple lines
of code we just wrote some puppeteer API
code and you can wrap that in your
favorite testing framework and all of a
sudden you have an instant smoke test
right insert your favorite testing
harness no matter what you want to use
and you've got an instant integration
smoke test we're just testing the
functionality of Twitter in this case
very very cool and easy to do using
puppeteer now another thing you can do
that's very very powerful is intercept
requests before the browser ever issues
those requests and we can do that using
the set request interception method
in this case what I'm doing is I'm
waiting for the request event every time
the browser tries to make a network
request will intercept that request and
decide what to do with it so this
example here is going to navigate to
youtube.com and it's the resource type
if the request is for an image will
actually just abort that request will
cancel it the browser will never issue
that if it's not we'll just let that
pass through as normal so the end result
if you actually run this piece of code
you know in node exactly what you'd
expect so the images start to 404 well
this is really great for is you can test
things like does my muzzle and layout of
my site work if images don't load is my
is my accessibility okay is my layout
okay you can imagine doing this for
other resources like CSS maybe you want
to intercept one stylesheet and serve up
another you can totally do that using
network request interception so to kind
of decide what to do based on the
request type a really common thing to do
in automation is to do automation form
submission hey does my form actually
work so puppeteer has high-level api's
for this for typing in form inputs and
clicking things on the page the classic
example here is just go to google.com
right so we'll never get to google.com
will input the text puppeteer into that
search box just by selecting it using
its CSS selector and we'll call page
click and click the google search button
using page click next we use the same
weight force selector method each of the
google.com search results is an anchor
tag wrapped in an h3 so we'll just wait
for those results to be ready using that
same method and then finally we'll just
use double dollar sign eval to iterate
through all of those those titles that
come up and just print the titles to the
console so if you run this in node just
in the console you get exactly what
you'd expect just the list of search
results for the word puppeteer so we've
showed two things we've showed
interaction with the keyboard form
submission and actually just scraping
content from a website using puppeteers
api's so something new to the dev tools
is it actually has this new panel called
performance monitor which has a slew of
awesome performance if it makes you
inside of it a lot of that stuff is
actually being surfaced in lighthouse
now and you can programmatically get
access to that as well inside a
puppeteer it's a simple API call a
puppeteer
Paige not metrics will give you this
information it corresponds to the panel
itself so all the information like how
long do your scripts take how long does
it take to recalc style Zinn this app
and more and more stuff is being add to
this all the time by the dev tools team
so this is going to get much more rich
as we go on this is really great if you
want to track performance over time if
your application may be in a CI
environment really useful stuff and
there's a ton of stuff you can do with
puppeteer I can't cover everything today
I just want to point out a couple more
things if you use up serviceworker a PWA
you want to test your site to work
offline you can test you can turn
actually a JavaScript off or you can
test with the network connection off to
see if your site does indeed work
offline using puppets here we can
intercept network or end the console
request that any time the browser that
site logs something to the console we
can intercept that and print that or do
something with that information and if
we don't have a device descriptor for
you you can actually emulate any type of
device you want using page set viewport
set of device pixel or any dimensions
you want so before I leave you a couple
more pro tips that i've actually run to
talk to a lot of developers getting
started a puppeteer just want to mention
a few pro tips for debugging i think
they're really useful so let's talk
about this puppet to your launch method
and again it's just launches headless
chrome and you get a browser instance to
interact with a couple of interesting
things right if you're writing a script
and you can't see what's going on it's
not so useful maybe you're debugging the
script you have no idea what's doing
just throw on headless Falls you can
actually just launch Chrome you can see
the window you can see puppeteer
automate the script the page and
navigate and click around it's actually
pretty cool to watch this but that's
actually really useful just for
debugging too so I highly recommend
throwing the head full mode of Chrome on
you can also auto open the dev tools if
you want using this flag dev tools
equals true that will launch a head full
version of Chrome but also just open the
dev tools at the same time kind of
useful you can see dev tools poke around
as puppeteer is kind of automating your
page all right
debugging options another couple of
interesting things you can do is you can
set slo-mo and slow low is a flag that
allows you to slow down all operations
that puppeteer does by a certain number
of milliseconds so let's say somebody's
typing in a website right they don't
type as fast as a computer so you can
actually slow that operation down using
this this option slo-mo which will
basically
a real user which is useful to see what
do you really user would do on your site
it also slows things down like
navigation so you can see what's
happening as puppeteer is going through
dump io is useful if you want to see
information from Chrome itself so if
your page is doing something weird like
the browser is actually crashing turning
this flag on is actually pretty useful
to see that information so last but not
least if you don't want to actually
install anything today you can totally
just try out puppeteer I hacked together
this little site over the weekend
it's called tribe puppeteer appspot.com
you can go there you just play around
with puppeteers API run all of our demos
tweak code see the results at the top
you can see the console information and
also any PDFs or screenshots you
generate really easy just get started
and kind of tinker around but no
guarantees on off time because it is
just a hack project now one thing you
can kind of do that's cool with this is
we can use puppeteer locally on our
machine to launch that site and then
which runs headless chrome and puppeteer
in the cloud so we're using puppeteer to
control puppeteer which is kind of like
this crazy inception moment so just to
show that possible actually built that
little script what we're gonna do here
is we're gonna run puppeteer on my
machine we're gonna launch that site try
puppeteer inject some code so you can
see what I've done is injected code that
opens that page itself and then takes a
screenshot of the final product so
hopefully we'll see a picture within a
picture here and note my mouse at the
top is not going to move so we're
actually automating this using node
we're not moving and clicking around the
page so puppetry will click that Run
button we'll get a final product and
eventually what happens is you get a
screenshot within a screenshot which is
kind of cool so before I leave you just
a couple of things to mention the first
thing is make sure if you're using one
of these testing frameworks out there
phantom or slumming you know make sure
they're using the headless version of
the browser a lot of browsers now have a
head a proper headless mode and some of
these guys and framix have been around
for a while they might not be using this
mode it'll save you memory it'll save
you time it's a lot faster to test in
headless mode a lot of people use
libraries like James done which is a
great awesome library for testing dom
and testing code that uses dumb but the
fact that we have a headless browser and
we can actually test in a real dumb
implementation using a real browser
maybe you don't need a library like jaws
dom anymore so consider that and also
you know testing other browsers not just
chrome obviously
firefox has a headless mode that they
launched in firefox 56 and other
browsers also are implementing headless
mode so test across all browsers it's
not just chrome it's very important so
with that we throw a lot of stuff your
way here all are all the open source
project and resources that we talked
about today lighthouse which we covered
puppeteer the dev tools protocol if you
want to really know what the dev tools
can do and that API can do really really
awesome stuff the article and headless
Chrome and the chrome launcher module if
you just want to work with headless
chrome check that out so I think with
that we're all done and we really
appreciate you guys sticking around we
know it's late in the day thank you
everyone on the livestream for attending
my name is Eric bidelman I'm venom at
the single and thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>