<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building an Android Instant App (GDD India '17) | Coder Coacher - Coaching Coders</title><meta content="Building an Android Instant App (GDD India '17) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Developers-India/">Google Developers India</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building an Android Instant App (GDD India '17)</b></h2><h5 class="post__date">2017-12-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aqzHJa_QV-k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right welcome everybody to the
Android instant apps session my name is
Lila and I'm an Android developer
advocate this session will cover
building an instant app including core
concepts the modular ization process apk
sizing and important related api's now
instead apps were announced at Google
i/o 2016 but they became generally
available at Google i/o 2017 and now any
of you could build an instant app but
first let's talk a little bit about what
Instant apps are instant apps are native
Android apps that require no
installation but instead of me waving my
hands around and using a lot of words
let's just take a look at what that
looks like okay so here I am doing a
search for the show on Red Bull TV
called the crevasse I click on a link
for the incident app and I'm immediately
taken into a immersive native app
experience this works from any URL that
you own whether it's from a Google
search as this example or from a text
message from a friend
now instead apps work on lollipop at
hire so in fact if you have a phone
running L or higher you could take it
out search for New York Times crossword
and go ahead and click on that card that
has the instant apik you can see the
experience yourself instant apps are
supported on over 900 million devices in
addition many of our early access
partners created insted apps and they've
already seen increases in session to
rate duration and engagement from there
instead apps okay so I'm going to go
ahead and take a dive into how you would
actually set up your app to be ready for
instant apps now the whole point of
instant apps is to decrease friction for
users we want it to be so that you click
on the link and you get into this native
app experience so you don't want to be
showing them some sort of long
permissions dialog when they do this
instant apps require runtime permissions
to show contextually relevant
permissions during runtime
in addition for instant apps you're
obviously going to be mapping URLs to
different activities in your apps and
this is exactly what applix do so we use
applique functionality to enable this
audience naps so you need to support
applix notably applix also allow you to
get rid of that disambiguation dialog
that kills sometimes see when clicking
got a URL so applix require basically
two things to get working first you need
to make intent filters in your manifest
file that associate those activities
with the URLs second you're going to
need to generate a digital asset link
Jason's file that you upload to verify
that you actually own at your server
now there's a applix assistance tool in
the Android studio that will get you
started with both of these it both
generates the XML intent filters that
you need and it will also generate for
you that digital asset like JSON file
now both applix and runtime permissions
are for API level 23 and above but as I
said before instead apps work on API
level 21 at higher phones so to achieve
this there's actually a runtime that's
managing your instead apps and the
incident rum tied back ports both of
these functionalities 4-l and higher
apps so if you actually want to see that
runtime running on your phone it's
called the Google Play services for
instant amp runtime and you can see it
writing over your phone as shown here so
runtime permission permissions and app
links are the two major technologies
that your apps will need to be able to
support before you can start building
instant apps but in addition there's
also a smaller checklist checklist of
sort of smaller preparations that you
need to make so for example of some of
these things on the checklist you need
it snaps have a sub set of available
permissions and they also require web
requests to be made over HTTP there's a
couple of other restrictions and
requirements that you should look over
I'm not going to list those out now but
we have awesome instant app
documentation so you could go to the
site and kind of get that full checklist
for yourself okay so now let's actually
so we've made our app sort of ready to
become a dead stop so now I want to talk
about how instant apps are actually
structured so one of the central goals
when making it it's
it's like you want to make sure when you
click on that leg that you're getting to
your app fast and that it's not dragging
out a really long time now you're
probably used to having a single module
for your app probably called app which
contains all of your code and resources
but within your code you probably have
separate features so for this example
I'm gonna be taking you through a
fictional travel app called Ben Jarrah
and bechara uses your location to give
you a list of nearby attractions so for
example in this app you could view
specific details about an attraction get
a map to go to where that attraction is
you can also write reviews if you happen
to be a fan of that attraction so each
of these three different activity flows
can be thought of as a separate feature
features are discreet experiences where
the user accomplishes some sort of
meaningful task France taps a feature
must be associated with an activity or
activities banjaara has essentially
three features okay the first one is
browsing a list of nearby attractions
the second is posting a review about an
attraction and the third is getting that
detailed information about one
attraction so a user could use any one
of these features independently and
they'd still be able to do something
interesting and useful for them okay so
features probably don't have completely
separated code most likely they will
share some code so for example you
probably want your activities to have
the same colors and logos and not to be
switching those things up so they'll
probably share common styles at graphics
similarly you'll probably have some
shared utility classes such as a class
to set up dependency injection and
finally they're probably some common
libraries like the support library or
maybe architecture components that
you're going to be using at all of your
features so for all of this shared code
I'm gonna be calling this code base and
that's gonna become very clear why I'm
doing that soon okay so here it is all
mapped out we have our single module but
remember inside our module we have these
sort of different sections
of code for the different features of
the base feature so what are the core
principles behind incident apps is this
if your users only need to use one
feature why are you wasting their time
and their data downloading all of the
features another way to think about
instant apps is the user clicks on a
link and they download only the compiled
code and resources for the single
feature that they need at that moment so
if your friend wants to send you the
attract the details of an attraction you
could click on a link and via instant
apps you would only download the been
jarred details feature and you wouldn't
have to download the feature where
you're searching for attractions or the
feature for where you're writing a
review and you can do all of this
without having to fork your apps code so
you're not going to create an extra
little mini app on the side one of the
other core principles is that instead
ABB's billed for the same codebase so
you're gonna use your same code base for
building both your instead app Edgar
install will app now this of course
makes maintenance easier because you
don't need to maintain a completely
separate codebase but it also ensures
that your instant app feels the same as
your installable app which is very
important because it essentially is the
same app so what you'll do instead of
forking your app is to take your single
app module and you're going to separate
out your code into different modules one
for each feature and you will very
cleverly call these modules feature
modules okay and then you're also gonna
take that base code that I talked about
before and you'll separate out it out
into a nother module called the base
feature module now you're gonna make two
additional modules on top of that and
they're both for building the app so
what are those modules is going to be
called your installable app module and
it's meant for building the installable
app and the other module will be a
instant app module and it's meant for
building the instant app so essentially
we're gonna take our one app module
world and now we're gonna break it up
into six different modules okay so now
to properly configure all of this and
build your instead app you're gonna need
to learn about some new Gradle plugin
types so here are modules again
now each of these modules has its own
Gradle file and each of these modules
will be using a slightly different
Gradle plugin the installable app uses
the application plugin and the instant
app module uses the incident at plugin
now the application plug-in should be
pretty familiar to you it's that
standard plug-in that you're using to
build your apk this the purpose of this
module is to create the apk for your
installable app its Gradle file will
also identify the app ID
it can include code that is specific to
your install but for example you might
have some sort of offline mode feature
that doesn't make sense in the instant
app context but you could also have it
be empty and have its purpose just be
for building your installable app and
because it's build against all blob it
also needs it needs dependencies on all
of the other feature modules okay so in
comparison the new Institute app plugin
creates a instant app and basically it
contains nothing it doesn't contain any
code it doesn't canady any resources and
it has a blank manifest but it does
depend on any of the features that you
want to include as part of that instant
app experience the future modules use a
different plug-in called the feature
plugin which is new okay so the future
plug-in is what makes instant apps
possible and it's pretty cool the future
plug-in will compile compile differently
based on what's build again so if you're
building a feature from your installable
app it'll compile as if it is an android
library but if instead you compile from
a instant app it's going to compile as
if it's a separate sort of midi APK and
of course your feature about module will
contain code specific to that feature
okay so the basic feature module is a
little bit different than the other
feature modules it uses the same feature
plug-in but there's a flag inside of it
which identifies that it is a base
feature module now importantly you can
only have exactly one base feature
module per insta-death and again it's
not really a feature it
it's this shared it's this location
where you have shared resources coded
libraries all of your other features
have to depend on it because it has all
those shared code resources and
libraries that they want and importantly
it propagates the app ID out back out to
the incident app apks so in practice
what's actually going on what we both
build the instant installed app and then
we put it up on the Play Store so let's
go ahead and look at happens when we
make an installable app module when you
build an installable app this creates an
APK similar to the apk that you're used
to well it's exactly the same as the apk
that you're used to and you go ahead and
get just upload that up to Google Play
and this is just completely normal all
the features are included as libraries
because again the future plug-in decided
to do that
and they're included with the within the
overall installable app ok so now the
user goes to the Google Play Store and
they download your app and they get that
exact same apk on their device with all
of the features that you've put in it ok
so let's look at what the internet
module does which is a little bit
different ok so now this looks similar
but you might notice that there's a
couple of extra file extensions that
snuck in there so the instant module is
doing is it's not making a single apk
instead it's creating these separate
MIDI apks for each of your future
modules and then it zips all those up
into a single zip file this is if file
is what you upload to Google Play then
the behavior on the user's device is
this when they click on an instant app
link for the first time two things are
downloaded first is the feature your apk
that they're interested in using and
second is that base feature apk which is
going to come along with all of your
different features
so for Fred tells you to check out a
nearby attraction and sends you a link
you will only download the detail
features apk and the base feature AP
came and then let's say later that you
want to write a review about that
attraction so you go to google search
and you click on the review like
functionality so you already have the
base feet feature apk so that the only
thing that's downloaded at that point is
the review feature AP came so as you can
see your user is downloading only
exactly what they need and that's
because you are the head of your module
or as your app ok so now I'm gonna take
a deeper dive into the code to create a
single a simple single feature instead
app so here's our end goal which is a
little bit complicated and here's where
we're starting with a single module that
has all of this different code inside of
it so much easier intermediate goal is
to start by just building those two
additional modules that make your app
and that you could have all of your code
in a single feature module now this
isn't doing that cool thing where it
selectively downloads particular
features yet but it does allow you to
get those to build processes working and
then resolve any issues like
implementing the correct permission
structure okay so I'm gonna black box
all of this and here's the same diagram
I'm just kind of hiding all of that in
turtle code and the feature module there
okay
so again all of these modules have
Gradle files and the Gradle files are
how you set up the configuration and get
everything to build properly so let's go
ahead and take a peek into the
installable apps Gradle file ok so we
use the application plugin it'll contain
the application ID as I mentioned before
and it's gonna depend on that one to app
feature module because it needs that to
make the apk ok
so nothing too surprising there let's go
ahead to take a look at what's going on
in our instant app module ok so this is
basically the same as the installable
app but instead we're using that instant
app plugin and you'll notice that there
is no app ID but we're still getting
that same dependency to the feature
because we want that feature to be part
of the Internet
ok so then finally let's look at what's
going on in our apps build up Gradle
file this is the one feature that we're
building right now ok so this is going
to use that new feature plugin and it
has a special application dependency on
the installable app and the reason for
this is so that it is able to go and get
the app ID from the installable app and
that's pretty much why that's there
you'll also notice that we have this
base feature
figuration set to true remember how I
said that all instant apps need exactly
one base feature module well in this
simple version of the app we only have
one feature and therefore it follows
that this must be the base feature okay
so with that you have your first instant
app running and again I'm gonna call
this a single feature instead app
because it only has one feature and so
if I did this for big jar I could see
been jar writing as a dead stop which is
pretty cool
but there's another reason to take this
intermediate step which I mentioned
before which is that it can help you
flag libraries or permissions that might
not be compatible with instant apps
before you go through all the process of
modular eyes in your code but the real
power does come in from that modular is
a modular ization process and splitting
up your code into separate feature
modules so here's our end goal again and
here's where we are right now after we
built those additional Gradle modules so
at this point you're going to want to
start modular izing so where should you
start first well my suggestion is that
you first identify what should be in
that base that shared base feature
module and you separate it out the base
module will again contain all of the
classes resources and libraries that the
other features the list review at detail
rely on and once you've done this you
can start extracting other features one
at a time and sort of testing how it's
going as you go now note that you don't
need to have all of your features be
part of the instant app so you could
decide that you just want to extract the
details feature and only include that as
the instant app and the only difference
would be that you would require and
install as soon as they wanted to use
the review feature or the list feature
but if you do keep extracting features
you'll eventually get to this point so I
want to talk about quickly a tool at
Android studio to help you with this
process and it's called the refactor
modular ice tool to use this tool
basically what you do is you'll go ahead
and you'll select the different classes
and resources that you want to move into
a different module and then you'll right
click those and you'll go to refactor
motorize this will move the those
classes and files over to a different
module but it's also going to tell you
the dependencies that those classes have
so it'll tell you other
dependencies on different classes and
other dependencies of different
resources and it will give you the
ability to selectively decide what you
might want to also move over with it
okay so now let's take a quick look at
the griddle files for this more
complicated app so I'm gonna go look at
just the base Gradle file there okay so
here's our base feature Gradle file it
has the feature to append the same it
still has the base feature set to true
okay now notice that we have that
application project dependency on the
install blopp module and that's again to
get the app ID we also then have
additional feature project dependencies
on each of the different feature modules
and the point of that is simply to you
have that app ID and now the base
feature is responsible for propagating
that app ID to each of those different
feature projects and this ensures that
your entire app your instant app anger
install block have the same application
ID which is pretty important when you
upload to play okay so let's take a look
at what one of the more normal feature
module greater file looks like
so notice that this does not contain
that base feature configuration because
it's not a base feature feature modules
will also always depend on the base
feature module but they won't have any
other dependencies on any of the other
feature modules you also can have
specific library or implementations for
things that you need for only that
feature in there as well okay so at this
point you have both your installable and
your instant app modules which depend on
all of your feature modules and you have
your feature modules which all depend on
your base module and you have that one
single base module which has all the
shared code and resources that you need
for your future modules and finally that
base module is responsible for
propagating or forgetting the app ID
from the install block and propagating
it out to the rest of the app and that's
kind of what our full instant app
structure looks like okay so now it's my
pleasure to introduce any Rudel whadya
who's gonna who works on the
partnerships team and he's going to be
chatting about managing module size and
some additional instant app capabilities
thank you
alright let's talk about managing module
sizes now in development mode when your
device is connected to your development
machine there are no constraints on
module size it's great for first
refactoring efforts and making sure your
app is compatible with in synapse
sandbox okay
understanding module size restrictions
so to be instant' your module needs to
be leave the max size for a module is 4
MB and the module by Mario we mean a
download Mario will discuss that about
him so but nevertheless you should aim
for less you should aim for less to
improve delivery speed and to improve
user experience okay so the download we
said the total download bundle size
should be less than 4 megabyte that
really means that the feature that you
are trying to run or download which has
the activity being addressed by the URL
plus the base feature module should be
less than 4 megabytes the base describes
your app to the system and has all the
required common dependencies and it's
always downloaded unless it's already
cached so and this is where refactoring
into feature modules is really useful
now in this example we have a base
module with three megabytes in it now
this effectively leaves us one megabyte
for each feature module if P were to
have four features in our app we can
have seven megabytes of total app code
but there may be some cases where you
want a little more room in your feature
module for example a large SDK or a
third-party library a good example will
this be a payment module suppose you
have a big payments library but you then
want to do is you want to pull up the
payments library from the base module to
the feature module and create more room
to add functionality in this case when
we pull up suppose say for example a one
megabyte library onto a feature module
or basis now 2 megabytes and this gives
us 2 megabytes in each of
our future models but the total download
bundle style size still needs to be less
than four megabytes so with instant apps
we introduced a new publishing track
called the development track this
development track lets you build and
perform end-to-end testing of your
instant apps to rapidly to testing of
your incentives rapidly to match the
velocity of development this module size
restriction for the development track is
10 megabytes in addition to this we also
have the alpha beta and production
tracks where the module size limit is 4
megabytes so here is a blog post that
talks about the best practices for
managing your download side for instant
app modules
now let's discuss some tips and tricks
for managing your module size use
ProGuard to shrink your app forgot use
forgot to remove any unnecessary classes
from your decks files that are not being
used you should start with your
installable app first and then remove
useful pro-gard on your future modules
you see a peak analyze the tool to
investigate your resources code and
assets start optimizing with the biggest
chunk which is usually the resources in
your app use the unused resources link
check to see a list of resources that
are not being utilized in your app
investigate and remove as needed couple
more tips here use WebP II to optimize
your image assets and also starting
support library version 26 you can use
download fonts quick look into the epic
analyzer so the epic analyzer
understands your instant and build
artifacts and is able to show details
for the constituent feature apks in the
screenshot on your left you can see we
click on our in Sanibel artifact from
the bill folder this is a zip file this
will show us the feature apks inside and
then you can drill down into the future
apk into its specific code resources and
investigate this site
ok within synapse we also introduce
configuration apks configuration
implicates are very similar to multi
apks but with one key difference they do
not have any code they only carry a
configuration specific resources we
support three dimensions correctly
currently architecture density and
languages by using configuration AP case
you can bundle resources and libraries
specific to your device configuration in
smaller configure pickles and only
deliver the required apk to the device
this places your apps Dex code and
device agnostic resources in one apk and
then a set of device independent native
and resource in separate apk is the
Gradle configuration block for
configuration ap Caves is there you use
the conch generate pure splits equal to
true configuration and then you specify
the dimensions that you wanna generate
the configure PK's for on the right
you'll see a screen shot again from the
epic analyzer tool you see a bunch of
APK generated apart from the base and
detail feature epic a so a lot of
configuration apks they're carrying the
resources for that specific
configuration and we only calculate the
size of the largest configure PK plus
the base for each supported dimension
this can help you pack more code and
functionality in your 4 megabyte
download size limit ok now let's talk
about some instant app specific features
and api's so we stress that the instant
AB and the installable app should be the
same app however there may be some cases
where your installable app offers some
functionality that's not possible with
the insane app a good example of this
would be offline video and in those
cases you may want to prom the users
install the app we made it easy for
users to install your app when using
your instant app this can be done by
placing a button so let's check the code
for install but not by default our
button is hidden in the layout now on
the top you will see a dependency being
added
that's the instant app library that has
the installed API so now what we do in
the code is first we check for instant
app context so you want to unhide the
body only when you're running as an
instan app the API there is is insan'
app you check if you're running an
instant app and you unhide the install
button and then on click event you use
the install API instant apps not sure
installed prompt to present that dialog
that installs the app ok now we covered
how to install the how to install your
app but when doing that you want to make
sure the transition is seamless from the
user as they move from the instant to
installable app it is also important to
keep user context and migrate user
generated data over to the Installer the
instant app SDK provides cookie API
similar to a web cookie it's useful for
storing user context that you can
retrieve later so on android 8.0 and
above you can directly use framework
classes to invoke cookie api for cookie
api the specific class is package
manager on android 7 bar X and below we
use package manager compatible so let's
go over the flow for cookie API when
running as an instant app the first
thing you do is you check whether you
have cookie fits the allowance this is
done by calling get instant app cookie
maxsize on package manager once you do
that in your cookie is under the limits
you store the data in your internet so
you store the data using set insane app
to key at that point
the app is installed and now you're on
the installed state and in the installed
cells you retrieve the data back you
retrieve the cookie by calling get in
cenarf working and then you have user
context and restore where the you the
user was in your installer in the onion
instant app site also recently we added
the ability to let the user experience
your instant app from your Play Store
listing there is a China button that
launches your instant app and it's right
next to the install app removing any
friction for integration with China and
launcher will require apps to provide a
consistent landing screen this is the
default or home experience for your app
you do this by adding a default URL
attribute in the XML block there you see
a metadata tag that says default URL is
example.com slash index dot HTML this is
the home or default experience for your
app this activity should be URL
addressable and support browsable
category and in intent filters ok
finally instant abs are all about
removing friction so we recommend you
use smart lock for identity and Google
Play billing for any billing in your app
right some final thoughts
to summarize think of your app as a set
of features each feature that's user
complete a task start with a single
feature app to quickly prototype and
then start carving out features one at a
time use the API analyzer
pro-gard and other tools to minimize
your make your modules leaner provide a
consistent landing screen for your
instant apps and finally make the
transition seamless for users from
instant to install state using QT API
further information here on in synapse
that's the developer home page the dark
assertions in app link to our samples
and code labs a couple of useful
resources for that can help you
manage your module size and finally some
related talks on instant ABS and
modularization all right thank you
everyone we are very excited with the
experiences you will build thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>