<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Taking Advantage of Kotlin in Your Android App with Sean McQuillan (GDD India '17) | Coder Coacher - Coaching Coders</title><meta content="Taking Advantage of Kotlin in Your Android App with Sean McQuillan (GDD India '17) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Developers-India/">Google Developers India</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Taking Advantage of Kotlin in Your Android App with Sean McQuillan (GDD India '17)</b></h2><h5 class="post__date">2018-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5IOPd35j-ys" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's go ahead and get started hi I'm
Sean McMullen I'm a developer advocate
for Android and today I'm going to talk
to you about Colin yes so we're gonna be
doing an instructor-led training today
so what that means is you're gonna work
a code lab on Colin and we're gonna be
here to help so I'm gonna help you with
it I'm gonna walk through some
instruction and we have some TAS in the
audience they're gonna help you with any
problems that you have what I'm gonna do
today is we're gonna get started by
getting our downloads set up getting
Android studio compiling the project
then I'm gonna give you about a ten
minute lecture then we'll work part of
the code lab I'll talk again and we'll
work part of the code lab again so what
we're gonna do in this code lab is
migrate a java application to colin it's
an address book application that we've
put together that's written in java and
we're gonna use the Kotlin converter and
we're gonna take some write some
abstractions in Colin I'm gonna see how
it can help us reduce our boilerplate
code provide concise readable code
that's easy to maintain and we'll avoid
some common problems by building
abstractions to help us write better
codes so let's go ahead and jump right
in and go ahead and follow that link at
the top to download the code lab and get
started you'll want to work steps one
and two and get to the point where
you're compiling it in Android studio
that way we'll be able to all download
all of the dependencies
I saw most people got to the point where
they were downloading dependencies in
Android studio so looks like the Wi-Fi
break work so one of the really cool
features that comes with Colin is the
Kotlin - sorry the Java - Colin
convertor in Android studio to use it
your project has to have Kali configured
to start with and then when you bring
you select a Java file you can go to the
code menu and you see there's a Java
file - Kotlin a really cool feature
about this converter at one of my
favorite ones and it seems like magic
every time I use it is when you paste
Java code from the clipboard into a
common file it will automatically
convert the Java code into Kotlin as it
pastes so what I want to talk about now
is just an overview of all of the
Collins index basics that we're going to
use in our code lab today so we can take
a look at this function declaration
right here we're gonna walk through it
step by step so in Kotlin anytime you
want to define a function its defined
with the keyword fun so here we're
defining a function sum with two
parameters a and B the parameters have a
type a has a type of integer can be
hesitant integer and this is a common
syntax all throughout Kotlin to put the
types of a variable after the variable
declaration so this is different than
the Java programming language which
obviously is the other way similarly the
return type of the function is listed
after the arguments so its function sum
with two parameters that returns an
integer and then another really cool
feature about Colin is semicolons are
optional so just like JavaScript the
designers at Colin wanted us to argue
for years about whether we should put
semicolons in our code or not that
semicolons now you shouldn't put
semicolons in your college code it's
considered an anti-pattern to have
semicolons in your polygon you can also
define a function with the single line
syntax that you see here so here we're
defining a function sum it takes two
parameters again and it returns a plus B
so that's just an expression on the
right there and we use the assignment
operator in order to define a function
this way and this is available to you
whenever you wanted to find a function
that can
of a single expression like this if you
want to make multiple expressions you
need to use the curly brackets index
that we're familiar with Kotlin also
provides default arguments for example
we have a function sum with usually two
which has a type of integer and a
default value of two so every time you
call this if you don't specify an
argument for that it will default to two
so next up let's talk about variable
declaration so here I'm defining two
variables one's called name the other
ones called attendees name is eval and
attendees is a var so this is similar to
JavaScript and that name is immutable so
I can't ever assign another string to
name it's gonna be NICTA forever
attendees is mutable so I do assign it
to an ArrayList that i instantiate there
but I could later in my source code
assign it to a different array list so
it's immutable variable Collin really
the difference between Kotlin and the
java programming languages Collin adds
vowels which is the preferred way to
define variables in Collin there's a
couple other syntax things going on in
the slide you'll see when we make a new
ArrayList we don't call the new keyword
in fact there is no new keyword in
Collin constructing a class looks just
like calling a function in Collin and it
looks just like this another thing
that's going on is you'll see the
question mark there which means that
that string is allowed to be null Collin
introduces nullable types which means by
default if I just read spring without a
question mark it would be a non null
string and I can guarantee that that
string will always be not null in my
code and it won't get a null pointer
exception by saying that it's no Lebel
I'm allowed to store Nolen there and
when I dereference it I have to use
special syntax or I'll get a null
pointer exception the next thing I want
to talk about our data classes in Collin
they're a concise way to define a lot of
code so what I'm defining here is a data
class on contact and it has three fields
it has first name last name in email I
could do the same thing in the Java
programming language
I'd say string first name string last
name and string email
and then I'd have to write three getters
and a setter and then I have to write an
equals method and I have to write a
two-string method all of those functions
are going to be generated automatically
for me when I use the data class a
really interesting part about this is I
generally don't have to provide a class
body for a data class if all I'm doing
is defining a plain old Java being
object like this I can just go ahead and
declare a value or first name which
means it's immutable a value of last
name which also means it's immutable and
then aver of email and that means that
it's an assignable field like you see on
the bottom we can assign to email you
might think on this bottom line that I'm
assigning directly to the field I'm
actually calling the setter and this is
a cool part about hot line whose
properties are implicitly called
both forget errs and setters similar to
languages like C sharp or Swift that you
may have already seen this syntax in one
thing that is interesting in Kotlin when
it comes to Java programming often in
Java we have life cycles that are
related to Android life cycle so we have
the activity life cycle which is
different than the activity object so
the object obviously has a constructor
and then we have on create in the
activity which is a different method
Collin requires that all non null
variables on the class be initialized by
the end of the constructor which can be
a problem when you for example get your
shared preferences after the constructor
finishes here we can see an example
where we could make shared preferences
variable knowable and there won't be
access it we have to use either the
double bang we have to put an if check
to make sure every single time we access
it to make sure that we are not
accessing a null variable a better way
to write this in collin it's something
we're going to do a lot in android is to
use late in it so late in it says it's
it's a little bit of a weird construct
but what it really means is this shared
preferences is going to be not null when
I access it but I can't guarantee I'm
gonna have it done by the end of the
constructor so at some point before I
access this variable I promise to the
compiler I'm gonna make it
so it'll relax its no ability checks but
it's not going to enforce that I assign
it before the constructor is done if you
do not actually initialize that field
and access it you'll get a different
runtime exception so it doesn't really
make no pointer exceptions go away
completely here but it does clearly
document what you're trying to do so
we've covered a quite a bit of the
basics of the syntax here it's time to
go back to the code lab and work through
step 3 where you'll do some of the steps
that I just talked about and use some of
the language
so one question I had from a couple
people was does Colin compile to Java
before it before it actually compiles to
a bytecode and the answer is caught link
piles directly to bytecode it generates
JVM 6 compatible bytecode and it also
adds a little bit of extra information
to the bytecode to support some of the
common language syntax which is actually
stored in a protocol buffer in the
header in the bytecode files so there's
no like hotland to Java to bytecode its
Colin to bytecode Java to bytecode and
then it links the to what I want to talk
about now is Kotlin view binding so this
is an Android extension plugin that
comes from JetBrains and it allows us to
access views using the using synthetic
properties so we already have libraries
for doing this in the java programming
language we've probably all seen
butter-knife where you can go ahead and
skip your find view by ID this is a very
similar idea it allows you to skip the
find view by ID the compiler will do
this at violation time and it provides
lazy assignment and caching so I'm just
gonna go ahead and walk through how you
use view biting on some slides right
here so at the App level Gradle file
these are the steps in step 4 if we go
ahead and apply the plug-in Kotlin
Android extensions and then when we do
that it's going to generate synthetic
getters
in the Colin X namespace so it's Colin X
Android synthetic and then now we get
into our code we have main activity
context so that's a layout file we've
defined and then we can get the views
from in there so for example if I've
declared a activity contacts XML with a
floating action button and it has the ID
of that so this is pretty typical code
when I want to use this in my class
instead of having to you know use fine
be variety or even define a property on
contacts activity I
just go ahead and use the fab accessor
and it's synthetically added I just have
to do a static import to get that it's
going to do caching of the fine view of
peyote so the first time I access the
fab it's going to do find view ID to
find it and then every other time I
access it it'll use the same instance
and it caches that in a hash map so
yesterday at the Colin talk we talked a
lot about extension functions so if you
haven't seen that it's up on YouTube I'm
going to take a look today we're going
to define a few of our own
extension functions in this code lab so
I'm gonna motivate extension functions
today by looking at this classic pattern
from the Java programming language and
we're gonna basically added method
called is Tuesday to the date class so
in Java we would write this as date
utils we'd have a static method it
returns a boolean it's Tuesday and it
takes the date as its only argument and
this looks just like a member function
if you think about it and when we call
this in Java we say date utils is
Tuesday date it's a little bit about
awkward construct but is something we've
done in all of our code bases and it
works really well so column provides
extension functions and extension
properties to do exactly this with
better syntax support an extension
function is an extension of an existing
class adding another member to a class
that already exists likewise an
extension property can add getters and
setters to a class that already exists
here we can see the syntax for defining
and calling an extension function so
we're defining a function is Tuesday
that is a method on the date class and
then we're using that inline assignment
to say whenever day equals to two return
true because of type inference we don't
have to specify the return type of our
function and then when we call it we say
date that is Tuesday so it looks just
like it's a member method on the class
however it's not actually modifying the
date class so this is really like the
key to understanding extensions
Kotlin it seems like we're doing all
this magic and we're opening up classes
and adding methods but we're not doing
that so the bate class doesn't get
recompiled we don't add methods to it
we've just defined a static method
called is Tuesday it takes a single
argument that is the date parameter
Colin provides just a little bit of
extra syntax in order to call it like
this so our code looks like this in cot
1 but we haven't actually you know
opened the class and that also helps you
understand how the call semantics work
for these the next thing I want to talk
about our lambda expressions and so I
just have a ton of lambda expressions up
on the screen here and we're gonna walk
through the syntax and how to read them
and how to write them so the first one
the first line actually doesn't compile
all by itself but it's useful to talk
about
it's a lambda expression we can tell
because it has curly brackets on the
outside and an arrow in the middle and
in the left side we have two arguments a
and B and on the right side we have an
expression A plus B so this is a
function that takes two arguments and
adds them together it doesn't compile
because we haven't provided the types
for a and B so we get on to the next
line and we'll see we've defined a as an
integer B is an integer so if we think
about this we can now say a plus B and
we don't have to specify the return type
of that lambda an integer plus an
integer is always an integer and calling
then we assign that to sum and you see
we don't have to provide the type
because some can infer the type from the
literal expression that's on the right
hand side there the next line line 3 we
have the Sun and we've defined the type
on the some object the some variable
itself here it says any function that
takes two integers and produces an
integer that's what that syntax there is
it's in parentheses you list the types
of the parameters you put an arrow and
then on the right you'll it's the return
type of the function then we assign that
to our object literal or lambda that we
had on the first line and you'll see now
it does compile
because we can use type inference to
flow through those types over to the
right-hand side we've defined the
parameters this integer an integer and
now a is an integer because we've used
it in a context where it has to be and B
is an integer because we've used it in a
context where it has to be and again we
still don't have to turn don't have to
say the return type of the lamp and then
on the last line I show a little bit
more of a practical lambda a value not
empty so it takes a textview
and it returns a boolean and then this
shows an interesting part of the lambda
lambda syntax and Kotlin so in this case
I'm not actually providing the arrow
syntax or naming the parameter the value
for a one parameter lambda is called it
that's by default you can always rename
it but in this case we're just gonna
leave it it and so we say it dot text
dot is not empty so where these really
shine is when we start doing anonymous
inner classes so we do this all the time
in the java programming language we do
set on close this quick listener and
then if I read all that it'd be very
long but in the end we override an
on-click method and then the only actual
code that I'm writing here is perform
action everything else there isn't
actually code it's just stuff I have to
get my IDE to generate for me so I can
write the code that I'm trying to write
Colin we can use lambdas to write
exactly what we were trying to say so
this is something we can do we can do
fab that's set onclicklistener
and then we just literally write the
code we were trying to say we can get
rid of all of that extra stuff and it
stays around because we keep using type
inference it's a lot more concise and
it's very similar to the Java 8 lambda
syntax where Landa's get really powerful
is when we start using them in a
higher-order way we've already seen an
example of this but it's any function
that takes another function as its
argument and this is something that you
can use in Kotlin to really make your
code very readable and very expressive
so a classic example of a higher-order
function from like I don't know like
1970 or something
is the filter method so a filter method
is operates on lists so you have a list
and you filter it and you give it a
predicate and whenever the predicate is
true you produce a new list containing
the values where the filter was true so
let's go ahead and read this declaration
because it shows a lot of calculon's
syntax so it's a function it has a
generic type T and then it's an
extension on a list of T and this is
kind of interesting because you can
define an extension on a generic type
this is something that you can do some
really really clever stuff you can even
define it unlike a t question mark where
are you saying I want to define an
extension on a tea or a null value of a
tea then we're going to define a
function called filter which takes one
predicate and then we can see here that
it's a function that takes one argument
of type T and returns a boolean and then
finally of course our function returns a
list of T and then inside the function
we just make a new array list and we
call the predicate on the item whenever
the predicate is true we add it to the
new list and then we return the new list
so if we can win ahead and try to use
this we'd say you know list of which is
Collins way to declare a static list
apple orange celery carrot and then we'd
go basket dot filter again we use that
it to shorten our code if the first
character is C then we're going to
generate a list of just celery and
carrot so that's not particularly
compelling I mean I think we can all
write a loop to go ahead and do that on
our own
but we can write much more expressive
things when we start doing boilerplate
code like this so this is an example of
how you do a database transaction if you
don't use room you have to begin the
transaction then you have to call the
actual database func you want to do and
then you have to end transaction and if
you want to do it even better you have
to do begin transaction call the
function you want to do set transaction
successful and then end the transaction
so again just like the onclicklistener
there's actually only one line of real
code here and everything else is stuff
that I'm just typing and or generating
via other means and because of the way
the Java programming language works it's
difficult to simplify this and turn it
into an abstraction but in Kotlin we can
actually go pretty well
so in kala we can do sequel light
database in transaction so we're gonna
do an extension function on our database
and we're gonna put all of that
boilerplate exactly the same way so
begin transaction set transaction
successful and end transaction but we're
gonna instead of having to write all of
that around every single line of code
that we're trying to write we're just
gonna pass the line of code as a lambda
in the function argument so functions
any function that takes no arguments and
returns no arc no value so when we use
that it looks like this right so we say
DB in transaction we pass it a lambda
and then we only write the code that
we're actually trying to write now this
is a little bit weird because we're
accessing database from inside of our
lambda and lambda is a function literal
so if you think about it that means I'm
gonna have to make a closure in order to
get to that database variable in another
way we might do that is we might pass
the database to the function in this
case we've defined function as a sequel
light a function that takes a sequel a
database and returns nothing so if we
did that it would look like this Davida
in transaction it thought the week it's
okay but it's I think it's a little bit
weird still we can do even better the
this syntax right here for defining
function is what we call an extension
lambda it's a floating function that
operates as an extension function when
we do this we can go ahead and call the
extension function on any object of type
sequel a database in this case we're
going to use the implicit this from our
extension function and call this thunk
then over in the other code I can just
say DBA and transaction and I can just
go ahead and call the function on the
database that I wanted to use this
creates the beginning of a
domain-specific language in college and
it's extremely powerful there's one
thing I want to mention about the code
that we have up here though this is what
happens if you compile that code and
then D compile it we end up with this
and it looks a little bit messy but
what's really important is when you call
in transaction it creates a new function
object
because every single time it has to
capture the arguments in Colin when you
write functions that you intend to be
high-performance that take a lambda you
should use the inline keyword so you can
use the inline keyword and when it does
when you pet specify inline is it'll
actually do a source code transformation
every time you call that function so
this works a lot different than in lines
you might be familiar with from other
languages like C++ if you call an inline
function in Colin if you're guaranteed
it's not like a hint it's a literal
requirement you're guaranteed that your
function body for your inline function
will be dropped in place of the call
site at every single indication of that
inline function alright so let's go
ahead and finish the codelab
so whatever steps you have left and then
I wanted to ask everyone to take three
to five minutes before you do to fill
out a feedback form on this blue tab
right here we want to know what you guys
think about Kotlin and where you want to
see us improve going forward and if
you're interested in joining Kotlin case
study go ahead and talk to me I'll be
walking around thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>