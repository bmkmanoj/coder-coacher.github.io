<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>TechSession - Google Identity Products with Amrit Sanjeev | Coder Coacher - Coaching Coders</title><meta content="TechSession - Google Identity Products with Amrit Sanjeev - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Developers-India/">Google Developers India</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>TechSession - Google Identity Products with Amrit Sanjeev</b></h2><h5 class="post__date">2017-08-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4p1t90iE4CU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">[MUSIC PLAYING]
AMRIT SANJEEV: So
how many of you
have apps which
have a login page?
Many of you people, right?
So good.
What we're going to talk
about the next half an hour
is what are the identity
products that we have,
and how you might want
to use some of them
together to kind
of give a better
experience for your user.
Login is not an easy
problem to solve.
You might look at it like a one
screen with a user ID password.
And I'll tell you how
much complexity is there
over this next set of slides.
Well, the idea is to call out
some of the current issues
with workflows on identity.
What options we are providing.
I'm not talking about
external authentication APIs.
I'm just going to talk
about what Google's
providing for you today and
how this can kind of make
an experience a little better.
And if there are questions, I
can take it towards the end.
So let me start
with something which
you want to differentiate--
identity and security.
They're not the same.
That's the whole point that you
should start thinking about.
Identity is not about
validating who you are.
It is just getting an identifier
for a particular user.
Your name is your
identity, your email ID
would be your identity.
But when coupled
with a password, when
you can verify
against it, that's
when security is
actually coming in.
A lot of times, solutions
don't need security.
They just need an identity.
Like if you want to save
a user's preference, which
he is not editing but
only your app is actually
going to understand, all
you need is identity.
You don't need a user
ID password there.
You just need an
identity against which
you could save certain
parameters, which
you can reuse to kind of
make the experience better.
Simple example is
personalization.
If you want to kind of use
data to personalize somebody's
experience, you need an
identity at most times.
When you want that person
to be able to change it,
that's when you need
the security part of it.
You can then actually
kind of look at it
like, OK, I need to
allow them to sign
in, verify his identity,
a verified identity,
then allow him to
change his password.
Or allow him to
change his settings,
in this case,
which the app might
have collected on its own.
So first thing is start
off by deciding what
your solution really needs.
There are a lot of solutions
where people usually
ask for a user ID password.
But the user does not have
anything to edit against.
It basically is for
only storing their data
or personalizing some
information at a later use.
Why would we need these
identity solutions?
Basically because apps
are now more complicated.
If you [AUDIO OUT]
today, most of them
have identity-- most of them
have like, personalization,
which requires identity.
Most of them have your bank
account, your social profiles.
All of these things,
card payment-- sorry,
payment options.
All these things are
something that you
need to protect with
a security around it.
So apps have become
more complicated.
Things they are building are
becoming more complicated.
So the need for having security
and using identity solutions
are more and more
prevalent right now.
Again, securing data is
not the only thing here.
You also have a
lot of apps which
are actually building
personalization and experience
around it.
So users always love that
personalized experience.
And that's like an
identity that you are--
things that people
are actually seeing
as plus points of your app.
So you really need to kind
of build these things.
But when you look at the
login screen, a lot of people
look at that when
they want to log in.
You really have
to consider login,
and then you have to look at--
what are the options provided?
Which one should I use?
Did I use this last time?
All these sort of
things, questions
start coming into your mind.
And login is not something that
is a part of your business.
It's basically a way
to get to your service.
So you need to make this
as frictionless as possible
and make it as easy
for the user so
that he can get over this hurdle
and then get into your app.
Making it harder here is kind
of a way for dropping users off.
So typical thing, if you
look at a login screen
today, you have some
of these questions
that come to your mind.
What are the permissions
that I need to give here?
It's asking for SMS.
It's asking for this
account storage.
So multiple permissions
are getting asked.
Why?
Where are they going to
use this information?
Now, there will be multiple
login options provided.
Twitter, Facebook, GitHub--
email, ID, password.
Which one should I use?
Which is going to be
more convenient for me?
Which one should I share?
These are all questions
that the user has
to answer before coming to us.
And again, if it is something
like user identity password,
you did not think when you
put your first name dot
last name at
Gmail.com that you had
to type that long name every
single time you want to log in.
So you would have loved to
put the first name, first cap,
maybe a few characters, and the
second name, few characters.
But instead you put really
long names as your Gmail IDs.
Not typing it in without any
mistakes becomes a problem.
So these are all places where
users actually slow themselves
down.
And when you already
made your login,
the next time you're
trying to log in,
again, you have problems.
You then think about, I don't
really remember the password.
That's just part
of the problem, OK?
You can also have problems in--
which option of the four
did I select last time?
If you remember the option,
which Gmail ID did I use?
And the sad part of
this whole concept
is that you have
to try each of them
to figure out what
you did or did not do.
You can't really have any
additional information there.
I think I used Gmail.
So now try to log in with Gmail.
It says, oh, no, a conflict.
OK.
Then I did not use Gmail.
So this becomes like a
permutation combination problem
to solve.
But this is not simple.
Because according to research
that some of the UX team did,
92% of users drop off when
they can't figure this out.
They are not taking the
time to kind of go and try
all these options.
9 out of 10 abandon an app
when they're trying to log in.
That's so much business lost.
And I'll keep
calling business out,
because that's what you are in.
Business of the apps, right?
You're not always
about free providing
for the better of the world.
You're also kind of trying
to make money out of this.
But if people are not able
to re-log in into your app,
how are they going to
experience your service?
And how will you earn revenue if
people are not coming into it?
So the re-login, a lot
of you guys save it,
make it automatic
for users to come in.
But one year later, when
they actually kind of change
their phones, they again have to
go through this whole problem.
Now, when you're building login,
it's not just about signing up.
There are multiple flows--
sign up, password recovery,
resetting passwords, sign in.
All these flows have to be built
with the same level of security
and same level of
thought that you
are doing for the login screen.
So there are alternative
paths that you have to take.
What happens with
each of these paths
when the network
connectivity is not
there, when the network
connectivity is there,
when the server
returns an error?
All these conditions
have to be taken care of.
So this is not
really super simple.
And the problems
multiply when you
have multiple platforms of
support like web, iOS, Android.
So then in each place you
have to build all these flows.
So building a login
system is not like, oh,
I'll do this over the weekend.
It becomes quite
tricky as you go.
And it scales.
You need scalable
back end to do that.
Like, suddenly some of the
top app blogs feature you.
You get hundreds and
thousands of users
coming into your app on
that first three days.
You need the system to be
able to scale to that too.
So these are real
problems that happen.
And you need to kind
of work with it.
But what do really users want?
What do you think users want?
Why do you think login
is kind of this, my god,
I have to do this
again sort of a thing?
What do users look for when
they think about a login screen?
Any guesses?
They would like phone
numbers instead of email IDs.
OK.
That's one way a
lot of Indian apps
have actually moved on to
phone-based authentication.
So all these are different
solutions to the problem.
But the problem really is that
all users want is simplicity.
Why do you think everybody
puts the same password for all
the sites?
Bad idea, by the way.
If you put the same password
on all the sites, one password,
one side leaks it, your entire--
what is it?
Your entire secure web
browsing or service usage
becomes open for everybody
to play around with.
So don't do that.
I know.
I can see a lot of
smiles, which means some
of you guys are doing that.
When I say same password for
multiple sites, don't do that.
That's a bad idea.
But passwords are
not a bad thing.
And people don't remember
because passwords are bad--
or forget because
passwords are bad.
It's just not simple enough.
So one of the other stats,
most of the passwords
that all password people use,
one is password, by the way.
The word password
is the password.
And other common ones
are 1, 2, 3, 4, 5, 6.
That's actually very high in
the list of top 20 passwords
used in the world.
But the very interesting thing
is, out of the top 20 passwords
people use, a majority
of them are a combination
of 1, 2, 3, 4, 5, 6.
It's 1, 2, 3, 4.
1, 2, 3, 4, 5, 6.
1, 2, 3, 4, 5.
Things like that--
or 6, 4, backward.
Majority of the top
20 passwords, that is.
I'm not asking you guys to
go hack anybody tonight.
I'm just giving you some
stats just to prove the point
that it's difficult for people.
That's where Google
Signin comes in.
That's the first product
I want to talk about.
That's Google Signin.
Basically, a couple
of things that we did.
Google Signin's been
around for some time.
A couple of things that
happened in the last year
is that an improved UI
came into the picture.
So if you've tried Google
Signin a couple of years ago,
then the experience
that you have
now versus what you had
a couple of years ago
would be different.
First thing that happened
was that the first screen,
which is the one in the blue,
that that UI was how it came.
It said, the site
wants to do this.
It wants to do xyz.
Thinks it will get this
sort of information.
Lot of cognitive overload
there, because people don't
understand what that meant.
&amp;gt;From that we changed
to the second screen,
which is choose an
account and the account--
like your Gmail ID
just comes up there.
Really easy for
users to work with.
What we did internally is
basically to kind of reduce
the amount of information
that's coming back in your JWT--
which is a web token,
JSON web token--
and the users email ID.
And this was made
consistent across platforms.
That's the web one, and
this is the iOS one.
So it became consistent
across platforms.
Made it easier for people
to see that if they've
used or experienced
your app on the web,
it becomes very easy
for them to kind of go
through the same workflow
if they're using it
on Android, or vice versa, or
on another platform by the way.
The second thing
was, all the SDKs
were oriented to kind of give
the basic profile information
which consisted of four things--
what was the type, your name,
email ID, and your photo URL.
So three pieces of
information come back
in an encrypted web token.
So that made it
consistent across it.
And if you wanted
more information,
then you could use
the People API.
There's another API
called People API,
and it will request
for more information.
At that point, the user will
be prompted to provide access
to that information though.
But making the
simplification kind of
does a couple of things.
One, it reduces the number
of calls to the server.
Earlier, you would actually
ask for an access token.
Then you will sign in.
You get an access token back.
Using the access token, you
will pass that access token
to your back end server.
The back end server would then
go ask for user information
and then would get
user information.
So multiple round trips,
multiple systems involved.
With the new ID flow
what happens is your app
will ask for the information.
It basically asks for sign in.
You get an ID token back.
The ID token is passed
to your back end,
and you get the
information ready.
So it is easy for
you to kind of work
with it, the round trip-- one
more round trip to the server
got reduced.
Because the encrypted
token, the encrypted token
goes back to your back end.
Your back end can unencrypt it.
And then it sends
you the data back.
It makes it less time consuming
for making a login flow.
Now, I want to go
to the second one.
But before that, this makes
signing in really easy.
Because you are just
clicking on one,
providing your information,
and then you're
signing in automatically.
But again, the problems that
we talked about earlier,
which is--
which option should I select?
Now, once I select
my email ID, typing
would be more or less like
the one just for the bottom.
I keep typing it,
making a mistake.
How do we avoid all these
things happening again?
So that's where a lot of
apps have huge drop offs.
Over 50% of people, they say,
don't complete their sign
in flows.
And when we talked to a lot of
the top apps of the country,
they mentioned that they are not
happy with their sign in flows
because it's overly complicated.
Now, this is where Smart
lock comes into picture.
Smart lock is a product that
allows you to kind of save
the credential information and
associate it to your identity.
So if I'm using xyz app, when
I log in for the first time,
or when I'm signing
up for the first time,
I can actually save the
credentials on Smart lock.
This makes signing in
again an automatic process.
So when you open the app, or
when you reinstall the app
again, what happens is
it knows your identity,
which is your email ID/password.
It will automatically pull
it up from the credentials
and sign you in and go
straight into the home page.
You won't need to kind of
go to the sign up page.
And this works across platforms.
So if you sign in on Android,
save it on Smart lock.
When you go to web
on your solution,
it will automatically
sign you in.
You don't have to type your
user ID password again.
Now, if you are not--
your solution does not
require you to kind of--
this can even be
simplified, where
the user doesn't even ever
type in a user ID password
at the start.
You just have to select
the account they're using,
the password.
If you're using email
ID-- let's assume
you're using user
email ID and password.
The password could be
an auto generated value.
You can put it in.
Because the user coming
back to your site
will automatically be logged in.
The user is never typing his
password again after that.
And that makes it very easy to
kind of simplify and speed up
the process of signing
in for your user.
So when the user comes
back to your solution--
has signed in once, saved
on the credential store.
You come back to the site
again, the site or the app
again, automatically
signs us in.
So the next time
somebody-- all these
points that we talked about,
forgetting your password,
which option do we use?
All of that can be taken off.
And this works not
just with Google ID.
You can use a Facebook.
You log in with Facebook, also
it allows you to go through.
Your give your ID there,
it just goes through there.
Now, the amount of code
that you got to write
is something like this.
It's really very concise code.
You basically create
a credential request.
You set the support type
of logins that you support
and the new request for it.
That's basically
all that's there.
So the amount of
typing that you've
got to do in terms of writing
in code to realize this use case
is really small.
You barely use the SDK.
This is how it happens.
The first one was in Android,
this one is in Chrome.
Now, one more concern
I talked about
was that the user has to type in
their user ID password, right?
Now, that is a place
where a lot of drop
off happens, because
there are mistakes
that are made when
you type in because
of the cramped keyboard, or
you are in a moving vehicle,
and things like that.
Makes it more difficult to
type in a user ID password.
That's where this
API called it Auth
Hint API comes into picture.
What Auth Hint API
allows you to do
is basically it throws
up a dialog like this,
showing all the
identities that you've
registered on the device.
So in a place where
you have a user
ID that needs to be typed--
assume it's email.
Instead of typing
it, when you click
on that, when the focus comes
to that, a dialog like this
will come up, prompting
all the accounts that
are already there.
Anyway your phone already has
your email ID registered to it.
That email ID will come up.
All you've got to do is click.
It'll automatically
populate that for you.
That means the need for you
to type in your password--
eliminated.
It works with
phone numbers, too.
So the phone numbers,
again, you don't have
to type in your phone numbers.
You just can go ahead
and prompt the user,
the user can select it, and it
will automatically get loaded.
And this makes it--
and some of the people
that we worked with
have conversions over 20%.
Because they
actually implemented
[AUDIO OUT] to sign up.
The signing in
became a lot faster.
The number of mistakes
that the user did
typing in the wrong thing, wrong
email ID, or wrong phone number
got reduced.
So the whole login process
became a lot more faster
and simpler for people.
Let me skip this one.
But let's see how
much code is there.
It basically has this
much code to actually work
with when you want to
add that to Android.
You are asking for the hint API.
And this works
independent of whether you
use Smart lock or any other.
It can be added
to any text field
where you want to
populate your user ID.
And that makes it
really, really easy.
This is the amount of code that
you need to code for Android.
And now let's jump onto
something which is--
so now we have done two parts,
actually three components.
First is, how do you sign in?
Google Signin allows
you to do that.
Second, we actually looked
at Smart lock, which allows
you to save the credential.
So first case, simplify
the signing in process.
Second, simplify the resigning
process, or re-logging
in sort of a mechanism.
The third one
allowed something--
the third one augmented
the experience
by reducing the amount of
typing in a user had to do.
So the amount of
keyboard usage got
reduced, because you are
just clicking through,
selecting your ID that
you want to work with.
Now, Firebase Auth basically
is about the back end part.
Now, this is all front
end right on your device.
Now, if you want to kind
of talk about the back end,
there are a couple of things.
One is that a login
system should be set up
on a very secure server.
So there will be
security around that.
Fine, that can be done.
But it also needs
to be high up time.
You cannot tell
your users that, oh,
you can't log in because
my server did not--
all our servers are available,
but you can't log in though.
Bad idea.
So you need a high up time
server, which is costly.
It's not easy.
A 99.95 server is going to
be difficult to maintain
and administer.
Changes, everything is
actually trickier than that.
It also needs to handle
user credentials.
You need to integrate it
with things like, how do you
handle password resets?
So you need code to
be done for all this
if you're doing it
all by yourselves.
How do you do
authentication flows?
Basically, if the user has
roles and responsibility
authorization, roles
and responsibility,
then how do you
map these things?
How can you change some of this?
It also has to
manage user sessions.
How long will be
the user session?
Somebody sends you a mail.
I want you to
revoke my password.
What would be the
process for that?
You need to actually
be having UI to do--
UI or a programmatic construct--
to do all these things.
Basically because
you can't get--
like, one user asks
you--you have 50,000 users.
One user asks you, I want
you to revoke my password.
Admin goes into the SQL
table and types in SQL.
That's a bad idea.
He misses one statement,
everybody will get logged out.
So those sort of mistakes
we want to avoid.
So you have to build in--
you have to build all these
things into your server side
management tool.
Mapping user
restrictions-- again,
roles and responsibilities
if you want to do,
you have to actually
create best practices.
You have to ensure that somebody
cannot be an admin as well
as a user.
A user, when given admin,
needs to be checked again.
All these processes have to
be built into the programs
that you write on
the server side.
Now, what Firebase
Auth gives you
is a mechanism to do all
these things, keeping
Firebase as the back end first.
The currently supported
signin methods are--
we've added one more,
by the way, phone--
GitHub, Gmail,
Facebook, Twitter.
You are anonymous.
Your user ID password, if
you need that support--
and also phone.
These all are options that
are available already.
And you can use any of this
to sign into the Firebase back
end.
The Firebase back end
will tell you, hey,
this person is allowed to sign
in and use all the services.
It not only does that,
but it also allows--
if you're actually
using Firebase Auth,
and you're using
Firebase database,
you don't have to re-log in
to other services in Firebase.
You're only logging in once.
The token provided has
access across the board.
So this makes it really easy
for you to kind of speed up
the usage of
services in your app.
Like if you're using
storage, for instance,
to store all the images, you are
using real time database, say,
for messages and
communication between users.
You're using another Firebase
service, like analytics,
for instance, or multiples
always are there.
So basically, if
you want to use,
it's the same token
that you would use.
You are signing in
once at the start.
And that token might be used
for all of these other systems.
So instead of actually
signing into each system
and to authenticate
and authorize,
you can actually manage it one
place for all these services.
So it makes it really easy for
you to manage and administer
your users from a
security perspective.
This is all that you
got to do in order
to kind of create something
with user ID and password-- one
line.
It does all this work of
verifying it, storing it,
coming back and authenticating.
All that thing is done for you.
Now, what I said,
you can log in once
and access multiple services.
Otherwise, if you're using
separate services for this,
you'd log into each service.
And then it might
be under the hood.
The user might type in
the user ID password once.
But before you use the
service, you go to that server,
give the user his
password or credential,
and then ensure that he
is able to sign into that
and get his authorization there.
Use that to apply the
operation that you're actually
trying to do.
Much longer process.
Otherwise, with Firebase, it's
much easier in that sense.
Now, if you want to
build a UI-- so now
we have talked about how to
move out the back end also.
Now building UI-- if you look at
the super simplified workflow,
I'm coming in.
Users are signed in or not.
If they are not signed in--
if they are signed in, take
them straight to the service.
If they are not signed
in, go to a sign up page.
Very simple.
But as you grow and implement
more of the features
that I talked about
earlier, the UI
becomes complicated like this.
This is an actual flow of an
app with all the flows so far
logging in just
depicted in pictures.
This is not how complex it is.
It is three times more
complicated than this
because you have to do it
thrice for different platforms.
So when you come back,
the amount of code that--
we roughly did some
experiments, and said,
look, the amount of
code most people would
write on each of these
platforms would be this much.
Now with Firebase Auth UI,
which is basically our solution,
this reduces down to this.
The amount of lines
of code you write
reduces down from 3K to 7,
just seven lines of code.
And this saves a lot
of time in development.
So if you are actually building
a new solution around it,
or you are actually thinking of
upgrading your security things,
try looking at this one because
it saves you a ton of time,
a ton of testing.
You could use your
resources to work
on writing 5K lines of
code on one platform
to kind of move and work
on something else which
is more important for
your business, maybe
the next business feature.
And this is how the
UI looks like when
you use Firebase Auth UI.
It basically has
customization of the UI.
You can actually theme
it to your application.
It provides you sign in flows.
It provides you
create account flows.
All these things are provided.
And you have this consistent
experience across applications.
So if two or three of the apps
are using the same Firebase
Auth UI with their
own branding on it,
from a user's perspective
he will clearly understand,
what are the permissions
that he is giving?
What is the information
he is giving?
What will be the
next screen like?
So there's a consistency
across applications,
and it becomes really
easy for the user.
So in a nutshell, this is
how much code that is there.
Super cool, really
simple to write.
And that actually gets you the
UI up and running for login.
You don't have to worry
about all the different flows
that we talked about.
You don't have to
worry about how
you wire it to the back end.
All you got to do is use this
plus the Firebase server--
I mean, Auth component.
Auth UI and Auth
component put together
makes it ready in less
than an hour for you.
Which otherwise would be, like,
at least a week and a half,
including testing.
So this allows you to build
stuff really, really fast.
So that's all I had to
kind of talk about today.
But just to run through
it one more time.
We talked about
Firebase-- we talked
about Google Signin,
which makes signing
into your solution really easy.
You don't have to really
maintain user ID passwords
and stuff like that.
&amp;gt;From there, we
moved to Smart lock.
Smart lock saves
the credentials you
use so that you can reuse it to
automatically log in your user.
So the re-login becomes
a completely frictionless
process.
Then we talked about Hint API.
Hint API basically allowed
the sign up process
to become a lot easier,
because you're not
typing in your credentials.
You are not typing in the user
IDs or email IDs or your phone
numbers, for instance.
It automates that for you.
The user gets a selection
box of the IDs that
are registered on the device.
You could select
the one, and it auto
populates it on your behalf.
&amp;gt;From there, we moved
to Firebase Auth,
which is the back end server.
So once your front end is--
these three things put
together in the front end
makes sign-up process
easy, saving your passwords
and signing in easy, and saving
your passwords really easy.
Saving and re-logging
in really easy.
But there also is a
back end component.
So if you want to do
the back end component,
you introduce Firebase
Auth to do it.
Now, once that is
done, if you really
want to kind of completely take
your hands off the UI also,
you don't want to build
a UI for logging in,
you can use Firebase Auth
UI and kind of simplify
the whole thing.
So all these products
put together,
your auth experience
for the user
becomes really easy, consistent.
&amp;gt;From your perspective,
the amount
of effort that you need
to do is a lot less.
That's it from me.
Thank you.
[APPLAUSE]
[MUSIC PLAYING]</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>