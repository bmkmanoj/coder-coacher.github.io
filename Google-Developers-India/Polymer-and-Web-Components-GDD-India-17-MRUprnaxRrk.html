<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Polymer and Web Components (GDD India '17) | Coder Coacher - Coaching Coders</title><meta content="Polymer and Web Components (GDD India '17) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Developers-India/">Google Developers India</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Polymer and Web Components (GDD India '17)</b></h2><h5 class="post__date">2017-12-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MRUprnaxRrk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right hi everybody my name is Taylor
savage I'm a product manager on the
chrome team at Google working on are
many different open source web developer
products that we build as part of the
chrome team and I'm here today to talk
about one of the products that we work
on on Chrome in particular that we've
actually been working on for quite a
long time which is the polymer project
and also to talk about some of the
underlying new really exciting web
technology that makes polymer possible
which is web components so I'd like to
start off by giving a little bit of
background by talking about some of the
problems that we set out to solve when
we went and started the polymer project
then when we started this effort around
web components so as everyone here well
knows the expectations of web developers
are extremely high we're expected to
build sites that work across a wide
variety of different browsers devices
that work across all kinds of different
screen sizes that run at 60 frames per
second that are silky smooth to the
touch and immediately responsive that
load fast on slow and flaky networks
that work offline that can send push
notifications so much more there's all
this difficulty in building a modern
mobile web site today but the tools that
were given as web developers on the web
platform haven't really caught up to
this challenge the web was initially
designed for documents and so the
primitives that we get on the web are
tags for things like headers and lists
and paragraphs things that were great
when you were trying to send a document
over the wire but just don't really work
for the applications that we're trying
to build today so we don't get
primitives for example for things like
UI tab strips a UI tabs are an extremely
common paradigm across all kinds of
different modern mobile applications but
this is surprisingly difficult to
achieve on the web and this should
really be something that's first-class
and easy when we're trying to build
mobile websites and so over the years
we've come up with lots of different
ways to basically effectively munch
together these very low-level document
primitives to be able to eventually end
up with something like UI tabs and the
way primarily that we do this nowadays
is through JavaScript frameworks and
these JavaScript frameworks take these
low-level document primitives in
into UI and they work in all kinds of
different ways so some frameworks will
have us kind of overload existing tags
and scaffold out any UI elements we want
to build using HTML and then make some
magic JavaScript incantation that will
somehow know how to understand the
existing HTML and create a tab strip
others will let you kind of add more
HTML and JavaScript together and kind of
customize your tab strip enjoyed with a
JavaScript object and also customize by
using different HTML tags some will have
us do as much as we can in JavaScript
and we'll have us not worry at all about
the Dom that it's going to construct and
then others will see some sort of mix
they'll mix until Nesta HTML strings
inside of JavaScript inside of HTML
inside of JavaScript and maybe some
domain-specific language inside of that
JavaScript HTML Frankenstein monster and
all these different approaches are
really ultimately solving the same kind
of problems we're trying to build a
reusable UI component but all these
approaches are very very very different
and it can sometimes feel like there's a
new JavaScript framework coming out each
week because there really is a new
JavaScript framework coming out each
week and this is exciting this is not a
bad thing only the web platform affords
the kind of scale and flexibility and
diversity to support this massive
flourishing ecosystem of different
JavaScript frameworks this is great this
is really good but for us it on the one
the web platform team at Google it's
kind of indicative of a larger problem
and it also causes a lot of problems for
all of us as a web developers as well
which I'll get it to it a little bit so
on the polymer project on the chrome
team we recognized that this explosion
of frameworks was awesome it was a
testament to the power of the web
platform but it was also an indicator
that there was something wrong there was
some underlying problem that needed to
be solved by all these different
frameworks in the web platform itself
that we were all looking towards
javascript frameworks to fill and so
when we set out on the polymer project
rather than just setting out to build a
better JavaScript framework which we
couldn't really do we set out to fix the
underlying platform problems itself so
you actually build a better web that's
one that's more conducive
to application development to help kind
of solve some of the problems that all
these frameworks are trying to solve in
the platform itself so what do I mean by
that that sounds hard and complicated
where do we start so we started with
kind of a survey of all the different
JavaScript frameworks out there which
again solved many of the same problems
in slightly different ways and many of
us on the chrome web platform team had
past lives had ourselves built
JavaScript frameworks and so we were
very well acquainted with some of the
problems that this proliferation of
frameworks can cause with web
development so there are two really main
costs that really that expose themselves
as we went through this research of
different JavaScript frameworks that we
set out to solve by baking in new
primitives to the web platform itself so
the first cost is a lack of
interoperability so what do I mean by
that this lack of up interoperability is
a cost that you the developer pays so
JavaScript works bring a lot of value to
make web development more efficient and
many bring their entire stacks
proprietary stacks of functionality and
all javascript frameworks ultimately
provide a way to build a standalone
component model that's kind of the crux
of vast majority of javascript renmark's
is allowing you to build a standalone
reusable component but the components
that you build in a framework are very
fundamentally tied to that framework
stack and that frameworks runtime so
this is fine if you're one developer
building one site but if you're working
with a bunch of different teams who each
want to kind of use their own paradigm
or each use their own framework you're
you're stuck you can't share components
at all if you're one developer that
builds a site once in one framework and
wants to maybe move to a new or more
modern framework later on all those
components you built for that old site
are useless you can't port them to the
new framework so this makes for a really
incredibly high switching cost when you
want to switch frameworks and it also
makes that decision of what framework
should I use to be kind of the most
important decision that you have to make
for your entire project then you have to
make it day zero which is really scary
and it also fractures kind of a
component ecosystem across all of us web
developers so this is a very costly
problem a very costly decision not so
much for a single developer but as your
team scales and as the ecosystem scales
it becomes kind of this aggregate cost
the second cost that we set out to solve
was one that your users pay which is
extra overhead specifically on mobile so
the mobile web as we all know has really
incredible reach but it reaches into
places where your users might have slow
connections flaky mobile connections
expensive mobile connections or be
running your website on slower older
devices and furthermore user
expectations on mobile devices are
extremely high users expect these
applications to run at 60 frames per
second to load extremely quickly and so
it's incredibly important that we're
able to build sites that can load
quickly on mobile even despite these
difficult kind of network challenges so
when we're using a JavaScript framework
to provide our component model the
browser must download and then parse and
then compile and then execute that
entire JavaScript framework before your
web app can even come close to running
and this is fine on big beefy machines
with wired internet connections but it
doesn't really fly on flaky mobile
connections we're taking the most
critical part of our code which can be
you know 50k of JavaScript then forcing
it through this very narrow pipe and
that cost of extract of attraction
becomes extremely real when you get out
into the real world and start loading
these frameworks on real mobile devices
on real networks so our mission on the
polymer project is to make the web
platform itself a more capable
development platform so that you can
build web applications with way less
overhead with wave fewer costs and take
advantage of what's already sitting
there directly in our users pockets on
our users devices in the form of the
browser that they have on their phone
and so our motto for the project overall
is to use the platform to use what's
already be installed on the user's
device the browser so there's some good
news the web platform itself is actually
incredibly powerful and I want to show
you a little bit what I mean by that by
taking a look at a element that an HTML
element that I'm sure many of us are
familiar with which is the humble select
element so we're probably familiar with
select it provides you with this
drop-down menu that you can click on or
tap on it expands and you can select an
item inside
lect and it's a really incredibly simple
element but it provides this incredible
amount of power kind of all hidden away
behind the select tag so if you just put
an empty select tag on your page you'll
get this little kind of button like
thing with the little arrows and nothing
else but you'll notice this one little
tag gave us kind of quite a bit of UI we
didn't tell it how to draw on screen we
didn't put those arrows in there we got
this all for free as part of this select
tag so the Select elements also
composable we can add options to the
Select drop-down and in order to add
options to let the user choose from
we simply compose new option children
under the Select element itself and now
we get this much more complicated UI so
we get the ability to kind of mouse over
and the new the option that the the user
is hovering over highlights when they
tap that option it becomes the selected
option in the drop-down you can use
arrow keys and things like that to
navigate the Select drop-down again all
of this for free just by using this
little tag it's also declarative so
beyond just just children and select
element we can use HTML attributes to
make certain options selected or sampled
we can change the behavior of this
component just with this declarative
attribute it's forgiving so if we mess
up and if we put the wrong child in our
Select element the browser doesn't crash
our web app doesn't crash it'll just
kind of ignore that and keep moving on
it's accessible to a screen reader kind
of by default so it gives you these nice
little attribute handles to make sure
that this element is fully accessible
and it's also programmable so the
document object model the Dom provides
an interface for your application to
talk directly to this select element in
JavaScript so it provides a whole API
you can get and set information using
properties on the component you can
listen to its events to that it fires
when state changes within the component
and you can call methods on the
component if you want it to do something
so it's got this full kind of rich
comprehensive API again just for free
just by putting this tag on your page so
all in all select is a pretty amazing
elements declarative it's encapsulated
you can reuse it all you want you drop
it on your page you're not worried about
it impacting other things on your page
this is the sort of UI component that we
really all want with us
standard interface that's usable in
JavaScript so you might think okay so
let's take that select element which
again was kind of great for documents
and simple forms and let's just build a
whole bunch of more elements for more
mobile-friendly kind of UI components
and on the web platform team we might be
tempted to do that to add a bunch more
HTML elements like select that were
there specific for mobile applications
and indeed in the past that has kind of
been how we've gone about adding
functionality into the web platform but
a few years ago a bunch of browser
vendors got together and wrote what was
called the extensible web manifesto and
this is basically an agreement saying we
as browser vendors can't really
anticipate what the next high-level
abstraction or the next high-level
component you're gonna want is going to
be so instead of doing that first we're
gonna take a step back and make
low-level primitives that let them make
the browser itself extensible so that
you as a developer get the full power
that we as web as the web platform
creators would have in order to create
your own HTML elements so rather than us
defining the language for you you get to
build the language yourself so we want
to be able to provide all of the power
that makes select possible to you the
developer in the form of new low-level
api's so what would you need in order to
build your own HTML element like select
well you need to give it a prototype and
you need to let the document know that
you've defined this new HTML element you
need to be able to define its own
internal UI kind of like how the Select
had that drop down menu in those little
arrows you need to be able to define
that yourself and encapsulate it for
your particular element you need to be
able to extract away how it manages
those children and abstract away any any
uh any styles for the element for how it
works so that it doesn't impact the rest
of your page when you use your own
element and you want it to let it
declare in it and handle its own
dependencies so if the element relies on
other elements it needs to be able to
load those itself so all of these
features that I just described all these
features that make building your own
HTML element possible are part of the
new web component standards so this is a
set of API is available in the web
platform to let you have a developer
extend the language of HTML itself and
build your own H
Bell tags so I won't go too deep into
web components there's it's certainly a
trove of information there but it's
effectively made up of three new
primitives so custom elements which let
you define your own HTML elements and
and tags and add behavior onto the
JavaScript prototype or JavaScript class
templates let you define your elements
internal layout in an inert and easily
cloneable way and then shadow Dom gives
you composition as well as scoping to
encapsulate away any Styles you might
want to apply to your element but not
the rest of the page so now for those of
you that have that may have been
following web components you might
notice that I've left out something here
which is HTML imports traditionally HTML
imports have been part of web components
they were conceived as a way to load
element definitions but as of recently
since browser vendors are shipping ES
modules as a way to load code from other
code we're leaning in the web components
community more towards using es modules
as that loading mechanism so I've left
them I left imports out of here just to
avoid any confusion so web components
help really solve the two major costs
that I talked about earlier so they're
naturally interoperable at the end of
the day all JavaScript frameworks
ultimately have to speak the language of
HTML and Dom that at the end of the day
JavaScript frameworks are manipulating
Dom at the lowest possible level and
with web components you can now extend
the language of Dom itself so Dom itself
becomes your interoperability layer and
furthermore all of this powerful
component lifecycle and encapsulation
all the things you need to build your
own reusable component are now baked
directly into browsers so you don't have
to ship down an expensive bespoke
component model in the form of a
framework all of that component power is
sitting right there on the user's device
in their browser with web platform
native api's so what does it actually
look like to use a web component so on
the polymer project we've built out a
large set of web components ourselves to
kind of provide the look and feel for
Google's material design UI paradigm and
we've built these all out as web
components so you can just drop
something like a paper button or a paper
toolbar under your page and get this
really nice-looking mobile-friendly UI
component just like you would with kind
of a select element so I'll give it an
example of one of how you might use one
of the
components that we've built so if you
wanted a responsive toolbar for example
you could use our paper toolbar element
and this provides a toolbar that sticks
to the top of the page and you can put
things inside the toolbar to make it
more interactive and you use it just by
loading this definition this paper
toolbar definition that we've built and
then just dropping a paper toolbar tag
directly into your document and to give
it a title you can just nest a div as a
child of that paper toolbar and put your
title my app right inside that paper
toolbar and you get this really
nice-looking mobile friendly responsive
UI component but custom elements are
really all about composability so if you
wanted to add maybe a little hamburger
menu to the left part of your toolbar
you can just nest another component that
we've built paper icon button inside
your paper toolbar set the icon to menu
and that will load this hamburger menu
icon and you get this again really
nice-looking responsive paper toolbar
material design toolbar just
declaratively just using these web
components just like you'd write normal
HTML okay so that's pretty
straightforward let's jump into
something a little more complex a
slightly more complicated use case for
web components so let's say we wanted to
express an ABB an entire API as an
element so for example let's say we
wanted to add a marker to a Google map
and drop it on our page if we wanted to
do this using the Google Maps API
imperative lead directly this actually
takes a whole bunch of code in order to
to set up and it's kind of messy in the
world of web components though we can
encapsulate all of this code all of this
behavior into just a single tag the
Google map element we can load its
definition we can put google map on our
page and just like that you've got a
Google map but that's not it let's say
we wanted to Center the map at a
specific latitude and longitude and with
custom elements we can do exactly that
by using attributes so just like
attributes in HTML we can put a lat
attribute and a law and attribute on our
component we can give it values and
that'll Center the map wherever we asked
it to
now we can also set a zoom level as an
attribute to zoom into the map and
adding an icon to the map is just
intuitive just the way you'd use HTML as
well so you simply add a Google map
marker element as a child of the Google
map give it a latitude and a longitude
maybe make it trackable maybe give it a
title and again just like that you get a
map marker on your map really nice
declarative way of putting together a
Google map and we can express the full
complexity of the Google Maps API is or
whatever kind of part of the API you
want to express as attributes on our
elements totally up to us what those
attributes look like what attributes it
accepts and what behavior they them in
part two the element itself so we've
actually prototyped a whole bunch of
different Google services to web
components and there are a whole bunch
of web components out there for other
types of services as well and you can of
course experiment with your own sort of
services and other things you might want
to encapsulate as a web component so
that's kind of the power of using web
components abstracting really
complicated things or really simple
things like UI elements behind just HTML
tags so what is polymer so the web
component API is that I talked about
custom elements shadow Dom template are
actually very very low-level API so
they're they're very very raw and you
can totally just use them directly just
in JavaScript but we've found that if
you build a bunch of custom elements if
you build a bunch of components yourself
you end up sort of writing the same
boilerplate code over and over and over
again and so we pulled out some of the
common boilerplate code for creating web
components into a library which is
called polymer so polymer itself is just
an opinionated library that provides a
lightweight sugaring layer that makes it
a little bit easier to build web
components and I sort of don't repeat
yourself way so let's take a look at how
you use polymer to build a component so
these examples come from the new polymer
2.0 version of the library which uses a
really nice es6 class-based syntax so
let's look at a very simple totally
basic element just a custom element that
just says I am a custom element so to
create an element with polymer you
create a new custom element class that
will be the class for your element and
you extend polymer element Bay
class which imbues your class with a lot
of the common functionality that you
might need to construct your element you
also define an is method which returns
the tag name for your element so in this
case we're calling the tag for our
element custom - element and then here
in this particular element we'll set the
text content to be I am a custom element
when they when that element actually
boots up and then finally we have to
tell the browser hey I've just created a
new custom element here's its tag name
and so for that we'll directly use the
custom elements that define API which
lets you give the custom element
registry a tag name for the element
which in our case is the result of
custom elements that is getter and the
class that will represent that element
which is our custom element class and
just like that when we put a tag custom
element on a page
we'll get I am a custom element so
fairly straightforward but you can start
to see sort of the power that we might
be able to get by using these these
custom elements api's and Palin Palmer
so let's say we wanted to make the
elements UI a little bit nicer by giving
it a template so associating an HTML
template with a custom element is a
really really common paradigm and so we
make it trivial with the polymer library
so polymer provides this notion of a Dom
module which is effectively just a like
a bucket of HTML that you're gonna want
always associated as the template for
your element so whenever your element is
on a page this template will be will
provide that elements UI so inside the
Dom module you want to give it an ID
that matches the tag name of your custom
element so that polymer can associate
the two and then you want to give this
Dom module a template child and inside
that template you'll define any of the
HTML that will make up the common user
interface for your particular element so
in this case where our element is also
going to be very simple it'll just be a
paragraph that says I'm a Dom element
this is my shadow Dom and again we'll
define our element base class like we
just did in the last example and we'll
register it with the browser and now
when we put this dumb element on the
page polymer itself will automatically
stamp that stamp out that template and
we'll get I am a Dom element this is my
shadow Dom so again fairly
straightforward but we want to make sure
that the behavior of our specific
element
leak out and disrupt the rest of the
page we can't have any style that we
apply to our template accidentally
applying to the entire document and
furthermore we want our element to be
able to handle children really elegantly
so this is where shadow DOM comes in now
polymer automatically puts all of the
contents of an element's template inside
of an encapsulated shadow root and this
is incredibly powerful so what a shadow
root provides for an element is this
kind of safe bubble this safe space
where you can put Dom where you can put
CSS and all of it will just be
encapsulated inside of that particular
shadow root and won't leak outside of
the rest of that shadow which I'll show
you what I mean so let's say we want to
build a picture frame element which just
provides a little gray border around a
specific image so you can see here that
inside our elements template we give
some style to just the basic div tag we
give it sort of a grey curved border now
normally if we provided this style to
div this would totally screw up our
entire website every every div on the
page would have this border but now a
shadow Dom this all gets in caps a
little away encapsulated way too away
inside of our particular particular
element shadow root and also shadow Dom
gives us the power of projection so it
lets an element define where in its
template any children of that element
should be effectively displayed so this
is what's called the insertion point for
your particular element and we declare
this using the slot tag so in this
picture frame case in our template we're
gonna have a div that we've styled above
and then inside that div we want to
effectively project through any children
of our picture frame element so that it
looks like it's appearing inside of that
div so when we use our picture frame
element we'll have our picture frame tag
and then as a child we'll have that
image tag any image tag we want and it
will get projected through that slot
inside that div and it'll get that nice
gray border painted around it and again
all of this will be encapsulated away so
there's even more polymer provides some
basic functionality for doing
declarative data binding inside your
elements template so say we wanted to
create a name tag element we
the elements owner property the actual
property on the Dom node itself will be
a string and that string will show up
inside the text this is owner's name tag
element inside of our template so in our
polymer template we can use this curly
brace syntax and inside of it referenced
the owner property on the elements
prototype so that's what owner here will
reference is the property on the on the
elements prototype with that same with
that same property name and so in our
elements constructor say we can set this
owner to be Daniel and when we add the
name tag to the page the result will be
this is Daniel's name tag element and if
we later on change the value of this dot
owner of the owner property on that
specific element that value in the
string there will update automatically
polymer will handle all of that so I'm
only scratching the surface of all the
things that polymer provides there's a
lot more kind of really handy functions
and things in polymer they'll make it
really easy to build a reusable
component so now the ever important
question which is what browsers do this
work in so polymer and web components in
particular have seen incredible browser
uptake they're there the specs we've
been working on for a while but we a new
version of web components came out a
little over a year ago with v1 and most
major brought mobile browsers now
stative lis support web components so
Chrome and Safari and opera all natively
support web components in in the end the
latest version of these browsers Firefox
just started working on Firefox fry it
down their own web component
implementation and it's really high
priority on edges roadmap in fact it's
the number one and number two requests
on the edge user voice request for
features is shadow Dom and custom
elements and fortunately we provide a
set of web component polyfills so that
if web components are not yet natively
supported on these browsers you can
still use the web components api's
they'll just be a little bit slower and
those polyfills allow you to support all
the way back to older browsers like I 11
and Safari 9 so what browser support is
fairly broad for web components
thanks to native support and also
polyfills that help support older
browsers and the great part is as newer
browsers start shipping native support
for web components so when Firefox comes
out with web comes up where it when edge
comes out with web components support it
you
get that support for free and the web
the polyfills will just drop away the
rest of your code will continue to just
work and you won't have to load that
extra polyfill code so polymer web
components are seeing some pretty
serious adoption in the wild well over
four million pages are using polymer in
production actually we broke our
monitoring system for so we can't even
tell you how many pages but it's
definitely over 4 million we also use
polymer a bunch inside Google so there
are over 500 Google projects using
polymer including all of YouTube as
using polymer in production and then
other major Google products as well as
major brands around the world are using
polymer for their for their UI
construction today in fact Ola cabs
progressive web app is built using
polymer so you can learn more about the
polymer project if you're interested at
polymer project org I'd also highly
recommend checking out the massive and
growing catalog of open-source web
components at web component org so there
are over as of last count over 1300
unique components that are up at web
components that org built by developers
all around the world that you can just
download and use directly in your
application with all of this great
functionality so again that's just
scratching the surface of web components
of polymer I really encourage you to go
check out learn more on the polymer
project website there's also a polymer
app toolbox which is our set of tools
and components that make it really easy
to build a progressive web app so if
you're looking to just get started
building a progressive web app using
polymer web components the polymer
project or insight is a great place to
start so that's it thank you so much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>