<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Creating high performance and stable app experiences (App Excellence Summit 2017) | Coder Coacher - Coaching Coders</title><meta content="Creating high performance and stable app experiences (App Excellence Summit 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Developers-India/">Google Developers India</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Creating high performance and stable app experiences (App Excellence Summit 2017)</b></h2><h5 class="post__date">2017-08-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Mq9TnsrDhZQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's time for all of you all to welcome
our next set of presenters please join
in welcoming the bigger players Jessica
and Graham here from the Play
Constantine - I'm Dario I'm one of
engineering lead on the Play console
team and I focus on analytics hi I'm
Georgia or George and I'm a design lead
on the Play Developer console we're hit
we're happy to be today so let's get
started
who here wants a one-star rating people
know that's great help they want to hear
so we are here to help you to understand
how to avoid them and how to engineer
you Android up for success with tools
from Android and the play causal so
today we are going to cover first about
and talk about why performance matters
and how it affects your user experience
then we will we launched on Io and it is
showing the video from scientists and
always presentation about our program
for Android vitals and then introduce
the notion of bad behaviors following
that we will dip dive into most
prominent performance areas - with tools
how to detect and how to fix these bad
behaviors so we can keep you up in a
healthy state and keep your users happy
as you saw today probably in the keynote
we run machine learning on all the
english reviews to understand the
sentiment of the users are giving in the
1 star 5 star rating what we discovered
is that 50% of the users giving 1 star
rating always complain about stability
and bugs while 60% of the users giving 5
star rating they talk about they praise
our speed design and usability it's not
about the reviews for example the fees
games the developer big-fish games the
developer of the dungeon
cause they focus on load times and the
RAM use to improve their 30-day
retention of the users at Google we are
obsessed with the quality of our Android
platform and the apps you are building
on it so historically since 2012 with
jellybean we introduced the project
butter for better app responsiveness
then we Android marshmallow we
introduced Android those and up
stability also up standby then we
enjoyed nugget we launched a new graphic
API so with a Vulcan api's and finally
we enjoy it all we have a better battery
efficiency and RAM management we have
spent a ton of time to understand what
metrics contribute to our performance
and we are going to talk about those
today so we launched an i/o this year
androids vitals Android battles is an
initiative by Google to improve the
stability and performance of devices you
just saw a video about Android vitals so
no need to repeat in a lot details and
we are going to talk about three major
performance areas which is stability
which may make your app robust and
reliable that means less crashes and
less up freezes then we are going to
talk about battery meaning the primary
concern is not to use the battery
excessively for example preventing
actions like keeping the radio or CPU
active and not necessary and we are
going to focus on rendering how to
achieve that smooth and silky experience
for your users for example if you have a
lot going on in the UI thread how to
move those activities in some big
background thread and hit those frame
rates in time so now that we know these
three areas let me introduce you to the
notion or a bad behaviors so this is the
challenge to make each metric in this
performance area actionable what makes a
good up are good up right
so our first thing this is very hard and
we spend lots of time to came up with
metrics that you can take action on
Dario will dip dive later on in this
matrix and what a bit behaviour exactly
that behaviors application habits that
have a significant and lasting impact on
define on device performance and user
experience today we'll cover six of
those so without any further ado pro the
ordinal if you go to a play console and
open the play course we can see a new
section called
androids vitals and I will turn it over
to Dario to introduce the first four
baby behaviors thank you so you done yes
okay so this is how the Android vitals
dashboard
look like you can we will go into detail
of each section of the under dashboard
one thing that I want to mention before
moving on the data coming here coming
from million of Android users that have
opted in to share diagnostic information
with with googling with you developers
and also it comes for free to you you
don't need to install any SDK in in your
app it's this data are collected at the
operating system level and shipped to
you directly via the Play console as we
will see also if you are performing
particularly poorly in certain areas the
Android vitals dashboard will will let
you know that by showing some where
destination Mass for by highlighting it
so these are the three areas stability
but rendering before moving on let me
mention something about the volume of
the reports that we improve doing
android vitals so previously you would
all you would have only received crashes
or inr reports if a user explicitly
acknowledged a dialogue every time they
were experiencing a crash this was very
tedious and also led to a very low
volume of crashes in many occasions
well with under the titles we only ask
the user for consent once which
typically happens phone activation and
then all the crashes and ANR's for users
that have opted in are sent in in
background
this led for certain apps to an
increased volume of like a hundred x
certainly for most apps is more than 10
X the previous volume and still with a
good coverage 98% of the Android devices
running Google Play services are covered
from all the Android version starting
from jellybean on so let's get started
with with the bad behavior we identified
for stability stability is all about
making your app not crash or not freeze
as George mentioned so they let behavior
identified here ANR rate and crushed
rate which are defined as the percentage
of users that experience a crash or an
ANR on a given on a given day you may be
familiar if you use crashlytics with the
equivalent metric called crash free
users so I assume that most of you are
already familiar with crashes which are
much more common also during development
so I'll dive more in in detail about a
NR NR are like you can see in this
screenshot event in which the
application is not responding typically
for one of three reasons either you're
doing a blocking operation the UI thread
or you are receiving a broadcast you are
essentially doing taking a long time
during a broadcast receiver or there is
a deadlock in Europe somewhere so what's
peculiar about the ans that since the
app is frozen there is no SDK out that
can tell you that your user experience
today or not right
on the contrary we collect this
information at the operating system
level so this information is only
available in the Play console so this
way it's particularly important to get
your attention on this so ok so there is
an a in our rate section on the android
vitals console in the play on the
android vitals - both in the play counts
here you can see a report of how many
user experience an application not
responding across up version device and
ice versions for any given day if the
fraction of user is significantly high
you will also get ready client remarks
to draw your attention if you click on
related ans you
we'll be redirected to the ANR in
crashes sections here you see more
details about each ANR in this case
experienced by the user let's say we
click on it each cluster Elena's
experienced by the user
they console also has a this new feature
of highlighting which ANR's for crashes
were introduced introduced in the latest
version of the app so you can understand
whether your new release is causing some
new problems that weren't there earlier
before you also get to see the number of
affected users so you can understand
whether the Riza they were the
particular issues is affecting a lot of
users or is affecting few users but
multiple times if you click on a
particular of clash or in our cluster
you will see even more details about the
specific crash like the frequency over
time frequency breakdown across devices
up version than the analysed version and
also a time series to see how this crash
is behaving let's say over time and also
you also access the thread dams of the
threads that we believe our purpose are
contributed to the crash of Vienna's so
this is probably the most detail
information that you can get that can
lead you to reproduce the the problem on
your side I want to touch a little bit
on this because Android studio 3.0 gives
you new tools also to work better into
debugging and fixing a NRS or crashes
there are plenty of new profiling
capabilities especially for what
concerns CPU utilization memory
utilization and also a disk or network
i/o operations and this is a great step
to the back
ANR ok they would cost as I said earlier
often lies into some CPU intensive
operation that are taking a long time or
some blocking operations that are
freezing the entire up so if you look at
the CPU profiler you can see a timeline
of essentially how long each method each
annotated method this is taking and if
these methods are happening on the UI
thread
this is likely a cause of an A&amp;amp;R
on the user's device and similarly the
network activity profiler displays the
network activity on a time line if you
can also understand which thread is
waiting on that particular Network
facility to happen so you can understand
from here for example if a slow Network
call is closing are at it is blocking
your thread for our response so we
discussed how review and the bug
Dianna's but how to prevent them in the
first place so the textbook
recommendation is not to do any blocking
operations on the UI thread if you have
to to do some long-running operation you
can use the async task class to schedule
this operation into a different thread
and then get results when they are ready
ok another tool you can use is you can
enable strict mode on the UI thread so
that every time there is a blocking
operation it will be treated actually as
an error so you will discover this
during getting development another
common pattern is as I said as low
broadcast receivers so when you call for
example I go async and then it takes a
long time for you to call finish so
these are very simple examples I
understand
in your case probably your code is much
more convoluted than this and might be
harder let's say to understand or ideal
to this practice but even in these
scenarios you have the same
recommendation of course so you have to
structure your code or you subscribe to
such your code in a way that is
consistent and doesn't allow or it's not
designed to allow long-running processes
to run on the UI side in any conditions
so keep an eye on when you have like
multiple callbacks on which threads they
are running ok this is particularly
tricky when you're using also
third-party libraries because you have
also to take care of how the libraries
are scheduling their daily operations
finally in case of a deadlock you can
usually spot them by looking carefully
at the other traces ok by looking at the
traces you can understand for example if
some threads are mutually waiting on
each other which say
typical cause of a deadlock can happen
also with multiple threads and you have
to detect let's say the cycle so why do
we are not mattes I want to touch on
this before moving on to the next step
we did a sudden turn they mattered a lot
because they affect also your use of
attention we've seen that apps with a
high crash rate where we define
high-class traitor as more than 5% and
have 30% more uninstallation
on the first day then apps with a low
grave site so we observe an immediate
effect on user retention during the
first day and we have a nice testimonial
also from one of the twitter leads
decklid that was using these accessing
the a not the android vitals dashboard
shortly before launching they actually
were able to spot some ANR's and that
was they weren't even aware they existed
and they were able with the tools that
we provided them with the data that we
provided them to reproduce them and fix
them and they've been there probably
since a long time now let's talk about
battery
why does that really matter but battery
matter because it matters to the user
right you are also user of my phone and
I'm sure that you are frustrated as I am
when you don't reach the end of the day
well absolutely fun in how the battery
is used right and we have some tools
apps have some tools to keep the device
active and prevent the device from going
to sleep which is actually the main
cause for battery is draining like much
faster than the issue we identified two
bad behaviors here which we call the
stuck way clots and excessive wake up's
we mentioned a bit earlier I'm going to
dive more in detail about those let's
talk about wake locks so wake locks are
some api's that prevent the device from
going to sleep and saving battle right
and there are two types of wake looks
full wake locks and partial vehicles
full wake locks are used typically in
multimedia apps or games to keep the
device awake in the screen active and
others are not particularly dangerous
because the user is actively using the
app side the usually stay in control of
this particular behavior
also a cook happens when you want to
keep the device awake because you want
to finish an operation but then the user
doesn't have any control on those so if
you keep a partial wake lock for a long
time actually for more than 60 minutes
that's our definition of stock partial
wake look okay and that's the behavior
that we alight to you there is a
dedicated section about starquake looks
in the under advisor section with a
histogram so you can see in this case
that there are many devices that support
the weight loss being held for only few
minutes but some devices on the long
tail are actually been held for longer
than 60 minutes in the breakdown panel
at the bottom of the of this page you
can also see more details about which
way clock is holding or abilities
causing troubles now for in order to
avoid leaking privacy sensitive
information we only report wakelock
names here when we seen them coming from
many sessions so we encourage you to use
standard names when in your in your code
so you don't use dynamic names for
example for weight looks so that you
will receive like the red button reports
because many in case of troubles because
many user with a part are the same the
same name okay
in this case we see for example a
clean-up operation which is presumably
an operation to be done before the
application is shut down just to perform
some cleanup okay why are we why are we
highlighting stuff like logs we did an
internal studies to understand what was
causing excessive power drain issues and
in 30% of the cases we observed that
this was caused because of starquake
looks a health value by some by some
apps on the device so this is really one
of the top sa culprit of poor battery
usage by by any up really
and you should prevent initiative on it
as much as possible to to cause this
kind of troubles to the user how can you
avoid using wakelocks well in some cases
you can wait lots were introduced in the
early days of the Android platform where
it was the only way to have some
long-running operations right but other
time the libraries has added some
utilities to do this kind of common
operation in a more let's say stay
flavor order of a pathway for example if
you need to download a file you can use
the download manager not only it plays
well with the device battery but also it
deals with the HTTP protocol nuances
with the tries automatically it even
rate rise across reboot if you if you
wanted to if your use case is
synchronizing the information between
application and some server-side
database for example you can use the
sync adapter and similarly the think
adapter does some optimization for the
for the user for example thinking
multiple apps at the same time so device
only needs to be kept awake for a
relatively short time if you need to
schedule some job but the article you
can use the five best job dispatcher we
will see an example later on in this
presentation and this allows you also to
set particular constraints so that you
can avoid dispatching jobs whether for
example the user is not charging the
device or it's anomaly or it's on a
metered data network which I know it's
it's very relevant in your market and if
your use cases that you want to wait
until a job intent is completed you can
use the job intent service which also
plays nicely with the without wait logs
and so you don't have to program them
manually if you cannot avoid using white
clock at all still please like program
defensively make sure and this is like
very very basic and if I consider sign
101 make sure that if you acquire a lock
you release the lock in every possible
code path okay I see some of you smiling
here you can see here that if that
finally wasn't there in certain cases we
could have held a look like forever
because the code path to release the
lock would have never been being called
one thing was noticing though is that
even if your code or at least your code
base doesn't use wake locks directly you
might still use wake locks by means of
other library even some under it library
in this case we see that this MLP rate
log stands for a network location
provider and it's sold in the wakelock
excessively which probably means here
that Europe is requesting the location
to the network location provider too
frequently so you should probably
address this by reducing the frequency
at which you depressed at which is the
location so pay attention to this page
even if you believe you don't use
wakelocks because some libraries that
you use might use wakelocks regardless
let's talk about wake-ups
which is the second bad behavior that
will drain your battery wake-ups are
essentially alarms so you can schedule
wake-ups if you want to wake up the
device under a certain condition now if
you do it excessively essentially you
will try the user button so the bad
behavior of excessive wake up's is
defined when you do as when you do more
than 10 wake up's per hour the UI is
very similar to wake locks in principle
they are very similar so you have
dedicated tab for excessive wake up's
and you also have a nice program to see
how frequently they are being filed on
each tab on each device and you can also
see in the similarly to the wake look
actually let me go back here similar to
the wake load you can see the name of
the of the wakeup in this case in the
list and similar to the wake lock in
order to avoid leaking personally
identifiable information you should use
standard names so that you can get many
reports in case you have troubles and
you can see them on the console ok so be
very mindful also when you see wake up's
one wait of update wake up's is to use
again libraries that are designed to
play more nicely with the device and
this is the example that I was
mentioning earlier for example using the
firebase job dispatcher why is this nice
because here you can decide many
conditions so it actually saves you a
lot of time and it allows you to
personalize more the behavior that you
want
devices to use in this case you can see
how I'm choosing to trigger a given
service is you consider my job service
class every 30 minutes and repeatedly
but with certain constraint you can see
that they are that they constrain self
when the device is charging because
maybe this operation after all either
needed to do it as frequently I can wait
to run till Daile until the user is
charging the device and also only run a
meter and later this probably doesn't
save battery per se but we you know
better probably done than the many
others how this can be important for the
user okay that the user has control over
this and back to George to talk about
render times thank you thank you all
right guys as a designer this topic is
very close to my heart rendering time
and smooth and silky experience of your
users in your office you know you you
can admit it just great if you're doing
what's fine but sometimes render times
can drops and this is the last bit
behavior we're going to talk today so
render time reflects how long it takes
for frame to be displayed on a device
screen also at a time impacts user
perception of your performance
applications are rendered at 60 frames
per second this is based on the maximum
display refresh rate on a hardware level
that breaks down to 60 milliseconds per
frame in order for your app to appear
smooth and silky for users each frame is
to render in less than 16 milliseconds
but what happens if your app is not
rendering within this time restraint in
in in a time larger than 16 milliseconds
even if it's only one millisecond up 70
milliseconds is going to be dropped as
long as a famous dropped your user will
and yourself you know yourself when you
use ups you will kind of experience a
staggering jerky experience of the app
so you should keep the percentage of the
frames taking longer than 60
milliseconds very low second event that
may occur is multiple frames are dropped
then users begin to actually perceive
you up as unresponsive we can found the
threshold of 700 milliseconds where the
user thing the application is
unresponsive and they feel frustrated
you should aim to have 0/0 frames taking
700 milliseconds to render so we
identified these three metrics as a slow
rendering and frozen frames so we will
flag you up with bei behavior if a
significant number of users either
experience 50% of frames with a render
time greater than 50 milliseconds or
they experienced at least one frame that
is rendered in time greater than 700
milliseconds so in the android vitals
does word very similar for the battery
and the stability we have full rendering
and frozen frame stops where you can
actually analyze this bit behavior so
just like the way clock dashboard you
can see the distribution of rendering
times so you can see how render times
vary across sessions the vitals does
what also shows some metrics that you
can use to diagnose a slow render time
those are those on the bottom in this
scorecard for example the high
percentage of slow UI thread here
indicates that the app may be doing too
much processing in the UI thread a
problem that can be solved by moving
disk i/o or network connectivity are in
the background thread but this starts
only pointing to the root of the cows to
really nail down where the problem is to
find the smoking gun you should do a
deep dive so you can do that for
rendering by using the frame matrix API
introduced in the version 26 of the
support library by estimating this into
your u activity
then as a step to you can send the
signals from the API to your servers so
you can analyze to find which flows are
taking longest surrender once you find
these flows go back to your device and
with Android 3.0 you can track trace
repeating these flows and actually
understanding in the inter trace what's
happening what operations are going on
in a while these frames are rendering so
that's how you can find the problem and
fix it today we covered a lot there are
many more aspects to that effect that
performance than the three performance
areas that we mentioned but in the
following days and quarters we are
working hard on introducing more and
more performance areas so keep an eye on
the Play console so you can make your
apps even better so finally on top of
the play kaizo tools 5s also introduced
a new tool that you can exactly give a
bunch of cool functionality so not only
you can have network connectivity
performance but you can also dip dive
with your own events and have even
better understanding of your performance
so time to recap we are coming to the
end of our talk so today we talk about
our performance and how much it matters
if you want to achieve a stellar
operating in the store and maximize
maximize your user retention we
introduced the Android battles program
and the notion of bad behaviors that did
our habits that when present have a
significant and lasting impact on device
performance and user experience I'm
going to read this we focus on focus on
the crush rate in our slow rendering
photo frames a stack way clocks and
excessive wake-ups
this example is amplified the three main
performance
is stability battery and rendering then
we introduce a set of tools in the
androids vitals does what in a play
console the new performance tracking
tools for Android 3.0 and a set of api's
like the frame tracker from the Android
API so guys finally I want to close this
I'm going to leave that by building your
app to be excellent and saving battery
life and have a great user experience
you may actually save user lives with
two billion Android users and I believe
India is very strong I knew in the
Android usage you can just you know help
users to have a battery where they need
to make that emergency call I'm nauseous
is 911 a different emergency code yeah
exactly so if you all develop you know
apps that performs better we can save
users slice so you can catch us in the
way causal consultation boot later thank
you so much for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>