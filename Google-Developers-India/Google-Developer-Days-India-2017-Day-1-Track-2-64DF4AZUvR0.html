<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Google Developer Days India 2017 - Day 1 (Track 2) | Coder Coacher - Coaching Coders</title><meta content="Google Developer Days India 2017 - Day 1 (Track 2) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Developers-India/">Google Developers India</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Google Developer Days India 2017 - Day 1 (Track 2)</b></h2><h5 class="post__date">2017-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/64DF4AZUvR0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">
        KAZ SATO: Hi, thank you
for taking your time more my 
session on Real-world Machine 
Learning. Attending the events 
like this. Speaking about 
products and technologies. I've 
been working at Google for over 
seven years. Working for the 
Google Cloud
 team. Before we dive deeper 
into the products from Google, 
I'd like to discuss what are the
 differences between AI, Machine
 Learning and I network. There's
 no scientific definition. Some 
technology or science to think 
smart or make 
this smarter. During the 
picture. Yeah. And there has 
been many approaches
 to realize to AI, and one of 
them is machine learning. 
Usually, if you want to build a 
new IT system, you have to hire 
programmers to write a
 program. 
Instead, now, you can use data 
instead of human programmer to 
program your computer so you can
 put more and more data into the
 computer so the computer 
somehow defines the way to solve
 the problem. There has been so 
many different algorithms, and 
one of them is the Neural 
Network. And more and more 
layers.
 And we have been seeing a 
breakthrough has been happening 
in the networks. That's why 
Google has been spending so much
 amount of resources and 
investment in the Neural 
Network. Let's take a look at 
how Neural Network can solve a 
problem by using this fruit 
problem. If you have a customer 
and imagine that you are a 
programmer for the customer, and
 your customer asked you to 
classify these fruits as an 
apple or an orange.
What kind of program called? 
Java, Python? Anything? Maybe 
just wait to look tat the
 at the color of pixels. If it's
 orange, must be orange. But 
your customer comes up to you, 
comes to you, again, and asks 
you, so in the production 
system, the image would be like 
this. What kind of program to 
classify these as an apple and 
orange? In this case, you have 
to look at the shape or patterns
 or texture of the images. 
    And then, your customer 
comes to you, again, and asks if
 you can do that, the apples and
 oranges, maybe you can do 
classify on these images, too. 
Can you
 do that? This looks like mops 
or broom or something. But if 
you're carefully looking at some
 of these images, there are some
 sheep dogs. You know, and the 
images at the top left were 
images at the right bottom, they
 are not mops, they are dogs. 
How do you classify these 
images? 
    Actually, by using Cloud 
Vision API, you can get high 
accuracy of these images. 
    In algorithms, it's almost 
impossible to get 100% positive 
accuracy. The accuracy something
 like 70%, 80%, 90%, but it 
cannot be 100% positive in most 
cases. But still, Cloud Vision 
API does a decent job of 
classifying these images as a 
dog or a mop. 
    And how does it do that? How
 does the network work to 
classify the images or any kind 
of data? Actually, your network 
is not dedicated for image 
classification, it's just a 
function. A function in 
programming or mathematics. You 
get any kind of data to Neural
 Network to Neural Network to 
solve your problem. 
    For example, you can put 
images of cats and dogs. You can
 train the function to CLAGS
 my classify the images of cat 
or dog. And you can replace them
 with any other datas you want. 
You have a database or the 
customer transaction data from 
the e-commerce website. You can 
try the customer transactions 
into a bunch of numbers called a
 vector or matrix and use Neural
 Networks to classify customers 
who are premium or what 
customers would be spamming or 
cheating customers or the 
spammers. That could be the one 
example of the Neural Network. 
Let's see how your network can 
solve your problem with the 
demonstration video. 
    Let's take a look at the 
video. This is a demonstration 
called TensorFlow Playground. 
You can build the Neural Network
 inside the browser. Anyone can 
Google, TensorFlow Playground. 
Anyone can play with it. You're 
seeing the Neural Network can 
try to wait to classify the data
 points of the space as an 
orange spiral or blue spiral. 
    In this case, you don't have
 to write any program code like 
a java code. Instead, what you 
have to do is put more and more 
data to the Neural Network. It's
 twice defined, what is the best
 way to classify this data as an
 orange spiral or blue spiral? 
    If you spend, like, a few 
minutes, one or two minutes, it 
could be fully trained so it can
 classify the data points into 
one of the spirals. Just like we
 do by using human instinct. 
See?
    And it can extend this 
technology to solve many other 
kind of problems, such as image 
recognition. For example, if you
 have a handwritten images, 
handwritten text images, 28 by 
28 pixel images, you can flatten
 the pixel data into a single 
vector with 
784 data. You can put those data
 into the Neural Network 
directory. This is not the 
network -- this is a 
single-layer neural Network. 
Still, you can get a decent 
recognition accuracy, such as 
the 80% or 90%. 
    So if you're trying the 
Neural Network, it can be 
trained to determine which 
pixels you have to look up to 
determine whether the images 
should be in digit 8 or digit 6 
or digit 0. And if you have more
 and more layers between input
put data and output data, you 
can get much, much higher. And 
sometimes, you can get the 
higher accuracy than humans. 
    So, for example, in this 
case, you have the tens or 
dozens of the hidden layers 
between input data and output 
data so each is that hidden 
layers can be trained to 
recognize simple patterns, such 
as as you can see the patterns 
on the vectors or the complex 
textures or colors. Or part of 
objects it knows, like a dog or 
the wheel in an automobile. 
    Finally, you can have the 
new ones that can recognize a 
whole object like an automobile 
or wedding party. That is a 
deeper network. Over 100 
production services and 
projects, including Google 
Search, Android Maps and Gmail. 
If you are using Google Search, 
that means deep learning from 
Google every day, because in 
2015, we have introduced one 
brain to determining the search 
results. Which one should be the
 first? Which one should be the 
second? 
    And now, we are trying to 
externalize the power of Machine
 Learning on Google Cloud. From 
the Machine Learning Services. 
The first part of the product is
 APIs. That doesn't require any 
Machine Learning expertise or 
knowledge. You can just upload 
your own images or your data to 
the API so you'll be getting the
 result in seconds. 
    So let's take a look at the 
few example of those APIs. 
First, we'd like to show a video
 of the Vision API 
demonstration.
In this demonstration, you can 
go to the product page of the 
Vision API. Anyone can drop your
 own images without spending any
 money. It's available free. If 
you drop the sheep dog images to
 the API, you can get the result
 like dog or dog like mammal, 
mammal. Yep. 
    So let's go to the next 
video. Yeah. We have another 
video. This is an example of the
 demonstration of Speech 
API and if you press bottom and 
speak to the microphone, then, 
it can start recognizing your 
voice in realtime at high 
accuracy. Just like the other 
devices. 
    And once you've got the 
result, you can copy and paste 
result into another API,
 which is Natural Language API. 
That allows you analysis on the 
text, such as the HG analysis. 
So by pressing the button, it 
can get the result with the SG 
analysis, so it can extract the 
analysis or put up things, the 
company name from the result, or
 anything positive or negative. 
Or syntax analysis, which is the
 part of the text of each word. 
    You don't have to hire 
expensive process researchers or
 data scientists, you can just 
use the API. 
    So that was Machine Learning
 API that requires no Machine 
Learning expertise, you can just
 start using APIs from today. 
But, sometimes, you want to 
customize the Machine Learning 
or Neural Network models by 
using your own data, especially 
for designing your business 
model. 
    That is -- to Seoul that 
solve that problem, we have 
TensorFlow. TensorFlow is the 
Machine Learning development 
tool used inside Google for 
developing any new machine 
learning or API services. We 
have OpenSource, by the Google 
team. TensorFlow is the 
scalability and probability. You
 can start trying the product, 
TensorFlow by using your own Mac
 or Windows. And the
 TensorFlow has stages. That 
could be one of Mac or your 
Windows. You will find that 
between the network model or 
training the model can take so 
much computing power, so long 
time. If you want to bring a 
solution into production 
quality. That's where you want 
to use GPU from Nvidia or dozens
 of GPUs to do the training on 
the production. You don't have 
to change your code in the 
TensorFlow. Because TensorFlow 
is Scalable. You can just hop it
 on to the Cloud. Or we can 
provide the tens or hundreds of 
GPUs. 
    So it's Scalable. And once 
you have finished training your 
model, you can copy the model. 
It's just tens of megabytes of 
data, or hundreds of megabytes 
of data. You can copy that data,
 the model to the smaller 
devices such as mobile phones or
 MP3 systems. Where you can run 
TensorFlow, specifically 
TensorFlow Lite to run your 
model to solve your problem with
 smartphones or the systems in 
your factories or any 
environment where you cannot get
 the internet connection. 
    So the benefits of 
TensorFlow with the popularity 
of the OpenSource industry, that
 is the most popular framework 
for deep plannings in the world.
And the many companies, 
enterprises, and start-ups and 
the individuals are starting to 
use TensorFlow to build PLCs or 
production systems. Such as 
Airbus, Intel, IBM, those 
companies are really deploying 
TensorFlow in their systems.

been using TensorFlow. I have 
taken these pictures by myself 
about 1 1/2  years ago. And 
there are three farmers in the 
picture. The one guy in the 
middle, he has parents who have 
been doing cucumber farming for 
a long time. And he started 
helping cucumber farming three 
years ago, and he found out the 
most time consuming task for 
cucumber farmers is classifying 
the cucumbers in nine different 
classes at high accuracy. His 
mother spent eight hours a day 
just classifying ccucumbers. And
 he wanted to help them. 
    He downloaded TensorFlow and
 did his own TensorFlow base for
 cucumber sorter. He can put the
 cucumber on the plate. That way
 TensorFlow can classify the 
cucumber into nine different 
classes. 
    And he build this by himself
 and it cost only $1,500. So you
 don't have to, you know, pay 
millions of dollars to the 
system's integrator to build 
this high-quality, high-accuracy
 system. You can have an 
individual, you know,
 farmer planning for solving 
their problems. 
    So that is the blooming of 
the TensorFlow community and 
system right now we are having. 
But if you want to bring the 
technology of TensorFlow into 
production for solving your own 
enterprise problem, there are 
problems you'll be seeing. 
    There are three problems you
 have to have the large Dataset 
to train your network model. 
That is one of the downside of 
using the planning. It requires 
many dataset. And you have to 
build a good model of 
TensorFlow. Maybe sometimes you 
have to hire data scientists to 
do that. But the largest problem
 is the lots of competition. You
 need to buy more and more GPUs 
to do the largest training to 
bring the technology into 
production. 
    So that is a reason why we 
provide Google Cloud as a 
solution for the data scientists
 and Machine Learning users. We 
call our data center as a 
computer. That means, it's not 
just a
 bunch in a building. It's a 
massive compile of computers. 
The data networks. So any 
software engineers at Google can
 run his or her program called 
applications or hundreds of 
machines. It's just one line
 of the command. 
    What is the reason why 
Google Cloud has differentiated 
from the
 other cloud? Part of the result
 when you learn the TensorFlow 
on the large scale on Google 
Cloud. The result is much, much 
shorter training tile, like 40 
times faster or sometimes 300 
times faster. 
Right now, if you are trying to
 use the deep learnings, you 
have to spend a few days or few 
weeks to train. But for Google 
engineers, you have to only 
spend tens of minutes, like a 
lunchtime. If you go to lunch, 
going back to your office, has 
finished. That's the most 
important factor of the biggest 
reason why Google has been so 
successful on deploying 
technology into production. 
    We even designed our own
 customized ASIC. This is not a 
CPU or GPU. It is a design our 
own processor just for running 
TensorFlow or massive amount, a 
matrix operations between the 
vectors. 
    And now externalizing all of
 the power of the cloud, 
TensorFlow as a product called 
ML Engine. You don't have to 
take care of of the GPU expenses
 by yourself. All you have to do
 is try TensorFlow and apply 
your code to the ML Engine data 
and that's it. And Google takes 
care
 of the management, everything. 
And we try the opportunity so 
that allows you to shorten the 
training time much, much 
shorter. 
    So let's take a look at the 
Real-world example of customers 
already using TensorFlow.
 The company like Airbus, 
AXA, Coca-Cola, they have been 
using TensorFlow for solving 
their real problems. This is a 
project called Global Fishing 
Watch that is a project for 
preventing overfishing. And the 
project is collecting over 
200,000 of the vessels and GPS 
positions of 200,000 vessels in 
realtime. 
They are collecting all of the 
GPS positions, stored on Google 
Cloud and uses the Cloud data 
flow to do the batch processing,
 and then uses the TensorFlow 
and ML Engine to separate the 
movements of the vessels or the 
ships in the oceans. 
    So what do you get? You can 
understand how many ships are 
actually doing the fishing in 
each ocean by looking at the 
movement of the GPS positions. 
Is it doing tawl fishing, long 
line fishing? 
    This is another customer for
 using TensorFlow for Seouling
ing solving their problem. That 
is kewpie. They were trying to 
find a bad potato piece, the 
black color or the bad shape. 
But because they're using the 
very high-quality ingredients, 
it's really hard -- it's really 
hard for the existing image 
system to find out the bad 
potato. They have been using 
human workers to watch for
 all of the potatoes all day. 
But when they tried TensorFlow, 
then they were able to get much,
 much higher on the existing 
solutions. You can hear the
 sound. 
    So you heard the sound. It 
sounds like Super Mario 
Brothers, but it's not. That 
ring sound tells you the 
position of the bad potato cube 
coming on the conveyer. They 
don't have to watch out all the 
day. You have to listen to the 
sound, pick up the bad potatoes 
whenever you hear the sound. 
It's much, much like the test. 
They were able to reduce the 
cost of the human operators 
significantly. 
    Lastly, I'd like to show the
 AUCNET case. AUCNET is the 
largest real-time car auction 
provider in Japan. They're 
handling over 5 million cars 
every year. But the largest 
challenge for the users is the 
classifying the images for each 
car. 
    For every car, you want to 
enter into the auction, you have
 to take 20 different images 
from front or side or back or 
the part of the car, like,
 wheels or tires and put the 
tags or labels on each images. 
And so, that takes over 15 
minutes or 20 minutes by human 
pop
ulateres. 
They try to use TensorFlow for 
building the customized 
classifier. So they have used 
the transport running techniques
 so they're able to reduce the 
number of photographs or images 
tutoring the model for each car 
model. 
    You only have to have 200 
images for each car model to 
classify the cars at high 
accuracy. And they were able to 
use the ML Engine to speed up 
the training time significantly.
They were able to get the 86 
times faster training time. 
    So the end result for the 
business is much, much shorter 
operating time. They were able 
to shorten the operation time 
and enter the car into the 
auction from 15 minutes to 3 
minutes. Let's take a look at 
the video. 
    This is the actual systems. 
So you can upload 20 different 
images for a car, from the 
front, side, tires or parts of 
the cars and then the system 
that classifies the images. 
    An important point of this 
project is the AUCNET don't have
 expertise on machine learning 
when they started the project. 
THEMP able to find the best 
partner from TensorFlow in 
Japan. They spent three or four 
weeks expert in the community. 
They were able to learn how to 
bid production for the system. 
And now, this system is deployed
 in the production environment 
from last December, only by the 
engineers in the AUCNET. The 
subsidiary. 
    So a summary, we provide two
 different solutions. The first 
solution is the ML APIs, you can
 start using those APIs from now
 because it doesn't require any 
Machine Learning expertise, just
 follow images. 
    Another solution is 
TensorFlow, and the various 
class of products that it 
provides and solutions to build 
a customized machine learning
 solutions.  TensorFlow works 
with the Cloud Data
 Flow, and of course, we can 
continue to use the industry 
standard, 
too. 
    So that's it. Thank you
 so much. 
    [ Applause ]
   DAN MCGRATH: Hey, everyone, 
I'm Dan McGrath, I'm a product 
manager on the Google Cloud 
Team. And I'm going to talk to 
you today about a new product 
called Cloud Firestore. 
As a way of introducing Google's
 newest database, I want to give
 you an overview of building 
Scalable Apps with Firebase. 
Before we get started, as people
 are walking in, I want to get 
to know the audience a little 
bit better. 
    By way of showing hands, how
 many people have used the 
Firebase Realtime
 Database before? How many 
people have used Cloud Functions
 already? 
Not bad. And because this is 
about Cloud Firestore, how many 
people have already taken a look
 at Cloud Firestore? Nice, 
that's more than I
 expected. 
    So for the talk today, I'm 
going to give you an overview of
 Cloud Firestore, tell you what 
it's about, what sort of 
features and functionalities it 
gives you. And then, I'm going 
to dive into an example. And I'm
 going to go through the code in
 that example to show you how to
 build an application in 
practice. 
    And then, once I've done 
that, I'll show you a bit more 
code on how you can use 
libraries and frameworks to do a
 bit more. 
    So Cloud Firestore was 
inspired by the experience of 
building a Realtime Database. 
And the community feedback we've
 got over the years. So bear 
with me as I step back a little 
bit and take a little bit of a 
walk on the history of the 
journey that led us to building 
this new system.

2012, it introduced a 
fundamentally new way of 
building apps. The Firebase 
Realtime Database solves many of
 the hard problems dealing with
 app data. 
    Specifically, it does three 
things very well that makes our 
lives easier as developers. 
First, it allows us to access 
data directly from mobile 
clients and web apps. Second, it
 allows us to access the 
changing data in realtime. And 
third, it allows us to build 
offline-capable apps very 
easily. 
    Cloud Firestore does these 
three fundamental things, as 
well. And I'll dive into why I 
think it's so important in a 
minute. 
    At the heart of the Realtime
 Database, it does one thing 
incredibly well, syncing app 
state in realtime with low 
latency. 
    Over the years, as adoption 
of the Realtime Database grew, 
usage patterns evolved and 
expanded. And it's been used by 
increasingly larger 
applications. When stretching 
the Realtime Database outside of
 its core purpose, we run into 
two issues. First, is data 
modelling and querying.
In particular, you can't query 
over multiple properties at the 
same time. Getting around this 
involves duplicating data or 
doing client side filtering. 
    The second, is the Realtime 
Database doesn't scale 
automatically. Beyond 100,000 
concurrent users, which means 
about tens of millions of daily 
active users, you have to 
manually shard across multiple 
databases. Granted, that's a 
pretty high bar. But we wanted 
to do even better. Wouldn't it 
be great if you could build an 
app that goes from zero to a 
very large scale without having 
to change a single line of code?
    This is why we built Cloud 
Firestore. It's a
 NoSQL Database we built 
specifically for web and mobile 
applications. Cloud Firestore 
builds what users love most 
about the Realtime Database and 
combines it with Google Cloud's 
powerful infrastructure.
    It's flexible to build all 
types of apps and Scalable to 
grow to any size. For me, this 
is real exciting. Prior to 
Google, I spent many years 
building complex systems and 
tackled problems of moving data 
between mobile devices and the 
backend database. 
    Now, this is greatly 
simplified, but often, I would 
start with something similar to 
this. We have mobile and web 
clients that talk to a middle 
tier. The middle tier is made up
 of a web server handling your 
static content. And then, either
 as part of that or as a 
separate system, you have an 
application server that handles 
all of your business logic, 
authentication and talks to the 
database system in the back-end.

infrastructure you need to 
manage in terms of deploying 
changes to it, sizing the 
machines, upgrading the 
operating system and various 
components like the web server 
and database. 
    And at some point, if your 
app needs to grow beyond a 
single database, you start 
adding things like replication 
and multiple database servers, 
which is another piece of 
infrastructure you need to spend
 your time managing. 
    Now you're continuing to 
grow, you start thinking about 
disaster recovery and standby 
systems in a different location.
Maybe you've already tackled 
this. By this time, you've got 
some pretty hefty 
infrastructure. You have people 
working on this, you're spending
 time on it. And frankly, it's 
not something that brings 
immediate value to our users. 
You're not going to do a press 
release or a blog post about 
your new back-end infrastructure
 and how much value it adds. 
    The reason I love Firebase 
and I imagine many of you do, as
 well, is it takes care of all 
this for you. 
    And now with Cloud Firestore
 complete in this picture to 
simplify that hefty 
infrastructure, you can do all 
of this with a couple of 
incredibly powerful services 
that you can just drop an SDK 
into your app to handle. 
    And even though it's really 
simple to use, you can build 
some incredibly complex systems 
with it. You can use things like
 Cloud Function to integrate 
into the full cape
 capabilities of Google Cloud. 
    Cloud Firestore was a 
database I could only dream 
about having available. It would
 have saved me many months of 
effort. Months I could have been
 implementing features we wanted
 rather than being bogged down 
in designing and implementing 
the basic building blocks. 
    Now, I'm going to dive into 
some of the details that make 
Cloud Firestore so special. 
Cloud Firestore is fully 
supported in the Firebase SDKs. 
This means, it's available on 
the web, on iOS, Android, access
 data directly from the clients,
 removing the middle tier for 
access control, data validation 
and delivery of data between 
different devices. 
    And all this worked 
seamlessly because of Firebase 
Authentication and security 
rules that let us have control 
to who has access to read and 
write the data. 
    Security rules is a 
declarative configuration 
language that handles data 
authorization and validation. 
You can also extend your 
application on the service side 
with Cloud Functions, service 
side code can be very helpful 
for making fair decisions for 
our users or including a secret 
source algorithm you don't want 
to have on untrusted client 
devices. 
    We can also coordinate 
multi-party interactions much 
more easier on the service side.
Or do things like autonomous 
agents and bots. 
    Now, being powered by Google
 Cloud's Scalable powerful 
infrastructure, you've got 
access to a globally distributed
 database that scales 
automatically with usage. If 
you're not using it, it doesn't 
charge you anything. The moment 
you get traffic, it's there and 
available for you. 
    Now, it's a serverless 
system. That means, Google is 
taking care of all of that for 
you. Everything from capacity 
planning, upgrades and 
maintenance, we do all of that 
with no scheduled down time. 
It's always up and available. 
    And speaking of that, it's 
very reliable and available. It 
is a multi-region replication, 
keeps the app and user data 
safe, even in the face of 
natural disasters. It's 
replicated across regions in 
case of that disaster without 
any configuration or management 
by you. 
    That's right. Cloud 
Firestore brings you a full 
advantage, 
multi-region, database just like
 you've had in Cloud Datastore 
for the last several years. And 
like Cloud Spanner we brought 
you last year. 
    It's now expected that we 
have apps that work across both 
mobile and web. Even when we 
never plan to sync across 
multiple devices, there's a 
growing expectation that our 
apps will just work. 
    Cloud Firestore makes it 
easy for customers to transition
 between devices or even use 
them at the same time. 
    The system is made easier by
 data-binding between client and
 server. Writing an app this way
 makes it easier to make appload
 seem faster. You can display 
the minimum amount of data when 
you load your page. And then, 
render the new information as it
 becomes available. 
    It's becoming 
increasingly often for people to
 expect our apps to work 
offline. As many of you know, 
this problem is very challenging
 because it requires building 
complex sync and conflict 
resolution logic. 
    With Cloud Firestore, 
building offline-ready apps is 
natively supported. The SDK 
includes a mobile database that 
supports and handles conflict 
resolution. Having a local 
database means our apps function
 smoothly even when it loses 
connectivity or the 
connectivity's flakey. 
    This offline mode is 
available on all platforms, 
including the web. So you have a
 consistent
 experience. 
    Cloud Firestore also lets 
our structure, lets us structure
 data as collections and 
documents. This makes queries 
much easier to do. We store 
related data together in a 
hierarchy. We base this model on
 what we learned from the
 Realtime Database Developers. 
Supporting the most common use 
patterns with what people used 
intuitively. 
    So far, this reduces the 
learning curve and gives a data 
model that's designed to scale. 
Query performance is based on 
the size of the result set. 
Which means, you don't have to 
rearchitect your application or 
your data model as your app 
grows from gigabytes to 
petabytes. So here, I've got a 
screen shot of the data  Data 
Console UI. I've got a
 single item, and in the second 
column, I've got documents with 
a unique ID. When I click on the
 documents, I display all of the
 fields that are in there. 
    Now, in the items 
collection, I actually have 
millions of documents, and this 
can easily go to many millions 
and even billions of documents 
and it will still handle it. 
    When you look at the 
document, you can think of this 
as JASON-like data. So let's see
 what this particular dataset 
looks like rendered on a page. 
    So here, I'm showing Cloud 
Firestore action and diving to 
the code behind this. And 
talking about some of the core 
features and functionality. 
    We build an offline capable 
web app backed by Firestore. It 
displays news stories where the 
community can upload stories and
 add comments. 
    It's displaying top-voted 
news stories over the last 
couple of days and it's done 
with just HTML and java script.

hosting, but the news stories, 
the comments and the metadata 
about them is stored in Cloud 
Firestore. 
    And we get them directly 
from the database without that 
middle tier. There are no other 
back-ends involved. 
    And we store all of those 
documents in this collection I 
showed just before. Each news 
story is its own document and it
 has a bunch of metadata such as
 the score, the time it was 
submitted, who the submitter 
was. 
    Let's have a look at the 
code. Going to go through this 
line-by-line. The great thing 
about this app we made, we spent
 a lot of time figuring the HTML
 and CSS, but the integration 
with Firestore was really 
simple. The entire Firestore 
code is on the single slide. 
    So in the first line, I'm 
just assigning the result to a 
variable called unsubscribe, 
which I can use later when I 
want to stop listening to live 
updates. And the second line is 
just grabbing a connection to 
the database or creating it, if 
we don't already have it. And 
then telling it I'm interested 
in all of the documents in 
items. And I want them ordered 
by a field I've called &quot;top&quot; 
which gives me the ranking on 
the page. And because I'm only 
displaying the front page, I'm 
only interested in the top 30 
stories. 
    The real magic happens on 
the next line what I call &quot;on
&quot;onSnapshot,&quot; sends a query to 
the server, which grabs the 
initial results and sends it 
back and gives it to me as data
dataSnapshot. And to my display 
function, display stories, all 
I'm doing is taking that list of
 documents and rendering that 
page that you can see. 
    We believe one of the most 
important features in Cloud 
Firestore is the realtime 
nature. So onSnapshot doesn't 
get called once. It 
automatically gets called 
anytime the data changes on the 
server. If a story drops out of 
the top 30, new stories come in.
Even if you change the title of 
the story, it will call it, 
again, give you that updated 
data so you can really render 
that and just make the app 
actually live with the data. You
 don't have to worry about 
sorting out all of that stuff. 
    We can even generate other 
pages quite simply by changing 
that code a little bit. So here 
is how we would display the use 
of profile page where I want to 
see the latest stories submitted
 by myself. 
    I just add a where clause, 
and it handles it for me. I can 
even chain multiple &quot;where&quot; 
clauses together. In this 
instance, I'm not just filtering
 by the submitter, but I'm also 
limiting the story submitted to 
within just the last year. 
    We do this by attaching the 
other &quot;where&quot; clause and only 
the queries continue to work in 
realtime. So keeping that last 
chunk of code in mind, we're 
going to talk about Scalable 
Queries a little bit. As I said 
before, the performance is 
related to the size of the 
result set, not the dataset 
size. When we look at our 
database, it could have billions
 of documents in it. And then, I
 tell it, I'm interested in just
 a collection, which is millions
 of documents. I, then, restrict
 it by myself as the submitter. 
That's hundreds of documents. 
    I then, say within the last 
year, we're now down to five 
documents. The query time, the 
performance of it, will be 
exactly the same from my 
database that has billions of 
documents to my database that 
only has those five documents. 
    And so, that's why it's 
important to think about how you
 structure your data and allow 
you to strict it down to just 
the data you're interested in. 
We do this by making indexing 
really easy. We actually 
automatically index all of the 
fields without any action. And 
all of our queries are served 
using the indexes. 
    The more complex queries, 
you create composite indexes for
 the fields you care about. And 
even that, I'll show in a 
minute, we make simple for you 
to do. We have really good 
documentation on how to 
structure your data and tips 
about doing it in our 
documentation. So I really 
suggest checking that out. 
    So here's an example of what
 happens if you try to do a 
query on multiple fields when 
you don't have one of those 
composite indexes. The query 
follows with an arrow. As you 
can see here, the error message 
itself has a link to the console
 that will allow you to do a 
single click. 
    When I click on that link or
 follow it in a browser, it 
brings you to the exact spot in 
the console with all of the 
information to build the index 
prefilled For you. It's a single
 click, and off you go. This 
makes developing and it
erating easy and fast. 
    When we're talking about 
offline Cloud Firestore supports
 in some Android, iOS and web, 
we make it so simple it's 
literally just a configuration 
when you initialize the database
 and say, I want offline 
persistence. 
    When we're doing it, we pass
 a little bit of metadata so you
 can know if it's been submitted
 locally or submitted to the 
server. 
    The newsstories are all 
managed through Cloud Firestore,
 which moves, we can cache the 
data and queries will continue 
to work even when we're offline.
But it gets  better. When you're
 offline, not only is -- sorry. 
When you're offline, when you 
create a new item or submit a 
new story, it'll show up in your
 queries in the local device. 
    And when you reconnect or 
get network connection, again, 
will automatically sync it down 
for you. That means, when you're
 offline and people make 
changes, update titles, you can 
close your app, close the 
browser down, come back to the 
page and all of the rights are 
persisted for you. 
    One other little bit of 
magic we can do, just to give 
you an example of how you can 
string all of these things 
together is I can deploy this 
very small Cloud Function 
snippet. By telling it we're 
interested in Firestore event. 
And specifically, I want to 
listen to all events when I 
create a new document in that 
collection called &quot;items.&quot; When 
I detect a new document being 
created, I grab the data from 
that document, convert it to low
 er case, check for the word 
Firebase, if it exists, I take 
that text and post it to our 
Slack channel. That is literally
 all of the code you need to 
send any document, any item 
about Firebase to a Slack 
channel. 
    And to show you I'm not 
cheating, when I look at the 
post to Slack, it doesn't have 
anything to do with Firestore 
here. All I'm doing is a rest 
API call to Slack to give it the
 information. 
    Cloud Functions itself is an
 incredibly powerful way to do 
that service side glue to put 
everything together. Supported 
in Cloud Firestore, the Realtime
 Database, Cloud Storage, 
Authentication, Kurrasch
  Crashanalytics.

quick run through of an example 
on how you can string all of 
that together. It doesn't seem 
like much because, honestly, 
that is how simple it is to hook
 this into your system. I want 
to spend a little bit now 
talking about frameworks and 
libraries. 
    I just showed you java 
script examples. The exact same 
samples work on Android and iOS,
 as well. If you're doing server
 side development in more 
traditional VMs, we also have 
Python, Java, GO and Mode use, 
JS libraries you can as well. 
I want to talk about meeting you
 where your app is. Perhaps 
you're a developer. Our 
community has done
 an excellent job of providing 
plug-ins and 
 collection called and grabbing 
the most recent
 20 published articles. 
    Now,
 light wrapper, and it's a 
similar API. You should be able 
to jump between them very 
easily. 
    And the second one, I'm
 has a use looking at an 
individual document that links 
your page directly to the data 
in Cloud Firestore itself. 
    Perhaps, you're a React 
native developer. The same thing
 applies using React Native 
Firebase. You can do the same 
thing. And you can grab a 
reference to the collection you 
care about and do lots of cool 
things with it. You're adding a 
new document as simple as doing 
ref.add. When you mount a 
component, you can do the same 
onSnapshot magic I mentioned and
 tell it what method to call 
whenever data changes. 
    And mentioned the 
community's been busy, it's not 
just React Native, not just 
Angular, perhaps VR work and 
you're using A-Frame. Maybe 
you're a Backbone developer or 
using Flutter. All of these 
integrate with Cloud Firestore 
today. 
    So with that, I want to 
thank you for coming out here. I
 hope this has inspired you to 
go out, try Cloud Firestore and 
see what incredible things you 
can build with it. If you have 
any questions, you can meet me 
at the office hours area behind 
the main hall. I'll be in the 
Firebase session. You can reach 
out on twitter #CloudFirestore 
or in our group where we've got 
engineers keen to hear your 
feedback and to see how you're 
using it. Check out Firebase 
Talk. Thank you very much. 
    [ Applause ]
  BEN MORSS: Hello. Good 
afternoon. My name is Ben Morss,
 my job is to help the web be 
beautiful and easy for both 
users and developers. And before
 I was at Google, I worked on 
websites for companies like the 
&quot;New York Times,&quot; AOL, places 
like that. Before that, I was a 
musician. I took lessons for a 
while. I'm here with my friend 
and colleague Raghu. 
   RAGHU SIMHA: Good afternoon, 
everybody, I'm a developer at 
Google, I work on AMP. And 
together with Ben, we're going 
to talk about building an 
e-commerce site with AMP. I 
thought I'd mention I, too, am a
 former bang  Bangalorean. 
 BEN MORSS: It's true. AMP as 
you know it accelerated mobile 
pages. Why would you want to 
build new pages in AMP? What's 
the point of this thing? Good 
question. . 
    It's mostly because today's 
mobile sites aren't what they 
could be in many cases. They've 
gotten much better than they 
were 5 years ago, six, Severin 
years ago, but they tend to be 
too slow and too complicated 
under the hood. The phone is a 
personal thing for people. 
People use their phones all the 
time for all kinds of purposes. 
And they expect everything on 
their phone to be good, whether 
it's a messaging app, they're 
watching videos, playing Candy 
Crush or using your website. 
They expect everything to be 
fast, responsive and beautiful 
and useful. And if your website 
isn't like that on Mobile, it 
will suffer. 
    You see over here some 
stats. More stats like this out 
there. One on the left is from a
 study that was done recently 
just taking data from sites that
 were opted into sharing their 
data with Google Analytics. And 
they found out if a site took 
longer than 3 seconds to load, 
more than half of users would 
just leave. Three seconds, which
 is not much time. 
    And other stats over here 
show most people who think a 
site is slow or doesn't work 
well won't come back. They're 
just gone forever. 
    And also, of course, 
conversions will drop if a site 
is slower, bounce rate gets 
worse. It's shows that people 
want their phone to work really 
well and work fast. And if it 
doesn't, they'll just think it's
 broken, it isn't good, and 
they'll just do something else. 
    And, in fact, many sites 
today load slowly, and I think I
 recently saw that 
three-quarters of mobile sites 
took ten seconds or longer to 
load over 3G, and also, they can
 be 
unresponsive. 
The Java script is still 
loading, parsing, and executing 
much slower on phones than on 
laptops. And so, people will tap
 on things and they don't do 
anything. 
    They assume it's broken, 
they'll do something else. And 
also, ads may kind of pop in 
there and displace content. So 
none of these
 things are good. 
    Not to sound negative, but 
people are all smart over here 
you know the latest technique 
for site performance, how to 
make things work quickly. But it
 takes a lot of work to do this.
It's not easy, and sites will 
keep on slowing down and require
 constant speeding up. 
    So for all of these reasons,
 we created AMP. The AMP Project
 is an OpenSource initiative 
with sites that are fast, 
beautiful and, also, can make 
money. 
    And it's fast and easy, not 
just for users, but also for 
you, the developers. 
    It's been popular. There's 
over 4 billion pages that are in
 production now that are AMP 
pages. Over a million domains 
are producing AMP pages. And 
every week, more than 50 million
 pages get produced. And now, 
Raghu will talk about what AMP 
is a little bit more. 
   RAGHU SIMHA:En thanks, Ben. 
So we've motivated the reason 
behind the existence of the AMP 
Project. As you might have 
heard, it stands for accelerated
 mobile pagesment but. But we're
 going to discover whether the 
mobile is restricted to mobile 
or if you can make beautiful 
experiences on desktop and 
mobile with AMP. Now that we've 
talked about motivation, let's 
dial into what AMP really is. 
    There are three core 
components to AMP as you can see
 on the screen behind me. AMP 
HMTL, AMP JS
. It consists of a web 
components library that provides
 a powerful and comprehensive 
set of building blocks with 
which you can make beautiful 
desktop and mobile sites that 
are fast, responsive and not 
only that beautiful, 
user friendly. AMP JS, that's 
the engine that drives AMP. It's
 a Java SKRICHT script engine 
and manages resource loading and
 implementing best practices to 
make sure your pages render 
really fast. And finally the AMP
 Cache. It fetches, caches and 
serves AMP pages and ensures 
that what you see on the screen 
is, in fact, as fresh as 
possible. 
    Now, for our intents and 
purposes, the AMP Cache is 
virtually invisible. That is, 
what you see when you load a 
page via the cache, there's a 
cache version in the background,
 the cache is updated. 
    Now, for pages that are 
uploaded frequently, or hit 
frequently, this is not a 
problem. The cache is virtually 
transparent. 
    But if you have a page not 
hit as frequently, there are 
APIs you can call that help you 
manually update this cache. 
    But AMP is designed for 
efficiency and speed. And it, 
therefore, must enforce some 
constraints. The first thing 
might surprise some of you. A 
valid AMP page may not contain 
any custom Java script. You 
heard me right. Most web pages 
today contain lots of java 
script. So what's the deal with 
this? 
    Well, most of the java 
script in a valid AMP page is 
contained inside the AMP run 
time. And you and your page use 
AMP web components library and 
use this Java script engine to 
write your page. 
    Second, you might ask, what 
about the AMP format? How does 
it relate to HTML? Well, the AMP
 format is a specialized subset 
of HTML. And it does contain 
several additional features, 
which you'll see about in the 
web components library. 
    And finally, there's a hard 
limit on the size of the CSS 
that can be associated with the 
AMP page. Now, in spite of these
 constraints, and I'm going to 
argue because of these 
constraints, the AMP run time 
lets you build mobile and 
desktop experiences that can 
delight your users while 
remaining high-performance. 
    Let's take a simple image. 
In regular HTML, you'd use an 
image tag. What do we do with 
AMP? Well, we use AMP Image. 
You're going to see a whole lot 
of examples with the amp -- in 
front of it. It's part of the 
HTML, web components library. 
The only thing to note here is 
by specifying the width and 
height of an
 image beforehand, it knows how 
to load a page. 
    We also introduce a layout 
attribute to most AMP 
components. And by saying it's a
 responsible AI element, the run
 time knows how to resize the 
pages. 
    Let's breeze through a 
couple more. If you want videos 
on your page, let's say a 
YouTube video, it's as simple as
 this little piece of HTML on 
the screen. Again, specify the 
width and the height, a 
responsive layout, and it's as 
simple as a few lines of code 
here. The Java script engine 
takes care of the rest. 
    You will see an example, and
 we're going to discuss how to 
build an e-commerce site later 
during this talk. And some of 
the things you will see can be 
done using the web components 
I'm going to show you now. The 
first example is AMP Carousel 
where you can swipe images left 
and right and have a carousel of
 images, articles, whatever. A 
side bar most complex websites 
need to have a menu and a way to
 get around the website. So AMP 
Sidebar lets you do that. 
    And finally, if you want to 
let people share pages from your
 website, AMP Social Share lets 
you do that easily with a few 
lines of code. 
    So what you saw just now 
were just a few of the building 
blocks that together formed the 
AMP web components library. But 
the library contains so much 
more functionality, like video 
players, social embeds, 
accordions that let you expand 
and collapse areas of the page, 
carousels, menus, special 
effects, and a whole host of 
things in addition to doing 
things like serving ads, user 
engagement. And now, Ben's going
 to talk you through a way of 
building e-commerce site with 
the Web Components Library. 
 BEN MORSS: As Raghu was saying,
 AMP has a lot of components 
built in. When AMP started out, 
it was made for publishers to 
use. So it was good for static 
pages, simple pages. But as he's
 been showing you over here, AMP
 has advanced since then. And 
I'm here to say AMP isn't just 
for publishers anymore. 
    It can be used to make all 
kinds of sites. As Raghu was 
saying, not just mobile 
experiences, but desktop, as 
well. Many, many kinds of 
scythes  sites are easier to 
make with AMP and a lot faster 
for users, hopefully, easier for
 you. 
    E-commerce is a complicated 
idea, so we're going to discuss,
 actually, how to build an 
e-commerce site with AMP. And 
that may show that all kinds of 
things can be done, including, 
of course, e-commerce. So going 
on, let's do it. 
    Here's a site over here. 
This is a bike shop we're going 
to build for you in the next 19 
minutes and 24 seconds. By the 
way, this bike shop already 
exists on AMPstart.com. We'll 
give you the URL later on. And 
the code examples are modelled 
after that site. 
    An e-commerce site, first of
 all, you need a home page, 
where a user can go there from 
search, Facebook, Twitter, 
whatever, and find your stuff 
and see what you are, look for 
things. 
    And then, I found something 
they're interested in, they 
might search around, use a 
category and menu and go to a 
product browse page where they 
can look at various products 
and, you know, see if they want 
to actually buy. 
    Next, they will actually 
click on a product, hopefully, 
if things all go well and go to 
a product details page where 
they can see the product, what 
it's like, what it costs, and so
 on. 
    If they like it, they might 
try to actually buy it. In which
 case, they'll go to the &quot;cart&quot; 
page. And the &quot;cart&quot; page shows 
what's in the cart, what they 
have. 
    And then, finally, the 
checkout, and then you guys get 
money. So let's go back to the 
beginning. The home page. The 
home page is not that 
complicated, usually, in most 
cases. And the things on this 
page over here can mostly be 
done using pretty standard 
static-type end components. For 
example, Images, you saw AMP 
Image, if you have a video, we 
have various components for 
embedding videos. If you want to
 have a little sliding image 
carousel showing products or 
specials, also possible, 
navigation of the menu. And the 
Sidebar gives you that. There it
 is on the
 top left. It's a burger menu in
 Germany, not a hamburger menu. 
Let's pass on that, though. 
Navigation isn't hard to do and 
offers highlights, mostly 
possible, using standard kinds 
of AMP components. I didn't 
include search here, yet. We'll 
get to that. 
    Let's go on to the next 
page, though. The product 
browsing page. So here, again, 
you can have these products over
 here loaded at static products.

feel like you want it to be 
dynamic. Maybe you want the 
 freshest product data. And 
maybe the cache doesn't refresh 
enough to have that happen for 
you. 
Maybe you want to actually pull 
these in using java script. 
There is no java script. How do 
you do that? It's impossible, 
right? It's possible. We're 
going to show you how to do it. 
    And something else, looks 
like the EuroZone  user wants to
 go through filter certain 
things, sort by price, filter by
 color. User actions. It's going
 to require some different kinds
 of dynamic components. 
    So we have those in AMP now.
Oh U  sorry. What do we do? The 
question, Dynamic AMP, we can do
 it. So you think about a page 
being dynamic. 
    There's two ways this often 
would happen, where a content 
would want to change in some 
way. One of those is, simply, 
retrieve content from the server
 and display it on the page. The
 user has requested something, 
whether you do it because you 
want to do it. 
    One way, content is 
retrieved from the server and 
displayed. Number two, the page 
simply changes in response to 
user actions. Maybe that content
 is already been on the page 
somewhere in HTML and gets shown
 or a class gets changed, 
changed in some way. 
    So another way of looking at
 this is dynamic stuff can 
happen, even response to user 
reaction or not. And the content
 can come from the user or 
server. An AMP in general, 
things change when a user 
requests them. 
    So here's our heroes today 
that can do these things. Our 
Wonder Twins of amp-list and 
amp-bind. They combine forces to
 dynamic. They covered use 
cases, amp-list pulls content 
from the server and amp-bind 
over here looks very, very 
serious today. 
Amp-bind lets you, actually, 
bind components to actions of 
some sort. So what's the second 
case? Amp-bind or change the 
page in response to user action.
These things cover a shockingly 
wide array of different things 
to change the page. 
    So back to our product 
browse page over here. If you 
want fresh product data when the
 page is loaded, that's a case 
of filling content from the
 server.
Amp-list. And the sorting and 
filtering is a case where the 
page changes in response to user
 actions. It might also involve 
from the server, as well. But 
this is mostly an amp-bind kind 
of thing. 
    Let's go with amp-lists. 
Retrieves data from the server, 
lets you form with a template 
and show the results to the 
user. And as amp-list and 
amp-bind are friends, amp-list 
has its own friend called 
amp-mustache. Amp-list, 
amp-mustache perform together 
and Raghu will show you how that
 works. 
   RAGHU SIMHA: Thank you very 
much. Now, it's time to write 
some code. So pull out your 
notebooks. I'm
 kidding. 
    The first problem that Ben 
alluded to having to do with 
pulling content from the server 
dynamically. We're going to 
start with data. It's JSON data.
We're going to build all product
 site. There's a couple of items
 in this JSON, and each item has
 some data associated with the 
JSON format. It's got an item 
ID, the name you're going to 
display on the product page, a 
description of what it does, a 
price, which you can update 
behind the scenes on the server.
And an image that you show in 
the store. 
    Second, amp-mustache, we're 
going to introduce this. Those 
familiar with HTML might know 
about templates in the HTML, the
 template element. The amp-run 
time introduces amp-mustache, 
which is a wrapper around the 
mustache JS templating system. 
    And as you can see here, 
this template specifies the way 
a product item needs to be 
displayed on the page. So we 
specify things, like, 
formatting, what goes in each 
field, how large the text is 
displayed, et cetera. 
    It's just a placeholder, as 
you can see. Now, let's flesh 
this out. The next step. Let's 
add some more details, like a 
link to the actual product page 
from the details page. An image 
of what the product looks like. 
And yet, as you can see, the 
double curly braces indicate 
it's also a templated element. 
We specify so the run time knows
 how big to display it. And now 
that we fleshed out our 
template, let's combine it with 
amp-list. 
    This is where the magic 
happens. This piece of code 
here, as you can see, contains 
an outer layer of an amp-list 
element. The list users in the 
source field, the product 
components JSON, which is the 
first code slide we just looked 
at. And so, the list is 
dynamically populated based on 
data pulled from a server in raw
 JSON format. 
    And that JSON pulmoed  
pulled from a server is 
populated using the mustache 
template. This looks like a 
simple piece of HTML code and 
does pretty complex stuff. 
    So what we're really doing 
here is encapsulating the JSON 
data inside an AMP list. And 
with this, we've got a product 
page. Hey, it
 worked. 
 BEN MORSS: There it is, 
actually, the live page. The 
thing we showed you a minute 
ago. The two products and the 
JSON caliper brakes and wheel 
set. There it is. I might go 
faster, I realize our time is 
running shorter here. Let's go 
on to the second part over here.
    Because for the filtering 
and asserting, we're going to 
want to use amp-bind: An example
 of the page changing in 
response to user actions. So 
binding, as you have in Angular 
and react
ant is useful. And bind has a 
friend, as well. Amp-bind works 
with the constant companion and 
faithful collaborator amp-state.
Here's Raghu to explain how this
 works. 
   RAGHU SIMHA: Let's breeze 
through this. We can solve the 
second problem here with code. 
Second problem, mainly, changing
 a page's content in response to
 a user action. So user clicks 
and the page responds 
immediately. And the web -- the 
contents of the page change with
 your user input. 
    So understanding how this 
works can be done in three quick
 steps. Step one, we call it 
&quot;state&quot; where defining state. In
 this case, amp-bind introduces 
a sub element called amp-state. 
The ID is greeting. This is an 
example we're going to go to. It
 contains raw JSON in it. And we
 can index it. So you can say 
&quot;greeting.name&quot; and this 
evaluates to an expression on 
the page. 
    This is a way of putting 
data inside the dawn of a page. 
Step two, we've got to bind this
 data to an actual element 
that's on a page. 
    So far, we just have data. 
Now, we have a paragraph 
element, which is going to be 
displayed on the page. The thing
 to note here is that the text 
property of the paragraph 
element is in square brackets. 
And so, what happens is the 
value of that text property is 
going to be what we evaluate 
from the expression. 
    So in this case, what I've 
done is initialized the value of
 the text property with the 
phrase &quot;hello, Bangalore &quot; and 
this is bound to the expression 
you see in double quotes. And 
that's where amp-bind gets its 
name. The third and most 
important step, &quot;mutation,&quot; 
which means changing the dataen 
O the page based on user input. 
    A simple example, a button. 
In this example, the AMP run 
time, amp-bind introduces a new 
method called &quot;setState,&quot; going 
to set the state of the city 
field to Bengaluru. You can 
imagine how this is going to 
work out. Let's put them 
together really fast. To recap, 
we've got the amp-state, which 
establishes the JSON data and 
initializes it. 
    And the second step has an 
element that's seen on the page 
and we bind the expression to 
the value of that element. And 
third, the mutation, which comes
 from user input. 
    So as you can see in the 
animated gif behind me, tapping 
the button corrects the name of 
our old city's name Bangalore to
 our current city name 
Bengaluru.
And that is amp-bind in a 
nutshell. 
    Now, let's put these 
ingredients together and see how
 this applies to the product 
page really fast. Again, we 
apply this to the PRUBLGT page 
product page example. These are 
the  
products. We start off with 
products from all categories and
 a selector in this case, not a 
button. And when the user clicks
 the selector and changes the 
value. When you go from all 
categories to just bikes or 
components, the magic happens in
 the background. 
    And thirdly, when we have an
 amp list, putting the source 
tab in square brackets means it 
is bound to the value of the 
JSON in the page. And
 here we are. 
 BEN MORSS: There she is. It's 
working. That wasn't hard to do,
 was it? No Java script 
involved.
This is a pretty simple way to 
make pages dynamic. And it works
 pretty well. Who is this guy 
over here? Is this, like, a 
baseball player with a 
funny-looking bat
 or something? 
   RAGHU SIMHA: Everybody knows 
who this is. Like a world 
crafted century, it took us 
quite a lot of steps to get 
here. It's a slow process, but 
it works. 
 BEN MORSS: That cricket thing. 
   RAGHU SIMHA: That's right. 
What we have as a result of this
 process of using amp-list, it's
 a product page that serves 
dynamic content and supports 
advances in functionality. And 
all of this is built from 
ground-up, what AMP, no custom 
user Java script. Pretty 
amazing. 
 BEN MORSS: Not bad. 
   RAGHU SIMHA: Yeah. 
 BEN MORSS: We can now make 
Dynamic pages. Let's finish up 
the site. The idea is here is 
how you can make a site that's 
dynamic, simply with AMP. Back 
to our home page over here. I 
said before, there's no &quot;search&quot;
 because we didn't know how to 
make the autocompletion. And 
it's like cricket without a bat.
It's no good. 
    Over here, on our home page,
 we have a search over here, we 
can use amp-form for a validated
 form over here, which is our 
search area. We can use amp-bind
 over here to bind the contents 
of the search and put an API 
requests. 
    And then, we use amp-lists 
for the completion area itself. 
The amp-list has the request in 
it, it is bound to the search 
input, the input changes, the 
API request changes, you can 
format it with amp-mustache and 
stick it right there on your 
page. Works pretty well. 
    The other , product detail 
page over here. You want the 
user to be able to choose 
different colors and sizes over 
here. You simply, actually, bind
 those, the image up there. And 
there it is. You add to the 
&quot;cart&quot; button, make a server 
request, this is a form over 
here. Also possible to do, you 
want to have reviews that can 
get pulled from the server using
 AMP-lists. Submit those via 
form. Amp-list for templating. 
You get the idea, right? You can
 do all of these things, various
 things with amp-bind and 
amp-list. And Social Sharing was
 a component for that. Twitter, 
Facebook, all of those, all 
possible with AMP. 
    The &quot;cart&quot; page, similar, 
you're going to get shipping 
costs, go to the server for 
those kind of things. If you 
want to change the quantities, 
combine the quantities there to 
the actual price. If you want to
 remove items. Again, you can 
have binding to change classes 
on things when things are 
reMbued. You
 can have tracking on what's in 
the cart. And your calculating 
totals. 
    The checkout page over here,
 we haven't discussed this 
before, but AMP comes with form 
validation built in. You can 
specify regular expressions, 
whatever you want to to have 
nice, helpful messages over here
 when things are submitted or 
entered that are not the correct
 format. 
    And then, for payments, this
 is a new feature that's coming 
to all browsers, Chrome already 
has it, Safari is working on it.
It's coming everywhere, Payment 
Request API. This will pull up 
over here, a nice little screen 
with users, devices, actual 
method of payments built in. If 
that isn't good for you, AMP 
iframe can be used. You can put 
whatever you want in there. Java
 script is allowed. You can do 
payment through the iframe. 
    What if you actually need 
more? If you find that, 
actually, you can't use AMP for 
everything anymore and you want 
custom Java script, there are 
ways to do this, as well. 
    We mentioned before with the
 amp-iFrame, you can embed 
whatever JS you want to use. 
    But also, you might find 
that the balance of speed and 
convenience of AMP is outweighed
 by either more powerful 
functionality that PWA has, or 
more complicated stuff that 
demands more Java script. This 
is not a problem here. This 
lovely animation says it all. 
AMP, PWA. It is common to start 
with AMP pages for speed. And 
then, at a certain point, 
position to PWA, to have PWA 
features where things load 
quickly, things available 
offline and so on and so forth. 
An AMP-installed service worker 
can be used to get it loaded and
 working in the background so 
your next PWA page loads 
immediately. AMP, PWA are a 
powerful combination. 
    As I was saying before, you 
can try this out yourself over 
here, ampstart.com/templates has
 this very same bike template 
over here that we showed you 
today. And e-commerce actually 
works shockingly well, while 
Mobile over in Seattle has been 
amping various e-commerce sites 
and the numbers here are 
impressive. A doubling of 
conversion rates. 
    Numbers like this occur 
sometimes with raw performance, 
but not usually. AMP is so much 
faster than anything else, that 
tends to please users quite a 
bit as long as the user 
interface is nice and the design
 is good.
 Fastcommerce, seeing pages get 
faster. Actually, right over 
here in Bengaluru is Myntra 
which has done AMP e-commerce 
and seen 60% increase in speed 
and a large reduction in bounce 
rates. 
    That's all we have for you. 
If you have questions, come find
 us at the AMP Office Hours or 
the AMP Sandbox over in the 
other building place. We're here
 to answer your questions. Thank
 you for your time. And have an 
excellent afternoon. 
   RAGHU SIMHA: Thank you. 
[ Applause ]
   WAYNE PIEKARSKI: Hello, 
everyone. Good afternoon. 
Welcome to GDDIndia. Today, my 
session is about What's up with 
the Internet of Which I thinks, 
TensorFlow and Google Assistant.
My name is Wayne Piekarski. My 
job is to talk to you about the 
cool things in this area. This 
is a new area with exciting
 possibilities. I think you're 
going to get a lot out of this. 
    There's a lot of different 
things we're talking about. But 
we're going to talk about a 
concept called ubiquitous 
computing: And computing's going
 to change. And I want to bring 
you up to speed with everything 
that Google's doing in this 
area. And what you can use to do
 your awesome projects, and so 
forth. 
    Let's get started. 
Computing's evolved over the 
years. We started from 
mainframes, went to desktops, 
laptops and then, to phones. And
 every decade, computers have 
gotten smaller and smaller. 
    Clearly, we can't keep 
making them smaller forever 
because then, you wouldn't be 
able to hold it in your hands. 
If you had a computer the size 
of a coin, you couldn't interact
 with it, whatever. There's a 
limit to how small we can make 
things go. 
    Now, over time, what has 
happened is that we've also 
moved in a different kinds of 
devices. So most people nowadays
 have a phone. But we also have 
computing devices in cars and on
 TVs and on Androidwear devices.

but we're now using them in 
different ways. We're not using 
a keyboard or a mouse like we 
would do before. 
    So we use different devices,
 depending on what we're trying 
to do. So, for example, if you 
want to write an email, a 
laptop's the best way to do 
that. If you want to watch 
videos, use a TV. If you want to
 use something out and about, 
use a phone and use a wearable 
while you're walking or when 
you're not sitting down. 
    So, each of these devices 
has a specific purpose and, we 
use them for those specific 
tasks. We don't want to use a 
watch to try to write an email. 
That doesn't make any sense. 
    We're now moving into a 
world now where computing is 
going to disappear, and it's 
going to disappear in all of our
 different devices that we have.

and lightbulbs with computers 
inside them. And we're moving to
 a world where computing is 
going to be everywhere. You're 
not going to have a device to do
 something. You're going to use 
computing wherever you go. And 
we're going to solve problems 
for people we didn't know 
existed and look back oven this 
and go, wow, that was incredible
 when that certain device came 
out. Today, I'm going to enable 
you to build that really cool 
device. 
    So, I had someone ask me 
today, oh, you know, this IoT 
thing SCHBT goingisn't going to 
go far. We sold hundreds O  of 
millions of computers and then 
smartphones. You're not going to
 have just a couple of IoT 
devices, you're going to have 30
 or 50 or different devices, 
you're going to have this growth
 in computing and this is where 
the devices will be. 
    And so, we use the term 
Ubiquitous Computing to describe
 when computing is everywhere, 
it's accessible, wherever they 
are and whatever they're doing. 
    And so, today, we're going 
to talk about the platforms that
 Google provides to enable you 
to participate in this. Because 
IoT's going to be bigger than 
anything you've seen before. If 
you thought phones were big, 
this is the next thing. 
    Let's talk about the kinds 
of things that Google can offer 
you to help build your new 
products. In the past, we 
trained users to install apps on
 their devices. 
    You had one app for each 
kind of task. And, you had an 
icon that you  launched it with 
and so forth. Now, we have 
devices that don't even have 
screens. We need to think 
differently about computing. We 
need to think about what it 
means. We need to think about 
the user's context, what they're
 DOICHK, doing, the time, the 
location and the physical 
activity. And that determines 
how we're going to go about 
interacting with them and what 
kind of computing they can do. 
    You need to think of your 
app no longer as an app but 
think of it as a view into a 
service. And your service is 
going to be everywhere. So your 
service is available in 
wearables, living room, in a 
car. It's going to be 
everywhere. And that's how you 
need to think about it. 
    And you need to have a 
seamless experience. You don't 
want to have the user use the 
app and log in on each platform.
You want to make it really easy 
so they can get started without 
having to think about the fact 
there's different devices. 
    What do we have to offer you
 that you can use to help make 
these kinds of devices to 
support ubiquitous computing? 
    Firstly, let's summarize 
what we have as consumer 
platforms and start off talking 
about Android Devices. 
    Many of you here are Android
 developers because it's 
GDDIndia. We have android 
phones, Android tablets, which 
are very common. And then 
Androidwear and AndroidTV and 
Androidauto as new experiences, 
new platforms for people to do 
Android on different kinds of 
devices. 
    Now, the cool thing about 
all of these platforms is that 
they're still based on Android 
Studio, write APKs, apps, games,
 sensor processing, 3D graphics,
 audio. And many of you write 
apps for some of these platforms
 already. 
    And the good news is that if
 you're an Android phone or 
tablet developer, you already 
know how to write for 
Androidwear or AndroidTV. It's 
literally the same thing. They 
all support networking, all 
support Google Play, and it's 
easy to port. 
    What other platforms can you
 get into? Writing an 
Androidwear or TV app is 
something to consider. 
Androidauto is a little 
different. What you do is you 
write templates for messaging or
 media apps. And these run on 
your phone. 
    And the way it works, your 
phone plugs into the head unit 
in the car and projects the 
video and the audio. 
Alternatively, you can run 
Android Auto on your phone and 
run it on the dash of the car. 
It allows people to listen to 
music and do messaging while 
they're driving. 
    So we've got lots of 
different form factors to cover 
all of the different things your
 users might be doing. And each 
of them are appropriate at 
different times, while on the go
 or in your home in the living 
room. 
    You also may have heard 
about the Google Assistant. And 
so, the Google Assistant and 
Home Devices are new ways of 
interacting with customers, as 
well. 
    And so, each of these 
platforms here are extended by 
the Google Assistant. We started
 off with Google Home Devices, 
but now you can use the Google 
Assistant on a phone. You can 
also use it on different 
platforms, such as Android TVs, 
Google Pixel Books, and it's 
great because it's everywhere 
and users can talk to it or type
 to it to get things done by 
talking to the Google Assistant.
If you haven't tried it before, 
you want to try out the Google 
Assistant to see how it feels 
and have really awesome 
conversations with it. And it 
feels really natural. It's not 
like talking to a robot. And 
it's a very compelling 
experience that makes nice 
conversations. 
    As I said, the Google 
Assistant works with both text 
and voice-based inputs. And it 
has text and voice-based 
outputs. And it works with the 
user whatever they're doing and 
whatever they're doing, as well.
    And the good news, is that 
we've launched the Google 
Assistant in all kinds of 
countries and locales all around
 the world. And recently, a 
couple of weeks ago, we launched
 the Google Assistant in India 
for English languages. And these
 are all of the different 
languages we support. We've got 
a bunch of them covered. And 
we're always launching new 
languages. More are coming soon.
Stay tuned if you're interested 
in other languages. 
    The nice thing is that we 
have coverage for lots of 
different users all around the 
world. 
    So those are examples of the
 consumer platforms that Google 
provides that consumers have in 
their homes or cars or walking 
around. 
    Now, we're going to talk 
about what you as a developer 
can use to participate in the 
ecosystems to provide services 
and interact allowing users to 
interact with the app. 
    There are a bunch of new 
options you'll find interesting.
Let's go through them. The first
 thing is that end of last year,
 we announced a developer 
preview for Android Things. And 
Android Things is the new 
platform to support developers 
who want to build their own IoT 
devices. And one of the coolest 
things, it's based around this 
concept of this board here. It's
 2 by 2 centimeters and contains
 the CPU, wireless chip, memory,
 and all of the important things
 that makes a device do what it 
does and on a common board with 
a common set of software. And 
you can buy these in bulk and 
cheaply and you can plug the 
SoMs into your boards. And the 
SoM contains all of the 
expensive, hard-to-design 
components. And then, you can 
build a small board around it 
that has your electronics for 
your application. 
    And so, we want to try to 
democratize hardware development
 to make it easy. In the past, 
it's been limited to big 
companies with large L budgets. 
But you as an android developer 
can now develop for IoT, as 
well. And you can make your own 
hardware and PAMP participate in
 the IoT system that's the next 
big thing. 
    You start off with a 
developer board. You can see at 
the top, we have a developer 
board there, and the SoM plugs 
into it. 
    You take the SoM away, and 
you've got this developer board 
that breaks out all of the 
different connectors. So it has 
things like USB, audio, GPIO 
pins, buses and so forth. You 
build your prototype with these 
boards. You plug things in, test
 it out. And then, when you're 
done, you then make your own 
custom board that plugs into the
 SoM. And it allows you to make 
things that are really tiny. But
 you can prototype on something 
bigger, as well. 
    And so, my colleague Dave 
Smith actually built his own 
small little LED candle as a 
basic example as the simplest 
thing. It's on GitHub. Check it 
out if you're interested. He 
prototyped it on the board on 
the left. And on the right, you 
can see, he manufactured his own
 custom printed circuit board 
that shows you how tiy you can 
make an IoT device. It's 
literally this big and it's 
everything. WI-FI, bluetooth, 
OTA updates, and it's fully 
self-contained and it's easy to 
work with and you can develop 
with Android Studio. That is the
 cool thing about androidthings.
It allows you to make your own 
custom devices, and you don't 
need to have a huge budget to do
 it. This is something you can 
do yourself and all of the 
schematics and source code are 
available online, as well. 
    What makes Android Things 
awesome is it's based on the 
power of Android. You use the 
existing Android APIs you're 
familiar with it and just like 
wear, TV or auto. It's supported
 by the Android ecosystem and 
the team at Google. And you can 
use Android Studio to write your
 code, the same libraries and 
APIs, everything's included. 
    It's also a real Android 
device, so it includes Google 
Play Services designed for IoT 
devices. It's a minimized 
version that runs and everything
 that you use from Google Play 
Services before. As I said 
before, Android Things is based 
on SoM architecture. 
    The modules are 
standardized. And Google 
supports them with what is 
called a common board support 
package or BSP. And this BSP is 
provided by Google and it's 
supported by us. And we provide 
the Linox kernels, port them 
over, maintain them, and also 
the necessary security updates, 
as well. So our team at Google 
that maintains the security 
updates for Android phones, we 
provide the same thing for 
Android Things devices. And when
 a security update needs to be 
pushed out, Google has the 
ability to push them out to the 
IoT devices so you don't have to
 worry about it yourself. 
    You can focus on what makes 
your IoT application great and 
Google handles all of the 
security updates and drivers and
 all of the stuff like that. 
    And, we provide an over the 
update mechanism that supports 
pushing up the updates so you 
don't have to write it yourself.
If any of you have developed IoT
 devices before, you'll have to 
do your own kernels, build your 
own OTA infrastructure, and this
 is time consuming and very 
expensive. It's something you 
don't have to worry about. 
    We see many things that you 
can do with Android Things. And 
a lot of people ask me, Wayne, 
why should I use Android Things 
compared to a small 
microcontroller or something 
like that? Microcontrollers are 
cool because they're cheap and 
do things like turn on and off 
lights O  or control a dial, but
 what you can't do is really 
powerful things, like, computer 
vision, audio processing and 
machine learning. These are 
things that you can't do on a 
small microcontroller. But it's 
something that you can do on an 
Android Things Device. And over 
time, as computing gets cheaper 
and cheaper, IoT devices are 
going to be cheap, it's going to
 be possible to do Machine 
Learning, TensorFlow and all of 
these things on super cheap 
devices in the same way we use 
microcontrollers now. 
    One of these great examples 
we put together is running 
TensorFlow and Android Things. 
The same TensorFlow talks you've
 seen at this event and at 
Google I/O previously, all of 
those things you can run on 
Google Android devices, as well.
    So we have a sample here 
that it has a camera and takes 
pictures of dogs. And you can 
see in this example here that 
when it takes a picture of my 
dog, it correctly identifies her
 breed. Now, this is not just 
saying dog or cat, it tells you 
the kind of dog, specifically, 
with a percentage probability. 
    And so TensorFlow has this 
thing called the Google 
Inception Model, trained with 
millions of photos put through 
the system. 
    And this model is capable of
 analyzing images and telling 
you what they are. We have this 
demo, actually, set up in the 
Sandbox area, and we have the 
code on GitHub so you can try it
 out on your Android things or 
phones, as well. It's a simple 
example to how to use TensorFlow
 on an Android Things device. 
There's all kinds of really cool
 applications to use this for. 
And we look forward to seeing 
what you build with that. 
    Now, we talked about the 
Google Assistant earlier. It's 
also possible to extend the 
Google Assistant. And you can 
write your own apps for the 
Google Assistant for using 
Actions on Google. Which is our 
platform, for developers to hook
 in their own conversations into
 the Google Assistant. And we 
have a tool called
  Dialogflow. 
It's a simple, easy to use 
interface that you program your 
conversations into and it makes 
it easy to make conversations. 
    And a lot of people think, 
well, conversations are easy, 
you process some strings. But 
those are really simple things, 
like yes or no answers. But if 
you want to converse with a 
computer, a natural conversation
 with it. And the Google 
Assistant supports natural 
conversations. And in a minute, 
we'll show a video that shows 
how this works. 
    So, these conversations that
 you develop, they run in the 
cloud, they're based on a web 
hook you develop using Java 
script. And they receive text 
that's transcribed from Google 
that has the conversation that 
was spoken to the action. It 
then gives it to you, you can 
decide what the reply will be, 
and then, you send it back. 
    Now, you can do this 
yourself, you can process the 
strings manually, but most 
developers don't want to do 
that. So we have the Dialogflow 
tool that provides it for you. 
    I'm going to show you a 
little video that demonstrates 
sort of a conversation and what 
it would sound like with a user 
interacting with it. 
    (Speaker off mic)
interacting with it. 
right. 
Sounds good to me, too. Okay. So
 let's look at what we saw in 
that video. I was chatting to a 
Google Assistant then. But that 
was very natural. I wasn't 
talking like a robot. I was just
 like, yeah, I want some chicken
 soup. It was kind of cold 
outside. I want someone to warm 
me up. 
    That was a very normal 
conversation you'd have with a 
person. And the sentences I 
spoke were quite complicated, 
too. If you look at the 
sentence, I asked for a hot soup
 because I wanted to be warmed 
up  because it's cold outside. 
So I said the words &quot;warm, hot 
and cold&quot; all in the same 
sentence. 
And somehow, the Google 
Assistant was able to get it 
correctly. If you were writing 
expressions looking for the 
words  &quot;hot&quot; or &quot;cold,&quot; you 
wouldn't have gotten it right. 
Trying to process this yourself 
is really hard. And so the 
dialogue flow tool makes this 
really easy. 
    And the way it does it is 
using Machine Learning. The 
Dialogflow tool, you type in 
example sentences, like you can 
see the examples there, chicken 
sounds good to me, I'd like a 
cold dessert. And it trains a 
Machine Learning model to 
understand other sentences that 
a user might speak. 
    We programmed in some 
examples like that. And then, 
when we made that video, I spoke
 completely differently and said
 different things, but it still 
understood what I was asking 
for. 
    And so Dialogflow allows you
 to implement these interfaces 
really easily. The graphical 
tool helps you identify the 
entities. And that's it. So it's
 definitely a tool you should 
check out to learn about how to 
build conversations for the 
Google Assistant. 
    When I saw this tool, I was 
like, wow, this makes everything
 easy and I don't have to worry 
about doing the conversation 
myself. Definitely check that 
out. 
    So with the Google 
Assistant, we also have the 
ability to embed it into your 
own custom devices. So we talked
 about Android Things earlier, 
you can run the Assistant SDK on
 an Android Things device and 
make your own custom hardware 
devices that have the Assistant 
embedded into them. You could 
make, like, toys or robots or 
whatever. And you can talk to 
them using the Google Assistant 
and Dialogflow. And then, you 
can make them move around and do
 things. And you don't have to 
implement the conversation 
yourself. 
    So once again, really easy. 
And you can embed the Assistant 
SDK into any of your custom 
devices. And you may have seen 
the projects kit, that works 
with Google Assistant SDK. It's 
a speaker, microphone and a 
button and then you've got a 
device. In the Sandbox area, you
 can see some of the examples we
 have of the Google Assistant 
SDK running on a device. And you
 can embed the Assistant in 
pretty much anything. Lots of 
possibilities for people to try 
different kinds of ideas. And if
 you look here, this is the 
inside of what the Assistant SDK
 Kit looks like. Very simple. 
And another cool thing, it works
 on many different platforms. 
We've got support for Android 
Things, but also, basic Linox 
machines and also many other 
platforms because it's portable 
and uses what's called GRPC. 
I've seen people run it on all 
kinds of platforms. There's a 
lot of options of what you can 
use the Assistant SDK for. 
    So that's possibilities of 
different platforms we have. 
Android, Google Assistant, 
actions on Google Assistant SDK.
You might want to connect these 
things up. It's important to 
have an ecosystem of platforms 
that allow people to use your 
service for many different 
places depending on what they're
 doing. 
    Now, we're going to talk 
about connectivity and how to 
bring them all together. So the 
Google Assistant supports a new 
API that we have called Smart 
Home. Smart Home allows device 
makers that's making IoT-based 
lightbulbs or thermostats or air
 conditioners or something like 
that, Smart Home is the API to 
integrate the devices in with 
the Google Assistant. 
    So we have this concept 
called a Home Graph. It has an 
API called Smart Home, and you 
implement the Smart Home API on 
your service. And whenever the 
user says something, like, dim 
the lights in the room or turn 
the air-conditioning up, the 
Google Assistant processes that 
and sends commands to your 
service saying turn the 
temperature up 5 degrees. So you
 implement the API for your 
devices and the assistant can 
then control them. 
    And so, from a user's 
perspective, it's great, they 
can have devices made by many 
different companies. And, they 
can communicate with all of them
 at the same time. And the Home 
 Graph brings them together. 
This is something to look at if 
you're building IoT devices for 
common household tasks. 
    And here's sort of a diagram
 that shows you how it works. 
You don't write a full 
conversation like you do with 
Dialogflow. 
Because the Google Assistant 
handles the conversation or part
 of it. You just implement the 
API for hooking your device into
 Home Graph and that's it. And 
the user has the ability to 
speak these commands and make 
their lightbulbs and thermostats
 and other things change state. 
    Finally, many of you have 
heard about Firebase and 
hopefully, have used it before. 
All of Firebase Functionality 
works in Android Things. It's 
nice, you can use it on Android,
 iOS, and you can use Firebase 
to implement communications 
between all of these different 
platforms. 
    And Firebase Cloud Messaging
 is really PORNT important 
because it allows you to build 
toward devices. When someone 
adjusts the temperature on their
 phone of a thermostat, it'll 
take five minutes, sometimes, P 
for the thermostat to adjust. 
But Firebase Cloud Messaging 
implements push notification so 
the changes take effect 
immediately without having to 
wait and without having to do 
inefficient polling. It's 
something you should be using if
 you want to sync between 
devices and do it quickly and 
efficiently. 
    Firebase also provides a 
realtime database and cloud 
storage to synchronize data and 
store images and videos and so 
forth. And it's nice because, 
once again, it's across 
platform, but also works on 
microcontrols, as well. 
    GitHub.com, Firebase, where 
you can implement Firebase on 
really, really tiny 
microcontrollers. Not even 
Android Things, but something 
really small. It implements 
across all of those platforms, 
as well. 
    And so, definitely, Firebase
 is something you want to check 
out because you don't need to 
implement your own Cloud 
Infrastructure yourself. A lot 
of developers try to build this 
themselves and it takes a lot of
 time. And it's important you do
 it securely. If you don't do it
 securely, someone will hack the
 service and your data gets 
compromised and so forth. 
Firebase is nice because it 
handles the hard aspects so you 
can focus on building your 
application. 
    And then, Google I/O this 
year, we announced what's called
 Google Cloud IoT Core. The cool
 thing about Google Cloud IoT 
Core, it's designed to scale up 
to worldwide IoT infrastructure.
Most companies know how to build
 something for thousands of 
devices or tens of thousands, 
but Google IoT Cloud is designed
 to scale all around the world. 
And it's something that the 
Cloud Team themselves put 
together. And it's designed to 
scale to millions of devices. It
 has end points all around the 
world so it handles dealing with
 traffic coming from everywhere.

about provisioning. And it adds 
redundancy to everything you 
build, as well. 
    It uses standard protocols 
like NQTT to get data from 
devices and aggregate and store 
them into the Google Cloud 
Infrastructure. It's great for 
enterprise use. And we have a 
lot of enterprise customers who 
have asked for these kind of 
features because they want to 
roll out millions of devices. 
And they want to have all of the
 infrastructure to handle data 
coming in from millions of 
devices constantly all day, 
every day. Trying to build that 
yourself is quite tricky. 
    Once the data is in Google 
Cloud, you can then use Cloud 
Services such as BigQuery to 
query these massive datasets to 
learn more and more about. 
    One of my colleagues, Gus 
Class is here and talking about 
Cloud IoT in another session. Go
 check that out if you want to 
learn more about what's possible
 with their software. 
    So that was a very big 
whirlwind tour of all of 
Google's products to support 
ubiquitous computing and the 
internet of things. 
    So we hope this can help you
 make really amazing devices 
that are powerful and also 
secure. 
Because in the past, a lot of 
companies have built devices 
that are not secure and then 
consumers have their data 
stolen. And devices get broken 
into. And it causes problems for
 everyone. And consumers want to
 buy well-made devices that get 
updates and that are maintained 
so they can trust them. 
    And so, Google's services 
that we provide that I went 
through today helped to provide 
many of the pieces that you need
 so you can fit them together to
 build the kinds of devices and 
infrastructure that people want.
    So we have a Sandbox area 
over in main area outside this 
building. You should definitely 
come by and check out some of 
the demos we have. We have a 
variety of different android 
things, Android SDK and Google 
Assistant demos to try out and 
see how they're built. And many 
of my team members have come out
 to talk to you because we want 
to learn about more about the 
things you want to build. 
    While we're here to teach 
you about things, we want to 
learn about cool ideas you have 
for things you want to build and
 how we can help enable them. 
And if it's new features you 
want or something, talk to me or
 my colleagues because we want 
to hear about what they are and 
what kinds of things you want. 
    What's next? We have many 
different resources for you to 
learn more. And so, we have a 
bunch of communities on Google 
Plus. We have one focused on IoT
 Developers, Android Things, 
Cloud IoT, things like that. 
Actions on Google Community. We 
have an Assistant SDK community 
for people embedded the 
Assistant SDK into their own 
custom devices. 
    These three communities are 
great places to ask questions 
and share ideas. I do a lot of 
posting for IoT and Assistant 
and so forth. Follow me on 
Twitter or Google Plus. I post a
 lot about the different tools 
and new things we're doing. 
    And so, definitely keep 
up-to-date with that. That was a
 quick little summary of what 
Google has to offer you. I want 
you to take this away and think 
about all of the different 
possibilities of things that we 
could make and what kind of 
devices would help benefit 
people. 
    Think of people who are less
 fortunate or might not be able 
to use a regular computer. They 
might have accessibility issues.
And, you know, think about how 
they could benefit for more 
computing in their lives and 
what ubiquitous computing could 
do to help them perform tasks 
they couldn't perform or help 
make their lives better. 
    Think about this. And as I 
said before, IoT is going to be 
a huge thing. It's going to be 
bigger than computers and bigger
 than phones. It's going to be 
way bigger than that. You want 
to be a part of it. Come by our 
sand box and say hello. And I'm 
excited to see what you build 
with this. Thanks for coming. 
    [ Applause ]
    Thanks a lot. I'll see
 you later.    DANIEL 
IMRIE-SITUNAYAKE: 
Hey, everybody. Pardon me. I've 
got a bit of a sore throat. My 
name's Dan and I'm a developer 
advocate for Dialogflow and 
Actions on Google. We're going 
to look at how to build an app 
for the Google Assistant. Let's 
start by introducing the 
Assistant Platform. 
    At Google, we believe the 
future is AI first. We've been 
investing in Machine Learning, 
Speech Recognition and Language 
Understanding. It basically 
allows you to have a 
conversation with Google that 
helps you get things done. 
    Because of these investments
 in AI, the conversation can be 
completely natural. You just use
 your voice, ask in a natural 
way and the assistant will help 
you.
    What does this mean for a 
developer? Well, the Assistant 
Platform has three parts. The 
first part is the device being 
used to interact with the 
Assistant. It could be the 
mobile phone, Androidwear Watch,
 a Google Smart speaker or many 
other devices. It's the 
conversation between the user 
and Google.

user can do by using the 
Assistant directly. But the 
third part, which is Actions on 
Google allows developers to 
extend the Assistant. So 
developer can implement an 
assisted app. This is what we're
 going to focus on today. 
    By the way, the Assistant is
 available in many different 
languages. We're launching new 
languages and locales all the 
time. You can support many users
 in different languages all 
around the world. And we just 
announced support for Indian 
English. We built an example 
around a personal chef, which is
 an app that suggests recipes 
based on what you want. 
    First, the user needs to 
invoke your app. They say a 
phrase, like, &quot;okay, Google, 
talk to Personal Chef.&quot; From 
this point onwards, the user is 
now talking to your app. Your 
app generates dialogue output, 
which is then spoken to the 
user. 
    The user, then, makes 
request, Your App processes it 
and replies back, again, so the 
user has a two-way dialogue 
until the conversation is 
finished. I'm going to show you 
a quick demo of this app called 
Personal Chef. We're going to 
dive into it a little deeper 
today,
 this afternoon. 
       . 
    Okay, Google. 
    Hi, I'm Personal Chef. 
    Well, it's cold outside. I 
need something to warm me up 
like hot soup. 
    All right. 
    Chicken soup. 
    Okay. I think we should try 
chicken and tomato soup recipe. 
    Sounds good to me. 
   DANIEL IMRIE-SITUNAYAKE: All 
right. So that demo conversation
 is actually
 quite complex. Can you imagine 
trying to write a 
regular expression. So many 
different cases. Let's find the 
various cays to build this 
interaction. Using the 
conversation API and the Actions
 SDK. You receive a request 
containing the spoken text from 
a user as a string. Google 
handles the Speech Recognition 
for you and you pass the 
strings, generate a response and
 Google handles this back to the
 speaker. However, passing NAMPL
 language can be difficult. 
    Fortunately, we provide 
tools that make this kind of 
thing really easy. Dialogflow is
 one of these. And it's a 
platform that makes it 
incredibly straightforward to 
build conversational 
experiences. You might not have 
to write any code. 
    We're going to give you an 
overview and so many of you can 
use to implement your own 
Assistant app. What is 
Dialogflow? Basically, it 
provides an intrusive user 
interface for creating 
conversational experiences. 
    You program in a few example
 sentences of things a user 
might speak and you can specify 
which values you can get from 
the user. It uses machine 
learning to understand the 
sentences and manage the 
conversation. 
    So the key part here is that
 you no longer need to process 
strings, Dialogue does this for 
you. It handles the conversation
 and fulfillment, like, in the 
earlier diagram. Dialogue flow 
handles the conversation for 
you. So once the user is talking
 to your assisted app, they 
start something we call the User
 Says phrase, like find me a 
recipe for homemade cannoli. 
Find the appropriate intent. The
 phrase is processed to extract 
entities which are important 
pieces of information that 
you're looking for. 
    And it then calls web hook 
with the action. And the web 
hook  can generate a response 
spoken back to the user. 
    Let's see a quick demo of 
what Dialogflow can
 do. So in Dialogflow, we create
 an intent to represent each 
thing the user might want to do.
 In this case, we built an 
intent that covers the user 
asking for a recipe.
 So here, you can see how we've 
provided examples of different 
ways the user might express 
their desire for a recipe. 
    These examples are used to 
train a Machine Learning model 
to recognize what the user 
wants. As we add examples, 
Dialogflow will automatically 
pick out important concepts that
 are mentioned by the user. The 
system understands many concepts
 by itself, but you can add 
custom domain specific 
information, like, in this case,
 recipe ingredients. 
    I'm going to add a couple of
 examples here. So how ability, 
, do you have any ideas for 
chicken
 salad? Or &quot;I want a quick 
starter.&quot;
We can also mark this 
information as required so our 
app will automatically ask the 
user if they didn't
 mention it. 
I'm going to save here and we're
 going to give it a try.
 If I ask here, &quot;I want 
something with beef,&quot; we 
mentioned beef. But the agent 
also wants to know a vegetable 
and a dish type. So it's 
automatically asking for them. 
Let's add these here. 
Potato. And it asks what kind of
 dish do you prefer? Let's say
 main course. All right. Now, we
 can be suggesting a recipe if 
the server looked this up on the
 back end. 
    So it's amazing to be able 
to conduct a conversation 
dynamically on the fly without 
knowing ahead of time what the 
user will say. Once the intent 
has captured all of this 
information, it becomes 
available on the back-end where 
you can make stuff happen and 
generate a response. 
    Once we're done, it's only a
 few clicks to integrate the app
 with a load of different 
platforms. We want to integrate 
with Actions on Google. You can 
click here and load up the 
simulator to test
 it out. 
    So this tool allows us to 
trial our Actions. Talk to my 
test app.
 And now, we're talking to our 
Actions. I it out. 
    So this tool allows us to 
trial our can say, &quot;let's try a 
recipe with chicken chicken .&quot; 
And I misspelled it.

 have potato, and we want a main
 course. It's the same app now 
available in the Actions on 
Google Platform with one click. 
This is the work flow for 
building an action. It's fast 
and simple, you should give it a
 try. 
    So that's the end of my 
demo. Let's talk a little bit 
more about
 the platform. All right. So 
we've heard about how apps with 
the Google Assistant are built. 
But how do we make sure we build
 apps that users will love? 
Google offers a ton of tools and
 features that will help you 
create a magical experience for 
your users. 
    Most important thing to 
think about is the design of 
your app. Voice user interface 
design is a huge topic, and we 
don't have time to cover it in 
this presentation. Fortunately, 
Google Developer website can 
teach you how to think like a 
designer and build experiences 
that are natural and fun to use.
This should be the first place 
you go when you're designing a 
new app. 
    Let's talk about sort of the
 platform features you can use 
to divide your users. Your app 
can support simple audio output 
on the Google Home or other 
Smart Speakers or Mobile 
handset. You can craft special 
responses that make the most of 
your devices  screen. You can 
specify onscreen display text 
that is distinct from the spoken
 response. 
    To guide the user in 
responding, you can provide 
suggestion chips. These supply 
suggested answers to a question 
that can be chosen with a single
 tap. And then, basic cards 
allow you to display substantial
 information in the form of 
images, text and a hyperlink. 
The text there doesn't have to 
be spoken out loud. You can use 
lists and carousels to provide a
 visual mechanism selection for 
users. 
    A carousel shows images, 
titles for items. And a list has
 the capacity for substantially 
more but the images are smaller.
You can affect the way your app 
speech sounds. You can play 
sound effects, alter the rate, 
pitch and volume of speech and 
control how words and numbers 
are read aloud. 
    You can even layer 
background music and sounds. And
 you do all of this through 
SSML.
You might also have a 
conversation that needs to know 
the user's name or location. So 
here's one example of finding a 
local bookstore and you need to 
know the ZIP Code. 
    You can use R SDK to
 find out device coarse 
location. It will ask for 
permission using your app's 
voice. 
    If you'd like to link a user
 with their account on your own 
service and you have an OF 
server, the Google Assistant can
 prompt users for their account.
The user receives a card on the 
top of the Google Home map that 
provides a link to the log-in 
page. 
    Once the user has completed 
the account flow, they can 
invoke your action and 
authenticate to your services. 
It's worth noting that it needs 
to be one you own rather than a 
third-party service. 
    If your experience involves 
shopping or payments, we support
 rich transactions and allow you
 to accept user payments. The 
really cool part is customers 
can use whatever payment 
information they have on file 
with Google. Payments can be 
super easy. No need to fumble 
around with a credit card or 
read numbers out loud. 
Transactions also supports a 
shopping cart, delivery options,
 order summary and payments. And
 the user can see a history of 
all of their transactions. 
    The Google Assistant 
supports home automation. Device
 makers can easily integrate 
their existing devices with our 
Home Graph. It knows the state 
of all connected devices. So 
when you ask to dim the lights a
 little bit, it knows how to do 
that. So the user can make all 
kinds of requests. Make it 
warmer, turn off the lights, how
 many lights there are. The 
possibilities are endless here. 
We plan on adding many different
 device types very soon. 
    We've also asked that Google
 Assistant SDK which enables you
 to embed the Google Assistant 
into your own custom hardware 
projects. And we've included the
 AI projects kit, provides a 
button, speaker and microphone 
to wrap around a pipe which uses
 the Google Assistant SDK. And 
at Google I/O this year, we 
demoed from our partner, which 
embeds the Google Assistant SDK 
also so you can walk up to the 
device, tell it the kind of 
drink you want and it'll mix it 
up for you. So you can mix the 
Google Assistant into pretty 
much anything. 
    You've built a great app. 
Now what? How do you get it in 
front of users? The basic way to
 access your app is invoking it 
by name. So when you submit your
 app, you can provide a set of 
trigger phrases that the 
Assistant will recognize as a 
request to speak to your app. As
 mentioned earlier, you can also
 support Deep Links. They can 
ask your app for a particular 
thing.
    In the long-term, users will
 be able to find your app based 
on its specific capabilities. If
 they ask to play a game, the 
Assistant will offer a few 
options from the Assistant
 Apps available. We also have a 
directory. Users still -- don't 
have to install or pay, they're 
available just by asking by 
name. 
    Finally, you can hyperlink 
to your app from just about 
anywhere. You can share it in 
social media, promote it through
 your site or apps or encourage 
press to drive traffic to your 
Assistant app. If the user 
clicks the link, they'll be sent
 to a screen where they can read
 about your app and try out. 
    So hopefully, you're feeling
 excited about building your 
first app for the Google 
Assistant. But how do you get 
started? Your first port of call
 should be the Google 
Developer's page for Actions on 
Google. Your guide to getting 
started with building R your 
first app. P with Templates, yo 
uh can build an app, you fill 
out a spreadsheet, create your 
own trivia, personality quiz or 
flashcards game. And on the 
codelab site, we'll guide you 
through creating your first app 
for the Google Assistant using 
dialogue flow. When you create 
and deploy your first app. We'll
 thank you with a free T-shirt 
and $200 in credits every year. 
If you'd like to dive deeper 
into the platform, there's a 
talk tomorrow on new features. 
It'll show you how to do things 
like layering audio and sending 
push notifications to your 
users. I definitely recommend 
checking it out. 
    And finally, when you want 
to discuss this with other 
developers, we have the action 
on Google Developer community on
 Google Plus. We post regularly 
to keep you up to date on latest
 news and we answer questions 
from developers. We also have a 
great community on overflow. And
 we're active on Twitter, too.

 by the sandbox area and chat 
with us. And you should attend 
the talk tomorrow called What's 
New with the Google Assistant. 
Thanks for coming and enjoy your
 time at GDD. 
[ Applause ] 
   AMRIT SANJEEV: Good 
afternoon, everyone. Wake up.
 My name is Amrit, I work in the
 develop relations team here at 
Google. And we're going to see 
something interesting. How you 
can get Actionable Insights from
 Firebase predictions. Before we
 start, let's play a math game. 
It's not too complicated. If Yao
 seen this before, play along. 
Don't spoil the fun. 
    Think of a number between 
one and ten. Don't tell anyone, 
keep it in your mind. Okay? 
Multiply that
 by two. All good? 
Plus eight
 to it. Okay. All right. Don't 
worry, it won't be too long. 
Divide this by half. 
By two, half of it. And minus 
the original number you thought 
of, initially, from the result 
that you got right now. 
    You have your numbers? Okay.
Now, you most likely probably 
got a number before 26.
 Now, if you've got 1, it's 
going to be A, if you got 2, 
it's going to be B, and so 
forth. Now, pick a country, any 
country, that starts with the 
letter that you thought of, the 
character that you have got
 right now. 
    Don't say that out loud. 
Hold on. Pick the next character
 from the alphabet queue. So if 
you have A, pick B, if you have 
B, pick C, so on. Okay? Pick the
 next character. 
    Now, think of an animal, but
 actually, starts with the 
letter. All thought of? Now, the
 thing we're going to try and do
 here is to kind of think of or 
predict what you guys have 
thought of. How many have 
thought of an elephant? Show of 
hands. Good number of people. 
How many thought of Denmark as a
 country? Again, a good number. 
How many thought both of that? 
Again, the same number? Okay. 
    You guys are a very 
predictable audience. Well, 
interesting, there are no 
elephants in Denmark, it seems. 
That's a new thing I learned. 
But it feels magical, right? 
This is how you want most of 
your app experiences to be like.
Where you have the emotional 
connections to the apps so you 
retain those apps more. You want
 to spend on those apps, the 
particular experiences come in 
and delight you every now and 
then. 
    Now, some of you might have 
thought of something else. Could
 be an animal. That's fine.
 But, let's think of building a 
game along these lines that we 
talked about right now. 
    If you are actually seeing, 
we have the elephant, let's 
think of the game's intention 
for this elephant to go around 
the world and collect bananas.
But if you look at the formula 
of the game, there's something 
interesting you will find. 
Within 24 hours, for most games,
 within 24 hours of acquiring 
some  users, you're going to 
lose half of them. 
    That doesn't end there. 
Seven days later, most likely 
lose another half. And, 30 days 
later, another half. This is a 
worrying trend. And, yes, the 
elephant's not going to be 
happy. You've done a lot of work
 to acquire the users, and then,
 the users are getting lost over
 a period of time. 
    Now, you can think of ways 
in which you want to retain 
these users that you're going to
 lose. You can come up with new 
strategies, maybe new work flows
 by which you retain the users 
to your app. 
    But in order to do that, you
 most likely want to know who is
 going to leave. It's easier to 
retain somebody who is about to 
leave than getting the users who
 left and the users who get back
 after they've left. But 
identifying those users is going
 to be tricky. 
    Because they can be any 
bunch from your user set. That's
 where Firebase Prediction comes
 into the picture. If you 
started using Google Analytics 
for Firebase already, it's 
pretty straightforward. All you 
do is go ahead, console, click 
on the Predictions tab, and 
that's all the work you do. 
    From then, we actually take 
the data from your analytics 
that you have, actually, logged 
in over a period of time. And 
then, run it through an ML model
 and show your predictions. 
    This is all the code. 
There's no code to write on it. 
Just click the button and you 
can start getting the full 
predictions for this. 
    Now, let's get a little 
deeper into how this is 
happening. Now, if you look at 
it at the heart of this problem,
 this is supervisored learning 
model. Standard way. You have 
within the past 100 days of 
data, divided into two segments.
One, for the last seven days, we
 know what has happened, we 
label that data. And for the 
data before that, we actually 
studied a user behavior and then
 validate it against the 
available data. 
    And then, using these two 
things, running in a TensorFlow 
model, we'll be able to predict 
for the next seven days what the
 behavior would be like. We have
 the training data as well as 
the holdout data. The training 
data is used in order to 
understand the behavior of the 
users based on past history. And
 at every step of the training, 
we use to holdout data to ensure
 that we have the right accuracy
 and we can feed back data into 
it. 
    Now, using this model, we 
can then predict what will 
happen with the existing set of 
users for the next seven days. 
And that's how predictions have 
actually formed and
 shared. Now, using this, you 
have five
 days' data from TensorFlow, 
then flowing into your Firebase 
Console. With one check, 
basically, for the accuracy, 
once the accuracy is crossing 
that, we share it in the 
Console. You can use the 
prediction and the data and act 
upon that. 
    Now, it doesn't stop there. 
You can go ahead and use that. 
And then use it with Remote 
Console or testing. It comes 
most strongly when you use it 
with other tools that are along 
with Firebase. You might be able
 to change something in Remote 
Conflict. Or you would be 
wanting to send push 
notifications to a certain set 
of audience based on the 
prediction that you've got or 
around a different test on one 
of the segments which is 
predicting. 
    Let's look at the Default 
Predictions. You can get a few 
things, and also custom 
predictions. But let's start 
with the Default Predictions. 
This is aa prediction for an app
 for churn and not churn. 
    Like, whoever's going to 
leave the app and who is less 
likely to leave the app. Let me 
show you the different sections 
on the card. Now, first is the 
name what the prediction's 
about. Here, it's not the -- the
 second one is where the users 
are not going to churn from the 
app. And then you have the 
percentage of users that you 
will see from the current user 
base who are predicted to churn 
in the next seven days, 36%. 
That's fairly high. You need to 
do something about that. 
    Now, you would also see that
 36% plus, we are not adding up 
to 100, but that's fair. There 
are some users in your system 
that we don't know enough data 
about. And we would not predict 
for them. 
    So sometimes, these numbers 
will add up to 100. A set of 
users we have not learned enough
 data to understand some 
behaviors from them. 
    The next thing you want to 
look at is the number. We also 
show not just in percentage, but
 what is the total number of 
users that will be affected or 
that is actually in the segment 
right now? 
    Now, the second prediction, 
this is even more
 interesting is who is 
predicted, is this person likely
 to spend on the app? Or is this
 person not likely to spend on 
the app? 
    This can, again, be used to 
create some workflow changes, by
 which you're getting preset 
revenue. 
    Now, if you see the slide 
which said, which was there in 
each of these cards. This is 
basically a slider. Now, this s 
a way of you to tell the system 
how vulnerable you are to false 
positives. You change the value,
 the number targeted and the 
percentage. Let me explain that 
with the example. 
    Now, if your risk tolerance 
is low, which means that you 
have low tolerance to, say, 
something, like, the risk you 
want to take with the action 
that you take. You P want it to 
be fairly low and you don't want
 false positives. You can tell 
it to be low. 
    Or the risk -- a lot more 
risk can be taken, you can set 
to a higher risk level. Giving 
an example, if I'm going to 
target in this app, I'm going to
 target all of the users who are
 about to churn, for example. 
And I'm going to give them a 
free gift. Or, rather, let me 
take another example. 
    Let's talk about somebody 
who is already spending and 
you're putting a new in-app 
purchase in the app. You want to
 show the users who were 
actually more likely to purchase
 that. 
You don't want to show it to 
non-spenders. When you take 
that, you can take a higher 
risk. 
    Even if you show this new 
in-app product to a user that is
 not likely to spend, it's still
 fine because at the most, he's 
not going to do any action on 
it. But there's no loss of 
revenue or anything on you by 
taking that. So you'll actually 
try to give it to a maximum risk
 tolerance. 
    In the same way, if you 
think about giving a free, say, 
product or a free subscription 
to everybody in the game who is 
about to churn, to increase 
retention, you might want to 
give it to a low tolerance. You 
don't want to give it free to a 
user who is willing to pay for 
this. You P want the risk 
tolerance to be minimum. You 
want to change
 your value. 
Overall accuracy, that's the 
last part on the card. We know 
what happened. And we know what 
we predicted. We can use that 
information to kind of tell you 
how accurate this prediction has
 been developed. It takes 14 
days and shows you the 
positives, positive scenarios 
and the negative scenarios and 
overall accuracy. That's the 
accuracy card. 
    Sometimes, you want to take 
into account the accuracy before
 you decide on the risk 
tolerance or decide on whether 
you want to act upon that 
prediction, or not. If the 
accuracy is low, maybe you don't
 want to take into account that 
one. 
    Now, how would you use 
predictions in your app? Now, 
let's take an example in this 
case where
 -- let's take an example where 
users are likely to predict and 
we want to do something about 
that. 
    Now, we know from our app's 
data that, hey, at the level 4, 
if people have actually crossed 
level 4, they have an emotional 
connection to the app and they 
tend to play more because there 
are more options available, 
there are more game play 
choices. The retention's higher 
after level 4. 
    That's a fact that we know. 
Now, let's see how we can 
translate that with prediction 
that you made so far. Now, you 
could use the prediction churn 
where you had 36% of people who 
are likely to churn, and you 
could actually use Remote k 
Conflict to do something like 
this. We could change people who
 are more likely to churn. And 
when the user is below level 4, 
you change the game level 
difficulty to easy, only for 
those users without affecting 
the game play for everybody. 
You're not changing for 
everyone, only the people who 
actually are predicted to churn.
Which means, they will find it 
easier to go over to level 4, 
which means the retention will 
increase. For everybody else, 
default medium level is what we 
want to keep. 
    That way, for people who are
 enjoying the game so far and 
not predicted to churn, you 
would continue to give them the 
same level of difficulty. But at
 the same time, those predicted 
to churn will be given an easier
 way to kind of play more and go
 over level 4. 
    Now, for Predicted Spend. 
Let's think about how we can 
improve that part. Prediction 
Spend, people willing to spend 
on it, it's a good number. We 
should try to improve that. 
    One thing you could do is 
kind of use to decide
 what would be the best way 
people are looking at. There are
 two variants you can run 
against the people who will 
spend. 
    You could run a variant A, 
which gives you a dozen bananas 
for $1, 99 cents, or ten dozen
 bananas for $5.99. What are 
people more likely to buy? You 
want to send it to the users, 
enable only for the users who 
would actually pay for this, 
right? The risk of running this 
for everyone
 is that it's inconclusive 
because a lot of people will not
 buy it anyway. 
You will not get conclusive data
 on it. Those spending are 
likely to spend, you get a much 
more accurate way of measuring 
this and deciding which variant 
should you continue to keep. 
    Once you see that a Variant 
B is what most people want, what
 you would do is just use that.
that. -- throughout the app. So 
the result would be based on how
 users are using it and the 
right segment to the right 
audience. 
    Now, you also have 74% of 
people who are not paying. 
That's the non-spending group. 
Here, you could use an 
alternative monetization model. 
So you can increase the revenue 
from people who are not even 
likely to spend. They're not 
buying it, maybe you want to 
kind of show them by which the 
revenue increases, they might 
get benefits out of the app. 
Opening up levels, things like 
that. But they are generating 
revenue for you. 
    This is powerful because you
 now target people based on what
 they plan, how they would 
generate revenue for you by 
showing a reward for everyone, 
your effectiveness is less. Or 
showing that to everyone, it 
suddenly jumps up when you 
target them correctly. 
    Now, there are also custom 
predictions you could do. Not 
just the default ones. There are
 five Custom Predictions where 
it's as simple as this. Let's 
look at the flow of a Custom 
Prediction. 
    You start by taking one of 
your conversion events you've 
logged already. When you log, 
you can see that to be a 
conversion event and take one of
 the conversion events. And 
then, share, like in this case, 
whether somebody would share 
some data, or not. 
    You want to show the share, 
users more likely to share it 
others, it's a level that either
 you could actually skip. You 
want to introduce social 
engagement in the app and show 
the users that are interested in
 doing that. 
    Now, I've taken a 
prediction, a social engagement 
and I'm looking for people who 
will share. Once you actually 
get that, in this case, there's 
34% of people who are willing to
 share that. With that data, you
 could then turn on using Remote
 Config, maybe turn on a screen 
which would show them the search
 -- share interface. 
    Let's look at examples of 
how people have used this and 
made some changes in the app in 
the real world. Halfbrick was 
one of the partners, increased 
retention for their app by 20%. 
By using Firebase Predictions. 
Let's see what they have done. 
Initially, they went ahead and 
said you were going to use 
Firebase Predictions and opted 
in for Firebase Predictions. In 
the background Firebase 
Prediction started preparing 
this, and once the predictions 
were ready, we send the mail, 
you open the mail, click on the 
console. And in the console, 
you'll get predictions of who is
 going to churn. 23% in this 
case. 
    What they did is, then, 
clicked on Target Users button, 
showed up in Config option and 
they used Config in this case. 
They created a parameter will 
churn, and then, published it. 
Now, with -- by doing this, what
 they have done is in their app,
 they have a parameter for that 
every user in the next Remote. 
Which means, the app right now 
has the intelligence to decide 
whether this person will churn, 
or not, based on the prediction 
that happened in Firebase 
Prediction Console. 
    I'll tell you what they did 
in picture. They actually shared
 a specialty for people who were
 about to churn. They gave them 
a little bit of coins. And a 
play button, which is very 
enticing. 
So by doing this, only to the 
people that were about to churn,
 they reduced the risk of 
retention by 20%. It's not a 
small number to give back. There
 might be many incentives in 
your apps that you can do things
 very similar. 
    Let's take another example 
where somebody has optimized 
revenue based on predictions. 
Now Rockbite is one of the apps 
we worked with who increased the
 revenue by using Firebase 
Predictions. 
    Now, what they did is 
basically used the predictions
 that -- the Spend Prediction 
and changed the order in which 
goods were shown in AV testing, 
sorry, in the digital story. 
They used AV testing tool to 
kind of do that. 
    What they did has amazing 
results. Increased the revenue 
for spenders by 25%. That's 
one-fourth increase in revenue. 
Not a small number you can 
ignore, right? 
    Now, what they have done is 
used
 this condition and ordered 
differently in the way which 
they would keep digital goods 
in-app purchases in their app. 
The in-app purchases they had 
and the order was, actually, 
changed based on this data. 
    Now, for the spenders group,
 they actually gave rare items, 
that is a chest that you see up 
front. And for those people who 
were not spenders, what they did
 was gave things that could 
continue game play for a longer
 period of time. Like, for 
instance, that can be used in 
the game. 
    This is more than 
interesting, for the 72% that 
did not spend, increased the 
revenue by 24% for people who 
are not willing to spend. 
    So this way of actually 
changing things by using A/B 
testing tool allows them to 
increase revenue on the spenders
 as well as the nonspenders. 
They're both getting customized 
experiences, which made them 
spend more. 
    Now, Config is
  -- Concrete, another partner 
who improved their user 
experience by showing them ads, 
which were -- showing ads to 
users that were more likely to 
retain more ads and less as 
people churn, they reduce the 
number of it. And they gave this
 clearly with the user-centric 
approach, able to increase 
in-app purchases by over 20%.  
    In summary, this whole 
thing. If you're already using 
Firebase Analytics, if you're 
not, start using it. If you're 
already using that, opt in for 
Firebase Predictions. With 
Firebase Predictions, you'll be 
able to find out these 
interesting bits by which you 
can change your flows and 
improve experiences for user, 
making it customized and get it 
to work for you as part of your 
team. So that's the staff photo 
after you add Firebase 
Predictions to your team. We are
 also part of that. 
    It doesn't end there. It's 
not just about predicting the 
user behavior, it's also about 
using them with appropriate work
 flows. Push notification, where
 you push notify the users based
 on their behavior. You might 
want to send certain users who 
are based on your prediction, 
that segment of user, one type 
of message and a different one 
for a different type of -- 
different segment of audience or
 changing more conflict and 
changing the behavior of the app
 on the fly. 
    Or, it could be that you run
 more A/B tests on the more 
appropriate set of people you 
have. The power comes in when 
you use it all in combination 
with each other. 
    And if there are more 
questions, feel free to meet us 
at the Firebase Office Hours 
section. And I hope this was 
useful for you guys, and you try
 it out. If there are 
interesting cases that come up, 
do not forget to let us know. 
Thank you. 
[ Applause ] 
           KC AYYAGARI: Hi, 
everyone.
 Hello. It's been a long day and
 hopefully you've had a lot of 
good sessions since morning. 
This session, we are going to, 
actually, start with 
understanding Containers, 
Kubernetes and as well as Google
 Cloud. Before we start, a
 word to understand where we 
are. How many of you know about
 Containers? How many know about
 Kubernetes? Excellent. And 
Google Cloud?
 You are experts, then. Let me 
try to give a different 
perspective. 
    So this is our agenda. We 
will not be diving into 
Kubernetes as a whole, but we 
are trying to understand why 
Kubernetes got out or containers
 got out. And what is the use 
case of these Containers and why
 we have to use them. And yes, 
I'll also show you how easy it 
is to create a Kubernetes 
cluster and I'll take you to 
Kubernetes Engine.
 And we'll wrap it up. 
    If you understand Current 
Practice, applications. We have 
been doing the same kind of 
application development. If you 
look at the current application 
development is, we have a couple
 of webservers you put your 
quote E quota on and you have a 
database, and there'll be batch 
processing happens from the 
database to whatever you want 
to, basically, get the data out 
and you have a cache. 
    This is a traditional app. 
And what is the biggest 
challenge you see if you're 
building these kind of 
applications? How many people 
here have an issue of waiting 
for the test team or the test 
team waiting for the developers 
to give it to you? A few of you.
This is a common issue. 
    And the second one, you have
 a couple of pieces, a
 couple of modules in your 
application. 
Still, you have to code them, 
wait for the builder to succeed 
so that you can push your binary
 out. That's an issue. 
    Even though you're working 
on a model which P doesn't have 
any dependency, you have to wait
 for the development. If you did
 that as one app, I showed you, 
the app actually has monolithic 
apps has an issue it requires 
large resources, for instance. 
    Basically, you need to put 
these heavy apps into a single 
mission. You can't divide them 
they're not built into services.
They're a single app, you have 
to put them nearby. 
    The second one, these are 
hard to scale. And the biggest 
problem I see because I've been 
working with a lot of 
developers. The biggest problem 
I see is it's very, very hard 
for the teams to coordinate with
 each other to build the apps. 
    Yes, you always have issues 
around performance and 
availability and all of that 
comes into the forefront. 
    Now, how are we going to 
solve this? Microservices and 
Containers. The next of what 
we're doing here is can be 
modulized as this. For example, 
you have a complete app. If you 
can break down into 
comparatively small services 
which can be
 managed where every development
 team would focus on a service 
by itself. 
    That would create
 much more.
Taking the entire app, managing 
them into comparatively small 
services where development can 
focus on. The best part of this 
kind of architecture is you can 
scale them or the services as 
per your requirements. You don't
 need to scale -- one piece of 
the service is one of the scale.
The e-commerce website if you 
have a huge number of orders 
coming in, which model do you 
think
 has to scale? Management or 
solution, it has to be okay, you
 don't have to scale them as big
 as possible. 
    This gives you independently
 Scalable model which is a 
really lucrative feature. Now, 
the problem -- coming to where 
you can deploy these services. 
Now, you have, we have 
established that, yes, Microsoft
 is the
  -- 
where do you want to put these? 
We started with shared missions.
As in, you don't have the 
virtualization there. With 
libraries and apps installed on 
it. The issue is there is no 
isolation, as such. There is no 
name spacing, but you do have 
common libraries. 
    The biggest issue that
 -- 
this works. This is not like it 
doesn't work. But let's think 
about the scaling part of these 
shared missions. It's very, very
 difficult to actually scale 
them up. 
    Then came Virtual Machines, 
we took the same applications. 
The key challenge in 
virtualization or Virtual 
Machines. You still have kernel 
attached to library and app, 
which makes them heavy. So how 
much time do you take? Create a 
Virtual Machine. It's still, 
today, it's a heavy-lifting job 
even though you have the best 
server, processing available. 
    So which means you got some 
isolation, but it is still 
inefficient and hard to manage, 
as usual. 
    That's where Containers 
where the kernel is taken out, 
the libraries and app are 
modelleded  into a single 
entity. The apps and libraries 
are easy to scale, basically, 
and easy to create. It takes a 
fraction of second and easy to 
scale. 
    Just covers all of your 
issues. If you change your 
architecture to containers, you 
have a container which actually 
can scale. Now, let's talk about
 what we have been doing. Let's 
talk about -- let's go to 
history. 
    So for the last 15 years, 
we've been creating a lot of 
powerful infrastructure. We 
started building this company. 
And yes, we are kind of a 
start-up of our own. What we had
 to do is create our own 
hardware, essentially, as 
building, best hardware 
engineers and build the best and
 most powerful infrastructure in
 the world. 
    Now, I will give you some 
background. How do you think we 
are actually creating this? What
 is that we are running in this 
hardware? It's Containers. We 
actually run all of our services
 on containers. 
    So if you look
 at the Search, Gmail, Maps and 
Chrome, they're using 
containers. This is a kind of a 
slide which gives your technical
 innovation, how many of you 
know these names? 
How many of them do you 
recognize the names? Quite a 
lot. Yes. That's great. So these
 are -- for people who don't 
know, these
 are actually -- you can go 
ahead and Google them. 
These are purpose that Google 
released which spanned upon the 
OpenOpenSource implementations 
in a period of time. 
    So we are kind of pushing 
the boundaries in terms of 
managing the huge data by end of
 that, the infrastructure is 
built on the microservices 
architecture. 
    Giving you perspective,
 there is our implementation of 
Container Engine. How to 
orchestrate these containers. So
 it is there for ten years. And 
this is the way we used to run. 
And we started running, we 
create 2 billion containers 
every week and it is growing. 
    Now, how we can achieve that
 is, essentially, how are we 
going to achieve that? Is, 
basically, all this -- I show 
you the architecture of how the 
bog looks like and how a simple 
command can translate into a 
working piece of coding. 
    Let's establish why you need
 containers here. First of all, 
they're fast, they're portable 
and quite efficient, and they 
can run anywhere in their 
elements. This takes away the 
concept of deployment hell. 
Deployment hell means, I'll give
 you a back story. 
    For example, if you remember
 a ship company where it 
WACHBTeded  wanted to transport 
a huge number of goods from one 
place to another, it has to pack
 those goods according to how 
they are created and how they 
have to be packed right. 
    That's the biggest issue 
because to create that and the 
actual transport, the packaging 
has to be aligned with the 
goods. If you remember the 
latest shipping, which is a 
container, this container allows
 you to put any sort of -- you 
can manage any sort of goods in 
there, close them, give it to 
the shipyard, they will 
transport it. They have a common
 mechanism to transport it. So 
the same isolation -- take the 
same technology, put it in the 
code. You, as a developer, pack 
your code, put it in a 
container, give the develops 
guy. And on any infrastructure, 
any hardware. That bridges 
friction between the developer 
and the person who wants to 
deploy as well as a developer 
who has complete control on how 
it is code without getting 
changed over a period of time. 
    These are the advantages 
that you get out of the 
Containers. But do you think 
everything is green with the 
container? No, there are some 
limitations for this. The 
biggest limitation is how do you
 deal with multiple servers? 
    There are a huge number of 
servers where the containers 
have to be maintained. How do 
you deal with multiple servers? 
What if a server fails? What if 
the container fails? How do you 
define what a container failure 
is? You keep on scaling it out. 
The container, itself, will 
become messy. 
    You can scale them up, what 
if they fail? Or how do you 
scale up on a cluster? These are
 some of the challenges always 
comes with -- using containers. 
The solution for that is manage 
the containers. How do you 
manage it? It's very difficult. 
    Let's create a program which
 can manage the container is 
what is essentially
 container engine.
Something which can orchestrate 
the entire suite of containers. 
Kubernetes and Google
 Container, Kubernetes Engine, 
you can run in your lab, it's 
100% opensource framework. But
 Kubernetes Engine is a service.
You don't need to worry about 
the master note. I'll explain 
what that means. 
    Look at these two analo
analogies.
One is maintained and managed by
 Google. Second one, you can run
 off your own by managing your 
own. If you go back to the 
history, this is the precursor. 
If you look at this Borg. It was
 clear that the architecture of 
Borg. So let's take -- let's 
imagine. Let's imagine this is a
 data center and you P wanted to
 have dozens of applications 
running here. How do you -- you 
just, as a developer, you wanted
 to deploy a &quot;Hello, World&quot; 
application in this data center 
where that application of that 
particular microservice
 will use one tenth of a CPU. 
The way we started writing this 
kind of deployment is using 
simple code.
This piece of code will tell 
Borg master, go ahead and deploy
 10,000, whatever the number. 
Deploy these instances of 
microservices on the cluster of 
data center where it has to use 
ram and KRRVGS 
 CPU of .1. The master will go 
ahead and clear it. It's so 
easy. You don't need to worry 
about how you have to, you know,
 manage that entire
 data center.will go ahead and 
clear it. It's
 so easy. You don't need to 
worry about how you have to, you
 know, manage that entire data 
center. 
This is how it looks like. A 
binary, a piece of code that 
your architecture is built on. 
You take the binary, have a 
configuration file, which talks 
about the
 binary. Which is repository, it
 will be given to the Borg 
master. The Borg master will 
take the binary and deploy into 
the notes. Every mode here, the 
bottom four presented here, 
every mode
 is an OS. And every mode has a 
Borglet, a kind of program that 
can listen to the BorgMaster. 
You have suite of missions down,
 deployed by -- 
which has Borglets and instruct 
on it. The Borglets will take 
care of listening to the master,
 where it can deploy the notes 
and start running them. 
    This is how we were able to 
achieve the same small piece of 
code which I showed you in the 
earlier slide. This slide, which
 we have passed on to the 
Borgmaster. Will start deploying
 a number of microservices 
directly. 
    Now, once it happens, the 
Borgmaster starts applying all 
over data center. You don't need
 to worry about scaling it down.

configuration what size it has 
to be used. As simple
 as that. 
Now Kubernetes is a container 
orchestration engine which 
supports multiple clouds. And it
 is inspired by Borg, which I 
just showed you. 
    So the Borg, which is used 
by Google the same, I show you 
an analogy. The same, actually, 
the architecture is sticking 
out. It's completely Open 
Source, it is donated to Open
nSource
 community. Don't manage your 
machines, manage your 
applications well. 
    So Cloud Native Computing 
Foundation.
 Essentially, sorry -- 
containers individually, you 
have to orchestrate, you have to
 monitor them, you have to 
distribute them. There are so 
many Open Source projects which 
are formed in the Cloud Native 
Computing Foundation. Which is 
part of orchestration. 
    So right now, the Kubernetes
 is using 1.8, it has 4,500 plus
 contributors and
 there are a huge number of 
parameters to it.
    If you are using -- if you 
are building your apps in 
Kubernetes, there's a high 
chance that the same app can be 
run on a multi-cloud 
environment.
 So 10,000 foot view, if you 
look at Kubernetes at a high 
level as an end user, this is 
how it looks like. You have a 
Master Note. Going to talk to 
the developers, and the notes 
are essentially machines. 
And if you look at the machines,
 it's installed with cubelet, 
which is a service designed to 
talk to the master. And the 
users can talk to the master
 using API, CLI and user 
interface, you can use APIs and 
call with that. 
    If you look at the four 
pieces in the master, if it is 
this kind of a database where it
 can store the contain. The 
notes which are available, 
schedulers, which schedule 
desired configuration and 
controllers, actually. 
    Now, let's come to how the 
same level of Borg translated to
 what Kubernetes looks like. You
 take the image, build as an 
application, which is a docker 
image. A GitHub repository and 
push a configuration file to the
 master, the configuration file
 is written -- everything in
 Kubernetes is -- written in 
yaml file. A way to do the work 
for you. So the master note, the
 yaml file is taken. And then, 
according to the yaml file, the 
individual services will be 
pushed across. 
    Again, those services are 
taken away from the data private
 repository you have. The 
declaration happens on the top 
of it where the configuration 
file is a yaml file. Once the 
declaration is made and pushed 
to Master Note, with the help of
 Scheduler, actually, goes ahead
 and pushes the services into 
different machines, which are 
hard machines and keeps running 
them. 
    As an end user, all you need
 to KEAFR about is you make an 
API 
call. Or
 command line. Just understand 
how many command lines you ever 
and creating a Machine of your 
own. 
    Before I go into Deployments
 and Rep command line. Just 
understand how many command 
lines you ever and creating
licase, the smallest
 commodity is a prod. 
Essentially, if you look at, you
 are the end user, that's a 
Kubernetes Master. Which is 
going to create an orchestra of 
parts. You don't need to create 
prods yourself. They are created
 using replica sets. Replicaset 
created with original units. 
    So just to make you 
understand, container is
 runs as monoservice, 
encapsulates the containers, one
 or multiple containers, the 
same application said there will
 be deployments which actually 
creates application sets. 
    Your job is to create a
 template which archives all of 
the facts and using the command 
and sending it so the deployment
 will be created. 
    The kubeset command with the
 name of the app with deployment
 that looks like this, it keeps 
on with replicates of three. And
 the application name as my app 
with the version v1, it creates 
three services or three 
instances, which is a 
configuration of the version v1 
application of my app. What if I
 change the replicas to four and
 create one more? All you need 
to do is focus on the yaml 
template, update it, send it to 
Kubernetes, it'll replicate 
that. If I have three services 
and kill one of them. Any 
hardware failure, any service 
level failure is already taken 
care. 
    Now, let's -- you wanted to 
upgrade this. You P wanted to 
upgrade this to V2 version, you 
need to have an upgrade command,
 which actually starts creating,
 which is V2 which slowly kills 
the V1 and starts upgrading v2. 
    You have in place, your 
application is moved. The 
services will get updated. Now, 
if you
 look at the model, they're 
bound, by the way. How
 do you manage them? How do you 
communicate them? Their services
 are essentially provides a 
stable IP address and solutions.
So these services will 
essentially help you to 
communicate to three different 
parts. Intercommunication. And 
they also can be used for 
actually having them communicate
 to external users. 
    So each microservices can be
 individually -- and this is how
 the diagram looks like if a 
monolithic app can be converted 
into different services, which 
are containers and servers in 
them will be easy to 
communicated, not all perfect 
between the services there. 
    So essentially, the right
 architecture is you have the 
Kubernetes will help you to 
schedule our orchestra, the 
containers. The containers are 
easy to services. And take your 
monolithic app, break it into 
pieces so that it can be very 
well managed. 
    Now, I show you
 the exact look of what a 
Kubernetes Engine looks like. 
It's the same Kubernetes servers
 on your local machine. So 
Google has its own manager 
container engine which is called
 Google Kubernetes Engine which 
has all of the features BIMT 
built into it. 
Built for containers.
 The development optimizer for 
containers. You get a private 
repository. You will get fully 
managed service. It's a fully 
managed service and support. 
Other than that, the best way to
 create is go to
 Google cluster, create a 
cluster
 and just key in your details.
 Select your -- 
where you want to deploy this 
cluster. And what is a machine 
type you need? You can custom 
your machine
 types. And I want, maybe, 7, 
whatever the size you want.

 will create you a cluster size 
of 7, which we entered there. 
And every virtual machine has to
 code and it creates a cluster 
of its own with the master note 
is manageable to the cloud. You 
don't need to worry about 
whether the master goes down. 
The master is managed and the 
cluster comes in. The results of
 configuration, which means,
 if you figure it, the 
configuration where you can have
 almost all of the clouds 
connected. 
    You can deploy your 
microservices in every cloud 
using Kubernetes.

 out of
 time. So in a nutshell, Google 
Container of Kubernetes Engine 
will provide you a cluster in 
seconds. It's
 designed for multicloud as well
 as you can use with no 
additional cost for that. There 
is a free tier. Anyone who is 
interested, go to the Codelabs, 
search for cloud and search for 
Kubernetes in
 this. You get a step-by-step 
approach of how to create a 
container engine, basically, an 
application and a few clicks the
 entire process is actually 
given here. 
Screenshots. Go out and try 
this. You will see how easy it 
is to create an entire 
microservice architecture 
service on Google Container 
Engine in a short
 period of time. 
    And thanks for coming here. 
And I'll be there later on. Feel
 free to come talk to me. Thank 
you.

Hey, everybody. I'm Wesley. I'm 
happy to be here to talk to you 
guys. 
Oh, first, I should say, welcome
 to our session. This is -- 
we're getting close to the end 
of the day. How are you guys 
doing so far? Are you learning a
 lot? 
Awesome. All right. I have to 
take a picture because I have to
 prove to my boss I came here 
and talked to you guys. 
Otherwise, they're not going to 
pay me. 
Smile. Everybody look like 
you're happy. 
    Awesome. All right. So first
 thing I want to tell you guys 
is this is a big
 bait-n-switch. Who have heard 
of Google App Script?
Normally it's 1 out of 10 or 3 
out of 10, but this was almost 4
 out of 10. Too bad for the rest
 of you, that's what today's 
talk is about. 
    However, you'll also learn 
how to extend Google doc, 
sheets, forms and with add-ones.
We have 30 minutes and I have 48
 Slides. Let's go. 
    By the way, if you guys look
 -- if you have any extra 
questions, feel free to drop 
them in the booksing do  -- my 
main goal is to help you become 
successful at using the 
developer tools and APIs. 
    Some of you know I have 
videos from time to time and a 
lot of the samples I'm going to 
show you today, there will be 
video so you can actually watch 
individual video on a specific 
example that is interesting to 
you. I'm also a contributor to 
the blog and the Twitter handle.
    I look forward to keeping in
 touch with you guys online even
 if I'm not guilty physically 
here. 
    My background is, I'm a 
software engineer, I was one of 
the original engineers that 
built Yahoo Mail. I'm a teacher,
 as well, too, and I'm happy to 
be talking to you guys today App
 Script as well as Add-ones.  
I'll show you what kind of 
things you can do to automate 
and extend G Suite and I'll talk
 about various use cases and 
apps that people have already 
done. 
    All right. So what is Google
 Apps Script? And what is it 
not?
We have lots of secrets, right? 
Well, you know, it's not really 
our best kept secret, nor is it 
really a secret at all. But I 
think it still has relatively 
low mind share. That's why I 
asked who have heard of it 
before. 
    So what is Google Apps 
Script? Here are our original 
and our new logos. And the new 
design hints that app Script is 
like a Swiss army knife. It's a 
tool based on JavaScript but 
less like using APIs and more 
like using services or built-in 
API access. 
    And because of that, you 
don't have to worry about more 
mundane things like writing a 
lot of code. To help with this 
understanding, let's talk about 
what App Script is not. It's not
 something completely different.

isn't that much new to learn. 
Even a Python guy like me knows 
some JavaScript. 
    But it's also not your 
daddy's JavaScript. Meaning, 
it's not client side and doesn't
 run in the browser, 
necessarily.
You're not going to use it for 
manipulation or form validation.
There are some exceptions, of 
course. 
    But what are you going to do
 with the browser? Well, the 
only thing you'll do with the 
browser is edit your source code
 in it. 
That's generally the case with 
App Script. If you're familiar 
with Node, it's like Node 
because it is server side. 
However, you're not running 
asynchronous event-driven code. 
Instead, your applications are 
going to run in the same Google 
data centers that power Search 
and YouTube and Gmail and all of
 the other services you're used 
to using. Your apps will be 
running on the same machines. 
    In fact, that will give you 
access to resources that you 
can't get with a regular Node 
server, right? Being able to 
talk to your Google Apps, access
 the data and things like that. 
    That's really where the 
power comes in. So if someone 
was to ask you or ask me in one 
sentence, how can you describe 
what App Script is? It's a 
serveless JavaScript run time 
for G Suite automation, 
extension and integration. 
    And then, we'll look at 
examples of each of these so you
 can see what I mean by that. 
What kind of things can you do 
with App Script? It can be 
something simple like a function
 in a spreadsheet or a complete 
web app that does lots of 
different things. Many, many 
lines of code. And, of course, 
everything in between. 
    Now, let's look at 
Automating and Extending G Suite
 and then we'll talk about 
add-ons. So the Google services 
you see on the screen here, 
you'll see, yes, there are some 
Google Apps and G Suite ones, 
but there are ones that are not 
parking lot of Apps or G Suite. 
They are Google services, but 
not part of G Suite. 
    This gives you a hint as to 
the fact that App Script can do 
a lot more than just deal with 
apps and G Suite. There's plenty
 more. 
    Each one is a single 
JavaScript class. You see I've 
highlighted a couple of them 
here. One is for Google 
Calendar, one is for Google 
Docs. Whenever you see something
 with app after it, that 
generally indicates this is a 
service. Notice, again, it's not
 like using an API as much. 
Instead, it's like an object 
that's already there. The 
example from the page in the dox
 is for Google Slide. You can 
create a new presentation. It 
uses Slides app. That's how you 
access Google Services. One 
JavaScript class and you have a 
whole bunch of methods you can 
call to access those particular 
document types or those 
services. 
    All right. Everybody good so
 far? All right. Good. What is 
the list of all of the things 
that you can do with App Script?
Well, all of the stuff you know 
on the left-hand side, including
 ones you probably don't know. 
Then, you can also talk to the 
other Google Services in the 
middle column. 
    And finally, we don't want 
to constrain you, right? Maybe 
you need to leave Google, right?
Access services that are 
available online somewhere else.
Somewhere in your data center, 
something that belongs to your 
company. Or maybe, it's a public
 service, right? That's why you 
have URL, so you can send a get 
request and post request and 
talk to other apps online. 
You're not restricted to just 
doing everything from within a G
 Suite environment or Google 
environment. And similarly, if 
you want to talk to an external 
database, you can use a JBC 
service. 
    What kinds of App  Scripts 
are there? Stand alone scripts 
which are exactly what they 
sound like. Just regular code 
that sits out there and runs and
 does stuff for you. 
    Then, we also have add-ons 
and document-bound scripts. 
Generally, if you're in an 
editor, you pull down the tools 
menu bar, and then, there's a 
selection called Scripteditor. 
And then, you pull up the Code 
Editor for App Scripts for that 
document. And then add-ons also 
from that pulldown. And then, 
finally, the last type of App 
Script are the simple web apps 
and gadgets that run under 
Google sites. These are the 
three main types. We're really 
focused on add-ons and document 
bound scripts. We're just 
focussing on the topic at hand. 
    Okay.
So document-bound scripts. Open 
up Google docs or sheets and 
pull down Scripteditor. Those 
tied to specific documents, like
 a doc, sheet or form. 
    You're going to have method 
calls that are unique to those 
document
 types. It doesn't make sense to
 do that for docs or things like
 that. Same thing for create 
presentation, only works for 
Slides. You can't create a 
slide, a presentation in 
spreadsheet and things like 
that. 
    So those are document bound.
Now, add-ons are a specific type
 of document-bound script. And 
Gmail is special. Gmail are not 
tied to documents, but instead, 
individual email threads. 
    So what are add-ons, again, 
they allow you to extend 
existing G Suite applications or
 allows you to embed the 
functionality in your app inside
 ours giving your users that 
access where, oh, gosh, I don't 
have to exit my editor to go 
access this app. I don't have to
 switch browser tabs. I can 
actually get the functionality 
from your app directly inside 
one of Google's editors or 
Gmail. 
    So the add-ons that we have 
launched in 2014 for Google 
docs, sheets and forms. And 
then, just nine weeks ago, we 
released Google Slides add-ons. 
And five weeks ago, Gmail 
add-ons. I'll have more examples
 for the last two because 
they're the latest hotness. But 
I'm also going to show you 
examples of the other types, 
too. Just so you can see the 
variety of things you can do. 
    All right. So let's say 
you're new to App Script. Let's 
get everybody else up to speed. 
When you create a brand new App 
Script project, you get this 
panel you see here that gives 
you pre-defined codes, 
boilerplate code in case you're 
writing those specific types of 
add-ons. If not, choose blank 
project. 
    So that's first experience 
that you have. And then, once 
you get past this, then you get 
dropped into the editor. And so,
 your first &quot;Hello, World&quot; 
application will look something 
like this. I'm in a spreadsheet,
 I pulled down &quot;tools,&quot; &quot;script 
editor,&quot; &quot;blank project&quot; and 
type in this one JavaScript 
function so you can see each 
piece one at a time. 
    I have a generic function, 
it connects to the spreadsheet, 
and one of the commands I want 
it to do, get the current active
 sheet I'm on and looking at 
that spreadsheet in my computer,
 I want to access what is in 
cell A1 in the upper left-hand 
corner and what I want to do 
with that cell. I want to set 
the value of that cell to 
&quot;Hello, World&quot;. 
    So once you save this and 
run it, notice there's no 
authorization code. However, 
when you run the script, guess 
what. Your users still have to 
give permission to your apps to 
be able to access their 
spreadsheet. It's their personal
 data, right? They still have to
 go through the authorization 
process. But you didn't have to 
write any off code because that 
part is built in already. That's
 one of the useful things about 
using App Script. It's more user
 friendly or developer friendly.

 code to manage getting access 
token in order to be able to 
access user data. 
    This is definitely one of 
the benefits for developers is 
they don't have to
 worry about. 
And once the user clicks allow, 
giving code and you're going to 
expect that that text is going 
to show up in the spreadsheet. 
Okay? It's almost like magic. 
When it happens the first time, 
it'll make you smile. All right?
And that's the best part about 
it. You feel you've gotten 
something done. And now, your 
mind is going to wonder as to --
well, if I can do this, think of
 all of the other things I could
 build with it, right? It's 
really, really exciting. 
    If you want to review this 
simple &quot;Hello, World,&quot; of 
course, I have a video. It's 
what I do for a living. I don't 
have a private life anymore. I'm
 here to make you guys 
successful. That's my job. 
    All right. Let's look at 
this one. What can we do with 
this? That's an address, right? 
Happens to be the address of the
 Google New York office. But you
 know, maybe you want to invite 
your friend here for lunch. What
 can you do with it? 
    Well, we know we can talk to
 a spreadsheet. The universe is 
big within Google. For example, 
I could say, hey, you know what,
 I'm going to talk to that 
spreadsheet, again, the current 
active sheet I'm on. And this 
time, I'm going to look at cell 
A2, which we can see is the 
actual address. What do we want 
to do with A2? We're going to 
get its value, save that 
address. And then, I can say 
Google Maps, can you create me a
 brand new app and put a pin on 
that address? Cool, right? 
    And furthermore, maybe you 
want your friend to come to 
lunch here at the Google Office,
 right? I can then say, hey, can
 you send a link of this map to 
my friends so they know where to
 come for lunch? 
    And that's it. You've got a 
four-line JavaScript 
application. Four lines. But it 
touches three different Google 
products. Spreadsheets, Google 
sheets, Google Maps and Gmail. 
It's not exactly a 
mission-critical app, right? But
 it does show you that you can 
use multiple Google services 
simultaneously to write tools 
that are somewhat useful or 
could be very useful. 
    Of course, there's a video 
in case you want to review this,
 too. Once you can do something 
like this, where can you take 
this? Well, guess what, maybe 
you're a salesperson. Maybe you 
have to visit all of your 
customers in the New York area. 
Well, guess what, I don't have 
to have just one address. I 
could have four addresses for 
all of my customers. Then, I can
 kind of plan out where, you 
know, which way I want to go. 
    And then, guess what, I have
 access to Google Maps drivng 
directions, too. If I have to, 
you know, drive or have to bike 
or walk, I can get that stuff 
progressmatically, as well. And 
maybe have a monthly book club, 
maybe meets at a different 
location every month. Maybe want
 to tell everybody, hey, this 
month we're meeting at this 
location. 
    Or maybe I have a user group
 that meets once a month in a 
different location, right? You 
can kind of, like, imagine what 
kind of things you can build 
with just a little bit more code
 than the example that I showed 
you guys. 
    In fact, one of the other 
things you can do is maybe you 
can ask your membership, who is 
coming, right? Maybe you have a 
Google forum. And as soon as 
they submit the form, then maybe
 then you know they're coming 
and you can email them the link 
to the map of the
 location. Why bother mailing 
400 people if you know only 200 
are coming. That's like another 
use case. Another way to extend 
this particular type of 
application.
 All right. 
    Let's say, I have a bunch of
 images for brevity sake. Let's 
pretend they're all online, but 
they could be somewhere else. 
You could have a zip file, a 
Google file folder full of 
images. Let's pretend I've got 
the four images online and I 
want to build a slide deck with 
these images.

 Slide Service we launched nine 
weeks ago. Taking each one of 
these images and building an 
individual slide for each one. 
You can see that in the 
presentation that it's been 
created based on the images that
 you see on the left-hand side. 
How do we do something like 
this? How complicated is this 
code? 
    It's not that complicated. 
In fact, I would say this is 
only about six, seven lines of 
code. If you don't count the 
data because I have a whole list
 of images on the URLs. If you 
don't consider those lines of 
code. Well, you really only 
havehave, you know, our main 
body has four lines of code 
here. All right. 
    And I'm just going to walk 
you through each line really 
quickly right now so you can get
 an idea of what it does. 
Everybody knows when you create 
a new Google Slide Deck, you get
 the title page. Title and 
subtitle. The whole purpose of 
the first three lines is to fill
 in the name of the 
presentation, which comes in the
 name variable and then, the 
subtitle down here, which is 
Google App Scripts live service 
data. So fill in the title L and
 subtitle on the slide. There's 
the title, there's the subtitle.
 All of the other ones are 
added. 
    So once we have that, then 
we have a four loop that loops 
through all of the images in the
 array. And for every image 
calls the add image function and
 inserts that image into that 
slide. And now, you have
 a SlideShow. And, of course, 
there's a video. 
    That's one example. So what 
we've seen so far are 
document-bound scripts. We have 
the &quot;Hello, World&quot;. We have the 
Maps and Gmail example. Those 
are tied to a Google Sheet. They
 are document bound to a Google 
Sheet. And we looked at the 
creating of a SlideShow. 
    How do we convert those 
document-bound scripts into 
add-ons? That's the whole 
purpose of this talk. And why 
would you convert something to 
an add-on. It's really hard to 
share that code. 
    You can't -- you'd have to 
cut and paste it or somehow copy
 the document. That's really not
 distributable, right? 
    If you turn things into an 
add-on and put it in the 
marketplace or the Chrome 
webstore, others can find your 
app and install it, perhaps, for
 their entire companies. 
    You can actually make a 
living writing software to help 
companies be more efficient. And
 one of the things you have to 
do to convert a bound script to 
an add-on are a couple of 
things. 
One is, what happens when this 
document is opened? You have to 
add in unopened. What happens 
when this add-on is installed?. 
Generally, just calls on open. 
And then, if you want to further
 modify the user interface, you 
can add a side bar so that your 
users can see your app on the 
right-hand side within the same 
document or the same spreadsheet
 or form. Those are the key 
things you would need to 
implement on top of the existing
 code. 
    Everything else on the 
bottom there is whatever we had 
before. All the code I showed 
you before. The &quot;Hello, World,&quot; 
the Gmail and the Google Maps 
example and creating Slides, 
those things are part of a 
document-bound script. All you 
would do is add these things. 
    And then, the other thing 
you need to be careful about is 
understanding the authorization 
life cycle. And the reason for 
this is because companies may be
 installing your code, right? It
 would make people nervous if 
all of a sudden when they opened
 their document there's this 
weird add-on that was added to 
their, you know, document, 
right? 
    There's a slightly more 
complex authorization life cycle
 that you need to understand. 
What happens is, when that 
add-on first runs, it doesn't 
have full permission to do 
everything. Okay. You have to 
wait for the user to sort of, 
like, opt in to be using this 
particular add-on. 
    Just because it's installed 
doesn't mean it's been enabled 
for usage. If you are going to 
be creating lots of add-ons, 
learn the life cycle well so you
 understand what things your 
script can and cannot do at what
 times. 
    Once you get past that, 
you'll have an add-on and upload
 it to the G Suite marketplace 
and people can find it. You make
 a logo, you make a description.

people install your add-on? Why 
is it useful? Keep those things 
in mind. Even though you're 
developers, part of your brain 
has to think, what do I do 
marketing wise? How do I get 
people interested in my add-on? 
And encourage them to install? 
And how can I make their lives 
easier? That's the main thing. 
    Let's talk about Gmail 
add-ones now. Gmail are a bit 
different. Let's say your 
company sent you here for work. 
Maybe you booked an airline 
reservation, maybe a hotel 
reservation and maybe you're 
catching taxis every day or Uber
 or whatnot. 
    We know the email receipts 
are coming into our Gmail 
because we see them as they 
happen, right? And if we're 
going to have to create an 
expense report and, you know, 
get reimbursed by our companies,
 it's kind of a burden to have 
to look through all of my 
receipts, copy down the 
information, go to my separate 
expense reporting app, fill in 
all of that information and 
then, submit to get reimbursed, 
right? Can't we just do the same
 thing without leaving Gmail? 
Can't I process my expenses at 
the same time I'm looking at the
 receipt? And can't I do it on 
the web and mobile without 
writing two separate apps for 
this? Those are the key 
questions that drove the product
 team to creating Gmail add-ons 
for everyone. I'm happy to say 
we can do this now.
You can actually make this 
little form show up right in 
your Gmail. 
    In fact, I hid it so you 
couldn't see it before. This is 
exactly what it would look like 
if you were on your computer and
 actually brought up this 
particular add-on that my summer
 intern wrote this summer or 
this past summer where it could 
read the contents out of your 
email message, specifically, the
 receipt. It can pull out the 
date of the transaction, the 
amount and a description. All 
you need to provide is a 
spreadsheet URL. And when you 
click &quot;submit.&quot; Oh, by the way 
-- it would be great if I could 
do it on Mobile, too. So I don't
 have to wait to get back to the
 office. I can do it while I'm 
sitting in the cab. 
    That's the one cool thing 
about Gmail add-ons is once you 
write it, it'll work on the web 
and in Mobile. And you don't 
have to write any other version.
Right? Just one piece of source 
code. This is the exact same 
receipt but on an android 
device. 
    Anyway. Once we have this 
and click submit, we get the, 
you know, &quot;my form has been 
successfully submitted.&quot; And 
then, when you go to the 
spreadsheet, you have one place 
that you can leave it up and do 
your expense report straight off
 from here. 
    That's really the main 
reason behind this. The code is 
going to be a little bit larger 
because Gmail provides you the 
ability to add your own user 
interface. For us, we had that 
little form. 
    It takes a little bit to 
create the user interface and 
build the code that runs behind 
it. Here is one kind of quick 
view of building the expenses 
form. 
    You can see all the source 
code in the video and we've also
 made this example available on 
GitHub so you can download the 
entire app and study it and 
implement it and change it and 
all of that kind of stuff. 
Everything's available for you. 
    It's also available as the 
Codelab. If you want to do how 
to do add-ons. You can build 
this example line-by-line. Maybe
 not line-by-line, but chunk by 
chunk. You can build this app 
for yourself. And then, you can 
take this as motivation to 
building your own Gmail add-ons.
So that's called ExpenseIt. 
    Now that I've shown you guys
 the technology, what have other
 companies done before you? What
 are some of the other Use Cases
 for App Script as well as 
Add-ons. Something like business
 work flows, controlling 
resources, automating THICHKs 
that normally take a lot of 
effort to do as a human. 
Building dashboards and other 
reporting for managers. 
Integrating with other third 
party tools. 
    You know, because for G 
Suite, we can't provide 
everything for
 you. We have to document 
editor, spreadsheet, 
presentations, we don't have a 
CRM, we don't have, you know, 
payroll and HR apps. We don't 
have that kind of functionality.
These are the kind of things you
 can bring into your G Suite 
environment by using the third 
party integrations. 
    And then, if you are a G 
Suite or Google apps domain 
administrator, you can use the 
tool to do a lot of stuff. Next 
week, you have 100 new 
employees, you don't want to 
create each Gmail account one at
 a time. It's good job security,
 but you're probably going to be
 burnt out pretty soon. 
    Those are the kind of things
 you can do with App Script. 
Teachers really, believe it or 
not, they like to write teacher 
tools that help automate, you 
know, instructing students. So, 
for example, there's a 
well-known App called Flubaroo. 
If they're creating an exam and 
all of the students submit the 
answers into a spreadsheet, the 
teacher can submit their own 
answer, which is the answer key,
 right? And then, the tool can 
actually grade everybody else, 
all the students' results based 
on the teacher's answer key. 
    Tools like that are very, 
very useful. Okay. And then, 
automation, like Mail Merge. So 
many different types. Like form 
letters and Google docs, your 
email addresses and Google 
sheets and sending these through
 Gmail. Three different Google 
products but all supported by 
App Script. 
    For my team, everybody's 
going on vacation a different 
time, right? What happens is 
everybody has their own out of 
office and their calendars, but 
then we have an App Script code 
that builds a teen vacation 
calendar, you can look at one 
calendar and it tells you when 
everybody is out of town. That's
 a useful thing, too. 
    All right. And then, of 
course, you can go to the G 
Suite Marketplace and look at 
the apps available for you and 
see how many users they have. 
Your app can go viral if 
companies install it. That's one
 -- another motivation as to why
 you guys should consider 
writing add-ons. And a big 
company like 
Lucidchat, they have a web app. 
Maybe I want to have these 
diagrams incorporated into the 
slide decks. Pretty awesome. 
    All right. Now what else do 
you need to know? May have heard
 about appmaker. It's a tool 
that you can drag and drop web 
components or UI components like
 a text box, a dialogue window 
and it automatically generates 
App Script code. You can modify 
and modify your apps. That's 
pretty
 powerful. 
    Keep that in mind. It's a 
little bit outside the scope of 
this talk. But overall, what I 
hope to impress on you the last 
half hour is that App Script and
 Add-ons are just JavaScript. 
Gives you access to Google 
services and other online 
resources. It's not like an API.
You don't have to worry about 
authentication and things like 
that. It's like built-in 
services. It's serverless. It 
runs in Google Data Centers for 
you. You can extend G Suite with
 add-ons or integrate your app's
 functionality and further 
customize applications. 
    And hopefully, after today, 
it's no longer our secret. If 
you want support, we have Stack 
Overflow, an issue tracker. 
Other things you can do, we have
 a Codelab. Come join me 
tomorrow. I'll show you a slide 
in a moment. We can do Codelab 
together tomorrow. Whole bunch 
of videos, docs and use our rest
 APIs if you want. Come join me 
tomorrow. I'm doing a hands-on 
training, one is App Script, the
 other is using REST APIs. And 
if you're a Python person, I'm 
speaking at the Bangalore Python
 users group. Hope to see you 
more later this week. Thank you 
very much. 
[ Applause ]
    If you have any questions, 
just I'll be just down here or 
outside or if you have extra 
questions that you remember or 
don't remember until later, feel
 free to drop something into the
 doc. That's it. All right. 
Thank you, guys,
 take care. 
   THOMAS STEINER: Hello. NAM
 took some practicing and the 
mic wasn't working. Here I am. 
Thank you very much for joining 
up really late or showing up 
really late. I'm the last talk. 
    And the title of my talk is 
What's next for the Web. Or 
exploring about://flags. I work 
as a mobile solutions consultant
 based out of the Google Hamburg
 office. 
    So before we get started, 
here's a quick warning. There's 
a lot of content coming and I'm 
going to speak fast, probably 
even too fast. Hold on to your 
seats, and watch out for all of 
the links. 
    On the Slides, there's 
links, so take a photo and write
 on the links. So you can catch 
up Java
 afterward. 
    Let's get started on the 
first topic, which is 
Progressive Web Apps. And 
something that is immersive, 
full-screen PWAs. Your PWA 
deserves a lot of screen real 
estate. 
    Some of you may remember an 
app called Paper Planes.world. 
It's a full-screen PWA. And the 
cool thing about it is if you 
pay close attention, there's 
something missing, which is, the
 top bar with the WI-FI signal, 
the clock and so on. It's a true
 games, true, fully immersive, 
full-screen experience. How do 
you get that? It can offset the 
display property to full screen 
and your app will be rendered in
 a full-screen view. 
    This is not always useful. 
But if you write a game, create 
a game, it's definitely 
something you can try out. 
    Something else in
 the area real applications on 
people's phones. With the new, 
improved home screen flow, users
 will be able to add the 
application directly to the home
 screens and find it in the app.
 It'll show up between the other
 Native Applications. And if you
 update the web manifest, you 
can change the icon and the name
 and it'll be reflected directly
 on people's phones. 
    And with the improved flow 
on the manifest scope and 
Android Intent filter is being 
created. And defines when the 
apps should be
 opened. I'm receiving a chat 
message, clicking on the chat 
message, and then, the 
application opens.
    The Web Share API is 
sharing, caring, definitely. 
Sharing is caring. We should 
make sharing easy. In 2017, if 
you look at publisher sites, 
they commonly look like this. 
You have a lot of screen real 
estate wasted for all the 
sharing buttons. 
    And obviously, if you want 
to share it, always one social 
network you would want to share 
the article is missing. That's a
 problem. And also, as seen 
before, sometimes if you have 
full screen PWAs, there's not a 
URL bar you could quickly copy 
the URL from. What can we do 
about that? The answer is the 
Web Share API. It opens the 
native sharing dialogue directly
 in the android phone. And it 
has a very simple API that is 
province-based, a title, text, 
and a URL. And then, people can 
just share it. 
    You can see here, the native
 share dialogue opens and you 
can select whatever networks you
 want to have there. It's all 
customizable by the user and it 
will always be the same for all 
web pages. It's not dependent on
 the website, it's dependent on 
you as a user. 
    Next topic is Web Push 
notifications. And luckily, now 
finally on Mac OS, no longer an 
alien. Before, artificially 
graded and I had this not really
 native-looking feel. And now, 
finally, just integrated 
directly in the control and 
notification center. Which also 
means, they respect the do not 
disturb settings. Something we 
really found was a pain in 
people's set-up. Do not disturb.
And seeing all of these 
notifications. Now, they just 
respect the operating systems 
and do not disturb
 settings. 
Navigation 
Preload. -- this is about 
waiting for the service worker 
to boot. What does this mean? If
 you have a PWA at some point 
needs to boot and start the 
service
 worker. This can take some 
time. And actually, if you are a
 big site with a lot of users 
and a lot of views. And if you 
are a site that is active on 
many tabs, like, for example, 
Facebook, where you have 
Facebook.com and a ton of 
buttons with like buttons that 
tend to connect to the service 
worker, this is something that 
can really
 harm performance. 
With the navigation preload, we 
are trying to find an answer to 
that. Essentially, the idea is 
to
 parallelize the talk. Instead 
of having them intercepting 
navigation requests, to already 
start listening for requests 
while the service worker is 
still booting and loading. 
    Speaking of code, how could 
this look like? In the service 
worker during the activate 
event; wait until the navigation
 preload is 
enabled. Essentially, start 
preloading already. And then,
 in the event, you go through 
response, you can check if you 
maybe have a preloaded response 
already. 
    So as I said, it's kind of 
complex, really, but there's 
links on the slide. So you can 
follow up after the talk. Very 
exciting feature. 
    Something that is always a 
pain is signing into pages and 
signing out for pages. And we 
have a solution for that and the
 one-tap sign-up API. 
Essentially, before you always 
had, like, do I use the log-in, 
the Facebook button? Will it 
post I'm using this app on 
Facebook? You never quite know. 
Or username and password, oh, 
mistyped, go back, correct, of 
course you have forgotten the 
password. And you have to click 
or link the forgot password 
link. 
    This can be really painful. 
One-tap sign by API, this has 
gone away. This works on all 
browsers, works on iOS, desktop,
 FireeFox. It's a new API that 
allows you to create account 
with one tab using a Google 
address and based on an extender
 called open.
 Open Yolo, if you have been on 
the page before and come back, 
you will automatically be signed
 in. 
    Like this, you can stitch 
sessions together. If people are
 on mobile and on desktop and 
use different devices but the 
same log-in, you can stitch the 
sessions together. So very, very
 useful
 information here. You can see 
the URL
 down here. First, you need to 
do some 
set-up. The supported token 
providers. You can see here. And
 then, you need to set up result
 function that will deal with 
the results when get it back. 
And essentially, there's still 
cases, there's auto sign-in and 
the auto signup. If you have to 
use it and the user's coming 
back and you can use the 
GoogleYOLO.retrieve with the 
functions a little bit further 
up. And then, you handle the 
result. 
    Essentially, you very easily
 can sign -- if you need to sign
 up, they are on a page for a 
first time and you have to 
GoogleYOLO.hint function. So the
 result is, of course, user, 
valid user, or not. 
    PWA always has the problem 
of if you have an application 
and you want to store content 
offline, is there enough memory 
left? Is there enough storage 
left? This we can finally answer
 because we have the storage 
estimation API. 
    This allows you to with just
 one call to the function 
navigator.storage.estimate, find
 out how much memory you have 
left. And essentially, you can 
get usage information and you 
get quota information to 
calculate the delta, how much 
memory can you still use? This 
can be useful if you want to 
decide should I really offline 
store? Yes or no? So I can 
dynamically decide if you want 
to do that. 
    Next big topic area is 
Media-related APIs. The first 
one is the image capture API. It
 allows you to zoom in on what 
really matters. You can see me 
playing around with the API in 
the office. I'm zooming in on 
the big nose. Essentially, it 
allows low-level access to the 
phone's hardware. If your camera
 has 
Zoom, it can access directly in 
java Script. Connected to this 
simple animation. From a media 
stream, we get
 video track. Once WEFR to 
track, we can get the settings 
and then after the settings. And
 let me get a reference to the 
query select to the input. And 
with the query selector. And 
then, we come to initialized 
input. We need to know how far 
and, yeah, minimal is the 
zooming level. We look at the 
capabilities, the zoom, the min 
and max. And then, we can set 
the value of the slider to the 
setting of the Zoom properties 
of the settings object. And 
then, essentially, all we do is 
-- the slider is being moved. So
 when the input changes, we 
apply the constraints to the 
Zoom. Really exciting. 
    The Shape Detection API 
allows to detect faces with bar 
codes and run optical character 
recognition. And from camera 
input. You can see here, I'm 
holding my phone and scanning 
the website of
 the previous -- 
and you can see on this page 
there's a bar code, text and a 
face. The camera detects this 
life and the API detects the 
life. And you can see what I've 
drawn here on the page. 
    Again, how does it work? 
Very quick, the code. And you 
have three different detectors 
you need to initialize.
A face detector and a bar code 
detector. You can use 
promise.all, the methods of the 
different detectors, and then, 
you get the -- the resulting 
faces, text and bar codes back. 
And you can then draw barcode. 
The API directly built into the 
browser. 
    The Media Session API. 
Staying in the area of media. To
 make your media sessions a lot 
more meaningful. So, something 
you encounter when you use the 
Media Session API. When you 
swipe down on an android device,
 you can see track information. 
You can see other information. 
You can see -- and like this, 
you have to -- more meaning FRL 
way of controlling your media 
directly from a Widget you can 
see when you swipe down. You can
 pause, fast forward, so on. 
There's a lot of information. 
    If you zoom in on what kind 
of information you can see, you 
have the title, the artist, the 
album, the artwork. And then, 
connecting to different action 
buttons. Backwards, previous 
track, forward and next track 
and play and pause. 
    Codewise, how does it work? 
You pass a new media into the 
object with all the things 
filled out. Looks a bit 
intimidating. But if you look, 
it's straightforward. Title, 
artist, album, artwork and 
different sizes and resolutions.
And then, you can connect all of
 the different action handlers 
to the particular events. Play, 
parse, seek, and so on to make a
 media player that's powerful 
and directly integrated with the
 Widget. 
    The media capabilities API 
is a very interesting API that 
allows you to determine not only
 if a certain device can play a 
given media file but
 also if it can do so in a 
smooth way and power-efficient
 way. You know, battery life on 
mobile devices is always a 
problem. With this API, you can 
directly find out where is a 
particular file smoothly 
playable and power-efficiently 
playable. You can dynamically 
decide, well, maybe the person 
is 20% battery only and in this 
case, you may want to ship lower
 version of a media file rather 
than shipping the super high-res
 file and also dynamically 
decide is this
 phone even able to play this 
file smoothly? Have a look at 
the code. The method here -- and
 you're passing an object where 
you essentially describe what is
 your media file like? So you 
have a file, it's a video, it's 
using the video webm. That is 
heightened with frame, you 
simply list the properties of a 
video file. And then, get a 
result back, and in this result,
 you can see not only is it 
supported at all, just yes or 
no. But you can also see is the 
playback going to be smooth? You
 have a device that's really low
 power. Maybe, you won't be able
 to play back smoothly. High-res
 video. And also, the most 
important question in some cases
 is it power efficient? The CPU 
was maxed out when playing or 
has the CPU, you know, upwards 
for doing other things
 on top. 
    Quite exciting API, going 
over to Web VR. The real reality
 sometimes is not real enough. 
WebVR allows you to create 
compelling experiences in the 
browser. A demo created here 
where you can just use your 
device and get a really 
realistic VR view of how for an 
interior designer, a certain 
piece of furniture would look 
like in your room or in a 
simulated room here. 
    WebVR makes it possible to 
experience VR directly in the 
browser so you don't need to 
download any plug-ins, you don't
 need any additional software. 
You just point people to a URL 
and they can take out their 
viewer, which can be whatever, 
and it can see directly from the
 browser in their phones how 
something would look like very 
exciting, very amazing. And 
really, I think, for some 
professions, life-changing if 
you are an interior designer, 
have a look at this. 
    And topic that is very dear 
to my heart is Performance and 
Performance-related APIs. So the
 first topic in there is the 
Network Information API. This 
allows you to know how fast you
 can go. Actually, it does allow
 you to get meaningful realtime 
network information. Today, we 
have all been on WI-FI. In 
theory, SUMP  super fast, but in
 practice. Sometimes, it wasn't 
really the best. So with the 
network information API, we now 
get not only static information,
 like, the type and the down 
link back, but the effective 
type. So today, sometimes, the 
WI-FI connection would have been
 a WI-FI connection of type but 
effective type would've maybe 
have only been 2G. So this is 
something that is, of course, 
very helpful if you want to make
 realtime decisions what to do 
with a certain, yeah, file, for 
example, or image. 
    One example where you can 
combine media queries with the 
network information API. So 
here, I'm using JavaScript to 
find out if a given device has a
 so-called retina display. 
    So I'm looking at the many 
device pixel ratio. I'm looking 
at the min ratio, or if it's at 
least 200DPI, if this media 
query matches, I know that the 
device supports retina, or a 
retina display. 
    I dynamically take the 
network information into account
 and only if the device supports
 retina. And only if the 
navigator.connection.effective 
type is 4G, meaning a fast 
connection, only then use retina
 graphics. Even if the media say
 it's a great device. It could 
support high-res graphics, I'm 
not using them because the 
network right now doesn't 
permit. It's just a quick idea 
what those kinds of things would
 allow. 
    The next thing is 
Performance APIs. You should 
care when your content loads. 
Here we have the navigation 
timing API that allows you to 
get general performance data. 
    You can see here, it's all 
available in the window of 
performance of timing object. 
Perf data then has some 
properties, like, Perf data.load
 event. If you use the 
perfdata.load, you get page load
 time. There's connect time, 
there's render time. A lot of 
useful information you can 
collect in a table and maybe 
report back to your system. And 
you get realtime user data of 
actual users. 
    You can see in the lab, 
we're simulating this and that. 
But actually, users in the wild 
are experiencing something 
completely differently. 
    It can get very easily 
realtime performance data from 
the users. 
    And sometimes, you also want
 to see how fast your page is 
rendered. And for this, you can 
get from the performance API, 
sorry from the Paint Timing API.
For example, Paint events. If 
you initialize your performance 
of server, you can then check 
for certain Paint Events and see
 when did they happen? You can 
see an observer observe and two 
types of
 type PP
aint. You can see how I'm doing 
that after the fact on this page
 here. I'm looking at 
performance.
 And then, you can see what 
information I got. I got First 
Paint. When is the first moment 
that something is paint D on the
 screen, which could be 
something as simple as the 
background color changes from 
white to blue and the first 
meaningful and first contentful 
paint is when can the user start
 reading the page, for example? 
When is an image loaded? When is
 the text loaded? Something 
meaningful on the screen so that
 the person can actually start 
consuming the page? 
    And, something else that is 
quite new are Client Hints. You 
can find out how capable a 
user's
 device is. They are especially 
useful on low-memory devices. In
 the Chrome team, they've done 
-- yeah, they have essentially 
figured out by using reports 
what kind of things happened and
 what kind of things led to 
crash reports. 
    Out of memory crashes than 
on a lot of low-end devices that
 have very limited RAM, 12 
megabytes or even, sorry, 1 
gigabyte of RAM. And if you know
 you have a low-powered device 
with less RAM than high-tier 
devices, and then, it can decide
 dynamically to serve only a 
light version of your page. 
    So service can advertise 
support for Client Hints by 
using the accept-CH. And it can 
list all the different device, 
the different Client Hints. For 
example, device memory. And on 
the client, then, the client can
 then report back to the server 
and say, my device memory is  
.5, for example.  .5 gigabytes.
And like this, dynamically, you 
can decide on the server, but 
it's a light device. Maybe I 
should be only serving a light 
version of my page. 
    It can also access this 
information from JavaScript. If 
you navigate.device memory and 
also get information about the 
number of cores that it has. 
Navigated concurrency. And you 
can see a low-powered device 
with .5 gigabytes and only two 
cores instead of maybe four
 or eight. 
    In the end, everything we do
 is powered by JavaScript. 
Something that is really amazing
 is Dynamic Module Imports. They
 allow you to really truly 
lazy-load JavaScript code. 
    For example in the code, you
 have a button. Unclick, 
dynamically loads the code for 
this box this button triggers. 
Once the import is finished, we 
can then open the dialog box or 
catch an error. So input allows 
you for dynamically importing 
and loadinging JavaScript. Very 
exciting. We all know dealing 
with asynchronous data can be 
painful. 
    And they can be used, for 
example, in four off loops and 
you can create custom 
asynchronous through 
asynchronous factories. One 
example here, we have a 
generator function so we can see
 a little star. You have a 
response that is from the fetch.
And then, we have B, which is 
the body of the response. And we
 have this asynchronous for 
await chunk of magic function 
that gives us a chunk back of 
the file. And we can, then, 
yield the chunk's length 
dynamically. 
Very exciting new functionality 
that this provides. 
    And then, finally, no pun 
intended, we have the finally 
method. Often times, you need to
 do something in a promise. 
Nevertheless, if the promise has
 fulfilled or if the promise has
 been rejected. You can see 
here, I'm fetching a display on 
my function here, I'm showing a 
loading spinner. And I'm trying 
to fetch a URL, then I get the 
response, then I get the 
response's text. And I catch in 
case something happens. 
    And then, finally, in our 
cases, no matter what happened, 
then case happened or the 
catchcase happened, I'm getting 
the text that can be the error 
message or the response text. 
And then, I'm just displaying it
 and hiding my spinner. An 
elegant way of dealing with code
 without repeating yourself. 
    And then, over to 
Hardware-related APIs. A lot of 
new Hard-ware APIs that allow 
you to communicate with blutooth
 devices. A demo from a 
colleague of mine who was using 
his phone to control bluetooth 
candles.
Just from a website. And he's 
sending messages over to the 
bluetooth candles. 
    Like this, the Web Bluetooth
 allows you to communicate with 
devices 
nearby. And the generic 
attribute profile GATT. And you 
can definitely play around with 
it on Chrome and Chrome OS. 
    Relatively similar, WebUSB, 
making them accessible from the 
web. And you can see how he is 
playing with WebUSB and sending 
a message. He's typing on the 
website some message WebUSB 
works, he's sending it to the 
device by WebUSB and it's being 
displayed. 
    Dealing with specifically 
designed full-web USB devices. 
And obviously, this is a very 
powerful API. It has to be HTTPS
 only. And again, it's 
implemented in Chrome, Lin UMT  
linux and Chrome OS. If you want
 to stay up to date, stay tuned 
to developers 
developers.Google.com. And don't
 clap just yet. This is not the 
end, really. 
    We have one big surprise, we
 have one next big thing. And 
this thing is, actually, a 
person. And this person
 has found the craziest of thing
 web.
Please welcome Jake. And thank 
you very much for listening.

last session of the day. It's a 
short one. It's only ten minutes
 long. I'm not going to get 
between you and the Java
 afterparty for too long. We're 
going to play a game. 
    We're going to play. There 
should be some sound playing if 
someone can make that happen. 
And there we go. We're going to 
play the Big Web Quiz. On your 
tablets, on your phones, 
laptops, whatever you've got 
that still have power remaining,
 get yourself down to 
bigwebquiz.com and there's a 
button to sign in with Google 
accounts and you can press that.
It's going to be a quiz about 
the strangest corners of the web
 platform. If you're someone 
that doesn't code on the web, I 
recommend playing along anyway. 
You might beat your colleagues 
who are web experts and that 
will be a fun thing to embarrass
 them with. 
    As a speaker, you get asked 
a few questions a few hours 
before a talk. Do you have your 
laptop? What kind of laptop is 
it? What are your Slides built 
in? I was asked, are you 
allergic to bees? Which was -- 
which surprised me, but I an 
apparently there was a big swarm
 of bees attacking the speakers.
And I've been petrified for the 
last two hours thinking my talk 
was going to be me attacked by 
an absolute swarm trying to get 
me. But apparently, it's not 
going to be that bad. 
    Is logging on going on okay?
Enough people logging in? 
Excellent. That's a good sign. 
Okay. So we're going to try to 
do the first question. Devices 
ready. Here
 we go. Which of the following 
are valid CSS colors? 
So we have four here. Select all
 of the ones that you think are 
valid and hit submit. 
    So we have 
lightgoldenrodyellow, 
blanchalmond, ChuckNorris, and 
Peru. All of the ones you think 
are valid CSS colors and hit 
submit. The question should be 
on your phones now.

your answers coming through. So 
we can see from this that 63% of
 you are pretty confident on one
 of those answers. There's one 
of them here, 20%, you're not so
 sure about. These are the ones 
comng in live. I'm going to 
close the question in a few 
seconds. Take a guess, make sure
 you hit the submit button. 
These are good lights. Thank you
 whoever is doing that. Three, 
two, one, and closing the
 question. 
    So we're pretty confident 
about blanchedalmond and
 lightgoldenrodyellow. The 
correct answers is all of them, 
all of them except for 
chucknorris. But Chuck Norris 
has history when it comes to 
colors on the web. It's a valid 
HTML color. This will display a 
dark red color. And the reason, 
HTML, it will take the 
chucknorris and zero out 
anything not a valid number, and
 treat those as RGB, and each of
 the part, two characters each 
and from that, you get a color 
in sort of a dark red. That does
 not work in CSS. 
    Okay. Let's move on to the 
next question, devices at the 
ready. Here we go. Okay. Which 
of the following will render and
 by render, which will the user 
be able to see with their eyes? 
We have a div here, visibility 
hidden, says hello. And inside 
div it says world. And inside a 
div with a positive 1 bar. Get 
your answers in. Select all that
 apply. Make sure your hit that 
submit button, as well. 
    We're pretty confident one 
of them is going to render, 
hovering around the 50% mark. 
Big confidence here for one of 
them sort of around the 65%, 70%
 mark. Low confidence for one of
 them, 20%. It'll be interesting
 to see which one that is. Get 
your answers in. I'm closing the
 question in three, two, one -- 
and it's closed. 
    What are we thinking? Okay. 
Pretty confident on bar and 
world, less confident on hello 
and Foo. The answers, just World
 will render. But it will 
render.
And here's why. 
    When you're dealing with 
capacity, it's very much like 
layers in photoshop.
 It fades the whole thing as if 
it's a layer. And if you get 
something in a positive one, 
there's no change there. The 
whole layer is not .5, things 
inside are already at one. 
Whereas, visibility hidden is 
actually different. You can give
 something visibility hidden. 
And it will sort of bring them 
back into rendering. 
    This is really useful if 
you're Paint Profiling, you can 
hide everything on the page 
except for one element and 
measure how much time it's 
taking. 
    Devices at the ready. Here 
we go. What is the final value 
of this div's class attribute? 
We've got a DVPT iv here, class 
equals A, and class equals B. Is
 it, A, B, AB together, or A 
space B? Select the one that 
applies. So we can see there's 
one answer you're pretty not 
interested in, only sort of  
-- 
that's a good thing to do. Guess
 if UMPBT you haven't already. 
I'm going to close the question 
in three, two, one, and it's 
closed. What are we saying? 
We're not overly confident about
 AB, low confident for A space 
B, pretty confident on B, not so
 confident on A. It's A. 
    This is a weird rule with 
HTML, a lot of specs on the web,
 it'll take the last valid 
value, that's true in CS, is, 
but for attributes, it's the 
first one and the rest are 
ignored.

question. Okay. This is 
involving some newer features on
 the web. According to the spec,
 not necessarily a browser, 
according to the spec, which of 
these scripts will execute 
first? I think most browsers get
 this right according to the 
spec. We've got a script, we 
have a source-type module. 
That's a new thing. We have an 
inline script-type module. We 
have an incline-script with 
defer attributes and an inline 
script, external script with the
 defer attribute there, as well.

execute first? Oh, okay. I was 
expecting more of a spread of 
answers here. But there's sort 
of high confidence on two of 
them, low confidence on the 
middle ones. Really curious to 
see which way this one is going 
to go. Get an answer in if you 
haven't already. Hit the submit 
button. Closing the question in 
three, two, one, and we're 
closed. 
    Right. Okay. So low 
confidence on three, lower 
confidence on four. Oh, I'm very
 sorry. It's three.
 Number three.
Why does this actually happen? 
Here, we have a module script, 
new script types. They are defer
 by default is
 implicitly defer, that's added 
to the defer queue.
This inline module script, add 
it to the defer queue. That's 
implicit. 
    So here,
 we have a standard inline 
script with a deferred 
attribute. It totally ignores 
the defer attribute on inline 
scripts. Only just started 
working with modules.
 It executes it straight away. 
So that's why it happens first. 
This one is also added to the 
defer queue. And so the order 
they'll be executed is three, 
one, 
two, four. Next question, here
 we go. 
    I like promises, so here's 
one about promises and 
microtasks. Which of the 
following promises rejects? 
We've got promise
 DONT promise DNT reject. And 
number four, promise.reject but 
a catch on the end there. Select
 all that apply. Make sure you 
hit the submit button. 
    All right. Oh, we're kind of
 seeing people going towards two
 anxiouses once, again. The high
 confidence, although the blue 
one there is dropping rapidly. 
Do get a guess in if you haven't
 already. I'm going to close the
 question in three, two, one. 
And we're
 closed. 
    As a room, you're saying 
three is the most likely one to 
reject. Less confident about 
one. The answer, it's all of 
them. They will all reject. 
Sorry. I know this is really 
evil quiz. If you're having a 
low score on this, it doesn't 
mean anything. It means it's all
 the weirdest corners of the 
web.
    Promise.reject false. This 
here will create a promise that 
rejects with a resolved promise,
 but it's still a reject. This 
one here, now, this is the weird
 one. Promise.resolve, it 
creates a -- well, whatever you 
pass the promise.resolve; it'll 
resolve that value unless you 
pass it a promise, and then 
it'll copy whatever that promise
 does. 
That's why this one also 
rejects. 
    This here, this is a cruel 
one. If you catch a promise, it 
will resolve rather than reject.
But you have to pass a function.
And if you don't pass a function
 in, it'll remain rejected as if
 nothing's happened. But if you 
did pass a function in, an empty
 function, that would resolve. 
    All right. Next question. So
 from this, this piece of code 
here, how many elements are 
created as this code runs? So in
 the HTML equals, plus equals, 
plus equals. Does it create one,
 four, ten, or 16? Select one 
and hit the submit button. 
    This is good. We've got high
 confidence on one answer here. 
That's what I like to see. Will 
it be the correct one? I guess 
we'll find out.
 Take a guess if you haven't 
already. I'm closing the 
question in three, two, one, and
 it's out. 
    Okay. So most of the room 
saying -- oh, four in the end. 
Switched places. So four and 
one. The answer, I'm sorry, it's
 ten. And here's why -- this is 
a piece of code that I used to 
do -- write code like this. And 
I didn't realize how much of a 
performance problem I was 
creating for myself. When you do
 this, you're passing code to 
the HTML inside the browser. 
Because it's plus equals -- 
you're asking the browser to 
serialize, and then you're 
asking it to pass it, again. It 
creates one element, two, three,
 four, five, six, seven, eight, 
nine, ten. 
    There'll only be four there 
at the end, but you've created 
ten elements in doing that. I 
would avoid that and, instead, 
use -- insert adjacent HTML. And
 that will only create that 
many.
All right. I'm running our time.
I'm going to pick a favorite 
question to go on
 next. 
    Let's do this one. This is 
fun. Okay. Devices at the ready.
Here comes the
 next question. 
Now, this is the evillest one 
I've got. Promises, again, and 
involves microtasks. Two event 
listen everies on the same 
button. But when the user clicks
 that button, which logs first? 
Does it log one, two, three, or 
four? There isn't even a four 
there. How can this possibly 
work? Or maybe when I did the 
design I assumed I would have 
four answers. Maybe that's 
what's happening. Get your guess
 in and let's look at how the 
answers are shaping up. 
    Oh. Okay. We've got a smart 
room here. There's high 
confidence one of the answers, 
all of the rest of them, not so 
interested in. So the last 
question, so you know, just take
 a guess if you haven't already.
Going to close the final 
question in three, two, one -- 
    We can all relax. Okay. So 
what we're saying, we're saying 
three is the one that is going 
to be logged first. I'm sorry. 
Correct answer is one. And this 
is something I only learned 
relatively recently. Let's take 
a look at some of the code. 
    Oh, my code's not appearing,
 why is that happening? Okay. So
 what I'm going to do is 
describe it with words. What 
happens is when you're running a
 -- resolve a promise, it queues
 as a microtask. And at some 
point later, the browser is 
going to handle that microtask 
queue and do something with it 
and start executing those 
things. And the time is when the
 JavaScript stack empties. 
    So when we run that first 
set of -- that first listener, 
that function runs, it cues a 
microtask and that function has 
done running. The stack is now 
empty. And because the stack is 
empty, that microtask is going 
to run. And that's why one is 
logged first. And then, it will 
handle the second listener where
 it'll log three, and then the 
microtask is queued, the correct
 order is one, three, two. 
    That actually changes if you
 ask the browser to call the 
click function. If you do 
element.click, then the order 
changes because you have that 
function called on the stack. 
You'll get the -- the answer 
most of you came up with, three,
 that will be the first one in 
that case, but only when you do 
that. 
    So my Slides are gone, but 
let's see if I can call up the 
scores. Can I do that? Yes, I 
can. 
    So here are the final 
scores. We've got joint first
 place. Congratulations to you. 
Huge round of applause for 
everyone in the top three. 
[ Applause ]
And I'm standing in the way of 
you and your afterparty. So if 
you're interested in doing more 
questions, I'm going to be here 
roughly the same time tomorrow 
at the end of the day with a new
 set of questions. 
    If you're the kind of person
 who enjoyed this, then you can 
come back for more. Go enjoy the
 after party. Thank you very </div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>