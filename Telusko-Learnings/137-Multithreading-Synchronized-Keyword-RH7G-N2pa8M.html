<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>13.7 Multithreading Synchronized Keyword | Coder Coacher - Coaching Coders</title><meta content="13.7 Multithreading Synchronized Keyword - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Telusko-Learnings/">Telusko Learnings</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>13.7 Multithreading Synchronized Keyword</b></h2><h5 class="post__date">2016-11-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RH7G-N2pa8M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now in this video we'll talk about
singular ization not exactly it means so
for that let me let me at an example
here and based on like that example will
we'll write our code or we'll try to
understand what is synchronization is so
let's say we have a class here and the
name of the class is counter okay and in
this counter we have a variable which is
count and in this we have a method we'll
say public void increment
now what this increment method method
will do is it will simply increment the
value of count okay so if the value of
count is initially zero and every time
you on this code every time you call
increment it will increment it willing
this the count of immediately it will
increase the value of the count okay so
for that what we'll do is we'll try to
increment the value using a main method
here for that time there just minimize
the window there okay so what we can do
here is let me create the object of
counter so that we can increment it
let's say counter c equal to new counter
and what i want to do now is i want to
call increment so i can simply say c dot
increment okay and let it on let me
create the object i mean let me print
the value of the counter so it's a
system dot out dot println we'll say
count o+ we'll say this is c dot count
is it yeah so now if I run this code you
can see will be getting the output as
okay so we got the output as 1 so count
is 1 let me take the output window here
so that will be very clear for us to see
the output now so once since we are
calling event only once it is printing
count 1 what if I if I what if I call
increment 2 times so it will it will run
this I it will get it will give you the
output which is 2 why because we are
calling them in two times now what I
will do is I will call increment
multiple time so let me call increment
let
10,000 times of course if the count
value will be 10,000 right but instead
of using main thread I will count I will
count it for two thousand it will I will
count using two different threads so
let's create a thread and each thread
will call increment thousand times let's
do that so we say thread t1 equal to new
thread and now we know how to create the
object of thread right so we can use my
expression here directly but just to
make it simple I will be using renewable
object okay I have to I want to pay too
I want to I wanted to create the object
of the neighbor here and here I will
create a method which is public void run
which is compositing for us to do right
and then in here I will creat I run a
loop which will start with one it will
go till 1000 and then will I will say
plus plus so I got a for loop so this
for loop will run for 1000 times and
every time it should call C dot
increment okay so every time you call
every time you call count I mean every
time you run this loop it will call
increment so a total the value of count
will be thousand right let's do that let
me just do let me just say t1 dot start
I will it work now so I am using only
one thread now and the count 1 is 0
that's weird why it's not working it's
because it is working if you can see if
you on this forward somebody you are
getting some value you can see 0 record
2 1 9 record 2:05 what is happening is
as soon as you say start it is running
this loop ok it will take some time for
running right by the time t1 is busy
incrementing this the main thread is
doing nothing it is printing the count
here right so what will do is will be we
have to ask our main just to wait for t1
to come to its job so for that we have
to say T 1 dot join and it might throw
an exception right now it was exception
there and I feel on this you can say
regard the count value as hundred so
what we are doing now with t1 t1 to join
is we are asking our thread to wait so
we are asking about main thread to wait
for t1 to complete its job okay so that
that is only one
right I want to use this again through
it now so how would you implement second
thread let's see that so let me just say
so let's say this is t1 done let me just
copy this code and I will make one more
thread here which is T 2 so we'll make
this as T 2 and this this was the same
thing it will it will increment with on
this loop four thousand times I it will
call increment and we have to say t2 dot
start and then we have to also wait for
t2 to convince drop right so we'll say T
2 dot join everything seems good right
so if you run these two loops it was if
we run these two threads it will it
should increment for approximately two
thousand times right so value of count
should be two thousand and if we run
this code that's we are they are not
getting two thousand differ on this once
again we are not getting two thousand
now why is that the case it's because
when two threads are are doing this
addition at the same time this this
statement looks very simple why this is
incrementing the value but this is not a
simple statement count plus plus simply
means count equal to count plus 1 that
means we are doing - we are performing
to action here one is addition and
second is assignment ok so let us say t1
and t2 the running in parallel right so
t1 comes to increment and says hey
increment I want to execute so your
increment says okay go on
so t1 fetches the value of count which
is zero so t1 fetch the value of count
which is zero it says plus 1 it is
making it one now so I the count value
for t1
I mean the count value is 1 and you
assign the value of 1 to count so the
current value of count is is 1 now T 2
reaches TT 2 says okay count give me
your value count will say my value is 1
T 2 will say ok your value is 1 I will
add 1 the value of count now is 2 right
so it will assign to now T 1 will again
come it will fetch the value of Commodus
- it will assign 1 the value of count
becomes 3 and this goes
all right so for t1 running 4,000 times
t2 learning 4,000 times in total it
should be 2,000 but what is happening is
somewhere in between when t1 reaches and
asked for the value of count so let us
say the current value is let's say 600
so somewhere somewhere after 600 t1
reaches and t1 says hey count give me a
value comment says okay my value is 600
by the time t1 is us adding the value so
by the time t1 is adding the value what
t2 is doing is t2 has also fetched the
value of count at the same time okay so
both are both have both are asking for
the value and the value both got is 600
both has added 1 which which is 601
because both have 6 600 both are adding
1 so they got 601 and that value is
assigned to count so where it should be
2006 I mean where it should be 6000 - or
600 - it is 600 1 because instead of
incrementing 2 times we are incrementing
only ones because both are fetching the
value and both are incrementing it at
the same time and this is not happening
this is not happening once or twice it
is happening multiple times that means
both this thread are using this method
the same time demonstrating the issue
both the threads are accessing this
method at the same time that is what is
fitting the issue what I want now is if
t1 is executing the increment method t2
should not execute this if t2 is
executing this method of t1 should not
interfere that means you want only one
thread to work with this method and how
to achieve that if you make this method
as synchronized if you make this method
synchronize that means only one thread
can work with this method if t1 is
working with increment T 2 has to wait
when t2 is working with the method of t1
has to wait so maximum one only one
thread can work with this so if you're
on this for now you can see we got the
count value as 2,000
let me on this once again you got the
value as mm it's that simple okay
so that's how you use synchronized
method so point remember is when you
don't make your better synchronized that
means your your method or your object
counter is not sweat save your class is
not thread safe which means that
multiple threads can access the same
method at the same time what we want is
we want to make this method synchronized
so that only one thread can use it at a
time so when t1 is executing increment
t2 will not interfere so t2 will wait
and when t2 is executing increment t1
will wait so that's different that's the
idea behind synchronized methods okay
and so once we have talked about
synchronized we can also talk about
string builder and string buffer so in
the Ximena ng session in in the in some
next few videos we'll talk or to talk
about string builder and string buffer
so once we start with string handling
we'll talk about that so that's about
synchronized keyword thank you some</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>