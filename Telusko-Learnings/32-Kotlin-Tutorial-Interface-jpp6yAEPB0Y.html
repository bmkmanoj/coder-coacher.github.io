<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>#32 Kotlin Tutorial | Interface | Coder Coacher - Coaching Coders</title><meta content="#32 Kotlin Tutorial | Interface - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Telusko-Learnings/">Telusko Learnings</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>#32 Kotlin Tutorial | Interface</b></h2><h5 class="post__date">2017-05-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jpp6yAEPB0Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so now we know about abstract class
right we have seen how to get abstract
class we had seen how to create abstract
methods now is it possible to achieve
multiple inheritance with abstract class
and of course not because abstract class
itself is a class and we know that when
you go for multiple inheritance in
Catalan or Java the basic problem is in
in both this scenario there might be an
ambiguity issue because the because of
ambiguity issue it says ok let's not use
multiple inheritance but when it comes
to interface Catalan and Java both
supports multiple inheritance how can we
do that so whatever we do here is let's
let's remove all this thing here let's
remove this human and all the thing let
me create interface in fact I will
remove this alien as well let's go for a
simple logic so what I will do here is I
will create an interface and I will say
interface a okay so we got interface a
and we got interface B now interface now
if you don't know what interface
interface is same as abstract class so
interface is same like abstract class
and so interface also we can declare
methods the thing is it interface we can
only declare methods right so what we
can do is if you want to declare a
message is very simple you can say fun
show and that's it
you don't even have to use an abstract
key when I remember in abstract class we
use a keyword called as abstract but in
in case of interface you don't have to
use abstract abstract keywords because
by default all the methods or functions
are up straight the same thing can be
done here we can say fun display so we
got this we got these two interfaces
they have two different methods now in
order to work with this of course we
have to work we have to get a class and
we'll say this class is maybe C and C
goes what goes with a and B now you can
see that we don't use any keyword called
as oh what's that so we are not using
any keyword called as implements or
extends so we don't have to do that so
in Java what we do is we exchange a
class and we implement an interface but
in case of Cortland you simply use a
codon you can you can extend you can
implement maybe one interface maybe five
interface it
work fine but then you might be saying
that there's an error the error is
because you can see in a we have a metal
show in bbl metal display it gives the
responsibility of Class C to define both
these methods how we can do that it's
very simple so we can say fun show and
we can define whatever we want here so I
can watch that will say praying to Ln
and will print in show so that's the
first definition we got and now the
problem is with display so what I will
do here is I would say fun and I will
name this as display and we say print
and then you will say in display right
so you can see we have defined we are
defining both the methods but still it
is not working now what's the issue see
if any way you try to override the
methods right even here we are trying to
override this method using show so what
we do is now you know that's right we
have to use a keyword called as override
so remember this thing whenever you
override any interface or whenever you
override the function of the interface
we need to use this keyword was called
as override and I guess everything is
everything is fine here if I create
object of C we can say where we're just
in case the phone is a bit here so bad
obj equals u and we can specify C and
lackattack switch that's we got the
object of C and we say C dot if I call
show it will call show if I call display
it will call display right so interface
is same like abstract class the only
differences and interface we cannot
define methods as of now right and
interface does support multiple
inheritance right now the problem is as
you know in Java 8 so from Java 8 we
were we we have allowed the Java and we
have allowed interface to have defined
methods which means that from Java 8 we
can define method and interface now
those methods are basically default
methods right
so again from Java 7 to Java 8 there was
a huge change which is having you can
define methods in interface and that was
weird I know now why they made it such
thing or why they allowed to go forward
multiple I mean Dwight love to define
methods and interface I would suggest
you to watch my video on that I do have
a video on on why interface are allowed
to have default methods now but then
just to give you a glimpse what will
happen is let's say we got we got this
class C and in that V it is it is
implementing a right now in which we
have only in this we have only one
method right position show and actually
by defining only one method let's say in
future if you thought okay I want to
have one more method inside this
interface a maybe that method name is
ABC so if you declare one more method it
will break all your code right it will
break all your classes so all the
classes in the world which is
implementing the same interface they
will give you trouble and that's why you
are not allowed to change the existing
interface but even if you have to change
that what you can do is you can define
methods again it was introduced in Java
8 and codling also suppose this thing so
what we can do is we can actually define
methods I can say fun I will name this
method as ABC itself and we can define
methods that's fine okay it works and if
I say print Ln and if I say okay let me
just print in ABC now let's find will
say in ABC a right and now we can
actually call both the methods we can
say obj dot ABC as well but in question
arise inside this see we don't have ABC
method right
but then okay we are actually exchanging
it right so this method actually comes
to your comes to your C class and
everything everything works fine if you
don't this code you can see it is
printing it is printing in show in
display and in ABC's ABC a now
everything is good here the problem is
now why Java has removed multiple images
of the first place is to avoid ambiguity
issue right what if you have the same
function in both the interfaces so if I
say in ABC B now so we got the same
method which is ABC and ABC input in
interface a and interface B
and now your C says hey there's an issue
now you are saying that the C implements
a and B and then you have the same
method which is ABC ABC at both the
places which ABC have to take care and
that's the issue you can see it says
okay it says Class C must override a
public open function ABC the problem is
whenever you whenever you have this type
of scenario where you are getting
ambiguity issue the best way to solve
that is by creating a method by yourself
which is called as ABC and again you
have to make sure that you have to
remove you have to make it over to ID so
we say over tight fun ABC and will print
will train in ABC ABC is C okay so now
the problem is solved you can see that
so in case of ambiguity problem music
interfaces where you can define methods
now you can actually print this thing
okay I mean you can actually what I this
method and your problem is the soil now
of course when you run this code it will
print in ABC C of course right you can
see we got the address in ABC C okay now
you might be thinking what if I want to
call a specific method I want to call
ABC of a maybe you want to call ABC of B
you don't want to print this thing so
you can do that as well so again we can
use a super and then we can say super
dot ABC but again the confusion is which
ABC are talking about again there is
ambiguity issue right so in that case
you have to use generics and you say hey
I want to specify a so call call ABC of
Class A and if you run this code now so
instead of printing in AC in ABC C it
will range in ABC a right and that's
what you want it and after doing all the
things there's only one question your
mind now if interphase can have method
definition what is the difference
between interphase and abstract class
right now that's the - D what you say a
one of the biggest mystery now other
thing is interface not was not allowed
to define methods earlier and that was
the main difference between interface
and abstract classes but then due to
modern requirements we they they made
interface to define methods as well
so unfortunately we
don't have a choice now so this is what
we this is what we do now so we have to
define methods and again given a choice
always go for interfaces of using
abstract classes so yeah that's it
that's how you interpret in Java end of
interface and Kotlin and that's it thank
you so much for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>