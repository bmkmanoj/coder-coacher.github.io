<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>8.22 Interface in Java 8 Default , Static Methods | New features | Coder Coacher - Coaching Coders</title><meta content="8.22 Interface in Java 8 Default , Static Methods | New features - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Telusko-Learnings/">Telusko Learnings</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>8.22 Interface in Java 8 Default , Static Methods | New features</b></h2><h5 class="post__date">2016-05-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4e_RsZWdiSc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome back aliens this is now when
ready from police collar things and in
this video we'll talk about interfaces
but not just interface will talk about
interface in Java 8 now you know
interface is there from a long time
right of course when you started with
Java we have interface and the main
reason why user interface is to define
the type of the class example let's say
you want to go forward so if you
remember the concept of C programming in
C programming whenever you want to
define a method what we saw function we
used to first declare the function we
should define the function and then we
used to use the function writer base to
call the function in java fern do the
same thing we use interface where you
can declare the methods in class you
define it and then you call it right so
we use interface in lots of applications
so if we talk about different inbuilt
classes and interface in Java there are
lots of interface which are inbuilt
right so we use interface so that's
what's what's new in that so if we talk
about interface so we have this concept
of we can define an interface and in
this interface relate to this interface
name is I so in this interface you can
only declare methods right example let's
say if you if you talk about a method
for a show so this method will be by
default public abstract right so this
will be let's say if I say void show so
by default it is public and ash track so
even if you don't mention it even if you
if you're not writing this part it is by
default public abstract and that's the
main difference between abstract class
and interface right so on the other hand
if you talk about abstract class we have
this concept of abstract class here in
which you define a class and you make
that class as abstract why this is a is
abstract and then let's say class name
is ABC and what we do is in this class
you can you can declare the methods are
akin to you can define methods we do it
right so we can also write some method
which has definitions that's what the
main difference between interface and
class right so in abstract class we can
make the method abstract or we can also
have a defined method but in case of
interface it should be only
abstract methods right now with so
interface will have only abstract
methods so that was the concept of
interface to Java 1.7 so from 1.0 to 1.7
they cannot define methods and interface
we can only declare it which is abstract
methods so by default all the methods
order of interface will be public
abstract but the problem is in Java 8
so in Java 8 we got lots of features
right so we got off we got one of the
feature call s stream API right so again
what is stream appeared as a different
thing but we are we have a concept of
stream API in which you have certain
methods of stream API so you have
methods like stream itself so streams of
method now this stream method was
introduced in jar 1.8 ok it was not
there before and it was introduced in
one of the interface called as least so
least is a interface in Java which we
you which we use in collection API right
so whenever you work with collection we
use least we use a de least we use
linked list right so we have this list
interface and in this list interface it
is there from one point two so this
interface is there from one point to
right and it has certain methods so
let's say it has X methods so initially
when list was created it has X methods
but in Java 1.8 we got some extra
methods so now we have X plus y methods
so this X methods which are there from
one point to and then we have this Y
methods which are related to stream API
not just string we have lots of methods
right which is which is built using
stream API right now the question arise
should we change the interface when it
is published example if one is let's say
if one of your friend or earlier you're
working with a software in which you are
working with one point seven right and
in one point seven we have X methods and
now you're reading is using the same
software on one point eight where you
have some extra methods which are
abstract then unfortunately your class
will implement all the methods that's
not possible right because you have not
changed this off
you have just changed the Java version
so it will not work
so what oracle has done it in java 1.8
what they did mention of declaring this
methods in such inside lists as abstract
they have defined it hold on can we
define a method inside interface is it
possible that means we can define an
interface
so that's your interface and let's name
it as least that's the input interface
right so it has some methods like it has
method like add which is abstract then
we have a weather like remove which is
abstract and then we also have a method
for the stream now we cannot make this
method as abstract because not every
class which is one point seven one point
seven we don't have this implementation
right so how did it work so it they have
this said this is not the declaration
you can actually define a method which
means you can say void stream no need to
declare it you can define the method
inside interface and hold on is it
possible to define then even if it is
possible then what the difference
between interface and abstract class
then because in both the things we can
declare and we can we can define right
so let's talk about how this definition
works here how to define a method inside
interface so this whole section so we'll
talk about this how to define a method
inside interface now so let's talk about
that so in order to define I in order to
define a method inside interface what we
can do is we can create an interface so
we will say this interface name or let
me just take some extra idea here okay
let me just take here
yeah so I have a interface I will in
this interface as I as usual and in this
interface I can declare a method and I
can also also define a method so let's
say if I were to declare a matter I will
say but I will say void let's say the
declared method is let's say and so we
have this method which is declared which
is public abstract right but you can
also define it so we can let say let me
get one new method here which is void
sure right now this method I want to
define it so what we'll do is we'll in
order to define this we just have to
write default keyword here okay if
you're just right void show it will not
work you just have to mention one more
key word which is default so that means
inside interface you can define a method
if that is default okay you have to use
this default keyword and once again this
code with this code will only work in
1.8 so let's say if you're using
netbeans if you are using Eclipse you
have to make sure that your JDK was
raised 1.8 okay so that's how you can
define it so that's how you define a you
create a default method interface so
this is this one little problem here you
know in Java we doesn't because we don't
have a concept of multiple inheritance
is because it creates a diamond problem
right I where's the diamond problem so
let's say we have let's say we have two
classes we have class a and we have
Class B and in Class A we have a method
which is show when Class B also we have
water which is show and then we have
paid in Class C and let's say if Class C
extends on the Class A it is not
extending Class B now
so if Class C extends Class A and if I
create the object of Class C as obj and
if I say show now since in Class C we
don't have a method which is show so it
will go to class
err right that's how it works but let's
say if Class C now extends Class B also
that's multiple inheritance right so
there will be a confusion which is a am
big ambiguity which show to Paul
so Java says no will not go for multiple
inheritance EO so multiple inheritance
is not allowed in Java but it is it is
applicable with the help of interface
right so what we can do is we can have
two interfaces I and J both are
interface both are interface and in both
this Smith in both this class and in
both this interface we have our with
show and let's say if I create a new
class which is C so this implements this
is not extent this is implements both
the interfaces now in this scenario if I
create the object of C it is compulsory
to have that method show here right
because they are declared that are not
defined so we can implement that but now
since in interface we have the
definition right so let's say now this
show is defined here so this show is
defined here so in order to define it
here right so that now if I say if this
C does not implement jate only
implements I now I can simply call OB j
dot show no need to the over I tack
method here because normally interface
what we do is so if you have an
interface in your class what we do we we
override those methods right
but since in I in interface I we already
defined our method which is show we
don't have to define it here right
that's the advantage and we can simply
say o which is our show but since in
Java in Java we can so one class can
implement two interfaces right so we can
simply say Class C which implements
which implements I comma J so if you are
doing this now the problem will arise
now because we have a class which
implements two interface and in both the
interfaces example we have interface I
and we also have interface J in which
you have a method which is show which is
defined right so this will also create a
problem now okay then you have to solve
this dependency
if you light this statement if you write
this statement in Java
eight now it will give you error okay
provided in I and J we have this methods
defined okay so now so Java says we
don't we don't support multiple
inheritance because a diamond problem
and in Java 8 we have the same problem
again and to solve that what we can do
is and this see also we have to define
so so if you have the confusion it is
your responsibility to define that
method here okay
in this scenario since obj dot show
which is a method of C now we will call
shown there will not be any confusion
okay so let me repeat if you are not if
you are not implementing J you are just
implementing I no need to define so here
because it is defined in interface using
default keyboard but if you are
implementing two interfaces and both
this interface has the same method show
which is which is defined using default
keyword you have to override in C also
sounds good and then we can say obj dot
show which is the object of C and we can
call it so why did you have this show
method here okay now let let me go for
one more thing what if let me just
create a scenario so let's say we have
interface I okay and we also have
interface J just imagine we have one
more interface here which is interface J
and the code for J is exactly same as
code of I okay same same code now and we
have a class which is a now this class a
doesn't implement anything okay nothing
nothing it is just a POJO and in this I
am saying public void show okay so this
is also show this is also show and this
is also in this also we have show right
and then we have class C which is this
this C extends a okay so we have a Class
A here
and now in this class see we already got
show right what happens if I say obj dot
show let me let me just print here so in
this sis out I am printing let me just
write SOP which is system dot out dot
println I am printing I write in this
SOP I am printing J and in this and this
I am printing
SOP as a so we have I J and a okay so if
I am getting the object of C which
extends a if I say obj dot show what
will the output of course a right
because we are just exchanging with a
but what will happen if I say implements
I now since in I also we have show in a
also we have show now which which method
will call so in this scenario the output
will be a because class has more power
compared to interface so if you have a
class in which you have a method this
method will will hide this method here
so default will have the low priority
and normal methods will have high
priority okay this is also called as
third rules so this this comes under a
topic all has third rules in Java okay
so so that's how it works so if you have
a class which extends a class and
interface then it will give the priority
to the class method not the interface
method sounds good
so that's one of the thing in default
methods now we have one more concept
here in default the concept is what if
we have our interface and in this
interface we have our method which is
public
boolean equals and which accept object
is oh and it says return true now
question is will it work or not public
by default right because we are working
with interface and inside interface we
can only have this default keyboard
right so will it work we are we are
defining and a method inside the
interface is it possible to define this
method are technically yes because if
you have you can define methods in Java
right in Java 8 if it is interface
providing it is provided we have used we
are using default keyboard but the
problem is this definition here this
signature method name is equals which
accepts the object as a parameter which
returns a boolean value this is a method
which is already there inside object
class right so if you have any method in
your interface which overrides object
class methods then this will give you
error okay this is not possible so these
are certain things you have to remember
when you work with default methods and
interface okay
so that's your default methods if you
have any questions you can put in the
comments section so that I will rectify
it using the screen recording so i will
type this inside inside eclipse and i
will show you the exact error if you
have any questions with that okay so
that's the default methods next we talk
about is static methods now if you are
working with java 1.6 or 1.7 static
methods were not allowed but now since
we are walking with java 8 it supports
static methods okay that means you can
create an interface which is let us say
this is interface i and in this
interface are you can actually define
methods which are static example we can
say static void and you can say this is
show you don't even have to use that
default keyboard right
now the advantage will be if I say sop
hi
now since this is static in your main
function so let's say we have a main
function here inside your main function
you don't even have to create the object
of I because we have a static method we
can simply say I dot show which is that
powerful right so yeah so that's how we
can use interfaces we can use the static
methods inside interface in Java 8 again
if you try to run this code inside one
point seven it will not work it will
only work in one point eight okay so
this is this is the new features in
interfaces in Java 8 ok so which is
default methods and static methods so
that's it from this video if you have
any questions you can use the comment
section to ask your question and you can
you can ask any question in fact they
have started with the QA sessions so
normally every Sunday will have this
maybe I need day any week I will give
you the two days per notice if you have
any Q s sessions so you can take the you
can come to that QA session you can ask
your own questions I will try to answer
those questions for that first you have
to subscribe the channel so that you
will get to know that I am going for the
QA session so that's it thanks for
watching and do subscribe for further
videos</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>