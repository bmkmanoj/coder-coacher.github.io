<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What is JUnit? | Why Mockito? | Coder Coacher - Coaching Coders</title><meta content="What is JUnit? | Why Mockito? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Telusko-Learnings/">Telusko Learnings</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What is JUnit? | Why Mockito?</b></h2><h5 class="post__date">2017-08-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eILy4p99ac8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome back aliens my name is dimon
Verde and in this video we're going to
talk about what is the unit and why do
we need mockito in Psych if you have
been in jail why from a long time you
might have heard about j-unit right or
maybe you have worked on j-unit and you
might have heard about mockito so what
exactly marketer is and why do we need
it so we start the example with J unit
and let's move towards why do we need
market organ in this video we are going
to not not talk about how to use market
oh but then why do you smoke it in the
next video we talk when we talk about
how to use market oh so what we will do
is let's get a sample project and while
doing that let me just create a mavin
project of course Mount is mavin project
because I need those two dependencies
which is J unit and mockito so let's go
for my own project I will say I will
need a simple QuickStart project I don't
need any web application and will give
an artifact idea as a project name we'll
say this is demo J unit again with
market of course but then let's not have
a big big name here and let's click on
finish now once we got our project in
this area you can see we have what the
project as well that's ignore that let's
focus only on our project which is demo
j unit now what we will do is first like
let's try to understand why do we need a
testing or generate framework if you
know that's great if you don't know what
happens is whenever you make up project
in your project there will be lots of
classes right specially if you if you're
working in Java so you will be having
lots of classes and in each class we'll
be having some methods right now what
happens is when you build an application
you have to make sure that you have you
you also test an application how do you
test it so the one way is you can build
the complete application and being
tested but you know it is not that
flexible to test the entire application
if something goes wrong how would you
know what went wrong so what we do is we
test the individual units what is unit a
smallest part of your application like
in terms of Java classes and methods
they are what you say this smallest part
right so methods has a behavior right so
you're testing that behavior so what we
will do is we will test the classes and
the methods that is called as unit using
J unit you can do that so you can
achieve
unit testing in Java using J unit again
there are there are lots of other
testing framework available but then we
will be using J unit here luckily if we
talk about Navin project if you expand
your mind dependency you can see we by
default we have J unit so we don't have
to worry about that so what we will do
now how do you actually implement that
so let's say if you have okay there's
one more points at which you should know
as TDD which is test-driven development
normally what happens there is benefit
we make a project and be tested right
the end of the tortures before making a
module create a test case it's something
like you have not build a thing but then
before building that stuff you have to
test it okay you have to get a test case
of course the test case will feel right
because if you are testing something
which is not there of course it will
fail then you have to create a module
which should work right that's done it
will be passed so first your test case
will fail and later it will pass but
again let's not get into that way
because again this video will be Linde
if I if I go in that way so let's create
a simple a very simple class here to
test again I will not be using any
complicated stuff here let's say I'm
using a calculator I don't I love this
example of calculator for every example
because I believe you know let's make it
as simple as possible right so let's use
calculator and of course when I say
calculator you'll be having some basic
keywords there is some basic features
right so every calculator will have our
method which is addition so what we'll
do is we'll say public and add and we'll
say this is int I comma int J and this
is your add method which returns I plus
J now how do you test it how do you test
this feature of course you can call this
right so you have from your main method
so in your app you have your main method
so what you can do is get an object of
calculator and a call add method your
job is done right but then that is not
how you actually test because that is
manual testing because if you are
checking by yesterday's manual let's
automate it because you might have
thousands of classes in your application
right and if you change one class it may
affect other classes as well can you
test all the thousand classes manually
that's not possible right even if it is
possible it is not flexible
so let's automate this stuff what
happens is even if you change one class
it should test all the classes and for
that we need automation and of course
for the idea is we can use
so how do you test this calculator so
what we can do is we can in your test
package if you can see we have a main
folder here and we have a test folder in
this let me create a test case so I will
say you can see that when you right
click and say a unit test case it is
there in case it is not available you
can go to others and you can search for
a unit test case series available let's
click on this and I will name this test
case by a naming convention we should
have test calculator because you are
testing this calculator right so it's a
test calculator with lacan finish and
you okay so we got this test case but
normally okay let's not use this extend
way this there are multiple ways of
doing this we can use annotation way
right so let's use annotations here just
to make our work simple whatever you do
here is I want to test the addition
method right so we should get a test
case I would say public void we are
testing the add method I will say test
add now how do you test it okay so what
we need is to test the calculator object
first we need object of calculator
that's how we test it right so we'll say
calculator C equal to new calculator but
normally what we do is okay let's just
have this calculator there and here what
we will do is we'll say okay how do you
test it now to test a calculator we need
to say at the rate test because we're
testing a method right so this is your
first test case but as you can see we
are getting some issue I guess the
problem is it is with the version of
January so let's use a latest a unit but
how do I get a latest GJ Mateus I will
say I will go to my depository and I
will search for Jaylyn because we want
it we want latest one
okay let's search for J minute and let's
pick up this 4.1 one and let's go back
to our pom file because this is where
you will change the version right so I
will just go to pom.xml file and let's
use the latest one so let's remove the
dependency and let's put new one okay
and now once we call the new dependency
you can see now we got that annotation
of a label so in your mind dependency as
well you can see we have the J minute
now
let's say control space and let's import
generate and here how do you test it now
so in this we have something called as
assert equals now assert equals is a
static method is that assert equals okay
it is giving it's not giving you the
option let's say assert equals and okay
I guess we have to import okay so
normally what happens is this assert
equals is a metal of a third class so
let's use a studying port because every
time you have to say assert dot assert
equals that doesn't make sense right so
let's use a static input now assert
equals will take two parameters the
first one is the okay let's say control
space
the first one is expected the second one
is actual so I will go for actual first
I will say when I call C dot add by
passing two values two and three it
should return five so I'm expecting five
if your logic is right of course this
flesh will pass right now how do you
test it okay so let's run this do we
have to run it as normal java
application no because we're testing it
right so I will right click here I will
say run as you can see is giving the
option of J unit test so I will say
click on generate test it should test
nearly the amazing part is when you say
run you're going one test only and one
test passed and you can see a green
symbol there so this green line means
your test passed and that's the beauty
let's say if I make if you if I make a
mistake let's say in calculator and
normally this is not the case right we
will not make a mistake in calculator
but let's say by mistake you are saying
I plus J plus one that's a mistake right
and now if you test it now I feel on
this test once again you can see we got
red line which means your test fails the
expected value was five and because of
some prop because of some what you say
the cold issue or the logical the
algorithm problem you have made a
mistake here and the test fails now you
know okay something went wrong let's
again do some modification oh you
realize that we should not be having one
plus one there so this is the right
logic and again you will test and you
can see we got green this is J unit
right again this is the simplest example
you can think in fact in June as well we
have
we have before we have after now why do
we need before let's say the object
which has pitted here is an open object
right let's say if you want to define if
you want to get an instance item method
normally we create that method something
like setup so we say setup because this
is a method where you will create all
the objects something like initially
this will be null and later you can say
C equal to new calculator but then when
to call this so you can say before the
testing of the units you can say before
so before is this will be called before
test and you can all see also have after
let's say if you want to remove release
some resources you can do that right
this is j-unit okay so this is perfect
why do people even if you have thousand
classes we can test all the classes
using j-unit okay so that makes sense
but why do we need so this is a unit
right simple again this is not the
complete system change I just wanted to
show you why do we need mockito okay now
why do we need a market over here okay
let's think about it let's say we have a
calculator right and by some means I
don't know why but let's say we have one
more class and that class is let's say I
will have a class and I will say this is
calculator okay calculator service I may
be careful to service here now it may
happen that you and this I don't want to
make it class I want to make it as
interface so let's say we have this
interface calculator service and in this
interface you actually have a method
called as ad so public ain't ad okay
which takes two parameters I will say
int I comma and J now you will think
okay why do we need this just think
about it this is a simple application
right calculator and that's why you're
defining it but sometime you might want
to process this information using cloud
service let's say if you have a cloud
server and that cloud service says hey
programmer if you want to add two
numbers you don't have to do that by
yourself you can use our cloud service
right so every time a user clicks on the
calculate button your application will
connect with a server and you will get
the response the second way second be
second scenario is let's say you are
fetching
data from database maybe in this
Calcutta service maybe this is not a
Couture server this is something you
will connect with database now what will
happen is every time okay so let's let's
write it here so that you will get a
good idea about it so let's say if you
have calculus service let's say this is
service and of course I want an object
of this so if you want to if you want to
add this whatever do is I will say
service dot ad and I'm passing those two
values so of course a user is expecting
that I will add those two numbers but
I'm so lazy that I'm not doing by that
might by myself I'm asking a cloud
service to do it for me so this is an
interface maybe you can imagine an API
so this is an interface which is
connecting with the cloud service okay
now that means every time I test this
calculator because if this calculator
services is well tested okay so whoever
has built is application of AP Calculus
service maybe this service is provided
by Google Google have done a proper
testing on capital service so of course
as a programmer as a developer of this
application I don't need to test CAC
with a service right I need to test only
calculator but the problem is every time
you test calculator it will be using
this capital service so just imagine
every time you test it let's say if you
are building an application in your
application you have thousands of
classes if you make one change since
you're using j-unit it will test all the
classes and even leave five classes in
crack with the cloud service even if
five classes in black we database five
classes interacting interacting with
something else just imagine if you are
if your testing application if you're
running the application it will take ten
minutes to run the test will it make
sense of course not right and why do we
need to test the service calc I mean the
capital service we have to test our
application right so what normally we do
is we create a stub because before
without this implementation we cannot
make it work so sometime what happens is
your application is dependent on some
other application or maybe your class is
dependent on some other class object so
that's something other other class
object may be working with EDA base
maybe it is not even build how can you
test it right and that's well we have to
walk those services
now when I say market simply mean
that we can create a fake service right
it is not the actual service every time
it tests this calculator it will not
connect with the server we will test
this calculator with the help of fake
service or a mock service again there's
a big difference between mock fake and
stub we'll talk about that in one of the
video but then we create a mock service
what it means this is not the actual
service this is a duplicate copy of your
service so that you don't have to worry
about capital service you have to only
test about test your calculator that's
where we think we need walking
frameworks right so you can do the
mocking with the help of mocking
frameworks and there are different
mocking frameworks I've been able we
have jmark we have easy mark and we have
mockito and mockito is one of the
easiest mocking service available so in
the next video we're going to talk about
how do you use mocking I mean how do you
do mocking in this application so yeah
that's it this is the simplest
application well we have talked about
j-unit how to build a genuine test case
and why do we need a mockito I hope you
enjoyed this video if you enjoyed it do
like do click on the like button and let
me know if you have any questions in the
comment section and if you have some
good things doing do do comment as well
so that's a thank you so much for
watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>