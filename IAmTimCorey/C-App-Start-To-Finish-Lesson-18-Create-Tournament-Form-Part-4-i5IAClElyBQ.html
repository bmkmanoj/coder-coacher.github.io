<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C# App Start To Finish Lesson 18 - Create Tournament Form Part 4 | Coder Coacher - Coaching Coders</title><meta content="C# App Start To Finish Lesson 18 - Create Tournament Form Part 4 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/IAmTimCorey/">IAmTimCorey</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C# App Start To Finish Lesson 18 - Create Tournament Form Part 4</b></h2><h5 class="post__date">2017-08-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/i5IAClElyBQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to lesson 18 in a c-sharp from
start-to-finish course my name is Tim
quarry and today we're going to finally
finish the create tournament form this
is going to be a logic heavy lesson
we're going to move a lot of parts
around to accomplish our goal that means
it's a very easy place for me to lose
you maybe you're already feeling a bit
anxious after last lesson we didn't
retest things we left a couple of things
undone I've said it before but I'll say
it again relax don't panic
we'll get through this this might seem
overwhelming and that's okay you might
not understand it the first time that's
okay to take your time and do it along
with me re watch the video a couple
times don't rush through this and hope
that everything will work out okay and
definitely don't just watch this and
think about watching some how you're
going to get it it takes practice it
takes work in my case particularly it
takes some visualization sometimes my
students forget that a real person they
think that somehow these applications
come out a brain fully formed and that
just doesn't sell in fact I've tried
hard throughout this course to show you
my mistakes
I didn't contrive my mistakes to make a
teaching moment I'm showing you how I
actually build an application that means
in my design sometimes I get it wrong
sometimes my code isn't that well
thought through and sometimes I've had
to rework a few things hopefully that
gives you hope development is always
going to have its struggles today will
be one of those days where he struggled
us visualize we're going to do since is
sewing moving pieces I'm going to start
us off by visualizing what I am
envisioning for application this diagram
represents my notebook looks like after
designing this lesson and before I
explain it all let me say that even now
good design starts on paper
if you don't know exactly how you're
going to do something design it first on
paper because that makes it much easier
to redo in fact I've redone this
particular section three times since our
last lesson I had a couple concerns the
logic so I tried three different ways to
accomplish a goal before arriving at
this solution I know I'm repeating what
I say for but I really hope you take it
to heart it's important this is
important to learn to design first on
paper all right so enough lecturing
let's actually look at this diagram and
see what we're doing over here we have
the teams now what I do is said we're
going to design our matchups remember we
did everything for setting a tournament
except actually create the matchups and
match up entries and over here on the
right I have the match up entries and
the matchups tables in their columns so
I decided do was create a sample of
three teams Jen Tim and soot pretending
two teams now the fourth one is called
by because I want to simulate the idea
of not having enough teams remember the
first thing we need to do is fill in so
for example you have seven teams we have
to add an eight in order to have an even
bracket so in this case I'm simulating
three teams so I can make sure that I
know that I'm going to do with that by
now I said okay let's create our first
round of matchups and see how that looks
so I create us match up and I said well
it's ID number one we'll need an ID for
later and then I said well Jen and Tim
would be in that first matchup because
is the first two in the list remember
this will be randomized so Jen plays Tim
and I said each one of these this is the
Emmy ID which is the matchup entries ID
so Jen is a matchup entry idea of one so
the ID of one if you're a parent matchup
idea zero the team competing will be
Jen's team and a score would be you know
nothing right now and then Tim is
matchup ID of two and so again two here
zero here
Tim's ID here for his team and again
score of zero the matchup number two
guesses matchup so two would be the the
ID for matchups in the round be one
winner be empty
it's knowable and the tournament idea to
argue supplied by the tournament so
matchup ID number two we have sue that'd
be three up here zero sues team and a
zero for score and then by so we do this
by because BIOS we have a team ID well
what I said was we have a matchup entry
of zero and what this represents is the
idea that we don't actually have a
matchup entry for the by entry so we
only have one match of entry for this
matchup so for this matchup we only have
one team competing because it makes no
sense to have a matchup entry where the
matchup entry ID the matchup ID is for
zero and so on and so forth there's no
information in here that's actually
relevant we're not going to give it a
score we're not going to assign a team
and it won't have parent because buys
only happen in the first round so
therefore we're going to leave it as no
entry here and therefore you only have
one team therefore we already know who
the winner is so now that's great for
the first round if you know all the
teams will be competing in a matchup but
what about the second route of matchups
well really we don't know we can create
a matchup ID for it say three and you
can say winner ID is obviously we don't
know yet but we know the tournament ID
we know its rounded is round two but
then the first match of entry we're
actually going to create one and say we
know which entry is we'll call it give
it an ID
we'll say here is the first the entry
for this matchup the parent matchup
we're going to know whereas a parent
matchup for this record right here is
one meaning over here and the teams
competing we're not going to know so you
actually have a change this from not
know to be no so we won't know a team
competing but we'll know where it came
from and that's important because it can
then link this back to its predecessor
so this matchup matchup ID number three
knows it links to this matchup and this
matchup and these are the two
competitors in this matchup and so for
each of the matchup entries you know
this one right here number one the
matchup entry ID will know we will know
the parent matchup and the squirrely
blank because there's no score yet and a
team competing will also be blank we
don't know yet who the winner is others
first round now the same thing is true
for this one except that really what
we'll do is we will automatically move
Sue's team into this because we know
she's going to win her match up with the
by week so it's a little bit rough it's
a little bit of a sketch idea of what
we're going to do this kind of outlines
for us the basics of how we're going to
layout our tournament the first round
will have populated with people with
teams the second round except for the
bye week entries which I ignored at this
point but for the second round and
beyond we
won't know who is any playing but we'll
know where they're coming from and
that's good enough that means we can
capture this entire pyramid a pyramid
outside this pyramid here even if it's
even larger where if we had 16 teams or
32 teams or 64 teams we could capture
all the different rounds remember each
matchup gets a round number so you know
two rounds in and even if we are another
layer deep we would just say you know
say we had a matchup down here we would
say well one of the records like here
would point back to this matchup and the
other one would point down to this one
down here that's not yet there but we
pretend it is so we can still point back
to matchups even though those matchups
don't you know who's playing in them yet
so you can draw the bracket out we can
draw the pyramid out without having
which team is going to play we just know
that if Tim wins he goes on to this spot
right here in matchup three if Jen wins
she goes on to the spot in matchup three
and down here we know asou wins there
fortunately over here in a second spot
okay so that's the idea let's move over
to the actual code and see how it's
going to play out before we do anything
else I want to actually modify that one
table remember that matchup entries we
designed this we have to change that one
column team competing ID to allowed
nulls go ahead and save that and I get
this message saving changes is not
permitted the change you have made
requires the following table to drop and
recreate you have either made changes to
a table that can't be recreated or
enable the option prevent saving changes
that requires a table to be recreated
so as a setting inside Seacliff says if
the table needs to be recreated which
means dropped re-added which means
basically destroyed and rebuilt that we
can't do that we have to actually either
enable this option in here or we have to
do something different can't make this
change so I'm actually going to enable
that option so in order to do that what
I do is hit cancel now actually close
this out without saving this change I'll
go to tools and options and then down to
my designers and I'll select that and
then down here prevent saving changes
that require table recreation uncheck
that and hit OK the reason that check is
because if I change a table like match
of entries now match up entries right
now if we select this we'll see it has
zero records in it so there's no big
deal but if that had say a million
records and I made this change where I
check this box and hit save what have to
happen is you would create a temporary
table move all those records over that
temporary table drop this table recreate
it and then move all those records back
into this table that's a lot of work if
you have a million records in our case
it's not so I'm going to go ahead and
say I know I'm doing so yep go ahead and
do it and notice that change also said
hey our tables are connected to this or
you sure you want to do it and that's
because they have those relationships
set up and one of those is for team
competing ID'd links to the team table
and that's okay I can say yep I know
it's going to happen that's fine
now we're done with that change now the
only change the sequel that I needed to
make let's come back over here to our
code and actually start working on this
change so I double click on my turret
button and it comes to this spot right
here and we have to actually wire up our
matchups here to do why are our matchups
before we do the actual save of our
tournament now what does wire up match
ups really mean well let's flesh this
out a little bit before we start doing
any code let's write out in comments
what we intend to do here so the first
thing to do if we look at our tournament
model f12 then down here we have a list
of a list of matchup model let's look at
the matchup model let's actually keep a
tournament model open and now hit f12
here so in this matchup model we have a
list of matchup entries so we have two
entries in a matchup model we have a
winner and the round so that's all
inside of one matchup model so you have
a list of a list of matchup models and
then inside each matchup model we have a
list of matchup entries which the two
teams so to come back over here what we
need to do is we need to first of all
order our list randomly and that's
because you want to have that idea of
it's random who gets picked win so we
don't have any bias as to when you put
the team in does one of our way back
when requirements was that doesn't
matter which order you put a team's in
we're going to randomly pick who gets
selected first second third
so we got order a list randomly of teams
next we're going to take that list and
check if it is big enough and if not add
in byes again the buy is the idea of you
don't have to play a team in the first
round so it's an automatic win and so if
we have 14 teams well 14 doesn't make a
tournament it would be 16 teams
therefore we have to have to bias and so
two people are going to get device okay
so we'll Philip has buys in order to
give us the number of teams we need for
a full tournament meaning 2 to the N
power and that may be a math thing to
you that kind of blows your mind but
it's really simple for a tournament to
work you have to have two teams or two
times two teams which is four teams or
two times two times two teams which is
eighteen or two times two times two
teams or sixteen teams this is called
powers two to the N power this is to the
first this is to the second this is 2 to
the third this is 2 to the fourth power
you write that out to carrot 4 so that
we're going to figure out which of these
it fits in and so we'll do that math in
a little bit but that won't be a big
deal it's actually pretty simple to do
let's just take that logic than that
idea and put it up here just out of the
way keep it in that line so once you got
enough teams then we need to do is
create our first round of matchups all
right we go through the first round
that's me an easy round will have all
the information we need then what we'll
do
is will create every round after that
and again now we're dividing by two
because if you have eight teams that
you'll be playing four matchups and from
those four matchups you'll have four
winners well 8 divided by 2 is 4 then
those four teams will have two matchups
one matchup for the first two teams one
matchup the second two teams out of
those two matchups come two teams 4
divided by 2 is 2 all the way down to 1
so create a round for every matchup set
after that so if we have 8 teams I'm
sorry 8 matchups
it's just 8 matchups then we'll have
four matchups they'll have two matchups
and then we'll have one matchup and so
if our first round is this 8 matchups
then they'll be create up here and then
every round after that will be the four
match up round the to match up round and
the 1 match up round and those be easy
as well because all they're going to do
is say for this let's match up the first
in this series of four we'll take the
first two matchups up here and we'll say
give me those two IDs and that's now my
match up the second matchup will say
give me the next two IDs that's my match
up all the way down through over here
we'll do the same thing at the first two
IDs for the first one grab a second two
IDs here for the second one here and of
course this one is just the ID from each
of these two matchups so when you break
it down it's not that hard
logically it's just a number of pieces
so once we've done all this
really done we have all of our rounds
and if you look at the model we just
need our rounds definitely if you filled
in therefore at this point we can
continue on with our create tournament
and there we can work on the actual
savings information to the database so
the next question is where do we do this
we do this right in here which doesn't
feel good because it feels like we're
doing an awful lot of things inside the
create tournament button and we're right
it's not a great place to put it at
least not the actual logic we'll call
something because we may want to do some
work after the fact remembers that each
of these matchups match up with a four
with a two and with a 1 we don't have
any people in there there's no teams in
there the teams don't get put in there
until after the first round is complete
well how do we put those teams in it
seems like they leave more methods that
are kind of similar we're doing right
now we're going to take a tournament
model and kind of update it with the
values once you have scores in there so
we'll probably have more work to do
after the fact after the term is created
once we start getting game scores in so
I like the idea of having a separate
place to call this we can reuse some of
our logic so let's come over here to our
library we want to push all the logic we
can into that library remember that the
forms aren't going to say our final UI
we may go to a web-based or WPF based
application at some point down the road
and so we don't want to have any logic
about how the the turnit works in our
forms code behind because we'll have to
recreate that in the new system so
instead we'll push it all the library if
possible so over here in the library we
have the text
connecter processor and that does some
processing stuff but it's just for tax
and it doesn't feel right there because
that's part of the data access folder
and that's not what we're doing here
we're not doing data access this is more
logic and it doesn't make sense to put
in the models folder which is not a
model it's more doing work on a model so
let's create a new class you may add to
a folder at some point but for now we'll
create right in the route let's call
this class tournament logic pretty
straightforward
make it a public static class I don't
think we're going to save any data
long-term in this class so instead we'll
make sure that we have our data come in
go out in the same method and therefore
can be static now if we find out later
yeah I kinda wanna store information
long term they can convert it over but I
don't think that's in the plans right
now so let's leave it at static and
zipping start there so what methods do
we need well I'm actually going to take
this logic right here and copy it and
over here at the very top before you do
anything else
I'm going to paste it in that we know we
have to do this stuff in here so I'm
just going to create a public static
void create rounds tournament model
control dot using tracker library dot
models and this for now will be my only
static public static method and so if
job is going to be to create the rounds
or essentially do all this logic so what
will happen is over here we can actually
call it now
save this right here we will say
tournament logic dot create rounds and
pass in our tournament model so it's
going to do all the work of actually
creating those those rounds and it will
put them right in that tournament model
variable because again we got to pass it
back and forth we pass it in now both
let's have that same address that same
location therefore they can do the work
on it and then we can go on to the next
step which is actually creating
determine so in essence we're now done
with this create tournament button on a
sword click that's it we're done now
there's no logic here yet so we won't
actually create the rounds but as far as
this button is concerned we're done so
let's start working on our logic we
first need to order our list of teams
randomly what seems like what we need is
a private static list of team model
randomize team order and we're going to
pass in a list of team model now am i
passing back out a list of team if I'm
passing in a list of team well because
we're going to pass in the list of team
from this tournament model we won't
override that list we'll create a new
list with the randomized order so
therefore we're going to have where I
call that and rest a list of team model
randomized teams equals randomized teams
our team order model dot
and where's our teams entered teams
there we go so what happens here is
we're going to pass in our entered teams
which is a list of team model this
method is going to randomize the order
and return a new list with those
randomize teams so now the question that
comes how we actually randomize our list
down here in fact if you wanted to go to
Google and just type in how to randomize
a c-sharp list of T and you'll probably
get this stack overflow question what's
the best way to randomize an order of
generic list and T in feature and the
accepted answer is this right here
that's a pretty good answer in fact they
even improve on it down here with some
thread-safe stuff but really our
application we don't need to get super
complicated like down here for
cryptography and doing all this that's
really for if you want to be absolutely
sure that's fully randomized all the
rest or leave them randomize it can be
but if it keeps scrolling you have this
answer now there's an awful lot of
discussion down here on whether this is
a good idea or not if it's a efficient
way or not if it's actually randomized
which is not or not but this is a pseudo
random answer and it's really simple so
what happens here is you take a list in
you do an order by and that's one of
those things we've done with the lambda
expressions where we say it's actually
linked instead of saying where x equals
grid and sine x dot whatever instead of
doing that we do order by it's the same
idea we're going to return an ordered
list and so heat is it a is it X but
here we're going to order by we order by
good new gooood well what's a good first
of all a good is meant to be a unique
identifier in theory there are no two
Goods they're the same it's in create a
very long character representation a
text representation
I believe it's addendum it says down
here a 16 byte value so going to a a
large value and create that as the ID
we're going to order our entries by that
new good for each row which means that
we have this identifier that's
supposedly unique and they don't get
created in order like a let me do with
our IDs in sequel they're not one two
three four it's just as random 16
character value therefore if every row
gets one of those and we order by those
in theory is pretty random in fact it
could be fully random or they can be not
quite random because Gulas are not meant
to be ordered it's not designed to come
out in a random order and so we could
have two they're pretty close together
or might get kind of clump but in theory
fish come out randomized now in our
instance on a copy this line right here
in our instance we don't
it is not worrying about cryptography
this is not worrying about you know
launching a space shuttle or letting an
orbiter on the moon or on Mars
this is randomizing a team order it's
not going to be the end of the world if
it's not exactly random and this
solution right here is elegant in its
simplicity so very easy to understand
therefore I'm going to use it now the
great thing about using this you
is I don't have to feel bad because if I
use this and then say you know what
every time I do this
the last team comes out first whatever
weird funky scenario I come up with that
I can say at that randomize might not be
random enough and so I can come back
here and modify just this randomize team
order method because it takes in a list
of team and it gives back a list of team
everything else it doesn't care about so
I can change this method internally as
much as I want and put that massive
cryptography random system in here as
long as I returned a list of team model
it all cares about all the rest of code
will still work so I can feel
comfortable doing this now and saying
later if it doesn't work I can come back
and change it without changing half my
application all right so how do you
actually do this well we're going to say
return teams dot order by x equals
greater then gooood dot new gooood just
like they did dot two lists now ordered
by sorts the elements and returns a new
list and as two lists will convert to an
actual list of T instead of a I ordered
innumerable so now I've returned this
new list and we're good to go now you
just you just randomized our list
excellent it's always good to feel like
you've accomplished something in your
application even when it seems
overwhelming if you can do a small chunk
or two it really gets you in the groove
of okay you can move on do more so now
you've got a randomized set of teams we
next need to see you
we need to have more bye weeks entered
how we going to do that well we need to
figure out which value applies to us so
let's create a new method actually
create it right here they may wonder how
I do my ordering of my methods and it's
really pretty simple I put my methods
closest to what I'm doing which means
that this method right here gets moved
down and that's okay what allows it
allows me to see the work up here that
I'm doing while I'm working down here
and see the work I'm doing down here
let come up here and use that and so it
keeps those two pieces of code kind of
close together while I'm working on it
then later I will move it down again if
I need another method so it it really is
more a matter of the efficiency one
coding it that is about a specific order
some people love to have all their
public methods up top inspection and
then all our private methods down below
in a section and they may even kind of
rope those sections off but I don't
really find that's useful I find most
useful to do it as I feel it's necessary
when uncoding initially so let's call
this method private static int find
number of rounds let's go to the number
of rounds and we're a pass in our let's
pass in our randomized teams list but
the list of team model teams doesn't
matter which list a pass in but let's do
that thread say int rounds equals fine
number of rounds randomized teams and so
that's
you call it now we have to do the logic
here and so we're going to say do it
into output equals zero all right now
the logic of this is a bit of a work in
progress it's something you to work
through and make sure that you run
through a couple examples to make sure
you've got it right when I built this it
took me about five or six passes
honestly before I figured out exactly
how the numbers work in part that's
because I'm not great with numbers when
it comes to less than or equal to and
evaluating and multiplying all the rest
it kind of messes my brain a little bit
and so what I do I try it
in fact I'll create another program and
just try some examples where I'm just
working through the numbers to make sure
the numbers come out right so I would
encourage you to the same now the first
thing I need to change here I'm thinking
about this and I say you know what this
list of team I don't need it I don't
need to know who the teams are all I
care about is a team count the number of
teams and say int team count and then up
here I'm going to pass in just that
count because that's all I care about is
a number of teams now besides my outputs
I also have this into the ow let's start
us off at two actually have to start my
output off within one and that's kind of
unusual for me you just start an InTown
at zero and once it's vowel about well
I'm going to loop through in a for loop
I'm sorry in a while loop and I'm going
to try and figure out how many rounds I
need to go so let's start off by seeing
it and then kind of understand why I'm
doing what I'm doing to do a while loop
remembering a while loop you evaluate
what's in the parens here first to see
if it's true if it is then
you run these this code inside crater
braces until it's done that comes back
to the top and says is it still true if
it is right again until finally this
says false and then we skip over doing
anything here and come down below which
means that a while loop could run zero
times because if this is immediately
false this code never gets run so what's
the code I put in here first let's do
the evaluation and we're going to say
that while val is less than team count
now let's first see what it's going to
look like team count well what if it's
two teams if as two teams will have just
one round because they'll play each
other and they're done so if we pass it
to in here is Val which is two less than
the team count no
therefore we never run this code
therefore at the very end we return
output which is one well that's one
round perfect but what if team count is
three well three teams means two rounds
because the first round just like we had
in our diagram the first round is that
first set of matchups and the second
matchup has a buy-in the winners of
those two matchups go to the final round
and play each other their fourth two
rounds so we're going to go in here and
do the logic what's the logic well
output plus equal one and that plus
equal simply symbolizes output equals
output plus one that's just shorthand
for doing this all right and then we
also say Val equals I'm sorry times
equal
- again that's shorthand and you'll
probably figure us out already but Val
equals Val times two so what we're doing
here
well we're saying that Val now becomes 4
because 2 times 2 is 4 and outputs
becomes 2 so this is 3 and this is 4 4
is not less than 3 therefore we're done
we don't do any more of rayna's code
therefore return output output is 2 2
rounds perfect if the team count is 4
it's still two rounds well 4 equals 4
therefore is not less than 4 therefore
we still return two rounds you see that
works may draw on paper make sure that
you understand how that logic is working
but essentially what happens is we
figure out by multiplying by 2 y
multiplied by 2 well that's how the
rounds work we have to multiply by 2 so
the next time evaluates it's going to
evaluate 4 times 2 is 8 so is 8 les
matine's count the next time is 16 less
than 18 count until finally we have an
evaluation that's false and return that
output so now we know the number of
rounds but how do we know the number of
buys which is in let's call it buys
equals what it was there this minute so
how do we know how many buys we need for
example if we have three teams like we
did in our our logic design notes the
beginning of this lesson we have three
teams we have one by well how we know
that well when you do it our
multiplication here and that's will
create a new method private static int
number of byes int rounds int number of
teams now there is a method inside C
sharp called math dot pound and what
that does is it takes one number let's
say our number is two and takes it to
the power of say four so if we put the
number of rounds here like this what
happens is a two to the fourth power 2
times 2 times 2 times 2 which is 16 and
that work except for one little thing
math dot pal returns a double and it
takes in doubles as well so we have to
do a conversion back to an int I really
don't like that because it can cause a
mess sometimes we'll it probably not
but really doing this on our own
isn't that hard so let's do that let's
do int output equals let's just all
right equals zero and then we're going
to do is find out how many teams total
we could do in our rounds
and that is the number of rounds we've
got safe say we have four rounds maybe
16 teams we're going to find out that
number 16 input in this total teams then
we'll just say total teams minus number
of teams equals our output or the number
of Vice because if we have 16 maximum
teams in here and the number of teams is
15 16 minus 15 is 1 by all right so how
we do that well we're going to say for
int I equals let's change this up a bit
and say 1 so if I equals 1 I is less
than or equal to not a length but
instead rounds now it's a little
differently normally do with a for loop
normally start with I equals 0 and I is
less than something but that's for a
zero based counting system we don't want
a zero based counting system we want to
one based and here's why let's walk
through this we're going to count from
one to the number of rounds that's why
it's less than or equal to so one and
two then three then four Iran four and
then we're done because we don't run in
five because five is not less than equal
to four and we're pretending like the
norm of round is four so what we got to
do in here well you start total teams
off at one and we're going to say total
teams times equal to so if we run it
once so if number of rounds is one we'll
come in here and say total teams times
equal to that's why you had to have it
one not zero because zero times
do is still zero but one times two is
two that's a total number of teams in a
one round tournament but if this is 2
we're going to go again what's 2 times 2
that's 4 that's the total number of
teams a two round tournament and so on
and so forth so that'll give us the
number of teams total after that we can
say output equals total teams minus
number of teams actually in our
tournament return outputs so now we've
found total number of teams we've
subtracted the actual number of teams
and gotten our value of the number of
bias now is up here with a number of
byes four rounds randomized teams dot
count so the number of rounds and the
number of actual teams and that gets us
our number of Bice so now we have or the
list randomly we've checked if it's not
big enough or if it's big enough and now
when you do the matchups now how you
going to do that well you might have
guessed we're going to start with a new
private method private static and the
question is we return something or not I
think the answer here is yes we return a
list of matchup entry model because over
here in our models we have a looks not
match entry a matchup model we have a
list of matchup model for each round so
we'll return a list of matchup model and
we'll call this
creates first round we're going to pass
in int the number of lies we're going to
pass in our list of team model teams it
will pass in int rounds the number of
rounds we have total actually running up
passing the number of rounds we don't
care because the first round we're going
to use every team plus every by so this
first round method doesn't even need to
care about the number of rounds because
it only does the first round so we can
ignore the number of rounds now you may
ask yourself wait a minute kind of
locking yourself in here because this
only does the first round why wouldn't
it do every round well the first round
is different than all the rest because
the first round we know who the teams
are after this first round we don't know
who the teams are it's all based upon
previous information and so in this
first round is different than all the
rest therefore to give its own method
now you for we actually do anything in
here let's first take a look at our
matchup model to see we need to create
it needs an ID which you don't get yet
that gets set we actually store the
database but then needs a list of
matchup entry model so we're out
actually pop that open in just a minute
and we'll close these other tabs out we
don't need them we'll leave us and open
and will actually pop open this so it's
in create a list of these well it's the
team competing we know that score seems
zero and the parent match up also blank
because we don't need to know who that
parent is at this point because there is
no parent this first round so match up
entries pretty simple we'll create two
of those we don't know the winner
and the razzing one so this first one
pretty straightforward the only thing
weird to deal with are these buys and so
how you going to deal with those
effectively I'll show you how I drew up
this design first let's do a list of
matchup model called output equals new
list of matchup model and then going to
do a for each we're going to say for
each team model team in teams so it's
going to look through all of my teams
here one at a time now the next thing
that I do is I am going to create up
here one matchup model USA this is the
current model equals new matchup model
and here's why I'm going to loop through
here but remember a team is only half of
one matchup and so what I need to do is
find out what the other half is before I
complete this matchup model so going to
loop through the first time I hit a team
I'm going to put that in the matchup
model but they're not doing anything the
next time I come through I'm going to
add a second team and then say okay that
matchup model is complete add to the
list and create a new one then loop
through again grab a 13 the fourth team
and so on and so forth buys linked a
little bit trickier but essentially what
will happen is I'm going to add the byes
to the first teams going to list so team
there one gets a bye if there is one
team number two gets a bye if there's
two buys or more and so on and so forth
that way I can get rid of those first
so let's see the logic for this I'm
going to say curve dot entries remember
entries is a list of match up entry
model dot add new entry model now say
the parents match up don't we can ignore
score ignore the team competing equals
team that's a very first thing that
happens so to add one entry and now I'm
going to say if the buys is greater than
0 or cur dot entries dot count is
greater than 1 now what does that do
well if we have a by still available
meaning it's not zero then really we're
done with this current match up because
it gets a by a by we don't add another
entry to our list we have the 1 or if we
have no buys but there's two entries in
this list mean is two teams either way
we're going to run this code where we
say curve dot we don't do ID but we do
the we don't do winner we do match up
round equals 1 why is that hard to it
because this is create first round
therefore what it's always 1 and then we
say output dot add cur and the rest say
cur equals new match up model so we'll
reuse this variable after we've added
that instance to our output list
and the last thing you need to do is we
need to subtract one from our buys if
buys is greater than 0 so if buys is
greater than 0
buys minus equals 1 now what that's
doing is saying if it was a buy that
guy's in here then make sure you take
one buy a way we've used it otherwise if
you had one or more buys everyone gets a
buy and that wouldn't be a fun
tournament so now we have set the match
up round we've added that entry we have
restarted our model and we've subtracted
1 from the buy if we use 1 now we come
back to the top of the for each get the
next team we add it to Kurt and we say
is buy is greater than 0 or is the entry
count greater than 1 now let's pretend
you only have one buy and we already did
down here we already the first person we
add the buy and complete it's now you
come back up the second time and we add
the next person and we don't have a bias
0 and the entry count is only 1
therefore it's not greater than 1
therefore we skip over this if statement
eyerly come back here and another entry
which is a third person and now we have
two people in our entries lists now
entries not count is greater than 1
therefore we add that person to our list
and we create the new match up model
which actually in a three person
tournament wouldn't be used that's okay
we come back to the for each there's no
more teams therefore we're done
therefore we return outputs and we're
we've created our first round now so far
we've written an awful lot of code and
haven't run this application and that's
a little scary my encouragement to you
is take pieces of this you can test and
can make sure that the logic works and
put somewhere else make sure that it
works like create small console
application trying it out because
otherwise we've now written a couple
hundred lines of code they're going to
debug at some point and if we have a
problem
debugging a couple of hundred lines is a
whole lot harder than debugging 20 lines
so whenever possible break this up as
smaller chunks the problem here is that
we're really doing one flow of thought
we'd like to get through the whole flow
of thought so that we actually see it
work entirely so we're not actually
testing at this point yet so that's just
something to think about if you're doing
this application your own maybe you do
test it maybe you do try and figure out
a way to get to work temporarily like
for example create rounds may at this
point you create your first round and
then return everything and just look at
the data and make sure it looks right so
for us now I'm going to do is I'm going
to say model dot rounds dot add create
first round byes randomized teams
and so what this does is it calls this
method here is create create first round
takes the output of that which is a list
of matchup model adds it to a rounds
which is the first round and now we've
got the first round actually in our
tournament model again if you want to
test at this point just return or be
done right now and then look at what
happens by inspecting that after it
comes back and that's actually in the
code behind here so you come down here
and say after the stamp so like right
here put your breakpoint run to here and
then check to make sure you have one
round and it's populated correctly
because that at this point it runs this
all is code so down here all that code
has been completed
therefore TM should have round one in it
but we're not going to stop there we now
need to do this create every round after
that how you going to do that well
private static void create other rounds
not really creating but essentially it's
every round after the first person want
to name it create every round after the
first so I call it create other rounds
now why is it void well we're going to
pass in tournament model model and that
would be this model right here going to
pass into this method because we're
going to add all the subsequent rounds
directly to the model then the only
thing left to pass in is int number of
rounds that way we know how many rounds
to do all that math has been taken care
of for us we don't need to know the
number of byes because that always
happens in the first round and after
that we don't do any more
so up here you will say create other
rounds model rounds done and again we're
not passing back a value because we're
operating directly on our tournament
model instance therefore no pass back is
necessary and if you've caught it by now
we're done with this public method
that's all it's going to do this is a
quarterback method so I call it what it
does is it says okay you do this you do
that you do this and keep going on down
a list commanding others to do the job
inside the boss it tells others what to
do and it just make sure the flow is
right from start to finish and so in
this instance the job of create other
rounds is to create every round after
the first now launching in here
shouldn't be too tough going to follow
the pattern we did down here actually
and do something very similar it's just
we're not going to have the team's to
loop through we're going to loop through
the previous previous matchup models a
list of them so let's start by having a
int round and this represents the
current round we're on so they'll start
off at round number two again we create
the first one already so this is round
two restaurant and then let's create a
list of matchup model I'm going to call
this previous round now what is this
well we have to work on the previous
round in order to evaluate to the
current round therefore grant captures
us in a list separate from our team
motto or tournament model their
tournament model has a number of rounds
and we don't want to get muddled up with
finding which one we want to pull out as
the previous one so let's create this
variable here it will actually populate
it initially this model dot rounds I'm
going to say rounds number one which is
actually position zero so this is going
to grab the first list of matchup model
in our rounds variable and since you
only have one list of matchup model nuts
but when we got from here create first
round there for testing the first round
initially so now we're going to say wow
round is less than or equal to rounds so
rounds plural is a total number of
rounds we're going to need round is the
current round run and it's less than or
equal to if you have to go through that
last round
now here the lunch actually gets a
little bit simpler than down here
because down here we have the current
entry and the next entry and all the
rest whereas here we're going to do a
for each for each and it will be a
matchup model called match in previous
round
so I loop through all the matchups in
this previous round in the first I do
this it's being round number one where
I'll loop through these were on
currently round number two now what does
that look like well again remember that
in our example from our notes way to
beginning we had Jen versus Tim and we
had su vs. by so those are the two
matchups in this list now su versus by
be first because the first person gets
to by so pretend su versus by is the
first matchup in here now we're going to
do is we're going to have a current
round so
do list of matchup model is current
round equals new list of matchup model
that's empty and actually have to add
one more thing up here we have to have a
matchup model cur matchup equals new
matchup model so now here we can say cur
matchup dots entries dot ad right create
new matchup entry model and the parent
matchup that's where it comes from
we're going to say equals match because
the parent is a matchup model so this is
in the previous round aggress say well
that was the match it came from
now why parent matchup because the
parent is the original matchup that the
winner from that matchup came here now
we don't have the score and we don't
have a team competing we don't know the
winner is yet that's team competing is
the winner so I create one of the parent
matchup matches and that's it so now
we've added a new matchup entry where
the parent is from the previous round
that match if curb matchup that entries
dot count is greater than one now just
like down here cur entries count is
greater than 1 same thing here if we
have more than one entry do this now why
don't I say equals 2 and the reason why
is because if for whatever reason I had
some kind of funky logic in here where I
skipped
and double added something so add to or
say three even so add three somehow well
if I have three it's not going to say
equals two therefore it will keep
running and add more and more and more
in infinite loop and that's a problem so
greater than one make sure that I
captured it too but for whatever reason
I got beyond - it's still okay now would
I really have a problem yeah
I'd have a problem and that might be an
instance where you say no I want to
throw an error if it's more than two but
in this case I'm going to say greater
than one for the count so it's greater
than one meaning to do I'm going to do
is I'm going to add that to my current
round current round dot add current
match up and then current match up
equals new current matcha or match up
model so I don't have to do this by
check in here and I don't have to do it
if statement down here I just need to
add the output and/or add to the current
round and reset the actual instance I
don't have to deal with this plus equals
one or all the rest of stuff oh I do
need to deal with equals one though I
need to say current match up dot match
up round equals round so that's the
current round we're in so I start over
two then three four five we get that far
so now I've added that match up entry to
my round my current round then I come
back to the top and keep going until I
have looped through this entire previous
round
and created half as many matchups
because I put two people in every
matchup therefore if I have eight
matchups in this previous round I'll
have four matchups entered into the
current round so that's all good now I
get down to here this is where we've
looped through the previous round
already and we're done
now that we're done adding the previous
or the current round I've completed that
when you do a little cleanup here and we
need to add this current round to our
model model dot rounds dot add current
round round plus equals one to make sure
we are adding to this round otherwise
again an infinite loop and we'd have a
wrong value for this right here when you
say match up round so now you can add
that current round to our rounds now we
have to reset the current round well so
we say current round equals new list of
match up model before we do that we have
to do one more thing one more clean up
thing and that is previous round equals
current round and that way we'll take
this list and we'll put it into the
previous round so now the previous round
gets its value from the current round
and now I can move on to the next
iteration of this loop once we're done
all these looping we're done that's
because we've add every entry to our
model dot rounds so that now the model
which is turning model its round is
pocketed with every set of rounds and
that's all we had to do in order to
complete this create rounds before we go
on let's review our checklist of things
we had to get done in this method order
our list randomly or list of teams yep
we did that check if it's big enough and
if not add Bice yep we did that create
our first round of matchups yep and then
create every round after that yep we did
all that and all that's been called
inside create rounds and create rounds
was called by our our code over here and
in heaven opened all the down here we
have that call to create the rounds so
we've wired ever match ups now we'll
just need to make sure we actually save
our rounds inside this create tournament
method we have that one to do yet and to
come down our task list we'll see that
we have it to do their capture round
information and that's in our method
here convert to current model when you
capture our round information so that's
pulling the information out we should
also have it to do down here for making
sure that our our setup is correct for
saving the information as well and so
we'll check on that as well that's
should we down here and I bet we don't
have a to do so we'll make sure we get
that done but
that's actually going to be for the next
video I know I would really want to
finish this in this video but it's just
too much information to do in one video
without this mean this video really just
too long
I mean we're we're almost at the
blockbuster movie length so I know it is
not a blockbuster movie but hopefully at
least do a good opening weekend but I
want to get to this this logic and make
sure you have it saving to the database
properly and that we're pulling it back
out as well so we'll check on that in
the next video and then do a whole bunch
of testing and some debugging if things
don't go well so let's make sure you
come back to that make sure you kind of
finish strong enough on this form and
then the good news is that we are almost
over this hump and once we're over it
it's all downhill from here
because the rest the logic is really
simple and so we'll just complete out
this application and then come back
through all right come back through and
add exception handling for error
handling we've talked about that will
also add the idea of emailing people in
their turn to play and will also even
add events possibly if we need them and
we'll also add in a video they'll be
just for the the people who are our
purchase in this course we'll have a
video for not just emailing people to
also texting them so right add a few
other things in here before we're
actually done but we only have two forms
to go and that extra stuff and then
we're done with this application so
we're getting close so stick with it
keep pushing through and follow them
long as I go so that's it for today
we'll move on the next video shortly</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>