<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Reinventing the REPL - Kovas Boguta | Coder Coacher - Coaching Coders</title><meta content="Reinventing the REPL - Kovas Boguta - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Reinventing the REPL - Kovas Boguta</b></h2><h5 class="post__date">2013-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sSQ1dqqINrQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's great to be with you last year was
my first closure conch so it's pretty
neat to be up here a year later talking
about what I'm building with closure and
de Thom McAn closure scripts and all the
other tools that we have so I'm really
grateful for all the people involved in
producing these tools since they're
helping me make progress on things that
I've been working on for a long time and
kind of finally getting somewhere so the
title of my talk is computable stories
because that's what session is about
it's about stories that are about
computations stories that are
computations so let me start unpacking
that for you so here's a quote sort of
our starting point most of our systems
live outside the bounds of any single
process we write so this is a quote from
a rich hickey from the first database as
a value talk and it's a point that he
elaborated upon yesterday in the keynote
and the point that he was making was
sort of no matter how nice it is inside
the bubble inside of our individual
process where we have the facilities of
closure and the state identity kind of
management situation we have their you
know these processes live in a broader
system and that broader system can
potentially reach into our process the
complexity from the broader system can
reach into our process and make things
complex for us there even with those
facilities that we have so kind of a
canonical example there is the database
you know complexity in the database
reaches into our individual process and
makes it harder for us there and it's
not only just can't what happens within
that bubble but it's about the
boundaries of the bubble right so what
does it mean to be an application server
you know part of the definition of that
is sort of defined by the attributes of
this greater system you know the
attributes of the database define what
it means to be an application server the
database is over there that limits the
architectural options you have it sets
the boundaries on the bubbles in which
we work
so the database is not the only thing of
this nature that's kind of reach into
our programs making life hard there and
then defining kind of the boxes in which
our programs can operate another thing
is the humans humans are part of the
systems as well right you know we are in
there setting up setting up servers
standing up systems changing the
architecture of our systems creating
values inserting them in places you know
where as much of a part of these systems
as the database as the application
server as anything else so the problem
is when we are computing as humans sort
of within the language of the system you
know there's no information model
there's no process model there's no
notion of update there's no kind of
built-in notion of conveyance you know
we're sort of flying blind without the
without the sort of facilities of
closure inside the process and without
and outside the facilities of kind of
however we set up our system to handle
some particular case and what ends up
happening is we're just constantly
blowing our foots right off you know
who's ever overwritten a piece of data
from the repple right you know this is
is this is stuff that happens all the
time you know we set up we set up some
system you know we you know initialize
it with some parameters you know we
close the repple and then a week later
we forgot what we did you know how you
know maybe we remember in generalities
what we did but you know what was that
second argument for that function that
we use to initialize this thing you know
and maybe it's usually this but in this
special case there was this other thing
and now we forgot what that was you know
we come back to our system and you know
now we kind of have to remember that
from scratch oh we get this area we
google it again oh this is something
that we remember was the situation this
particular case so let's you know let's
fix that so we have these kind of sordid
stories of success
in triumph and stories of failures and
we can't share that knowledge there's no
there's no sort of representation where
you can say this is how I stood up you
know my Hadoop cluster and you know
Randy's things that you can just kind of
pick up and give to someone else it's
it's always a totally ad hoc process of
oh you know let me write some tutorial
online it's a particular format in a
particular place and you know remember
all the steps hopefully we can remember
we put all those things in there it's a
pretty heavy weight thing to try to
share you know to try to share our story
is that we're living every day and
vaulting the cause of this is you know
this is a disaster of unmanaged state at
the level of human computation when
we're computing with our systems that's
that's kind of the ultimate cause and
the tendrils of this you know there's
bazillions of them and hope you know
maybe at the end of the talk I'll have
time to unload the full clip you know at
the rebel and kind of enumerate all the
ways that that this is causing problems
but you know we can kind of see that
already just kind of at a basic level we
can't remember what we did and we can't
reproduce what we did we can't share
with other people so kind of the
question that I have is what is the
closure way for human computation now
how do we apply the principles and
methods and tools of closure and atomic
to this case when we're doing the
computation and kind of the the key idea
is you know the thing that we can hook
onto is narrative because narrative is
where humans meet computation now they
are that sort of veneers concept that
humans can relate to to what computation
is so here's here's a basic observation
computation is a narrative and narrative
represents a computation you know
they're both kind of essentially about
going from point A to point B through a
series of steps you know sort of a
series you know an evolutionary process
that does this transformation from point
A to point B and it's it's all about
that sequence really
that's kind of what defines both of
those things if you just take the last
element of the sequence then you've lost
something essential right if you take
the last part of the computation the
output you know that's just a piece of
data that's no longer a computation
that's just a piece of data you take the
last element of a narrative you know and
then they lived happily ever after right
like you've lost something kind of
important you know it's not just about
the end you know it's about what
happened and sort of the meaning of what
you know the end is in the context of
what happened the meaning of what's in
the middle of the story is informed by
what happens later and what happens
before it and the reason why we care
about the overlap between these two
concepts is because narrative is the
most powerful way of communicating
knowledge it's the most general way of
community communicating knowledge and
for certain kinds of knowledge is it is
the only way of communicating knowledge
and I don't think it's sort of an
accident of evolution or something that
humans operate on narratives you know
narrative in nerd about you know we have
sort of the little drama of our lives
and you know we perceive the state of
the drama we compute the next step
you're the next action the world
responds and the narrative continues so
session is a system for narrating
computations the sequence of inputs and
outputs write this piece of code comes
in you know this result comes out this
piece of code comes in this piece of
this result comes out the sequence of
those pairs that's the computation that
we're interested in and what we want to
do is turn it into a value because then
we get all the benefits that values give
us you know easy to perceive right easy
to perceive the narrative doesn't have
to just be a bunch of text in the
terminal we can put it on a web page web
app have pictures in it and so forth
easy to remember we can actually
remember what we did you know easy to
fabricate easy to reproduce to relive
that sequence of steps you know there
are some fields where that is kind of
the defining critical issue of their
time right now now scientific computing
you people doing experiments how do you
reproduce those experiment
they have no way to represent some
structure that they can convey to do
that so you know you can convey to other
people another thing that's pretty
important is you can index index these
stories you know you can kind of
aggregate them index them query them and
so forth so let's kind of move towards
solving problems here so in in kind of
the more abstract case of what stories
do for us and then move towards some
demos obsession of how this kind of pans
out in in our world so the first thing
maybe the most fundamental thing stories
explain write stories explain how the
world came to be the way that it is know
how some artifact was created you know
that's sort of a oftentimes that's the
best way to understand the thing
sometimes it's the only way to
understand the thing is sort of how it
was created how he came to be so you
know who who's ever been surprised by
the output of their program right like
this is you know sort of this happens to
us like every single day and what do we
do kind of the canonical thing to do you
get some piece of data you don't quite
understand what it is or what it means
is you got to go back up the sequence
you got to go see the narrative and see
the actual steps of how it was created
you know whether it's the detail of you
know why is this date you know does it
have a time zone and you know what is it
or whatever like kind of the mechanical
details of the computation sussing that
out or understanding kind of what it
means in a broader sense of it came from
this data source and this is what the
computation was and therefore you know
we computed this about this thing you
know kind of where it lives in the
broader universe of things another thing
stories do the stories instruct it's
pretty easy to see that if you have a
story of how you went from A to B and
you want to go to be again then you help
you you have a recipe of how to do that
write stories instruct you you know how
to
do things so you know I here's the story
of how i installed you max right i
download this thing from this website i
installed something there I phone this
git repo and move those files over here
I ran it and I got this error you know
that's like the dramatic point in the
story and then but then I overcame it
because you know I did this and you know
now it works so you know one person you
know one kind of hero went out into the
unknown and came back with this
experience that they share and now other
people can follow in that path they
don't have to kind of start over from
scratch there's a path for them to go on
so a story is instruct stories also can
be purpose right they don't just tell
you why the world is the way it is if it
don't just kind of tell you how to
change the world into some new state
they tell you why you would want to do
that they give you purpose they convey a
purpose it can be a sort of values of
why you would want to do that and this
is really important because that's what
makes stories human you know that is
what makes them something you can
identify with as as a human individual
and they do so in many different ways
you know some of them are implicit just
the fact that something happened that
the story exists is sort of an implicit
endorsement that this is something worth
doing we're not doing that potentially I
think depending on your interpretation
and some stories just you know go
explicitly you know I did this and it
was good because you know X and you can
see that you know I implemented this
algorithm and things went faster
compared to the old algorithm and so
forth so stories convey purpose so let's
let's put some of these problems in
context so what's the biggest problem in
closure we actually know the answer to
this but you feel free to shout out
anyone anyone
so that's a problem it's a problem
that's not the biggest problem though
okay all right so the biggest problem is
documentation so I'm not just kind of
you know using my opinion here we have
this 2012 state of closure survey from
Chaz Emmerich doing excellent work there
so thirty percent of people you know the
highest number of all the possible
options said documentation lack of
documentation was the biggest thing
holding them back so obviously we have a
bunch of experts here so maybe it's not
as big of a problem now parenthesis may
still be a bigger problem for for the
people in this room so let me show you
an example of how we made how we might
do documentation so let's go to a
session here and okay so here's session
and i hope people can in the back and
see you can see this okay let's see all
right great so like I kind of mentioned
earlier the foundation of session is the
idea of a series of input and output
peers so let's let's sort of go ahead
and make sort of a tiny little closure
that closure language tutorial so we're
going to say here is apply a function
and you know here we have a example of
an input and an output results let's say
sort of apply a function across a back
door right so we can say map plus one
percent and then put some data in here
alright looks like it actually works
excellent and you know we can sort of go
on right and just kind of start adding
these examples take two elements moments
from beginning well
take two so we're sort of building up
this sequence of stuff and right now it
doesn't look much different from your
typical rebel session other than of
course you know we we have a web app
here we actually have a simple version
of part edit operating in here there's
this thing called subpar which gives us
some simple party capabilities which is
nice but let's just do sort of one more
thing reverse for a sec door so we can
fill this out here reverse alright so I
just kind of pretended to be the author
here sort of making examples of using
functions that you know I've written or
whatever someone else is written and now
we will simulate being a consumer or
reader of these little stories so you
may have not seen what happened but I
just reloaded the page right sort of the
equivalent of closing the repple window
and opening it back up and all the stuff
I did is still there where all the stuff
someone else did is still there and you
can just kind of go in here and start
reevaluating stuff you're not kind of
copying and pasting from some static
text somewhere or and you're not sort of
reevaluating code that's sitting in a
text file that does not have the output
right like if you don't know what nap
does and you see this example and you
don't have the output when you evaluate
that example how do you know the output
is correct you don't you have no idea of
what you're getting is correct or if you
see an error you know is that the
correct thing to be happening and not
only can we sort of relive the story
that was written before but it's sort of
as if you have the storyteller right
there and you can you can ask questions
about the narrative right oh you know
here's the detail part of the story and
I don't quite understand it so let me
sort of you know ask more detailed
question of what happens if it was like
this right you kind of can ask the
hypothetical questions and the bits
the narrative to enhance your
understanding of it so let me prepare
the next demo and then go back to my
slides here all right so play slideshow
all right so that's sort of an example
of an instructional session examples
without the insulin incidental
complexity and just kind of go to it
start evaluating stuff sort of
minimizing other fuss and it's it's
certainly better for the author you know
all they need to do is deal with the
closure evaluation environment maybe
they're doing this for their own benefit
and it's certainly better for the reader
/ user you know you have the examples
right there in line you could start
evaluating stuff right there in line you
know you have the sequence of examples
and you can permute them ask more
questions about what happened it's
certainly much easier to share and index
and you know sort of who's ever received
an incomplete bug report right like in
this kind of system it's there's a
direct line from what i have now too
well someone evaluated this example and
it blew up you know check mark you know
send off to you know some repository
indexing service somewhere you know kind
of notify the author of the library that
you know you had a bad user experience
in this case and they can get the
history of what you did you know and the
annotations that are happening behind
the scenes in session sort of adding
meta information and you can go beyond
that of course you know submitting
submitting tests you know why are we not
collectively creating repositories of
tests and it's because you know there's
no way to kind of share those lumps of
stuff in the in a reasonable way but
also because there's no user interface
hooks and this provides user interface
hooks were those sorts of things you
know this thing is something we think
should be a test you know click this
send it off to
the central test repository or whatever
so let's let me give you another example
sort of more complex example of what we
can do hopefully things have loaded here
properly yes okay so so who read the
codec blog post okay so who was
interested in kind of analyzing their
own repository okay so how many people
go went ahead and actually did that a
few okay actually these are decent
fraction of the people that raised their
hands for the second question but so
there's there's quite a bit of drop-off
in that in that conversion funnel and I
would argue the reason for that is the
same reason why you know what happens to
many projects which is you know you have
this kind of static bit of code and
maybe some explanation of how to use it
but you can't just kind of jump in to
start evaluating stuff and start doing
stuff so right here I have a session
that goes ahead and does a bunch of
analysis or some analysis on the closure
github repo so I'm going to go through
and so so when these things load they're
essentially you know representations of
what happened and I want to reproduce or
sort of relive what happened so I'm
going to go ahead and step through some
of these computations oh all right well
that's a little suspicious let's see
well let's see what happens here so I'm
going to step through these computations
okay all right now I'm starting to have
some confidence that this is actually
doing something good right if I did not
have the output together with the input
I wouldn't necessarily have confidence
that my revaluations we're doing the
correct thing so I'm going to explain
some of the some of this code that's at
a point when I kick off a more
substantial computation
okay yeah we're almost there okay so
this is a little bit more substantial
computation will take take them two
minutes or so and what it's doing is so
in the in the codec example in Rich's
blog post the kind of computation given
as an example was finding the novelty
that's being introduced into the
repository so you know a given commits
you know it modifies various code and
during that process you may be
introducing new definitions for
functions hopefully that's what you're
doing and then the question is when you
know sort of given the function given
the symbol what are the unique
definitions associated with that that
have happened during the history and
when sort of when was the unique time
that that was first introduced so you
know for instance you know for the
closure core map function there's I
guess four different definitions that
and those are the corresponding commit
entities for the when those different
definitions were introduced and just to
kind of show you a little bit more stuff
here we're still computing the commit
the that thing there but so one of these
commit entities basically looks like
this right you have kind of the commit
message in this particular case you know
some tests weren't you do sign nothing's
like the committed at time the Shah you
know so on and so forth so we're still
waiting for this thing to finish but
while we're doing that let me sort of
show you what you can do when when it
does finish ah well there it is great so
even without having had the computation
in hand I had already had some code here
that kind of shows you what the
structure is right so we take the first
from that commit sizes thing and you can
see the first thing is a big number and
the second thing is a smaller number
and you know if we just kind of look at
the structure of the code it's pretty
obvious you know the first thing is the
committed entity and the second number
is the number so it's the number of new
codex novel codex introduced in that
commit and I'm kind of interested in
that because I want to see you know how
many commit how many new codex are
introduced at each commit over the
history of the closure repository
because I think that's an interesting
question and it's launching launched off
point for sort of more questions so we
can take that data and just make a plot
this pot is a closure expression eating
data it's a tag literal when it turns
into when you get sucked into the into
the browser it kind of turns into a Java
object or a JavaScript object so you
know commits can have come it's can have
the same committed at date so we need to
do a little bit of transformation to
first accumulate all the all the commits
that happen at a particular date and
then turn that into the plot and that's
what you get you see there's a few
commits that totally dominates you know
it was just like tons and tons of new
things introduced and those commits and
you can find those pretty easily by
filtering on the commit size variable
there get things bigger than 400
different codecs touch those entities
and you see okay one of them is when
they added though you know one point 0
introduced that thing and all the
metadata another one is removing the
deprecated some deprecated reader macro
from a bunch of functions and then we
can do things like well let's filter
things they're all under commits that
are under 100 different things changed
and kind of see that so it kind of looks
like the most intensive period of
closure development was around here you
know 2010 June you know June and in July
seems like a bunch of stuff was
happening there and if we're kind of
interested in closure historical
research we might want to continue
looking at that direction but you know
that's sort of not really the point of
my talk
the point of the talk is this is a
knowledge artifact right I've done this
for closure and now I've kind of solved
that problem and if I give this to you
it's pretty straightforward for you to
just modify this code to operate on your
own repository or you know you could
also choose to continue the kind of
closure branch and explore closure some
more but you don't have to start from
scratch you can you know you kind of can
just go in there have a starting point
it's basis for modification and you know
where that you sort of know where the
narrative goes you know it's not just
some API where okay you can
theoretically do some capabilities and
it's also not an application you know
for me to turn this into an application
a parameter aiza Bilal occation where
you put in your repository and out comes
a bunch of analysis you know that's a
bunch of work and that's a bunch of work
on top of the work I've already did
let's go back to the this guy here so so
the advantages here is you know I
basically done an experiment or produce
some results it's reproducible and
there's significant advantages over this
model over an application which would be
kind of the alternative paradigm for
sharing reproducible knowledge right you
can't share reproducible knowledge from
the repple really the only paradigm that
we have for doing that is for writing
programs writing applications and that
incurs a ton of complexity so this is a
simpler way of transmitting the ability
to do we do a computation without kind
of incurring the complexity of going
into into the application space so that
should give you a sense of kind of what
session can do and why you would use it
so let's kind of go in a little bit into
the architecture and this is the basic
architecture it's all about day Tomic in
the middle here and then you have these
machines or conveyor belts that move
things around between day Tomic and the
person and day Tomic and the system
the person in the system never interact
directly it's all going through day
Tomic and basically we have well inside
the atomic we have these sequences of
actions and results right you this human
submitted this action and the system
produced this result and those things
are stored kind of in pairs in day Tomic
and the purpose all all this other
machinery is to just kind of aggregate
more of those things in the day Tomic
database so we have the UI that talks to
the sentient being performing the
universal computations you know put
these guys in front of a ipad and you'll
see anyway so so you know the UI is both
kind of the web UI and it's also of
course the thing that talks two day
Tomic which right now we can't really do
directly from the browser in the way
that I want to do so there's a little
bit of a service I can point it there
but it's quite thin and what happens is
you know you submit your action this
thing makes a transaction in today Tomic
these services are listening to the day
Tomic transaction stream and notice that
the action sort of the request embedded
in the action is talking about them so
they're listening to the transaction
stream notice a new action do whatever
is then that they need to do and then
they report back to day Tomic now oh and
then you know that results get sent over
a web socket and then you know back to
the you know we're listening out of
transaction stream here and then sending
over WebSocket back into the UI and your
kind of seeing the result appear there
and then you can perceive you know
perceive the result perceive the history
and take take the next action so there
are several important points here the
first point is that we're not storing
necessarily the data in session or in
day Tomic yes session the atomic in this
case it's all about storing stuff about
the world it's not about being the world
you know
this thing might be you know the data
might be some terabyte thing that we're
computing with and we don't want to be
responsible for storing it there's
services to do that for us so we tell
the services things they may produce a
value and kind of have it hanging out
within their own space and just tell us
you know I did I produce this it was
this big you know and here's kind of the
first few elements of it or whatever the
only thing you need back from the
service is enough facts or the human to
make a decision off of so that does not
necessarily include all the data it
could include a summary of the data it
could include you know metadata about
the data and so forth and that gives us
a lot of flexibility you know basically
the idea here is we're just coordinating
these services and coordinating these
services and telling them how to talk to
each other so for instance you know one
action will be you know compute this
thing you know do this computation the
next action can be put the thing that
you compute it into this other storage
service so that you can persist it right
take the thing that you have in memory
in your process in sort of the closure
valuation environment and persist it to
the storage service so that it can be
around later and when the person wants
all those pieces of data about how many
you know commits I'm record at codex
correspond to each commit you know they
just have it and they don't have to
re-evaluate all this stuff we you know
just persist that value so the greater
components of kind of this architecture
is there's a this process model which is
very important there's a services which
I talked about we need to achieve
location independence for data this is
very important and we need to be able to
represent as many things as values as we
can possibly can you know we need to
push the boundaries of what can be a
value you know if the database can be a
value then
you know that's kind of that's kind of
shocking right the database as a value
like that is pretty unbelievable so if
that's possible then there should be a
lot of other things that we should be
able to treat as values that right now
are just blobs of you know imperative
building up of stuff and if we can store
those things as values that gives us and
you know that's what enhances the power
of session even more so let's go through
the process model the basis the starting
point is the epical time model of day
Tomic you know we're building on d
atomic so that that's sort of not a
surprise and the only difference it
really is kind of what happens in those
little boxes and sort of what those f's
can be so this is kind of this is kind
of the process model right here so
inside of the database we have these
sequences of actions and results and the
process of adding stuff to the database
is more of a two-step thing so one step
is the sentient being looks at the
history of actions and results right
that's narrative now this is kind of the
whole input how you decide what you do
when you're looking you know you're
looking at the repple session you're
looking in session you see these inputs
and outputs your cogitating and you then
you decide based on all of that data
what should be the next step oh you know
let me look at the first element of this
list because I don't necessarily
understand what it is or looks like
everything works you know let me take
the next step and build this graphics
your kind of processing the entire
history of the narrative to produce the
next step of the narrative and to do
that you produce an action you know
that's your job that's the company you
know that's the computation that you do
as a human you take take that history
and then you produce the next action and
then it's the process it's the
responsibility of the universe than to
produce the result right and what it's
going to do is it's going to operate on
the action like the whole history of
stuff you know that's there but that's
kind of a vague thing requiring human
intelligence to really you know make a
predictable or to make a decision out of
and we want the things that we're
telling
what to do to make predictable decisions
based on kind of local information so
the services will just call that F take
the action and then resolve it into a
result and then between those two steps
we've sort of completed the entire loop
of adding adding to our narrative so
human computation narrative in narrative
out mechanical computation action and
result out right the whole thing the
thing of the work we do that's the human
computation the mechanical computation
is the individual steps so services not
just closure evaluation right you know
if all we can do close your evaluations
and there's a hole in our model because
the reason why we're you know a lot of
the thing that we're doing in the
closure valuation a lot of time is like
talking to all this other stuff so if
that's you know sort of if that's not
incorporated in our model then there's a
huge hole in our model and furthermore
there's no need to have a closure
dependency in order to talk to these
services if you're talking to the
Twitter API asking asking you for some
stuff no why should closure be kind of a
dependency in that path you should be
able to represent those things directly
you know if you're talking to some huge
computation service so how do ping you
should be able to talk to that directly
and give it an instruction directly get
the result back directly without kind of
going through some closure layer and
ultimately what we're doing is I'm we're
telling them to make stuff and report
back and we're also telling them to
coordinate with each other you know sort
of okay you guys set up whatever stream
you need between you and you know do the
dance and tell me you know what happened
I also believe that we can have services
as a value you know AP is the things
that we have they're not that great and
there's a way to do this enclosure with
values so i don't know if i should get
into it now but you know the problem is
is again solving this location
dependence location dependence problem
now if you need some cue to take things
from point A to point B now that Q is a
place and then you transfer your session
to someone else and they want to run
this computation you know they need that
little component of the system as well
right you know if you if you have your
session and you're talking to all these
components of the system the part you
know you need the components of the
system to be values otherwise when you
transfer the session you can't kind of
transfer the computation along with it
and there's already a precedent for this
Enbridge mention that yesterday which
was actors right you can move actors
around from process to process and it is
possible i believe to take the part of
actors that confines them to have in a
specific model of communication between
each other and happened sort of break
that off so you have the ability to move
these things around but you're not stuck
with only having one protocol that they
speak to each other with so 2013 will
get that one another big problem
definitely very important to solve
location independence for the data so
it's critical for a sound information
model in your session you can't be
writing to specific locations kind of
manually because then you could
overwrite them or you know it's just
it's just a huge mess critical for
convenience again Pat you know sort of
passing the session to someone else you
can't be managing the location of data
manually yourself it should be an
implementation detail managed by datums
so you know you have some result and you
have some attribute on the results the
location the location has various
attributes like host protocol whatever
you need to kind of resolve that
reference into a concrete thing and if
your code you know if all your code ever
knows is you know I call first on the
thing and it gives me the first element
like it's a Sikh or you know if you know
the thing implements whatever protocols
I expected to implement you know then
your code doesn't care you know that
back that well the data lives in three
different places that the atomic knows
about you know s3 my local storage and
my friend over here knows about this
piece of data and you know when I asked
for when I tried to perform an operation
on that data a bunch of stuff happened
behind the scenes to figure out which
thing I should use and just kind of pipe
it into my program so we can make it
into implementation detail managed by
datum so we're not sure if it's saying
like x 1 equals this x 2 equals that x 3
equals that you know as we're evaluating
our code and then you know get into some
situation where you fix a bug in your
you know transformation function and
then you reevaluate x2 but you don't
reevaluate x3 and now you know x 4 is
not based on the right piece of data now
these are the things that we get
ourselves into constantly when we're
working with data at the rubble and then
like I said we need to lean on values as
much as we possibly can the benefits are
just enormous and we need to especially
use them for things like graphics and
you I so that we can perceive our data
and perceive our session independent of
the state of the systems that we're
based on you know if you have to launch
some complicated system and then build
up a bunch of state inside of that
process just to see what it is that you
did like this is really bad you have to
be able to see perceive the work that
you did without having to launch all
this stuff up and the way to do that is
true things as data and the way to do
that is to treat them as tag literals
for things that have a little bit more
juice than just kind of you know a map
or whatever so it looks like i have some
time so we can unload the full clip in
three minutes so the repple so what's
the basic characteristic of the repple
Oh before I unload the foot let me you
know let me just point out the reason
why I'm doing this is just just point
out how this is different from the
things that we're doing and kind of
enhance the understanding of the Ganges
of doing them at the session way ok so
the characters of the rebel is this
right it's just like Sisyphus rolling
the boulder up the hill you're just like
rolling the state up the hill rolling
the state up the hill you close the
window and then poof you know you know
it's a new day you're back to all the
work is gone and you're sort of
committed sort of condemned to a
lifetime of you know toiling your way
you know copying and pasting things into
the repple or evaluating stuff so
there's no memory and that's kind of the
fundamental problem so there's no memory
of this is state of the system before
you did what you did notice every other
serious is after you did what you did no
memory of what the heck can even did
right so there's no reproducibility
can't reproduce we can't remember
limited perception that's sort of a
consequence of you know text-based thing
there's no there's nothing to convey to
something that can represent it in a
better way sort of DIY conveyance you
know you're at the repple and you want
to save the fact that you actually did
something in this universe right you
want to persist it beyond your
particular repple session and what we
end up doing is just plop all over the
place let me save this piece of data in
this file let me put it in some other
location in storage and then you know
you end up over writing it or someone
else is overriding it or it can get
confuses up with what it's a total
disaster and then you get transcription
errors you know who's ever made a
mistake copying some code from a
tutorial right like you know we're sort
of reduced to copy and paste as our
mechanism of conveyance to and from the
repple so there's no versioning you have
no idea what water things happened in
you know we had five versions of this
function which version produced the file
on disk you know who the hell knows now
you come back to this a month later you
know sort of no idea what happened
likewise no auditing you have some piece
of data there's no way to get the
history of how that piece of data was
created there's no context you know in
which context was this piece of data
created and of course no extension of
the environment of the repple because of
such a low level text-based thing can't
kind of go in there and start adding the
send this example to the owner of the
library so that they can you know choose
to accept it into their database to
other systems worth talking about my
final minute here before I get forcibly
carried off stage so small talk and
mathematica both you know very
innovative systems especially in their
time so we're not doing small talk
images the point is not to remember for
the sake of the computer the point is to
remember
the sake of the human being so we don't
have to persist kind of all the states
so that we have one hundred percent of
reproducible stuff we have stuff we need
to persist up so that the state of the
human mind can come back to where it is
and mathematica you know we're not
storing things in documents in notebooks
that's place oriented programming that's
overwriting old information and that's
also not being able to dig out the
information that you produced you know
if you're putting all your information
to document and someone else is
interested in that information there's
some other component in the system
that's like you know give me all the new
blog posts you know there's you know you
can't it's very difficult to have
automated systems to dig into these
documents and extract out the
information you want your information to
live in the lobby level playing field
with all the other components of the
language of the system so I believe this
is a paradigm whose time has come and
with the tools that we have now we can
finally make it so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>