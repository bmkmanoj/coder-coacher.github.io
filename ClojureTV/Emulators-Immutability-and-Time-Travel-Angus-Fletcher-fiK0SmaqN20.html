<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Emulators, Immutability, and Time Travel - Angus Fletcher | Coder Coacher - Coaching Coders</title><meta content="Emulators, Immutability, and Time Travel - Angus Fletcher - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Emulators, Immutability, and Time Travel - Angus Fletcher</b></h2><h5 class="post__date">2017-03-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fiK0SmaqN20" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Angus Angus Fletcher I'm from
I work for Sarah Nova which is a company
based out of Austin Texas and out of
sunny Fredericton New Brunswick Canada
this is the I took this a couple months
ago we went for a bike ride a nice nice
day PS I really like bikes I got a
chance to do a little bit of cycling
down here that's the the ride that I
took down I have a lot of bikes and I
have invented a function to determine
how many bikes a person should have this
one's public domain you can just have it
it's this so highly sophisticated but
very important okay but for real though
we should probably talk about what I
came here to talk about so I am talking
about emulators and I'm gonna start with
some of the inspirations that that got
me into this so about two years ago I
was reading racing the beam which is a
book by by Ian Bogost and Nick Montfort
and they were kind of getting into this
idea of doing what was called platform
criticism which is sort of like they
wanted to do critical theory for games
and so they wrote a book that's sort of
like 50% Hardware analysis and 50%
stories about people making games which
I I'm really into this stuff I like the
idea of sort of beautiful and
interesting technical writing where
people try to write about the technical
but in sort of an accidental or unusual
way and so that book got me really into
it and the title refers to a really
interesting phenomenon with the 2600
which is that there were in its it's
video chip only three registers or one
register for sprite and then there was
one for like player a and for one for
missile which is just four projectiles
and so if you wanted to draw multiple
sprites in a row
you actually had to kind of cheat and in
in a in a feat of mutability what you
would have to do is change stuff in that
particular register while things were
drawing so you had to essentially sync
your code up with how the video stuff
worked
hence beam racing so I think that's
really cool I heard over you but this is
a prominent example in space invaders
you can notice that in each of the rows
all of the sprites are the same and
that's that's not a coincidence
if a programmers would shift the sprite
location in concert with the graphics
renderer to copy it horizontally across
the screen due to the limitations of the
hardware this sort of hack was necessary
to create games beyond a certain level
of complexity and it required like a
little bit of ingenuity to sort of
figure this out and these limitations
and methods really jumped out at me - I
like this stuff I like when people have
to sort of come up with ingenious ways
to work around things and that
particularly I thought was really cool
and I was like maybe I should learn a
little bit more about how computers work
so the other good thing about these
computers is that they're actually like
quite a bit simpler than anything that
we use today like right now there's
there's no one person who can who can
dive into a chip that they have and say
you know this is something we understand
they're essentially you know you have
teams of hundreds of computer-aided city
planners that try and lay out these
chips the 6502 which is the chip that
inhabited the Atari 2600 was laid out by
a single person on paper and checked
with a ruler before they like did
anything with it right so they did that
and then they took it and they put it
onto some acetate and then they use that
acetate to etch the chip so they're like
literally would be people crawling
around on a table like trying not to
markup this this giant transparency so
that they could put transistors in the
right place it's I have no words for but
like I was inspired fresshe and the
teams of creators were really small -
usually games were made by one or two
people in a couple months in for example
ET I think was made in three months and
then promptly abandoned because it
arguably almost ruined the video game
industry so I didn't want to go too hard
on on wizard slides but only because I
figured that Ramsey would have it
covered but now some TSA officials gonna
be really confused because business
wizard isn't met in my search history hi
whatever whenever I account encounter
anything new in computing I usually
think it's kind of magic like graphics
are still magic to me for a long time I
thought that that security was complete
wizardry and there's just a lot of stuff
that seems opaque and daunting and
you're like how do people actually do
this you have no idea and then slowly I
sort of pull it the thread and and start
reading about something and it starts
coming together and that is absolutely
how I felt about emulation I probably
done I don't know 20 hours of assembly
programming in my entire life up to this
point most of it was in school and most
of it was on machines that were built
for pedagogical reasons and not for
actual use so I but having my my
whopping 20 hours of experience I was
like I know how register based machines
work well enough to do this probably so
at around the same time I was also
reading and watching at David Nolan's
work around home and it immediately
captured me specifically these two ideas
one was making interactive systems
declarative taking things that are sort
of stateful and side-effect E and trying
to model them in a mutable way and then
to sort of split the operations you do
into two separate kind of streams one
being querying which is declared if
you're just looking for paths 90% of the
time and then the other is transactions
where you're actually making changes so
it led me to start thinking what other
systems we might be able to build this
way I'm not a front-end dev byte
so when I like see some of this stuff
and how and how nicely that code is now
is now written and represented it kind
of blows me away and so you know I
wanted to see if I could do this in
maybe a different context and then the
other thing that that really that I
thought was really cool was in the to do
MVC demo there was like a slide or
something in a blog post or something it
was like time travel in six lines of
code like you just add a watch to an
atom and call it a day which is just
really cool like i i'm like i've been
writing closure for a couple years now
so maybe i'm a little bit more jaded
about it it's like time travel yeah
whatever so what but also it's pretty
cool so the other thing that i was kind
of following was that to elizabeth
assisted speedrun speedrunning
community' which is a group of people
who use emulators to complete games in
as little time as possible because they
can step through frame by frame it's
possible to take advantage of all sorts
of ridiculous timing issues and bugs
like the one shown above I probably
could have given an hour long talk with
just like gifts of weird stuff that
happens in games but but I found at
least one good one and they're they're
they're interesting they're cheeky and
subversive in their way they're a
celebration of loopholes there's
something that brings freeform play two
games that can otherwise be prescriptive
and rigid they're also painfully
handcrafted by manipulating a game frame
by frame discovering and exploiting
trips it tricks its its gameplay by
research and debugger it's a really
unusual way to play games it's like I'm
trying to think it's no it's weird it's
just like it's over engineered in the
most pleasing way possible so anyways I
figured all right well let's just take
these ideas and kind of squish them
together and maybe we can see what we
can do and build a time-traveling
emulator excellent so now I'm very
excited this is the first time I get to
I get to do a definition slide
so I'm just gonna soak it in
but emulate is is from emulous meaning
to rival or to match or surpass usually
through imitation it's about building a
system that imitates another with the
key point being imitation the more you
get into emulation you realize that for
the most part direct accuracy is not
necessarily the goal in the same way
that like again graphics is magic to me
so I can't speak to it but in the same
way that graphics isn't about one-to-one
simulation of physics emulation is is
not about one-to-one simulation of the
machine you're trying to imitate so
rather than creating a perfect image of
our desired system sometimes we're
creating a roughly render tack simile so
I don't really have much of a connection
to the Atari 2600 so I wanted to try
something from roughly that area but
something that I had a closer connection
to so I decided to to imitate the NES so
some very very brief history about the
NES it's it was released in in Japan in
July of 1983 as the Famicom or the
family computer
it was then released in the u.s. in 1985
as the Nintendo Entertainment System
anecdotally it it might have actually
saved the video game market which which
crashed in 1983 after et was buried in
the desert which is a very good story
I'll tell it later if you want to know
it also it had the RICO two ao3 which is
a very similar processor to the 6502
which I'll talk about in a moment and
yeah let's get started so first I was
trying to figure out how to learn how to
imitate this is a project that is not
like a lot of the things that I built
normally when you're designing a system
you try and find all of these decisions
that that sort of lay together or you or
you write us back and then you do
something but in this case that's not
that's not what we're doing right we're
the spec already exists and the spec is
a physical artifact the problem is is
that I can't just
get requirements out of it right like I
don't even have an NES so I essentially
have to build everything by hearsay more
or less it's like trying to imitate a
drawing but you only have other people's
description so I guess it's like being
like hey I forgive that's called a
criminal drawer the first thing that I
had to do was was try and come up with a
model for the thing that I was trying to
to imitate and that meant a ton of
reading luckily there are a few decades
of documents that help me put together a
picture of what I was looking at and
those sources are from all over the
place very little information came from
the directly from the manufacturer
surprisingly so most of it is
documentation of similar systems or the
result of people's reverse engineering
efforts so a lot of the most useful
information comes from text files from
the 90s and the aughts
that I have like probably four or five
PDFs of 6502 programming manuals on my
computer now which are really really fun
to look at also because all of the
diagrams for how things behave or they
were typewritten so there's like
typewriter ASCII art in them which is
really great so that was the first thing
I decided to have a model would be the
CPU so the CPU is the Ricoh to a of
three which I mentioned before it's a
got a subset of the functionality of the
6502 which is fortunate because as I
mentioned the 6502 is incredibly well
documented so it has three registers a x
and y a is the only register that can do
all of the math X and wire are mostly
placeholder registers not placeholders
but you know they do stuff they just
don't do all the math stuff and those
are all note that that most of these
registers are just a byte
right because this is an 8-bit system we
have one byte of status flags which
we'll get into in a second we have some
interrupt handling logic we have a
program counter it tells us where we are
we have a stack that allows for
subroutines and returns and a stack
pointer which tells us where we are on
the stack and then we have an
instruction set of 56 off codes and 11
addressing modes there are also some on
docking
opcodes most of them crash the system
some of them don't to support every game
you have to also support every
programmer who decided that an
undocumented opcodes is a really good
idea thanks guys so I so this is our
first picture and it's mostly of the CPU
and a few registers and some memory and
a program counter and right now that is
basically what it looks like right so we
have our registers we have the PC which
is going to be a byte we have the stack
pointer which is also a byte and then we
have the flags these these very very
well named flags C through n being carry
0 interrupts disabled binary coded
decimal which we actually don't use this
is actually the thing that was stripped
out of the the two ao3 the 6502 has
binary coded decimal we don't have it
but we have to support the flag so it's
there overflow a negative and end memory
which currently is an array of bytes but
we're gonna get into something a little
bit more advanced afterwards so
basically what we're trying to do is we
want to we want to find a byte at the
program counter we want to look it up we
want to resolve some some address stuff
as well because the addressing modes all
behave differently and then we want to
apply changes to the state and so this
is sort of this isn't a function but
this is how the data flows and so when I
mentioned Ramsey's talked before this is
kind of a backwards version of that
where I'm taking at the bottom I have I
have this assembly code machine code and
I'm turning it into these these closure
Maps or an array of closure maps that we
can work with so in this case this is
and 0 specifically and is so and
immediate 0 so what this does is I take
the argument 0 and I end it with the
accumulator which will 0 my accumulator
so I read it and I have just a very very
big lookup table that shows what all
these op codes mapped
I'll be happy to show it afterwards
during questions or later on if you it's
all someone get help I guess but and
then we have one argument we and we get
a certain number of arguments so we look
up the opcode and we see the function
there we see the address mode is set to
immediate we have the number of bytes
read and the number of cycles that this
is going to take we don't care about the
cycles yet but we will after we do some
augmenting with the address mode we have
another function that goes away and and
reaches into memory and resolves our
arguments from from memory so that we
can make our changes to state so the way
that looks is basically we have a map
lookup we have a multi method and then
we have a second multi method for
actually exactly executing the operation
and that looks like this so we take the
state which is our just big map of state
I showed you the the sort of simplified
version of that model and then we take
the operation and we apply all of these
things to the state so that cond arrow I
promise actually should be there I just
deleted something that we don't care
about right now so that the slide would
fit but all of these these gets and sets
I wrote just a ton of these tiny
functions than it was basically because
I changed my memory representation or my
internal representation three or four
times and I didn't want to do that
anymore so I wrote a I accidentally
wrote a language I guess yes so that's
that's basically what it looks like when
we when we execute that so this is a fun
thing where we have to do arithmetic and
I thought okay well cool we have the
closure core library so we can just use
all of the bitwise operators there and
that'll be fine right but no because if
we are using an 8-bit number some things
won't work because 8-bit assumes
overflow at certain points so that means
that we have to write some of the some
of those arithmetic functions
sells that is but not actually as hard
as I thought inspect was a really big
win here because I can write things like
this so this is arithmetic shift right
or arithmetic shift left and carry is
not a good name for for that thing in
this situation but but I like while
messing around in the repple with the
spec I sort of converged on this thing
and though the little function invariant
here basically says like if you shift
something to the left the result will
either be bigger or you'll get a carry
and you can actually be even more
specific with that spec and say that it
will either be double and you'll get a
carry which I haven't done yet but I
noticed while I was working on my slides
a couple days ago so I'll probably do it
but so I have a bunch of those and I
have tests that run on a lot of the
arithmetic and anytime I made the
assumptions about arithmetic correctly
it's been fine I haven't had to do
anything but I did have a week where
two's complement which I was using in
subtraction and a bunch of other stuff
was was was wrong and I didn't know why
and it took a while so so we also have
cartridges and so in our previous
picture we had this big block of memory
and that memory was just an array of
bytes and we would literally literally
would address it by just going int and
that's fine but that's not really how
this works so we have a cartridge and
the cartridge is interesting because in
a lot of in most computers you you think
of a disk being just a sequential thing
and they're standard but the fun and
weird thing about character juice is
that they have their own hardware in
them so if you want to do extra stuff
where the cartridge you can so for
example I've implemented one of the
cartridge formats and that's an ROM zero
and it is it is not fancy at all so the
interface for a cartridge is you
basically you have a lower bank you have
an upper bank and then you have a little
bit of RAM and those banks are are just
ROM banks so they're they're read-only
and if you want something fancier like
for example a each of those are is 16 K
so
you want in 132 K of space then what you
would do is you would you would have
Bank switching so if you if you poked a
certain byte in memory then that would
that would switch that bank over so that
you could actually have more space and
also you could do weird animation stuff
with it because you could have tiles
that are very similar layered on top of
each other and then if you switch the
bank the tiles would animate which is
pretty neat and there's a bunch of other
stuff cartridges can do to for example
battery backups can first saves there
was I think the NES Zelda had saved
games on it and if your battery died you
just lost your save I was very sad so
yeah so I implemented the least fancy
mapper but the principles that I use to
implement it should should extend to
everything so it looks like this so I
have two protocols for parts of the
system that read and write memory and
for each mapper I just create a record
that maps that memory to the desired for
the desired cartridge type and if I want
to do fancy stuff like bank switching
and whatnot I can do all of that in the
background so I can just say when you
write here also like low key switch the
bank so yeah and again I can show the
specific code but almost all of it is
when we do a lookup we just have a very
large column that says if the address is
between here and here look here etc
again I'm happy to show anybody
afterwards if they're interested so with
this in hand I was able to make my first
debugger when I said that I am NOT a
front-end developer by trade I was not
joking but it's pretty cool right like
these are all these are all just reagent
cursors that point to various parts of
state in memory and on the on the right
side there I just just console.log the
the instructions so this here is the
beginning in the initialization code for
a particular ROM and so the way that I
do bugs when I started was I would run
this stuff and get the log messages out
and then
some wonderful soul had had disassembled
and annotated one of the roms that I was
testing against so I'd just like emitted
some some instructions and then I
checked both of them to make sure that
everything was like reading and jumping
properly which works super well for a
while except for the fact that your
emulator doesn't have to run like ten
instructions correctly it has to run all
of them so so I had to proceed to other
testing methods and so at this point I
decided one of the things that's sort of
interesting about the CPU is that it
really only does half the heavy lifting
and I wanted to make sure that I could
solve the problems of synchronization
because they're important so I wanted to
so I started to write the picture
processing unit which I have drawn here
and it is a lot less clear how this
works than the than the CPU the CPU
because it is designed to be used by
programmers has interfaces that are
documented everything about the PPU is
reverse engineered so I have probably
five or six documents that explain how
it worked and ice and I spent like
probably three weeks squinting at them
and wondering what I got myself into but
it's so the chip was called the reco 2
Co 3 it has a series of registers that
are all memory mapped almost any i/o or
interaction in the NES is memory mapped
so there's not a lot of direct memory
sharing which is actually pretty nice
for our purposes and so it has memory it
has a couple it has two big registers
the cycle register and the scanline
register and it's something that you can
I kind of had to implement by steps
because there's a lot of stuff that goes
on in there but the PPU is more or less
a fancy clock so it it keeps track of
two main things it has a cycle register
and a scanline register and
so cycle is is is basically your
x-coordinate and it takes up every every
time the PPU runs for a cycle and goes
from left to right and then when it gets
to the furthest right it stops and
resets again so it's it's like the
second hand of this clock but it also
goes left to right and then then we have
the scan line is vertical so this is
like driving a TV directly so we're
thinking about this as being something
that is that is you know sort of
shooting beams and then advancing one
and then doing that again and so it the
cycle runs from 0 to 340 and the scan
line we can think of this in the minute
hand and the minute hand goes from 0 to
261 and not all of those coordinates
actually are things that map to the
screen some of them happen off screen
and the reason you do that is for
synchronization because again it takes
time for the beam to either reset from
left to right to left again or from from
bottom to top so we have to account for
that by adding cycles in in there as
well so there's also a bunch of other
stuff that's happening in here and the
PPU is I mean I don't really fully
understand it yet and there's there's a
lot of stuff there but the important
thing that we need to know is that once
every hour basically which in this case
is 60 times the second time I might have
not a big great metaphor but once cycle
bought hits the bottom of the screen it
fires an interrupt to the CPU which is
called a V blank or a vertical blank and
what that interrupt means is that that
it essentially is like I have rendered a
frame go do some stuff and almost all of
the stuff that the CPU does like
anything that's time-sensitive if you're
reading i/o for example IO is all memory
mapped so to read from controllers you
just pull them 60 times a second every
time this interrupt fires we anytime you
have timers for anything like whether a
platform is moving back and forth or
something like that that is all tracked
in this in
corrupt if you're using animation also
happens here audio happens here anything
that's like real timey is probably
driven by a V blank interrupts because
this is this is our clock right in a
strange and backwards way we're using
the TV as the clock for the rest of our
system so there are three things that
are hard about synchronizing these two
things one is that the PPU operates
roughly three times as many times as the
CPU does in this case the solution was
not actually that bad I literally have
like a tiny vector in my state map that
says that says PP upp upp u CPU and I
just rotate it every time it's not fast
Photoworks
and then the second thing that's harder
is opcode timing because in addition to
the fact that we have this ratio between
the two not every CPU operation takes
the same amount of time right so we have
to also simulate that and this is this
is one of the things where I was talking
about how when you when you emulate
something you're not it's not one-to-one
is because if you are really good at
this and interested in a very accurate
emulator then what you are gonna do is
you're going to look at what state
changes in every single cycle for each
opcode and write those details and
that's a lot of work it like some people
would take like years to do it it's a
it's a pretty difficult thing to do and
there are only a few cycle accurate
emulators I mean part of it is even just
finding the spec and knowing that on
cycle 2 of an end that these two
registers change and then later on
something else changes so you can still
do you can have the opposite model which
is what I'm doing right now where you
can either commit all of your state
changes at the very beginning and then
just don't compute for the remaining
cycles which is what I do or you could
also say when this timer is finished
counting down execute the instruction in
theory they should both work the same
way but it's not clear so and the third
thing is interrupts and interrupts are
the first time I was I was tempted to
reach for something stateful when I was
modeling this thing I was like oh cool
interrupts they're like they're like
channels I'll use the channel and then I
was like wait a second how do i
serialize a channel I'd have to just
write something you know take the bite
buffer and write that down I'm like no
II I don't want to do that at all so so
what I did instead is just like
literally just add another key to the
state map that says is an interrupts
firing right now and I just check it
every cycle it's so with these two
things solved it's like great we're
we're done right not really
imitating things is is very difficult so
this is a drawing of what my mental
model of how this would go when I
started working on it which is that I
would spend 50% of the time working on
something that couldn't really run
emulated software and then the other 50%
of the time would be sunshine and
rainbows and really cool graphical
glitches that I could post screenshots
of unfortunately that's not the case
it's it's a it's an incredibly complex
system if one a one or two of your
instructions don't work properly then
just things don't turn on so it looks a
little bit more like this so where where
I am I'm still I'm still somewhere
outside of that outside of that slice
I'm working quite a bit harder than than
I thought I would that I thought I would
need to for accuracy but luckily because
I'm not the first person to ever ride an
NES emulator a lot of people have had to
solve this problem and the way that
people solve this is they write test
runs so they essentially write software
for the machine that that they then will
run on either a known good emulator or
or on the system itself and they'll see
what the result is and they'll use that
as the spec for the system so so I
started writing I started implementing
the one of the first tests which is it's
called Ness test
and it is a it runs about 8,000
instructions and it logs every single
line of the instruction and and that log
contains some of the states so to pass
the test you essentially have to make
sure that your logs are synched up and
that the timing is correct and the
memory is good and so this is what one
of those log entries look like looks
like so I have an address I have the
bytes that I'm supposed to read I have
the OP I have the the memory read and
then I have some some register state and
then additionally there is there are
some cycle counts that are on the end of
this log I currently truncate those
because I am working to get my my CPU
correct and then I'm gonna work on the
synchronization next so that's where I'm
gonna that's where I'm gonna go with it
after this but it's really interesting
because this is not a kind of testing
I've really ever done with something
before it feels like every time I pass a
series of tests and get that one I get
another sort of layer closer to what the
actual hardware is and in so doing I've
now made my system precise enough to run
another test so for example I can now
run these these test roms and do that
comparison so that means that that most
everything is working properly but
there's there are a ton of very very
small details that you have to sort of
suss out for example one of the last
ones I fixed is what happens if you were
reading something that works on so
there's a thing there's a concept in the
memory called called the zero page which
is it's the first piece of memory
between 0 and FF and if I read an
address at FF and addresses two bytes so
do I read out of the zero page or do I
wrap around and the answer is that I
wrap around but there's no way I would
have known to look for that until I saw
a test that said hey I bet you're not
testing for this so I have this skeleton
of a CPU I'm
I'm currently fine-tuning or of a PP
user I'm currently fine-tuning the CPU
for accuracy and fixing bugs the
previously mentioned test Ness test I'm
about three thousand out of 8,000 log
entries correct to give a little bit of
context for that there are a lot of
emulators that never pass that test
which is another one of those things
that makes is really interesting right
is that the the the sort of we judge an
emulator by how well it runs software we
don't necessarily care about the details
so there are emulators that have been in
the wild for like 20 years that still
aren't technically correct which shows
us probably some things about
correctness in software so here's some
stuff I learned I learned a lot about
low-level computing I definitely I
thought I understood register machines
it turned out I didn't now I understand
a little bit more but it's it's really
really interesting stuff I've had a lot
of fun with it one the one big atom
model is is great and it works and every
time I tried to separate something out
because I thought maybe these two things
shouldn't be able to write to the same
map because they they don't technically
share memory in in the actual system
every time I had that thought I would I
would be burned by by the fact that this
model was no longer simple and so
keeping everything in one place actually
works really well and the time-travel
stuff works works pretty well so far
I've debugged a lot of problems with
like that debugger that I showed you
before fix a lot of stuff with that it
doesn't look very nice but you can go
back to when things were wrong it's the
this sort of the same thing is like the
closure script development feeling right
you can just go back work through a
problem stop and do it again and just
sort of like be in flow I guess the
entire time so it's working pretty well
and and software archaeology in general
is is super fun I I really like this
stuff I
under historically if we are going to be
very good at documenting a lot of the
things about the systems that we've
built and I know that there are
librarians and architects specifically
or not architects but like librarians
and and archaeologists who are
interested in this particular thing like
if I put code from something in a museum
does that actually technically count as
archival if I have a printout of
something or does it have to be the
dynamic artifact like how do we actually
capture that history and not only that
but you just have to you have to figure
everything out by by reverse engineering
or testing or sort of poking through
stuff emulation is not magic I'm happy
to report thought it was magic it's not
magic it's really interesting it takes
like a lot of a lot of thought and and
work but it's it's great and I would
encourage anybody who's even thinking
about about doing a little bit of
emulator stuff to to dive in and I'd be
happy to talk about it after after the
fact as well
so I think that's what I've got I'm
Angus I guess on Twitter I have all of
the code up on github it's under very
heavy development right now but I but
I'm certainly happy to accept patches
I'm I have some ideas for future work
I've been talking I'm thinking about
about making it sale JC because really
the only thing that won't port directly
over is probably the arithmetic and
that's just because of data type stuff
and I've prepared a bibliography as well
and that's on git io / time travel which
has links to almost everything that I
use to make this and also some books
that I read and liked that got me to do
this project in the first place so
thanks so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>