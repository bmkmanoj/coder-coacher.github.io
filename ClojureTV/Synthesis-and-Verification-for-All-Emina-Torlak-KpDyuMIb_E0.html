<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Synthesis and Verification for All - Emina Torlak | Coder Coacher - Coaching Coders</title><meta content="Synthesis and Verification for All - Emina Torlak - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Synthesis and Verification for All - Emina Torlak</b></h2><h5 class="post__date">2017-03-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KpDyuMIb_E0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well thank you Alex for the introduction
and thank you all for being here I know
it's Friday afternoon so I will try to
finish before 5:30 first hello my name
is Amina and I'm an assistant professor
at the University of Washington in the
computer science department I am here
today because like everybody in this
room
I love functional programming and of
course parentheses so what I'm going to
talk about today is a new programming
language that has plenty of both it is
based on racket which as Alex said is
another whisky language and in
particular word racket is very good at
is essentially being a programmable
programming language it allows you to
very easily create new programming
languages in particular you the main
specific languages so basically you can
use racket to package your insights and
knowledge about a particular the native
applications and allow other people to
efficiently store problems for database
now once you've created your language in
racket your DSL you might also want to
create some tools that allow people to
use your language more efficiently for
example and also make a test generation
tool and automated debugger and so on so
the language that I'd be developing for
the last four or five years on top of
rackets allows you to build a city class
of tools that are based on program
verification and synthesis so the
language itself is called or set and if
you're not familiar with the
certification and synthesis tool don't
worry everything is going to be clear by
the end of this talk but at a very high
level you can think of verification as
solving a problem of checking that a
program satisfy the specification
all inputs drawn from some either very
large so exponentially large or even
infinite set right so you can think of
it as exhaustive testing is very program
synthesis solds kind of the
complementary problem which is somebody
gives you a high level spec and you can
use program synthesis to actually
generate code that implements that speck
in your DSL
these tools are based on state of the
art automated theorem provers would also
go by the name of facile versus ability
solvers or SMP soldiers so
satisfiability modules Theory silver and
for that reason in addition to being a
programmable programming language by
virtue of being embedded in racket
rosette is also a solver Eva's
programming language now as I said all
of these words are going to become
second nature to you by the end of the
spoke but before I got into telling you
what is it is and how you can use it to
do cool things let me briefly move today
this work why it is that you know outs
in the last five years of my life
working with this what's exciting about
it and what it is what are the kind of
cool things that you can do in the real
world if you had access to this
technology that's very very location
instead of the schools they're based on
automated or push-button theorem proving
all right so normally when you think of
programming you think of it as a task
that is performed by professional
software developers right essentially
the people and people in this room it
turns out that in the real world pretty
much any kind of a knowledge worker
needs or wants to do some kind of
programming they have a bunch of tasks
that they want to automate so let me
give you a few concrete examples of
people or the kinds of people of whom
you may not think of as programmers but
who actually do need to do the
programming tasks
and how we can help them with this
verification synthesis technology so our
first little guy here is in social
sciences so today in social science
involves essentially collecting and
analyzing - huge amounts of data now
before you can do anything useful with
your data you have to massage it into
some kind of a standardized format if
you know how to program that's easy
if you don't know how to program you put
it into an Excel spreadsheet if you
transform each one of them by hand all
right this is very painful essentially
what these people would like to do is
demonstrate on a few examples how to
perform the data transformation and have
the computers to decide the program that
will perform the rest of the
transformation now I'm not that kind of
person whom you may not think of the
programmer are biologists so what they
would like to do is create executable
model of biological processes and the
reason why they would like to having a
model is because they can essentially
cut the amount of time and expense that
it takes to conduct experiments in the
wet lab a particular kind of biological
model that they would like to have are
essentially models or diseases or models
of processes that lead to diseases the
way they would like to create these
programs is not by writing Python or
even closure code or racket code what I
would like to do is give some system
input-output example here is a new
patient that I performed on my model
organism usually some kind of a worm and
here is the outcome the organism dime is
a small font and so on
given these input output example
synthesize an executive model of a
protein Network that is specific to the
data
that explains it moreover if there's
more than one model that explains that
there multiple ones tell me what
experiments what next experiment I need
to run in the wet lab to disambiguate
between these two competing hypotheses
this is a huge feeling biology for us
running experiments is easy right to
cheat the right controller we press the
button runs in a few seconds for
biologists running an experiment is
really expensive really hard it takes a
lot of time so anything that we can do
to help them make this process more
targeted is extremely useful so this is
how program synthesis can help
biologists now our final example is
hardware engineers or architects
computer architects so these days what
they spend their time doing is creating
new hardware that's more parallel more
energy efficient now creating new
hardware is great but if you want
anybody to use it you have to make it
programmable you have to provide things
that people expect by cache coherence
protocols and memory consistency model
getting these things right actually
creating the correct package for him
protocol or a memory system model is
extremely difficult for memory
consistency models alone right
getting the x86 model for example
formalised took four years and pan
papers as programming languages of
formal model method conferences this is
how it's hard it is for experts to do
this by hand so what all these examples
have in common is that people have in
fact built verification and synthesis
tools to help knowledge workers in the
EU's domain however the gap between the
knowledge workers in the tools they need
is huge because it takes so much
expertise if so much time to build just
one of these goals in fact if you build
it and it scales and you're successful
you'll get a PhD
and the very least you will get a paper
at a self academic conference that is
how much time next receives it requires
to build just one of these tools clearly
if you want to make this card technology
accessible and available to wider range
of people
what OHS to bigger engine domains we
have to make the process of building
these tools easier and this is basically
what my research is about I work on a
new class of languages so celebrated
languages Rosetta is one of them did
make it possible to build these advanced
automated tools the reasoning tool
without having to get a PhD and without
having to become an expert in automated
theorem proving in fact all you need to
be able to do is program the young mr.
user over that that I know of is a high
school student and he used to build for
example a state-of-the-art verifier that
can tell you whether a type system that
you developed is down which is pretty
cool so for the rest of this talk what
I'm going to do is first I will talk
about what's overrated schools are so
I've given you two examples synthesis of
verification and I will define these
things a little bit more formally and I
will show you what it takes
where I will discuss what it takes to
actually build one of these things by
sham then we'll talk about how things
get better or easier when you have a so
overrated language in particular I will
show you how to use it to build advanced
automation so verification synthesis and
so on for a very simple toy language of
course this is a talk that's going to
last for 40 to 50 minutes so it's going
to be a very soil language however the
same process the process that I'm going
to demonstrate on this toy yourself is
what you can use
implement synthesizers are verified for
real programming languages and solve
real problems in the real world and this
is what the last part of the talk is
going to be about I will briefly tell
you about some of the more recent
applications over that to a wide variety
of problems from verification of safety
critical systems to super optimization
for low-level machine code arm code and
so on all right so let's start with
overrated tools what are they and how
can they help you create better code so
more correct software now normally when
you think about writing code normally
when you think about the acts of
programming the picture looks something
like this you have a programmer he has a
specification his mind some high-level
intent that he was to translate into
code so he will write a piece of code
that hopefully implements a
specification
so what's the first thing that you do
after you write a piece of code
exactly you have to test it right if you
have no other means of health whether
your program implemented specification
of course you're going to test it so
what is deafening well you basically
write a property about your program a
property of your code that needs to hold
so here I'm just getting a really boring
name safe the safe predicate returns
true is B produces a correct output on a
given input and what we have here in the
best case is basically test the C
behaves correctly on one particular
concrete input out of men now when you
bring and automated here improver into
the loop something interesting happens
you can ask questions about the behavior
programs on all possible inputs so
here's here's what that might look like
for example we can ask our solar the
search for an input if one exists on
which the program fails to satisfy spec
so basically this assertion fails so
wait if we do that and this is important
this is basically what's hard is by
essentially expressing the semantics of
this program as a formula in some logic
usually first-order logic now if you
remember I can take in a logic class or
discrete math class or something like
that you might you might remember what
these people stand for but essentially
what's happening here is that this box
in the middle act as a compiler so
instead of compiling your language to
x86 or machine coders or another
programming language you're essentially
compiling it into logical constraints so
once you do that once you have the
encoding of the program semantics as a
logical constraint what this thing in
the book says is there exists a net so
that makes this simple
such that it is not the case
a space if this formula has a solution
and the solution here means there is a
concrete value for the variable X which
you can substitute in there so this
formula has a solution that solution is
a concrete test case a concrete input on
which your programs fail so this is how
all modern program education tools more
or less work they take a programming
language the expressive semantics as a
formula and then they ask one of these
automated theorem provers to answer a
query of this form about this program if
the silver find the solution we will
lift it into values that are meaning for
the level of programming language so for
us is going to be a concrete integer
let's say 40 to 50 say open 42 okay so
you've written penal code you've asked
your verifier with it's correct to
respect your spec enough is enough it
gives you a concrete input such that if
you run beyond this next put on 42 is
going to fail this assertion what is the
next thing that you do or the first
thing that you do once you have a
failing test case would you have to do
debug it you have to localize your fault
first it turns out that a solver can
help you do that as well and we do that
by using the same trick we are going to
express the semantics of this program
again as a formula to logic and we are
going to ask discover what a dis formula
has a solution
so the verifier just told us that p is
not safe so the negation of safety is
true on X is equal to 42 so what do you
know about this formula I'm showing is
applied does it have any solutions is it
truth No so you would think that you
know I'm sitting this over a formatter
has no solution we call that
about formula that it can't say anything
useful about it
it actually can what it can do is it can
isolate a smaller subset of this formula
which myself has no solution right so
normally these translations are huge
when you take a piece of code and you
translate it into assembly it's going to
be a lot of assembly same thing and take
a piece of code and you translate it
into logic you have gets hundreds of
thousands or millions of constraints the
solder can actually identify just a few
of them which are responsible for
distinct having no solution and when you
map those constrains back to the level
of the programming program from which
they were produced what you will get is
a minimal set of expressions in the
program such that you have to change at
least one of them to make the program
correct so this way forests can also
help with full fertilization
alright so we localize the fold now we
have two choices if we are super lazy
and for whatever reason it's okay for us
to call an np-complete procedure at
runtime don't do this but let's say it
is we could actually choose to repair
this program at runtime by using this
over as a runtime Oracle so I'm going to
replace my buggy expression with a call
so this magic function choose and the
semantics of this function is at runtime
when it's cold it will return a value
such that all the assertions downstream
are going to pass you can think of it as
programming with a clairvoyance Oracle
there are actually cool applications of
this you can actually build a cool
logics puzzle of solving engines with
this and in that case it's actually okay
to use the solver at runtime
because they can't scale well enough for
this thing to be fast obviously using it
on real code is going to be much much
slower so what we really want to do
instead is repair this ferment matically
to do so we're going to replace our body
of expression with the double question
mark and I'm going to use this to denote
hole in the program this whole self to
the underlying system find me an
expression in this programming language
that I can plug in if one exists of
course and put it into the visible
question mark such that the program is
correct on all possibly and again we're
using the same trick we're translating
the semantics of the program to a
formula and then we're saying there
exists an expression e in our language
such that when we specialized the
program P with e so we plug this plug in
each with a double question marks there
for all X if you have excesses so this
is how all of these rules worked in
principle the thing that's really hard
you will notice that every time I
explain how one of these tools work I
basically have to tell you that you need
in order to get this to work you need a
compiler from programming language down
focus train system and this is extremely
hard to build I mean building any kind
of a compiler is hard there is no reason
why building this kind of a compiler
would be especially easy and in fact
it's not this is what takes an enormous
amount of time and almost a lot of
expertise so whatever that saves you
from doing is essentially it saves you
from building this compiler instead of
having to compile the semantics of your
language to constrain all you need to do
is you implement an interpreter for your
language everybody knows how to do that
or if it is an embedded yourself he
implemented as an API or a library the
catch is you have to implement it in a
whole
language such as rosette which is Excel
solver Edith and then you will get a
translation to constraints for free
so essentially what her that is doing
it's taking an interpreter for your
language a program running on top of
that interpreter and translating both of
those things suspiciously syllable SMT
constraint it does it's magic with the
help of something called the symbolic
virtual machine this is the thing that
is capable of translating essentially
the semantics of your language is given
by the interpreter and the program in
your language to constrain and this
holds a hard technical problem I mean I
only told you that just building a
compiler for one programming language is
really hard right what I'm now telling
you is that I have a compiler for
programming languages so that was the
hard technical program full barrier that
I will not go into details about exactly
how this works how the symbolic virtual
machine works you can find it in our
papers and of course I'll be happy to
talk to you offline so what I'm going to
do instead is I'm actually going to tell
you how to use with that to build these
tools without having to build a compiler
before we do that let me briefly talk
about what I mean by the main specific
language what I've invited yourself in
the rest of this talk why we're focusing
on DSL they sell why are they
interesting and then we'll see how to
build one so normally we build yourself
by layering them on top of general
purpose languages when I say the
accelerator made specific language I
mean a language that is specialized for
solving problems in a given domain
usually not always usually they're also
limited in capacity in a way most of
them are made
of them are not very complete for
example you create one of these things
in one of two ways you can do what we
call a deep embedding of a dsl into a
host language and that officially means
that you're going to write an
interpreter for your DSL in a
general-purpose post language the other
approach to building the DSL and this is
a very popular one in fact almost all
the talks that I've seen today they were
in the building yourself but they called
this this or not or they were using
yourself so the second approach is to
essentially build an API or library if
you really think about it a
well-designed API gives you a language
it gives you the right extractions the
right operations of those abstractions
the right concepts to solve a class of
problem so building an API the act of
building an API is the act of
essentially building and embedded
yourself so to give you some concrete
examples of all of these things
general-purpose languages that are very
good for building yourself a Scala
racket closure JavaScript and of course
everybody in this room has used or at
least heard of or at least one of the
DSL that are here on the slide right
just about any domain that you can think
of there's the DSL for it why why do you
think people would bother with yourself
and it's clearly anything you can do it
in individual you can do a
general-purpose languages because the
general-purpose language is to treat a
more expressive usually so why bother
with yourself
well the DSL is the ultimate abstraction
for solving a problem so let me give you
a Colgate example a code example so what
you see here is municipal to the K
Express in the linear algebra to
yourself right like MATLAB or eigen and
matrix multiplication Express and C or
job so the difference is obvious when
you're working in a DSL in a language it
provides the right abstractions for
solving problems in a given domain
you're going to write far less code this
is great it means that you are more
productive and you're also less likely
to introduce bugs
thank you are close to your bugs the
other thing that's really important here
is that these cells are very good for
tools to operate on if you're building a
compiler for a DSL for example
optimizing compilers it can take
advantage of the properties of the
domain that are not obvious or would be
very hard for a general-purpose compiler
to enforce for example a mascot compiler
can take advantage of the fact that
maybe certification is associated
there's just no way that the C compiler
can figure that out from these three
networks so these smells are good for
people because they narrow the gap
between between what you want to say and
how you say it
they're also good for tools because they
allow the tools to take advantage of the
domain properties in this case matrix
multiplication and this both for all
tools not just from file as it goes for
verifiers synthesizers and so on so a
solver aided language that looks just
like a normal language back except that
it's running on top of this non-standard
virtual machine that's basically the
main difference one so overrated host
language that exists actually the first
one that was the earth is resist a few
other ones have been undeveloped since
then but we all focus under that here
because that's what I know best and some
of the so overrated DSL that has been
developed in reserve
as you can see they cover a huge range
of domain so this is just a few recent
examples there is a vesl for spatial
programming for intelligent tutoring for
memory mobiles and so on
I will talk about some of these in more
detail towards the end of the end of the
talk before we do that though let's talk
about our let itself let's see what it
is that it adds to racket and if you
wanted to build a solver in a first
language for your favorite language
closure what would you need to add to it
well it turns out that all your needs is
six construct six and in these I will
explain what they mean I will walk you
to their semantics as we go through an
example but I think for some of them you
can already guess what they do
a third does what you think it does
right I take the predicate and check
whether it satisfied the lower three
essentially are making the tools that I
talked about where education services so
on into language constructs first-class
language constructs in this racket
language and the first one is probably
the least familiar and that is the one
that will introduce by example so we're
going to be our example well we're going
to build a tiny tiny silver it is
yourself is going to look a lot like
assembly code I'm going to call BV which
stands for bit vectors and you can
imagine that you use this to develop a
fast low-level library so here is an
example of the program on this program
takes the maximum of two 32-bit integers
without doing any branching and the
operators do what you probably imagined
that they do
so be vge checks whether the first
argument is greater than or equal the
second argument B D neg in the
arithmetic negation XOR and and and hard
bitwise XOR and hand ok so this is what
a program from the VV language may look
like so what do we want to do with
programs in the video language well
obviously we want to be able to run them
and test them we want to be able to
verify them debug them if necessary and
synthesize your cares if needed so this
is what we want to be able to do by the
end of the next ten minutes and here's
how we're going to do it we will
implement an interpreter for DV internet
it's going to be about ten lines of code
and we'll get everything else more or
less suffering so let's see how that
works I will show you how the
interpreter for BD works by
demonstrating its operations on this
particular example so we are applying
daily map to the input minus two and
minus one so the first thing that
happens of course is we're going to
parse this code we're going to parse it
into this extremely simple
representation that I'm doing that I'm
using here so a program is a list of
lists and each of the lists represents
an instruction as follows the first
number in the list is the identifier of
the output register to which the
instruction is going to write it output
value the second identifier so the
symbol is the name of these structures
we're going to execute but this is our
op code and the remaining values in this
list are the identifiers of the import
registers so this is where the
instruction is going to draw its input
values from so it's a super simple
representation is nothing tricky about
this
so here is our tiny little interpreter
is going to take this a SC abstract
syntax
drink is going to take our input and is
going to do the following thing the
first thing it does is it creates enough
registers to run this program and
because our representation is so simple
it's basically the length of the over to
the length of the program representation
and is going to populate the first and
registers with the end input to the
program alright then
is going for each instruction is going
to execute it as follows we are going to
use rackets tag matching to bind the
local variable out of coding in to the
corresponding events because from this
list so the corresponding elements of
the list so the outer variable for the
first instruction is going to be bound
to the value to the opcode is going to
be bound to the symbol to be dge
and in E is going to be bound to the
list 0 1 the next thing that we're going
to do is we're going to use eval to
evaluate the opcode and grab from the
environment the procedure object that
corresponds to this opcode right
it turns out that rosette actually
exposes these bits a corporation's items
are the people who work on solver than
automated theorem provers really love
these low-level things so we expose them
and when you do an email of an opcode
here you will get a procedure that will
behave as you would expect the next
thing that we're going to do is we are
going to load the values of the input
registers into this arguments variable
this is our local variable so now our
contains the actual values to which we
want to apply our procedure so the last
thing is we're going to do is we're
going to apply the procedure to the
argument and store the result in the
output register we're going to do this
for every single instruction and the
result of the program the result of this
evaluation is going to be the value
that's stored in the last register
so this is it the reason why I'm showing
you this code it's not because it's
complicated quite the opposite
right I'm showing you this code to show
you that it's actually something really
simple if I had asked you to build an
interpreter for such a low level
language you might write something like
this will probably take you ten minutes
now this is not interesting or
complicated for the point of view of a
programmer however note that this is
using this interpreter is using all
sorts of advanced programming languages
features right so it's actually using
pattern matching interactive it's using
first-class procedures using eval if
using high order procedures in using
cymatics may not seem like a big deal to
a programmer as I said but this is what
makes people who work on verification
synthesis cry we cry when you see this
these constructs are incredibly
difficult to translate sufficient
constraints some of them we don't even
know how to translate however I'm
letting you use it letting you use all
of these and if you do have some
background in compilers part of the
reason why this works is essentially
partial evaluation most of the time
we're able to partially evaluate away
the constructs that are not translatable
to constraints
alright so here is our interpreter for
the VV language and when we interpret
medium acts on the input - 2 - 1 you get
minus 1 is expected right so all things
to be good but in degrees well we can
see whether this program is indeed
correct on all possible 32-bit inputs by
verifying it so here is what the
interface for verification is going to
look like for the DV language
so the verified form or the verified
construct at the bv level is going to
take two inputs the first one is the
implementation right so the thing is we
want to verify and the second one is a
reference implementation which is going
to act as our specification I'm not
showing what max looks like on the fly
here but you can imagine that it is the
obvious implementation of max which uses
the conditional right so here I'm using
another program is expect in fact the
beauty of doing all of this inner that
is that your notion of aspect is
extremely flexible you can write
constraints you can write assertions
you can use a reference program as your
spec so what we're going to do now is we
will see how to implement this
verification for the beginning language
by using the verify construct that are
set as bracket along with the in these
two other constructs define symbolic and
assert which all of you know what a
third does so let's talk about define
symbolic now so what this thing here
does it basically creates two fresh
symbolic constants of type integers
integers and it binds them to the two
local variables and zero and n1 so what
the symbolic constant well it is a value
of type integer and this is the only
thing that the runtime knows about it it
knows it is the value it's not that it's
an integer but it doesn't know which
integer the solar will eventually decide
which integer these two need to be in
order to try and violate an assertion if
that is possible so as far as you're
concerned you are the programmer the
value of this particular integer is
unknown
at compile-time it's unknown at around
time it actually only becomes known
after stalling but you can use it in the
same way that you use any other value of
the same type you can put it in a data
structure sure you can put concrete in
decision data structures and problems
you can apply or expanded operations to
it you can pass it into your own
procedure that you wrote that is
interpret no problem
you basically just treat it as a normal
integer value finally in order to
implement our verifier we're going to
use this verified construct here in
redacted witchers that provides and the
semantics here is the following
verify expression here expression can be
an arbitrary expression in right-sided
can call other procedures it can contain
many assertions but conceptually what
verified does it executes all possible
paths to this expression obviously it
does not really do that it performs
symbolic reasoning but conceptually it
will execute all paths through this
program collect all the assertions that
are encountered along this path and ask
the solver whether there is a binding of
concrete values to these that can
replace these symbolic values and 0 and
1 such that at least one of the
assertions encountered during the
execution of the expression is violated
so this is the semantics of verify and
this is how you can implement
verification for this be deal anguish
without actually ever interacting with
this folder directly yourself right
you're just using the corresponding
constructs in the host language to
implement verifications for your own
domain-specific language so it turns out
that um
I made the mistake somewhere when I
wrote this Victor evening routine and in
fact there is a concrete input on which
this program will fail so the solver
says that BB max does not behave as max
it doesn't actually take the xxx the
maximum of these two 32-bit integers
zero and minus two we can check that the
verifier is not lying by simply running
our code we have an interpreter for it
right and when we run the remax on zero
and minus two we got the result minus
one which is very clearly incorrect so
what's wrong anyone says I'm just
kidding we're going to ask the Solberg
to help us with this one as you can see
even though it's a very small amount of
code and give it enough time you could
all figure out what's actually wrong it
would probably take you quite a bit of
time it would take me quite a lot of
time to and obviously if anything to the
book so the debug construct is going to
be implemented in the same way as the
verify construct by essentially
leveraging the underlying concepts of
the host language and I'm not going to
walk you through the details of the code
I am just showing you the code to
convince you that it is a small amount
of code but at the DB level the
semantics of debug is I'm going to take
an implementation a specification and a
concrete input on which they differ and
the output is going to be a minimal set
of expressions in my program at least
one of it I have to change in order to
make this program correct
which one and how do I change well we're
going to ask the solver for help there
as well we're going to replace those
buggy registers with a double question
mark and we're going to implement a
synthesis procedure for our BD language
by using the synthesis procedure from
rosette
again with an implementation in this
case a partial implementation with holes
in it and a specification and here is
the correct program this indeed
implements our maximal 232 the integers
without any branches so this is it this
is how you use for them to implement
verification synthesis and so on tools
based on automated theorem provers
without having to become an expert in
automated theorem proving and trust me
takes a lot of time to do that so what
I'm going to do now is I'm going to take
the remaining time to tell you a little
bit about some of the real applications
of rosette which were built in pretty
much the same way as I just demonstrated
for the store language except of course
on a much larger scale so here is a
partial list of things that people have
built just in the last year
Rosetta's is publicly available since
2014 and people have done lots of cool
things with it I will focus on three
applications that kind of show the range
of the main which you can apply the sort
of technology so the first application
that I'm going to talk about is building
a verifier for a safety critical system
as I said I work at University of
Washington and at the University of
Washington Medical Center they have this
amazing machine which is called TNT f
stands for clinical Neutron therapy
system this is a machine that treats
inoperable and radiation resistant
cancers with neutron radiation normally
radiation machines do so by protons and
electrons but some tumors actually
resistant to proton electron irradiation
this guy uses nuclear radiation while
it's significant
well it turns out that building a
machine that you
new tradition in this wave extremely
expensive there's six of these in the
world we have one of them because they
are so expensive they have to last for a
really long time
this machine has been treating patients
for over 30 years the first doctor
controller for this machine they
basically control the machine movements
during therapy and basically a
prescription to be treated by one of
these things involves a physician
writing down the values of 400
parameters that has to be set and one of
the jobs of the software controller the
state the critical part is that it has
to make sure that every single one of
those parameters remain within the
prescribed limit during treatment
because if they don't you're risking
radiation exposure so this is one of the
main speakers were probably the subject
control has been maintained the first
version of this control that was
installed by the vendor would live in
Fortran the engineers who maintained the
machine they rewrote the software
Control Agency in the 1990s but very
recent thing around 2013 in order to
support new therapies that have switched
to programming language called ethics
does anyone heard of ethics this is the
most important programming language
nobody has ever heard of it controls
billions of dollars of scientific
equipment if you remember gravitational
waves being detected
I think it was last year that was
running at this code it runs everything
from telescopes to Neutron accelerators
to all sorts of advanced machinery so
they rewrote their consultant controller
in epics and they were wondering whether
this was correct does it satisfy this
safety-critical property that it needs
to maintain in order to check this we
wrote an interpreter for Ethics in
rosette and when we ran it on a
pre-release version of the therapy
control software we found a safety
critical bug that would have prevented
the being
from being shot off when it was the
postal then bug was so nasty in fact on
the way that we build an interpreter for
ethics is by reading the ethic
documentation essentially the spec and
implementing the spec when we found a
bug in begins of the engineers a
concrete input a test case they are
anything they're coded they were like
none of it is a false positive by your
tool our code works fine on this it
turns out that the bug in their code
with being masked by a bug in the ethics
at runtime so they have to go through
their code and are actually six all
instances of this box before they could
upgrade to the corrected version of the
runtime and they are currently using
this verifier to check their code every
time they add new therapies every time
they change it they will Rivera fire to
make sure that it's still safe
so that's one application another one is
very very different
there is a nonprofit organization called
N word which is based in Seattle it's
run by one of my colleges or Popovich
and M word mission is to create
educational tool that makes it easy for
little kids so we're talking a great
case or 12 to learn things like math
algebra and so on they are using
rossette to automatically generate
things like masking with educational mad
games that have been released by the
difference of total skills they're being
used by thousands of students well and
eventually million so that's the goal
what they're working on currently is
actually creating good reserve based
yourself that would enable people for
not necessarily experts at educational
technology so teacher themselves to
build their own tools and their own
games that work with their own
curriculum so that's another application
so the final one that I'm going to
mention very briefly and is a region of
application to super optimizations does
anybody know what super condition is so
what an optimizing compiler does in
order to optimize a piece of code it
will apply a series of rewrite rules to
the code right so pattern match we
arrive pattern match rewrites to
essentially make your code go faster
writing the zero is really hard right I
mean this is why people have taken you
know that capability and getting them
right is also really hard
super simulation instead of actually
creating variety we use a theorem prover
to search for optimal code sequences you
give me a list of straight line code
that's going to be my reference
implementation and I am going to search
for the most efficient sequence that
implements the one that you gave me but
minimizes some cost according to a
performance cost model this particular
framework called greenthumb
allows you to create these super
optimizer is very fast for very exotic
architectures and the performance
benefit that you gain are pretty
significant so for example it will show
up to 82 percent speed-up over DC co3
for the ARM chips when run on wireless
and embedded benchmarking suite so this
is a target this is the application Li
they were targeting and also it will
allow you to create optimizing compilers
for new emerging chips that are designed
to be very low energy very energy
efficient so they use a small amount of
energy to perform the same amount of
computation that a traditional chip
would and all you need to do to use this
thing is to essentially write an
insulator for your chip
and that will give you the education
synthesis part for free and green that
will do the super optimization search
for you so that's all I have thank you
very much for your attention and if you
have any questions I'll be happy to
think that afterwards because I'm out of
time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>