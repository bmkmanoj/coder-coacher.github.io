<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dendrology - Brandon Bloom | Coder Coacher - Coaching Coders</title><meta content="Dendrology - Brandon Bloom - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dendrology - Brandon Bloom</b></h2><h5 class="post__date">2014-03-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YgvJqWiyMRY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Brandon bloom and today I
want to talk about dendrology which is
the study of trees and the title for
this talk comes from Gary Frederick's
who who said this to me in the closure
IRC channel I was i made an offhand
remark about how i'm interested in new
ways to process and analyze trees and
i'm obsessed with this idea since coming
to closure and gary said well be bloom
is a dendrologist and i laughed pretty
hard at this he told closure but closure
bot now remembers that and it makes me
chuckle every time I think about it but
I think that as computer scientists and
especially as closure programmers we
should all will be dendrologist we
should all people who love and study
trees and so we'll talk about what I
mean by that and why first some
assumptions you love data you like
immutability you like values you like
these things right your closure
programmers you'd like all these great
ideas that rich enclosure has has put
into your mind and the argument I make
is this implies that you like trees and
i'm going to show you why that's the
case and I'm going to help you help you
see trees from the weird perspective I
see them so trees are everywhere in
software but the world is not
necessarily tree shaped and I found a
piece of clipart that perfectly
represents this the world is a big
puddle of spaghetti here and there's
this beautiful little piece of parsley
in the middle that's your nice
functional tree in this scary not so
functional spaghetti world and so I'm
going to help you untangle this bye-bye
thinking about about what makes a tree
in the nature of it so what's a tree
anyway this is a tree in this case I
label the tree nodes here letters and
I've got pointers from the parent nodes
down to their children and there are
some ordering here and there are many
many many many data structures that have
this general shape or feel or look to
them this is also a tree but this is a
very different type of
tree this is a case where the children
point to their parents and this is the
case you have in like a relational
database for instance you can have a
could be your customer and BCD could be
your orders and efg could be items and
the items have order IDs and the orders
have customer IDs this is the parents
pointing to their children this is a
very different type of tree than those
that we build our everyday data
structures out of I'm not talking about
this type of tree today I'm talking
about this one where the parents point
to their children that distinction there
alone a lot of people don't don't make
and I think it's an important one to
consider this is also a tree this is the
degenerate case of a tree this is a list
and this is a tree well not really this
is a directed acyclic graph but I argue
that this is as good as a tree because
there's a canonical traversal of this
and you just copy the nodes and you can
you can think of it as a tree and so
frankly a directed acyclic graph is just
an optimized tree and that's that's
important there are subtleties where
that's not true and you talk about
reference identity and and and things
like that but by and large you can think
of a directed acyclic graph as an
optimized tree this however is a cycle
this is not a tree this is a graph and
this causes all sorts of problems so
here's a real tree this is called a
banyan tree and what happens with the
bandage was everybody and then to be
seen a banyan tree before okay so this
thing is huge this is one tree what
happens is the trunk grows up vines come
down they touch the ground they take
root and they form new trunks and this
is one living tree every time you have
one of these new roots you cannot like
it changes like we're one tree begins in
one tree ends and so even real Dendra
let's get this wrong this is not a tree
this is a banyan graph and I argue that
there are that there are this problem
where where
we're dendrologist mischaracterized this
as a tree happens in programs all the
time where we're vines take root and
form new trunks and make it really hard
to say where one tree begins in one tree
ends and this is true because and so the
problem is that pointer cycles are the
root of all evil and just as with the
ban entry this is true because they're
also the talib all evil and so I'm going
to make the case that pointer cycles are
just generally evil and i'm going to
show you why and and help you justify
that to other folks when you say that
sort of crazy idea to them so I've got a
I've got my directed acyclic graph here
I've got a b c d and i've invented some
notation this little orange arrow you
can think of as an atom write it so it's
the root mutable cell for this tree and
this notation that i invented here is
just BD i want to say i want to rewrite
the tree at d from the path of be in to
be e if i do this my atom moves over I
get a nutria get a prime B Prime this
new E and I have the structural sharing
we all know and love from all our
closure data structures but what happens
if I have a cycle and try and do the
same thing well I have to copy the
entire cycle and this this may you might
be able to think well I can imagine a
case oh that's not no that's that's no
you this is always true with cycles you
always have to copy the whole cycle if
you have an immutable data structure or
if you had a mutable cycle and once you
create a pointer cycle you have this
problem and you lose the ability to do
optimized trees and and I'll dig more
into this problem in a moment but i want
to show you this how many people have
written or know what might have seen a
system that looks like this everybody's
hand should be up everyone has even
implemented this what this is is this is
your user interface code this is
anywhere where you have that parent
pointer right and so here this little
orange arrow that's that's one parent
pointer that's like component dot
container or something like that right
in your application
and even though in the source code you
only have that one up pointer that one
parent pointer that one vine over time
in your running application that takes
root and all those other up arrows are
just the one parent pointer in your code
so at runtime you have far more pointer
cycles than you had expected from that
one little pointer and so if you wanted
to rewrite g2g prime you have to rewrite
this entire tree if you wanted to
maintain your immutability of it so I'm
gonna go further I'm going to argue that
it's not just point your cycles that are
evil it's that pointers are evil just in
general and I'll show you an example of
of the semantic problems of pointers in
this context so here this orange arrow
here is actually not an up pointer per
se we'll call it a cross reference so we
can imagine this graph as for example a
let's say we're working on a word
document or a making funny faces at me
we're working on a latex document there
we go got it this is a cross reference
right and what we want to do here is we
want to change some text in paragraph B
and create paragraph B Prime well when
we do that we now have a bit of a
problem because D is pointing to the old
be if it's a pointer and so what we
really want to do is we don't want it to
be a pointer we want that to be kind of
like a nebulous cross reference thing
and we actually wanted to point to the
newbie than your B Prime and this can
happen in parallel with other threads
with other processes other functions if
I have be prying to be double Prime I
have this uh this detracts the B and
that pointer only has meaning or that
reference only has meaning in the
context of the current document this
reminds me of something which is this
slide i shamelessly stole from rich
which is a great slide and this is about
identities and the succession of of
states
and so when you think about this B is an
identity right it's a succession of
states it's B it's B prime it's be
double Prime and we think about
identities in the context of closure as
atoms as refs but in reality we actually
have more identities than these mutable
synchronized concurrency primitives
identity is just a more general concept
and so here in this example we actually
have two identities at play there's
there's the atom or whatever variable
that is and then there's this pointer or
non pointer to be so let's talk a little
bit more about pointers and identities
and I have to apologize because the
first code i'm going to show on screen
is a pseudo code in C++ my apologies for
this here is a pointer let's imagine
that C++ did not have pointers and let's
imagine that swear word in the middle
there is some syntax it actually works
to make this code correct and here is a
pointer right we've got our our static
memory that's global we've got some
pointer it's identified by a number we
can director which brings the memory and
the pointer address together we can do
math on our pointer and and this is what
a pointer is but if we get rid of that
pointer math we have a more abstract
thing a reference and this lets us use
smarter stuff like garbage collection
and we have lots of power by moving the
abstraction here so this probably still
should scare you a little bit now that
you see memory as a global mutable
variable there you don't think about it
that way but that's really what it is
and so as functional programmers we want
to get rid of that global mutable scary
thing so we need to accomplish that
magic swear word there so we still need
memory from somewhere so one thing we
could do is we could pass it in as an
argument to the reference this is kind
of problematic if memory becomes
immutable because then this reference
always points to the same thing it's not
a succession of values over time so in
order to
to get a succession of values over time
we actually want to pass memory to the
dr f function right we want to
dereference this in this piece of memory
and now let's see what that might look
like enclosure you have ID RF right this
is the at sign you use for your atoms or
whatever you can imagine a protocol IDF
in that reference that the reference is
an abstract identity in a context and I
could even want this reference much more
succinctly than the C++ as ID ruffian
memory with a swear word again and we
combine memory in that that address and
we're dereferencing that in that place
so example of how you may use this as if
i had a database reference it's a table
and an ID and i implemented i forgot to
mention the protocol there but i know
meant d rack in as get row in the
database i could create an instance of
this i can use it with dear i thin so
here brandon is user five ID reference
it in the context of the current
database and this this is this idea that
i just kind of was going over i want i
want to make the impression that that
identities only have meaning in a
context and the context you generally
work with is all of memory you don't
actually have to do this i direct thing
or idea afghan you shouldn't it was just
sort of for for illustration purposes in
reality you're going to do something
like this you're going to just write a
get user function right but what's
actually happening is you're dancing and
identity in a context and this is akin
to the example we saw earlier or talked
about earlier with with the referencing
a cross reference in your in your text
document because you want because that
that identity only as meaning in the
context of the current document you can
use this here get user Brandon five
right I d5 this is an identity right
this is a REST API endpoint this is an
identity this is just a vector with user
five this is an identity this is brandon
and you only know that from the previous
slides the context
five does not mean Brandon in other
context but in your applications you do
this all the time where you have pure
values that represent identities that
represent successions of values and if
you think about that it's it's really
deep early related to adams and refs and
all those different things and those
that great slide rich put into our our
collective thoughts years ago and so the
point i want to make here is that
context is king and so when you go to go
chat with folks and they say how was the
talk in the other room you'll say yeah
it was it was awesome and then you'll
say he put the burger king on a slide it
creeped me out and they'll be filling
like the burger king what was the
context and you'll say exactly it only
makes sense in context and so so
hopefully that mnemonic will help you
remember to think about context so the
the original identity is a symbol right
the atoms and refs of our of our list
for fathers are symbols and so here's a
piece of nonsensical closure code i
define a top-level X I I reference it in
several places eyeshadow it and then if
I compile that the closure script using
the closure compiler I get something
like this and what you'll note is that
in this context X is a var and in this
context X is a local and so if you if
you were at the Tim's tools tools
analyzer talk or if you have ever hacked
on the closure script compiler or taking
a look at the source it is a really
great place to learn about and see how
to do context in a closure way and this
this symbol being resolved in context is
is fundamental to how compilers work and
these symbols are no different than
atoms I just want to also point out that
context are not just about to
referencing identities in this case X is
a statement or it's in a statement
position in this case it's in a tail
position
and I don't actually care what thing is
in that position it's it could be a
symbol that can be the same it can be
different but in one case it's
contextually going to return because
it's in tail position and that doesn't
matter that these are X or not that's
that's a statement about the position in
the tree not about the identity in the
tree so I want to go over some examples
of context unrelated to identities and
give a little bit of practical advice on
working with trees enclosure so first
here's a tree labeled in breadth first
order and here is a representation of
that tree as a vector and a kind of
hiccup this style I recommend not doing
that and instead doing this and using
extensible Maps you will thank me later
do not try to be clever do not try to be
terse start with a map use children keys
addict your keys to the thing always
start with an extensible map you will
thank me when you start with the first
one and then get burned by the fact you
want to put extra data in and don't know
where to put it you can always add
syntax later you can always add that
abbreviation on top and in fact that's
what we already do when we write code
right we have this nice AST back yet
again going the tools the tools analyzer
example and we write s expressions and a
much more terse way on top and so syntax
is can be layered later so definitely
choose the second representation by
default so we're gonna do something
really some pretty simple algorithms
that and talk about them for way you may
not have talked about them or thought
about them before we're just going to
annotate we're stuff I annotating the
depth of each of these nodes so for each
node we want to assign a depth key to it
and give it give it a value here is a
simple recursive algorithm to do that we
kick off at the bottom there with the
base case and then we're cursed down the
tree incrementing the depth as we go and
then associating it into the map and
then we're cursing over the children
what I want to point out is depth here
this single integer is your contact
and this context gets merged onto the
tree again recommending that you this is
immediately this is valuable because I
wanted to put the data on there I just
do this pass over the tree and I have
the benefit of the heterogeneous map and
we're passing that context through the
tree downward there are also examples
where you pass context upward through
the tree so here I want to annotate the
max depth so let's take that tree
already annotated and do another pass
over it and do another simple recursive
algorithm and this time we're getting
the depth from the node and we're
passing it up the tree and in this case
it's the same traversal but we do some
work when we back out of the recursion
rather than when we go into the
recursion and this pattern happens all
the time when you do recursive
algorithms on tree you want to think
about if I have what the attribute
grammar folks would call an inherited
attribute that goes down or synthesized
attribute that goes up so let's look at
something that's oddly a bit trickier
that you wouldn't expect which is a
depth-first numbering of the tree here
this is the depth-first traversal the
way it would the order would go I give
each note a number its its index and
we'll start not by numbering the tree
but by printing the tree out in numbered
order so here I got a 01 be here is the
simple recursive algorithm that does
that printing and it's exactly the same
as you saw before but this time we're
threading through an index instead of a
depth value and we're kicking this guy
off with the base case and we're
returning Neil because we're not
returning the new tree we're just
printing it and this is very simple and
this matches the simple recursive
algorithm you guys didn't algorithms 101
when you were writing C or Pascal or
whatever they taught that class in or
Java nowadays and so it turns out to be
a little bit trickier when you have a
mutable data to number the tree and
actually return the tree changed because
you want to return the tree change and
all of the other changes along with it
and so
so it gets a little Messier and you have
this number get first recursive and
you'll note here that the same shape as
we've seen with the reducing over the
children where threading and index
through and a max index as well so the
index is inherited and moving downward
and the max index is synthesized than
moving upward from the children and at
this point you're probably looking at
this and going man I remember this being
a lot easier in my algorithms class and
for some weird reason this functional
version of it's like a little bit
hairier and I think that's because
you're you're actually seeing the the
actual true nature of the problem in
order to accomplish this and so you may
be tempted to do this imperative Lee and
frankly this is the version I would
write but I just wanted to show you
what's what's what's kind of behind this
right this is looping over it
recursively and incrementing an index
every time through and in this version I
just update in the current children and
recurs an update in the asos and I get
the the depth-first numbering that way
and the the atom here is effectively
doing the inheritance and synthase
synthesizing of that data for us and
don't feel bad to use a little bit of
mutability to simplify your code here
although there are other ways right and
so we'll look at some let's look at an
iterative version of printing not
numbering this tree here this this is an
iterative version and we're just doing a
loop and what I've done is I've made the
stack the execution stack explicit it
turns out that whenever you traverse a
tree you have some context that you're
getting for free from your evaluator
from your interpreter from your compiler
from your runtime you're getting the
call stack and that cost that's a data
structure and you're kind of cheating by
leveraging it as part of your algorithm
and so here I've made it real so that
nodes list with the initial node is a
stack and each time through i push the
children on to that stack and I don't
recommend you use concat to build a
stack that has some some issues but I
did
here for a reason to illustrate
something which is that by reifying the
context by making it a real thing so we
can talk about first of all I can debug
it now I can print that stack out but
more importantly I can make an
observation that if I swap those two
values i switch my depth first traversal
to a breadth-first traversal by
switching from a stack to a queue I've
changed this algorithm to do something
different if I were to have done this
recursively I would have had to totally
rewrite the entire algorithm to get a
breadth-first traversal and so by making
the context explicit I was able to have
this insight and this benefit and so
sure the recursive algorithm using a
stack is convenient and you should write
the more straightforward natural code in
the general case but you need to be
aware that that's what you're doing
right you're you're leveraging existing
context and that has a cost and the cost
is it's harder to bug but it's also
harder to to make these sorts of changes
when you swap out a data structure and
get a different and corresponding
algorithm so again that's just printing
the tree if we wanted to iteratively
label the tree we can look at the
context at E and so at E we have this
queue of nodes to visit and this stack
of the trees above us and when you see a
pair of stacks like this you should be
thinking functional queues and when
you're thinking and you're seeing
functional queues or stacks in this way
in a tree shape a thought you may have
is zippers and closure zippers I've
regretted using almost every time I do
but I've not regretted learning about
them and so I highly recommend you play
with them and get an intuition for them
and then you can do like like David said
in his own talk and encode context of
your tree and a different style than in
the up-down left-right zipper style but
i'm going to use zippers here to
illustrate how you can do a functional
iterative traversal with reified context
pretty
simply so here I'm going to make a
zipper I've got a branch any node can
have children the children are stored
the children key I can create a new node
or a modified version of a node by
composing children with the node just
associating it in and I'll kick it off
with a root and here is number
depth-first with a zipper so what's
happening here is I'm looping starting
with index zero I've made a zipper for
the initial position which is both my
context of the tree around me and the
queue for a depth-first traversal ahead
of me I ask if I'm at the end of the
zipper I if I do that I rewind a zipper
back to the root otherwise I just keep
on ricura curse through this thing
iteratively proceeding to the next
location and what's happening here is
that the complete context of this
algorithm is data the index right that
synthesize inherited chained attribute
the traversal context both the future of
the traversal and the past of it and all
of the tria rounding it are encapsulated
in that zipper and that index and so I
can print that out visualize it think
about it debug it do backtracking you
also do crazy things that I couldn't do
if this was hidden in the execution
context and so what I encourage you to
do not necessarily to use zippers but to
think about can I reify context as a
first class thing what is my contacts
what does it look like and if you think
about that you'll actually come up with
more easy to debug and more easy to
change programs now I'm not going to
talk about a breadth-first numbering
because it turns out that closure zipper
API won't lend itself to a convenient
swapping of the concat order and there
are some pretty interesting bits of
research around like why is this
surprisingly difficult why is that code
look hairier than the imperative version
and I'm not going to try to pronounce
their names but these guys have done a
lot of the the
work on functional data structures on
functional iterators and this idea is
now well understood in the research
community and what I encourage you to do
is to try these examples on your own in
a functional way that these really
simple examples from from like you're
early 101 algorithms classes and and pay
special attention to context when you do
so and you'll learn something you'll
internalize these these ideas and then
when you're done try these try doing a
breath verse iterator it's it's a little
bit of mind bender and it's kind of it's
kind of fun so what I want to do is
leave you with the key ideas of this
talk which are that when you work with
trees you need to carefully consider
your identities and your context these
two ideas are fundamental to language
and I mean that both in the human sense
and in the programming sense to symbolic
computation their fundamental to trees
and if you are carefully considered of
of your identities and your contacts
you'll have easier to bug programs
you'll have more flexible programs
you'll have faster programs that'll have
features they didn't have like
backtracking iterators can give you and
all that sort of stuff and you'll have
happy trees and the result is that you
will be a dendrologist like me and king
of the mountain and and take over the
trees here and this sort of thinking has
been really beneficial to me in my work
enclosure and I hope it's beneficial to
you so thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>