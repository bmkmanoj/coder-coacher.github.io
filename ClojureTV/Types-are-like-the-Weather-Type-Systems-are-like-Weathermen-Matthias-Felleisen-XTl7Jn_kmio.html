<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Types are like the Weather, Type Systems are like Weathermen - Matthias Felleisen | Coder Coacher - Coaching Coders</title><meta content="Types are like the Weather, Type Systems are like Weathermen - Matthias Felleisen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Types are like the Weather, Type Systems are like Weathermen - Matthias Felleisen</b></h2><h5 class="post__date">2016-04-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XTl7Jn_kmio" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I have learned a lot from this community
you are great and you're doing really
cool stuff with functional programming
in industry which I teach to middle
school children and high school kids and
freshmen and master students and so it's
a real pleasure to see that I wish I had
a day to tell you all the mistakes I saw
that we made and you're making them
again but but I don't so as as Mark said
I'm the man I'm the man who stands
between you and the party and it's worse
I'm a professor and I just can't leave
it so I was thinking of giving you a
lightweight talk about the weather I'm
not I'm gonna give you a lecture with
pop quizzes and we'll practice this
popular stuff right now okay ready okay
so here's how it works on location I
will give you a question and I expect
this audience to participate that's how
it works I actually knew to know all the
names I can call them people the name
it's not gonna have time for that now so
a few years ago three years ago I wrote
a book with eight freshmen at my
university now they're not freshmen
anymore actually finished I'm publishing
at with no star - no Riley label and I
will call our questions and if he answer
those questions you will get a copy okay
so we practice that now I'm just going
to call it a question and and and I'll
pick somebody who finishes correctly who
can stand up quickly
it's just one oh absolutely it's not
because the front row I don't mind
walking to the back row okay
so just just do it okay so yesterday
morning Claire who spent a lot of time
in my lap between two or three years
working with me stood here and gave you
talk and apologized for using the word
type over and over again I feel really
bad for her like you know here she
stands and hears apologized the
community so if you know this picture
it's from its from a little from a
little current country album it's I feel
like the types on misunderstood here
it's like this song mr. misunderstood
this little kid sends in the back of the
school school room classroom and he just
doesn't get it doesn't get any attention
and you ignoring him and I did too for a
long time now learn to appreciate this
guy over many years and I want to tell
you that story in an hour so here's my
life story
I'm condensing thirty-five years of my
life for you in one hour it's hard but
we'll try okay
so what I did was I started out like
many of you in an imperative world with
dumb types and then a couple of years
later I switch to prologue I'm typed
right and I went to scheme and other
things and you see the whole life you I
won't tell you what the life exactly is
like but this stage is where I got to
realize types on completely evil right
and so as a first stage is orange stage
where I started thinking about them and
publishing about them but always stop to
I'm type programming and I am known as
the academic the only fool academic
that's what I call me there who sticks
to untyped languages everybody knows
types other thing to do and then there's
a red face when we start doing racket
and we realized it's red because it's
really hot red over 20 years we maintain
the code base and maintaining a code
base really really brought home to me
what it meant to have those types in
your language even if you start out
untyped like all of you do okay so
that's the story I wanna break us why
I've migrated over 30 years from a love
of untie programming to appreciating
types okay so there are two notions of
types there's the one that tells the
compiler allocate that many bits and
make that run fast and I don't care
about that one I just don't
I want the types that tell me the
developer and I do develop coding as a
professor right tell me something about
the program something that helps me work
with that code that I'm writing down so
that's what my focus is okay
and when I say maintain are you gonna
give you a just an idea what the code
base was like a few years ago five
hundred thousand lines of code
I've heard people here call a code base
of 10,000 lines big that's a little bit
bigger okay
and when you do that when you talk about
development time what I'm interested in
so it's a very simple phenomenon you
start you develop something you deploy
it and then you have to do more work and
what you see and any deployed again and
you you know the whole cycle you know of
the cycle and what's really going on is
that what you do at the front end
affects the time you spent afterwards on
that code that should be called
development time don't just call it the
first little step development time okay
good
so in that spirit type I like the
weather right so sometimes the weather
is just fine and you don't care you go
out there you enjoy you don't pay
attention sometimes you know you have a
nice landscape enjoy even more because
you have a day off the rain is over
rainbow comes out you don't need
umbrella anymore
with any of that anybody from Tornado
Alley here I know what I mean yeah there
we go right you you want to know when
that thing is coming tomorrow or if you
have lifted the Gulf Coast and two
through two hurricanes that's what you
go with it you want to know that these
things are coming in ok that's true too
for computation when things go right you
get an answer often they don't and then
those of you oh that's cool a lot more
people laughing I thought with laughs I
thought they had eliminated that one you
know but don't get schmuck the Linux
people have the problem too and in this
image of course you don't have blue
screens of death anymore
we have exceptions and they exist in
closure too so you know wouldn't it be
fun if we could think about the weather
and the types well 15 years ago 100
weather reporting became a big thing
what would and then they know it
afterwards for all kinds of purposes and
very applied purposes for more platforms
in the Gulf to you know corn fields in
the West and they're very important
purposes and so what people do but the
field figured out was you can write them
you can look at today's weather so to
speak or something in the world you can
write on a bunch of math and then what
you do is you turn this into pretty
pictures on TV
okay and they they distill this math
into stuff that is good enough just good
enough right and tomorrow you actually
experience good enough you stay indoors
because there's a thunderstorm or you go
outdoors because it's a great technique
plan right and the predictions aren't
perfect by any means but they're useful
okay and they are kind of accurate and
if you notice the weather reporting my
age group knows that where's the
reporting where the predicting have
become much more accurate over last
year's lottery tickets right the other
thing is of course they're partial you
don't get a complete with a report that
can give you a lot more details but even
they don't know everything so what you
get is little hints little pictures and
it's good enough you just look at this
icon you know is sunshine or as a
hurricane coming I'd stay indoors you
know whatever right and the question is
what's accuracy same is true in
programming you can write down code and
you can actually write down equations
about that code or you can write down
your thoughts about this code and we
synthesize equations from this code okay
and then we still this and check what
these thoughts you thought about the
code predict about running that okay and
then you get 42 and the predictions just
like the weatherman are the partial
predictions they're not complete but
they're useful I promise you I'll show
you some uses and the question is how
accurate are they or if they're not
accurate how bad can they be so here's
two little predictions and you can write
many more the first one is a function it
says give me number and I give you a
number back of course you can recoat and
you can do better than that you know
it's a square of that number you get
back right or if you write down fun X X
you know that whatever you give me I
give you back right that's what I mean
by predict
and we can check those by checking the
context of this thing by checking B by
checking the actual inside of the
function stuff like that the question is
accuracy what does it mean so when you
take away from this part of the talk is
that types of the language of
predictions yeah your language of
predicting what happens when you compute
okay type systems check your predictions
and let you know how good you are with
them the question is the question you
asked is useful and is it meaningful and
I'm gonna roll back I'm gonna roll up
these questions backwards because
meaningful is very important and it will
get back to the very end of this talk
when I talk about that type closure it's
often called soundness
it's called type soundness and I will
tell you at the end of this part of talk
that it has nothing to do with types
you'll find out so this is a computation
it's a random walk through the land of
bits often I call it the sea of bits and
you'll appreciate this because your
programs right you go along and you your
compilation may be stated enclosure it
may be sit in Java in racket but
eventually it's compiled down to the
things that everybody on the street
knows computers do with things in bits
and so you get to this place where you
have a bit string and if another bit
string and you add the bit strings
together all right but what if some of
those bits don't actually represent a
number what you the developer thought
would be a number when he gets there
there's an odd thought isn't it and I
know some of you know that this works
and some of you have may be surprised
okay but the machine doesn't think the
machine is told here to pitch strings
adding together and the CPU the
the coppers I said whatever we'll do
that the question can it happen and the
thing is in unsafe languages this
happens all the time for unsafe unsound
right say many bits of bits
life goes on which is continued
computing because that's what happens
next right what happens when you add the
character C to the value true perfect
addition right in bits tricks if you're
lucky if you're really really lucky you
get a blue screen of death but usually
you're not lucky you get an answer and
it's close enough to what you want it
let's go with it right
that's an unsound language so even
during testing if you take that path it
may just look like you came out okay
that should scare you if you think that
this code is in your grandma's heart
pacemaker because it just outputs stuff
and sometimes it will output 42 million
into the 42 and the heart rate goes up
or down okay so how about a sound
language in the sound language you get
to the same point and for some reason
how we figured out that you're not
adding two numbers okay and you
immediately get an exception it stops
right here but this is a little picture
down there and all of you're curious to
see what it says right okay if that
exception is raised in the operational
during surgery
well your instruments go down so maybe
exceptions aren't that much better right
well I want to bring this across because
I'm a scientist I'm not an ideologue I'm
not gonna sell you one side or the other
I'm going to show you there's a spectrum
of things and the spectrum here is the
question that you get asked is our
developers better off most of the time
yes because you get the exception during
testing and it very much nails down the
source of where things went wrong that's
not necessarily where the illogical
barks its but that's the source where
you can trace it back that's a huge
progress over the fact that the
computation just goes on and says 42 I
use this better off most of the time yes
because they don't purchase an aircraft
when I want a pair of shoes or something
else goes wrong right okay
something goes wrong early enough and
worse things don't happen so that's
that's what you see here
okay so soundness something is really
establishes very important
characteristics or language safety
soundness bring across what happens at
the bit level seen from the source level
and we want that okay so I'm giving you
takeaways and I give put the slides in
there on somewhere on the web and you
can download them so you know what is
not in this part right whoops as I said
before it's a spectrum it's not a binary
decision academics always talk about a
binary thing it's sound or it's not
sound I believe it's a spectrum and we
just moved over on the scale from really
really evil to it's okay the question
that should be on your mind is its
closure type sound okay let's pick this
pop quiz I'm gonna see you Father what
do you think hands up
okay you lost because it's not a single
answer right so I can't give you a book
okay that was a dirty trick okay I'll do
better later it turns out that so-called
unter not all but many untyped languages
actually have one type and that type is
a simple prediction the program will
start running I don't know how far it
gets but it will start okay and that's
if you if you hang out on the slum
called web then you know that this is
due to Bob Harper it's actually not due
to Bob Harper it's a quote from Dana
Scott from the 1970s then here equals
over and over again and Bob and I go
back a long time so he will forgive me
when I say that okay so what I say is
and he says it by the way he agrees with
that a language was a single type can be
sound and in that spirit closure is
mostly sound it's weird isn't it so
closure has no types except for one and
every expression is that type and it's
sound with respect to this time that's
not a bad thing so first is how useful
is it to have one type this is my Bob
this is my answer to Bob right well
let's say what it means if you're in
closure you have a loved one type so
everything in closure like the variable
M here has the type the variable X and
the function isn't in the bottom it has
that one type the function over there it
has that one time
that's the remind you of something it
ought to remind you of the language that
you hate because they also have one type
well they have more but in reality you
use one type the type voice over and
over again my function test my method
takes no inputs it returns void my for
loop it doesn't do anything it returns
void void work work work
that's all you get there it's not very
practical either because as a functional
programmer you have many more thoughts
about how your program will run you have
such more sophisticated thoughts because
you are dealing with little mathematical
things okay and so you know that M isn't
just the one type it's a map and you can
be more precise than that or that thing
over there is a thunk it takes no
arguments but it gives you string back
when you run it and the thing down there
is a function could be function that
takes in one of those songs and then
returns a string okay so these are much
more sophisticated thoughts they're not
perfect thoughts about what these
functions will do but they're far more
sophisticated
right okay so then what's really going
on is you have thoughts and you can't
write them down and that's a real
problem because code is written for the
next developer to be to read it and by
the way it also runs on a computer I
wish I were the first one to say that
I'm not it goes back a long long time
okay but that's if you if you take
nothing away from this talk that is
something you should take away it's for
other people to read they read your
thoughts but you can't even write them
down so let's look at a very concrete
example for my record world so I got
this program as a Christmas gift don't
laugh I kept telling my PhD students I
had grown up on Algol 60 and I love that
little language and it was wonderful so
Matthew Flatts
the guy who creates the bottom of the of
the racket beast he implemented Algol 60
in our framework which is a language for
programming languages in afternoon it
used to take five six years to create an
hour ago 60 compiler
he's an afternoon shipped it off and I
played with that and I started running
program analysis on it
and of course he found a mistake
somewhere deep down there at the time
the thing was a tree lines in one
function mess that Matthew is a really
great programmer
I trusted my life I trust I trust with
my life but but he sometimes makes for
long functions fortunately he was about
to come out there was like in February
whatever and so I sat down with him and
we we looked at the problem right we
looked for what's going on and he sat
down with me and 20 minutes later he had
figured out what the parameters of that
function were doing what what they stood
for - only 20 minutes what's that
considering a whole lifetime right 20
minutes to reconstruct because the only
comment he had was actually start
reading the compiler here at the very
top so clearly we learned our lesson and
we wrote down we wrote down a comment
you see the comment pop quiz what's the
problem
with that comment you come up we
actually tell me the answer first no
precise almost what no getting close
keep going keep going this is pop please
come on yes yes it's wrong come on up
good job
what is it name right yes yes yes you're
supposed to guess that's exactly the
right strategy because it's obvious
there's a serum out there all comments
are wrong all the time that's of course
not true and I make using a gorgeous
statement but it's really what's going
on is comments are kind is a spectrum
it's never binary comments are mostly
okay in there convey a sense of what's
going on but they're not really perfect
that's the better way of saying it but
they're all wrong all the time
and you can see here there are four
things supposedly going into the
function according to comment and we
route on these little quasi types but
they actually five parameters the
program changed something like that so
we learned our lesson we slowly started
adding types to racket and we rode on
and in red is a good stuff right we rode
on types and what's the advantage the
bench is you can check them like
somebody said comments aren't checked ok
types are checked and so now we know
next time you read that code and we
worried over over again we know that
checked and then predict the computation
properly so when we have a buck we can
go back and say what's wrong with the
prediction we can rely on these things
so it's not just for maintainer now this
is a little clock it's not really
commercial but that's the book that
might talk about the one on the left but
actually the way I write books is or
write them on the web first and then I
force publishers to buy it while leaving
the text on the web so MIT press
publishes book very happily but the
whole text online ok
what this text really teaches is if you
think with types as comments you create
programs with the right organization
that's what Mike was trying to say what
we're saying and an introduction so so
types even an untyped language like
racket or closure if you write them down
as comments will help you organize your
program properly recursion is no problem
from here or not four weeks in the first
course you ever take you eat recursion
during day time and you dream of it no
nightmares wonderful dreams at night
time really so that's it so takeaway
from this part is all of you think types
all the time
sometimes a bit more refined sometimes a
bit less refined but you think them it
just happens to be the case that closure
won't let you write them down but if you
can't write them down you can't check
them and the guy that follows up on you
has to reconstruct them 20 minutes per
method or something like that for good
guy so if you are not married if you
don't want to spend time with your kids
if you hate vacations that's the way
your program
okay or if you are running a startup and
your venture capitalists have no limits
on the funds they're gonna throw at you
that's the way you run their company
okay but I love anti programming too so
what can we do about the situation how
many of you have heard of type inference
good the answer is okay I'm a researcher
I don't give answers like this without
justification I have opinions but these
opinions are typically established over
years of working on a problem and then
working out why the answer is clip no I
spent 15 years of research exploring
four different approaches to type
inference on untyped languages like
scheme 84 scheme 88 PLT scheme racket it
doesn't work that would be another
hour-long talk on explaining why it
doesn't work and I'm actually giving a
talk like this in the Eco at the Korean
version of this kind of thing it's more
strange location in Europe in a few
months I'll give you a bottom line
inside and Bob Bob Harper told me that
you've been as I start on this work if
you don't have a language of types in
mind inferring types is near inferring
that program is really care about it's
nearly impossible and then the lots of
technical problems and the real problem
is when when things go right nobody
cares
everybody is fine Danny okay but these
things go wrong things go wrong all the
time type errors right then you have to
come up with air masses that are
informative
and you don't get them it's just
impossible to get good ones even for the
MLL guy so the Hasker guys good ones so
don't go there okay no type inference
we're gonna write down our thoughts
we're actually going to write in our
thoughts leaving behind for the next guy
to take over and the next guy to take
over could be you 2 years older or 2
days older and you forgot what's going
on all of us get out there sooner or
later
okay so how do you add
how should adding types to an untyped
language work out when you have a
reasonable-sized codebase like this one
you you cannot have you cannot put your
team there overnight and says spend two
more hours tonight and put types in all
the five nine thousand lines of code
this doesn't work you want to be able to
add those things very carefully
gradually incremental e basically what
you want to do is you want to add them
like this leave a bug or your open some
file to add a feature and used to
reconstruct something by golly I'll
write it down
and if you don't have to open the file
leave it alone
that's incrementing right it's actually
easy but here's another thing you live
in a community that's untyped I live in
a community that is untyped we develop
our own idioms of programming okay if we
the type checker if you add a type
checker that forces you to rewrite
working code of course you're gonna get
mad at me all you should have to do is
write down you type your thoughts to
type predictions on the variables
without actually touching cook and we
can do that for 98% 99% of functional
code and you don't care about the other
kinds of code that we write because
they're not welcome here understand the
imperative okay finally you want a third
property that is something like
soundness you you want to raise
exceptions or you want to get type
errors that makes sense to you I can't
cover the whole thing
I'll give you some indications of all
three in the next unit in this last big
part of the talk so I have this nice
little module and I have wonderful
comments that say these functions F G
and H take non-empty lists of numbers
and then I'm going to call this thing on
the empty list what's going to happen
no it's untyped it's comments a runtime
error yes and this is pop quiz come on
guys
exception where's the exception erased
anybody see last line I couldn't I think
it was you so if it wasn't you're lucky
mister what's your name ladies there we
go one more Bryce man is okay good
good job so what happens is this empty
melodies empty lists flows in and you've
experienced that in some shape or other
it bubbles down from F to G to age to
age inside and then it says that can't
be a first or a car of an empty list
don't tell me you have never seen this
error so of course you don't know where
this empty list came from so what
happens if you add types if I add sound
types non empty list may not be your
type that I really check but if I do
check it and I do call F on empty list
I get that error right here at the top
of the chain okay at the top of the
chain I don't have to think through six
seven eight lane layers I got it at the
top I can go home play with the kids but
that twenty-five and thirty now so
okay here's another one this is untyped
idioms this is probably the code density
slide of the talk so I'm going to go
deeply into this but I give you notes
too many parentheses we have thought
okay that comes from copy and pasting
from running code sorry so on the left
side I have this informal comment this
is a this is a program that I teach
beginners in the fourth or fifth week so
a shape is this thing that's either
square or circle or circle as radios the
square for the size and the cons pair of
two shapes like you can put together two
shapes and you know you have a tree of
shape and you render them on the screen
afterwards and you have a little example
to the bottom that's the left hand side
and the right hand side you've a
function that computes the approximate
area of such shapes just approximate
like pies three make this is like in the
NRA so I got my PhD there dunk it's
actually true I checked it out Alexis
nobody knows in Indiana our pies three
eighteen sixty something so anyway so of
course you lay out that function on the
right exactly a glowed according to the
data definition there's comment on the
left okay um and why do you think about
that code the way you think about that
code is I'm getting a shape okay and
when I see a circle on the right inside
of my conditional so this is how we
write conditions can't write you know
that s is no longer just an ordinary
shape it's a square you know that so
that's how you think about that very
simple predicate based thinking it's
called predicate logic actually but you
don't have to know that next line down
you know on the right hand side of that
can't that's not a shape it's a circle
do you know the s now stands for circle
because I tested that with circle huh
on the right hand on the left hand side
and down here I know that s and s are
shapes and I even know that they're
smaller shapes and the one that was
I'll call as in critters right so that's
the kind of idiom you think with think
about any type language you know they
don't do that
you enclosure world you write code like
this - and you think that way - so what
you do is you take one same variable and
it stands for different types in
different places now when we add types
in type record all we really do is like
I promise incremental like we only add
that line we turn this comment into an
type annotation on one variable the area
function in our prediction our
weatherman goes through the coat and
make sure out he gave me but now I
know that I tests a circle so I know
that on the right hand side of this con
I actually have a square so let's go to
the square whatever one of those things
you get circles and squares the type
system knows how to cope with a variable
the same variable in different places
having different types some types the
way set based thinking works you may
never heard of her you may have never
heard of sets but you think with sets
enclosure all the time I have a big set
of shapes but now I'm dealing with
circles which is a little subset that's
how we think and the type checker has to
accommodate those idioms okay how does
it doesn't matter but it has to do that
and what we call that is occurrence
typing and we have many more tricks in
the type checker and a typed language to
accommodate untyped thinking so that's
what I mean by accommodating the idioms
that you have grown up with that you've
come to love that you use on a daily
basis we don't want to touch them it's
working code the most we want to do is
add an annotation that says this should
work okay incrementality so the I don't
want to talk too much about it so that
there's a code in academia there was a
co invention of this idea of explicit
gradual typing it's called incremental
typing this is spectrum in type racket
we have real modules think of a file if
speaking good enough
with a few extra specs in reticulated
python which is a reasonably new
creation very let you not just deal with
an entire module that's now typed
whatever you want to write it down they
deal with it and they let you do it an
expression level it's much more
incremental much more gradual and as a
spectrum using this so Facebook has
created a type PHP Microsoft has created
a type JavaScript they're using these
things and they live somewhere on that
spectrum okay so there's a whole bunch
of these languages have fall upon our
leet and do that kind of stuff and you
of course you know if have closure
exists somewhere on that spectrum and a
little bit about it later so what does
it mean let's go back to soundness what
does it mean to have a module right a
module is like in our world so racket is
not a language it's a family of
languages that is extensible you can
make your own so the first line of every
module says I am in my favorite language
which in this case is racket then you
can do your provides and you can put it
anywhere but I put them in the top and
you can say I'm I'm exploiting only one
function
I'm call the function redo or delete
whatever call later on then have some
comments right right here it says it's a
string and a natural number and I get a
string back and of course the function
definitions and so on so now suppose I
export this thing it means I require
less like closure Lane I require this
file and I call this function I call it
redo now called delete I'm sorry
talk isn't finished so but I'm giving it
so so sorry ain't pouring this thing
right what does it mean if I move one
module into typed lamp and all I do I
really all I do is I say type racket in
the first line and then I turned
comments into annotations that checked
and if they're not okay I will fix them
but this is what was what these things
look like
so now I'm exporting a function from
title and where it was type checked to
untyped land who can tell what the
mistake is he was first okay your name
LVH he got it
so so what should happen right what
should happen when when I when the typed
land gives the untyped land of function
and the untyped land has a mistake maybe
he's only covered now you know what
should happen that wasn't a pop quiz but
come on up
you don't have a nametag you're like me
David okay good job well two modules is
not how we operate I don't actually know
how many modules we happens in tens of
thousands so what if some of them are
typed some of them are not and you keep
belong eggs to keep exporting say the
leftmost is typed you see the red thing
in there and all the others are untied
and just keep on passing along the buck
like back then the buck stopped there
that was two men but now we have
somebody else and and and you end up
having a mistake down there far far away
different galaxy right what should
happen what happens in type racket we
tell you exactly where that value cross
from tie plant to untie plant and say
this is where you have to fix something
because you have assumptions that later
on weigh you down on the road caused an
error and the only place you can fix it
is at that boundary because you made an
assumption in the type world about the
untapped world how you would use that
value and that's wrong so somewhere in
the middle you need you need a module an
adapter design there's actually a
mathematical theory behind that that
tells you exactly why that is and so
it's a theorem of economic value and we
can talk about this later if you want I
see your questions don't worry about it
okay how do we do that
what we roughly do we call these things
contracts you might call them wrappers
they're really proxy values that the
chip knows about we wrap those things
that flow out of type land in the
untyped land and we remember where this
assumption that there would be okay
an untyped land is established that's
the boundary okay
and then when something happens that's
how we can point back of course we call
it carries along predicates and stuff
like this details are not really too
important but that's what happens yes
yes the question was did the error
surface in the net in the untapped world
yes the untied world treats the function
from in T to the integer by applying it
to hello world
it shouldn't something went wrong this
saves to develop a tremendous time we
know that because we know exactly where
the search for the misconception that
this function would be okay to live an
untyped land the developer can do that
okay here's the key question this is
where it's really closure issue now what
happens if we don't use contracts if we
don't establish a firm boundary between
the tight land and the untied land
that's not true
if you don't have these proxy values
that monitor how you use type values in
untyped land here's what can happen on
the left side with read annotations I
have type closure and it has implemented
a voting machine and one of the voting
machines could be a setup
where I say who you can vote for like
Donald and it's used it's X imported
into an untyped thing top right and you
set up your ballot and the first guy on
the ballot is Donald Duck right and what
you do is you export the function that
also says let me update the votes that
Donald got or the other guys in the list
right and of course you know you know
that vote additions from a precinct can
only be positive as our natural numbers
counting numbers zero one two three
right
okay so we're exporting this thing with
the second line it says I am taking a
name and the counting number of votes
that this guy got so none exporting this
function to an untyped module okay so
what do you think will happen let's
think so on the right side something odd
happens I'm having negative notes from a
precinct what do you think is gonna
happen here to end up for come on no no
one more one more pop kiss there we go
your name was you can't get more than
one did you have only one off okay a G a
G so if you by the way you got a book
for pop quiz don't come a second time I
know you're all good in really good
students so so if you if you export that
without checking that the function
always consumes natural numbers it's
okay it's perfectly okay to pass in
minus two three four
nobody will check how you use that
function and of course inside of typed
land we had already checked that you
only use non-negative integers we can
check that damn so now we just tricked
Donald Duck into losing 234 votes the
calculation goes on just like before you
have reopened the door to completely
unsafe C++ style programming that's what
unchecked optional types do and
unfortunately that's what type closure
does and Ambrose knows that's why it's
now a PhD student
okay so that was a long part it's types
for untyped languages and here's the
list of things that I think are critical
to make this work you must teach that
type system your idioms mostly works out
sometimes we have idioms that we don't
speak for example we have classes as
first class values in racket and we took
us four years to figure out how to deal
with that because nobody had ever
thought of this anti plant and I assume
we'll talk about just finished just PhD
on that a couple of weeks ago the next
thing is we need to be gradual and how
gradual isn't clear yet
until recently I thought module level
was good I have not one of my research
scientists when the Microsoft and is
missing type JavaScript and there you
can do much finer grained gradual types
and he is unbelievably happy
so he's again like me he's an untyped
programmer but she loves to write down
types for complicated functions and he
says this very fine granularity is
really cool no soundness no business
you're gonna have you're gonna lift the
problems that exist only at the bit
level to the source level
congratulations it's not it's not
progress it's a step back if you do have
it you get two things out of it you will
get a heightened sense of security
because types establish once and for all
that certain properties hold the once
and for all let's say this computation
will behave in this way okay that's
really cool
it's a for all quantifier assertions
check that for particular values that
flow through these things work
predicates for one value that flows
through or three over five but not for
all and the other one is
it reduces developer time and as I said
before you know if you're happy not
having time for other things then maybe
you don't want them but that's what it
does but there's a problem and I'm a
researcher in addition to a developer
and I will admit that for a long time we
didn't know what the cost was
and to my embarrassment the cost is much
higher than I expected
it took us about a year and a half to
figure out a performance evaluation
framework again I don't have time to
talk about this year we push publish an
academic paper about this and at the
moment I will just call this an open
research problem some of you may have
seen the tweets about my paper there and
it says gradual typing is dead or type
closure is dead it's not true it's not
true
just like Lazarus we will resurrect the
sky or you may know the movie where it
says dead isn't almost that it's not the
same as dead right anybody know the
movie friends is Fri there we go okay so
it's perfectly big takeaway big takeaway
I wouldn't let you read the next slide
that's what you will find on my coma
homepage and that's the first thing I
show every freshman who wants to learn
the code you really you really really
want to think that way and you almost
want to think that the Psychopaths out
there who are just users we should have
a much higher standard of coding closure
is the right step in this directions I
think function programming is superior
in getting code right and getting it
useful code right to the users out there
but we need to think that way that's the
only way I just think properly okay so
take that slide home to anybody take a
picture real quick
all right I love untie programming to
this day I almost never never never
start in time record even though it's
been it's ten years old now it's really
mature to expect companies some
companies apparently make a lot of money
on it but you know it's not my thing and
it probably isn't used either part of it
is I explore with code you explore with
code part of it is I know what I'm doing
I'm a macho man or your macho woman or
whatever it is you know we don't need
that of course it's my head anyway and
then I catch myself oh man I should've
written it down you know and so I have
this ongoing research program and I I
pursue this reading for a long time
in essence I first of pursue this region
from for thirty years okay and now I'm
in a position where I can actually
execute and when I my share of the
Cobras is relatively small is about
20,000 25,000 lines of code but it's at
the very surface that middle school high
school students or freshmen see so I
have to be careful when I open things
now I add tags and I'm incredibly
careful I'm doing it right okay it saves
me time my kids are old enough that need
me anymore vacation I love my profession
why should have your vacation you know
but I really it really saves me time for
doing more things there's so many things
in my plate still I'm you know I'm close
to death so no you never know what you
get but you also want to add value to
your grandmother's life and types help
you there too okay so so so don't
dismiss them as oh I know they're only
catch typos that catch typos in Java but
your enclosure you are thinking rich
thoughts about types you've a very
refined way of thinking about things
you're composing these things that's
where it helps nobody else composes
stuff
the only composition operator in java is
C my color
Boyd composed with void you have two
voids now right you are composing
expressions you're composing functions
you're composing functors you will have
one day okay
and that composition works because
you've picked your types right and you
have them in your head and sometimes you
want to write them down because then you
have them checked and they are true once
and for all because you will get a sound
closure language sound type tours
language - it's a research program we
have built a hybrid language where you
can play with this and I encourage you
to go out there and play with racket and
type record just to get a sense of how
it works for example how you compose
many modules and we blame exactly the
place where it goes wrong you will see
the developer oh I know how to fix that
because it's at the boundary this one is
wrong this one you know exactly what's
going on okay so just play with it so
I'm I'm not saying a bat enclosure but
record it really is much cooler okay
with that said thank you very much
I'm questions give a book no okay good
so I just had dinner with Ambrose in
Europe actually last week and because he
came to give a talk and he's slowly
moving he realizes what he did wrong and
he said to ask the same somebody else in
me actually the amend of RabbitMQ so
what he said was I was a master student
I literally copy Sam's work and didn't
know what I was doing and because I
didn't know was doing and this contract
stuff was not in closure and I don't
have proxy values in the JVM I didn't
know what to do so I just a bat me
because I didn't think was a big deal
and of course now he completely
understands and he he went to Indiana
because he wants to work with Sam on
this project so he is he's clearly
thinking his ideas and how to add the
necessary mechanisms is this contract
proxies but I wanna warn you it's
expensive and we have to figure out how
to make them cheap so a parallel project
that we're running in different places
is a JIT compiler that is really aware
much more aware than we are now of the
practicing push through so for example
we have reduced the overhead by factors
already so there is there is hope I
think very long term I think about 20
years that's long term and I don't know
you don't have that time so don't wait
for us but pray for us that we succeed
in our in our research program
so we have a first and mu skip the party
is there a second I don't do that I have
to make of a talk so maybe I come back
one day it is there's a bunch of things
that just obvious I will tell you I
learned a lot and I see a lot of
repetition and it's just wonderful it
would be much more wonderful if we had a
much closer connection so one of things
I've been talking about is that some of
you should maybe get together and talk
about putting closure where I put it in
the early education because algebra is
the key element of Education in school
and it is has an incredible impact on
the kids with closure and racket and
teaching language actually call them you
can make huge progress in bringing
across the kids who never understood
math to say this is cool stuff we've
hundreds and thousands of teachers that
do that really works ok so another thing
I would like to encourage you so you
just rewrite the books that I rode hey
they're online right enclosure you know
you should never have a junior developer
stand up ever again and say recursion
was magic to me because it's your
brother you bought your bread and butter
and these books do that and super nachi
of victrola ruled out from those books
they don't teach factorial they don't
eat recursion recursion is when the
structure of the code matches the
structure of the type even if the types
are just in comments so other things
that you can easily inherit from us as a
lot of useful work that we need to
integrate from you guys from you from
your world to ours and I'm gonna go home
and get this going
right now actually I'm gonna start a
long email walk out before the party
starts right so that's how I see things
happening I think rocketing closer could
really merge over time merge in and the
conceptual sense not in a concrete sense
and every wonderful to see IM that
corner class this is my webpage
yes great question right fantastic
question
it turns out I was in business school
when I when I came to this country and
moved over to computer science because
Business School is so boring and the
first thing I took was a class there was
was ten kids eight girls and two boys it
was wonderful
but there was a boy he was about testing
okay back then he was computer science
was a female-dominated undergraduate
major not a male 1 what the first class
was interesting and it's a basic theorem
you cannot test all possible paths
period that was a question can't be just
test enough and the answer is no types
mean I prove for all your data set is
infinite even your streams are infinite
it's like one little value in the
infinite world is infant right this is
big infinite it's infinite of infinite
you can't test that that's what types
come in they prove it once and for all
more questions back there I couldn't
quite hear the last part
oh you mean I'm sorry another closure
man I'm a Rocketeer ok that's what
contracts are ok sorry I got it I didn't
hear the word and I just clicked to me
in 98 I realized that I could get away
with what's called contract or
assertions that's what I thought so and
I kind of knew I would need it
eventually so I built this contract
library of course and then I realized
higher order values like lazy streams
or first-class functions or objects they
mess you up let's just mess you up
because then when something bad happens
we don't even on the stack anymore okay
so that's why we spend five years
exploring the proxy wrappers to get that
right both in theory and in practice
okay and then we realized oh program has
used them all the time cool but you're
going to use them for they thought they
were writing down types but there aren't
types there are no types in two senses
types are free when they are checked
they have no runtime cost and they
actually improve your runtime I didn't
want to talk about this but types
actually helped so when we run type
racket fully type converted code it runs
at 70 percent of the runtime and we
haven't even started yet on type
optimizations okay contract are not free
at all higher order contracts allocate
and as an old Lisp assess when you have
performance problems count all the
conscious and all the lambdas in your
code or funds whatever you call them
okay
because allocation is evil so contracts
in that world allocate is evil they have
a penetration cost it's evil
we just don't know how to cope so
contact a good for a little bit of
checking and for expressing very
complicated thoughts that we don't know
how to write our own types and I write
those contracts a lot okay but in in
this in the sense of replacing types not
at all next question
oh yes I understand if you promise not
to tweet anything I will tell you the
truth if there's anybody here who has a
phone then I will not say what I think
okay good
in that case so where's academic
research going where it's going is type
systems that are far more powerful than
anything you have seen here we can write
down far more interesting predictions
now than you could in the past as a
result you can use types these kind of
types to prove the correctness of a C
compiler as anybody here for a concert
okay that's a project that came out of
Excel really was a research lab at India
and France and they proved the first C
compiler correct what the French have
had a have long history of putting code
that is written in very high-level
language very functional or time or any
languages into the air bus okay that's
an airplane it flies around like this
you know so so then they want to know
where that really works so chris'll has
the Cousteau family has verified for
example that no floating-point
calculations on the Airbus can ever go
wrong they use a type like system to
analyze the bits into which they are
compiled so they can't Rick they cannot
analyze the types at the source level
because they don't know what will
compile that's the right thing
so they analyze the bit level outcome of
the compilation process obviously what
you want is you want a compiler for
embedded systems
that has a hundred percent defined
behavior and that's what they did so
that type system can write down such
tight thoughts about what a compiler
does that you can eventually run this
type checking thingy it's a very
complicated typing Feeny and it says
this compiler is correct and it will
always do what I wrote down there on
that page and nothing else that's
amazing
but the over here I give you so at the
moment DARPA is running a project where
they're putting the same kind of things
in the drones and and mind clearing
robots some of my academic colleagues do
that and they are able to do similar
things okay I'll give you a rough idea
of what it means when you write one line
of code you write 70 lines of types okay
do you understand why I prefer to write
untyped code okay but don't treat that
any more questions now it's you standing
between the party and us right here yes
yes that's me I call myself a radical
centrist in politics too therefore the
too few of us right and what I mean by
that is you don't want to go to extreme
europÃ©enne Adi lager says untyped is
the best thing ever and you don't want
to say running 70 lines of code I'll
ever send other types per line of code
it's heaven
it isn't okay for the ordinary program
on the street you want to find just the
right balance that's been my goal for my
research career no one's gonna do that
for the rest of my life
so the question is should we change the
standard library to accommodate the type
system if you design a programming
language from scratch and you're happy
with three users that's a great way to
go but I'm dealing one of the things
that there's an academic I actually
tried to look into the real world and
say what are the problems that are
facing they wrote an enormous amount of
Untied code Oh easy I'm just like like
Bob for example I'm gonna tell them
throw your code away and revise an ml or
Haskell I'm sorry it doesn't work that
way
so changing the state so in my mind
there are two parts of language that you
don't change well you change it but you
change them carefully and gradually and
very slowly and that's the core language
and a standard library okay you don't
you pull out the rock underneath some
programmers because they use to the
names to the behavior to things in
racket land we go to extremes to remain
backward compatible and we sometimes
preserve errors to be backwards
compatible it sounds odd and I openly do
that I always get into an argument with
my colleagues but they're right okay
more questions over there
yes so I gave up on inference actually
around 95 by reading a very influential
paper that never saw the day of light
is anybody here Emma's deck Cirque
research lab in California okay
so the technical report it's buried is
so Dec was bought by I think Compaq
which you probably don't remember either
and then it was and then it was bought
by HP which you probably won't remember
next year how are they uh and so that
they have this incredibly famous we just
like that has a humongous amount of
great stuff so Chawla was really
inspired by modular three from that lab
so take the port called type full
programming by Luca cut deli and what
are your rights there is really it's
about types what you want to do is you
want to move the ID into the IDE the
type in France er but it fails program
matures right sometimes okay here's
another example that we want and we have
already built we have a tool that tells
you which contract boundary which
boundary between tie plant and untie
plant is the expensive one so we can
inject measurement probes and measure
the cost of a feature right most most
profilers measure the cost of lines or
maybe functions we measure the cost of
proxy values of course the lots of proxy
values never tell you that proxy value
generated there consumes 80% of the time
and we find that
here's another tool so in addition to
helping you infer the types that you
have written down because you're dealing
with a module you might want to have
help in constructing interfaces that are
more suitable for the rest of the code
or you can have a tool that takes your
test suite and runs at a speed and such
as code to you some of you may know
diamond ruby or d ruby comes out of
Maryland it's a very poor
high-pitched Ruby version but they
already can do that so we're not trying
to integrate this into our world so if a
tool in the IDE that can help you make
this type very quickly so there's lots
of room lots of room for building for
building tools that help you with that
task yes we wrote the paper that says I
will contact a bat so the question the
question was do I know eiffel of course
I know eiffel - is limited originated
contracts in the O&amp;amp;O land and what they
did there is it turns out they forgot
about inheritance I don't know how you
can do that in an old world but they
forgot about inheritance and so
contracts at the time when I started
exploring contracts for for racket I
actually start with eiffel and the first
thing we did is we ran the program with
an inherit little class chain and it ran
to completion
42 but we had actually baked in a buck I
wanted to see how the contract system
reports the buck look that was odd 42 so
we we wrote a paper on how Eiffel failed
eiffel source level contracts fail the
intuition of the programmer and there
and there and they fixed some of that in
the meantime but it's still not right so
I give you a room for one more question
and that's the that's the pride that's
it that's this thing what you get for it
okay there's about one way back there
you were first
that's an amazingly cool question
Kennedy am deal with types that are high
level and by high level you can mean two
things one of them could be high level
in sense of you know very nested type
structure arrows another one could be
these dependent types dimension before
and yes people will work on that how far
that goes I don't know but if you think
about a dependent type we can say
something about here's a value coming in
and the result type is shaped by the
runtime value right a chip could exploit
that and specialize the body for this
range of values that we find good and we
already do that now but inferring at
runtime what's still going on but with
dependent types we can do it with
upfront compilation already and don't
have to wait for the warm-up to do that
so there's clearly opportunity for doing
these things there's opportunity for
using contracts to push the contract
assertions through a method or a
function and improve that one-time cost
actually in the compiler in the compiler
supposed to the VM so there's lots of
room for that performance improvement I
won't be able to do it all if you want
to be a PhD student you just google my
first name and on the first page send me
an email</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>