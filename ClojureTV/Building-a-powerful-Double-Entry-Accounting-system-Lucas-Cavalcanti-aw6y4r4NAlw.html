<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building a powerful Double Entry Accounting system - Lucas Cavalcanti | Coder Coacher - Coaching Coders</title><meta content="Building a powerful Double Entry Accounting system - Lucas Cavalcanti - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building a powerful Double Entry Accounting system - Lucas Cavalcanti</b></h2><h5 class="post__date">2016-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aw6y4r4NAlw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody thank you for being here
I'm Lucas and I'm here to talk to tell
you how how we build a powerful
double-entry accounting system using
using closure and all the tools we have
and first of all double-entry accounting
is an ancient technology it's being used
by decades by changers even so it's not
a new thing it's a thing that pretty
much every company needs to deal with
and I try to find a Google an image a
funny image to put it here but counting
is no fun it's like only numbers
spreadsheets and like and you know what
to do so but in the context of
functional programming accounts
accounting is a really good deal so
first of all some context I work at new
bank that's FinTech based in Brazil we
have a credit card product so a credit
card product where when the user can
manage its purchases its bills and the
whole financials about this credit card
on a mobile app that they can stall and
the whole usability around it and as we
are a pin tag we aren't we deal with
people's money
okay so dealing with other people's
money that makes you a little bit scared
and you make you need to make things
right and the first thing is how do we
represent this money well one way to
represent is by looking at user balances
for example how how much money the user
have available for
chose to spend on the credit card how
much is the latest close bill we have
for this user so the user had needs to
pay me a thousand he eyes for example
how much is the next view that the user
will pay or how much is the future bills
that we have those balances that the
user cares about we could only store
those balances but then we only can
insert that question or how much is the
balances we can also begin to store the
operations we have on this credit card
for example each purchase we have each
charge back from those purchase each
payment the user makes so we store all
the operations that are basically
positive and negative amounts for
example and with that we can calculate
all those balances ok so we can go that
way and store all the those operations
but still it we can we can calculate all
the balances but we can't answer all of
our possible questions with just that we
also have a view that's business only
view that's the company only view that's
the balance sheet of that customer of of
the company so these are these are
accounting accounts so book accounts
that shows each of the amounts the user
owes us for anything so we can tell how
how much money the user already gave to
us as profit for example how much
interest the user paid to us or how much
interchange we got from purchases and we
can tell how many money with how much
money we we need to pay the merchants
for example the purple side of there
and we have the assets on the the left
side we can tell like how much the user
will pay us or how much the user already
pay us looking at those balances and
these allows us to ensure transfer much
more questions than just looking
operations or just looking at balances
the user balances and to to get to that
point we need to take a look at some
abstractions that double-entry
accounting gets to us give to us
first of all the double-entry accounting
works by having each movement having a
set of debits and credits on those
balance sheet accounts and we get those
those depths and credits and pass it
through a ledger that allows us to
compute a lot of things such as income
income statements cash flow statements
and balance sheet sheets we will focus
on this balance sheet operation that
looks a little bit like this so we have
assets on one side and liabilities and
equity on the other side and the
property is that both those two sides
are equal there are the same amount
which means that on each movement we
make on a double entry accounting system
and the sum of credits is equal to the
sum of that it this is a property and
it's being done this way like for
centuries for decades and for example
how do how does that work if I have a
purchase of a hundred dollars I will
debit hundred dollars on the asset
settled
that's something the user will pay me
eventually okay and I can credit nine
seven dollars that I will pay the
merchant on the
payables liability side and the other
$3.00 is my interchange is the profit I
get for that specific transaction for
example and it's not just that I also
need to take hundred reais out of the
user limit so the user already used that
one hundred years hundred dollars sorry
and and I do that by debiting the
liability clearing to limit and the
asset courage limit they are those are
off balance accounts that we use just to
keep track of the limits in this case so
we we have one account on each side and
we always move the same amount on both
of them okay
you can do the same for a payment for
example so a payment is basically
debating the cash account on asset side
and crediting this settle account for
example so we use those hundred dollars
to pay the purchase the user made okay
and since I made a payment I need to
restore the limit so I do a credit and
debit on the current limit accounts to
increase them okay and this is basically
how double in three words there's there
are much more things that there is for
the bow into accounts but these are the
main things and if you take a look
double double in three account is
basically some event like a new payment
arrived or a new purchase was made or we
we accrued some interest for the user
okay some events that triggers
accounting movements you know it's also
immutable its append-only so each day we
have some movements and we cannot change
the movements from yesterday for example
we can
then say the movements from yesterday by
debiting and I'm out the old amount
crediting the new amounts and so on but
it's append-only we can only change
balances for today create movements for
today the next day it's another day it's
immutable in that sense and it has
invariance so some of the if you if you
take a look at credit cells being
negative and debits being positive if we
sum all the entries it's so sum to zero
all the time and if I need to get a
balance for any book account it's just a
matter of summing all the credits and
abs for that book account we can get the
balance and I'm not talking about
programming here I'm talking only about
double entry accounting those those
things seems familiar to you it's like
they're those properties they are
basically functional programming
properties so double entry accounts
thing is a perfect fit for functional
programming so in this case we use
closure for that the way that movements
are stored in an accounting system we're
not in accounting books our append-only
entry logs this also reminds us of
something like diatomic for example it's
pretty much the way the atomic works
another perfect fit for this domain and
it's even basic which means that we can
use something like Kafka that's an even
based message queue to manage all the
movements so again we have a financial
domain double entry accounting domain
that's a perfect fit for functional
programming the atomic Kafka message
queue in system so that's a better
that's the those are the best
we can use to build it and this is how
we've built it using the atomic and
closure and Kafka first of all a
movement is composed of any amount of
entries okay and this is how we model
the the entry we use Blue Magic schemas
in this case we didn't have specs back
then so we still uses schemas and but
they are similar so we have an entry
that has an ID a positive amount always
okay and I credit and debit accounts
there there are one of those balance
sheet accounts and we have a in that
entry is of a post date so this is the
date that entry actually occurred in
this entries from a movement and
modeling it this way by design the sum
of credits is equal to sum of debit
because because we don't have separate
entries we have just one entry that
specifies the debit and credit accounts
okay and we also have that one business
event for example new purchase a new
payment a new bill closing generates
exactly one movement with with its meta
data associated so here we have the ID
of the movement the flow ID that's
basically I need a unique in date fire
for that event so we don't save the same
event twice on the database we have the
topic that's the name of the event or
the name of the Kafka topic that
generate that event the owner account
that's the customer account that owns
that movement the produced that and
consumed that that are metadata about
the message consumption so the date and
time
which the message was produced at the
origin and the date it was consumed it
on the double-entry system and when that
applies the user that triggered that
event okay so we have this meta
information about the movement and also
the Matt information about the entity
that generated that movement for example
the matter the the new payment needs to
have a payment associated with it the
new purchase needs to have a purchase
that associated with it so we can keep
track of that and those entities are
entities from any other service of no
Bank so the wine entry is one on one one
service that receives events from all
other services and stores it in this way
and we also need to declare the to to
write the rules for each of these events
and we do this by first first of all
getting the wire schema for from those
events and in this case the purchase
the wire if a schema for the purchase is
this Nestor
purchase with ID immersion that's a
string an amount that's positive and an
interchange that's also positive and
that time that purchase occurred we
don't use namespaces here on the wire
schema because we use JSON to serialize
peer to peer so the Kafka message only
contained JSON so nesting fits more than
namespacing in this case and for payment
we have a payment with an ID an amount
that that's also always false positive
and a post date that's a date the date
that the payment was made and giving
giving those schemas we can declare
rules
by creating this vector here that
declares what is each entry for that
movement for example for a new purchase
it will debit Seto Brazil credit payable
Brazil meaning that's the National
purchase in our case and the way we get
the amounts is looking at the purchase
amount of the Kafka message getting that
post date is the purchase time converted
to a date okay
and the way we get the interchange we we
take the interchange from the payable
Brazil just added and put it into the
interchange Brazil so we took those
three dollars from payable Brazil to
interchange Brazil and do we get it from
the interchange of the purchase and the
time is the same and I also need to
decrease the limit so I debit the
current limit counterparty account and
credit the current limit account so I
get the amount is the purchase amount
and the time is the same time of the
other entries you can do the same for
payments so a payment we debit a
transitory bank account that's the cash
account and we credit this cerebral zoo
account so we would in this case pay the
Seto Brazil that we had from the
previous purchase and they did and the
way we get the entry amount for that
movement is getting the payment amount
and the post date is the payment post
date we have on the message okay same
thing for current limit except for this
way we are increasing the user limits
okay and getting a real message so I
have here a purchase of hundred dollars
and three dollars interchange
and today and getting that that
purchased through the Drew book that's
Brooke book of the rules of all the
possible movements we have on this
system it will generate the first entry
that's the $100 from Sara Brazil two
payable Brazil at today and the second
entry will be the interchange entry that
moves three dollars from payable Brazil
to interchange Brazil also today and the
latest entry would be the hundred
dollars from current limit to current
limit that's to decrease the limit from
the user and get getting a new payment
would be quite similar we experience for
$400 we'll get some take some money out
of cero Brazil and putting into
transitory bank or the opposite the the
money that we get from the user we
increase transitory bank thinking out of
cero Brazil also as of today and
increasing the limit by getting both
parties here and what we build having
those entries and movements storing in
storage in the atomic we have two logs
two timelines we can look at we have the
actual time that's the diatomic time the
the time we didn't know when those
events happened on the double entry
accounting system that's that happens by
looking at the atomic transaction on
time for example and we have the system
of record time that's when those events
actually happened we have some
characteristics for example payments we
only acknowledge payments two days later
or three days later and the date
we need to add on the double-entry
system is the date that the user made
the payment not the date we acknowledge
the payment so we have those two two
timelines so you can have a movement
movements on the date 30 they're the
change day 15 and they 17 for example
and we have another movement on day 90
that changes also the date feed 15 and
the day date 60 for example but we
gained for that is that we can know for
sure how was the balance sheet for that
user yesterday or a month ago because we
can cut by the the atomic transaction
time so we filter the atomic by a given
time and we look at the balance sheet
sheet at that time and we can compute
the balances daily of the bounce daily
using the post dates of the entries Y we
can compute the balance by just summing
all their entries as the database grows
it becomes impractical to do this every
single time so we also build a cache
around it so we cache those balances so
so we can compute at least the recent
balances in a better way in a faster way
than we did before the point three
accounting has some invariants but our
business also have some invariants so we
can state that for example there are
certain accounts that should always be
positive or should always be negative
their balances should always be positive
or always be negative for example profit
accounts are always positive loss
accounts are always negative and we can
check that
other thing that doesn't make much sense
for us is the user cannot have a late
balance or that means that he has adapt
with us and a prepaid balance that means
that it that he paid more than it should
so this doesn't make sense this prepaid
balance should have paid the bat the
debt so we can state that and do this
fix so in this case if we verify that
this happened we use the prepaid amount
to pay the late amount so simple as that
and these are balanced invariants but we
can have also movement invariants for
example the new purchase movement event
should move exactly the purchase amount
doesn't mean it doesn't make much sense
for a purchase movement of a hundred to
move it $300 from one account to another
so you can also check this this before
saving anything to database and how how
do we check those invariants we use
generative testing okay why do we use
generative testing because we have 20
possible events that can happen then on
any order at any time from any post date
so the possibilities here are huge and
we can we can't possibly think of all
the possibilities so we let generative
testing do it for us in our case we we
use the schema generators that is a
project that takes up AI schema and
generates the generator for that schema
so we can do a property like I need an
account and a vector of events that can
be a pert a new purchase a new payment a
new view of whatever and I tried from an
end to database say to save all
those events take the DB the resulting
to be of those those transactions and
check that the balances are all positive
for example so we can check each one of
the invariance by using this we just
need to set up the right generators okay
in this case the the right generators
are not necessarily all random okay
because for example a purchase can only
be cancelled
after there was a purchase in the first
place I cannot cancel purchase that did
not get to the the double entry system
before so we can get as sophisticated as
we want to on those events we could do
something like generating a state
machine that of possible events and
feeding it to this and we can check all
those invariants by writing generative
testing and Tremp if I let's take a look
at how a single customer event string
looks like the first thing that happens
is we show a card for that customer so
that movement basically assigns limits
for those for further customer in this
event again is a Kafka message it
appointed by the Dodd flow AG each event
we will apply the rule book and create a
movement with any amount of entry
entries and as those movements balance
by design because each entry balances by
design and we associated we associate
metadata from that movements with the
message topic that generated that
movement the user the correlation ID or
anything like that and we we P check
most invariants before saving it into
the database so we certainly don't want
to say save bad data into the
double-entry system of record of our
system and we cash the balance the
resulting balances at that time so we
can query it afterwards
continuing the the event string the user
make makes the first purchase it takes
some money out of the limit and puts
into the set of Brazil and the payable
Brazil accounts then we close the first
bill that moves that cero accounting to
the closed account that means that the
user needs to pay that the data amount
right now if the user makes a partial
payment then we get some cash out of it
but that close amout becomes a late
amount so now the user has adapt with us
we didn't paid his full debt since he
did that we can accrue some interest so
we charge it seven dollars interest
because he didn't pay it info and then
we get a small green part there that's
not our profit right now and when the
user pays the whole bill now we have the
the limit restored and we have some cash
account the transitory bank account with
the money the user paid us we still have
to pay some money to the merchants
eventually so the payable account is
still there and we already have the
interest account that small green part
down there that's our profit for that
account and to grasp the power this
amount of detail this amount of
granularity give us
you a quick video this big square is the
sum across all the accounts of the
system okay how it behaves the mid row
is basically occurred by due date the
day the user needs to pay us to pay the
bill so the due date five that do they
tend at do day 15 and they do it with
8:20
they behave kind of similar but the that
time is just like a wave it's supposed
to behave like that the top row are
individual customers so we can look at
the behavior of each single customer of
our system and the the bottom row is the
cohort cut so we take all the users that
were created in January all the users
that were created on March all the users
that were created on June and we can get
the behavior based on the aging of that
customer and this behavior is supposed
to be almost the same for the same
period that the customer is our customer
okay so we can detect anomalies on that
so the cohort from August is behaving
too different than the January cohorts
that means that's something changed and
we can take a look of what change it and
we can do that that analysis by any any
restriction we want we can do that
analysis by cohort by demographics by
Geographics by by age by anything we
like to and we can get the behavior for
the user I did like a simple
visualization here but imagine a machine
learning model taking a lot of those
data that data and trying to predict how
much the user will spend over the next
year taking out
the users that are look like the looks I
like that customer so it's a huge power
that we can get by building that kind of
the Boeing 3 accounting system so how
can you use that debt system as most
companies they still care about the
aggregates overall the customers so we
can generate the aggregates and input it
to an ERP software for example we can
use that data to report the government
for example to report some partners it's
easy to to get that query and we can use
it for manage our own business
so we can build delinquency tables by
cohort by age by by anything we can at
any point in time know how much money we
were to receive in the future for from
all the customers for example we can get
the revenue per customer or across a
group of customers it's easy to do that
query and the most important thing is we
can detect operational mistakes by just
looking at the balance sheet of a
customer if some account gold went
negative for some reason it's definitely
an operational mistake
if everything went the way it should all
boss will be positive if something is
negative something wrong happened either
somebody made a Bennett made a an
adjustment that is bigger than it should
or a system had a bug that generated
much more interest than it should we can
detect that by only looking at the
balance sheet and the things we most
liked for for this double-entry system
are the declarative rules it's very easy
to add a new movement to declare how a
new move
it looks like we just declare how we
built each entry based on a Kafka
message it's very easy to do that
and we can extend for other products not
just the credit card product we can
create another set of book accounts and
another set of movements with the same
row book code and create a rewards
balance sheet for example our debt
financing balance sheet financial
analysis can occur at any level we want
at any journal editor level we want so
we can take a look at each customer each
group is anything we want to we can
check business invariants before saving
data to the database and after saving
data to the database so we can detect
wrong states or impossible stage and
investigate what went wrong generative
testing finds real bugs the first time
the first generative test we wrote we
spend the next three days fine just
fixing bugs it found it was amazing that
we couldn't open a pull request because
we spent three days like just fixing
bugs because it will think of all the
possibilities you couldn't possibly
think because they are basically too
many you can't do that by yourself and
the last thing here is that serve this
service is easily sharable as we don't
have customer to customer interaction we
can simply get two groups of customers
and give each one of them a database and
we will be fine it works as it had you
would work for just one database and as
this system is append-only we can also
chart by time easily we just stopped
stop writing to the old database and
start writing to the new
database and we are fine if we get the
properties of summing all the movements
gets me the balances or something all
the interest gets made the balances it's
fine for charging the the database by
time it's very easy to do that and for
querying we can query only the most
recent chart or an old chart plus the
the new chart based on the date we are
acquiring if all the dates are only on
the new database we can do just that
the main takeaway for this this the
stock is if you're building a system
where you're interested with the
customer financials you should
definitely be build a double entry
system for that that product but that
system you're building for and if you
choose to do so
you should probably use functional
programming to do it because it's the
perfect fit for it imagine building
invariants and all that this thing in
Java or something like that it's
certainly possible but functional
programming is much or closure is much a
much better fit than an object-oriented
solution or imperative solution because
it has the same properties and that's it
thank you very much for listening and
I'm open to questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>