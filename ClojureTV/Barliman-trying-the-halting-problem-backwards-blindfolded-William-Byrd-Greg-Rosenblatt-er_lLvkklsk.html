<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Barliman: trying the halting problem backwards, blindfolded - William Byrd, Greg Rosenblatt | Coder Coacher - Coaching Coders</title><meta content="Barliman: trying the halting problem backwards, blindfolded - William Byrd, Greg Rosenblatt - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Barliman: trying the halting problem backwards, blindfolded - William Byrd, Greg Rosenblatt</b></h2><h5 class="post__date">2016-12-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/er_lLvkklsk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's great to be here again I think dan
Friedman and I spoke at an unsession at
the con five years ago and since then
the closure community has been by far
the most supportive group of the work
we've been doing and I think it's
accurate to say that what you're about
to see wouldn't exist if it weren't for
the closure community and folks like
David Nolan has worked on CoreLogic
really gave us a big boost and stew
Holloway's infamous question about
flying generation has basically driven
my research for the last four years so
I'm you know seriously thank you I think
this is an amazing community and I found
it super inspirational when there have
been times where academia hasn't always
been as supportive as you know now
giving me a you know part of the jobs
for rocks it's things and they're pretty
good at it but you know the closure
community's enthusiasm is really what's
driven this so so what we're gonna where
you're gonna see wouldn't exist if it
weren't for you also thank you
so introducing barliman 4.3 and inspired
by Rich's talk we've decided to go with
an immutable versioning scheme so at all
times in the future this will be 4.3
I think that was the takeaway if I
understood it yeah you got it right I
said what we're gonna try to show you is
is sort of what Dan and I were we're
trying to to show off five five years
ago part of the vision and we've gotten
better and we've hidden a lot of the
details that you may have seen if you've
seen some of the previous talks so you
can forget for a minute at least how
this is working under the hood if you
know how it might work you know kind of
erase that from your mind let's just
think for a minute what an interactive
development environment might look like
or what capabilities it might have in
the future you know so think about what
your ideas can do today and we're gonna
try to give you a little bit of a teaser
of of how we think an IDE might work in
the future and hopefully not far future
for now and we're not going to show you
everything that we think an IV you
should have what we're gonna show you a
couple things that we think are
interesting and what I'm gonna ask you
to I'm gonna ask your indulgence and ask
you to look at this as very much a
prototype this is this is an idea talk
we're trying to show you some things
that might be possible in in either than
the midterm future or hopefully some of
these things I think will be available
in the near term future like within two
years some things maybe within like six
months and it's also very much an appeal
to you if you find this interesting we
could use your help we could use your
help I would love to have a version of
this enclosure using core logic and
there's a whole bunch of tasks in terms
of interface design interaction design I
think a really interesting language
design all sorts of implementation
details really interesting work I think
so this appeals to you at all please let
us know all right
so without further ado Greg is going to
define concatenate okay this is all on
scheme we've tried to use closure names
to confuse me but well we'll see how
that goes but we're gonna define
concatenate so Greg please define
concatenate in the most natural way all
right
I'm done okay how much a it is
concatenate of course all right and you
can see that barliman took a guess at
filling in whatever comma a mean so the
a is a meta variable it represents an
unknown expression and down below in the
best guess window you can see that we
get clearly the definition of
concatenate now we might want to try a
test yeah let's try it tests for
concatenate make sure this is the cat
cat me we actually want right so like a
diligent programmer I will test my code
before I inflicted upon other people so
we'll start with a simple test case and
cat on two empty lists should give us at
the empty list okay so now barliman is
saying that it thinks this function is
called can cat
in scheme li notation it's saying that
it can take any number of arguments as a
very attic function and it always
returns the empty list okay so so far
that passes our tests great perhaps we
should add another test before we ship
it
so we'll concatenate a 1 in list
containing 2 and we should get those
containing 1 &amp;amp; 2
okay so barliman has synthesized a more
sophisticated program now barliman
believes that the function probably
takes two arguments and it's doing a
null check on the second argument and at
which case that we return the empty
lists otherwise it returns what's
clearly the answers are based on the
test which is a list 1 to Parliament is
very lazy it finds the path of least
resistance to satisfy your examples so
it's like Marlon's view has proved me
wrong so we have a technique for getting
around this which is to use specially
generated symbols that are Parliament is
not allowed to write into the definition
let's let's generalize over our inputs
of 1 &amp;amp; 2 and try to make a little more
generic so these are essentially
Jensen's or lexically scoped Jensen's is
G 1 G 2 things I'm saying we don't
actually care what the data is that
should be unimportant in the function
that you're you're trying to generate
for us so we have a good result
yeah so now you can see can cat is no
longer specializing over inputs 1 &amp;amp; 2
and instead it's gonna have to use cons
and car okay so car 2 people in the
closure world that's how you take apart
part of a pair in scheme we don't have
all the fancy pattern matching although
barliman actually does support pattern
matching okay now is there anything
missing with this definition what's
missing with that definition of a king
cat would you be happy with this
definition can cat I see heads shaking
so know what what's wrong with it
and list with something else also it's
the empty listen listen saying well you
know so basically what we're missing is
recursion right we don't have a case
that will allow us to to do this with a
list of arbitrary lengths when the first
list is arbitrarily long so time for
another test
all right so barliman will think for a
minute help us make this faster yes okay
now we have another definition so
barliman now thinks that this should be
a recursive definition and we have these
weird-looking variable names underscore
one underscore zero and those are
abstract variable names the idea here is
that we don't actually have to know what
names they are we can accentuate those
to any legal scheme identifiers yeah I
can clean those up though so I'll do
that now just to make it slightly easier
to read so Greg's putting in another
variable here underscore a and the idea
of this underscore a are centers a comma
a the comma a is a hole okay so we have
a hole in our program we have a
partially specified program by the
programmer in the definitions window but
it has a hole in it represented by this
meta variable comma a and now you can
see because he instantiated the
variables that we can see the actual
variable names in the definition and
furthermore you may have noticed that
the synthesis was faster and the reason
is faster is that now barliman knows for
sure that this is a function that takes
two arguments and actually knows the
concrete names which and our current
version speeds up a little bit if you
look at the test you can see that we
could do better because we should be
able to take a reasonable guess that
this is a function that takes two
arguments right now barliman doesn't
really know it's not using that
information and one thing that we'd like
to do is have a version of barliman that
has a back-end that can run in parallel
you know getting an ec2 instance get 10
of them if you want you know run a
thousand threads or something like that
with different barliman searches running
in parallel with different heuristics
with the idea that maybe you'll get
lucky and if you get lucky because this
is inherently an exponential problem if
you get lucky you get really lucky it's
way faster so you know using heuristics
is something that would be good here
okay so I'll show you another neat thing
we can do so in a more realistic setting
you wouldn't be defining something like
in a vacuum you would often have access
to some kind of standard library so to
sort of simulate that I'm going to paste
in a definition of what we call reduce
right you can think of this as a reduce
that goes right to left rather than the
standard left to right and you'll notice
that almost I I didn't even notice that
it did it it synthesized as a result for
for concat in terms of reviews right
down here so another thing that we can
do is if you were to be given this
definition of concat in terms of reduce
right but you didn't happen to have a
definition sorry the definition of
Concannon terms of reviews right but you
didn't have the definition of reduce
right you could actually use this
definition of concat to synthesize
reduce right we won't show that now
because it'll take a little bit of time
and and involve some monkey work so
let's move on to something so we need so
some part of the problem is we have a
lot more capabilities than we're
exposing currently so this is sort of a
UI challenge and just sort of an
implementation challenge so that little
scroll bar thingy I implemented that at
4:30 I don't know 3:30 this morning so
we're still still working on this so
we'll go for another seemingly simple
definition will try to reversal this now
so reversing the empty list of course
gives us the empty list reversing a list
of size 1 gives us that same list very
interesting and barliman seems to be
handling this just fine so far
now we will try to reverse the first
interesting list and will notice that
barliman is having some trouble I'll
give you a spoiler it's it's never come
back for me
I've sat and watched for a long long
time but you can try it at home yes so
there's an unfortunate wrinkle with the
definition of reverse barliman seems to
prefer to define things in a naturally
recursive way very directly but if
you've tried to define reverse for
yourself before you might know that
there are some some issues with that
I'll show you what I believe is pretty
close to what barliman is trying to
synthesize here which is reverse in
terms of concat now if you've studied
this definition of reverse before you'll
know that it is it's time complexity is
quadratic in the length of the list
because each of these iterations does a
kink at on a list of length n minus 1
then n minus 2 and so on so you add all
those together and you get something
quadratic so unfortunately the way that
barliman is currently implemented the
computational expense of a particular
solution impacts how far down the search
tree it will find it so it's actually
much harder for it to find a definition
like this than one that would be linear
time for instance so one thing to wonder
is let's say here you're defining
reverse will go back to this template
and you're sitting here it's taking
forever and you wonder what's going on
maybe it's at a bad a bad mode and it
can't find a solution without your help
one thing you can one possibility is one
way to speed up recursive definitions is
you can sometimes pass an accumulator
and thereby avoid constructing and
deconstructing the same representation
over and over
you're just passing a state to the next
iteration so let's let's based on the
hypothesis I just shared let's
hypothesize that there is some reverse
AK which takes some accumulator and we
don't really care what it does with it
and we'll just define our reverse in
terms of that and see what happens
we'll assume we can pass a an empty list
as the accumulator and pretty quickly
barliman comes back with an answer so
the idea of barliman is that program
synthesis is hard recursive program
since this is especially hard especially
without Daniel or static typing and
things like that so you know we're
playing in hard mode although we do have
one great advantage and this is an
advantage that closure has is that we
have pure functions we believe in the
mutability and things like that so if
you're dealing with pure functions it
makes it much easier and I'd rather
actually have the pure functions than
have types and have mutation in terms of
the synthesis for sure but because this
is a difficult problem that's inherently
exponential the idea of barliman is we
want to experiment with something
interactive when we have the programmer
in the loop and the programmer can just
use this as an IDE here we're trying to
so show synthesis examples by example we
write the tests and then you get the
program but that's not really how we
envision most people using Berlin and
it'd be more like you're writing your
program and if you followed practices of
test-driven development or whatever you
have generated tests you can have a
bunch of tests and the tests can help
you so one thing they can do to help you
is try to synthesize missing parts of
your program and it so maybe it's the
case that it's too slow to synthesize
most your program but maybe you can give
it a little bit of help like that or
maybe you can write 90% of the code and
it fills in the last 10% so think of it
as sort of like maybe an autocomplete
that has that understands the meaning of
your program and not just things like
the types or the grammar so sort of a
semantic autocomplete
that's one one use case we have we got
some other use cases we're going to show
you as well but that's one of the ways I
can think of it and so one of the
questions we have with Parliament is
we're trying to answer with Parliament
is well you know how well does this have
to work in practice to be useful to be
worth you know using this sort of IDE if
you could get all the complete for the
last ten percent of your program would
that be sufficient you know how and how
well can we scale this so I'm gonna just
show them one more neat thing you can do
so now that we have a definition of
reverse axe let's just for fun we'll
synthesize the driver using it so we'll
replace this with what we just
synthesized and you can see we can also
go in reverse and synthesize the driver
using it so just a neat thing so let's
show a slightly different example so
suppose you have some data you'd like to
transform you have a list of them may be
nested structures of some kinds you
might use map to do this
so suppose we are we have this nested
structure that looks something like this
so we have three elements that the
second one happens to be a nested list
with two more elements and let's just
say we're interested in for each of
these nested structures we're interested
in grabbing the first item of the second
item so in this case it would be B and
in this case it would be two so often
you pass some something like a lambda or
a predefined riskalyze function to map
in order to do the transformation here
we'll suppose that we're going to
synthesize some kind of lambda and we're
interested in seeing what the body of
that should be so we'll say that this
should be equal to B into as I explained
before and barliman figures out that the
lambda should look like this so it picks
apart the the refer to the nested
structure in exactly the way that we
were hoping it would all right let's
look at another one let's do remove foo
okay here's a simple recursive
definition in the spirit of the little
schemer and roof who's gonna do is gonna
take a list potentially nested list
deeply nested list and it's going to
remove all of occurrences of the symbol
foo from that list and give you back a
list with removed so okay a few tests
here for remove foo hopefully it's
pretty clear what remove foo should do
and it turns out that remove who is not
something that we can currently
synthesize hopefully
do it in the future but this is also
saying we're generative tests might help
but we're gonna show somewhat different
use case say you have a definition and
this is more realistic I think so you
have a definition you're not going to be
able synthesize directly from a
specification or from tasks or from
properties or whatever or from types if
we know we could add type inference to
barliman and use that for synthesis as
well we could add all these things but
in practice you're probably going to
have to write most of it as a programmer
and so what Gregg is doing right now is
he's pretending to be sort of a
structured editor and he's trying to
keep legal s-expressions at all time and
he's adding these meta variables to keep
the structure correct and so he's just
going ahead and adding the base case for
remove foo and you could see the dot a
at the bottom that's saying whoo that's
some unknown number of additional con
clauses zero or more so we're we're
saying that you know this this program
could have arbitrarily large number of
con classes could have a million of them
or whatever and so he's written a
certain amount of structure now and so
he's got cons BC so we have three
different holes in this program right
now we've got the B C and a and the
interesting thing here is that even
though we will only partially specified
this program we can fail a test so the
second test fails and what that's
telling us is that there are no
expressions in our subset of scheme for
which filling in BC and a would actually
make that test to pass so the idea is we
can do test-driven development on
partially specified programs and I think
once we add the capability to doing
generative testing to this it will be
way more powerful and and this is
something that I think we could make
practical a relatively relatively near
future and I think that would be a
pretty cool capability for IDE is the
ability to do this and I think closure
would actually be a particularly good
language for this especially with things
like core spec so what I really like to
get to the point where we can have core
spec style properties that you would
specify and you'd be able to
run contracts on partially specified
programs and things like that I think
that would be a very powerful way to do
development and my hypothesis is if you
had those sort of rich properties that
you wrote first you would be able to
keep yourself from going down dead ends
many times early this is still a
hypothesis we don't know and practice
how well this will work because we're
still developing the tool the point
where where we can do these sorts of
things but I think it would be helpful
all right now let's let's let's have
some fun these have been kind of
straightforward and boring so far we're
going to play with a little evaluator
written in scheme or scheme it's due
here no all right this is this is a
Stu's fault this example so we have a
very simple definition of eval it can
construct some literal data it has it
can make first-class functions reference
variables build pairs and apply
functions so not much do it may be an
interesting thing to note here is the
the tower of interpretation do you want
to describe this sure well one example
then I'll explain that all right so I'm
gonna to set up this query to run while
we explain what's going on okay
get it running yep it's running okay so
what what we're currently doing is we're
generating we're trying to generate oh
by the way how many people have seen
inception all right does anyone know
what a cost does anyone know the coin is
some people here should okay so a coin
is a program that evaluates to itself
and do Holloway I guess about four years
ago suggested that the work we're doing
we should be able to generate climbs
just from the mathematical specification
and it turns out we were able to after a
lot of work
and I sort of driven my research that
little observation so here we're doing
the same thing but we're doing it in a
slightly different way so we are trying
to generate a client a program that
values itself in this little subset of
scheme but the way we're doing it is
we're using this eval function which is
a scheme interpreter written in scheme
in a higher-order way with using
procedures to represent environments and
closures so this is a higher-order
recursive definition evaluator this
scheme interpreter which is generating a
scheme expression which is a kleine is
itself being interpreted by a scheme
evaluator written in the mini cameron
constraint logic programming language
which is itself written in mini cameron
which is a self written in scheme we can
go significantly deeper but this is you
know sort of like a good starting point
so this is the coin that we've generated
according to you know sort of Stu's
suggestion that we can generate Cline's
it's a little bit slower because we're
going through all these levels of
interpretation and this is this is an
open problem that we're trying to work
on is trying to do things like partial
evaluation and super compilation to get
rid of most of this interpretive
overhead and it looks like there are
things we can do this speed this up okay
since you convince you that this works
by the way I'll prove to us run in a
scheme interpreter so this is really
scheme interpreter look I can add things
and it does what you think very
sophisticated yes so here all uh I'll
just copy this guy that we synthesized
and it returns itself so it seems to do
the right thing
so uh let's show another fun example
yeah let's have a little more time so
this one is going to be a proof checker
very logic this is a base on a proof
checker that Matt might wrote and he
wrote it I think for a paper we were
writing and so he wrote a little tiny
proof checker for propositional logic a
very weak logic and he just wrote it in
racket I was like hey yeah we get the
slope roof checker and Greg has extended
a little bit to make it a little more
interesting but it's still written in
the same spirit and if you take this
code and you run it in racket you know
it runs forward the way that this works
is that you have to give it a proof of
something used to say okay here are my
assumptions here's the thing I want to
prove and here is the explicit proof
saying exactly which rules of inference
I'm using at each step if you've ever
taken a course in mathematical logic
these are the sorts of things you do by
hand where you say okay now we're using
modus ponens and here we're using modus
tollens or whatever here we're using an
assumption it's a real pain yes real
pain so yes that's an example proof you
know they look like that and if you were
taking a logic course you spent hours
doing those by hand so anyway Matt just
did something did a little proof checker
that would check that these proofs are
correct so we've taken that code without
modification this is the same code you
would run in racket it was intended to
run in racket as a function so just to
give you peace of mind just to make sure
that this this test actually does
succeed so this test is attempting to to
check the proof that we've handwritten
here so test should return true here and
Parliament agrees so yep I'll trust it
that little define answer thing that's
the hack that Greg had to invent because
we're not exposing all the behavior of
the underlying mini-camera system yet
all right so if we're since we're
synthesizing dead code to pretend that
we have like a query system
but we're gonna add a real query system
soon so you'll be able to do this a
little more naturally but so you can you
can kind of ignore the answer thing
that's sort of a hack because our
interfaces and expressive enough yeah so
if you picked up on our theme so far you
probably can anticipate what we're gonna
do next
we're gonna take this proof checker and
we're going to give it the conclusion
and the assumptions we're not going to
tell it how to prove our conclusion
we're just gonna leave it up to barliman
and see what it does we're going to tell
it that this proof should really be a
proof yeah you have to say that that the
proof checker should return true
otherwise you will only generate
incorrect proofs we can do that as well
I mean it sounds funny but being able to
generate almost correct proofs is
actually really useful because this is
an example of the sort of thing we can
do with test generation and I think
that's another thing that we will be
able to do practically in the near
future you often want to be able to
generate programs which are almost
correct or almost have some property but
not quite and so that's the ability to
be able to enumerate incorrect proofs is
actually potentially useful so if we
look at the result we can sort of
compare it side-by-side it if you do a
visual scan it looks like it synthesized
the same proof that we acted and written
before so seems to do the right thing
you'll notice that in the original code
we were just stuffing this out so we
didn't cheat there this thing really
works we can prove more interesting
things as well let me pull up a few
ideas so here are a bunch of things
we've proven so far using this
particular proof checker a fun one is
this community of hypotheses the idea is
that if a implies that the imply C then
also be implies a implies C so we should
be able to prove this conclusion
this
so now we should replace our answer with
the proof of this that's not what I
expected
now I think it's running oh sorry I have
to actually say what C is that's kind of
important and C is the thing we're
trying to prove right
C is the conclusion so this thing is C I
can actually do it this way
it's great fun running these queries
okay you never know if they'll actually
come back you know your your one missing
comma away from not
so we'll take a few seconds or it will
take forever or I might I might have
written something wrong yeah oh it seems
to have come up with an answer so here's
a here's a proof of the conclusion we
were just trying to prove I looked at it
offline
it seemed fine to me you can verify for
yourselves yeah for a second maybe about
kind of where where this might go and
what ideas we have yeah a couple of
other ideas we'll mention first thing I
could say is you know we're not the only
people exploring programs since this and
there are a lot of people exploring
program synthesis in various ways and
not we're not even on the only people
exploring interactive program since this
with like an IDE there's lots of work
good point you too I'm backed up we need
to update the barliman web page to try
to point to some of this existing work
in one piece of related work is by Peter
Michael Oh Sarah he's got this type in
test-driven development system it's
really cool there's a whole bunch of
interesting systems out there Leon so
forth
there's been a real renaissance in
program synthesis and last say five
years and I think you're gonna see a lot
of interesting work on this space the
thing that makes barliman different I
guess is our philosophy or philosophy I
think is very much closure II and very
much like core spec which is why I like
the design Cora spec so much is it
you know I guess stew described it as
ala carte I think was the term he used
where the idea is that you can use
whatever you want but the system is
never gonna require you to do anything
and so ramen has the same idea you can
write tests and the tests might help you
synthesize some missing code the test
might help you refute the code you've
written saying that this is incompatible
what you've written is incompatible with
a certain test no matter how you fill it
those are useful things but if you don't
want to write any tests you just want to
hack away it's fine it will degrade to a
standard text editor if you want to add
types and a type system and type
inference or type checking it can handle
that but it's not going to require in
fact if you added a type
system on top of this so you did serve
like at an ml version with s-expressions
as your language then you could actually
specify partial types you could say this
is a function that takes an int and maps
it to I don't know I don't want to think
that hard just fill in whatever so you
could have partially specified tests
partially specified types partially
specified properties partially specified
definitions of your program and barliman
will just take all that information and
combined it and try to help you but it's
never gonna require you to do anything
and that was one of the main points that
we have we wanted to be very easy for
programmers to use and use as much or as
little capabilities as they want at
anytime and then the other day idea was
we wanted to make it feel interactive
and feel fast so the programmers could
you know just use it as an editor and
everyone smile there's a happy surprise
and it fills in something or says no
you're wrong computer says no you have
to rethink this partial definition
before you've written the entire program
before you'd written the entire program
right so our view is true test-driven
development you not only write the tests
first but the test should be running all
of the time as you're writing the
program it should be constantly running
in the background and so ideas we have
better heuristics better search better
paralyzation one of the things that greg
did was over a six-week period he sped
up the synthesis queries by valid a
factor of a million to 10 million I was
like I didn't get you anything Greg but
that was appreciated thank you and it
seems like there are a lot more
techniques that are out there for
program senseless that we could apply so
you know we've sped up between some of
that and some other changes we've spent
a program synthesis by a factor of
probably 10 to the seventh ten to the
eighth more than faster than what you
saw five years ago with one dan and I
were giving demos I think we can
conservatively get another factor of 10
to the sixth another factor of a million
and I think it's likely we can get
another factor of a million after that
when you're dealing with an inherently
exponential space that doesn't you know
doesn't doesn't mean you're going to
synthesize 100,000
compiler it means that you can do
modestly more capable for larger
programs and more complex programs but
it's enough where I think it's starting
to become interesting and especially
with the testing technology and the VA
the ability to refute your code as
you're writing I think as we make that
faster and more capable that was
something that will be practical
near-term comments or no I think you
said it all another nice thing about
exponential problems is you can always
keep making progress you're never done
Gregg sped it up ten thousand times and
now we're only dreadfully slow you know</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>