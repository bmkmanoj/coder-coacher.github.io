<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building a Legal Data Service with Clojure - Jonathan Boston, Caleb Phillips | Coder Coacher - Coaching Coders</title><meta content="Building a Legal Data Service with Clojure - Jonathan Boston, Caleb Phillips - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building a Legal Data Service with Clojure - Jonathan Boston, Caleb Phillips</b></h2><h5 class="post__date">2016-04-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sSUzn6g-6vE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is building the legal data service
with closure I'm Jonathan Boston this is
kayla phillips and we work for a company
called cicada we've been in business
about four years and we write software
in the e-discovery space so we're going
to talk about our experience with
closure in that and so ediscovery is
basically the process of exchanging
information in any type of legal case
exchanging evidence even so an
e-discovery is the electronic version of
that same as email all right so let's
say company a and Company B are involved
in some type of type of legal to speed
so company a has an obligation to let's
say Company B says you infringe from our
patent and we can prove it if you take
all the emails and documents that your
engineers have written over the past
four years right and if you give us
those we can prove you infringe our
patent so company a will collect all the
relevant documents and then hand them
off to their lawyers and the lawyers are
going to filter those rights a social
security numbers personal home addresses
things like that that are relevant to
the case they'll redact those anything
that's like attorney-client privilege I
don't have to send that to you I'm not
legally obligated so we won't see those
this is my secret sauce this is how we
make our thing and so we're not legally
obligated to hand you over all of our
trade secrets right so they'll filter
those documents and then produce those
documents is called a production and
they will hand that production over to
the other side right saying here's
evidence you requested we're giving it
to you so a company b will take that
production and import it to whatever
system whatever software they're using
and then their lawyers will go through
and search through all those documents
right and what they're searching for is
what is called the hot document the
smoking gun that proves the case proves
what we have stated in the court alright
so a few difficulties with this the
documents that are collecting that can
be anything from a tiny email to a
spreadsheet with millions of rows to an
access database right anything
electronic and then you can have a few
documents or you can have millions of
documents right so you have the small
documents huge documents and potentially
a large set
right and then not only you're not
sometimes you're trying to find a single
document out of those millions of
documents and sometimes you're trying to
find a few or a group of documents that
you use to piece together a story that
proves your case so a lot of times it's
not just this guy knew this but if you
see this guy talk to this lady and this
lady talk to this lady and talk to this
guy at sea you can see the chain right
so you're trying to build this case and
it's all needs to be fast because you
have very expensive people involved in
this so any you know if you're going to
millions of documents and you have a few
seconds on each of those documents that
slows you down they ends up to be a
significant amount of money and so our
staff will use closure on the back end
close grip on the front end day Tomic as
our main data store main database
elastic search for fast search and then
AWS we use heavily so for this we're
going to talk caleb is going to talk
about our backend enclosure some
experience with that I'll talk about our
front end with closure script and then
what kind of and with some lessons
learned and I'll go with this is be
transparent is to show what is it really
like so those things that kind of seem
embarrassing because oh we should have
known that we're going to talk about
those and hopefully say these things we
feel like we got right or at least got
better with so with that I'll hand it
off to Caleb
alright like Boston set I'm Kayla
Phillips and I'm going to talk about the
back end kind of side of things our data
pipeline and I'm calling this section
designing with constraints and kind of
take you through how we've learned to
apply some of these things quick
overview this section I'm going to talk
about a couple propositions i'm going to
make how we did stuff wrong how we're
getting better at that and then a little
discussion about how we can maybe do
that getting better earlier in the
process so to continue the lego theme
from this morning my first proposition
is that the goal of software design is
to allow you to focus on the task that
you're working on your building a
feature for your customer and so any
design that we do is to reduce the set
of decisions that you have to make and
keep your thinking space to that
particular problem what you don't want
to do when you're building your Lego
house is to have to drop down to the
Lego factory and figure out how you make
a red lego brick or how long you have to
cook it to make it the right consistency
and those kind of things right so a
corollary to the the first proposition
is that missing design is distracting
right when we don't have the right LEGO
pieces we as developers have to kind of
go over the same decisions again and
again and we get distracted and we're
you know it's it's more stressful
because you know I don't know if you've
ever been in that place where you think
hasn't somebody already figured this out
for me why are we coming across this
ground again and part of the problem is
that compared to just banging out code
on the keyboard coming up with
abstractions doing up front design is
more of a soft skill right it's a little
more intimidating I don't know if
anybody has ever been a part of an
effort where you've inherited some big
upfront design that doesn't match the
problem that you're dealing with it all
and then you have to live with that not
only that you don't have what you need
but you have to support the bugs of this
other thing so
we're always looking for ways how can we
design better without wasting time so
much second proposition is that
considering limitations the constraints
that your software's going to face when
you deploy it is a concrete way to go
searching for abstraction I'm not
ringing feel like so it gives us a
handle to think about what are what are
the problems that I'm going to run into
when I get this into production and a
lot of times we certainly went through
this kind of mindset it when you're
starting out with a project it's easy to
think about what are these awesome
features that I'm building and and
scaling problems in edge cases we'll
just kind of well think about those
later right that's it that's just that's
a good problem to have right but I think
what we're trying to see is that if we
flip that around those actually become
tools for us to find what kind of things
we need to pin down in a talk about
three years ago rich said that design is
making decisions right the artifact of
the design process is a set of decisions
that you deliver and so decisions about
how am I going to deal with this
constraint how am I going to deal with
running out of disk space how am I going
to run how am I going to deal with not
being able to connect to this service
those are the kind of decisions that can
give us the Lego blocks we need to build
our features so i said i was going to
start out kind of in three phases here
doing it wrong so our first phase is
just that kind of wishful thinking hey
we'll deal with that later when we're
wildly successful and we we can just
we'll have all the knowledge to figure
out how to deal with constraints so let
me give you a little setup on our
environment Boston talk some about this
but the way that we get data in is that
we get just these big dumps of data so
we're dealing with hundreds and millions
of facts coming in and we need to get
into day Tomic in particular and they're
not spread out over the month or over
the week it's just one day hey we're
already late on this case
you get 100 million facts into the
database the judge says we have to do it
you know it's it's it's we're always
behind but we also run it an online
system that's you know has all the
normal characteristics of a web
application so people have to be able to
access it and do their work and as
Boston mentioned we have a lot of
variation and cardinality so if we treat
our document kind of as our fundamental
unit of work some documents have one
page and some documents surprisingly
have a hundred thousand pages we haven't
yet wrapped our mind around how that
happens in the world but we think it has
something to do with computers doing
crazy stuff how you get a hundred
thousand pages out of anything as well
but and then finally we're in this
environment where we have all kinds of
computing power we have a language that
makes it really easy to do stuff can
currently do stuff in parallel so we
have the ability to put lots of things
into flight and on the constraint side
of things I'm going to talk about day
Tomic and I've got the picture of the
coal miner with a canary up there
because the atomic has some really cool
characteristics because the architecture
trade-offs that were made are well
documented and they're also enforced day
Tomic is a system that when you push
past its boundaries it will let you know
about it in a in a way that that's
useful actually and so for us it was
very much a canary in the coal mine so I
mentioned this already and one of the
main trade-offs the daytime it makes in
the architectures it trades right
scalability for acid transactions so the
decision that was made is it hey we've
got a single thread in a single process
it's going to serialize transactions and
that's how we're going to maintain
sequences of consistent database states
but you know it is very much a trade-off
we can't go horizontally wide with right
scaling and this is the question in this
example that we failed to ask because we
knew all along
that this was something we were probably
going to run into okay date timings
right limited database we get a whole
bunch of data all at once it'll probably
be okay you know we'll figure it out
when it gets there so and again the
important point is that the atomic is
something that pushed back on us
relatively early but every service has a
limitation because we live in the actual
physical world so any service even you
know s3 and amazon has some kind of
limitation and those are the things that
we're going to have to deal with so how
did it work out for us to kind of just
use hope as a strategy so in the system
a variety of bolt transaction jobs just
you know kind of spring up here and
they're doing lots of transacting some
of them try to be good citizens and
batch of transactions and do the day
topic best practice some of them started
lots of threads because hey maybe
that'll be faster so we've got a lot of
different things going on going into day
Tomic and what we didn't provide in
terms of a design is a coordination
mechanism so a lot of Rights with no way
to coordinate those and what we found
was the answer to the question that we
did not ask is that when you push the
atomic past what it can write to its
index it has a couple of water marks one
is hey this is my lower watermark I need
to be writing to my durable index and
the high-water mark is hey you can't do
anything else because I'm so far behind
on my index and it will not accept any
more transactions which when we first
started seeing this you know we're
running around all day Tomic is it's
unstable we're going to what's going on
and you go look and there's a happy
process sitting there resources are fine
on the box there's no errors in the logs
everything's fine and you know we'd go
read the documentation and look at the
metrics and it's like oh turns out it is
doing fine this is what happens when it
meets its limit so we found ourselves in
a place that felt very much like playing
the whack-a-mole game you know you put
some pressure in the system over here
hey somebody put a million transactions
in and hey
somebody can tag from the UI and vice
versa we're just we're kind of running
around and trying to figure out how to
you know put our finger in the hole in
the dike all over the place and the
important point of this is that day
Tomic was doing exactly what it said it
would do what we were not doing is
dealing with what day Tomic said it
would do so our first reaction to this
is to try to figure out okay let's stop
starting so many threads let's match up
things let's try to make it better but
we quickly realized that we're going to
have to zoom out right back to the Lego
analogy we had not provided what we
needed as developers to be successful in
getting this data in our system and it
didn't matter how we tuned and tweaked
what we had it just was missing some
fundamental pieces so for the second
stage I'm calling this getting better
using discovered constraints to drive
some decisions and by discovered
constraints I mean stuff that's smacking
you in the face right stuff that you're
going to have to deal with so as we went
through this process you know I said
design is about making decisions what
are the things that we were having to
think about whenever we were trying to
get this data into the system so they
might we go through a list of those here
we had to think about what what's the
batch size of our transaction and how
many threads should be doing that and
that is really about trying to get the
transaction to the right length so that
people using the system interactively or
not waiting for a ten second transaction
because if transactions are handled
serially ten seconds is going to be 10
seconds to everybody who's behind it we
needed to how we're going to handle
errors what if I'm trying to put in a
million facts and we get a dynamo
exception what happens where do I put
those what I do with them we wanted to
be able to annotate transactions with
job info this is one of the superpowers
of day Tomic is that you have reified
transactions your transactions or actual
data and when we've got millions of
facts coming in we have to break that up
over thousands of transactions if we
annotate all those transactions we can
put that job back together
and make it into a coherent whole
actually existing in the database so
that we if we need to look at the
history of jobs we need to look at how
did this document get here who did this
crazy thing we can go back and look and
say oh this job ran this job ran this
person from the UI added this tag but
this was something that was being being
reimplemented in a couple different
places and it's you know right it's not
something that needs to be a minute
reinvented for long running jobs you
need to track progress do pause and
resume and really importantly we need to
be able to coordinate back pressure with
other jobs I mean fundamentally if you
look at the design of day Tomic it's a
single pipe it's a single pipe in a
general purpose database which means if
we're going to be successful getting a
lot of data in there we need a single
pipe on our side that has our domain
modeled in it right the atomic doesn't
know about our domain and doesn't know
how to do anything other than hey let
the first guy win so we needed a place
to do things like sharing capacity
between jobs and establishing priorities
so this is the kind of stuff when we
step back and look okay this is the kind
of things not making those decisions
forces developers to do every time and
it's just when I'm writing a job to you
know draw redactions on documents this
is not the level I want to be thinking
at am I going to bring down the database
or can I draw the pictures so we needed
to put those decisions in place oh no
hit it twice forget you saw that bullet
okay I'm going to talk about some of the
decisions that came out of looking at
that and the first one is that we need a
single bolt component we need to start
pulling out a service that would do that
stuff for us and again this is not an
atomic thing this is all of the services
that we use they all have their own
limitations their own ways that they
they want to be interacted with from
elasticsearch to our natural language
processing engine to even things like s3
which is theoretically you could put
every
you want there but it has its own quirks
and we don't want to pass that to
developers every single time we decided
that we're going to communicate via cues
and before we had done this and somewhat
half-hearted manner but we decided this
is the way we're going to do it because
you just kind of get nice out of the box
error handling and retry stuff you get a
default visualization of your workflow
even you know seeing where things back
up seeing where you need to scale things
that stuff just kind of comes for free
with cues and you don't have to worry
about timing and kind of synchronicity
issues because you have things can build
up on cues and if you have a problem you
can deal with it without it becoming a
cascading fail your kind of scenario and
we're in Amazon so we have nice cues
that let us generate lots of messages
without worrying about it we did go
ahead and implement a multiplexer for
resource sharing this turns out to be
very important all over the place
because everything we use is limited so
we need to slice it up between all of
the jobs that want access to it right
this is a fundamental concept right this
is in your operating system this is
everywhere but we needed to do it on our
side as well we decided to extract job
tracking out of day Tomic into its own
data store and this is one I don't think
we expected but we realized as we looked
at this that the atomic is really great
for our domain right that's where we
want to see how documents live what
happens to them how they got to where
they are but the kind of temporary data
that documents how a document gets into
the system isn't useful it isn't
interesting to the customer it's just
kind of part of our machinery and it was
eating up a significant portion of this
limited right capacity we had so we said
okay we should stop doing that because
that's just kind of shooting ourselves
in the foot and then also as we looked
at our data patterns we said we're not
really happy we're we're good functional
programmers I we like to
our side effects but we're writing to
the data plate database all over the
place and so what we wanted to do is say
okay let's put in tools that let us
accumulate data over a process and then
in a very controlled way say this is
where we want to transact and not you
know dozens of transactions all over the
place so that went into that decision
and we implemented a routing slip
pattern to build jobs out of these
components and what this let us do was
make a declarative way a data oriented
way to say the process of this item
getting into the system is this step
this step this step in this one and it
just allowed us to break things apart
and one final it's not even a day Tomic
specific thing but one of the things we
had done was just delegate identity
creation to our database which caused
some ordering constraints I mean we had
to go into day Tomic first and it also
made it difficult to deal with problems
like multiple delivery that you have in
a distributed queuing system so we said
actually you know we're drawing a line
here and the people on this side who are
creating the data need to make some good
decisions about what identity is so that
we can do up certs and we can do you
know make art make sure our operations
are repeatable well it's tough so I in
the set up I said you know there's kind
of two main goals we were trying to get
when we step back and one was to be able
to get this data into the system while
maintaining the stability and the kind
of response times for the interactive
users that we want and the second ones
do is to kind of take it off the
developers plate right it's not
something I have to invent every time I
want to do this I don't have to you know
get a knot in my stomach when I think
about writing a data oriented job in the
system and so we've been successful in
doing that so that's been really good we
hate we don't actually get transactor
unavailable exceptions anymore except
when it actually is unavailable like if
dynamos out or something and developers
have
ported most of our processes to this
framework and I want to run over a few
of it is a few of the payoffs that we
had that we didn't quite expect but
which have been really gratifying to me
and the first is that our process became
more data oriented when we broke things
into components and we reordered the
components we discovered surprise little
decisions made deep down on the
components that didn't really have
anything to do with the functionality
say of going into day Tomic but somebody
happened to discover a bad data value
down there and so they filtered it out
down in that component and when we
reorder things those rose to the top as
bugs because right the assumptions about
what the data look like no longer held
because things were reordered and so
kind of scratch their heads on that and
we realize now that we had this system
in place we can move those decisions
back to the beginning of the process so
we read our data in we parse it we clean
it up and we we can design a routing
slip that says these are the places that
needs to go it can skip that place
because it doesn't have that data and so
that was that was cool to find out that
we could go to a more data oriented more
simple right the components had fewer
surprise branches in them and this point
is similar if we think about design is
breaking things apart with the routing
slip we could skip steps but we found
places where I can't skip this step
because I need one particular branch of
an if statement and that helped us see
where we had things like basically to
Lego blocks you know melted together and
then we need to pull those apart so that
we could design the processes the way we
wanted to and this is a big one too I
keep thinking I'm going to skip a bullet
point here to save time but this was a
big thing for us because I'm sure
everybody in here has accumulated data
in your database over the years and your
database starts looking like why is it
like that
and you have to explain well it
shouldn't be like that but there's a
million rows and so we can't do it and
but putting this in place has allowed us
to do things like to we've done
migrations on hundreds and millions of
entities and we know that we can do that
we know what it's going to look like we
know how we can control the resources
and back it off and keep it out of the
way of our production data which is
always cool it feel like we can be
better stewards of the data that we have
and then scaling is a more
straightforward story too and so for my
my third and final quick little section
I'm going to talk about how can we do
this better because it's very it's cool
I'm you know I'm proud of the place that
we are in terms of the architecture that
we have but it has at felt at times a
little bit like this picture that I saw
an internet when I saw this on the
internet I I think I cried a little bit
because I don't know if you've seen that
if you can watch the video they get that
car up on two wheels and change the
tires and I actually sent this to our
CEO one point to say this is how it
feels right now but doing that process
of changing your architecture out from
underneath while you're trying to
maintain a production system while
you're trying to scale it while you're
supporting customers is to me it's not
the ideal setup so if we could learn to
do this Center I think I would have
fewer gray hairs so I'm calling getting
better earlier digging for constraints
upfront and I mean the basic idea here
is just being realistic and thinking
about I'm writing a feature and you
don't have to read all those points
that's just a list of stuff that can go
wrong for I think we can probably all
come up with list of stuff that can go
wrong pretty fast and I've also you know
put a picture of the release it booked
up there a colleague of ours Tim pote I
was really pushed that on us and it's a
great source of ideas about the kind of
things that your app is going to run
into that you probably didn't expect
when it starts to get under traffic
pressure so I'm gonna kick it back to
Boston talk about the UI
alright alright I'm going to talk about
designing the UI and give a little bit
of an overview what I will discuss
basically our closure script experience
the libraries we use and then design ?
right what do we do with this design how
did it work out what should we have done
what are we going to do so simply put we
love close your script we've been using
it from the start and we just love it we
think it's great so with JavaScript you
have things like this and changing
different versions of equality you know
double equals trip equals namespaces
right kind of modules basically you know
making modules using closures right but
all sources of crazy bugs and lots of
work right and we there's a whole class
above the whole class of work that we
just don't have to think about with
closure script and so I think that is a
really really big win when we do
interrupt with JavaScript we use some
JavaScript libraries PDF jas being a big
one interrupt what that is very
straightforward flows really well the
main problem being we love data we want
data and we get objects and so when you
interrupt with JavaScript that's the
main difficulty but on our side we love
it and fig will and ripple fig wheels
tool for hot reloading and then ruppel
we all know and love just what we give a
closure crip we love we're super happy
with the decision to use it a list of
some libraries for you so you know we
have a app in production for 34 years
you end up doing upgrades and overlap
and I have old code that I don't really
want to touch or that isn't you know
part of the new feature i'm doing right
so so we have some overlap and here's a
list of some of the things that we use
in moving forward what we'd like to be
using chorusing component data script
and home so new features old features
that you end up touching again we move
to move into these new things right and
so just kind as a walk through some of
the libraries
we've upgraded to or new tools that
we've chosen so what is the frame spin
like that doing those and why do we
choose those so again we purposely chose
closure crib over JavaScript and until
we never actually made a transition but
that was a specific choice we made
before I actually joined the company but
a choice that was made and then we're
using jquery and baking jas which is a
frp functional reactive programming
library and we're using up for you I and
then we switch to use in reacting home
and this was a mostly positive mostly
straight forward transition own played
well in being able to just take over
this section in this component and you
have a stream or multiple streams at
Simmons data there and we're able to do
upgrade over time period as opposed to
rewrite everything at once so I was a
known fan when I came on and drove
really pushed from this so we had you
know frp i think is you know a lot of
people enjoy that a lot of great for for
me and for seem like most of the team it
didn't fit as well as we thought but but
overall this was we are net marking this
as a positive is something we enjoyed a
good change and then we had our
application state we kept it in a simple
map and then we had some more
complicated relationships that we went
to storing there and so we moved to data
script data script is basically de Tomic
database on the front end or in
javascript and so we use that and that
we hold our application state in dick
Tomic are in data script now and then we
have you no callback world where you
know this thing happens you give it this
function so tell me when it happened by
calling this function right and we moved
to you sand quarry sink and channels now
so you know so callbacks are basically
hey this thing happened get the value
you know you most time you get an object
so parse out the data you want make it
actual immutable data and then put on
our channel and you're done so I think
Corey sink is probably my favorite
library just because it's just amazing
to me that we get that from a library
and what it adds and it makes
synchronous code look synchronous and
more simple to think through so these
are a few of evergreens we've made and
and I would say all of them have been a
positive all of them have been
purposeful choices we made that have
worked out well yeah so but when I stop
and look at these and as a team we stop
and look at these and start looking at
what what we're getting one of the bugs
that come up what are the features that
are still hard or you know what am I
thinking about we have to ask ourselves
are these useful right so I've made all
these upgrades and move from a map to
data script right and what do I get out
of that right at some point i still have
my application stay in this atom
basically right and so after all these
upgrades like we feel like overall
objectively it's better right we got
specifically better performance when we
moved around to ohm versus frp and most
that was our fault but we look at the
code if that's what you're producing at
some point you you kind of look at that
and say all right is that what I want to
be doing so we got better performance
faster iterations when you just overall
simpler code right so we we certainly
got some benefits but on one hand it
feels like you get six you move to half
a dozen right because you're kind of
doing the same thing but incrementally
getting better and so we said we step
back and say okay we still have a lot of
stuff that's hard to do what are we
missing right what is what is going on
and so kind of continuing with the theme
of what cable saner what are decisions
that are missing what a design what are
things I have to think about continually
when I go to code right and so here's a
big list none of these are particularly
unique to us and you could come up with
their own list right that's all
highlight a few like partial partial
estelle app state right so if you're
storing all your application stay until
it moves to a different section of this
of the site of your application some of
that or even most of application state
is still valid right it's it applies to
where they're at and it's up to date but
there's some section of application
state that you don't have rights you
have to go to server get it or that's
out of date right so what do you do
there do you display everything and just
wait to get the new stuff do you just
wait until you get all the new stuff you
just throw it away right and so it's not
to see that that's particular but that's
a decision that needs to be made that
hasn't been made right or the users
leaving the page and make sure that
everything's been saved right okay maybe
an hour quickly hard problem but if you
haven't done it
then it just means you have to do it
every time on every page make sure it's
done right and so these are when you put
these together you're like okay this is
a whole lot of stuff and at that point
we have to stop because I know my
natural tendency and I feel like the
developers in general we're just like
okay I remember you know communicating
novelty an identity I remember
specifically david nolan talked about
that his own next talk so I'm gonna go
Google em next and start looking at it
and figure it out oh yeah we're gonna
use I'm next right you're like no
actually right because that is what i'm
calling library driven development right
it's the i have this problem find the
library for it i have this problem
finding library and so this is from the
practical day of twitter right I love
this right because how many of us know
that rewriting your front end every six
weeks right and i love the tagline right
it's this time you have definitely
chosen the right libraries right like i
know everyone has been there with like
this is the one this is the library that
is going to fix this right and then like
tomorrow hacker news has that new thing
that does this whiz-bang thing or so
yeah right and it's like you know at
some point we want to we're about to
upgrade start feeling like what am i
doing this feels like deja vu like I've
been here and I'm going to be here again
right because it's not you know I feel
like this is a lot of the source of the
JavaScript 40 right it's because we're
turning we're doing the same thing we're
doing the same thing and incremental
grant incremental game right in this
library is it really really solving our
problem right it's not really talking
the hard part of what we're doing right
and so it's what we love enclosure what
we want to be doing design driven
development and we all love the hammock
right we praise the hammock like the
hammock right and so we want to take
more time to sit and design sit and
think right sit and figure out what are
the real problems we're needing to solve
right and then another tool that is
perhaps more humble and gets less love
is a pen and paper I love this quote
writing is nature's way of letting you
know how sloppy your thinking is I'm
lazy and so I love the hammock I don't
necessarily love the hard part of
writing things down and explain your
right so we use we try to use writing
not simply as a document everything so
the next person can read it but even as
a further clarification of our thinking
and even a communication with yourself
of have I this through what have I
missed
and then as a way to communicate with
others as well right so so we want to
take a step back and really design
things right so so what are some of the
decisions we've made number one the you
Isis system right we it needs to be
designed together it's it's not-it's
moved from a you know just put the
designer on at the person who kind of
put the junior developer on it right the
person who doesn't really know about the
design right like it's no longer that
right especially for us and this is in
process we're still learning how to do
this we're still in the process of
actually figuring out the entire design
and then libraries don't define the
system just a set of incrementally
improving your libraries does not give
you a system does not give you things
that work all together right and we've
been afraid to spend a lot of design
time on the front end because like oh
there's so much churn things are
changing all the time we don't want to
spend a bunch of design is just going to
change right I feel like that section
kind of backwards right is that
everything changes all time because we
don't design right it's like oh I didn't
think about this thing's let me go get
this new thing right and it's like so if
we spend more two more design time up
front we spend less time on the turn and
the upgrade of the library becomes
simpler because you know where it fits
and all the seams and all the way it
connects and so again we're in the
middle of this so I don't want to make
it sound like we have all the answers I
have to figure out but is it working our
company's doing doing well I mean we're
still starter piece stage kind of moving
out of that but we've had real success
of customers that can't get their data
in another system because it's you know
two million documents and it crashes or
system they can't use it and basically
in that case what happens is the case is
dropped right I we can't make money off
this because we can't do our job we
can't software so just drop the case
we're not going to take it and so we had
a case where it was about to be dropped
and they try our system and they
literally brought everyone into the
conference room and show the software
run in their system because they were
just like in all that the system can
actually handle it right and so our
system work great and you know again
there's bugs and their stuff we're not
perfect but but things are working
really well and we are growing as
developers of you know I said earlier it
low and tough like I've grown more in
the past year then I have you know maybe
you know five years before that just
being in the closure community doing
things like this and the way closure
pushes us
to learn new things right so a few of
our influences when the videos is made
public you can con google these these
are really great talks one thing I want
to point out own necks seems like almost
contradictory because I just said it's
not about libraries and I put on next
one things I love about that talk is how
David enumerates the problems he's
trying to solve right and that's part of
the design I'm talking about right when
you look at that tall he talks about hey
this problem this problem this problem
this problem it's not this feature so I
did this in this feature so I did this
right and it's a actual design so this
talk could kind of be summed up in
learning their practice what we preach
like we love simplicity talk about key
use data immutability right we love
those things and I hope most of us
aren't just giving the lip service but
there is a process of learning what that
means right what does it mean for a code
to be simple right and then what does it
mean not just for this function to be
simple but for this namespace and then
what is this module and what does the
system as a whole look like right so
learning those things is a process and
one that we've been on and continue to
be on and hopefully stay on for a while
so with that we just say thanks and
we'll open up for questions we'll take a
few questions just maybe one or if
someone has 11 I've been given a signal
one you might have a quick question all
right we'll be around we we would love
to talk to you if you're shy like he
seems to be here sometimes I'm scared
but anyways thanks for your time we
appreciate it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>