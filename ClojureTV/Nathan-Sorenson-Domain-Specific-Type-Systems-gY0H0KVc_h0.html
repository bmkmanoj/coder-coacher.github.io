<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Nathan Sorenson - Domain Specific Type Systems | Coder Coacher - Coaching Coders</title><meta content="Nathan Sorenson - Domain Specific Type Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Nathan Sorenson - Domain Specific Type Systems</b></h2><h5 class="post__date">2015-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gY0H0KVc_h0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Nathan Sorenson I work at
spark fund we do energy efficiency
financing and I'm gonna be talking about
domain specific type systems so this
talk is gonna have two parts on one hand
I'm gonna be talking about writing type
systems for domain-specific languages
and I'm gonna talk about a DSL we wrote
at spark fund that we found really
useful so I'm gonna just go through how
that worked for us and what that can
look like in your case but I also want
to step back and talk more generally so
if you don't find yourself writing kind
of like a classic DSL I want to argue
that a lot of what we do as programmers
is create domain-specific abstractions
and a lot of the design work we do can
be done really well and types are a
really effective tool for talking about
these domain-specific designs so I want
to I want to approach the topic from
from the high level and and something
concrete and I also want to be quite
generous in what I mean by
domain-specific so we all have examples
of kind of brand name domain-specific
languages like sequel or make which are
these external tools we use to do a
specific job we also know we can have
embedded dsls so macros in closure let
us do list comprehensions or or have
namespace forms they give us convenient
syntax for doing something inside of a
language but I also think when you're
working with a library you're also
getting to manipulate abstractions that
are specific to a particular domain so
for example a routing library like
pedestal or an live which lets you do
HTML selectors even though there's not
necessarily macros involved you still
have a very opinionated set of
abstractions that represent a domain and
help you understand how to how to work
with a domain and and how to engage with
it
so I want to kind of include all of this
type of design in this talk and I think
doing a good job at any of these
involves the same kind of solving the
same kind of problems and this is this
is what the job of programming is as
described in
the book how to design programs and I'm
gonna be citing this book a lot it's an
undergraduate textbook that teaches
undergraduates not just how to program
but how to be programmers how to how to
do our job in the middle space between
working in a domain representing
concepts in this domain as programs but
interpreting that back into these
particular domains so we don't just
tinker with programs so they give
results we need to interpret those
results to teach us more about our jobs
or understand what our correct decisions
or actually influenced the real world by
sending emails and things like that so
to talk about how types fit into this
model I'm gonna be working through what
I mean by a type system and and this is
going to be as described by John
Reynolds in his paper types attraction
and polymorphism and this is a really
classic paper and type theory and and
the whole paper is about how types are
away we write these abstractions and in
the paper
he says type structure is a syntactic
discipline for enforcing levels of
abstraction now this is kind of like a
dense quote so so let's just work
bottom-up and going through what what
each of these words mean so let's start
with abstraction so just take a second
to think you know we use this word all
the time but but what would be a pithy
definition for like what do we mean as
programmers by the word abstraction
I think one sense that we often mean is
to kind of summarize something
complicated so that's the idea to to
make like an abridged version and this
is literally like the abstract of a
paper it's it's hiding details and
giving you the high-level summary and we
know a lot of abstractions that have
that sense of hiding messy details or
just giving you the what you need to
know to get the high-level picture I
think a lot of times we also think of
the idea of isolating commonalities
between different things so at spark
fund we'll have maybe leases for for LED
lights with a lot of different companies
and there's a lot of repetition in the
structure of these leases so then we can
have a lambda abstraction to show what's
common between all the leases and what
varies and the part that varies is a
variable now both of these definitions I
kind of tackle the definition from the
idea of compression so so definition one
has this idea of a lossy compression
where we're losing some of the details
but kind of getting the gist of it and
the idea of lambda abstraction doesn't
really lose information but it's the
idea of like factoring it out in a more
efficient way the problem with thinking
of abstraction is compression is you
know what's stopping us from just
throwing our documents through a JPEG
compression and gzipping them right the
point is that these aren't bad
abstractions or non composable
abstractions it's just these this is not
abstraction at all the point isn't
compression even though that's often
involved in the process of abstraction
the point of abstraction is to create a
map for a domain so this is like an
actual tangible artifact we give to a
human to understand the domain they're
in so like literally a map you would
give to a pedestrian to help them
understand how to get from point A to
point B and this is something that is
more why we make abstractions because
the audience becomes important we give a
different map to pedestrian than we
would to a city planner but the idea is
the map always it helps human
understanding and it helps human
creativity in reimagining the situation
so you can do hypothetical reasoning so
as a pedestrian I can think if I want to
get to point B by three o'clock I'll
have to leave
fifteen minutes early and if you're a
city planner you can think well if I
rearrange the street and add a bike lane
here that might help traffic so it's
this level of abstracting over domain
that's the important part of abstraction
abstractions are also specification
jean-yves gerard is a logician who did a
lot of important work on type theory and
he says abstractions are specifications
in the way that tires are abstractions
and he says tires become abstractions
because they've got numbers describing
when we can swap one out for another and
we know what size they are so they fit
under rims and so on he also talks about
money being an abstraction so in our
society we have ways of assigning debt
to each other and it's like a protocol
that a lot of things can implement like
cash and bank accounts and credit cards
and so on and the interesting thing is
that both of these are kind of two sides
of the same process depending on which
way'd causality flows so when we think
of Maps we think of the landscape is
sort of existing and all we can do is
describe what we see this is how
abstractions work in the Natural
Sciences so gravity works a certain way
and so we come up with the abstraction
of Newton's laws of gravitation to
understand this and sort of creatively
imagine how to shoot rockets into space
but a lot of times as programmers we're
in the other situation where nature
adapts to fit to our abstractions so if
I'm writing a public API the real world
code starts cropping up that a debt
that's using my code and then you know I
come up with a tire specification and
real tires start getting built that
match my my abstractions and and quite
often reality somewhere in the middle
where there's a bit of back and forth
where we describe what's happening but
we're also specifying what ought to
happen so this is this is this is the
idea of abstracting over a domain and
types are somehow about levels of us
excuse-me extraction and I think this is
something that we're really familiar
with as programmers you know when we
write closure we know there's a long
path before we see anything running on a
microprocessor and and and we see this
pattern any dimension
or access we look so whether that's
fetching web pages or saving files to a
disk and I think this is why I've never
met a programmer who is confused by the
movie Inception right I mean like worlds
within worlds like it did this before
breakfast today like showing programmers
inception is like showing jaws to an
actual shark like they're not going to
be impressed so so the point of how how
types relate to these layers of
abstraction is described in the paper
through a fable and I I tell it a little
bit differently than it is in the paper
but the story is that there's there's a
couple and they're both mathematicians
and they give birth to twins and they
soon realize that they have
irreconcilable differences on how to
raise their kids on the subject of
complex analysis so they they amicably
decide to part ways and separate the
twins of birth and they they each take
one
the mother travels to to England and you
know teaches her kid that a complex
number is formed by a pair of real
numbers one represents the real
component and one represents the
imaginary component and then it taught
her how to add them and multiply them
and exponentiate them and then drive a
bunch of results on top of this
abstraction meanwhile the father moved
to California and a taught her daughter
that that real numbers consist of two
real numbers or sorry complex number
consists of two real numbers one
represents the distance from the origin
and one represents the angle from the
real axis and then he taught her how to
add them and multiply them and
exponentiate them and then drive to a
bunch of subsequent results now as fate
would have it the two twins discovered
each other at summer camp and hatched a
plan to swap places unknown to their
parents
and the ruse went on for several weeks
until their parents realized with horror
what had happened the wrong twin had
been receiving the wrong math curricula
but then something incredible happened
and you wouldn't guess what they both
got a hundred percent on their final
exams how did this happen
well it turns out both parents had an
intuitive notion of type which allowed
them to talk at a level of abstraction
that was completely compatible in the
later courses this led them to reconcile
their differences and get back together
and everyone lived happily ever after so
so the whole paper is about making
precise this notion of an intuitive
understanding of type and and really
formalizing this with with kind of
heavy-duty math and and it gets a little
bit dense so I usually recommend just
watching the Disney adaptation which is
wholesome family fun but but what about
what are the lessons that we can draw
just from this from this parable and one
is that types aren't data structures if
we said complex numbers were equivalent
to pairs of real numbers the twins would
have got confused and started giving
wrong answers they're not the same but
there is this by ejection between them
they're really - you're talking at two
different levels and you're able to
intuitively know when you're switching
register and talking about either one
and this goes back to how to design
programs in our idea of domain-specific
abstractions we have a representation in
our programs of complex numbers and we
can interpret our representations as
complex numbers but we're always
negotiating the distinction between them
and that's kind of where our expertise
expertise lies as programmers and types
help us in help us talk about this
distinction in an interesting way and
that's at the level of syntax now when
we're talking about syntax here you know
we don't want to think about tabs versus
spaces or even structured data versus
strings of characters all of that can be
syntax the idea is that it's just a
static description of a program right so
it's like what we
check into source control now every
every programming language has a static
semantics and a dynamic semantics the
static semantics are talking about how
do we combine our descriptions together
how do we understand what a description
means and how to have what's a valid
description and the dynamics are what
happens when we plug our programs into
the electrical socket and press GO and
you know what what do they do when
they're running and you can make
knowledge claims about either of these
perspectives and they're both important
when we talk about the dynamics this is
where we're using unit tests and
generated have tests to make claims and
and the interesting thing is all of the
claims from this perspective take the
form of falsifiable conjectures so when
you write a unit test or when you write
a generative test you're not really
saying why you believe something is true
you're giving a mechanism to build
confidence that it's true and this is
the same idea of karl popper's idea of
scientific knowledge you should listen
to what I'm saying because I'm giving
you a technique to use to prove that I'm
a liar so that's why you can trust my
confidence and that's how that's how
generative tests work you you say you
know shovel all these numbers into my
running machine and they should all have
this property if they don't you'll find
out and you can you can stay online and
types are coming from the opposite
perspective when talking about a program
they're talking about the statics so
this is talking about the level of the
syntax
aside from however it runs so that and I
think that's an important distinction
that sometimes gets blurred when we talk
about types so I just really want to
emphasize thinking about this is
properties about the syntax of the
program so imagine we have we're setting
up a function and don't think about this
as a runtime function just think about
this of some text and we have to two
things in our context a sterling that
has type string to int an exodus type
string so think of this as the actual
characters F as having this type and I
think that's helps just emphasize this
perspective if you're not sort of used
to thinking it in this way so so
sterling doesn't represent some variable
that at runtime will have string to end
this piece of syntax has type string to
end now in the real world there's a
really tight coupling between statics
and and dynamics and they should always
be in complete harmony so you can kind
of be back and forth and see them from
both ways equally but just for the
purpose of this this dichotomy I think
it's helpful to imagine is just a
property of syntax and now let's just
say things of like when we put these two
pieces of syntax together this compound
piece of syntax has type integer right
and I'm not thinking about runtime I'm
not thinking about where in the program
this piece of syntax lives I'm not
thinking if it's called on a Tuesday or
Wednesday and and that's just the angle
that these types of knowledge claims are
coming from and that can be important
because we we realize when we're
reasoning syntactically we can get upset
when something dynamic sort of invades
this mode of thought right like if you
if you don't realize something's in
dynamic variable you suddenly do have to
worry about where this function is
called at runtime and that can be
surprising when that happens and that's
why you know usually you try to be very
conservative about using dynamic scope
and things like that and it's also nice
to be able to make these claims because
statics are are are maps like there
there are instruction manuals for how to
use our software and they're like our
repair manuals for how to change our
software when the requirements change
and they're they're these artifacts we
give to humans and incidentally we also
run them and and we know this and we
hear this all the time but it's nice to
have a rich language for talking about
that the text or the map specifically so
so as you're making claims about this
perspective they have a different flavor
and that's of definition and derivation
this is kind of like saying one plus one
equals two two because that's the
definition of what one plus one means
this has type int because I'm following
rule number two of your type theory so
it's not really a claim that you have to
test it's just that's the definition of
what a type is so I'm spending a lot of
time on this definition because I like
how it defines types is not about
enforcing correctness but about
describing abstractions and I think a
lot of us think about types as being
something that improves correctness and
I think that's a lot what a lot of the
advocate
see four types is is like you should use
types because then your programs are
more correct and I'm not saying that's
not the case but it's like abstraction
it usually involves more correctness but
the purpose is to let us make more
precise claims about the statics it's
it's it's an artifact for humans to
consume to reason about and sort of
creatively reimagine how to combine
these programs together so that let's
just think about types is more of a
design language
Simon Peyton Jones is a creative GHC of
one of the creators says types of the
UML of functional programming and he's
talking specifically about Haskell but I
think it applies to all functional
programming even in untyped settings so
going again back to how design programs
this is a curriculums based around an
untyped language that's thats related to
racket and it's this is a scheme and
it's it's untyped but they give a design
recipe for students to follow and to
make sure you establish the habit of
thinking through all these steps before
you write code so you start by
describing your abstractions in terms of
previous abstractions so this is
introducing a new type you talk about
how to interpret that in your domain and
then you write a type signature for the
function you want to write that you
think would be useful so this is
checking for equality of complex numbers
and then you write a unit test to
describe the dynamics of this function
and only then do you start writing the
actual implementation now I think you
know as we get more experience we
short-circuit a lot of these steps but I
think it's important just to remember
that literally writing out the type has
advantage in in working through the
design and the point isn't that you know
it you know comments can get out of date
and it should be a comment for it and
formatted in a certain way but types
should be present in your mind when
you're designing a function and I think
that's a valuable habit too to make use
of so when you take this perspective
types also become a design criteria that
help you make better designs so imagine
you're you're writing you're writing an
API for fetching prices from some market
and your team team loves your work and
as is making good use of it
but they come back to you and say you
know
is great but we sometimes want to get a
spread so we want multiple prices back
and so you go back to the drawing board
and then think you know well maybe we
can just take an argument and so if it's
true then you get what you got before or
if it's false then I'll give you give
you the spread and then you know this
works great and it meets the design
requirements but then you start thinking
you know i want i wonder what type this
has so maybe you're trying to add some
types to get more correctness later and
well clearly it takes a boolean and then
returns what well it kind of depends
right it depends on the value of that
boolean so we know if it's true then
we're returning a price but if it's
false we're returning a list of prices
but what's this price red thing though
and we're saying the type is well that
that's taking billions clearly but then
is returning at type somehow so this you
know an innocent design process has led
us to this dependent type family which
might take a PhD to describe to somebody
and the point isn't using this as a
jumping off point to talking about when
dependent types are useful or not useful
it's just that it's clear that if you
don't incorporate types into thinking
through the design you know you probably
would have reasonably given up at this
point just said oh it returns either one
of the two and kind of reasoned at that
level if you saw a price X where X is a
variable you just would have known it's
one of the two and you wouldn't have
tried to say anything more but if you
start with the types in your mind you
would have maybe step back and say hey
maybe we should split this into two
functions you know one returns the price
always and one always returns a list of
prices now this in terms of static you
know a claim of truth is just as strong
as the dependent type but it's way
easier just to describe to someone and
way easier to understand when you see
prices in syntax you know how to
rearrange that correctly you know you
can map over it and this shouldn't be
surprising when you make things simpler
you often have more things and I think
this is something that I see in my own
work a lot of times it's just split up
into more multiple things and I also
think this perspective maybe adds a
little bit to some of the classic you
know back and forth we have of wind
types are useful so sometimes I imagine
people saying that types are premature
optimization
and I think this argument actually does
make sense if you think of types is
adding correctness because it's
important you know the hard part of our
job is building the right thing you can
always kind of try to make it more
correct before we put into production
and maybe that's where we want to add
types so this is kind of the idea that
types are like they're like a Mod Podge
glue you put over your puzzle when
you're done and when you want to hang it
up on the wall to show it off it's
something you kind of add after the fact
but if types are part of the design
process this is like saying I want to
build the thing first and design it
later like design is a premature
optimization and I think in the case of
building abstractions and building
public facing API
you want to fight for as much design
time as you can and I think it's
valuable because we know from experience
it's always easier to build systems that
turnout in a couple months to be
actually surprisingly complex and so I
think think types are a way of just
reflecting that complexity from a
different angle the complexity of how
tricky is a relationship of our is our
of our syntax that we're sort of buying
by making this design so now I just want
to talk about DSL that we built at spark
fund that is that came out of a lot of
these ideas and these philosophies we
have ton of tons of northeastern grads
working with us and they're all grew up
in the how to design programs so it's a
lot of fun working with this crew and
and the libraries called spectacular and
it gives our sort of dream type system
that works on top of day Tomic the
original work comes from Jim Charcot who
was with us in the early days of spark
fund but it's been really turned into
something cool and useful with the work
of Clair Alvis and it's open source but
it's not it's not really ready for
public consumption yet so you're not
going to find any any documentation here
yet it's just all source code comments
but but if if anything I say is
interesting you just want to check out
how we did things the codes all in the
open
so the atomic is really flexible in what
it allows you to do which is a good
thing and a bad thing so if you imagine
you have you know if you have people in
your database and you have this concept
of an attribute for a first name you can
now attach first names to anything in
your database so you could attach a
first name to a corporation and things
like that and likewise if something
points to another entity there's nothing
stopping you from pointing to anything
in your database so clearly no one does
this in production we all kind of have
conventions for what
what's a sensible way for your entities
to point to each other and so we kind of
congealed around this idea of specs to
excuse me to articulate this and at
first none of this was enforced it was
all a type system we agreed on in our
minds for saying wait it doesn't make
sense to attach a first name to a
corporation here's the document that
says what you can't attach a first name
to so we have this idea of specs and
here here's a lease that can have a
lessee which is a corporation and
crucially this can only point to
corporations I can attach attach like an
email address to the lessee these are
also kind of namespaced
so you know for example there's a status
field here other things can have status
fields and those status fields can have
different types so they're all kind of
named spaced by the by the type of spec
that you're talking about and we also
have younam's so here we can have status
that can be unsigned or signed and this
turned into eventually more of a union
type so these branches or these these
variants that it can take both
themselves can have fields and
properties but once we had all that
written down we started to be able to do
cool things with it so we could
introspect our specifications even
though they weren't enforced we could
print documentation and things like that
and one of the cool things that we
started to do and this is this is
Clare's work is write a query language
that's aware of our types so it lets us
write shorthand so I mentioned these are
all named spaced so if you were writing
raw day Tomic you'd have to say a lease
slash lessee and
have to know how that translation worked
we don't have to do that in our query
language because it's aware of our
conventions so here you can see a query
that's looking for all the leases and
fetching the names of the lyses and
binding that to the return so it's
basically giving us a list of strings
back which are the names so I'm just
gonna walk through kind of how a type
checking algorithm would tackle this
this is a really simple type system with
no polymorphism and no high order
functions and instead of getting into
the code I'll just step through the
algorithm just to give you a sense of
what's going on and this is something
you probably probably drive for yourself
if you if you looked at it hard enough
and it also gives a good sense of how
how type analysis of air is a very
syntactic approach so it's totally
directed by looking at the syntax as
like symbols in source code so type
checking starts at the outermost
expression which is this query statement
and then we look at this and know that
it's got to be some query that returns
some type we don't know what that is but
we are seeing that we're introducing a
new variable n so we'll just leave that
in the type for now and come back to
that later and we're also introducing a
scope so we have a context to keep track
of our outstanding variables and the
variables that are are in scope under in
this expression so here in our context
we say we add a pair with the variable
and in saying it as type e and that
stands for existential so there exists
some type that n is we just don't know
what it is yet and then we proceed to
the next sub expression which is this
lease statement so here this is this is
this is the pattern that's saying find
me all the leases in the database and we
know that the type of this should
correspond with lease because it's
written there and there's no no new
variables being bound so we just
continue down to the next sub expression
which is in the lessee field and here we
get to the name pattern so we're looking
for the names of lessees now just
looking at this we don't know we no
longer know what type this should be so
these are namespace so while these
corporations have names other things in
the data
could have named fields so we don't know
right now what type this should be but
we do know what our context is and those
we're coming down from Elysee so we can
expand the definition of lease which is
has these different fields and follow
the same path down that we followed in
our expression so that's where we know
it's a corporation and then we can
continue well expand the name field to
the next sub expression and we hit a
variable again just looking at the
variable we don't know what type it
should be so we expand the definition of
the parent type follow the field and
realize that should be string so now we
want to our typed isms claiming that n
probably should be string so to double
check that we look and up in the context
and see that it's still existential so
we still is some type that we don't know
what it is and that's compatible with
saying it's a string so we update our
context to say n is equal to string and
that's our final obligation so if you
imagine this is a recursive function
that's going through the syntax it will
bubble back up with with our updated
context and we can update the query to
say now it's a query of type string just
by fetching and out of the out of the
context there and and that's that's
really all there is to it this is how
I've showed this is it's called
bi-directional type checking just in
terms of the different kind of nouns
that describe this process synthesis is
when we look at an expression and know
what type it ought to be checking is
when we know the type from some other
context and we pass that down and
compare them when we're looking at a
variable and have to compare that to it
context and maybe update the context
that's called instantiation and finally
substitutions when we're done and we
know the context we need to update the
types to reflect the knowledge we've
learned and this is we don't actually
use these terms in our type checker just
because it's so simple and you can
actually just write it all as one
function but the nice thing about this
is that if you do phrase in terms of
these different you know if these are
multi methods you can grow your type
system and you can add more inference
and that would be in the synthesis for
example so so it's sort of like a
framework for writing type checkers and
if if you're interested in a more
advanced example I'm sort of learning
this my
self and you can see some of my my
stumbling around in this this repo where
I'm applying these ideas to polymorphism
and higher-order functions and things
like that and it's all based on a paper
and the references are in the project
another nice thing about this approach
is it makes it easy to give sensible
error messages when you are expanding
the definitions say for example you're
using a field name that doesn't exist
when you're going through the type
checker you always have the type at hand
and the expression that you're looking
at so you can make an error message that
says Lee says no field you know your
misspelled word and this can be as easy
as just throwing an exception in your
recursive function you don't you don't
have to to make this any fancier than
that similarly if you are doing an
instantiation step and your usage
doesn't match what you have in the
context for example if we try to bind
end to a field that's status instead of
a string you again have all the
information you need there just to give
a really sensible error message but we'd
also like to do more so imagine this
query is put into real source code so
this query would expand in some actual
date Tomic query it's a macro expansion
and then if someone tries to map
increment over it so remember this is
returning some query of strings this is
a type error and it would be nice if we
could alert someone that you know when
you can't actually do that it's not
unreasonable to expect that we caches
the compile time it's because we know
the type of compile time because all
their specs sort of describe and and we
can do that you know we don't have to
write a type checker for all of closure
because we have typed closer so the
trick here is that we wrap our query and
this is all done by the macro queue with
this this this this other macro called
ignore with unchecked cast and this
comes from typed closure and this is
basically saying you know trust me type
closure I know this expression returns
this type so that way we can talk to
typed closure and tell it what we know
from our nice little simple type system
and have type closure which is a really
incredible piece of software that works
an arbitrary closure code which we would
never be able to write ourselves have it
enforced that yet at the EU's site so
so typed closure if you type check your
code it will say oh you know this
expression is returning a query of
string and you're trying to call
increment on it that doesn't make sense
so this this is an improvement on des
Tomic de Tomic takes sort of runtime
data basically for its queries and it
has no way of saying at compile time
what the queries return so this is an
improvement that just you know it
doesn't catch a lot of errors but it's
it's gives us confidence in refactoring
and it just lets us know that our
comments are going to get out of date
right the the wins were part of the
design enforcing it is just more
convenient for us and this is this is
this is the this embedding into type
closure is the idea of like an embedded
DSL so we know that we can write DSOs I
can be called by a host language but
here what we're doing is embedding the
types of our DSL into the type system of
the host language and we do that just
with a simple translation at macro
expand so that that's like a quick
high-level just walkthrough of what it
does and I hope it just illustrates that
if you have if you have simple types as
part of your design odds are that
there's a simple type checker you can
write to to enforce that it doesn't have
to be a huge undertaking now kind of the
the problem you know it's easy for me to
get up here and talk about types the
problem is that that type theory is just
a huge subject and I think is just
reasonable to to admit that I didn't do
any type thing at school and I am a
super beginner at all this stuff so this
is my best understanding and this is a
reflection of what I've learned so far
there's two classic textbooks types in
programming languages as well as
practical foundations for programming
languages and I've been working through
these books for you know it feels like
years and I'm always learning new things
but it is it is like a big subject and I
think it's fair just to recognize that
you know we all have tons of things we
feel like we should always be learning
more about and I guess all I can do is
just give a little increment to the
priority of type theory I think it's
really a fundamental part of programming
I think it really is you know we have a
lot of experience with these dynamic
properties we know how to write unit
tests we know
how to write generative tests but I
think for me personally I've never
really thought about types as sort of
the fundamental other perspective of our
programs the perspective of how do we
make claims about our syntax and our
syntax is important you know it's what
you know one of the most valuable things
we produce as a physical artifact I also
say it's I found it useful to study
Haskell and all Campbell and I studied
Haskell specifically and and this isn't
like a language snob briefing at all
it's just these these languages have
been around for 25 years they've had a
lot of time and a lot of good libraries
sort of totally committed to this single
idea of fancy types and I think if
you've got a finite amount of time to
kind of fiddle with this stuff I think I
found it more a better use of my time to
learn it in a language where it was
totally committed to these ideas and
then pour my knowledge back to tech
closure but that's just my my experience
you know you know I'm you're spending
less time learning about type theory and
all the exceptions and compromises that
have to be made because of the JVM or
things like that so so that's that's
kind of where I'm coming from here's
just a link dump mostly for the YouTube
crowd stuff that either I mentioned or
it was inspiring to me and kind of
inform this talk but that's that's all
I've got
yeah so takeaways our types aren't about
correctness but they're about a design
language for abstraction abstractions
not about compression but it's about
artifacts we give to humans to help them
understand a domain and creatively
reimagine how to reconfigure that domain
and you know if you've got types as part
of your design process odds are you'll
end up with simple types sometimes and
then you know feel free to write a type
checker because it's fun okay so that's
what I got
well so I think we have time for a
couple of questions anybody has one yeah
yeah so the question is like you know
spectacular is not ready for public
consumption but how are using it today
so so we are using it in production
today but we just haven't made it nice
and we haven't made it easy for
contributors to know how to grapple with
our code base so we're a very small team
that know the codebase intimately so
we're using it in production now but
it's we don't feel it's we don't feel
it's easy for other people to just see
and make use in their context
necessarily but we do we do find it
useful and we do find it a very it's
infected it's actually infected our
whole company to our our specs we we
generate documentation for that and our
ops teams and our you know our product
managers and sales people when they're
describing what we do will refer to our
documents so so really the language that
we use and and this goes back and forth
but we can really gather around our
types and walk through the type file and
talk about like well it doesn't make
sense for this to be called that and
things like so it's actually been a
really good artifact for our whole
company to to kind of work through this
together
so the question is can you design with
too many types and I think that's
definitely true like if it's a it's a
design language so can you can you write
a map with too many symbols on it like
definitely right it's it's all about
knowing your audience and it's all about
knowing if you're giving a map to a
pedestrian versus giving a map to a city
planner if you're writing a theorem
prover you want to give as many types as
possible because they're experts and
have studied this for a long time and
have very subtle things they want to say
but if you're you're writing a simple
calculator you know you may be you don't
need to go right into super advanced
dependent type theory I mean it's not
useful for helping people understand
what they're trying to do yeah yeah so
the question is what what about
prismatic schema prismatic schema is a
really good tool for the dynamics
perspective right it lets you say really
in a really easy language these are the
things at runtime that I expect to
happen and it gives you good error
messages when those aren't true so like
you always want to say things from both
sides and prismatic a great way for
talking about the dynamic enforcement of
sort of true things yep something about
recursive types Oh spectacular it does
yeah so so you can have linked lists of
things it but other than that it
basically nothing so it actually doesn't
have polymorphism so like everything is
a concrete type and I think we can get
away with that is because we've got we
just used the the the cardinality of des
Tomic so we don't have lists and things
like that we just say it has one or it
has as many and that's des tommix is one
or as many odd there's a chance we might
have to upgrade to polymorphism but
again that's just that's something we'll
agree on as a team like we want to have
this new concept that's higher order and
then we'll talk about how to do that but
for now it's it's recursive types and
basically the simplest everything else
cool well thanks for time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>