<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Clojure for Business Teams - Decomplecting Data Analysis - Ram Krishnan | Coder Coacher - Coaching Coders</title><meta content="Clojure for Business Teams - Decomplecting Data Analysis - Ram Krishnan - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Clojure for Business Teams - Decomplecting Data Analysis - Ram Krishnan</b></h2><h5 class="post__date">2015-11-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WNOTVsthhpI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone my name is ramakrishnan I'm
I come from a small start-up in bay area
called jacks Taio we're doing some
interesting stuff with making business
analytics more consumable by business
users non-technical users and this talk
is going to be primarily about some of
the experiences that I've had building
the system that we are working on and
using closure to solve some of these
issues I've been a programmer for over
20 years I started my career am using C
and less small talk erlang java and then
i discovered closure on 2009 I've
actually built a few applications
commercial applications one is streaming
media one in EdTech and work on some
interesting problems and e-commerce okay
this is my first kanj by the way and so
I'm really excited oh thank you so if i
mix up my lines or something please
forgive me it's just the excitement okay
so this is a story from India it's about
some of you may know this what I'll just
quickly run through it it's it's about
these it's about this king who asked
these blind men to go examine this new
animal that's walked into the kingdom
and report back on what it is I don't
know why he picked blind men but he did
they picked different parts of the of
the animal and drew completely different
conclusions the guy who was you know who
touched the tail thought it was a snake
the guy who is feeling up the legs
thought it was a pillar and so they came
back with perfectly reasonable you know
conclusions but they were just wrong and
obviously the insight that poner to the
king was happen to be false business
analytics sometimes feels this way let
me see if I can no I get it
hmm
hello
I apologize if I'm going to switch
huh you think you're prepared for
everything oh whatever that was ah
goodness do you guys mind if I just left
at this in this safe okay thank you so
business analytics feels a lot like this
we've gotten very good at collecting
data and storing it in lots of different
shapes and married technologies we've
carved up the functions across all these
boundaries and each of these functional
groups have come up with their own tool
sets and tooling and they do great at
what they do you know in terms of
piecemeal analytics but they don't do a
good job integrating out of it and
forming a cohesive picture going up to
in this particular case a line of
business leader and so there's
integrating this integration isn't just
about plugging results from each of
these groups into it into another
spreadsheet and coming up with another
chart that that the line of business
leader can look at insight really comes
from collaboration across all these
boundaries so if if a line of business
analyst comes up with a question which
is implemented using artifacts that are
created by the data analyst or data
science teams then conversely new
products that come out of data science
and data analysts need to be able to
come back and influence the direction of
the questions or or what kinds of
questions are being asked so there needs
to be a much more open much more visible
way for all these teams to share
collaborate and enrich the overall
tooling just a quick word on the reality
of data tools so we seem to be stuck in
this you know schism of you know it's
either user-friendly or it's powerful so
you know business analyst will use Excel
because it's user-friendly the XL is a
great tool I'm not knocking any tools
here i'm just saying that we've kind of
carved ourselves into these niches where
these teams have these tools don't
necessarily talk to each other well
throwing a CSV over the wall isn't
integration right or a JSON file is an
integration you need something a little
bit more by direct
something that propagates in either
direction that's that's the that's the
core premise here that integration and
collaboration is what makes insight okay
so out of all this I apologize again
lost my cursor so again this is kind of
reiterating what I was saying that
before but the opportunity that we're
really you know my partner and i we were
commiserating about these issues my
partner is a product line manager was a
product line manager in a semiconductor
company and he had pretty much the same
problem he had all this data sitting in
data warehouses and so forth but anytime
he wanted to have a build some you know
test an idea test hypotheses it was
impossible given all the tooling and the
manpower in the middle so there was no
direct access to any of it there was no
way for him to directly drive one what
he wanted to do so that became one core
tenet for us self-service enable every
one of those groups that I was talking
about in the previous slide to be able
to do their job and to be able to
leverage what the other teams are going
so that that's an important goal
abstraction objection is important
because each of these groups have their
own terminology their own vernacular
that they use and it's important I mean
rich Hickey famously you know has
demonstrated the need for using words
correctly in the in the right context
abstraction is important because each of
those teams to be productive and to be
effective they need to see the process
through their mental model so that
abstraction collaboration each of these
functional groups functional teams needs
to be able to contribute just as much as
they consume and as effectively as as
they consume so it's it can't be data
science produces something and business
analyst you know uses it and there's no
backward propagation of
information or insight so that's that
needs to change Thanks okay so before I
go further I want to clarify one thing
so the title of this talk is closure for
business teams I want to emphasize what
it is and what it isn't it is not
substituting closure for our or Python I
think I don't think that's the right way
to go it is not another closure ID at
least not IDE in the conventional sense
it's not a DSL it is about rethinking
data tooling up but applying all of the
learnings we've taken from the closure
from closure and its ecosystem and these
are functional abstractions composition
interactive you know interactively
building and testing immutable data
these are the these are the concepts
that we need to figure that we figured
need to be presented to business users
non-technical non closure developers so
without further ado this is what just I
oh is it is a visual it uses a visual
schematic metaphor a drag-and-drop
canvas on Twitch functional blocks are
placed and they're wired together to
match whatever appropriate data flow is
required it's kind of like Lego for data
but it's it's got closer underneath so
it's actually Lego for data with closure
which is like I mean how cool is that
okay so I've talked a lot let me show
you some stuff and then we can um so Jax
io is a fairly recent project the UX and
the UI is constantly being changed but
this is roughly how we organize things
and there's actually a certain parallel
to how closure organizes namespaces and
functions so we have projects projects
are kind of a a group of almost like
projects or a jar boundary so you can
have a bunch of modules each of those
modules are themselves namespaces so let
me let me open one of these
appropriately named closure conch demo
this is just a very simple flow all it's
doing is it's generating an inclusive
range which is really just a range but
with the upper end included the top and
included and pushing it through a
collect which is really just a map and
printing it out on the console I'm going
to run this and then i'll get back to
explaining what's actually going on okay
so it prints out a bunch of numbers so
each of these blocks has a certain set
of properties and those properties can
be defined via literal values or as
signals coming in from upstream block
each of those blocks has a value out
which can be taken out to the next stage
collect which I mentioned is a is a kind
of a quick word on terminology so we
kind of a be tested different terms with
business users and for whatever reason
math filter reduced in paths we ended up
with the small talk II sounding collect
select and reject and and so forth and
roll up anyway so collect is essentially
a map and it takes a collector which is
in fact another module in and of itself
and in this case I'm using a square dot
clj which is I'm going to metod out into
this
and that's really just a this is this is
an abstract component there's an
abstract graph where it has a unbound
input which it expects the caller or the
or the user to supply which goes into in
this case a little closure closure code
block and this is where you can more or
less it's an escape valve for going
straight through Rock closure and the
output goes as a output binding and and
that's really it what it's doing is
exactly what map does it takes the list
of numbers the sequence of numbers it
collects over them generates a new
collection which gets printed out using
a console print okay so let's look at
something what's behind this a little
bit okay so the the anatomy of this
graph is really like I was saying is
these each one of those blocks is backed
by a function inclusive range has those
arguments collect has those arguments
console print and the graph itself is
represented by a structure very similar
to what's the code fragment of the
bottom you could almost see the
threading arrow going from port to port
there right okay and the square abstract
module is literally that I yeah so I
apologize the the example that I showed
was was using a closure code block but
there is an implementation which uses
this expression block which is an infix
minion fix language that business users
like and that's actually thanks to marks
amazing insta parcel library so again
and so yeah one quick point that
expression actually takes what's called
a very attic parameter so it's one is
one of these parameters where we as you
keep adding new signals to it it will
allow for more signals to be added so
it's essentially it's like a varargs for
in a visual way okay so that's a fairly
straightforward graph what happens when
things get a little bit more complicated
so this is a
reasonably typical data science task
where we load some kind of data set
split it into a training and test set
apply some some kind of algorithm to it
in this case it is doing its training a
linear regression predictor and then we
want to test the effectiveness of the
predictor using the test set so the the
graph more or less describes what's
happening there and the code down at the
bottom is trying to it does pretty much
the same thing which you can start to
see the moment we we look at the code
this requires someone with closure
understanding you need to know what the
let binding is doing who's referencing
the lead binding and so forth whereas
the visual flow is something that a non
developer can look at and pretty quickly
understand what's going on they may not
necessarily understand how linear
regression is you know implemented or
performing but they can more or less
follow the follower logic and click
through and and look at the states so
and this is something that we've we've
had a chance to observe with user groups
where we've had completely novice
product managers and proclaim people sit
with this environment and start to I
mean after a little bit of training
start to build fairly interesting graphs
in fact this this flow and another floor
that'll show later was actually built by
someone who has no development
experience but this is a this is clearly
a well thought-out functional flow okay
so one clarification this is not to say
cool you know code sucks or something I
mean obviously not it's a code is always
going to be more succinct it is going to
be in terms of flexibility there's
probably going to be there's always
going to be more ways of working with
the code then there isn't this
individual forum but the visual form
lends itself to easier understanding and
knowledge transfer you know
discoverability those are these are
these are properties that come almost
for free with the visual flow paradise
okay actually let me switch back to the
demo I want to show a couple of other
examples now i'm doing a time ok so
these flows that i talked about are
still fairly low-level there are
probably things that are developer or a
data scientist would build so let's talk
about something that a product line
manager typically uses okay so this is
one of the other flows that i was
talking about which someone who's a non
closure developer build let me run this
and then and then come back and talk
about okay I preload a lot of the data
so it just runs better anyway so this is
a very typical sales dashboard that
shows things like you know how our
certain products doing in say different
market segments who are my top 10
customers what you know what what
lifetime mean lifetime revenue am I
saying from them you know what's how's
my product one of my primary market
segments performing at a secondary
market level or maybe something across
geographical regions and so forth so
it's fairly straightforward something
that probably gets built a million times
in different business units and this is
more or less how it gets built in just
there is some import process but
presumably it's an ETL processes running
in batch or even it could be integrated
right here in inline the values coming
out of that are being pushed into a
block called called portfolio summary
now here's the abstraction at work
portfolio summary is something a product
line manager understands if if you had a
palette of these blocks on the side
with there are in fact Republican blocks
on the sites which have neglected to
mention if you had a pallet of these
blocks a portfolio summary makes sense
to a product line guy he would pull that
in and expect that when he pushes his
data into when he gets some kind of
graph that looks like the chart we
looked at earlier the top ten customers
is another block segment stats is
another block segment stats has some
presents it's abstraction for you know
and expects to be sent what segments the
report should be presenting and so forth
and the results of these blocks is being
merged back into a an HTML page and
rendered rendered to a link there's also
an AWS method in this which sends out an
email so presumably every time this this
dashboard gets up late updated you'd
want to be notified about it again each
one of these blocks does one very
specific thing you put them together you
start to seem more interesting patterns
combat okay so the last last demo
example that I have is actually a fairly
full fledged data science use case which
is which hopefully illustrates this
point that once you have is this visual
abstraction then there's really nothing
you can't put into one of these blocks
it could be something as complex as
random forest or something as you know
straightforward is sending an email or
you know generate you're doing a map so
here's here's an example of slightly
more involved what it's doing is it's
loading the same data set training a
linear regression predictor and the
random forest whitaker and just
generating a comparison of how they do
against the original values so let's go
ahead and run that
ok
okay I'm not sure this is all that
interesting to look at but basically
gives you an idea of how they're how
they how each of those predictors
performed there's some interesting
things going on here in terms of
translating low-level closure primitives
into a built-ins into into the right
abstraction for the data scientists
point of view and and also in terms of
introspection and debug ability there is
we've got some interesting stuff going
on here where you can once you've run
this you can go introspect values and if
this is showing you results from the
last evaluation we're also working on
features to do partial evaluation so the
ability to save the state of a part of
this graph and invoke the rest of it so
that you can sort of so you know prime
your your test environment and iterate
through many test cases quickly okay
okay so I want to switch gears a little
bit and talk a little bit about what's
under the hood so as I said everything
all of these blocks these raps they are
just functions they're just closer
functions this is a helper macro def
module which essentially ensures that
everything that is required to turn a
function into a block has been provided
ID is a is a good in this case it could
it it could be anything actually but as
long I dia here is that the name of the
component the name of the module is not
a unique identifier it can change it can
be different and it shouldn't affect
uses of it across the system the other
piece here that's interesting is the
inputs the the properties or signal
ports are really just it's it's a
declarative definition of what each
input is what kind of schema it takes
and what the output type is
unfortunately the example that I picked
and I realizes too late isn't rich
enough but that schema definition can be
can get fairly specific it can be quite
tune and and the body of the of the
module is really just the closure
function so no magic really okay and
sort of the orchestration of all of this
is we split it into a design workbench
piece and a deployment piece the design
work bench is the interactive piece or
the the front end with where all the
wiring happens the drag-and-drop canvas
the inspector or the debugger all of
that is the design piece when you hit
run that that evaluation is actually
happening in the deployment piece where
we have a source to source
transformation of the of that graph into
closure code and that closure code then
goes through closure core compiler so
again no magic it's it's just data being
formed yeah I got lean in there so we
actually also have pomegranate and
vinyasa which was a great little library
for reloading things in place so you
don't have to fire up and fire down java
instances JVM instances the product of
the transpiler can be compiled into an
uber jar and deployed completely
independent of this so you know one use
case really is where we have a hosted
design environment and all of the
deployment happens in a private cloud
somewhere so the stack is again we need
to do I hated but it's not anything
anything fascinating it's we've got
closure script omen fig wheel to handle
all the front end stuff the design
services is all I mean it's almost
motherhood and apple pie libraries at
this point and and a big thanks to all
of the amazing developers who put out
these meticulously crafted libraries so
really okay so none of this is you know
dramatically you know new original
visual environments and data flow for
analytics have been around forever I
mean there's some great examples Yahoo
pipes Apple quartz composer scratch
numerous other ones that i'm sure i'm
missing it's a proven approach but
what's interesting now is combining that
approach with closure and its ecosystem
I think introduces I mean it could be a
seriously game-changing effect we could
see some new things happening that I
mean a new class of developers who
aren't necessarily closure developers or
coming to closure via other means so
anyway that's my pipe dream okay what's
next as I said we're we're a fairly
young project we just got a working out
for Lisa
working with a few customers in pharma
IOT and semiconductors part of the
reason is actually this conch talk is
the first that we're coming out and
socializing the ideas behind just part
of the reason for that is we really
believe the end application of just is
has to be driven by a non closure
community and so we we've been focusing
on that but now it's it's to the point
where we think the ideas have been have
been vetted and it's now it's time to
get my people my brother to you know
involved and and seriously where we're
at this point keen to see what
challenges you may yourself be facing
applications that you think something
like just could be interestingly applied
I just want to quickly thank a few
people especially Lynn and Alex and all
the other folks at closure cons for
inviting me I'm super excited to be here
I mean I'm I'm really going to start
enjoying the the conference after this
is done but again I wish you all a great
conference any questions I'd be happy to
get into yeah the primary certainly from
the technology stack point of view we
didn't have any major surprises I mean
we've learned a few things along the way
for example the first incarnation of jux
was very monolithic it had everything
that the designer the compiler
everything was in one piece and that was
that was limited another lesson we
learned was the way those modules and
those libraries get imported we needed
to rethink that and we architected in a
way such that it is very easy to take
any open source library whether it's I
mean for example I didn't go through
that library list very indeed in great
detail but you know we pulled in things
like
a CL jml encounter amazonica just great
libraries but the we got it to the point
where we were able to bring these
libraries in with minimal effort like
literally I mean especially the
well-designed ones there's virtually no
effort you just you're sticking a
wrapper around it there are some
libraries where you know they're more
imperative and therefore there's that
aspect of these aren't kosher leaves
these Java libraries so there's that the
that part of figuring out what that
abstraction need needs to be and that's
a constant process we're constantly
learning how to build the right
abstraction for the right right easier
so I don't know if that helps yeah
true for Java a great question so the
first part yes the short answer is yes
we do handle you can pretty much
anything that you think of that you
could you would say I can use Jack's
Frodo I mean I could use closure for
doing this you could probably think of
just as being equally applicable so if
its data transforms and by the way this
is not that's not a plug to say use just
instead of closure at all it just means
that a non closure developer might be
able to do some of those things I mean
can you get I mean I'm sort of ranting a
little here but can you imagine the
number of times you get pinged as a
developer to do things that you wish
people could do themselves and and you
know and and and what do we end up doing
we end up building custom user
interfaces for those things we come up
with all I gotta build this importer
that thing instead if we could just say
hey here's a few blocks here's here are
a few blocks and this is how it roughly
works go to town with it so that's
that's one part of it and your second
question about the absolutely Java
interop is great but that is exactly the
place where the abstraction problem
exists turning those imperative you know
design you know approaches into a
functional data flow ready path
sometimes poses challenges the closure
libraries are breeze I mean literally
you could you could add a a metod a meta
map to a closure function which is what
def module does anyway and you'd be done
so it's but it's it's that it's the
impedance mismatch between the
imperative and the data flow where time
gets bent yes
that's a great question actually I know
if everybody got that but basically why
is this different or how is this better
right other than having a larger how is
this better than the approach say yahoo
pipes token support so now yahoo pipes
was a very purpose oriented platform
they didn't try to be very general
purpose about it baby it was about
processing RSS feeds and general general
web web formats and so forth mashups if
I'm if I'm not mistaken and I don't
think yahoo pipes necessarily gave you a
very good extension capability wasn't
something where you could easily extend
it with your own primitives in some way
or add on a you know import your jar and
say this is what I want done actually a
few things that I that I not get into
and I I apologize because there's a lot
of stuff and I had to make some priority
calls on what what I actually presented
here so to directly answer your question
it's hard for me to talk about you know
as specific set of things that
differentiate this but I'll just list
them and maybe maybe we can draw some
conclusions from that one is closure in
the Java ecosystem right closure in the
larger Java ecosystem which means you
have a much larger set of things that
can be plugged it not all of them can be
plugged in with the same ease of use but
they can all be plugged in the second
aspect is because of the because we had
the benefit of hindsight we started with
this idea that the design and the
deployment are distinctly separate
concerns so there is really no there's
nothing that ties us from say you know
having all of this closure front-end
capability Java you know ecosystem but
rendering something that's completely
different because this is we're doing
data transforms we could just as easily
assuming all of the appropriate
infrastructure were in place we can just
as easily generate say C
in fact there is an IOT application
where we we've been tossing this idea of
where a graph gets compiled to see and
that C piece would be compiled into an
embedded environment so again the AHA
here really is a synthesis of different
ideas no no one of which is is unique or
significant in and of itself but i think
you know they've already to put it all
together and and make it work into end
maybe is that does that work yeah
yes yes there is the meantime I will not
deny that I mean there is still a there
is still a learning curve associated
with even something like just but maybe
abstraction can help with that if we
turn blocks and if we turn processes
into in not just terminology but flow
wise as well separation moyes as well
into things that are identifiable in
specific business domains then maybe
there's there's hope at least at least
we got to try yes yeah yeah yeah
ah great almost like a continuation kind
of thing so do you wrap up wrap up part
it's a it's an idea that's actually been
bandied about so part of the partial
eval feature that I was talking about
earlier I wish I had that ready for to
demo to you guys but it's not part of
that is is that is the ability it gives
us a couple of different things one is
the ability to iterate without having to
rerun large parts of the graph the
second is resilience if this if this
node imagine a distributed cluster in
which the computation is taking place
the node dies we have the ability to
resume that node because the data could
be replicated the the Kia hi again is
that that's data we can take that and
push it into another another node or you
know simultaneously populate two nodes
you can be running you know without
skipping a beat you could switch to your
earlier point about Excel Excel is great
there's even some very cool stuff that
I've seen about putting closure and
excelled cell and enclosures crippling
excelsa which is great but fundamentally
excel you know fall fails for the other
reason that you mentioned which is it is
all one place and the only way for me to
collaborate with someone else is to hand
that entire thing over and then when
they make a change for them to hand it
back to me or I guess maybe build a
visual basic macros or something but as
a metaphor as a UX metaphor grids are
great in fact we've even considered
doing that for parts of this but I still
believe that the data flow is clear I
mean I won't after some threshold after
some point a complex Excel spreadsheet
is gobbledygook it's I mean you just
lose track of where things are happening
and I've actually seen a debugger for
excel macros which D compiles it back
into a data flow makes it much easier to
look at much easier to reason about so
not discounting Excel I'm just saying
that maybe the two can coexist be a nice
happy family okay oh yes sir
yes yeah yeah yeah that's a that's a
great question as well so I kind of
cheated there so right now the way this
feature works right so we're actually
collecting all of the intermediate state
so yes do you answer your question we
can we don't have the UI for it because
this is the challenge the moment we
because it is hierarchical its composite
all right you have abstract modules
beneath you know modules are being
composed together hierarchically if a
failure happens let's say three levels
deep and you catch it how do you
communicate this to a non technical user
that there's a stack involved and you
need navigate down to the so we're we're
we're kind of sidestepping that a little
bit we're basically saying a netter
happen at this top level module and by
the way the state that that that's
involved with it is this it may not be
you know adequate for you to debug it
but it's the best view I we could come
up with so far but those are the kinds
of challenges we want to we want to be
addressing how do we how do we turn this
UX into a how do we improve the UX to
the 22 where a non closure developer a
non technical user can think about these
things in terms of oh I have a I have
these different levels of abstraction
when I look at it through this lens it's
this information when I when I move this
lens I'm seeing this next level and so
forth so these are some interesting at
least they're more interesting than you
know just writing reports school reports
anyway
yeah okay thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>