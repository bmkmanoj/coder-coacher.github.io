<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>2017 in ClojureScript Web Perf &amp; JS Ecosystem Integration - António Monteiro | Coder Coacher - Coaching Coders</title><meta content="2017 in ClojureScript Web Perf &amp; JS Ecosystem Integration - António Monteiro - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>2017 in ClojureScript Web Perf &amp; JS Ecosystem Integration - António Monteiro</b></h2><h5 class="post__date">2017-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/63K--ctvT-g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">awesome thank you Alex
so great to be here helping celebrate
the closure 10th anniversary so this
talk is a little bit about what we've
been up to in 2017 okay what are the the
puzzles that we had to solve in order to
allow you to solve the problems I think
that's how rich put it so my name is
Antonio I'm a software engineer at a
small company in California helping
people get covered for life insurance I
have also been doing quite a bit of work
in closure script in the past couple
years and I'm the author of a project
called lumo which is a new closure
script environment for nodejs entirely
self hosted so before we get started I
think it's important to kind of clarify
why we are doing this at all like what
is the grand vision the the bigger
picture for closure script and it has
always been about reach write closure is
a really cool language but our platforms
that it cannot reach there are places
where the JVM Kanako and so closure
script has always been about using a an
arguably better more powerful language
to program the web and other platforms
where JVM can go and I think we're
really ahead of you know mainstream
tooling in the JavaScript ecosystem and
I'll tell you a little bit more about
that
so before we start couple things this
talk is about closure is as of closure
script 1 9 9 4 6 which was just released
last week and when I mentioned closure
or Google closure closure compiler it's
an unfortunate name what I'm referring
to the Google project which is a
JavaScript compiler and optimizer and
all we mention closure the language if I
need to speak about it so this occupies
about 2017 but we cannot do that without
starting a little bit like a couple
years back so let's start in 2015 in
prepared the stage for the kind of
big changes that we we did this year so
in JavaScript some in 2015 something
very important happened there was a very
successful Google Summer of Code project
where Maria Geller worked on landing
initial JavaScript module support into
the closure compiler and so this is
about having Google closure understand
what foreign JavaScript you are
consuming to make this a little bit
clearer like if you have a closure
script project the closure compiler will
come compile your your color script into
something like what's shown there at the
top of your file there are these good up
providing good required statements which
are really a exquisite module module
format that the Google closure library
understands and feeds into the Google
closure compiler to optimize your code
but in the wild right JavaScript modules
may be common j/s which export a
function like they're at the bottom they
may be the new ACMA script six or extra
2017 which is now ever-evolving
they may also be what they call a
synchronous module definition or AMD and
so with all these kinds of module
formats the the solution that was put
into closure script in 2013 is about
converting all these types of modules to
the closure library format in a way that
the closure compiler can understand them
and and so what this allows is your your
foreign dependencies because we're in
our own closure script island and we
want to sometimes we have the need to go
outside and consume some foreign
JavaScript and before this what we did
was just prepend these foreign
javascript sources to our closure script
sources or the generator javascript
sources and the in with this support
there is now the possibility or there
has been for some time the possibility
to convert
to a format that Google closure
understands and have Google closure
compiler perform advanced and
sophisticated optimizations on these
foreign there or put it another way
these libraries are not foreign anymore
2015 was also a year where we landed
initial code splitting support
I took code splitting is is very hyped
right now in the JavaScript community it
is basically about shipping less
JavaScript to your clients to the
browser this is very important if you
need to support low low end devices or
slow networks and the Google closure
compiler has had support for code
splitting for a while now and in 2015
David worked on adding initial support
for this into a closure compiler I will
tell you later that this year we really
revamped
this code splitting support in a way
that is much easier to use so this is
all very fascinating for me on a
personal note but 2015 was also the year
where we landed the the self hosted
compiler or rather David did and and
self hosting closures bootstrapping the
compiler is not not really about being
cool not not about you know scoring cool
points or anything it's really necessary
because there are there in some cases we
want to compile a floater script where a
JVM really cannot go and it's it's
really cool to have something self
hosted but there was really a necessity
in there and so this is what allowed
lumo for example to exist or plunk
by Mike facts which has been a great
inspiration for my own project so a year
later we kept working on all this all
the stuff that I mentioned and still you
know continuously fixing bugs that we
introduced and one cool thing that I I
want to highlight about 2006 16 is
something that we call closure - closure
script namespace a aliasing
and so before you had because there are
some so in some cases we or the majority
of cases we we always try to kind of
mimic closure in the the namespace names
that we have so there is closure dot
string and closure dot set in closure
script but in some cases and because in
closure skip macros are written in
closure we needed to reach for
namespaces of the kind c LJ s dot
because otherwise the the namespace
would be taken right if we want to write
our own closure not test there's already
the the possibility they are closure dot
test from closure will be in the class
path so there's a namespace collision
there which promised you know to do have
to call it C LJ s test or C LJ s thought
spec clgs core not async and so in 2016
we have the support for a kind of
automatic aliasing of of closure to see
LJ s and so you may now write require
closure dot tests and the closure
compiler will know that your in reality
requiring CL JSF tests and it is the
that namespace automatically for you
this is really really cool with a not
yet another feature that we also add a
support for which is implicit macro
inference unloading and so before in
closure script there was the necessity
to sometimes use refer macros or include
macros this is no longer the case
because as of last year we can we can
now infer that your that a namespace has
macros and load them automatically for
you so if you see there at the bottom
when we put it all together and you if
you're writing AC ljc file you don't
need to write reader conditionals
anymore in your namespace declaration
and that is really cool and so 2016 was
even was the year where we need even
more enhancements and so require refer
closure import can now be optionally
left out of the NS form
in a way that you either have an ass
form or some require import statements
and this was something that was not
previously possible because of the way
that the closure compiler expects the to
know about your dependencies it all
needs to be very static and so these
this is what allows scripting for
example in a automatically inferred clgs
the username space it allows for
extensible data reader support which was
not previously in closure script and
once we once we added that feature we
adding adding their readers enclosure
scrip was just was trivial with it we
also deleted a bunch of ugly useless
repeal code there was a major hack just
to make requires that the rap will work
and so we had a first-class support for
require Island DNS form so rebels just
work automatically and that was pretty
cool so which leads us to 2017 and this
has been really an exciting year this is
the github contributions graph for the
closure script compiler project so you
can see there are three activity spikes
in this graph and the first one is the
initial release in 2011 the the second
one is when David put together self host
the bootstrap compiler and the the third
kind of spike with the most activity is
just this summer when we added node
modules and in hence the coast plating
support and I mean this is really
exciting and we added a bunch of
features this summer and for every
feature that we we add we try to really
replicate it in the the self hosted
compiler so they're always at feature
parity we also got closure script
running on CI now which was something
that took six years but I mean it's
there now it runs on both Windows and
Linux and if you're wondering yes I did
choose a screenshot that makes this look
good all the ticks are going there do
you know it's been really useful to
catch some some mistakes and oversights
and so I so let's dig into a little more
and I really want to speak about the
coast playing support that we revamped
this year as far as I said code
splitting is really extensively
discussed nowadays in the world of
browser applications and it's a way to
basically improve improve parse compile
render what they call time to
interactive times in applications that
need to run on so networks and low-end
devices and Peter Cook gave a great talk
about some closure script topics last
year at closure West this year in
closure West and in one of the topics in
his talk was demonstrating how to code
split a clutter script application which
was a little bit complex at the time
just like we'll see in a little bit and
he even put together a like his own
library for helping people do that so we
went ahead and we we made that part of
his talk completely obsolete by changing
how could splitting works in the closure
compiler but it's it's for the better
and so we'll see about we'll see you
about that in a little bit so the the
the faculty related to code splitting
before was really I mean it made a lot
of people afraid of touching it myself
included I never touched it before
because it's just just a dragon I didn't
want to slay and so the the faculty with
it and so this is the the the previous
were the the way that worked previously
you had to manually assign namespaces
that you want to become part of your I'm
gonna call it chunks instead of modules
not to confuse it with JavaScript
modules that I'm gonna speak about later
so even even if you did all this
correctly it's it was still very hard to
guess the correct split points and then
in most cases you'd still have to
inspect the resulting resulting
JavaScript chunks verify that the splits
were good it was too cumbersome and
you'd still run the the huge risk of
having everything end up in the what we
call the clgs base module which is the
the common module that always generates
some of the the core library things and
the core runtime and so this is how
module loading or chunk loading worked
before you have to manually assign a map
of IDs to URLs can I have the put your
own module information together and
assemble a module manager that loaded
your module call a bunch of exotic
functions inside the Google closure
library and I'm not generally in favor
of showing things or showing the wrong
way of doing things but I think in this
case it helps to visualize how radically
different we we made up this module
support also you can't really do it this
way anymore so it's so we really
enhanced the way that code splitting and
chunk loading works enclosure script as
I mentioned but I really wanted to show
this slide because closure skip now has
a blog and so thanks to Alex Miller for
setting it up for us and we now write
about it on on every release and every
major change change that we do we have
to do the compiler and so David wrote
about and Hank goes plating and loading
and this is what I'm and this is the new
way of doing things so you you no longer
have to assign particular namespaces or
a list of namespaces to to your chunks
you just add the your entry point really
really the the namespace where you think
you'll so what let's talk about a
concrete example right so you you have a
public page in the private page right
the the the your landing page in you
don't need to be shipping code that is
only for your part of it for the users
that are logged in your website if
you're just showing a landing page right
you can just load that lazily later if
say a user registers to your website
right and so do you just need to put the
entry points in there and the
assignments are automatically calculated
and it also by having first class
support right for a kind of a module
graph inside the closure compiler it
enables a bunch of other cool
optimizations and tricks such as you
know splitting a vendor bond the vendor
bundle entirely entirely so in this case
they say we were using a popular
front-end framework and for closure
script and we put that in the as the
entry point for for our vendor module
and so if that framework happens to use
react or react Dom all those namespaces
will get automatically pulled into the
vendor bundle which is now separate from
the rest and common from the rest of
your other code and it prevents it to be
put into into the the base module even
another one that David told me about
that which is really really cool notice
that at the bottom of this slide there's
a a common chunk which has no entries at
all
and what what this allows or if you have
a a common chunk with no entries and you
have a bunch of other chunks depend on
this this kind of orphan chunk what this
will do is it will pull common code
upper in the dependency graph right and
you let closure script do all the work
for you and in this case the common code
between the home page and the about page
and only that common code will be put in
the into what I call the the common
chunk and this was kind of a
mind-blowing for me it was I find it
really cool
so enhanced code splitting is or module
loading is module loading is also
enhanced for greatly enhanced and this
is how easy it is compared to the other
two code slides I showed before this how
easy it is to wire up Co splitting and
module loading and enclosure script app
today you you because we have all the
information about the modules the the
chunks in
in your compiler options we the closure
compiler can just already knows what
what are what module information you
have and so you don't need to write it
down in two places so we provide we now
provide a clgs not loader namespace
which you can use used to load some
chunks and I we also added a clgs core
resolve macro that I want to kind of
detail here so we need to use this
resolve macro when loading a chunk
because otherwise if we were requiring
in this case it is my project on about
page if we were requiring that namespace
right in our namespace declaration it
would end up as part of our the current
chunk it would not get split in the
current chunk because because we would
be depending directly on it so resolve
is kind of a rerun time resolve that
allows you to to resolve the the var
that you're trying to call so in this
case we we call a loader load about page
and this keyword is the exact needs to
be the exact same ID as the one the the
chunk ID that I declared in my compiler
options and so I I pass a because this
is a synchronous I pass a callback to
load and say when you're done loading
this this this chunk please resolve my
my render function and call it so I
think this is really cool and much
better than what we had before if you
want to read more about code splitting
in the Google closure compiler I
recommend this book it is it is a little
I think it is from 2011 but you know
that's as far as code splitting and
module loading goes in the Google
closure compiler and so it's still up to
date with regards to that because
support existed back then which leads us
to the the next topic of this talk so
let's talk about the JavaScript
ecosystem
so so currently in the world there are a
lot of JavaScript developers and we we
don't wanna we don't want to be isolated
in our own lonely closures island in
some cases we want and in other cases we
really need to interact with JavaScript
library works and and so this year we
really built on the the support that
Marija added in 2015 the JavaScript
module support and we delivered on the
promise of making this much much easier
and to consume so thanks to her work
thanks to you no further enhancements in
the Google closure compiler we now have
the ability to just take arbitrary npm
modules from node modules installation
run them through the Google closure
compiler and use them seamlessly in our
closure script projects as if they were
regular closure script namespaces and
you will see an example of this later in
there these JavaScript dependencies are
not are really not foreign anymore to
the closure scrip and compiler because
Google closure now understands them and
we'll see how we can use we can even
like refer them in our namespace
declaration so the way we did things
before with these dependencies was just
to bundle everything together
consume them through a foreign leaves
entry in compiler options just in clj
SJS which is a project that aggregate
that aggregates a bunch of popular
javascript libraries does it this way
right it exports or it gives you a bunch
of jars that that export that give you
foreign dependencies packaged together
in a way that Google closure does not
understand so what we need what do we
need in closure script or what what did
we need for for a modern Interop story
and what we did we need to put there in
the compiler so that you can take
advantage of that today and so I really
want to go through how how do how do we
consume NPM modules in a way that Google
closure understands in order to
perform sophisticated optimizations how
do i integrate javascript sources in a
closure script project even including
JSX which is a popular way of writing
kind of HTML in your JavaScript that
transforms to react virtual Dom elements
and this was a concrete example that we
heard at Euro closure 2016 we talked to
to a company in which their designers
they were really familiar with with
using react and JavaScript and JSX but
they couldn't get into you know kind of
hiccup hiccups in syntax for for for
closure scripts such as projects such as
cebuano and reagent allow you to write
kind of these react virtual Dom elements
as vectors of keywords so just using
plain closure script data structures and
so the designers couldn't couldn't get
into that so they they were asking for
for an option of integrating that
directly in their closure scripting
spaces because the way they were doing
it was just bundling everything together
and consuming a foreign dependency of
their own code which shouldn't be
foreign so how do we consume NPM modules
today well you you add an NPM depth
entry to your compiler options in this
case I'm I'm saying my project depends
on react and react Dom and notice how we
we can just require react and react DOM
and alias or referred these modules as
as if they were so we're really treating
NPM modules empty they were as if they
were regular closure script namespaces
because it just works closure Google
closure is now aware of it we also allow
the support for a couple different
module import patterns so sewing in when
you're requiring JavaScript modules
sometimes you need to reach them through
through a path
which which can can contain several of
slashes and those those are not valid
symbols in closure so we relax the
constraint that require only take
symbols in order to make these requires
with you know arbitrarily nested four
slashes work and in your namespace
declaration and they work just like
you'd expect them to work we also added
the ability to resolve required modules
as variables and this might seem kind of
weird but there's it's a necessary evil
that it that is required because there
there's a module export pattern so
normally if you have a JavaScript module
you can export a JavaScript object and
we can understand that just finding you
can alias that you can refer to modules
in that two functions and variables in
that namespace as if they were closure
script namespace but in some cases
modules decide to export a single
function and we had no no way to reach
for that without making a resolve work
with the the namespace that you're
importing so how do how how do we
integrate with JavaScript sources right
we know how to require modules in our
closure script namespaces so how do we
require JavaScript sources that may or
may not be in our project so the way you
do it is through the old foreign lead
style we know about this this is so in
this case you we had a support that you
can now pass a directory to for to a
foreign lips entry and say this this
directory provides this namespace and
you can require that and we will we will
kind of track what JavaScript modules
that that that directory or the modules
in that directory require we will go
pass them through Google closure
and everything would work like just just
like I've been showing yet another cool
thing is babble and other JavaScript
compilers are very popular today in the
JavaScript ecosystem so in your foreign
leaves entry you can now add a pre
process keyword that refers to a symbol
that will resolve at runtime and so with
this you can declare a namespace which
has say transforming functions that will
take pre process that will take raw you
know JavaScript or JSX or anything that
Google closure doesn't understand it's
it's up to you like calling to Nass horn
or call shell out to know J has to
transform those say using Babel you know
an interest from them to JavaScript at
the Google closure compiler can
understand and I'm really really pleased
to say that we we're trying to do this
with the the least amount of breakage
possible and so this might be kind of
weird to explain but the though if you
bundle everything together in a single
in a single bundle like you're like the
like we you we used to do before say say
you have a react and react Dom huge
bundle run through you know browser
browser a file web pack that provides a
react global variable but now you want
to migrate to the new module support we
provide you a migration path through a
keyword called global exports so we can
say so here's here's my my react bundle
and it has the the react with capital
our global variable and so we we tell
the closure compiler please be aware
that this global variable really is like
when I'm requiring the react or sale jsj
s react namespace this is really
referring to that global variable that
we have and so in this case aliasing and
refers work as if there were a npm
module and i'm really excited about this
because this will allow library authors
to provide a clear migration
path from the current way of doing
things to module support in a way that
is similar for application developers to
to upgrade so kind of circling back a
little bit what can what can closure
script do for you in 2017 how can you
take advantage of closure script today
in order to build your applications and
my stance is that we have I think we
have if not everything at least almost
everything that we need so we can we can
require a closure script dependencies
just like we did we can reach to the
wider JavaScript ecosystem integrate
with popular package managers such as
NPM yarn we're no longer stuck in our
own eyeline we have code splitting
through Google closure with first-class
support for four chunks and this is
really important as compel if we compare
to mainstream tooling in the the
JavaScript ecosystem in which you kind
of define your split points inside your
own code through magical import
statements we include in the closure
script world we have the ability of for
defining first-class chunks through our
compiler options that that there are
really that you can then load at runtime
you can explicitly load a chunk instead
of putting a magical key word or or
comment in your code so Google closure
is a very sophisticated project it also
provides you what they call cross module
code motion and what this is is if you
if your namespace happens to be part of
a chunk but you're using a single
function from that namespace in another
one Google closure knows how to move
that single function from the first
chunk and all its dependencies to the
second chunk in a way that it so both
modules or put it a better way it
provides better locality for you for
your code
so we can target the web we can target
nodejs we can target platforms such as
react native we can this I think the
self hosted compiler can even go further
so I'm really looking forward to the day
where closure script can go to outer
space because if they are using nodejs
for the NASA space suits
I think closure script can one day be up
there too thank you
we have time for questions does anybody
have any question there's there's no
story about publishing to NPM if you're
if you're developing closure script I
don't think it's particularly useful to
to ship your your closure script code to
NPM this might change one day with
things like lumo and I'm actually
exploring that possibility myself
because now we have something that can
have first-class support to reach for
closure script coding node modules but
there nothing exists like that today
so the question was he's done a little
bit of react native development in it
was saying that the react native
packager is a little bit weird in the
way and in a way that it runs after the
closure script compilation process and
if there was another way of hooking into
that process is that there's a question
hooking into that process in a way that
doesn't mess with the react native
packager that provides a better support
nothing that I'm aware I'm not familiar
I'm not very familiar with react native
echo system I know there is a turn ative
project to the packager which runs with
webpack i think in that way you could I
mean you'd still have to run the the
closure script process but then you
you'd kind of you could bypass the
packager and run your code and bonneli
through a pack and serve it to your
mobile simulator yeah
that's that's a great question I also
didn't talk about extra names inference
which is something that was added in
2016 so you can now add I'll answer so
the question was does this solve the the
exchange problem and in most cases it
does but we have no control over what
javascript libraries do and in some
cases they use a very dynamic code and
generate functions and variables at
runtime there's no way for Google
closure compiler which is a Java project
that performance static static analysis
on JavaScript to know that you're
generating those variables at runtime so
externals might still be needed in some
cases and kind of circling back to
extremes inference you can now add a
kind of type hints like you do in
closure to your closure script code and
have the compiler generate experience
automatically for you I think there's
also a blog post about that yes
the question was I've got a JavaScript
module and I process it through closure
required in my closure script namespace
does it gets into the Google closure
compiler for advanced optimizations yes
that's that's that's exactly what we
gained we now have the ability for
Google closure to understand our code
and perform sophisticate optimizations
and that code elimination on javascript
sources that were previously foreign
yeah
yeah the the NPM support is about
consuming not publishing
I I don't I can hear you very well can
we quit we can speak about that later
awesome thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>