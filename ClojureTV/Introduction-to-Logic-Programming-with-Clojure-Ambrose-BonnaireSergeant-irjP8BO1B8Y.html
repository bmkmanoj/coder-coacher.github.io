<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to Logic Programming with Clojure - Ambrose Bonnaire-Sergeant | Coder Coacher - Coaching Coders</title><meta content="Introduction to Logic Programming with Clojure - Ambrose Bonnaire-Sergeant - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to Logic Programming with Clojure - Ambrose Bonnaire-Sergeant</b></h2><h5 class="post__date">2013-01-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/irjP8BO1B8Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so far today you've seen the caliber of
the average Alabama high school student
and the the caliber of the average
marketing guy in the scala community and
now you're going to find out what level
of ability it takes to not yet qualified
to graduate from college in Australia
this is Ambrose Binet our sergeant he is
completing his degree at the University
of Western Australia and this is his
first time in the United States this is
his first time ever meeting another
closure programmer in the flesh how cool
is that
and he's going to be talking to us about
logic programming which is an amazing
catch fire part of the closure world
right now it's it's so exciting to have
crowds of people who are jumping on to
logic programming and on the work that
he's done with tutorials and the work
that David Nolan and others have done
with core logic so thank you Ambrose and
welcome okay good yeah okay so who's
done any logic programming here their
hands sorry
how about Cortot logic anyone looked at
that no yes cool and then did anyone
write mini Cameron yeah oh yeah
so we have a special treat here this
year we've got Friedman and bird dan
Friedman and William Byrd and they've
got something really cool they want to
present their constraint Katerine and if
you get anything out of this talk make
sure you go see them after I think it's
tonight at 6 o'clock so yeah follow them
around they'll be presenting their
latest project sorry logic programming
so what I'll be covering here I'll be
covering some fundamental logic
programming concepts which you can kind
of see as an extension of functional
programming and so I'll be
making sure we all understand what what
we have already with functional programs
so and then we'll cover what general
implementation characteristics a logic
programming has a logic programming
language has and we'll use that
information to gain an understanding of
the execution model of Cortot logic so
what I got here on Monday night and a
lot of people were like great up I've
tried Cortot logic but I have no idea
what what is going on I can see that
this is happening but why so I'm I'm
trying to cover that kind of ground so
in function programming we have our pure
functions so some pretty obvious things
but they're worth pointing out functions
always have one value they're what we
call deterministic so yeah we always get
one value for our input arguments
another fairly obvious thing which seems
odd to point out is that functions only
work for one pattern of input and output
arguments so what do I mean by that so I
basically mean that the inputs are the
arguments or the parameters and the
output is the return value and that
seems pretty fundamental of something
like a function but okay so functions
they seem like they can do everything
but sometimes the inappropriate so look
at this interesting problem here
normally when we have a square root
function in language we get I think is
the primary root Bell is it the main
root so here we were asking the question
well we we say that four has two square
roots positive to a negative two and to
represent that return value with a
function we have to return a list of
values so it's kind of a bit of a hack
if you think about it it's an
interesting thing to think about and
even more interesting is that if you
divide a number by zero that it really
yields no result and another kind of
hack is to you know throw an exception
so these are the types of things that
are interesting when we look at um
functional logic programming because
when we introduce a relation a relation
can return any number of results or it
can generate any number of results as
we'll say and so any number zero or more
so it covers the cases of looked at
and that behavior is known as
non-deterministic behavior so we're not
always returning one result we don't
really know how many results a good
return and the pattern of input and
output arguments or a relation can be
different for each call so the the
parameters are no longer just for input
they're also for output which is it's
interesting it sounds pretty evil but
we'll see how it works so concrete well
kind of concrete definition of a
relation in mathematics the expression X
R Y is true if x and y satisfy the
relation R so let's see this X is less
than Y so there are always this less
than relation can be considered so this
first way we can consider it as a
generator of the infinite set of XY
pairs which X is less than Y so if we
think of XY as being as outputs here so
it can generate all these outputs so if
we if XY are both inputs if they're both
ground values or numbers and I'll define
that later on we can use it as a
predicate we can say X is less than Y
and we also have the two more specific
cases of generators if we give an X
it'll yield all the values of Y that are
greater than X and vice versa so just
syntactic ly if we want to can we want
to convert a function to a relation
there's there's one main thing that that
we have to look for so you can see here
that we always return well
conceptually we return a boolean value
from a relation a relation will either
succeed or it'll fail so in my little
made-up language this this isn't caught
on logic by the way this is just my
illustration that what relations can
succeed or fail so a relation returns
true if the relation is true and false
if the relation is false so you can see
that we've lost the ability of treating
this as an actual value so as a as a
return value so what we do is we move it
to an output parameter
so what's that funny-looking
oh that's superscript oh so basically it
showed it tells you that that is a
relation it's a cons relation so one
example of using this cons relation is
that it is as a predicate so if all the
arguments are ground values so if
they're not variables we can use it to
see if a head and a tail head cons onto
a tail equals the return value so you
could describe the cons relation with
this kind of documentation screen it
kind of it's like a constraint so we say
for the cons of head tail and result
konso returns true if head cons onto
tail equals result so head cons onto
tail equal result true head cons of the
tail no so that's false so another use
of konso is as a generator of values so
here we've we have to introduce the idea
of a query here because we're we want to
know the value of a logic variable after
after execution so the idea is that this
this argument here is our output so the
relation will fill in any any arguments
that need to be filled in such that the
relation is satisfied so to satisfy this
particular relation so the head head
cons on to the tail equals that so what
the konso does is it generates it
basically binds X 2 this value here now
this is the actual value here but what's
with this this list of values so this is
how we represent a non-deterministic
result so we can remember relations can
return zero or more results so what we
need to present it in some way and this
is how we can do it and the way we
control the number results we return is
if that number the solve one so you can
read this as give me one value of x such
that the cons of one and the vector of
two equals x
so let's go back to our square root
example here's an example of a relation
that will generate two different values
so we say that
give me two values of x such that the
square root of four equals x and we can
see that we've got our two results here
all right so how do we implement this
song so logic language usually calculate
0 or more results so this is this seems
more flexible in the most traditional
languages so it's non-deterministic so
the execution strategy must be more
flexible so basically it's implemented
as a search we search for an answer do
we have enough answers no let's go
search for more do we have enough yes
now now we return so the first thing to
understand with an exit with the
execution strategy of a logic language
is this concept of a branch or a choice
point so a choice point groups together
a set of alternative statements and if
visualized as a tree they are the
branching nodes so you can see that the
red root root node there is basically a
branch so it's like a conditional in a
conventional language but we'll see how
it differs and this is similar to a
conditional in that if an alternative is
found to be wrong later on then another
one is picked so if we go down a branch
and we see it's wrong then we choose
another so it's kind of similar to the
conditional release do so how do we say
that a branch is wrong so we have this
concept of a failure so each node each
node we have here is a separate
statement you can think of it as a
relation each one of these is a relation
so if we come across a relation that
represents this failure statement then
this whole branch can be considered
wrong or false and or at least you don't
you don't care about it anymore so you
might as well get rid of it so what do
you do when you come across the fail
point so that indicates we backtrack to
a choice point and try another
alternative so we go back and then we go
back down and find another alternative
so what happens if we don't come across
a failure so if we get to the end of the
branch that represents one valid result
or if we come across a leaf node and
that contributes one results to our
non-deterministic result so remember we
we represent our non-deterministic
result as a list so that'll be one entry
in our list so if another result is
requested we've backtracked to a choice
point and execute another alternative
statement and of course we do this until
we we've satisfied how many results you
want so remember we said solve for two
values of X give me two values of X so
we see we've got one value two values
alright that's good enough
we won't go down the third branch
alright so one one way to to approach an
implementation that does this is is with
encapsulated search so relational
programs so what I mean by relational
programs is a logic program consisting
of purely relations and they can
potentially execute in many different
ways and we want to be able to control
which choices are made and when they are
made so one way we can control the
choices that are made is controlling the
search strategy so before we saw a
depth-first search although it wouldn't
really matter in the last example but
you can think of other search strategies
so your normal breadth-first search and
and there are some other ones that are
particularly useful in logic languages
and you also want to be able to control
the amount of results because if you
imagine if you asked remember the less
than relation it generated the infinite
set of numbers that X are less than Y so
unless you can put a cap on that if this
is fairly useless so yeah that's a
requirement so one approach to this is
to execute a relational program with
encapsulated search in a kind of
environment which controls which choices
are made and when they are made and
another another requirement is that it
protects the rest of the environment
from side effects of choices so
basically what I mean is if you go down
a branch you don't want the side-effects
of one branch polluting the other branch
so you we want to be able to go back in
time and undo any any bindings that are
made to logic variables so one one way
to implement this is with a extremely
functional approach so we can protect
from the effects of choices by
representing states by a substitution so
we can protect from side-effects so it's
basically this pattern of putting state
through via functions instead of having
global state so a substitution is like a
list of identity value pairs for logic
variables so it's like the variable v
has value 1 or the variable a is unbound
so it's just it's a world it's a
snapshot so how do we get these states
so we have these these things called
goals and you can think of them as the
next state functions so what goals do
they take the current world or a
substitution and they return a lazy list
of zero or more substitutions and an
integral ation relations are usually
implemented as goals so we can control
which choices are made by different
monadic strategies and these are best
visualized by search trees and they're
extremely extremely hard to get your
head around I certainly have not and you
could you know give that first search
and that's this idea of interleaving
search as well which is it's just good
to know that it exists once you get used
to logic programming it's it's good to
get back to this concept but and this
idea of controlling the number of
results say I want to valleys of X so
that is if everything is lazy you just
say ah give me give me three results and
you just take it and yeah so that that
would be the approach that it's inclin'd
implemented with laziness so I think
I'll just have a drink
so we've seen enough to check out some
Cortot logic and might make some sense
out of it so one of the things that
characterized caught logic
so it's non-deterministic we can gather
0 and more results it uses substitutions
which remember was the estate
represented as a snapshot and it uses
goals to get our next states and it's
it's that whole monadic
functional implementation that I I kind
of hand my hand way of my way through
and two things you need to know is that
queries are done it's not the solve form
that I saw before but it's run and
another quirk is that if a variable is
unbound at the end of execution is it's
represented by one of these funny
underscore dot incrementing integer
things so if you see one of those things
it just basically means say we wanted
two values of Q and you come across one
of these underscore dot zero it says
that Q is unbound at this result and
we'll see what that means so there are
two fundamental goals succeed and fail
and succeeds fairly easy it's like a no
op or no operation it doesn't do
anything all it basically does is pass
along the current state so you give it a
state and it just pushes along so if we
visualize the the flow of substitutions
by a tree we can say the initial
substitution is is the world where Q is
unbound because remember we have our our
Q so basically a query implicitly
initializes that Q to an unbound
variable then we come across our succeed
and it's a leaf node because there's no
more goals to execute and then we come
across our leaf node substitution and
great we've got one value we don't need
to look for anymore and the reason that
this is underscored zero is that this
will be unbound and if we look at the
fail and rather fail indicates that the
branch is wrong so we've got the same
idea here initial substitution is where
Q is unbound we won't we go to our next
statement and it's a fail so our current
branch is wrong so what do we do we go
back to our last choice point and and
execute the next branch but obviously
there's no branches here so basically we
just there are zero results so we cannot
we there are no values that we can
extract from from a run so a very
important goal is unification this
equals equals function is not the
closure dot course slash equals equals
it's it's pronounced unifier and it
basically it takes two arguments and so
unification answers the question what
must the world look like for the left
and right arguments to be equal and if
it can make the left and right arguments
equal it will find the next world
the next snapshot such that both are
equal
so you can see in our run we want one
value of Q such that one is its unified
with Q so we come across this an initial
substitution Q is unbound and we asked
what must the world look like for one to
equal to Q and then we come across our
leaf node and what unification does is
it spits out its the next world state
where Q is equal to one because that is
a world where the left is equal to right
or 1 is equal to Q and you can see it's
kind of like assignment except it
doesn't matter because it's more general
than assignment so how do we introduce
more than one logic variable so we have
our 1 logic variable from the query our
say query logic variable so we also have
a goal called fresh and it's basically
syntactically like let accept it it
doesn't have pairs of things it just has
the names so and it basically it's like
let it's it dealing limits the scope of
the logic variable and if you come from
Prolog this is kind of
it's like because in prologue to
introduce a new logic variable you just
give it you start off the logic version
you just start off the name of the
variable with an A oh sorry a capital
letter and you can see this is kind of
seems a bit lower level but Daris I'm
not really sure I won't go on about that
I would pretend like I know anymore
but yeah it's a similar similar idea so
how do we define
choice points so cond e is syntactically
similar to schemes cond
so what closures con does is get rid of
the redundant grouping parenthesis
around add the question and the answer
of each Clause but conde is special in
that it can have multiple answers so
suddenly the grouping parentheses aren't
redundant anymore so we can have yeah so
the idea is that we can have one exactly
one answer one question for each Clause
and zero or more answers so here's an
example of a slightly involved execution
so let's look at the true representation
of what we're doing so basically you can
think of
we're always executing the nodes of the
branches on the left first so what
happens is we get to the our red choice
point we go we choose our first branch
and we haven't come across a failure so
if we get our leaf node great
one out of two results so we we have we
need to so we go back to our last choice
point we go down the next branch look
it's a failure so it's saying that this
branch is invalid so we go back to our
last choice point we go down the next
branch and we come across our our next
answer and we say great we've got two
out of two we don't need to execute
anymore
so if we follow along with this
conditional you can see that here is the
first branch this is the next branch
this is the next branch and this is the
last branch so the first branch unify is
q1 and you can see that this accounts
for this one here because it's a leaf
node you can imagine that this is a
substitution that Val combines Q to 1 so
we extract the value of Q from the
substitution and here it is
so we backtrack go to our next branch
the question is succeed that's not a
failure so we'll keep on going and that
we come across fail so this tells us our
whole branch is wrong so we backtrack
and go to succeed sorry it would go to
the next branch and this is where we
find our next our next answer so here we
have 2 out of 2 and you can see that
remember succeed is it does not change
the current environment so this accounts
for the unbound the the unbound value of
Q so remember we want the value of Q at
at this point and because it hasn't
changed this is the answer its unbound
so here's some real code in court logic
and I've done something kind of quirky
I've represented numbers as lists so you
can see I define 0 as 0 and 1 as 0 with
a with a list around it and then you can
imagine 2 is 1 with a list around it and
oh sorry yeah that's right so I'm going
to use this representation to illustrate
some to walk through some code so you
can see we're using our successor well
I'll explain the implementation first so
the successor function takes a previous
number and the next number of the PNN
and you can see it has a doc string
which is very much like a constraint P
and then a natural numbers such that n
is the successor of P and the reason I
say it's like a constraint is because if
this goal succeeds you can guarantee
that this this doc string will be true
so so if it doesn't right if if the goal
doesn't return false then then P and n
will be natural numbers and then the end
and will be the successor of P right so
you can see this in action here we're
saying I want one value of Q such that
the successor of 0 is Q and that
relation is true when Q is 1 so you can
rather in your mind remember this
represents our non-deterministic results
so there's 1 value of Q so we've got 1
here and we can use this backwards which
is pretty cool we can say give me 1
value of Q such that a successor of Q is
1 and of course that's when Q is 0 so we
can use this successor function to
represent all the natural numbers which
is all the numbers from 0 and positive
so the constraint our docstring says
that x is a natural number so if the
goal succeeds that means that x is a
natural number you can you can bank on
it so if we look at the implementation
you can see there are two branches the
first
French is our base case where X is zero
and the second branch it says there is a
number called previous such that
previous is a natural number so you can
see that this is the recursive case and
you can imagine we keep on going until
we get to where this is one and then
sorry when previous will be zero we'll
get to our base case so it's it looks
similar to the code we've seen before
like structurally so the way to use this
natural number we can use it as a
predicate we can say does remember this
is the list of zero and we can say give
me one valid for value of Q such that
one is a natural number and that doesn't
you don't need to change the world so Q
is unbound so that's successful now this
is interesting
give me six values of Q such that Q is a
natural number we've got zero one two
three four and five so we're going to
see how this works so we've got our
representation of the current code here
the actual code that's being executed
and I've just highlighted the the
current branch we've taken in orange and
the current result that we're accounting
for I have highlighted in an orange in
that box so this this one's the easy
case this is the the base case so we
basically come across our choice point
and we we go down our first branch and
it says unify Q is 0 and Q is Q is
unbound at that point because if we look
at the query at the start of a query Q
our query logic variable is unbound so
we the way to unify Q is 0 is by binding
Q to 0 and you can see if we look at our
tree that is a leaf node so we've got
one answer so what do we do when we come
across an answer we say have we got
enough answers no we want six answers so
we backtrack to our we go back in time
to our last choice point
so if we go down our other go down the
other branch remember there was a call
to natural number all this is I've just
expanded out they called a natural
number and it should look familiar is
the base case and the recursive case so
what's happened we've come across
another choice point so we take the
first one which is the base case so this
is this is interesting we say that
remember Q is unbound at this point
because we've gone back in time where
we're now we're now at this successor
node here which is success of previous
equals Q now Q isn't isn't anything Q is
just unbound and previous isn't anything
either so we're just kind of remembering
that okay we know that there's a
relation between previous and Q but
they're both unbound at this point but
if you can see our next goal says that
we unify previous with zero so we've got
some more information previous is zero
so therefore Q is one and that that
accounts for our second answer where Q
is 1 so we can repeat this exercise and
you can see that there are now two
successes the first successor says that
previous is the number of before Q then
we say previous is the number before
previous two and now previous two is 0
therefore previous is 1 and Q is 2 and
that should be the third answer with it
we get and you get the point
so the Restless talk would just be me
having a bit of fun showing you
something cool so this is I think David
Nolan worked write this and he got it
off some old prologue oh no it was a
Stack Overflow answer there was just
randomly this implementation of this
type checker and David sort thought it
was pretty cool and he implemented you
know in an impure style so we couldn't
we couldn't do what I'm about to show
you so I kind of I tested him and he
gave me this implementation so I could
play around with it
so this is a type checker for the simply
typed lambda calculus so all you need to
know you about simply typed lambda
calculus is that a function takes
exactly one argument so if you want a
function with two arguments you take a
funky you take a function with one
argument and you wrap it in another
function that takes 100 so the main the
engine of this type checker is this type
do so you'll see by the end why it's so
hard to name these things like I'm just
going to say this is type determine oh
that's good enough so we see the the doc
string says that context is an
environment such that the expression X
is executed in the environment context
and that results in type results hype so
that's a bit probably easier just to see
an example
so we can use this type checker as a
type checker obviously because that's
what it is first argument is an
environment and the way you read that
environment F is of type it's a function
takes an integer and returns an integer
and there's also another entry in the
environment that says G is of type
integer we have our expression which is
in blue and I just made up well I guess
David made made up a arbitrary syntax
for function application just have a
vector say apply F to G and that's
basically F is the function and G is the
argument and this third argument is the
type that we want the the the expression
to to be so if if this goal succeeds
then apply FG in the context of that
environment will be up type integer and
if you follow it through that's true
because F first argument is an integer G
is an integer
you know F returns an integer and you
can see that we don't need to modify the
value of Q and the the goal succeeds
anyway so we get this funny unbound
thing so what happens if we get rid of
this integer here and make it and put an
unbound logic variable so you can see
now you can see the utility of relations
being able to treat arguments as inputs
or outputs so we're basically saying
give me one value of Q such that apply
FG in the current environment is equal
to Q and we've already seen that the
third argument has to be an integer so Q
is unified with integer somewhere inside
the skull because remember the
constraint of this goal said that yeah
I've said it a million times but the
expression executed in the context in
the environment equals BR the type
oh he's uptight that type and Q has to
be of type integer for this to succeed
and we only asked for one results so we
only get one result now I'm pretty sure
there's only one result anyway so this
is kind of crazy we can this all this
stuff I'm in showing you is the same
same goal same relation you can see why
it is so hard to name this thing because
it's not a type checker we've seen that
it's not a type inference it's not just
the type inference because look at this
we can we can substitute our expression
our second argument with an unbound
logic variable and ask give me an
expression that when executed in the
context of that environment is of type
integer and we want four of these things
sorry
look what we get we get four beautiful
expressions that are of type integer
the first one is G if we go back to our
environment you can see that G is an
integer the second answer we get is
applying F to G and we've already seen
in that that is of type integer the
third the third result we get flying F
to G apply F to that and that returns
into fourth one by F to G after that
after that you can see pretty quickly
that there are infinite results here so
it's a good thing we're in Aus for or
wouldn't have anything to show on this
slide
so there's one more thing I can one more
place I can put this logic variable I
can say how how can I extend the current
environment such that applying A to B is
of type float and this is probably the
only bug that has brought a smile to my
face so this is a pretty cheeky bug so
clearly what's happening is that our
type inference doesn't really understand
our syntax very well it's basically
saying that if you want the expression a
B to equal float just put an environment
entry and environment where the
expression a B is equal to float so I
thought that was worth including I'm not
gonna fix it it's great and we get an
actual legitimate one so if you can
imagine that Q is substituted with this
environment rehear we say B is of type
integer and if you put this in here we
can kind of follow it all through a is
of type integer to a float if B is an
integer and it goes here then we get
back up float and float goes there
so who's who's seen this book who's read
at once who's read it twice I won't ask
you write it but they're just over there
yeah this is this is a mind bender but
if you want to check out more of this
stuff this is definitely the first place
to go it's the reason that schema it's
part of a series of books by Friedman
that Dan Friedman the the first one is a
real classic cold little schemer it
basically addresses recursion and Dan is
a really funny guy very cheeky and it
brings a smile to your face that every
everyday cheater
it's it's fantastic and there's another
one called the season schema I think and
the little was it the Java one I forgot
a little Java stomach yeah all amazing
books I haven't read that element and no
one and if you just want to get started
with CoreLogic
just google logic starter closure and
you'll find a tutorial that's actually
quite a good I know that that tutorial
actually plays around more with with
that type checker so yeah that that's
about it thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>