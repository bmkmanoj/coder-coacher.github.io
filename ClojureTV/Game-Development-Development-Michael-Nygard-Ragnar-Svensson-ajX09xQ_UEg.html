<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Game Development Development - Michael Nygard &amp; Ragnar Svensson | Coder Coacher - Coaching Coders</title><meta content="Game Development Development - Michael Nygard &amp; Ragnar Svensson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Game Development Development - Michael Nygard &amp; Ragnar Svensson</b></h2><h5 class="post__date">2015-11-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ajX09xQ_UEg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hi everyone and welcome to this
presentation about game development
development so it's it's not really a
typo it's like a matter thing we do at
King to improve the lives of our game
developers so I work at King a game
company and so for this past year I have
been working together with Mike on this
project and I'm before I will move into
what we have actually done I would like
to give you some context and background
in case you're not familiar with game
development so I would like to demo this
engine that we make it King called the
fold it's not eclipse
it's the game editor you're seeing here
built on Eclipse using Java and this is
also publicly available so if you are
interested contact me afterwards and I
will set you up with access for it but
so here I have opened a game so you see
the game files over here to the left and
I can just from this editor I can start
this and so this is a game biking that
was released two weeks ago or so so you
see the game is now running inside of
the game engine so this is a different
program it's the implementer in C++ so
it's faster and easily more you know
cross-platform and these things so I can
come back here into the editor and
inspect the files so it's similar to an
ID but it also has this ability to to
let me see what I'm working on so the
the key thing here is to let the
developer see instantly what they make
the effects and so on so I can also load
the GUI file here so this is the top
layer you see here and I can also come
in here modify it change that and now
you see that it's updates in the game so
this would also work if it's running on
a mobile phone or something so they're
the real thing here is to let everyone
be as quick as possible and
interactively make their games and of
course a game consists of many many
files data files source files and so on
so the problem here in this editor is
really to check all these dependencies
and make sure that whenever a file is
changed that the using files are changed
and so on so that's a big thing of this
this problem so this talk is not about
anything I'll kill that it's about this
software so it seems to be working it
seems good
people can use it to make the games and
you can shape the games and so on so
that should be good right well now it's
it's not really good for us who makes it
and I will describe one more about that
later but so the decision here was to
throw this away this application and
just completely implemented from scratch
and why we ship bugs nothing we're proud
of but we do all this stuff for to catch
the bugs before we ship anything and
it's anything from the sign processes
automated testing manual regression
testing all these things we constantly
we have very good test coverage but
somehow these bugs still are shipped and
the reason for that is that we have lots
of duplicated state in software mostly
to make it responsive and performant but
also because that's a fact
when you're using Eclipse and SWT and
you deal with native widgets and so on
you can't be wasteful with them you have
to synchronize the state and make sure
the application stays up-to-date we also
tend to repeat ourselves and and by this
I mean that whenever there's a
dependency so something is dependent on
something else that is solved right
there often by registering a listener
checking for filesystem events and then
filtering through them looking for this
specific thing when that happens do
arbitrary java logic as a response to
that so how should it be presented to
the user and let them see what's
happened it means that the code amount
is sort of proportional to the amount of
dependencies we had and as you all know
that's really a bad place to be
so we have the increase in complexity we
get slower and slower in introducing new
features and we come to sort of a dead
end where it's just mentally challenging
to do anything here without breaking in
the end we want our users to be able to
extend this platform so they might make
a game specific level editor or
something like that and to let them do
that in the light of everything I said
is mostly unethical like you can't
really put your users in that situation
we have to make something better here
and
people be you know more effective and
also for ourselves of course we also
want to be able to change this software
and make that better so the goals when
doing this from scratch would be to
solve things in the architecture as much
as possible so all these problems I
talked about to solving them once and
for all and have everyone else use them
rather than having to implement them we
have a lot of problematic data
dependencies in an application like this
and a strange example is that the title
bar of the application window happens to
be dependent on the project settings
file and the only reason for that is
that that file happens to store the name
of the project and that name we need to
show to the user in the title bar so you
have these dependencies that seems to go
from one end of the application to the
next and we just have to allow that like
treat that as something that's natural
to the system we also do a lot of heavy
computations so that would be maybe
texture compressions or bin packing
problems or just sorting the data and
optimize it in different ways and as I
said we really want to bring the build
times below a second so that the user
can just launch the games and change it
and launch and change it and that means
we we are happy to waste the memory of
the computer rather than having the CPU
go at each time so store them and as
long as they're constant thing but
parameters are constant we like to reuse
them so quickly fetch them for memory in
the game engine we also have live
development going on so the game
developers use Lua to script their games
and then they can like upload the new
code into the running game and and
that's a really really good thing and we
also want to bring that over to tool
development so you can imagine something
like Emacs or a small talk happening
here like you would call this editor
inside of itself and it would respond to
the new code happening and have that
kind of you know nice creative way of
developing so I'm talking about the
graph of dependencies one idea would be
to use a graph to model that problem
like that seems like a really good first
ID to change here and also state
problems so the the functional people
they always talk about how they don't
have state problems so that's really you
know curious for us who deal with them
every day and closure seems like a very
good approach today
since we are used to Java and that whole
platform that's that's also a nice fit
for us and Yelp that's helping Swedish
we don't know closure so we need help
from someone and it seems like cognitive
knows a bit of culture so we sort of
contacted them and asked them can you
please please help us in this and make
this graph architecture that we can use
to build our application on top of so
before letting Mike describe this
architecture and what cognitive has been
doing I just like to give you a glimpse
of the new dart editor by popular
request game developers tend to like
dark applications so this is a small
very small game just to show some
dumbing in it so it sort of works it's
still the same game engine running now
as we saw before I said I thought but
now it's been produced by this new
software so if we go back here this is
basically all of it written in enclosure
with some Java effects on top to do the
widgets so I can still come in here and
load this stuff check out the little
frog hero and maybe make a copy of him
maybe move that to the side and then
running again
we now have his identical twin so that's
yeah it didn't work really well there
but so it means that the application now
sort of behaves like the old one it
looks a bit different but it acts very
much like the old one and so for the
users it will be a nice transition once
it's done but it's it's it's getting
there we have still struggling with you
know learning cloches imperative
programmers and stuff like that but
we're making good ground anyway okay / -
okay so Ragnar talked about the graph
and game development the idea of a scene
graph is pretty natural you have objects
that are related to their parents so
they have an offset from their parent
they need to be translated together when
we were talking about the graph we
thought maybe we could extend this idea
even farther and have the graph actually
reach into the UI so we not only have
the scene graph of all the game assets
and and the dependencies among them but
the graph the graph is everything the
graph is life the graph is speed we've
built an in-memory transactional data
flow graph it starts pretty simply you
know we're just representing this as
closure data structures we haven't done
anything on disk the on disk assets are
still the same game assets they were
before they're largely represented in
text so they diff nicely and they go
into get nicely and the the references
in the text are in terms of strings as
we load things we turn those string
references into graph connections so we
have this flattened representation of
the graph you can see we've got nodes
that are indexed by their ID and then
we've got
Sark's and tark's those are the source
arcs and target arcs for some
performance reasons it became useful to
represent each arc in the graph twice
once indexed by its head and once
indexed by its tail and then successors
and transaction ID it's a little bit of
bookkeeping again a performance
optimization where we're just pre
calculating and cashing some values
every node in the graph essentially
follows the same
basic schema we have outputs from the
graph that are produced by production
functions outputs are labeled with a
keyword name and they're typed according
to the type of value that they produce
inputs likewise are labeled and typed
there's one additional bit of info on an
input which is it may be an array input
or a single input if it's an array input
then it can have many connections coming
in to it if it's a single input it can
only have one nodes have properties
which are just intrinsic to the node
property is also act as outputs so when
we look at the definition of a node we
can get its outputs by calling node
value and that triggers a tree of
computation so when I call node value on
an output I probably need to run a
production function but in order to call
that production function I need to
supply it with its dependencies which I
get from properties of the node itself
other outputs on the node or inputs to
the node and if I want to go get an
input to the node that may trigger me
calling a production function on an
upstream node so you can imagine this
sort of bifurcating tree of computation
when I pull on a single output node all
modifications to the graph happen by
calling a transaction you build a
transaction and you invoke it the
transaction until you invoke it is just
data so it's very easy to look at a set
of transaction steps and say this is
creating a node this is connecting a
node this is changing a property one
sort of basic kind of UI response is
here this is handling an input and you
can see there are some calls to node
value here we're asking the view what
its play mode is we're asking the view
what the selected updatable czar these
are outputs on the view and then we
build a transaction here by Khan Khattak
together the output of these set
property calls now set property it
sounds very imperative and side-effect
II again it's just a returning
transaction step that will actually set
the property when we do the transact
to make defining the nodes easier on the
end-users the end-users being the game
developers who are using this IDE we
defined a language for defining the
nodes and this is what we expect to be
the main means of extension there are
currently 78 different node types in the
editor
most of those represent game assets or
fragments of game assets but some of
them also represent components in the UI
itself so here is one example of a deaf
node this would be when you're editing a
Lua script or something along those
lines we create a node to represent that
text editing area you can see one of the
properties on this node is actually a
text area so the the type of that
property is Java class and it gets
instantiated and held at that property
we have these inputs that tell us where
to get the code from and which is this
new content this is calling a production
function update text area in the
definition of that function we would see
how a text area depends on its inputs
this particular output is cached which
means we're gonna hold on to the output
value until one of its dependencies
changes this is a more complex example
of a node so when packing textures into
a large texture map you also need to
keep track of where all the coordinates
of your original images landed in the
texture map that's the job of an atlas
it also brings together animation loops
so when you have in one of the tutorials
a spinning spaceship made up of eight
PNG s the animation group says cycle
through the PNG s in this order at this
many frames per second and you know loop
or ping-pong forward and back or play
once and stop or so on and so you can
see here we have several more inputs to
the Atlas it extends or inherits the
resource node so we create a notion of
subtyping
and you know don't tell anyone but we're
actually doing multiple inheritance and
it's working okay and then we have a
number of typed outputs some of which
are cached some of which present a
multiple output like this image where
you can get a collection of images
others say any which is our wildcard
type that's the one that says I can't be
bothered to define the type right now or
I actually want to allow any kind of but
usually it's more of the former than the
latter this is the node definition for
the Atlas node same exact thing just
translate it into text a couple of
points of interest to call out if you
take a look at some of these production
functions you'll see this GE fnk
business here G is just our alias to our
namespace F NK is actually the prismatic
plumbing key word function so when you
look at an F NK you don't just get the
arg list of sort of positions where
arguments can go you actually get the
names we use those names so when this F
and K says animations that's expressing
a dependency to call this function you
have to supply it with the animations
well where do we find animations in this
case it's an input so this says before I
can call the images production function
and get back my array of images I have
to collect the animations and supply
them to the function you can see here
another one this one for GPU texture it
takes an underscore name which are all
sort of magic IDs and it takes texture
set data as an input we don't find that
in our inputs or properties but we do
find that as another output of the same
node so we have this ability to chain
the outputs of the node here's a longer
production function that actually has
you know many dependencies and it
returns a record with all of that stuff
bundled into a record so again as the
writer of the node type you don't
necessarily care at this moment whether
frames is a property or an input or
another output you don't care whether
fps is a property or an input or another
output you just say
for this function I need to know what
the FPS is and the plumbing inside the
graph itself supplies those to you so I
talked about transactions it should be
familiar if anyone's used diatomic it's
the same exact idea we were heavily
inspired by diatomic I'll say that
sounds a lot better than copying the
design doesn't it so atomic state
advancement and it's the only way to
change state you build up your
transaction data one point that we found
important on this one was the ability to
build up a nested collection so it can
be a vector with vectors with vectors on
down and the reason for that is if you
try to make a flattened collection then
your code structure has to match that
kind of flattened structure but if you
allow a nested collection of transaction
steps then you can kind of compose all
of your transaction creating code in an
arbitrary way and whatever's natural for
the structure of your code so the
structure of the code and the
transaction can be isomorphic because
you know we're agnostic to the nesting
there now transactions are mostly pure
functions so underneath the covers we've
got this transact star function it this
is exactly the code for transact star it
works as a pipeline of steps that takes
this transaction context and a bunch of
actions and works its way through and
eventually returns to you the
transaction result one of the components
of this transaction result is the the
new basis which is like the updated
world value along with some status
information and some bookkeeping
information that we can use for other
important tasks that I'll show in a
second so our our basic life cycle here
is we have a graph we apply a
transaction and we get a new graph that
graph can produce all the values that we
need for the UI but it doesn't push them
through I talked about pulling on
outputs and that's that's the model it's
pull based not push based so we update
the GUI control
by pulling all these outputs and
painting the screen and updating the GUI
controls the GUI then does its GUI thing
and somehow translates you know user
gestures into GUI events those GUI
events then create more transactions and
so because we've got this loop that's
mediated by the transaction
we're not attaching a bunch of listeners
all over the place and one of the nice
things about that is it gets us away
from one of the key problems of gooeys
which is mutability and event storms so
when I have gooeys with listeners
pointing in every direction it's really
common to have one widget trigger an
event that causes the other one to
update itself which also triggers an
event which hits this one and and
suddenly you're at a hundred percent CPU
and you don't quite know why so we don't
have that because you know we're in a
closer to pure functional state
management system now I did look around
for any purely functional gooeys I found
some research dating back you know a
decade or more but really everything
today is kind of single threaded and
mutable and based on the widget toolkit
idea one of the features that we wanted
to build into the architecture was undo
and redo so the typical way of doing
this is the command pattern you build an
object that represents how to apply a
delta to your state and it has a method
to sort of unup lie or work backwards
and then you build a stack of these
commands they suffer from a couple of
big problems one when you make your
change it may cause side effects that
you as the programmer aren't aware of
especially if you allow extension by end
users so when you do the unup lie you
don't know what all has happened in your
environment to fully unup lie so we
actually just keep a record of all the
states every time there's a transaction
we advance this paper tape idea and
write a new state into it if we want to
undo we backup the paper tape and if we
want to redo we go forward now if you
undo we've built up some four
or future history and this redo log if
you then do something else we just drop
the future history
so you've you've gone back in time
killed your grandfather and you're on a
new timeline there was one other
subtlety about undo and redo that has to
do with caching and I'm gonna come back
to that because first I have to explain
how we do caching so to the node
developer cache looks like just a little
keyword that you can attach to your
production function which is fantastic
because we've actually solved caching
right one of the two biggest unsolved
problems in computer science
naming caching and off-by-one errors and
we solved caching well we can do that
because we know when state changes it
changes in a transaction and we have
this graph that tells us all the
dependencies when we look at an fnk for
a production function we know exactly
what it uses and so we can do this
tracing forward when we say you know if
this if this property changes we can
trace forward through the graph so we
have two directions we go we pull a
value which propagates computation
backward through the graph or we make a
change which propagates invalidation
forward through the graph and we also
treat topology changes as a cache in
validating change so if you connect
something new to an input or you
disconnect an input you know we consider
that sufficient cause to say anything
dependent on that input is probably
going to update well caching and
transactions and evaluation all kind of
happening at the same time has some
subtleties and and for here I really
thank Sam Umbach one of my colleagues
for writing about a hundred different
tests that all demonstrated
inconsistencies in evaluation so for
example I'm doing a computation and I'm
working my way backward through the
graph and somebody does a transaction in
the middle of that well now solemn of my
computation is based on the values at
the beginning
and some of my computation is based on
the values at the end no good many other
scenarios like I do a computation that
branches Andrey converges I want to only
compute that value once I don't want to
get it from two different time steps and
so we created this idea of an evaluation
context and so when we're pulling a node
value we create this evaluation context
that captures the state of the world at
the beginning in the form of this basis
it captures the state of the global
cache at the beginning in the form of
the cache snapshot and then in the local
snapshot it keeps a record of any new
cacheable values that were created
during that computation so whenever
we're looking for a value we first look
in the local cache then we look in the
snapshot then we look at the basis we
don't refer back to the current state of
the world because that could be changing
under us so I'm gonna hand it back over
so Ragnar can talk about how we employ
this in practice yes thank you Mike and
so in this example I'm showing a bunch
of production functions working in
combination so the point here is to take
the atlas which mark talked about it's
the collection of many images being
composed into one large texture and
showing that to the user so first of all
we need to collect all the image data
that's production functions then it
needs to lay them out the bin packing
problem essentially that's a separate
production function it takes all these
results pack that into a scene data
structure the scene data structure tells
the rendering system how this specific
thing should be rendered the scene view
is the actual JavaFX view that we render
in the middle so that just passes off
the scene data it receives over a way on
to the renderer and that performs a
sequence of production functions itself
so first one since the scene structure
is hierarchical you have like scene
graph nodes and transforms and all these
things he needs to flatten it out first
and then it looks at the data and the
sorting based on its well correct render
order going back to the front
and at the end it might also include
tools we use like graphical media to use
to manipulate objects in these things
and it sends back an image that it
produced through OpenGL of course and
the scene view takes this image using
Java FX presents that to the user and so
this is a bit one more of the complex
ones but the UI itself works a lot like
this at all points so all these
different views I talked about the
center one right now all these different
ones they continuously pull on the graph
of often through an old witch it's like
at the end of things there there's not
much happening after that so there are
at the endpoints pulling all the time on
these values and as soon as they see
something change in the value they
update themselves so looking at the
outline it would look something like
this regular closure data structure
coming in describing what should be
shown and it's also a hierarchical in
this case you see the children and tree
there it's the same format repeating and
so the outline view will take this data
read through it and and create Java
effects widgets from this so in this
case tree view items whatever that might
be
and using the icon and label here to you
know set the properties on them and so
this is stateful UI of course and this
is the source of all these event storms
that we talked about and to get rid of
that we now just throw away everything
in this view whenever it changes so we
recreate from scratch all the time and
we had this bug before that made this
happen at 60fps but it it happened at
60fps so that tells you something about
the performance of Java effects moving
forward other cool stuff happens when
you have this graph on your hands and I
just like to give you a quick
demonstration again about what might
happen so going back into the
application here I will undo now I've
flipped the whole state of the graph
back a few points but as you see we
still have these dependencies sorry
so this hero is actually defined in a
separate file so we can inspect the hero
in its isolation over here sorry and the
hero is composed of many other things so
here we have some death particles
whenever he dies
and we have them over here so we see
these are now nodes and the flow of
computation is is to the left for you so
this one sends this data down here and
it sends that data over here so now we
can peek back into this flow of data so
this was the file here now we see the
contents here all of a sudden and we
also can expand into the particles and
that lets us start playing this right
here when it's where it's used which is
massively useful for when you're making
these particles you get to see them in
the context they're used in and so on
and I can even peek into this actually
other file that's on a separate tab here
but change that in place so that's what
we mean by in place editing so I mean I
might go in here and of course I want
more blood because this game will not
corrupt the young and be promoting
violence and all that stuff that we're
in the business to do so bloodbath is
what I'm looking for something like that
and let me just post them so yeah it
looks really good
and then I can of course run this again
and and have more corrupting of the
young happening and you know violence so
that's nice and all of this of course is
you know transacting on the graph and
all that stuff that might just discard
then it's really impressive how fast
that can be done and that it's still a
responsive application with all this
stuff happening in the background so
that's fantastic if I now try to jump
out again of things here see that I mix
place the the hard element this is the
like live hearts I'll just correct this
sorry like so and let me try to go in so
here we have the the hearts representing
the lives of the character I happen to
know that the hearts here are rendered
through a GLSL shaders that I have right
here and now I will try to type in front
of you see how that goes
now I'm changing the source of the
shader to to be hard-coded yellow so
whatever it's texture is and everything
it will be hard-coded yellow in
so and then I'm gonna come back here
it's yellow and and the thing I did here
is transacting on the graph this
invalidated forward all the way up into
the view of this collection which is
dependent on this source so whenever I
clicked here this now checks backwards
again whatever it might recompute
recompile the shader uploads it to the
GPU and it changed it and what's even
more interesting that just sort of
happens here is that I I can remove this
line and undo this is still on the graph
and then when I come back here I can
undo as well and change the source of it
and have that visual so the idea here is
essentially to have a split of course
you can see the source you can see the
result and then live program the shaders
and change everything so is it really
and this this is just stuff that sort of
happens like we were hoping this would
happen for a long time and we never
understood how it would happen really
but in the end it sort of did and it's
really nice to not have to implement it
but just have it there and then you can
choose to use it or I want to present it
to the user so that was the end of the
demo so some conclusions here so we
managed to solve a lot of these problems
that we identified upfront like down the
redo problem so and it actually means
that whatever transforms someone else
would introduce to this system they
don't need to deal with the reverse of
that transform and we will always under
wait for them actually whether they want
it or not we will always be able to undo
back and forth we also have the 100%
correct cache invalidation which is a
very big statement to make but it's
simplified just by the fact that we know
all the input parameters to every
function and we know precisely when they
change and are able then to not do it
redundantly often or anything like that
it's very precise and always works
really great lines of code I don't think
that's a surprise to you in this
community but to me it was just
ridiculous how much you could express in
in ridiculously little code and also we
found that JavaFX was a requirement even
because it had that level of performance
that let
just be wasteful with the widgets and
just totally remake them from scratch
and and have that more like functional
behavior going on but I think another
revelation was that in the light of all
this we sort of realized that the old
application indeed had a computational
graph working much like this one it was
just horribly implemented like the worst
kind of way you could ever express such
a situation so rather than having the
node a node with an edge in between them
that would be described in the old
system by an if statement checking a
flow of events and then doing arbitrary
code as a response to that and then you
have the problem as a as a tool
developer to like you can't really
inspect that you can't do anything you
can't analyze it you can't do anything
with it
it's just there and it doesn't clearly
describe this relationship to anyone
looking at the code you have to
understand it to actually see that
connection but whereas now when we have
the explicit data flow inside of the
graph and in data we can make really
simple decisions based on it so we can
detect that you might have a thousand
files but you're only using five hundred
of them in your game which means that we
only compile those five hundred files
decrease the bundle size of the game and
it just sort it's stored sort of there
like we don't need to do all this kind
of really complicated things about it we
just look at it and say okay this is
everything we need actually compiling
the data now is pulling on an output
like that triggers the whole looking
back in the graph so it's there's not
even code to do this Puni like it's just
following arcs and whatever is connected
happen to being included in the building
so that helped a big deal for us and
it's it made all this worth the effort
of doing this whole project and we also
would like to take the time to thank
some people and Christian Murray who is
my boss he was the person behind this
idea to use a graph and a functional
language and enclosure so he made a
connection with the cogniat act happen
he also convinced King to pay for it
which was a really great achievement as
we could even do this since they they
had a working software and we're still
you know
wanted to see this happen and also a
bunch of people from cognate act then
Sam Stewart and Karen who helped with
design and implementation and also Eric
my colleague who is now implementing
this this editor so I think that makes
us ready for questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>