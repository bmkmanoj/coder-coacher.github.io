<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>miniKanren - Dan Friedman and William Byrd | Coder Coacher - Coaching Coders</title><meta content="miniKanren - Dan Friedman and William Byrd - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>miniKanren - Dan Friedman and William Byrd</b></h2><h5 class="post__date">2013-01-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5Q9x16uIsKA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">i'm dan friedman and this is real bird
and we are two of the three people who
developed mini cameron the third one is
only Kiselyov I brought we've brought
with us 25 copies of a draft of the
second edition and I will second edition
a second edition of the reason schemer
it doesn't have the elephants it doesn't
have the pretty cover or anything it's
just a draft but I'm I see that there's
maybe more than 25 people here so I'm
going to figure out a technology where I
can get your name and address and I will
send you one just for legal reasons I'm
not allowed to give you give you a PDF
I'm sorry but that's the way it works
the idea today is to first show you a
little bit about our philosophy on how
you can just be a sort of garden-variety
functional programmer and turn yourself
into a red-hot logic program a
relational program what we like to say
red face it turns out to be really easy
and so that's the first thing we're
going to do that doesn't turn out to be
easy well it turns out to be really
really hard you guys know who dick and
Tom smothers our
okay so then we're going to show you
some kind of neat examples that probably
wouldn't think of writing yourself we
hope and and then we'll finish it up
with some interesting new work that
we're doing on constraint logic
programming and we'll show you some some
of the famous problems that are solved
with those tools how will do this in 40
minutes I don't know but we're gonna
make a stab at it by the end of the talk
David will have added everything to core
logic of course and that's the reason
we're here basically because we found
out about core logic and thought well we
ought to meet the people and I'm excited
to Olli I'm sure would be excited if you
were here we ought to get old so we're
going to look at probably the easiest
program you've ever seen it's called a
pen oh wait we have to take you the
language first probably well they are
you so boiling which a little bit okay
there's the learner refresher now you
had a really great refresher so we're
going to assume that some of that so
again and so we're now we're gonna go to
the append okay and when we get new
stuff we'll talk about it okay so here
is the standard definition of a pen in
virtually every single this scheme
whatever or closure this is probably how
you write it
the only difference is that you probably
write it with l1 and l2 and we're
writing it with s okay that's just a
small difference but what we're going to
do is translate this program directly
into mini Cameron without any effort so
when you go from a function to relation
you add one more argument which is the
answer oh that's not the first thing you
do oh yeah
the name app endo everything has an O at
the end right Spanish if you if you
corner me I'll tell you why it's an O
but here we go
so it's a function well then we'll take
one extra argument and that's the only
thing you have to remember a function is
takes and arguments a relation will take
n plus 1 arguments and the first thing
we do is we'll change the canta canta
now our Cundy is not your condi yeah
our condi is completely interleaved it
uses what I like to refer to as a
distributed trampoline and I don't can't
explain that in the time we have but the
code is all there in the back of the
book a one page one little page all you
have to do is spend about a year looking
at that page of code and you'll be all
set
okay so condi is the same sort of like
the condi that that ambrose talked about
earlier and the first thing we want to
do is we want to mimic the behavior of
the pen so it says is the list empty so
the way we asked that is we asked it
does doesn't it unify with the empty
list and that's all we ask
and now if it does then that's an answer
we're happy with that so we allow out
though you called it LS I call it out I
know this no I'll forget this one is a
little bad habit okay fine I'll change
it to out but you have to forget that I
ever did this you shouldn't be thinking
of in and out variables I'm sure that's
okay so out will get unified with the
the result which is just the empty list
again the empty list L are you defying
the same append I am oh no do you know
how to find a pen no it's the S over
here so it's the yes okay so now we as a
book I can recommend it's all in there
very clearly okay so the next line which
is the last line so we're mimicking this
is to say all right we want to run this
piece of code okay but we can't be
cuz we have messed things and we don't
know how to deal with nestings so we
have that cons which is wrapping the
upend but another use of the word wrap
maybe and then we've got things like
cutter and car which are not really foam
their functions are not relations we
want to turn them all into conventional
things so we'll start very easily by
saying let's just do the car first in
order to do that we're going to have
some sort of out variable for it because
car takes one argument and we're going
to use okay so we're going to be you get
cargo cargo is cool and curves in the
book but this is a way like like a pro
the sons so we're going to introduce
fresh here which introduces some
variables and we're going to call the
variable a because it's for car and you
can guess that we're probably gonna want
to d2 so we can throw that in now if you
want and and now what we want to do is
simply say well what is this going to be
what is L going to be what's going to be
a list with a and D and I'm sorry you'll
excuse the term dotted pair but that's
the way we think about this so a dot d
which is car encoder will be associated
with L does closure have the back quote
and comma type thing I don't know what
this is the equivalent enclosure would
be even tilde okay so now we have taken
it apart and so that's the car in the
coder we've already pulled those pieces
out now we want to take the recursive
call of a pen and use that v is the
first argument s as the second argument
oh this is a recursive call well we're
going to need we're going to need
another variable because that's the
result of calling the recursion so it'll
be we call it res for result now we've
got we're almost finished now we have to
just do the cons part of this we're
going to cons the car on to something
but the
as a so we're going to do back quote a
Reds on two out okay so that's all it
takes to write this code now there's a
law called will Wilbur law that says no
no no no we're not gonna get that low
yeah I'm gonna get to that well yeah
we're just showing the hard way okay
mm-hm
Oh cons that's all my prologue was it
like a vertical bar or something yeah
it's a no has nothing to do with that
absolutely not you can it's the only way
well it's one of the cons is an operator
that allows you to create those but it
has nothing these are all this as far as
we're concerned right this moment okay
so we can yeah thank you very much oh I
need to stop doing that looky here
all right so we'd like to test this now
so let's try it
hmm append Oh ABCDEF the E and Q all
right see if it works
and sure enough it returns one answer
remember you don't have to look at those
other parentheses if you don't want to
it's only when you have more than one
answer so that was pretty nice could we
maybe that would be nice let's see what
that does anything so what do you
suppose that's going to return well
obviously it has to be the list de and
sure enough it is and then we can just
do one more
Oh put the BB back in there I'm fooling
them okay and now we'll see if it
returns us ABC and of course it will
oh gosh what happened well now we can
bring up the will bird law I believe is
that right yeah okay so the Wilbert law
says never play let's do a run one run
one okay let's do a run - there you go
so we got one answer let's go for double
jeopardy and no now you see we'd like
for this to terminate but it won't
so we violated the will bird wall the
will bird law says you have to always
put your recursions last and now we can
try it yeah so basically we had
something like that and now we want that
any here we go and run it more and the
regression tests okay so now runs and
all the trees okay so that was easy but
we want to do some fun stuff oh you're
not going to talk about why it so what
happened with the old bad program was
when you have these two clauses swapped
well not gonna do the trace of it really
but the problem is when you do a run
star you're saying I want all the
answers back or if you do a run - I you
want at least two answers back before
you show me anything and in this case
there's only one answer
so as Ambrose showed you have the search
tree and there's all this backtracking
and all this nastiness involved which
you shouldn't really think about when
you're writing this programs but that
stuff is going on and the problem is the
system isn't smart enough to know that
there isn't a second answer so you do a
run one you're fine if you do a run -
well the system hopefully would fail but
in this case
because we have the recursion before the
unification that could make it fail it's
just going to search forever okay and
this is a very important principle logic
programming that the failure and
divergence are indistinguishable that's
a very deep sort of theoretical result
there's nothing we can do about it but
as a general rule you want to make your
recursive goals come at the end of any
sort of conjunct and then the fun part
comes when you have multiple recursive
goals right because they can't all come
less and that's when you call holy yeah
okay I do anyway so the let's try
something a little more juicy let's put
let's try X let's introduce two
variables x and y look in run star Q and
XY
and now what we're going to do is a
little strange but we're gonna do it
anyway
on April inkle Q to back quote X Y comma
X comma Y so it's going no yeah that's
right so the next line we're going to
put in however it's a call to upend o
and this time we're going to say X Y and
a BCD today oh I think I'm full of novi
change the well you went back thank you
so much when do you do logic programming
you get used to you embrace the infinite
loop okay here we go
and there they are okay so that's would
you kind of expect but of course things
can get much more complicated than that
so let's make them more complicated okay
let's put in a dot comma Z at the end
here
I think that'll make it pretty
complicated but let's get rid of the
star cuz I think that would be a big
mistake so let's just make that like I
run five and there they are you remember
seeing the underscore dot zero those
answers are perfectly correct and
they're fine okay so what we've done so
far shown you is that you can take
conventional functional programs I'll so
say I don't like to advertise but just
typical in the first a chapter or first
seven chapters a little schemer would be
functions that would fall into this
pretty easy approach and of course once
you've done that a little bit you start
getting comfortable and you start
working out of the the balloon that you
started out started out in now now we're
going to show you some pretty
interesting stuff Oh jump to that so
let's write an interpreter so we're
gonna write it to them okay I mean I
wrote it well I wrote it while listening
to some less talks but well I saw that
Ambrose showed off the type inference
err right so really okay I'm saying yeah
we're going to show type inference or so
is like well now well we're gonna run it
like you know we both showed up to okay
so you can see the language by just
looking at the parse look at our
structure so the language has numbers it
has variables it has the primitive zero
question market has subtracting one
primitive times primitive if oh this is
the match oh look at this this is kind
of neat okay for those of you haven't
seen something like this this is called
a academ orphism if you look at the IPPS
the if line those are recursive calls in
the pattern match so that when you go to
the right-hand side there's no
yes Antigua is bound to the value
calling par Santi this has nothing to do
with many Cameron this is just a little
simple parsing trick but you should have
that it's like glossing so we have riff
and else we have left we have lambda we
have n we have applications it has to be
tagged
well it has to be probably okay anyway
so that's the little language we're
going to program in and we're going to
write a we're gonna look at an
interpreter I have to tell you that if
we were using that T this would be a lot
shorter but basically we're using just
the simple tools of run or run star
equal equal or unifying or fresh and
Condy that's all we're using okay so if
we were to be using that cheese just a
simple little macro that gets the job
done alright so you can see everything
so it should be all pretty obvious here
we're still using the out variable to
indicate where the answer is going but
of course that's just noise really cuz
the names don't matter anyway so you
have a lot of fresh variables or
introducing and that's just to do
pattern matching on the kinds of
expressions for the most part yeah they
should be a locally scope obviously yeah
we could do that but it wouldn't fit on
the screen anyway so we have this little
language and now we're going to run it
and see if it does in fact do an
interpreter does the work of an
interpreter oh yeah we also have numbers
in our system oh yeah enough not the
numbers Ambrose showed not the piano
numbers but these are what I like to
call oleg numbers these are binary list
representations so you'll see those
indian little indian presentation okay
so here we go and they are
we've loaded it and now we can test it
associated to give some tests that have
a PP sitting around in them all right so
here we go
all right so there's like no point
running this forward cuz that's boring
let's just run it backwards so here
we're gonna run generate 30 programs
that evaluate to 6 here we go sorry I
didn't have time to write another parser
so the first one okay so we've got this
little Indian binary notation so the
first number is 6
that's just like 1 1 0 second one we're
multiplying 1 by 6 and we're subtracting
1 from 7 and we're multiplying 6 by 1
here we have a let we don't even use the
variables so we're saying hey we had
some variable bound to a number and in
the body is 6
that's classy if zero this is zero is
zero then six else we don't care
multiply two by three so we just
factored yeah let's find what's the app
oh I hear some shouldn't be in the apps
know what uh there should be apps
because let picked it up oh those are
lambda down there do you want to know
when lambda we'll see we'll see right
one for 4150 there should be I did hear
something all right
okay this has to be really awesome I'm
sure I'll see this we're applying some
function with a an argument we ignore
his body is sub one from seven to a
number whose number value we don't care
about welcome to our world
so an interesting research problem is to
make it try generate interesting problem
programs in particular the answer if you
take dance class the answer everything
is 120 because he's really big on
factorial 5 so our dream is to put in
120 and generate factorial 5 using the
poor man's Y Combinator that hasn't
happened but you can instantiate most of
the program it'll feel a little tiny bit
yeah one of the things about the system
is you take a structure a program that
you might want to generate and you don't
have to have all the pieces like you
just you could just put in the recursion
for example I think you think you want
or just another call and then see if
it's smart enough to figure out the
recursion so you you basically give it
like a template with a bunch of blanks
should we try it
shukran saya ok hold on
I didn't practice this part about that
was that oh yeah no no only if I parse
it if I don't parse this all oh you
didn't parse it yeah okay so let's do
the run star Q yeah it doesn't have to
be Q by the way if any lexical variable
you like but it shows up a lot for some
reason here we go lovely definition of
factorial and I'm just gonna run forward
and make sure it's working here's the
empty environment and we want to get the
answer that let's see if that works
Oh things very naughty okay that part of
the demo will happen later
actually wait there's one aspect oh I
think this test is running so what do
they do yeah that works okay let's just
try this again
here we go I should be able to feed that
in
see if that works okay all right now is
the fun part so we know that the answer
is no the answer is 120 and we all know
how to write that it in binary okay so
we're gonna feed them the answer
okay now we got success all right so now
what we're gonna do is we're gonna
replace part of our program here okay so
let's put in I don't know a Q right here
see that should be far F so let's do a
round one whoa what is that
oh that's correct we never know what
this thing is going to return I'm
telling you it likes to cheat it likes
to say you want 120 I'll give you back
120 yeah here's just you know nested
lambda okay so let's just try and get
another answer back this is always a
and we gave you one yeah let's do five
there you go
listen old u4f there was yeah yeah okay
anyway so you see the idea is you can
take an interpreter you can run it
backwards and you come into forwards and
you can take something that looks sort
of like the program you want to generate
but fill in some pieces yourself and
it's a game you get to you get to play
it yourself and I don't know where it
can take you I have not the slightest
idea this woman
it's definitely research maybe research
nobody cares about but research
nonetheless research we thought no one
cared about coming here okay so now
let's let's switch gears completely and
let me introduce to you CK
this is sorry C Cameron which is the
constraint system that we have so let's
just bring some little simple programs
all right you just wonder like so we
added basically with there's something
called finite domains a finite domain
constraints and then there's this
equality constraints now finite domains
are the serve you know how did it come
about and well because people wanted to
solve send more money so if you haven't
heard about send more money just think
to yourself it's an arithmetic problem
for doing with addition so it's n plus
more money and you're supposed to come
up with numbers associated with those
variables so people discovered that if
you tried to do that in logic
programming it became very expensive so
that someone long along the way
discovered that you could do it using
constraints because you know
no no digit
is going to be bigger than nine here's
some more you don't have to worry about
it yeah so there's the statement crypto
ripped on sale by the way if you go to
the Steam Workshop 2011 page our paper
is there and you know it's you're free
to download it of course and the answer
to these questions are in the paper to
mention that clear out this
yeah it's implemented okay so this
system is inspired by the fact that at
one time I was reading in Pascal Henry's
book about how fast there a Queen's
chest solver was and they could do a
63,000 by 63,000 chessboard really fast
for fine solving the 8 Queens problem
that's a lot of Queens so I thought I
gotta understand figure it out and so
Clare all of us did and she's graduating
with a master's the spring so that's
like look this is do a little simple one
let's do a run okay so first of all
we've got a couple of operators we're
adding the mini cannon so we have a
domain operator you can associate a
variable logic variable with the domain
seeing it okay so whatever happens it's
value if it has one has to be one of
values in this domain and if not then we
fail so here we're associating Q with
values from the main one three and four
and if we run star we say hey okay well
you could be one three or four not a
surprise that's the first parts to mean
and then after that you can start using
constraints on those and of course
unification equal equal actually is a
constraint that's one of the constraints
over trees so equal equal works like you
might expect it to we've added a few
other constraints so
have less than equal over numbers and
addition dis equality over numbers and
all different saying that all the
variables on the list or all those items
have to have different values so here's
it will be easy to add more fact for my
research I'm working with clear and
Eirik olkhon a compiler for GPU
programming for the declarative language
for GPU programming and we're writing a
type inference urn of course we wrote it
in mini cannon and it turned out that
when we want to type integers and have
integers have 64-bit integers versus
32-bit integers that sort of thing we
had the problem of getting multiple
types back and wanting to have a
preference I think someone mentioned
that earlier today so we added a
preference constraint it was easy I've
been for that we stopped removed moved
all the hacks all the cut type things
that we had to use to get it to work
temporarily okay so this equality
constraint just says that queue cannot
be three queues in domain 1 3 4 then Q
has to be either 1 or 4 pretty simple
and yeah so the nice thing in many
constraint systems you actually have to
declare the domain of the variable first
in our system because we believe trying
to be this declarative as possible you
can always reorder the the goals any way
you want so it doesn't matter you can
declare the domain at the end of the run
that still works for clean and then you
can have a range of numbers can't be 3
so it has to be 2 4 or 5 ok yeah so here
we have addition constraint so we're
saying X plus y equals Z of course you
very seen the other numeric system we
had the oleg numbers as we call them but
the problem is that those aren't very
efficient and
also hard to read notices this gives you
a chances but to defend the oleg numbers
when you put a variable inside one of
those over link numbers either after the
dot at the end or somewhere in the
middle you get a whole lot of numbers
yeah that system is actually much more
general more general if you're doing
something like send more money you don't
need the full generality and you can say
hey I know my numbers are between this
MFD is like dumb F D but it takes any
number of variables yeah so here we're
saying XY and Z or in the range 1 to 5
each and we're adding x and y to get Z
and then we're going to see what the
values associated with XY and z are and
we get a bunch of sets of values here so
let's see 1 in 1 is 2 and 1 and 2 is 3
and etc ok and then we've got less than
constraints that's boring let's do
something fun let's do we'll send some
more money okay
now we don't have multiplication
constraints and one of the ways of
implementing send more money is to use
multiplication constraints what I wanted
to be as simple as possible I want to
know the language to be something that
you'd say well gee I can I can not only
understand what it's doing but I can
read the implementation so anything that
I we were willing to sort of leave out
we lift it up it's easy to have yeah
okay here we go
so here's send more money and so the way
you can think about it let's see if I
bring up the puzzle again so we've got
our letters up here in our fresh SE ND
mo or Y and we want to get the answer
back we want know what the values of all
those letters are the first thing we do
is we say that all those letters have to
have different values they ought to have
different numbers associated with them
the numbers S&amp;amp;M actually most of the
numbers can range from 0 to 9 but we
know an SM are special because they have
to be one that's that's sorry they can't
be 0 that's part of the problem problem
description at the leading numbers can't
be 0 so that range is slightly different
and then in order to do the addition
properly we're gonna have to have some
carries and the carries are gonna have
either your value 0 or 1 and now we just
do some long addition so we're gonna add
those those pairs up S Plus M it is
going to give us carry bid and output
variables so forth and then we can look
at the long addition which is sort of
what you would expect it to be so when
you add two numbers and a carryin bit
then you're going to carry out bit and a
digit and we know that the total sum
will be between 0 and 19 because the two
numbers coming in or between 0 and 9 and
we've got a carryin bit it could be 1
and a partial sum before we add the
carry bit is going to be at most
18 so we just add those up we add the
partial sum with the carrion bit to get
the total sum and then we have to give
the carryout that we have a choice so so
either the sum ends up being greater
than nine in which case we need to carry
out bit or we don't carry out that's
going to be 0 and in fact here when we
need to do a carry out we have to
subtract 10 from the the output digit so
here we're using addition for
subtraction which is one of the nice
things about having a relational
operator all right so let's run it
and there it is yes there we do
retirement sure it's very fast okay so
that's send more money and there's n
Queens
okay now you know probably that the 8
Queens problem has 92 solutions right so
we're going to show you everyone knows
that oh okay maybe we'll even so then do
you have any way the code we give in our
paper is nice and it can work for in
Queens but it's not very readable
because it's so general so kind of
unrolled those loops and here's a neat
Queens version of it basically the way
you can think of it as a chess board
we're only going to be looking at the
columns of those works we want to have a
number associated with each column a
through H and we have this constraint
all different with that across those
values to make sure that you know
basically you don't have two queens in
the same row we we already know that we
don't have two queens in the same column
because we have the same length and each
Queens position can range from 1 to 8
so we have here and then the only other
thing we have to do is make sure that
Queens aren't attacking each other along
a diagonal so here you can say okay well
if you have a queen in the first column
and a queen and a second column they
their positions can't differ by exactly
one because then they be along a
diagonally they're going up or right or
upper lower lower right and and
similarly and as you go to the right of
the board since we're not worrying about
going to the left we already handle that
sort of that's the way we described a
problem you only have to to add the
constraints when going right the number
of constraints you have gets smaller and
then for each of these diagonals we have
to use addition and then this equality
constraint to make
that you're not attacking along a
diagonal okay so let's try that real
quick
okay so those are all the answers yeah
no sorry we have so right now this is
running our Shay scheme or sorry this is
a petit chèvre scheme so this is an
interpreter I know the compiler it's a
lot faster but it's it's relatively fast
it's not gonna do 64,000 but the nice
thing about as far as performance goes
is that if you reorder the goals your
performance is still roughly the same
that's not true
mini-camera nor prologue or something
like that normally if you're just doing
regular logic programming if you're not
cutting off that search tree as
aggressively as possible you start
swapping goals and something that used
to come back you know in milliseconds
can take hours or a million years or the
worst case diverged so that's a nice
thing about having a constraint system
is that the performance is going to be
similar no matter how you look let me
tell you a little bit about some of the
things we're thinking about we have
implemented something called Alpha
Cameron which basically allows you to do
alpha equivalence of two arbitrary
lambda terms or to the universally
quantified terms or existentially
quantified terms whatever whenever you
have a binding kind of operator and
turns out when you want to write a type
inference or for example that's very
useful
oh yeah okay yeah yeah there's one
really cool thing there there is a bug
in Ambrose's borrow oh don't say it that
way this ro borrowed borrowed borrowed
types of - sir only because there was no
way that you would know there was a bug
so we're gonna show you we're gonna show
you the bug and how to fix it but anyway
oh yeah yeah so so the the nominal logic
stuff the Alpha caner and stuff that is
derived from the work of Andrew Pitts
mm-hmm Cheney and
okay so let's open an urban that's right
can't forget Christian okay so let's go
back to our Val okay so here's here's
our interpreter runs backwards and
listen with a bang
let's show you a little problem with our
lookup function their environment look
up here we go apply info okay I'll show
you a bad one first okay so here's the
reply info and this is basically just
like an ask you type of thing asked you
and then taking that quarter of it you
want to look for the variable in this
the environment and if it's there give
you back the value otherwise you know
recur fine so okay we're all happy now
I'm going to come out okay so here we've
got a nice little let program in well so
let X be three and inside of that let Y
be four and the body of that inner let
is just Y so Y should be four which in
only representation is zero zero one so
let's see if that works okay I passed
let's try this next passed okay so the
only difference between these two
programs for the variables they're
actually alpha equivalent so instead of
having an X and an Y now I've got an ax
and an inner X okay so this should give
you the same answer back right all right
probably know what's gonna happen
already but let's try it oh actually you
might not know what happened because I
forgot what happened okay yeah I thought
it's just give you the wrong answer but
of course what it does is it gives you
the right answer and the wrong answer
because
yeah okay so we got two answers back so
we got the answer for back and we got
the answer three back so so what's going
on here well what's happening is we're
getting both of the bindings in the
environment so X is bound to both three
and four were shadowing X in our
environment with this representation and
if we look at or apply info what's
happening is there's no you know here
we're checking to make sure that the
variable we're looking up X is actually
the first thing in the environment but
in this other case we're basically
saying hey just recur and then logic
programming unlike in functional
programming if you have a cond
of the equivalent of Conda condi you
take both branches and the branches
don't know anything about each other so
just because we took the first branch
and found an answer it doesn't mean
we're not going to recur okay so what we
need to do is actually cut off that
recursion here's the here's the correct
version what we need to do is have a dis
equality constraint saying that it's
must be the case in the second clause
that the variable we're looking up isn't
the first thing in the environment and
that's enough to cut off the search and
then we only get back the correct answer
and not doing weird things with scope so
that's an example of a type of
constraint I think they're diss equality
constraints in core logic right now as I
write so constraints over trees oh yeah
well that's why that's the version I had
but yeah let's make sure it still runs
yeah okay so so one of the things we did
do that was kind of interesting as we
took first-order predicate logic and
wrote a little theorem prover this was
work that we did with Joan herre who's
just about to leave I'm hoping to leave
MIT and may be coming to Bloomington I
don't know and we had to figure out a
way to
run it backward this that's the game we
play right it's not an interesting
program if you can't run it backwards so
sure enough Joe figured out a way in a
run to backwards and it was generating
things like modus ponens which is kind
of neat and you know if I was all that
interested in the topic I probably would
have you know running for a million or
something and see what other theorems it
was producing but we just wanted to
demonstrate some of the neat things you
can do with logic programming sorry we
hope you have some better appreciation
now about why you might want to get
involved and the stuff that David is
working on and Ambrose and thank you for
letting us</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>