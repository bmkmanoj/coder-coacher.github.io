<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Unravel your REPL - Paulus Esterhazy | Coder Coacher - Coaching Coders</title><meta content="Unravel your REPL - Paulus Esterhazy - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Unravel your REPL - Paulus Esterhazy</b></h2><h5 class="post__date">2017-08-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2P-UzXksdHs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so my name is Paulus and I would
like to talk about two projects one is
called unravel and the other one is
called unravel and I'm pretty excited
about those projects and I'm going to
tell you why I'm excited but before I do
that I want to talk about something else
so I want to talk about experience and
and specifically I want to talk about
the experience of programming and
closure so imagine that somebody comes
up to you and asks you what is it like
to program in closure right so this
might be the beginning of an answer so
some languages like Java sort of
encourage it top-down approach to
programming so whenever you make a
change to the source
it requires recompiling the program and
restarting the process and a lot of the
decisions are driven by static analysis
tools like the ones that are provided by
your ID now for better or worse the
approach that closure takes a lot of
closure program it takes the program
must take the product problem-solving is
different so here's what closure
programmers usually do they take a task
they break it into different parts and
they write functions for each of those
parts and then they'll sort of try to
exercise those functions with sample
input test if the results match the
expectations and if they don't they'll
repeat the process so closure sort of
encourages the more button bottom-up
approach to programming and I think this
applies to debugging as well so when I
do bug I usually identify a general
problem area then I come up with
of usual suspects like functions that
might be behaving incorrectly and then I
exercise each of the functions with
sample data and I compare the results of
the expectations and you know at some
point I'll probably realize which one of
the functions is not doing what it's
supposed to be doing so once you find
the incorrect functions you can change
the implementation and you can do that
in the running system and you can do it
just by reevaluate the definitions so I
don't want to argue at all that either
of those approaches is superior I do
have my preferences but that's not the
point
the point now is that closer programming
sort of feels different it feels more
incremental it feels more exploratory
and it feels more data centric so this
is a kind of a unique approach to
problem solving maybe isn't unique to
closure and it's probably not the only
way to program closure but I think it's
a sort of a good recipe so the outline
of the recipe is this you build up state
you run the code and you rerun until you
get things right it's kind of how will
work and what a neighbor says is that we
are able to change the logic at runtime
and we can inspect the data structures
that we're working with at one time and
of course we can only follow this
dynamic recipe for programming if we
have a long-running wrapper process we
can be working with Stewart Holloway has
a talk out with the title wrapper driven
development from just a couple of weeks
ago and it's it's great you should
definitely watch it and then the talk he
gives a lot of practical advice on how
to improve your workflow when you're
working with rebels
and he also goes into the wise into the
reasons why a repla is crucial to closer
programmers so he covers that ground
pretty well so I'm not going to go any
deeper into those topics what I want to
talk about is tools so the the workflow
that Stuart describes is one that
requires setting up a short feedback
loop and the point I want to make is
that we need tools that support this
workflow as best as possible so for
example you may be playing around with
logic you reinventions for a sample
input and at the same time you need to
be able to see what's going on you need
to be able to inspect intermediate
values and you need to be able to
inspect the results so this is what the
tools should look like I think they
should support an explore exploratory
approach and we should sort of support
and encourage this data centric approach
to to programming so again there are
different ways you could be working you
know different programmers have
different styles but if you pick a style
of working then you should have the
tools that are appropriate to that style
of working and if your development is
wrapper driven then you need tools that
are appropriate to this town you need
the tools that make working with rebels
pleasant so I think we should try to
come up with the best possible repla
tools that we can build
so this raises the question you know
what would the future look like
with better repple tools and I think
this is a difficult question to answer
the two projects that I started the talk
with unravel and unravel grew out of an
attempt to answer this question to give
you some background there was some
discussion about improving the state of
the repple back in 2015 on the close of
death mailing list and earlier this year
crystal Cole and I got to talking about
these topics and we saw the designing
unravel and unravel so unravel is the
protocol it's sort of in the same space
as n repple I know confusing names and
Christophe gall did all the heavy
lifting for the implementation although
I was lucky enough to be able to
contribute a couple of design ideas to
the total protocol and then finally
unravel I don't know if you can see the
bottom line is the command line client
that is sort of the first implementation
of this protocol okay so the confusing
names are confusing so I drew a little
diagram so unravel as the client talks
to the closure process through the
protocol which is called unravel
okay um so the rest of this talk is
going to be parked part practical and
part conceptual and because everybody
likes demos I'm going to start with the
practical part so unruffle is as I said
a command-line client as so you can
install it on your machine and it's
pretty easy to install if you have NPM
installed and all that NPM has some
problems sometimes but for the most part
it works pretty well so this is how you
use it you can also use yarn which these
days I prefer if I can and the next
thing you need to do is to set up your
closure process to accept connections in
the form of the socket server and that's
a feature that was introduced in closure
1.8 and it's actually pretty simple to
enable the only thing you need to do is
to set a Java system property called
closure that server to something to an
Eden string which is pretty much
self-explanatory I think and once you do
that you can sort of netcat or telnet
into the process and what you see is
simply a command prompt that you are
used to when you start the regular
closure jar with the main module the
next version of boot will have a task
that makes it even easier so you can
just type boot socket server and it will
automatically start a socket server in
the background
okay um as you saw just a minute ago you
can use telnet to connect to a socket
server socket server apple and unlevel
is designed to be sort of a drop-in
replacement for that so instead of going
netcat localhost
5055 you can go unravel localized 5055
and what you see is pretty similar
except that you have this little banner
at the beginning but unravel comes with
a couple of features that the basic bear
closure main level does not have so one
of the things that people have come to
expect is read line like editing
functionality so this means that you can
sort of move around in the line that
you're currently editing with the cursor
keys and you can use like ctrl W to
delete the last word and things like
this unravel also comes with basic
support for tap completion it's not
perfect yet but it can sort of complete
VARs and name spaces one more feature
that you're probably not missing if you
don't have it but it's really important
and you'll probably notice if you don't
have it is the ability to interrupt
evaluations so for example if you
accidentally type thread sleep long max
value at some point you probably get
tired of waiting and you want to stop
the process and you can just do that by
using ctrl C when you're using unravel
ok now moving on to the more interesting
features the first one I want to mention
is that unlevel is aimed to have a very
fast startup time so this is sort of in
comparison to the normal way we start
Rebels using line ripple or boot ripple
and in my experience that always takes
some time to get going unravel on the
other hand
has a sub-second startup time and
there's still some room for improvements
there how's that possible
we know the closure sometimes can be
slow to start up the the trick is to use
LUMO LUMO is a closing script
environment based on no GS and based on
the closer script bootstrap compiler and
it's developed by antonio montero who
introduced it a little bit more a little
bit more than half a year ago here in
Berlin at the closure Meetup and since
he did that it has come a long way I
really encourage you to check it out
it's amazing for you know testing a
little theory about photo script trying
things out but you can also use it to
build real command line applications
because it gives you all the libraries
available in the NPM ecosystem and you
can you can just use them using
JavaScript Interop so if there's one
thing I want you to take home not really
related to the main topic of the talk
then it's check out LUMO it's really
amazing ok then we also have a couple of
smaller
nice-to-haves features one of these is
the ability to show incomplete forms so
for example as you can see here it's
really big so maybe it's more obvious
when it's so big but what I did here is
to miss type one of the parentheses as a
square bracket and unravelled will let
you know immediately by showing a red
namespace indicator so it you know you
don't have to actually send the form to
the repple to to get feedback
okay so the next feature recorded a
little demo here you can see when you
type a name space or you type a a name
of a function and it immediately shows
you a short dog string okay it's a
little bit fast you can sort of get the
point
it shows you a doc string of the
function describing the function
basically the first a couple of lines of
the doc string along with the function
signature so you immediately know which
arguments to pass to the function if you
want to you can press control and that
gives you the complete dog string of the
function this is a feature that is
available in cider and it's very useful
there but I find it useful as well when
you're working in a terminal repple okay
so this is a the interactive bit of the
talk so I would like to ask you who has
seen something like this you type
something into your Apple and then you
get just a huge dump anyone like there's
just a quick show of hands okay almost
everyone yeah so for me is really common
and I get annoyed every time so we try
to do something about it
so what unravel does and what the
unravel protocol does behind the scenes
is to restrict the printing of lazy
sequences or of sequences in general
so when unwrap a print a sequence it
will only print a certain number of
elements up to the variable print length
I'll show you how it works in a second
but what the client will do is to show
an elysian mark three dots to show that
not all elements have been displayed yet
and the user can sort of request the
continuing continuation explicitly
Alucard so this is how it looks again a
demo so here I am bold enough to just
type
the range function into the methyl which
is a you know a no-no in a regular
closure rebel because it would almost
crash the whole thing but here is sort
of fine right you you just get the first
ten elements and then you can say
explicitly if you want to see more I
mentioned Stuart hello waist talk at the
beginning and I still think it's a
really amazing talk watch it definitely
but there's one thing I want to sort of
take issue a bit a little bit and he
what he says is you shouldn't be typing
things into the rebel and the confession
I should make is I really like typing
things into a rattle I like terminal
rattles I like line based rebels so of
course what Stuart means is that you
should use an editor like a proper
editor like editor like like Emacs or
cursive maybe and use all the facilities
that the editor gives you to edit your
code and then sort of send it off to the
repple like that well you can hear
basically see how I how I work with
sequences just sort of exploring how to
solve a problem in this case getting the
users in my ATC password file sort of
you doing that with unravel and
displaying some of the features so I
agree that it's useful to use a buffer
backed by a ripple in the style
popularized by Emacs and I do it all the
time of course but I still think it
should also be possible to just have
this line based interface and I think
it's a really good interface you know
it's it sort of gives you a lot of head
space because you can only only focus on
your problem you're only looking at this
one line that you're typing right now
and you also get weed line history so
you get almost an infinite history of
all the stuff that you type into the
raffle before
and that can be very valuable because it
it you know it can have all kinds of
gems and tricks in it and if if you want
to go back you just have to search your
history so I really like typing things
to revel up to a certain point at some
point you know you want to make things a
little bit more permanent and just copy
them over to the editor
okay so that's it for the part where I'm
talking about the command-line client
about about unlevel now I want to talk a
little bit more about the motivation
between behind a building unravel so how
do we expose a wrapper
well maybe the first question to ask
would be what is well anyway so I always
occurred to me that maybe a better word
for Apple would be propel because the
phases that you go through are actually
more accurate accurately described that
way so that's a prompt face you see the
prompt then the rapper reads string
evaluates substring principally result
back and then sort of loops at the
beginning and maybe there could be
another letter in that abbreviation for
compilation as well if you want to look
at a blueprint of how a rapper works
it's a good idea to look at the function
signature of the closure main weapon
function which is sort of the basic
repla interface that closure comes with
and there's a another version introduced
recently called closure core server
ripple which is almost the same thing so
how do we expose a rebel how do we
communicate with a rebel so maybe the
most straightforward answers of that
question would be to sort of do the UNIX
way so start a process the terminal is
connected to the process and the process
reads from STD in and writes the
standard output so that works for like a
line based rebel and it also works sort
of for buffer based rebels so for
example Emacs
comes with this idea of inferior
processes which is Emacs jargon for the
ability to launch a process in the
background is sort of connected to the
buffer that you're working in and if you
type something into the buffer that gets
sent over to the process and vice versa
and I should mention the enclosure Emacs
mode that and the other Guardians been
working on a lot lately and it works
based on this principle and I think it's
good is you know it's simple it's it's
straightforward but it has some
significant drawbacks so one of those
drawbacks is that it only allows a
single ripple per process for kind of
obvious reasons because UNIX process can
only have one standard input and one
standard output so the the solution to
this is to decouple the inferior process
from the editor process and I think you
want to do that because it's a bit
annoying if the ripple is sort of
dependent on the editor in this way so
for example if you restart the editor
suddenly your program also has to
restart and that messes with your
wrap-up time so yeah the the obvious
solution is to uses the TCP connection
to mediate between the editor and the
server of the process and you may ask
you know isn't that exactly what n R
Apple is doing so again you know it's
slightly a confusing name unravel and
unravel and it's true that unravel is a
fantastic project it's mature it works
really well it's been used in a lot of
projects so we wouldn't be where we are
today in the closure community without
and where poets for sure
so for example if you're using side of
these days
Saida is based on the envelope protocol
and any Apple itself is an RPC protocol
and uses asynchronous communication sort
of sending messages back and forth with
a rapid process and as I said it I think
that's fine it's a good approach but
unravel has decided to take a different
approach here so one of the reasons I'm
just going to explain I'm going to
explain the design goals in in a minute
but before I do that just just a few
preliminary remarks about that so one of
the reasons we went this way is that we
want unravel to have a low barrier of
entry for new developments so we want
people to be you know quick to just jump
in and buy the new tool based on the
unwrap of protocol and that's proven a
little bit more difficult with an apple
because of the choice of the
technologies used their second point I
want to make is that unwearable uses the
sort of standard ripple way of
communicating users synchronous stream
based interface whereas NREL as I
mentioned is based on asynchronous
communication I think that makes unravel
a little bit more closer to the spirit
of this pebbles and then finally this is
maybe a superficial difference but
unraveled was started you know in the
spring of this year so it can use a lot
of the features that were introduced in
closure
since NREL was started and maybe the
most important of those features is the
introduction of the socket server
functionality
really
a feature without which we wouldn't be
able to implement unreported easily okay
so for the rest of the talk I just want
to explain the design goals that were in
play when we came up with unravel
protocol so first one sort of ties in
with what I've just mentioned unruffle
is based on streams so it's based on the
idea that using a stream as the input
and a third mechanism is is a good idea
so again if you look at this closure
main rebel blueprint you can see the
different ways in which you can
customize a rebel so you could change
the way the prompt is printed you can
change the way characters are read into
forms into coded data structures you can
customize the evaluation function and
you can customize the way values are
printed back to the rebel so the rebel
user and something that you don't see
maybe at first class is at first glance
is that all of these functions these are
others functions passed to the rebel
function each take an implicit argument
as well in the form of dynamic VARs so
the most important of those are the
earmuff in and earmuff out bars which
represent the input stream and the
output stream respectively so this is
really close in spirit to the you know
unix idea of community you're
communicating using standard input and
standard output and you can sort of
understand a rebel process as a
conversation something that reads from
standard input from EMF in and writes
responses to
so let's better give the the distilled
version of what our Apple does so I
mentioned that unravel users streams use
input streams and output streams but the
output stream is actually not as in a
classical rebel a stream of characters
instead is the stream of object is a
stream of values so the protocol we the
encoding we chose for unravel is Eden
which has the really neat feature that
if you let get into a running unravel
server you can sort of see what's going
on by just looking at the Eden values
that are returned by the server because
we as human beings are used to or as
coded programmers I used to parse
closure syntax so it's really easy for
us to understand
Eden syntax as well so the problem with
the you know original character based
stream is that a single output stream
includes many different things it
includes you know stuff that gets
legitimately printed by the functions if
it is for example using print inside the
function but it also includes the
evaluation result of the function and it
includes the prompt the name space
indicator and maybe also stuff relating
to exceptions so if as a tooling author
you go to sort of go in and look at that
you would have to pass that and you
would have a really hard time and doing
that so instead what unravel is
returning is a stream of Eden values
instead of having all of these elements
intermingled in a single character
stream in unruffle they are neatly
separated as separate messages so
there's an odd message there's a
prompt message there's an evaluation
without message and so forth so Eden
gives you sort of these both both of
these things it's convenient for the
machines to pass and it's still kind of
friendly to tooling authors because the
authors are human beings and they can
look at the Eden that is printed out and
sort of get a sense of what's going on
so this this is about the inputs of the
output stream but now I want to talk
about the input stream and unravel
started with the design goal of actually
not doing anything with the input stream
so instead of instead of sort of
legislating a format for what goes in to
unravel you can just send any closure
forms you like just as you would with
the closure main level so prescribing an
input format is an anti goal of anti
rebel for offer of unravel so whether
you're sending regular evaluate
evaluations like for example equals 1 to
2 the rebel or you're sending tooling
commands all of those things take the
form of regular closure function collars
I mentioned that unravel requires
closure 1.8 and one of the reasons for
that is that the socket server feature
was introduced in that version the neat
thing about this is that it enables
unlevel to be very frugal when it comes
to dependencies so you don't need
anything running in the server except
for what comes in the regular closed jar
no further dependencies are required and
this also means that the obstacle to
configure your server are very very low
the only thing you did need to do is
configure the system property that I
mentioned before there is no additional
setup required on the server side
v design principle is upgradability so
the idea is that we can start with a
repeting and can sort of transform it
into a representated unruffle we use
this principle by taking a closure main
rebel and transforming it into a unread
possession the way this works is kind of
an interesting concept is that the
entire unravel source code it's kind of
100 lines or so of closure source code
gets concatenated into a single blob and
when an unravel client for example
unravel connects to a socket server it
sends all of the code over to the server
and wait until it receives the first
unruffle message and that would be the
unravel hello message and once you get
that message the first Edin value you
can assume that the rest of the session
is going to be you know
structured in the way that you expect
with the unravel protocol a serious
stream of Eden values and the final
principle I wanted to mention because
it's a cool name transclusion and I also
had to look this up if anyone is
wondering what that means
so transclusion means that a server in
responding to this request responds with
a full description of the resource that
is returning this is something that is
well known from you know by-the-book
implementations of rest Web Services
where for example if you post to a root
you get back HTTP response that it
includes as one of the response headers
pointer to the resource that was just
created and it's sort of a full
explanation a full URL that points to
that resource in the same way unravel
for example when an elysian gets
generated will return a marker that
allows you to request a continuation of
that lazy sequence and that market
itself is just a closing form that you
can just send back to the server so you
don't really need to know a lot about
the protocol to use it again you can
almost use it from Redcat if you want to
so that sort of wraps up what I wanted
to tell you the basic idea of one rebel
is pretty simple I encourage you to go
and look at the protocol specification
it's pretty simple I also encourage you
to try out unravel as a sort of a proof
of concept that it actually works you
can use it with your with your boot or
line again or just regular and closure
JA and processes and the idea behind we
unwrap really is that it should make it
easier for tooling authors to come up
with new tools to make improvements
about the experience of writing closure
code and here just mentioned a couple of
ideas how that might look like I just
saw on another person screen like it's
just a you know a not pretty printed
eden value with a lot of random keys you
know it's really hard to see the forest
for the trees and that you know in that
way of presenting information and if we
had you know better interactive in the
inspector widget for for those kinds of
values that would be really valuable and
that's the kind of thing you could
develop using unravel so that's about it
thanks for listening please check out
the project and please give one level or
unravel a try thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>