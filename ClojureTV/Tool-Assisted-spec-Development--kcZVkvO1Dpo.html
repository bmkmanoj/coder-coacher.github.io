<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tool Assisted spec Development - | Coder Coacher - Coaching Coders</title><meta content="Tool Assisted spec Development - - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tool Assisted spec Development -</b></h2><h5 class="post__date">2017-10-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kcZVkvO1Dpo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this talk is called tool-assisted spec
development
my name is Ambrose I work with Sam tub
and hushed at at Indiana University very
excited to present this work so I think
spec is one of the best things that's
happened to closure in a long long time
first of you have a specification
language developed by the creative
closure rich Hickey who better to name
to know the idioms he wrote the book on
idioms so now he wrote the specs on how
to check those videos not only can you
write in a language that communicates to
other programmers closure programmers
but you have ways to check that your
functions actually conform to those
specs with runtime instrumentation you
can also use generative testing and I
already talked about the documentation
values you can do all sorts of things
with spec including passing and I'm sure
the fact that it's an easy to use it's
just we just have Lisp data as the
syntax there are so many different uses
for spec but let's see a show of hands
who's avoided writing a spec because
they were - any experience with spec
who's avoided writing a spec because
they looked at this function and it was
a monster that no not today not today
so who partially wrote a spec and you
write half of it and they were like I'll
do it another day I'll do the rest the
other day but a little comment this to
do fix me all right who's updated aspect
because they found a typo in the spec
whose updated aspect because it became
out-of-date with the way that the
function works or the data works so this
is really the the main use case of a
spec so I'm here to tell you that we
need help writing our specs you may not
have realized it but you go through a
lot of thought a lot of deliberation and
some of them can be automated
so here's an idea we have this
dynamically type program it pretty much
just works it may be a little icky in
the middle you know but it just works
and spec is designed to model that the
way that your program currently works so
here's the idea just run the program and
see how it works
gather data get up gather observations
and use those observations to generate
specs
alright let's draw a straw an analogy
just to make sure we're all in the same
page let's consider a megaphone as a
function if a megaphone is a function
its input well I'm gonna yell into it
I'm pretty loud and then the output is
going to be even louder
it's gonna be sound to sound and the
problem is what is the spec for a
megaphones we're kind of mixing our
analogies but if you think of it more of
as a function that makes sense
if we want to classify how this this
works this this function works so the
step one is an instrumentation phase how
are you going to instrument a megaphone
well you set up some microphones on
either end the the microphone on the
left knows it's the megaphones input the
microphone on the right knows that it's
the megaphones output and we're gonna
save this data somewhere in the database
once we observe the running program I
shout into it we have some data about
the the running program and step three
profit we summarize the execution and
you could imagine if megaphones and
trumpets we saw some D major G major
notes maybe this is kind of where the
analogy breaks down you get any
questions about this analogy
so one of these steps is a little more
difficult than the others and that's the
third step how do we go from this big
mountain of data into a usable spec how
do we derive good specs what even are
good specs I don't know we know when we
write them but how can we get the
essence of it I don't really have that
answer just spoil it but let's look at
let's have a feel around this problem
space I'm going to divide the slides
into the top we have values that we've
observed during the program execution
and in the bottom I've written some
specs that you could plausibly write for
these these values so let's say that
we've seen the key word foo you could
imagine that a function that sees this
keyword food as its input it might not
actually care it might accept all kinds
of things so you might want they don't
care spec this first one you might care
that it is an instance of keyword or you
might actually care that it is food you
might want an enumeration so already
some decisions we're just just a key
word so let's move on to closures
fundamental data structure Mouse there
are many different ways you can use maps
here's one a map of integers to integers
you could imagine you just care that
this is a map you could care that it's a
map of instance you might want to
constrain exactly the keys and values
probably ill-advised but it's possible
or you might think okay these are
positive integers keys positive integer
values all plausible things plausible
situations okay so this is a common
idiom in closure we have an entity map
we have key word keys to some value and
the idea is the programmer wants to is
going to bank on particular keys being
present or optional so in here you can
imagine this point key other sorry this
point map the the the program is going
to
back to X or Y key but it could be
possible function that just expects a
map of key words to ants like this first
first SPECT oh we might want to include
that it is an entity map like the second
spec all right the values are on the
left now and the specs are on the right
but now we have a tagged entity map if
we look at the the value on the top left
it's a it's a square the we're
dispatching on the shape key and you can
imagine that we don't care about the
structure of this map the first spec
this the second spec we care about that
it's an entity map the third spec we
care that it's a multi spec and multi
specs make a little more sense if we add
another shape so if you have a rectangle
and we've added an optional entry to the
second spec notice that we require a
shape and a width but an optional height
but we've lost thus the structure of its
Taggard Ness and with the third spec
we've added a rectangle respec if we
actually cared about that structure okay
here's a recursively defined map we have
a square that inside of it has a
rectangle inside of it has a square now
we probably don't want a spec that is as
deep as this thing but who knows maybe
we do so you can imagine on the on the
Left we've got a few a few of the more
trivial ways you could spec this map but
number five we could have a recursively
defined map with an inner key that is
itself referencing the the shape multi
spec
oh that this is a lot of decisions that
we make implicitly so how do we make
sense of all this so one way I like to
think about this is viewing the possible
specs as a lattice and as we observe
different values depending on how they
relate to each other we move up down
left right on lattice until maybe we get
to the top we've seen it we've seen it
also you know
care what we get like and I think it
makes more sense to move up on this
lattice but we'll see so how do we build
this lattice for closures back well you
think about the heuristics that are
surrounding closure idioms you think
about what closure program is typically
care about in their functions and you
build a lattice that way so let me
demonstrate on the Left we have our
observed values we've we've recorded
these values at run time on the right we
have what we've chosen for this
particular spec so here we've chosen
integer ha because we've seen 1 2 &amp;amp; 3
okay on the next slide we're going to
see some more values we're gonna see
doubles and we've moved our chosen spec
up the lattice and actually that edge is
the heuristic like the heuristic is if
we've seen intz and we say doubles that
probably means that we care that those
two things were preserved in or doubles
and if we see some more things usually
in my experience closure programs that
see three or more integer number types
of which mixes numbers and and floating
points it should be in number ha so it's
another heuristic so let's look at maps
so let's say we have a rectangle map and
it looks like a tagged map but we don't
have multiple tags so it's probably not
worth remembering that this is a tagged
map so at the bottom of our lattice we
just remember that it has a shape
keyword and this shape shape entry that
is a keyword but if we add another shape
if we add a circle suddenly we have two
examples of a tag so that's the
heuristic to move up to a multi spec in
this case
if we see a totally different kind of
map here
it's an untagged entity map but the the
key sets a completely disjoint so we
probably want to throw away most of that
structure so we move up to a map of key
word and if we see a whole bunch of
stuff like 42 symbols and key words we
just say okay this is this just takes
anything this is like the identity
function or yeah all right never
remember how to bring up the demo
all right let's see where I just want to
make sure I'm not cheating so this is
closure time it is the tip of the master
branch the head rather okay so what
we're going to do we're going to
generate some specs for this so step one
is install line types and say do it
you go to your line profiles is this big
enough you go okay yeah so this is we've
installed this okay so that means we
have line types available to us so the
next thing is we're going to have a
runtime runtime dependency on type
closure of course we need type closure
to infer specs
and let's let's not do white let's let's
bump up the closure version because it
will probably break otherwise okay let's
look for a namespace that we want to
generate specs for well probably the
core namespace closure time core let's
have a look some of the defens in here
okay deprecated that's boring now okay
there's some these things look like
thunks okay these wouldn't be too hard
to spec manually once have a look date
oh my god I don't want to write that
spec let's ride this spec or let's get
line type to write this spec
okay so obviously the first thing that
happens is the type closure has to
initialize and then the next thing
that's going to happen is that basically
we're going to die it's done
but let's go to the top we have
instrumented the closure at the closure
time core namespace and what this
basically means we run it through type
closures compiler and basically rewrite
pieces of the the pieces that we care
about in the runtime so here you can see
we've we've instrumented some of the
initial values of the death and we've
instrumented some local functions so we
actually have access to the to the
source code we don't care about local
functions in spec but this tool can also
output type closure types and one thing
you need in type closure is local
annotations so it will instrument your
your local functions but it won't affect
your output in the spec so notice we we
have some errors in our unit tests so I
happen to know why this errors here if
you instrument closure time it breaks
pointer equality for functions usually
odd doesn't matter but there is some
some funky looking logic that does break
pointer equality but doesn't seem to
matter it okay we've got a bunch of we
have eleven errors out of 588 assertions
but apparently there is there are some
annotations let's have a look at them
well I have
all right let's what was it
I know your local time has a bunch of
arguments okay so we've got local time
okay so here's the generated spec for
local time it looks pretty good actually
notice that we have an era T for our
hour minute by minute second hour minute
second Milly's so 1 2 3 4 we have a 1
AAG 3 augs and for a hang on this
doesn't two odds missing so one thing
that we've discovered is that our unit
tests complete enough
we haven't exercised this path it's
interesting that this tool also doubles
as a very crude test coverage tool I
guess in their defense I could have
broken that tab that that these broken
tests could have just prevented the to
our execution but I'm just gonna blame
closure time for now oh yeah those yes
oh yeah here's the local time oh yeah I
didn't want to write this one I'm glad
that this is written for me so this
looks pretty good
ok let's go back to the slides any
questions on how to do that I was pretty
easy okay
alright let's look at some real world
examples the kinds of specs that we can
generate for their projects well let's
start with the good news so as we saw we
can take names out of the program a
source and reuse them
actually you don't even need access to
the source just grab the odds lists and
do something fancy and we can put these
straight into the the the F def syntax
this is this makes sense fairly
straightforward but this is work that we
have we would have to do manually and
there are a lot of positions inspect
that require extra names like the or
macro and you can you can see the kind
of strategy that we go for if it's a
char huh it's a char hockey word and
basically we generate names that are
sufficiently unique and pretty as well
and only very occasionally you'll see
Jenson underscore on their file of bug
report
so this this approach works particularly
well with simple collection manipulation
functions I don't know what this
function does but apparently it takes a
collection of intz and returns a
collection of vectors events so this is
pretty much I assume if this is correct
I wouldn't really change this very much
so this is pretty close to handwritten
and we've seen multiple era T's good
multi specs so how do multi specs
actually look in in real generated code
so this is a preliminary attempt to
generate specs from closure scripts
compiler closure scripts compiler is its
AST format is recursive so you can
imagine the the data that we're
gathering is going to be very it's not
kind of the it's all
it's old raps now it's completely
unfolded so there's a how do we how did
we fold it back up and I'm actually not
going to explain how but there's a bit
of magic that goes on but in terms of
the actual dispatching you can see that
the multi spec we've we've observed a
map of vector or Navarre and presumably
these haven't happened at the top level
of these data structures so we've we've
gone in and applied some magic and
extracted out the things that look like
they have the same tags and it's not
shown here but the omit function takes
this this multi spec in the actual
generated spec so that's that's good
news
so we also generate useful aliases if we
see the same kind of structure in two
different places
generally if they have a similar key set
modulo some optional keys we take those
the same map in those different
positions you can imagine a
configuration map being threaded through
your entire program you don't want the
entire configuration map just in that so
we can extract that out and make a
useful alias and you can see we have two
different two different references to
this aliases but can you guess how we
got the name for the alias so the first
key is called name the second key is
called n s the keys called lists this
this is a bit crude but it seems to work
and it's much better than a Jensen and
I'm not actually sure the best way to
get better better argument better alias
names you could imagine if you saw an
alias grow through a particular program
position that was named like a function
argument you could reuse that name but I
haven't got that all right so this is
type closure syntax because this would
be to lodge in closure spec this is an
example of a mutually recursive
map format we have this this would
correspond to three multi specs and this
is actually some spec that I generated
from a little toy that I wrote it was a
type system that had types propositions
and expressions and these are the
dependencies that we automatically
generated and yeah it was pretty much
handwritten and it looked handwritten
except for the cases where I didn't add
unit tests I know that there's a lander
in this why isn't oh I forgot to write a
unit test all right what sucks a lot but
here's a little little bit of it so you
lose keyword arguments right now I
actually don't know how to how to get
them back but you can see you can see if
you squint if you started off from this
spec and you wanted to to write keyword
arguments you can find them so if we
look from the top of this spec you see
we have one argument okay it takes an
int and then we have a five argument
that takes the int and then a min int
max can't so clearly this is supposed to
be keyword arguments and ideally you I
mean one good thing is that if you go
from this spec and you know this the
syntax for keyword arguments you could
easily recover the spec but actually I
don't even know the syntax for keyword
arguments that may be related but one
interesting thing is that to keep the
representation small for the data that
we gather we collapse all era T's of our
eighties of the same length so all five
arity functions at this particular
position get lost so say we we have a
five argument call here that calls min
Max and another five argument that calls
max min those two are going to be merged
and we're going to just all that
structural information is going to be
lost and this is kind of an integral
part of how the tool works so I'm not
sure how to how to preserve that
information you can imagine if you see
enough key
it's just to keep them separated another
inherent problem is over specify over
specificity if you don't unit test
enough then you're going to get things
like this like this is a C Keable but or
a vector of intz but we've only unit
tested with this with a three the three
topple this is actually pretty pervasive
this is one of the main main places
where you apply heuristics like if you
just see the number one you don't want
one if you just see a singleton
collection with one you probably it's
probably a C Keable events but in
particular cases you may want something
more specific say it's a helpful
function that you D structure you might
want the the output to the if you if you
call a helper function and it returns a
three tuple which you then do structure
you might want to actually preserve that
information all right so I have one
slide showing some some long specs so
this is might not be able to see the
right-hand side but this is three pages
of the same function so there are no
interests argh inference at all if you
imagine we're trying to apply this to
like plus or minus that has variable
arguments and you hold it in your unit
test you caught it with two arguments
for argument seven arguments 14
arguments guess what you're gonna see in
your generated spec something a bit like
this so actually that this example is
even more interesting it's not I I think
I realized recently that this isn't a
keyword argument and this isn't a rest
argument I think this is it has an XML
element followed by a string so it's
actually pairs of things that don't
start with keywords so it's yet another
idiom that we have to to think about
that I haven't
all right so what if some things in the
immediate feature that did I want to I
want to look at so just moving into type
closure syntax because that's what we
can write polymorphic types I'm
interested in capturing the way that
point of equal things flowed through our
program and this isn't really something
you can say very succinctly inspect but
you can say in type closure and in type
closure syntax you can you can actually
verify that these types hold by type
checking the functions so here's three
bits of data the first bit of data it
should be somewhat familiar you can
imagine that the unit test we've written
for identity was one we identity one
okay great
we've inferred into int but another
thing we've inferred is that a pointer
equal thing a thing was given to
identity and then a something that was
pointed equal or also came out so and
this probably happened twice this is two
bits of information these are fragments
and information that I don't know what
to do with if you think about how we
could apply this to map I have this
little function my map this first piece
of information is the the concrete runs
of map we see we've inferred it as a
higher-order function that takes
instance symbols but interestingly we
have all these fragments of polymorphic
types so if you look at line 29 we've
observed that a thing flowed out of the
the collection and into the function on
line 31 we've noticed that the thing
that flows out of the function flows
into the output collection this is kind
of where I want to take this work next
all right we have plenty of time I may
go backwards here's a magic trick okay
number from one to five
another number from one to five three
four okay all right let's do this three
one two three one two three four okay
the other magic trick is the Wi-Fi
working
all right what is this utility library
for encoding and decoding data let's see
does it have any dependencies they
probably won't stress the network very
much
so let's clone it and let's generate
some specs for it
nice ring crew dick
all right I've never seen this this
library before
all right so what have we got
we've got winged util codec it's got so
scons Wow Wow we're gonna get some sin
anyhow you are LD huh
okay oh yeah this is like oh yeah this
is interesting
we've got a bunch of protocols okay
let's see how we go stop stalling
what does it ring I'm sorry I forgot
ring you to call that codec dot util
oh whoops
all right any questions but while this
runs Stewart
so yes right now that my entry point was
the the granularity of a namespace and I
was my target was moving from an unspent
project to a SPECT project so you could
the DOS I'm kind of frustrated that this
doesn't have a small API at the moment
but one example of something that didn't
have very good unit tests was a little
text adventure game so I instrumented it
played it for a couple of minutes and I
outputted the spec so what great
so what we do is that we instrument
every top level function in a namespace
and if it gets cold then we generate a
spec for it it could be extracted yeah I
just I like my one dependency and I
apologize type closure is a bit of them
I couldn't believe how big type closure
this is as big as closure seola Wow
so
this this strategy was inspired by my
experiences of how real closure projects
are tested so the the fact that this use
uses unit tests at all is this purely
relies on unit tests or mostly is is
informed by the the programming culture
that we have if you're gonna have a
project you're probably gonna unit
tested so I can probably run it for you
and now with the introduction of speck
people are probably going to instrument
their functions and all the time so
they're not gonna have negative examples
because they're gonna fall outside of
the spec so you're correct that you know
garbage in garbage out functions so the
tests will mess up the specs but in my
experience it's not not a problem in
practice all right let's let's see what
happens I'm gonna have time for two
magic tricks oh okay that's let's codec
all right so she map any so she owns map
key Val alright let's let's have a look
at some of the unit tests what what
would being exercised here so she okay
Asajj conjure isn't going to help where
is that cold in forum decode okay
so form decode takes in strings Maps
okay well that's that's one thing form
decode let's see what form decode got
and we actually successfully extracted
this name out and to say that we have a
one argument and a two argument function
that's good
anything else interesting in this file
any house you could say that we use
nillable Wow okay
all right so this is this was probably
too easy okay all right I'll have one
more magic trick and then more questions
number between one and ten nine another
one where's my tab one two three four
five six seven eight nine one two three
four five six seven a line Engine plugin
I let's have a look
does this even have you know it doesn't
have a price no is this line code Oaks
all right this doesn't have unit tests
well it was seven and nine all right
let's let's just do yeah one two three
four five six seven one two three four
five six seven eight nine component
does this have unit tests did you unit
test this G oh good okay okay
oh I'm out of time
well try this at home</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>