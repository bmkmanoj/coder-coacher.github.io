<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Travis Vachon - cljs All The Things: Full Stack Apps with ClojureScript | Coder Coacher - Coaching Coders</title><meta content="Travis Vachon - cljs All The Things: Full Stack Apps with ClojureScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Travis Vachon - cljs All The Things: Full Stack Apps with ClojureScript</b></h2><h5 class="post__date">2014-03-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/a8has_eEka4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Travis Vachon I work for
starting a company called distiller I'm
Travis on github and I me VaShawn on
twitter i am going to talk about closure
script today but first I really need to
apologize because the title of my talk
is totally me me and I know that's super
lame but there are no more memes in the
entire presentation I'm getting them all
out of the way right here and so you
won't have to deal with that again so
you're welcome second a clarification so
I'm going to be using I know the
description of the talk reference to
apps and if somebody got the impression
that I'm going to be talking about how
to build an iOS app with closure today
I'm sorry because we're definitely not
going to do that because that's frankly
sort of insane in 2014 maybe someday but
definitely not today I'm using app in
the sense that Tim Bray is using it
these days which is to describe
basically a collection of software that
sort of forms a cohesive whole because
that's what people are using that term
to mean and third I'm going to do a demo
at the beginning the dangerous live
internet beginning of the talk demo so
cross your fingers so i am going to be
demoing deploying closure script to an
environment called parse today and
what's cool about that and what's cool
about closure is that it makes it really
easy to do demos like this if anybody
has never used the line engine template
stuff that's what i'm doing up here line
new par sep demo and that's literally
something that you can do on your
computer home today you can just type
line new par cette demo and you'll have
a parse app and that's because lunge in
is pretty awesome i'm not doing too much
else here i'm copying some some global
configuration i'm copying a little bit
of configuration so that you don't see
the private things that I'm pushing up
and then I'm actually doing some magic
that I'll talk about a little bit later
Oh
right I'm not connected to the Internet
okay well then we'll wait on the demo
until I am connected the internet which
i guess is now oops
okay right okay so I thrown out a bunch
of terms here so you guys probably have
no idea what I'm talking about which is
totally fine because we'll figure it out
by the end when I talk about parse I'm
talking about something that you can't
see I'm talking about a website called
parse com so what happened with parse
com is that a guy tried to build a
couple iOS apps and he got really
frustrated because it's a sort of a
terrible environment and so he built
rather than building these IRS absently
really working he built an
infrastructure service to make it easier
to build par steps and and to build iOS
apps but what's cool about this is that
it's actually good for building more
than just I OS apps you can tell I'm
just delaying so let's go back into the
thing here then and we'll come back to
the devil in just a second so my company
is building an iOS continuous
integration and deployment service we
also want to make it easier to test
ideas on iOS we started out building iOS
apps but mobile is great and mobile is
horrible and we just had a lot of
trouble coming up with something that
would would work really well and and
something that we could test quickly on
interested users parsed is a cool back
end of the service makes it easier to
build iOS apps and it has a hosted
nodejs like environment for deploying
code to there are a lot of as a service
things these days and clad code is
closer to App Engine than to AWS or
something like that the important thing
is that it deploys you can deploy
JavaScript to it and when you're
building iOS apps objective-c is a
necessary evil you can't get away from
that but Java scripts at least no matter
where you are is not the rest of this
talk is a story of our experience with
closure script on parse but it's not
really about parse because this isn't an
advertisement for parse because we're
not at the Facebook Developer Conference
it's about closure script on nodejs even
though parse isn't isn't really
technically nodejs but even more than
that it's a story about JavaScript and
the fact that anything we can do in
javascript we can do enclosure script a
little bit better and that's cool
because javascript is everywhere it's
it's just it's all over the place this
is actually the second weird place we've
deployed closure script the first was on
the left over here that's actually the
the iOS UI automation tools and you can
use that to actually control a live
iPhone and run tests on it and verify
things about the the interface and
closure script runs there too and
JavaScript I'm not kidding it runs
everywhere it's just in all these crazy
places and so the rest of this talk is
is hopefully convincing you that you can
run them wherever you want so let's get
back to our demo so we we created a new
closure script project using a line
engine template that made it a one liner
line engine actually goes out to the
Internet and finds the template that you
named and pulls it down so that's that's
all you got to do and then we deployed
our apt to parse and you'll have to
trust me here because this is what it
was doing before I deployed this code it
was a page not found and now it displays
a widget and if we go into the data
browser and we add a new widget to and
we wait for the internet it'll be over
here and that's pretty cool and just to
convince you that this isn't you know
just like a an easy way to create
objects you can do things like sending
SMSs SMS is really easily so check this
out we bring in
a little couple named oh god you bring
in a couple namespaces and we add a new
endpoint here and then we're going to
deploy it and we'll wait a little bit
longer and and then we'll come back to
them in a few minutes how many people
here have used nodejs awesome how many
of you believe Express cool so this is
just expressed they they have expressed
available they have a number of other
modules available you can send email you
can send text you can send all sorts of
stuff really easily okay and we'll come
back to that once it's deployed okay so
the first thing that I'm going to talk
about is just our story what we did and
and how we got to be able to run closure
script on their environment when we
started developing iOS apps we knew that
we didn't want to build everything
ourselves we knew that there were a lot
of shared things that people had already
built and we had no interest in redoing
all of that we found parson we realized
that you could deploy JavaScript to it
and my first thought as a hardcore old
school closure guy is I really want to
run closure and not JavaScript because
if I have to write Objective C in
JavaScript all day I'm going to go
insane so so how'd that work out so this
is a parse project this is actually what
a very simple JavaScript web app would
look like to you have some configuration
you have a JavaScript file and you have
some HTML and this is what a closure
script project looks like you have some
configuration you have some HTML you
have a project file and then you have
some closure script source and the
project file is just a normal line
engine project file with a closure
script build stands it in here that's
actually pretty straightforward how many
people have actually built closure
script things anything with closure
script so that's good so you guys
probably get
what this is doing for those of you that
don't it's not really as scary as it
looks this just says we have one bill
that's called server and you can
actually light a bunch of this stuff if
you only have one build and the source
for that build is that source source and
then you pass some arguments to the
compiler you say hey compiler take the
result of compiling all that closure
script and put it in cloud main used
whitespace optimizations only pretty
print target nodejs and don't use a
hashtag and actually a number of these
didn't really work when we started so
did it work not really I mean it did we
started out targeting the browser which
was what we had to do because targeting
nodejs had some even worse
incompatibilities for what we wanted to
do but there were issues with the
detection of a race so in JavaScript I
mean objects are sort of this this
detecting the type of an object is a
tricky thing the the runtime has some
support for it sometimes if you're
nodejs it has a handy function called is
array that you can use but that's not
available in all the browsers so that
was the first thing we ran into the
problem was that well and there was some
philosophical concerns why are we
targeting the browser we should be
targeting the environment that's closest
to the more actually deploying to which
is noted so we tried to target node
there were some even bigger issues there
the util module is not available in our
environment but clojurescript assumed it
is and there was a hash bang being
written into our javascript file and
parses just exploding so those are some
practical issues at this point we almost
gave up we thought you know this just
isn't working out of the box it's not
great but we dug a little bit deeper and
try to figure out how hard it would be
to use a custom version closure script
and it turns out it's actually not hard
at all so we patched target nodejs we
added
preamble or sort of the beginnings of
preamble it's evolved into something a
little bit different but also good in
better control hash bank controls we
actually didn't have that and use a
custom version of the closure script
compiler and this is all that looks like
because closure script like everything
else is a library you can pretty easily
change it by just changing the closure
source paths in your in your project and
what you're thinking now is well that's
kind of insane if I want to swap out
closure all I have to do is actually
change the dependency and the trick here
is that closure script is built using
line C ljs build which has some some
hard coded stuff it has a hard-coded
closure screwed dependent saying the
only way that you can use a custom
version with it is to change the source
path sub but this is actually not that
bad you throw a sub-module in there and
you keep it updated and and and you go
home okay so the next thing we wanted to
use is quartet async and this is this
was actually part of the the big reason
we wanted to use closure script anybody
who's done javascript knows all about a
call back he'll totally didn't put an
example of that up here but I have one
later and call back hell is a real place
it's somewhere that developers go and
and it's not nice and quartered async
really does fix that I'm not going to
spend too much time right the second on
showing you the difference between the
two but I promise we'll we'll go there
later but this is quartered a sync we
really wanted to be able to do things
like this take this very call backe find
like JavaScript find a method that takes
a hash of callbacks wrap it in a channel
and and and return the channel and have
that be the way that we do asynchronous
operations and again I'll talk a little
bit about this Oh actually I won't talk
about a little bit about this later this
is worth studying and making sure you
understand so what we're doing here is
creating a channel that can hold one
thing we're doing one
expect to get one result and then we are
sticking that result on the channel in
closing it this is actually a lot like a
promise this is the way that that
JavaScript promises work right you you
do a thing and you expect to get a
result and then you ask it sometime
later for the result and which is cool i
mean promises are neat and interesting
but there that's all they do this is all
they do and what's cool about corded
async is that it does a lot more so did
corn at a sink work nope not at all so
this is sort of esoteric but courted
async uses set immediate and set timeout
in its kind of core dispatching things
the idea being that I think there's an
event loop and it's it's making sure
that things are happening but it doesn't
want to block the rest of the thing
weirdly enough i was able to patch it
initially with by setting set immediate
to this this fun function that just
takes function calls it which if you if
you're familiar with the semantics have
set immediate or set timeout is going to
make you a little uncomfortable because
those should not have to wait for the
function to return to themselves return
so it was a little weird but it worked
for a little while at some point we
realized that a function called next
pick is available and we've we've
submitted a patch to JIRA and until then
we're using a custom version of cordite
a sink and again I'm talking about all
this stuff not because I think you're
following particularly closely or find
this particularly interesting but
because this is the kind of work that
you might need to do if you want to
extend closure script into a new
environment it is work but it's not it's
actually not that bad it's not that hard
and it gives you a chance to muck around
in the internals which is fun okay so
the last thing we really wanted was
protocols because protocols are awesome
they let you do polymorphism in all
sorts of places that you wouldn't
otherwise be able to do polymorphism and
and they're really fun to use so did
that work well I mean kinda and the
problem is that protocols enclosure
script work by looking at the the
prototype of the
the thing that they're trying to figure
out an implementation for you know you
you call a function and it looks at the
thing and that it says okay I know how
to call that function with this thing
and it does that but not everything in
javascript is what you think it is in
particular in in node sometimes things
are created by c++ and and it's just as
just as bad as you you might think and
closure script doesn't really behave
particularly well in that situation and
i'm pretty sure that that's why it's a
sort of esoteric so the good news is
that we were able to work around a lot
of this with something that I think is
not terribly widely known I didn't know
about until like last week which is
extend type default you can actually
extend protocols to the default which
which basically lets you sort of
override even the most generic existing
implementations this note is a really
evil thing to do to say I encode closure
if you were working in the browser and
you did this you would probably make
your application incompatible with a
wide range of different libraries
because you're you're changing basic
behavior of the operating system but we
felt like we could do it because we're
the only people running in this
environment and we really needed to do
it for compatibility and this is
actually one of the most powerful tools
we discovered for extending to a really
bizarre environment like this so that's
that's me so all that said it works and
more importantly it was possible we were
able to use a custom version recorded a
sink without any trouble we were able to
use a custom version a closure script of
that any trouble submitting patches
upstream is a slow process but it's
totally worth the you know getting into
it an understanding how it works and
it's a good idea so if you are
interested in extending a closure script
to an environment that it doesn't
currently support I suggest you do that
and you should email me your get in
touch with me if you have questions
because
we might be able to avoid some stumbling
blocks okay so let's go back to our demo
here note that most of the time we've
been waiting for this it's it's just
deploying to the environment most of the
waiting time here is deploying the
environment and this is actually a
problem it takes a while to 14 seconds
to do a raw build of the closure script
this is super unusual it's because we've
got some a whole bunch of weird stuff in
there and it it probably took a while on
this Wi-Fi to deploy to parse you can't
run parse apps locally and that's just
as bad as it sounds so we do a lot of
development in the cloud the connected
to the Internet all of our development
connected the internet the good news is
that we have a script called bin develop
that wraps a few auto deploying tools it
wraps the auto compile enclosure script
it wraps up our stool that auto deploy
code and so basically once this actually
gets going it takes about 30 to 40
seconds to get fired up but once it's
going we get deploys to the production
environment in about six seconds or son
ok so we deployed that code that we
added to send an SMS and we did
something really if you were paying
attention a dose we did something really
awful here which is send an SMS in a get
so if any but if the Google browser
happens to stumble upon this the spider
happens to stumble upon this my friend
Jeff is going to get a lot of texts but
so will reload it and Jeff is sitting
there and at some point here he's
probably gonna get a text and Jeff got a
text so nice job chef so and so this is
how hard it is to send a text in this
environment that's really cool it's it's
it's neat you can do this you can send
emails and all sorts of things with just
a little bit of code
so so what's that look like like what
what does an application like this look
like I showed you a really trivial one
here in the demo but that's obviously
not representative of everything that it
can do so let's talk a little bit about
building parse apps and again when i say
parse think nodejs there are some some
special things that parsed is giving us
that i'll show you but this is really
more about server-side development so we
have all the normal tools we have
namespaces which sort of under selling
by just throwing out here like this but
when you if any for anybody that's
anybody that has gone back to a non
closure environment after programming
enclosure probably understands what i
mean when when i say this is awesome
having this nice support for referring
in just the variables ago just the
functions you need and creating aliases
for things that you want to use on in a
little wider context is amazing you can
create these these beautiful little
readable dsl's in your code just with a
good name space we've got protocols
available so a parse object is not a
closure Script object it's a JavaScript
object object but we can extend things
like I look up to a parse object and and
then use a keyboard look up just like
we're used to we can use select keys
just like we're used to once you
implement a small number of protocols on
a new unlike an important object in your
new system you get all this closure
stuff for magic and you know the
alternative is stuff like this par
subject get in JavaScript and then
select keys is a bunch of for loops and
it's sort of a nightmare and we have
macros and macros are awesome i'm going
to show you a bunch of places where
we're using macros and it's it's totally
cool but this is huge we don't have this
in kind of straight up javascript there
are some things like sweet that I think
bring in some stuff like this but but
it's a joy to have and you know etc
there's a ton of stuff enclosure that
you just don't get out of the box with
with JavaScript underscore can bring
some of that in and different libraries
can bring some of that in but closure is
seriously batteries included and you
start feeling so the domain specific
stuff in parse is kind of nice to just a
few examples of the closure that we
write and the equivalent JavaScript so
when you want to start referring to a
new data type this is actually all you
do you say def parse type widget you can
save that widget even if you haven't
done anything on the par side and it
just shows up and this is actually not
that far off from the JavaScript but
it's it's kind of nice stuff parse also
gives you a way to do lifecycle hooks so
you can do before save after save all
the normal stuff that you want to do we
have played around a little bit with
using prismatic schema library with this
stuff and it works really well I am not
using a ton of it right now but it's
it's totally possible and that's really
cool you can see that in this case we
are starting to get some really nice or
more succinct code except oh yeah okay
and and we actually were able to hide
the fact that there's a function in
there which is also kinase you can also
do these just D RPC calls which are a
little horrible I mean you'd never use
them on the web but if you're building
an iOS app this actually does come in
handy because you don't actually care
about all the intricacies of an HTTP
request and this is what a fairly
non-trivial this is from their their
documentation this is what it looks like
in in parse and this is what it looks
like enclosure script now that's not
totally fair because we've done a much
better job of factoring this into you
know a few different well named
functions so let's actually look at
factoring it in JavaScript it's it's
even more horrible and and so I mean the
difference between these two is is
personally and this might just be
because my brain is is broken now but I
find that a lot more readable so that's
cool right okay so something I have been
holding out on you there's a weird thing
in here who's used portate sink so so
see that less than ? that's some weird
stuff that's not that's not stock quote
i dating but it is doing the same basic
thing and to fully understand what's
going on there we need to go to as
always david nolan who posted last
august about asynchronous error handling
and he had this really cool idea that
you could make error handling in an
asynchronous environment this callback
hell kind of thing look a lot more like
a error handling in a synchronous
environment and actually get like normal
stack traces and all sorts of good stuff
and it's really simple it's this is this
is all it is so so here's the basic idea
we have courted async channels and when
you you create the channel and you
expect to just put one thing on that
channel and whoever gets that channel
back knows because that's the the
contract of the function that is calling
that that channel that it gets back
we'll just put one thing on it and and
then be done so in that world if that
thing that it gets back on the channel
is an error as defined by this throw
error function then it can just throw
that error backup as long as the entire
stack plays by those rules then you
actually get stack traces all the way up
in an asynchronous environment there's a
simple macro with the ? that just wraps
the normal cord a sink weight function
and and throws it if throws a result of
its an error and that's all it takes go
catch does the the stuff it's just like
the go macro except that it
looks like it's actually swallowing the
result of it looks like it's for
swallowing the error but what it's doing
is returning it as the result of the
channel that is created by the go block
so go blocks create an implicit channel
that behaves according to the rules i
just described it's really cool so you
can do things like this list accessible
repos goes and finds the first user what
is it doing fine first oh right okay so
it creates the the accessible repo query
list finds the first one returns it if
fine first throws an error that will
bubble up and then it'll it'll bubble up
through this list accessible repos thing
and and so we can deal with it at the
correct level of abstraction so that's
what's going on there okay so let's talk
about the actual interesting stuff that
stuff that I'm actually doing on a
day-to-day basis this is what web stuff
looks like it's an express app it's a
little janky compared to most closure
right now we could use some more macros
in here to get rid of that function but
it's not so bad and it looks a lot nicer
than the equivalent JavaScript and the
interesting thing about the web is that
it the internet is made of lots of
different things and a given website is
made of a lot of different things and
coordinating getting all those things
can be a huge pain so let's this is a
function that tries to figure out which
of the projects that somebody has added
or has it has access to or watchable so
it needs to this reads pretty well we go
and we try to create the accessible
projects query which is going to take a
little while we go and find all the
watchable queries watched projects and
those go and they fire up at the same
time and then we do this this accessible
projects eh the problem is that this
accessible projects query actually needs
to wait on the result of the the first
thing the query query and and so we need
to actually wait inside there and then
at the end of all that once we've got
the accessible projects we've got the
watch
we take the difference so this looks
pretty nice in enclosure script this is
how it works in JavaScript we've got the
same kind of thing where we're doing the
query to find the query and then doing
the project thing and then we're finding
the projects and then we have this crazy
thing here this diff function which has
to check if the if both of the results
are available and then do that and we
have to call this at the end of each of
the things it's just a nightmare and so
if there's nothing if you get nothing
else out of that I hope this is
something that you take to heart because
coordination can be really bad and it's
just trivially with closure script async
is still really hard this is a broken
piece of code because it's going to try
to send the async text and then it's
immediately going to return the HTTP
response and actually cancel that that
SMS thing which sucks so we need to
remember you always have to wait on all
the erasing stuff and you'll get bit by
this fair amount so I said full stack
and I meant it so we're using closure
script on the front end to and and this
is cool because on the back end we do PR
str on basically whatever we get back
from whatever data finding thing we've
got and because we've extended the right
protocols it all just works on the front
end we've got this API request thing
that automatically just uses the the
Eden reader to read the string and it
goes up and so this all just works it it
feels very fluid seamless and it's all
because we can do this this protocol
extension stuff I'm going to running out
of time here something I'm going to skip
over this stuff a little bit but as a
point of interest we're using unfocus
which is if you haven't used it and
focus and live all of these HTML
oriented view layers are really cool
they're awesome it works great on our
front end doesn't work at all in our
back end which is it is what it is for
now it takes HTML like this it gives you
a way to turn it into a template and
it's pretty cool we're also using Jekyll
which is a little strange
but Jekyll serves as sort of a macro
system for our templates and this is
nice because we want to be able to
deploy dynamic code and static code sort
of dynamic pages and static pages sort
of right next to each other and what
this lets us do is use the same layouts
the exact same layout files for static
content stuff that's actually generated
into static files and pushed up to the
server and dynamic stuff stuff that has
to run through all the express routes
and this is the first time I've actually
been able to do this and that's awesome
I've wanted this for a long time so
that's cool this is almost I almost
forgot to even put this in here but this
is actually huge the dream of being able
to share code between the front end and
the back end it just works it's trivial
this is you update your your project co
je s build stuff and it just works this
is really useful for things like URLs
routes coordinating rendering pages on
the front end of the back end for
example we pick some IDs and can
actually just use those IDs on in the
HTML on the server and in the client
trivially and it just it all just works
and finally like I was saying we do have
an auto deploy thing there isn't a
ripple and I that is heartbreaking for
me I usually have a see ljs ripple or a
closure script up a lot but I can't
actually evaluate all of my code because
the the par stuff just isn't available
locally but the good news is that with
this auto deploy stuff we can make a
change in the local code and have it in
the production environment not actually
the production environment but in an
environment that's identical to the
production environment in about four
seconds best case I mean if we're on a
good internet connection and closure
script is behaving so that's cool
okay so so like I said this has been
sort of a rampage through what we've
been doing but it isn't a finished
product by a long shot this is still
very much something that we're using
internally I have pulled a lot of this
out into a library called par sab see
ljs and there is obviously a template
that's publicly available that you can
use to get going with this but if you're
interested in doing in following what
we're doing here be prepared for bumps
so like I said there's no repple but
this is neat you can create a ripple
endpoint that can just take some closure
script that it it gets and it can
evaluate it in the actual running parse
environment and it can return the
response the problem is that if that
thing that gets returned is an
asynchronous thing we have no way of
waiting on that the result that we get
from eval is always a string it's not
actually a full-fledged channel until we
just can't we can't we can't do anything
about it that said I think they're there
are some some potential ways forward we
just need to investigate that a little
bit more and if we can get that working
because of the way the sea ljs repple is
built with protocols we can do basically
just this and we have a ripple on this
parse environment that interacts with
all of the tools that already exist in
the closure script environment and this
is something that JavaScript just
doesn't there's no I mean it's it's like
not even a starter I guess you could get
a closer script like a JavaScript repple
running on parse but it wouldn't
interact with all the tooling in the
same way it wouldn't do all the nice
things we wouldn't be able to if this
works and I really do think it's not
that hard to get it working we can just
get it working with emacs trivially
which is great there are a few things we
need
we need a new closure script release
because some of the patches the last
patch that we needed is actually in
Cornell but it hasn't been released so
we're waiting on that a little bit but
like I said it's still possible to
develop with this stuff even before that
we need to get the next tick patch to
court at a sink merge so that we can
start using just standard quoted a sink
again and we do need more inflexible
environment targeting Chaz's talked this
morning about CL JX and future
expressions i think was was really good
and really interesting and one thing
that i have really wanted is to be able
to make changes to the closure scrub
copilot that just target this one
environment and that's a tricky thing
because there are a lot of different
environments that might need lots of
different things and it sort of turns
into a difficult problem accommodating
everybody but it would be awesome to
have some sort of solution to that
upstream from parse we need source map
support this is this is like this will
change our lives because right now it's
still a fair amount of digging through
generated JavaScript which isn't super
fun it's not as bad as it sounds but
it's not great it would be great if they
supported react on the back end they
they're actually owned by Facebook so it
feels like a natural fit but right now
they don't if we could use react to
render own components server side and
then use them front and client I mean to
just be awesome so that'd be great we
also need some support for actually
getting corded async timeout working
they don't give us anything like get
time out which actually sort of makes
sense if you're running sort of this
managed server environment you don't
want to give people a way to say hey run
this sometime in the future they could
give us some sort of bounded get timeout
and that would be really nice but it
hasn't really been a priority for them
so we just need if we get enough people
using it like this then I'm sure it will
be and then in par sab dot C ljs which
is the library that I've been extracting
stuff too we need to do a bunch of
cleanup we need to improve that web
extract abstraction it's it's kind of
awful we need to extract more common
functionality that we've been using be
great to give sort of a standard way to
unify server and client views
and we need tests we actually have a way
of testing the library itself but it's
it's pretty janky it means pushing up to
a live parse environment running tests
and stuff and it's and it's pretty bad
there are also a bunch of infrastructure
improvements the repple like I said and
improvements have been developed so that
it it is a little bit more robust so the
development experience of this stuff has
been a long way from regular closure web
development I've done closure web
development it's awesome especially
compared to this but it still beats
JavaScript I'm still insanely happy that
I'm not writing that and you should come
find out tomorrow so I'll be hanging out
at the hack thing tomorrow I'd love if
you're interested in doing this kind of
thing or even if you're interested in
deploying to node and have questions
about how it might work or I've gotten
stuck come find me happy to sit down and
give you a hand and that'd be fun so
that's pretty midget I'm Travis hit me
up on Twitter if you're interested in
this stuff and thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>