<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bottom Up vs  Top Down Design in Clojure - Mark Bastian | Coder Coacher - Coaching Coders</title><meta content="Bottom Up vs  Top Down Design in Clojure - Mark Bastian - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bottom Up vs  Top Down Design in Clojure - Mark Bastian</b></h2><h5 class="post__date">2015-11-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Tb823aqgX_0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I am mark bastion this is my first
closure cons I'm really glad to be here
it's been a great conference today I'm
going to talk about bottom-up versus
top-down design and closure and in the
time since I submitted the abstract and
prepared the slides and got until now
that title it's kind of morphed a little
bit to API first versus data first
design and closure and really they're
related topics just a little bit about
me I'm a mechanical engineer by training
but I have been doing software
development my entire professional life
I programmed in a lot of different
languages and a lot of different
interesting projects a long time ago
I've done you know languages like Pascal
Visual Basic Fortran in terms of
languages that I have spent significant
portions of my career doing software
development in I've spent you know at
least four years doing C++ over a decade
and Java over six years in Scala and in
the last couple of years I have been had
the good fortune of being able to do
closure
both personally and professionally and
throughout these different experiences
I've had the opportunity to learn both
the object-oriented programming as well
as functional programming techniques I
think one of the big barriers to entry
when people start learning closure or FP
in general is just the way we think is
it's a little bit different often from
what is taught in school and so that's
part of what I want to talk about today
is one of the one of those different
ways of thinking before I jump into
top-down versus bottom-up design I want
to talk about a specific problem that
I'll be modeling as part of this talk
and that is I came designed specifically
tabletop game design I'm gonna look at a
specific game the scheme is called
carnahan yet it's not a probably a
really common game in fact is anybody
here played card hey Mia alright we got
a couple hardcore gamers good job so
there are a few but probably everybody
here has played a board game in their
life and so you're familiar with games
and how games work and that's one reason
why I chose this as a topic is whatever
your background is you probably have
some familiar with the idea and games
really when you think about them have
some application to real life to many of
the systems we work in the domains we
work in games all have nouns they have
things that we interact with and model
this particular game has a board a lot
of games have boards
and it's randomly generated it has cards
that are in a deck it has little pieces
little pirate pieces the goal is you're
a bunch of pirates trying to escape from
a prison and then it has a boat at the
end that you're trying to work your way
towards games also have verbs they have
actions and so there are the things you
know the things the previous slide was
the things that you have and now these
are the things that you want to do and
any system also is going to have things
that are going to do to it
for this particular game the actions
that you have are when the game starts
everybody is given six random cards and
and just you know for your information
as far as the basics of the game each
card has one of six symbols which
correspond to the symbols on the game
track and on your turn you get three
actions and you get to choose from the
following items to do for your actions
you can either play a card and you can
pick any of your pirates and move
forward to the next open space that has
that symbol on it and if there are none
then you get to move to the boat or you
can move a pirate backwards and that's
how you earn cards and so I didn't go
backwards the first space behind you
that has one or two pirates on it you
get one or two cards and so it's kind of
is kind of a load balancing game where
you're trying to move forward at the
same time you have to move back to game
more cards so you can move forward your
third actions you can just pass them and
end your turn early and then the first
player to move all their Pirates to the
boat wins so back to my first question
well how would you design a game in
general this particular game so let's
talk about a couple of approaches the
first approach which if you're from a
very strong object-oriented programming
background this probably is very
familiar that's top-down or API first
design for that approach what you're
trying to do fundamentally is answer two
questions you want to know what are the
components in my system and the
relationships and as well as have I
sufficiently broken down that system so
that I understand it so I have some
top-level idea or concept in this case
it's Gainey more specific game what are
the pieces underneath it do I fully
understand each of those tractable from
a programming standpoint if not then I
need to break it down
I answer that that second question and
so there's a you know just a real simple
flow diagram where you can visualize
this so you could start with a high
level problem description game for each
class in your module or and your in your
system you would break that down and
again this applies to anything in what
you're trying to do a functional objects
decomposition and you say well I do I
need to further refine that if the
answer is yes and you go through and you
refine all your objects and until you're
done and then when you're done you have
your class hierarchy and that's the kind
of the basic way we do things whether
we're doing this explicitly or
implicitly when we sit down and say I'm
gonna you know model something in Java
you know you're gonna start writing
classes and your head you're gonna be
probably breaking things down this way
when you're done doing that there's
gonna be some level of refinement you're
probably going to be looking for
abstractions and patterns and ways that
you can make base classes to make your
code reusable and then once you're done
doing that you're going to be doing some
specific implementations of those
classes so let's walk through an example
of how you might do that with just a
concept of games rather than this a
specific game so you could start with
the abstraction of game just say I've
got a game interface and you can give
that to somebody while that is a
complete API for all games it's not
particularly useful and so you say well
is this simple enough no it is not so I
need to break that down and so how would
we decompose this well you could go look
at what the definition of a game is
games are systems in which players
engage in artificial conflict defined by
rules that results in a quantifiable
outcome so I could look at that and say
alright I'm gonna further break games
down into this idea of a game and games
have players and games have the rules
and that still isn't particularly useful
all games do you have players or rules
how you define that that's very abstract
so you might want some more or utility
functions or classes and helper classes
I break it down even more concretely so
again looking at games there are a lot
of different types of games there are
board games card games video games
sports games we're gonna focus on again
tabletop type games so board games are
one type of game and they often have
tokens or pieces they often have dice
for resolving movement or conflict
other elements of the game to introduce
randomness card games usually come in a
deck so that's one way that we could
break our class hierarchy down even
further over doing this modeling and so
here we have another iteration now at
some point I don't expect you to be able
to read the little words the big
observation is look at the number of
boxes in the number of lines connecting
them each of those represents a class
and a connection between those classes
so here I have an interface to a game I
have a board game I have a card game I
have a deck deck cast cards see you so
really if you think about this from an
object-oriented standpoint you might
think this is a good design because you
know for any game that has a deck I
could make a card that has a particular
value whether it's a standard you know
face cards or cards specific to a game
same kind of thing with a board game but
I might want to refine it some more
because there are corner cases that we
need to deal with when we're designing
games and for example some board games
have cards that game that I'm modeling
Carta Hanyu as a very simple board game
and it does have a deck of cards so it's
a board game that has cards and some
card games have boards there are some
games where you may have a deck and then
every player has a mat or a board or
something to kind of keep track of their
points or their actions or or some
aspect of that game so if you had that
situation well how would you do that if
I have a board game class in a card game
class well I could do multiple
inheritance if your language supports
that which Java does not we all know
that multiple inheritance is bad that's
what we're taught from day one so if we
can't do that and we do single
inheritance with compositions so we
picked the class that is most like what
we're doing and we extend that class you
know the implement all the interfaces
that are appropriate and then we and
then we go through the process of taking
all the abstract versions of those
classes and make an inner implementation
and then proxy every single one of those
methods and so that's just something for
you know one way we might decompose it
and there are a lot of things we can go
to go further here's an example of
another game this game is called
Twilight Imperium it's a very detailed
game if you want to model one of the
most complicated board games out there
is a
that has an evolving board each player
has their own board it has multiple
decks it has a lot of pieces and so if
you were to make a class hierarchy
something that was abstract and general
enough for everybody it would be very
complicated so but let's just look at
what we did if we took the previous
class diagram and just had the ability
to have board games with cards or card
games with boards so it gets even more
complicated and so now I have a default
card game with a board and a default
board game of cards I still haven't
gotten to the point of having games that
have multiple decks or anything else and
so it doesn't it's not particularly
general um and so if you could continue
down this path and say I'm gonna refined
this some more but at this point I'm
just gonna say stop you know if this is
something that you do a lot of and
you've seen in your life you know stop
doing this you know why are you doing
this I don't know why I don't know why
we do it I think it's when we're taught
object-oriented programming it is
natural to look at the the system
whatever system it is remodeling and say
well this particular thing makes sense
and it's got this sub component and so
it's good to understand your
relationships but then we immediately
try to turn that into objects and we end
up with something that's very complex
and often times even very simple
problems when we try to particularly
we're trying to be general when we try
to make a class hierarchy for those can
be very very complicated and if you're
familiar the idea of complected miss
it's the term that I think comes mostly
out of the closure community but is this
idea of things being tied together like
a knot and nearly everything when you do
this is tied together because all of
your systems in your subsystems and
components are tied together every class
knows about every other class that it
might possibly touch and you know
furthermore another problem with this
I've spent all this time trying to make
these classes but these really are only
structural classes they are things they
are the phases and the hazard
relationships I haven't even got to that
does a situation of methods so I haven't
even gotten to the point of going into
my methods and saying well I have all
these interfaces what are the you know a
player can you know player can play you
know dice can roll all these different
things and how they interact with each
other and even then I can flush out the
the method definitions but I don't have
implementations yet and so top-down API
design can be very time-consuming they
can result in a lot of code but it's
something that I see you know when I
want to on a more object-oriented
related project it's something that I've
seen a lot in my life where people I I
don't know exactly what the roots of
this is I think it's just because we we
we try to think natural in terms of
objects and we think if we break things
down into all their relationship somehow
that that makes life easier it happens
all the time there is a better way and
just kind of for future reference here's
a potential class diagram for the card
oh hey Nia game that I that I'm talking
about just a few numbers and this is
just for comparison you know there's 22
classes 11 interfaces and enumeration
there's no implementations of anything
at this point
they're just relationships and so far
just to do this it's 270 lines of code I
don't have any getters or setters yet
you know it's it's it's you know by the
time I I do all this that's going to be
a fairly large code base for something
that really is pretty simple and some
people might say well you're trying to
make it overly complicated I think even
when we try to do this as simply as we
possibly can oftentimes we lose the
abstractions they're trying to build and
we don't capture all the corner cases
and even then there is still a lot of
things that need to be filled out and we
still have a lot of unnecessary academic
exercises in which we're just looking
for relationships and trying to
understand the you know is those the
houses the desease you know and
everything else so let's talk about
bottom-up design or data first design
and this like with top-down design the
tries to answer the question what are
all of my relationships and do I fully
understand all of my pieces instead when
I'm starting bottom-up or particularly
data first the question I want to ask is
how do I represent my domain as data and
then also what functions do I need to
manipulate that data so it's all about
looking at whatever problem I'm doing
and saying how do I map that problem
directly as data and enclosure
talking about collection literals values
something that I can sit down and code
up using a you know maps list vectors
primitives and so on and again you know
similarly similarly we have a flow
diagram of how we might do this we have
these two values X the next prime X is
the starting value X prime is the
finishing value the thing I want to get
to and so it's it's a much simpler
process you look and you say do I have
the function that gets me from X to X
prime if I don't have that function that
I developed that function what's neat
about this is I have two pieces of data
that I can work with in isolation I can
develop this function in isolation and
then once I've done once I'm done I have
this this new piece that I can add to my
my API and so that I'm going to continue
doing that for that piece of data to get
to get the different mappings that I
need and then if I do have all these
functions for that particular piece of
data I might want to take that data and
combine it with other data but again I'm
still I'm still working with data and
then I have that data and I say all
right what are the functions I need to
apply to that data to transform it and I
repeat this process and then once I'm
finally done I have a a functional API
and so let's go back to the example I've
been talking about and I'm going to talk
specifically about this closure game and
some of these methods might apply to any
game they're not closed am cartina game
the starting data that I have is simply
a set of players and the players our
players name and their color so it's
that simple and what I want is to
represent my game state throughout the
game in this particular data structure
here so I need to know a few things I
need to know my turn order turn order is
going to change with every game because
there's going to be a different number
of players and players might use a
different color so that's something
that's relevant to the the current value
of my game and and then in this case
rather than having a turn sequence or a
turn order generator class I just have a
simple map that says this player's color
when their player when their turn ends
we go to this next players color and we
key off their color not their name
because you can have multiple people
with the same name playing the game but
you only get one one color we now have
our next section for how I represent my
game as data is the player section of
this structure and the players have
their feet off of their color they have
in Maine they have a certain number of
cards and again rather than having a
deck class in a hand class and
everything else to do card management I
simply have a map of the card types and
the number of cards that each player has
and then finally I have a certain number
of actions that are signed each player
and again rather than having an action
object and having to deal with any sort
of a complex definition I just give them
an integer number of actions and then
the last thing I need is a data
structure that represents my board again
simple data it's just a board key value
pair and that board is simply a sequence
of pieces on the board
so for each item that represents a
square as you move forward on the board
it keeps track of the number of each
player piece of their color on that
board board square as well as the symbol
that's on that Square and the symbols
start with start and then they go
through the various different symbols
that are on the board and they end with
boat that's the goal so if I were to
start with my initial piece of data
which is the player names and their
colors and then this final piece of data
which is the initial game of state how
would I do that well I'm gonna need some
functions I need some generator
functions to deal out cards to create a
board sequence that's turn sequins and
they need some kind of initialization
function that puts all that together and
just just to point out you know for
those that are very technical
these aren't functions from the
mathematical standpoint the ones that
generate random cards because they do
have random behavior but it is the
behavior that I want so these are what
these functions look like they're very
simple so for the functions that
generate my cards my board and my turn
sequence I simply if you if you look at
the code sample on line one I have my
card type site to find those is a simple
set of types and this particular game
the card types are hat flag pistol sword
bottle and key so those are the symbols
that are on the cards as well as on the
on the game track I have a draw function
which is this a simple function that I
say how many cards I want and then
repeatedly and time
randomly gives me a card symbol I have a
board sequence function which starts
which basically takes a sequence that
starts with start man's with boat and
then six times it goes through all of
the symbols of my card type shuffles
those creates the sequences and flattens
it and then finally I have a create turn
sequence which just takes the colors of
each player and then cycles them against
each other into a map so it's that easy
the next thing I do now that I've
defined these functions is I have some
player initialization functions and so
this initializes the players part of my
game value and this is where we start to
take our little functions and build them
up into bigger and bigger functions and
that really is the bottom up piece of
this you start with data and functions
and this process is going to be building
up more and more complicated functions
and the complexity is in terms of the
things they do not the actual func the
functions themselves aren't generally
complex so I have these methods that
develop that put cards into a player's
hand I have a definition of an empty
hand that's just a map of a card type
two two zero two zero cards and then an
initial hand that draws six cards and
puts that into a player's hand and then
I put all those together into this and
it players function so it takes that
that set of player information and it
returns the portion of my game value
representation that describes all of my
player state ok and then the last piece
of the function that I'm trying to
generate the larger function is actually
initialization of my game board and so I
already had a function that generates a
sequence of symbols but I need to map
that into a sequence of board squares to
have a symbol on it as well as keeping
track of the number of pirates that are
on each of those spaces and so I have a
an initial pieces function and to make a
board function and I combine all those
together into the set of board function
I'm not expecting everybody to
understand all the the code here and I
don't have the entire listing for the
code up here mainly the again the goal
and I'll repeat this is to build larger
capability from
functions or composing functions up from
the bottom rather than serving this idea
and decomposing it down to lots of
little little pieces so now I have this
admit game state function it uses three
functions I've already defined I have my
example input and if I were to feed that
example input into a net game state I
get this result which is exactly what I
showed you before so I have data and
both have a bunch of very small
functions out of small functions and I
now have a complete representation of my
game just before turn one adds data so a
few observations about this we've gone
from a description as data so we're
describing where we wanted where where
we where we started from and where we
want to be as data to a functioning
meaning not just a description of the
solution but an actual solution
functional API that completely
constructs our domain model when I say
domain model I mean they complete a
value they may be a complex value with
nested data and everything else but it
fully represents my game at a particular
state and if you're not doing games if
you're doing whatever other system
you're doing I've done this several
times on many projects it works very
well to to say how do I represent my
data and then once you have that
representation to develop functions to
to build that up and to manipulate it
another observation as functions
composed very well for objects do not so
I go through and I say what are the
functions I need I build these function
Vale tend to be quite small I can
assemble them together into larger
functions and reuse them in different
ways yeah where objects you can you can
do inheritance I guess to whatever level
you want but really I think that my
experience has been when I see API is
that have deep inheritance hierarchies
they tend to be very difficult to use I
don't think it in practice turns out to
be very good thing objects really do not
compose and they don't really have a lot
of reuse small functions are composed of
other small functions so your your
functionality increases but your
function size does not so you get more
functions but you don't get a lot of
bigger functions and all this was done
about 40 lines of code so my strawman
class diagram that I showed
or was about 270 lines of code and all
it did was describe relationships and
structure it didn't really do anything
I'm already at the point where I kind of
sink it get from player description to
you know turn one in forty lines so I've
already got something that works and
it's it's it's much more concise and I
think it makes a lot more sense that her
this way
how would actually play my game well
there are types of functions as I'm
going to develop to do this
I need to know some functions about how
I would do turn the sequencing so when a
when it turn ends and whose turn is next
some queries that are just generally of
use to know just different pieces of
information like to have a winner yet I
need to determine what movements I can
make and then finally I have these
top-level actions and I'll spend a whole
slide talking about those so turn the
sequencing has three functions only
first I need to assign an active player
and because I represented two actions in
my game as just an integer number all I
do is I go through and just set their
actions to three so it's that easy it's
that simple
determined who the active player is it's
just the player that has a positive
number of actions and then that player
is color since it's a key value pair
that gets returned I just returned the
key from the previous function so making
use of these functions that build them
up queries you these are just abuse for
functions that I can that I can ask
about my system do I have a winner yet
which means do I have six players and
there are six tokens of the same color
on the very last square as a particular
space occupied does a player have a
particular card these are the kind of
things I want to know and again I'm
making use of functions I've been
developing determining movement so now
I'm building up to the the place in
which I can say can I move forward or
backward to move forward I need to know
what's the next space with the cards
symbol or the boat on it and to move
backward I want to know what's the last
space behind that the person that I want
to move
has one or two uh pirates on it so and
I'm making use of the functions I
developed in the previous slide so all
these functions that I've been building
all these little functions they the
thing that they build up to are what I
call top-level functions and a top-level
function is simply a function that that
represents your entire state of your
system there are a piece of data that
represents the entire state of your
system and can transform that into
another appropriate full representation
of your system so these types of
functions are very valuable because if
you're building any sort of application
where you're representing a system you
can apply these functions to them and
then you still get a new valid system
and so all you really have to do is keep
track of the the thing that is
monitoring that using like a closure
atom for example and then you can apply
these functions to them so that really
is the top level of your API so some
things you can do with these top level
functions is you can thread the state
and I prepared this talk to be kind of a
have it have an audience of people who
are new to closure or had to have a ton
of experience so I don't have how many
of you are familiar with the threading
macro probably most of you have done a
lot of closure are but I know those
you're dabbling me not so basically what
you do is you take a value and you can
build pipelines of capability so I can
take a value that represents my game and
I could have these three functions F G
and H and one of those functions might
be if it was a game you know play a card
and then the next function might be to
fall back and then the last ones might
be to pass so I can compose pipelines
using these top level functions that
take a game state and then or our system
state and then then thread that system
state through these out through these
functions I can iterate iterate takes an
initial value and then some function
that I apply to it and again as long as
I'm structurally similar or have this to
have the same shape I can repeatedly
apply this function to a value and then
get new values out and then again apply
that to the same value and so on and I
can do that until the condition a
particular condition is met for this
particular game that I'm doing it's
probably not something that I would do
but if you're doing say a physics
simulation whether that
you know you're doing actually you know
science study or whether you're doing a
game that iterates over each time Delta
and then updates into simulation I like
a real-time strategy or first-person
shooter type game you could use this
iterate method to step forward and in
time to compute several states of your
system finally where this is very useful
is if you have some sort of an
application that keeps track of state
you can use a closure atom in there or
you could use a referent agent but in
this case I'm using the atom and that
atom has a in this case of the state it
keeps track of that value I can swap
that atom with my function so I apply
that top level function to the value and
then I get a new value that represents
the the new state of my system so these
top level functions are particularly
useful and that really when you're when
you're doing this bottom-up design
that's kind of the thing you're working
for is to develop a series of these so
kartaa Hania the top level functions
there's only three they're pretty simple
they're your game actions you can play
you can pass for you can fall back and
this is what they look like again I can
you know fit them all on one page
they're little dense but they all fit
there and the key point though is that
they all make very heavy use of
functions that I have already defined so
again as I defined this API I'm building
more and more small functions that allow
me to do a greater breadth of things all
right so let me do a demo of what this
game looks like as I was going through
some of the different applications I've
developed in closure this is the one
that I thought was most appropriate for
the topic even though it's one of the
first ones I'd probably this may be the
first non like hello world application
that I didn't it did in closure and so
this wasn't I was doing everything using
Java ewt so it's not a pretty demo but
it is a working demo so I have this
track and I have these symbols for these
two players that a yellow player and a
green player it's the yellow player's
turn I just color their cards by their
color and then I
play their various pieces and so they
moved forward to the next thing that
that the next item the symbol that I
played they move forward to the next
uncovered square now it's Greene's turn
so at this point I'm just gonna play out
all the plaid all their cards get them
all out on the board now normally what
you would do is actually look at the
cards in your hand and figure out which
ones move you the furthest ahead because
if somebody's just played a lot of
bottles and all the bottles are covered
up and if you play a bottle then you can
move way ahead and so now everybody's
out of cards and so you can pick its
yellows turn so this guy is gonna fall
back and he got a skull and then this
guy he's gonna fall back too and then he
got a key and then he can fall back
again to get two cards now it's gonna go
to greens turn so we don't see exactly
about two cards he got and then you can
continue to do that so this guy can fall
back this guy can fall back and then she
earned cards you can move forward again
and so I won't bore you by playing a
game against myself until we get to the
end but that's what the game looks like
and so it's a so we have a fully
functioning application with not very
much code and not very much effort so
some observations about this the entire
application really is just a bunch of
collection a collection of functions
applied to data and and this really is
kind of the one of the major outcomes or
ideas of this presentation is when
you're doing functional programming
especially close your functional
programming its functions applied the
data you build a lot of small functions
that you can pose from other small
functions so in this case I went through
and count at thirty-one functions the
longest one is only seven lines so
they're all very small single-use but
they can easily be recombined top level
functions thread the full the full state
of my application so they can may allow
me to representation of my domain and
they manipulate it to some new full
representation given some Delta whether
that's playing a card or
overtime or whatever that whatever is
irrelevant in your in your application
they're making changes to and the total
rule base for this there's only 144
lines of code so it's pretty it's pretty
small and again this is about half the
size of the amount of just skeleton code
that I wrote just to make a class
diagram the other way so you can jump
right into your problem and start
solving the problem right away as far as
the user interface I'm not going to show
the code for that just a couple
observations about it
there was one atom used so there's only
one stateful variable if you want to
call it that one thing that is keeping
track of my state in the entire
application and the that particular part
of the UI was a couple hundred lines of
code so it's pretty small but the UI was
very simple and I found this to be true
with any sort of user interface and this
is whether you're doing I you know then
you eyes and closure script as well as
in closure and whatever framework you're
using it turns out to be very simple
because all you really have to do is
render the current value you've got this
value in data that represents the
current state of the system and so you
just need to render that whether that's
rendering it using dialogues or
rendering it using some 2d or 3d
graphics engine all you have to do is
draw a picture of it you know whatever
whatever that representation is and then
you have to have some way in which you
execute actions against those values so
in this case you know it's your standard
action listeners and if you look at the
code the action listeners are literally
you know you know action performed swap
state and then pass or play card or
fallback with the argument attached to
it so the actual interplay between the
API that that I developed and the user
interface is extremely minimal and
they're highly decoupled which is very
nice the fact that they're decoupled
means that the rule piece of this will
compile directly as close your script as
well and there are a few little caveats
with closure script and closure but for
this particular one I don't think there
were any requirements to to do any sort
of a conditional modification of the
reader conditionals and so it compiles
directly either way and so the cool
thing about that then is you could
easily develop a different interface for
this if you wanted to do a you know
really
cool you know better implementation of
my interface which would be almost any
implementation of an interface you could
do a like a 3d implementation using the
J monkey engine again that would cure
Java you could do quill if you haven't
done cool yet cool this awesome API that
allows you to compile as close your
script and have a Java target where you
can compile it down to JavaScript and
run it in a web page or you could
compile it so it runs this just to
straight HTML in a canvas I doing it
that way so why is closure especially
suited to this when you when you go
Google up top down and bottom up and
people talk about this oftentimes the
criticism of bottom up is you just kind
of start somewhere and then you like I
need this other thing and I build that
and it's tied together there's no real
design
well closure is uniquely suited to this
because that that initial coupling that
happens when people when people have
their criticisms of it does not occur
because data is the thing that you're
modeling you're not modeling classes
that are just complected from from step
zero and other functional languages even
and so really it's it's it's closures
its closure as data that enables this
not because closure is functional so I
spent a lot of time doing Scala skull is
a great language I really like Scala
however Scala still uses classes and
even if you're doing you know very
functional skull and you're doing case
classes everything is immutable and
you've got a lot of functions you still
have all of your functions in your
classes and so objects are still the
glue that pulls all that together and so
even then people I think often naturally
yeah
drift towards this let's decompose
everything in the classes versus let's
just start with data and apply functions
to it closure is the only JVM language
I'm aware of and you know the only
language I'm aware of that separates the
valid that concerns a value function in
the state so all those things you can
either lead aren't tied together using
objects as the glue
so in summary top-down design that seeks
to decompose a problem into its into its
constituent parts and I will say this
top-down design actually is a very
important idea and important concept and
you should do it it's good to understand
the high-level relationships your
modules your
subcomponents your functionality however
and here's the here's here's the big big
catch when you take those things that
you figure it out and then you
immediately say I'm gonna turn all these
into objects that is the that's when
you're stepping on the landmine because
then you are automatically saying I'm
turning everything in objects and I'm
complected everything everything is
connected
instead use that that information that
you found to figure out what does my day
to look like and what functions do I
need to apply to that data to transform
it if you spend a lot of time trying to
figure out what are what you know what's
to be all end all class hierarchy for
something you can spend a lot of time
away from your goal of solving some
problem instead you're just making api's
bottom-up design you start with data and
and the developer actually understands
the problem better because rather than
saying well it's it's that are in talked
about the is in the houses it's let's
make a data structure and start filling
the values and see what it looks like
and you'll very quickly find things that
don't work and the things that do work
and again your functions focus on data
transformation they may not sound really
exciting but it actually gets you there
pretty quickly so it's it's pretty cool
and then the API is the function so it's
just the collection functions that you
generate when you're done functions are
inherently reusable and composable in a
way the objects aren't and it allows you
to help her to focus specifically the
specific problem at hand because there's
one one particular wherever you are in
the system there's one piece of data
you're focusing on at that time to get
to another piece of data and you can
focus on that without having to worry
about state and mutability and anything
else final thoughts I've done a lot of
object-oriented programming I've been
doing a functional programming for the
past couple of years I've seen the you
know the good the good in the bad and I
find that data first design is very
refreshing when you start from the
bottom and say how do I accurately
represent my system and then how do I
start applying functions to that it gets
me where I want to be a lot quicker I do
a lot less work in terms of code and
time and I end up with a solution that
is much simpler and easy to understand
and so if this is not something that's
familiar to your user even if it is give
it a try on your next project I think
that at least for me it
I think it's a great great approach any
questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>