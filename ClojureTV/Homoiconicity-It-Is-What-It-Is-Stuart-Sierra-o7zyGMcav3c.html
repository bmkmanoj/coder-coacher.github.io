<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Homoiconicity It Is What It Is - Stuart Sierra | Coder Coacher - Coaching Coders</title><meta content="Homoiconicity It Is What It Is - Stuart Sierra - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Homoiconicity It Is What It Is - Stuart Sierra</b></h2><h5 class="post__date">2017-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/o7zyGMcav3c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thank you for coming hope you can
stay awake just after lunch I'm Stuart
Sierra and I work now for club house we
make project management software but I'm
here today to talk about a topic that
I'm a big fan of and that is homo
iconicity now this being a closure cons
talk of course I need to start with a
dictionary definition so I typed homo
iconicity into my dictionary and got
nothing so I started digging around
online and I found a lot of references a
lot of links about this term on this
site the wikiwikiweb were the c2 wiki
long before Wikipedia there was the
original wiki and this was originally
set up for members of the software
patterns and agile development and XP
extreme programming for those
communities to share and collect ideas
it's been running continuously since
1995 and it's kind of a fascinating
history of software development
methodologies and practices so I visited
the wikiwikiweb and looked for their
pages about home iconicity a lot of
which looked like this it turns out a
couple years ago the maintainer z' of
the c2 wiki decided that they were going
to rewrite the application as a modern
JavaScript full-page application with a
distributed database back-end that would
last them for the next 20 years as a
result a lot of the pages with some of
the older content failed to get ported
over even the Internet Archive it turned
out did not have copies of these pages
as they existed what it did have luckily
was a bulk archive of the entire site as
it existed in early 2015 in a format
called work or web archive this is
basically a dump of everything that went
over the socket HTTP requests and
responses and even the chunking as
someone crawled the entire c2 wiki site
in early 2015 so I downloaded this and
there are some tools for working for
this format but I couldn't get any of
them to work with just a single
standalone file like this so of course I
wrote my own this is the world's worst
HTTP server it uses a regular expression
to parse the request jump to the
appropriate point in the LARC file and
then copy out the bytes exactly as they
appeared in 2015 amazingly enough this
works and I am also that I can do this
and browse also I could browse the
wikiwikiweb archives about homogeneous
'ti of which there are many so the
author's themselves had this to say that
there is some debate some argument about
the definition of this term boy is there
ever so I read all of this pages and
pages of back and forth and people
basically having long discussions in
wiki text on this site to try to come up
with to see if they'd settled on a
different definition and they seem to
agree on some things that it's not just
having reflection in your language or
being able to bootstrap a language in
itself that alone does not make a
programming language homo iconic
eventually they someone came up with a
sort of a challenge or a specification
to say this is what makes a language
homo iconic and this is the example they
give in common lisp they say take an
expression in this case set an
expression that sets a variable b
2:15 and assign that expression to
another variable a and then look at a
evaluated look at B and see the result
of evaluating it then modify that
expression this car encoder is just
common list structure modify that
expression to set B 237 evaluated again
and see the result of that now perhaps
it might be a little more familiar if I
put this in closure then this is just
doing the same thing definite are a to
be an expression evaluating it looking
at the result and of course we can't
actually modify a list in closure but we
can do the next best thing we can get a
new version and redefine a and evaluate
it again
now another example that the C 2 wiki
gives is tickle or tool control language
a popular early scripting language and
this is the same thing in tickle setting
A to B this block expression to set B
evaluate it print the value and then
modify it set the number 237 and then
this shows here we don't even have to
call eval in tickle if we have an
expression in a variable we can actually
use that variable in a piece of syntax
and it will get evaluated so this is
just demonstrating that with a dummy
conditional expression and we can see
that the value is B but of course if you
give programmers a challenge like this
they will come up with creative ways to
solve it so someone said hey look I can
do this in Java by writing a lot of code
that invokes the compiler and writes out
a bunch of strings to a file and then
compiles it and then executes sit but
the end result is the same thing and so
someone did this and they said okay well
therefore this is proof that Java is
also Homo iconic and the response was a
resounding no
adding eval to a language even if it's
successful does not count as homo
iconicity and you didn't even succeed at
that burn so they sort of end up without
a very satisfying answer they say well
it's this kind of property and some
languages are more like it with Lisp and
tickle up at the top and the see like
languages down at the bottom but that's
that's not a very satisfying answer we'd
like to make a stricter classification
well one thing it seems everyone does
agree on is the origin of the term and
that is this paper from 1965 by Charles
Moore's and Peter Deutsch about a system
they invented called track track was
designed to be what they called a
reactive typewriter or what we might now
recognize as a text editor this was
still probably ten years before we had
full screen text editors ala VI or Emacs
and they were doing this on the PDP one
which as you'll note from this picture
does not have a screen so they're trying
to build a text editor on a machine
without a screen and they wanted to
build a sophisticated text editor a
programmable text editor so they
invented this language called track and
track is an interesting language because
any text that is input to track is just
output verbatim so this is the most
boring HelloWorld program in existence
as a slightly more elaborate example to
escape from the output into the
programming language itself you can
write an expression
starting with hash paren so you can see
this looks if you squint it looks very
vaguely Lisp like and I read enough of
the manual to figure out roughly what
this is doing so you can still find the
manual for this online by the way again
this was a PDP one
so they didn't have a lot of memory
every byte counts so everything is very
short terse names so s means store in
this name fib Oh a block II is an
equality test on the first argument if
the first argument equals one then
returns zero otherwise that the first
argument equals two return 1 then this
expression all the arithmetic operators
started with a for arithmetic so a s is
subtract obviously subtract 1 from the
first argument subtract 2 from the first
argument R is recall the symbol fib o
which we are defining invoke it on that
get the result of each of those add them
together and you have your Fibonacci
function track was used it did exist for
a while it was ported to a few other
systems but it didn't get a whole lot of
popularity in part because I believe it
was mores was very aggressive about
enforcing their trademark on the name
track and they threatened litigation
against people who tried to re-implement
it so if you're curious the only extant
implementation of track I found is in
free max
free Max is an Emacs like editor for
free dass and it has its own internal
programming language which looks a lot
like track but it's called mint which
stands for mint is not track just to be
sure that they wouldn't get into trouble
but you can actually download this and
supposedly it compiles on modern
machines although I couldn't get it to
compile and this is the C syntax
indentation function from free Max and
you can see it's still a little messy
but at least we have equal signs and
plus signs and I'm not going to go
through what all of this does but if you
really want to write track you can do
that now the interesting property of
track which they commented on in their
paper
was that the source code form the way it
appears on the screen should be
identical to the form that guides the
track processor which what we would call
probably now an interpreter in other
words the procedures that it evaluates
like that Fibble procedure are stored in
memory exactly as the bytes that you
typed and this is kind of weird when you
think about it since almost every
programming language that we deal with
always has multiple representations
whether its source code or abstract
syntax trees or byte code or whatever
anything that's interpreted or compiled
almost certainly has more than one
representation but track didn't it just
reads one byte at a time and decides
what to do with it and so this is where
they get the term they say because the
procedures that it evaluates and the
text of those procedures are the same
inside the program and outside the
program it is Homo iconic same
representation so according to this
definition basically nothing else is
homo iconic because tract is the only
language that has this property now on
this sentence in the paper which is as
far as we can tell the first use of this
term they have a footnote following
suggestion of McCullough WS based on the
terminology due to purse
now they spelled his name incorrectly
but as far as I can tell
WS McCullough is almost certainly Warren
Sturges McCullough an American
mathematician who was probably around in
Cambridge around MIT and that sort of
general group of people at the time
although he would have been fairly
elderly at this point he is best known
for writing some of the earliest papers
describing the foundations of what we
would now call neural networks
he also made various other contributions
to computer science so apparently he was
a friend
there's he knew what they were doing
talked with him about it and suggested
this term homo iconic which he got from
this other person charles sanders purse
the CS purse who was an american
mathematician and he did some really
quite remarkable work he invented a
number of concepts and ideas decades
before other people later came across
those same ideas and got the credit for
them he was very much ahead of his time
and not very successful as a
mathematician he was slightly more
successful as a philosopher and that's
what he was better known as during his
lifetime he developed a number of
important philosophical concepts
including being credited as the founder
of semiotic Sande pragmatism and also
contributing to other fields as well so
this is from one of his key papers about
semiotics now if you've ever had the
experience of reading some documentation
for some software and you think you know
what this is just really terribly
written I can't understand what these
people are saying why would they write
it this way if they want me to
understand what they're talking about
just read some philosophy you will feel
so much better so this is this is Perth
talking about semiotic and I'm probably
going to butcher it so I apologize in
advance to any philosophy majors in the
room this being a lisp conference I know
you're out there but what I think he's
getting at is this idea that there are
things you can perceive whether they're
words or symbols like you see the symbol
death on and that creates an idea in
your mind about defining a function and
that idea in your mind refers to some
abstract concept or maybe a physical
object out in the world and semiotic was
all about categorizing these different
forms an idea might take em how they
relate to one another you can see it
obviously has application
to programming since this is essentially
what we do all day creating words and
having them mean concepts so getting
back to track they had this word homo
iconic and they had several other things
that they cited as inspiration
including commit which was another early
text editing system and lisp list which
had just come out a few years ago in
1960 john mccarthy published the first
paper about lisp and if you look at this
paper you're if you may have just seen
elsewhere that lisp looks like this it
was written in m expressions this was
the syntax that McCarthy devised for
Lisp as a language that he thought
people would actually use and it has
some of the niceties that we expect from
languages like algebraic arithmetic and
so on this was given in contrast to the
s expressions which were intended to be
the internal representation of the
language used in an interpreter or a
compiler but of course people decided
you know these s expressions are
actually kind of cool and they're not
that much harder to work with in the M
expression so they never got around to
implementing n expressions and s
expressions is how Lisp has been defined
ever since
now Moore's and Deutsch the track
authors definitely knew their Lisp in
fact Peter Deutsch was one of the
co-authors of the Lisp implementation
for the PDP one the computer that they
were working on so these folks knew
their Lisp but they weren't afraid of
criticizing it
they said it's it's kind of elegant but
you know it's it cheats a little bit it
has some of the primitives are
implemented in machine language and that
spoils this nice mathematical property
it has but if you know if you get rid of
those ugly M expressions and you just
have the s expressions and you ignore
those machine language procedures well
then maybe maybe it's closed
being homo like onic so they didn't even
quite allow lisp into their definition
they also said you know lisp is just too
hard we've tried to read the
documentation and we think our humble
text editor users are not going to be
able to master this mystique of a
language so here in 1965 I think we have
the first recorded complained about lisp
documentation
a few years later alan kay who would
later go on to create small talk and
some of the foundations of
object-oriented programming in 1969 he
was writing his PhD thesis and he
described a system called flex which as
far as I know was never implemented but
it had certain interesting properties
where you can sort of see the evolution
of what would eventually become small
talk and he was also inspired by both
Lisp and track and he referred to both
of them as Homo iconic because they're
internal and external representations
are essentially the same
so we're four years in now and we've
already started to muddy what this term
means but he also said that both of
these languages have terrible syntax
that they look like cuneiform this is I
believe the first recorded complained
about Lisp syntax now because I wanted
to be thorough in my research for this
talk I found a copy of that letter and
unfortunately I couldn't get it to
compile but if if anyone complains about
closure syntax just show them this see
look it could be worse so after all this
I'm not sure I was any closer to a
concrete definition of homogeneous city
so I did what any
developer in 2017 would do I asked
Twitter so I put this question out
earlier this year and I got a bunch of
interesting answers some people gave me
the fairly conventional answer code and
data of the same thing so close your his
list this is probably what most people
think of some people got more into what
it actually gives you as a programmer
that if you can manipulate the syntax of
the language in code very easily that is
the useful feature of a homo iconic
language some people got a little more
philosophical said it's balanced
parentheses everything it's just all all
there but I think my my favorite answer
was probably this one in the chain of
representations between human desire and
machine effect I love that phrase
there's one link where both parties have
the same shape and I like this because
this implicitly admits that there are
many representations of any language we
work with in a computer from characters
to bytes to syntax trees to electrons
and registers all of these things exist
and but at some point there is some
version where the computer
representation and the human
representation are the same so I'll
adopt as my working definition this fact
that you have to write your code using
literal data structures and I'll give
some examples of what I mean you have to
have data structures built into the
language so Lisp of course has lists
closure has lists and vectors and maps
and sets prologue has terms XSLT has
data structures they are XML elements
and the components of that and even more
importantly though you have to have a
reader for those data structures the
fact that I can say read this string
without compiling or evaluating it just
read it and give me a list or a vector
or whatever it represents being able to
do that is a fund
until difference so to sort of put this
in perspective think of other languages
that may have literal data structures
JavaScript as an example has literal
objects and literal arrays there is a
syntax for them and you can read them
we call it json and if we wonder why
json is so power so popular it's because
you can do that but it's not sufficient
you can't express the entirety of
JavaScript the language using just the
literal data structures if you tried you
would get something like this this is
AWS cloud formation and it is a
programming language employed in json
data structures but it is very awkward
to work with so much so that they
actually replaced this with gamal which
is only slightly better because json
just doesn't have enough descriptive and
enough types and of differences of
things to make a language out of so you
need these three things that i will say
these are essential properties for a
homo a conic language but there's still
that that loophole that guy who just
wrote eval in java with a bunch of
string so I said okay I'm not gonna
count that stream array is everything
could be strings and byte arrays if we
let that be part of the definition then
it just doesn't make any sense anymore
but then I thought okay well what about
track or what about tickel they were
sort of the defining original versions
of this property and they're primarily
based on strings and byte arrays so I'll
just grandfather them in
they will be allowed to remain so why do
I care about this why why is this so
important I have a problem which is that
I love giving conference talks but I
hate making slides so about every year
or two
I try to come up with a way to have a
program create the slides for me and put
them on the screen there's been several
attempts at this this is the latest one
I decided I would represent my slides as
closure maps and this slide is actually
rendering itself so you could say it's a
Cline some of the slides would have HTML
on them
some of them would be read directly from
source code so this was part of the
source code I used to create the
presentation I put some metadata on it
that said this function is also a slide
and then I showed that with some closure
script code and then I defined my slide
deck I wanted to quickly and easily
rearrange all the slides in my
presentation so I thought I'll just give
them all IDs and I'll make this tree
like structure with sections and IDs of
all the slides and this is just closure
data it's Eden data it is not closure
code I didn't define functions or macros
called deck and section I just read this
in as a piece of data and then I used
closure spec to parse it I think this is
one of the interesting underappreciated
features of spec is you can make these
really great little parsers with it
so I just defined this is the entire
spec right here a few simple rules about
how I structured things in my slide deck
data and I could use conform to turn
that into a nested map tree like
structure and that was a little easier
to work with in a program so I could
turn that into day Tomic data which I
could load into a database and then
write some closure script code to turn
it back into HTML and that is how we get
the slideshow now
the truth is it didn't really work that
well and I would I would not recommend
this as an approach to making slides I
probably spent 50 times as long making
this as I would have in a presentation
app but the point is I wouldn't have
even attempted this in any other
language the fact that I could have all
these different layers from presentation
down to the database and work with them
all in the same syntax sometimes
consuming them sometimes generating them
being able to do that all within one
language was what made this kind of
thing possible and I want to contrast
this with an approach that is very
popular in many languages and that is
embedded dsls or domain-specific
languages I first encountered this idea
probably in Ruby this is an example just
from active record creating a sequel
table but you can find examples of this
in almost every modern programming
language especially the more dynamic
ones with more flexible syntax but go
for example here's a simpler example
from go that is defining some HTTP
routes and you do run into the same kind
of thing there are embedded DSL in lisps
as well done with macros so you'll see
examples of this things like this
enclosure where the outer macro
establishes some context where the inner
macros have meaning they're effectively
creating their own mini language out of
macros but the problem with this and the
thing that I always run into is that
these macros are creating their own
language but I don't get to work with
that language I'm limited to whatever
form these expand into and whatever
structures that can support so if I want
to put a conditional expression in there
if I want to put a loop in there can I
do it who knows I'd have to study the
implementation
of the macro and figure out if whatever
it's doing is compatible with the rest
of the language that I'm programming in
so I think these embedded ESL's are
actually quite limiting because they
only give you one shot and you cannot
build further abstractions on top of
them or at least it's very difficult
once you have a macro it's very very
hard to generate it without writing
another macro or something even more
complicated so I would much rather have
a system or a library that operates in
terms of plain static data structures
because then I can use all the power and
utility of the programming language I
know to produce that data or consume
that data that gives me many more
options for adding different layers of
expansion or translation on top of
whatever the DSL is providing now I
wrote some examples of this in a real
system that I worked on this was an
article I wrote for cognate echt earlier
this year describing a system we built
it was a university course system the
details aren't important but we had a
complex problem and we decided to use
the data features of closure to work
with it we created our own language for
describing the system enclosure data
even before we knew all the details of
how that system was going to work and we
were able to do that and able to extend
this language and map it across many
different representations from database
schemas to UI features to documentation
all using the same source data because
we got to define how that data would be
interpreted now I'm sure you all have
your own opinions about what homo
iconicity is you are welcome to argue
with me about them at the bar but that
is it so thank you all for coming
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>