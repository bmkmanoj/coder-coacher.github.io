<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>μKanren: Running the Little Things Backwards - Bodil Stokke | Coder Coacher - Coaching Coders</title><meta content="μKanren: Running the Little Things Backwards - Bodil Stokke - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>μKanren: Running the Little Things Backwards - Bodil Stokke</b></h2><h5 class="post__date">2015-07-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2e8VFSSNORg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right hello hey buddy loser I heard
there's a lot of Finnish people in the
audience okay nice to be speaking it
you're a pleasure again I can't see any
of you I got these bright lights in my
eyes but I assume that you're all out
that I was gonna start off quite by
saying it's about time somebody did some
actual locating in emacs but Alex ended
very strongly in the NAR silk sir
we've got that covered so I might as
well just skip my talking we can all go
to the party oh I can actually try and
do something up here
so what I'm going to do there's one
thing though that hasn't been done much
today and that's running things
backwards I feel this is rather
important magical neutral conference
we've got a traditional logic
programming enclosure we've had Dan
Freeman and we'll bird come talk about
mini Condren quite a bit it's always
equally mind-blowing
we got kolodziejczak which is actually a
thing enclosure dan and his new student
Jason human recently published a paper
called micro Cameron well essentially
they reduce the whole idea of micro
Cameron into some very basic small
concepts and write some very short and
succinct scheme program that essentially
does what Michael what mini Cameron does
except smaller and a lot more easy to
understand and that's gonna be my aim
today to show you this magic and how it
actually works
so relational programming is essentially
a program that doesn't just take inputs
and produce outputs but it takes inputs
and outputs and then it sort of figures
out which part of it is missing this is
a very simple relation program which we
are going to try and able to run
this talk this isn't even simple woman
this is really boring what this means
the fresh declares a variable so we're
saying let's introduce a variable Q and
the append a function is a concatenation
it takes two lists and produces a list
which is the concatenation of the two
you Riyaz lists so the difference from
normal closure is that instead of taking
those two input parameters we also put
the upper promise rate and in this case
we've made it the variable key so the
job of this program is to infer what is
the value of Q and can you do that for
me please what's going to be the value
of Q list of 1 2 3 4 5 this is there can
actually be more answers to most
relational programs so what you're
seeing here is the list of a list of 1 2
3 4 5 which is the only arm Sam but they
could have been more which means that
the list would have included more
answers and this one is slightly more
interesting what we are introducing
essentially cute as well as a and B and
and the reason we introduced Q at all
here is because we usually only get the
the value of the first variable we
declare out as the arm son so we're
simply saying that key contains a and B
so that we get the value of birthday and
being side Q with the double equals
function and then we call the append
again except this one this time we only
produce the arm sir
and a and B are the inputs and the job
of the program now is to figure out what
a and B are and what are they in this
case actually work in a multiple arm
sense we can have empty list and one two
three four five one and two three four
five and so on until one two three four
five nine empty list six different
possibilities and this is magic this is
like wow how did this happen this is I
have no idea I'm doing what I'm going to
do today is show you how
it's done the magic is sort of peek
behind the curtain and show you how how
the real work gets done so there are
three core concepts of micro Cameron
first there's the consider the concept
of state state defines a set of
relations and a variable counter
essentially we have a map which contains
bindings from logic variables to values
or possibly order logic variables and we
have a variable counter essentially when
I want to introduce a new logic variable
what I do is just increment the counter
and take the value of it and thus I have
the name of the next the next available
variable in this case we've defined two
variables since the country is naughty
the variable sets of zero I've used the
convention that as I'm not able to use
sets in any way I'm just borrowing sets
to be like the data type of logic
variables and the set only contains one
thing the name which is 0 and it's bound
to the number one and the barrier one
despondent number two in this case and
we have streets or essentially later
lists of states essentially when you run
a relational program what comes out is a
stream of states which satisfy the
programmer and they look simply like a
list of of these states that I just
described there can be several there can
be eight none in which case the program
has no answer
we have ghosts and the ghosts are sort
of the program itself a goal isn't quite
a state and returns a stream or
satisfying state possibly given that
starting state and a goal is essentially
a function which takes a state in notice
that I'm using some D structuring though
which is a common pattern in micro
Cameron at least in my closure
implementation of it where I take out
the the states bindings and the can
and in this case what I do is
essentially declare a new variable but
doesn't I don't do anything with it so
essentially I'm just wasting a variable
I increment the counter and return the
same state without binding then you
variable to anything which is just the
stupidest example I can think of so
we've got states we've got streams and
we've got ghost State our program states
streams are answers which contain States
and groves are sort of the program is
that they're functions which take us
from from one state to zero or more new
bottom of states there's a description
in the paper essentially what what my
guru Cameron is it says the given
collection of goes maybe much inspired
by zero or more state the results of all
Michael Cameron program is the stream of
satisfying States and say I hope that
makes sense to you now fundamental
operations they define four of them like
the four most basic things he can do in
a logic program define a variable define
a relation which says that something is
equal to something else
disjunction which means you have one
goal or another goal and if one of them
is true then you have an answer
conjunction is essentially if you had
two goals both of them must be satisfied
to produce an answer and that's enough
talk let's get to the programming Emacs
should I increase the fontsize little
bit I think that so the problem with
implementing Michael Cameron in closure
is that Michael can realize heavily on
console son closure Haslem and despite
that it calls itself a list but still
I'm gonna try to be sore about that but
I had to implement this yesterday to
make it work essentially I got an
implementation of
console-based list i've given first and
rest as the coulomb enclosure their
proper names Carmen Cana just for the
occasion to make it more readable and
it's actually I've implemented combs
I've made this a deaf talk on a deaf
protocol and we have comScore in Qatar
we have a list function which lets you
construct the constant it's very quickly
that's it
so first of all it's wasted okay got a
half an hour this should be good
first of all we need functions functions
to define variables you'll notice by the
way that I've excluded a lot of things
up here that are going to redefine but I
wanted to call this var but var isn't
actually redefine double so I'm calling
it l VAR for logic horrible and that
simply takes a number C and returns my
convention are using the set as a logic
firewall so I'm set that contains that
number C and I want to be able to test
if something is it a variable and that's
very simple just test if it's a set so I
want an empty state just gonna be an
empty mouth and the numbers there right
this is the starting state so all my
general Brigham's let's see I got a
ruffle up here I should let me just test
if it works yeah it does
i Tripoli a75 for ladies and gentlemen
that's the compile of the apps well name
one tourist over similar properties oh
yeah single pass compilers I mean I can
just recompile it and and it would
probably work but I want to make a point
of this what was the gist propolis to
prove lists okay not a complainer well
okay
say I got a lousy right I get very busy
road on man
and Alwar question mark and while
they're very terse true brilliant and
about a question mark no it's false
that's that looks good okay so next I
want to function walk and the function
walk takes an arbitrary value and a
mapping from inside the state which will
wouldn't just call an ass of a state and
the task a walk is to look through the
state mapping and resolve the the value
that a pass in if it's just a value then
they should be returned as it is if it's
a variable we need to look through
through the table and figure out what
it's it's bounty and you have to keep
doing that because it might be bound to
another variable which eventually is
bound to allow you so we go if if u is a
variable and James if as has a mapping
for it then we call walk again we do
some recursion with the valued that is
bounty unless again which means that if
it's bound to a variable again then we
keep calling it until we get a value out
and if it's just the value just return
the value so walk 1337 and two maps you
get us 30 37 walk
but Rivera's Dara with an empty map
should be logic variable zero because
there's no binding for it if we add a
binding it should resolve to the value
of the binding if we bind if we bind
one to zero that chorizo to zero and
then to 1337 whoops unmask delimiter
this is embarrassing
sorry ah there we go that was not a
parenthesis error that was a curly brace
errors and bathing in the sea okay
looks good so far next we add just some
bindings here we want the functions for
making a stream of no arms this we call
that admin zero and that's just new
that's them to list and sorry that would
be death and we want a function unit
which just takes one state and and
returns that state as inside the list so
am their own unit don't panic I know
this sounds suspiciously like concepts
from Haskell don't ask what the M is for
but it's fine it's just they were used
in the paper I'm just reusing them it
just means empty stream all answers and
3 more monsters would one answer and
snacks unify this is where it gets
interesting we want a function that says
take these two values and unify them
which means that we declare them to be
equal and then note that in the state so
we can say 1 equals 1 and that doesn't
need noting in the state so we would
just return the state I'm changed we
could say 1 equals 2 which is obviously
incorrect presumably and that will
return nothing
because that is obviously not trained we
could find logic fireable something to
evaluate and that will be noted so let's
run implement that first we need to
resolve a and B just by walking them and
then we have a very big cons first if u
is a variable and B is a viable and
they're the same variable then just
return a state of change that doesn't
mean noting but if u is a variable and
the previous isn't true then we know
that U and V are equal essentially we
associate the key and B as the value in
us so same goes for V as V u so that
allows us to save variables are equal to
values and we need to be able to do this
inside lists so this one's a bit
interesting if u is a list and V the
list
then get a new s where we unify the
first element of the list the car and
the first elements of the other list and
if that hasn't failed and then we unify
the rest of the list cut a V on us there
we go and as I was close we just check
if if you and we are equal at this point
they should be just values then we
return us and if the equals test fails
that means we get a false out
means no I'm sad so let's test if that
works so let's try an unified 1337 1337
with the m2 this hasn't the empty map as
an input I can just the empty my back
that means there is an answer we didn't
need to know anything about it it works
30:38 we get false that means that it
sounded than it that eight are obviously
not the same what if we burn it to zero
we get a binding not good now assess
that zero is 1337 just good now I must
get interest let's make it interesting
this one two three this one two three
that's good one two four so I mean
that's false that's correct
one two three four just a test if it
checks the list of the same length yes
and now we can also get one two logic
variables zero and that actually picks
the three note like that the three is in
the third position in the first list and
the zero the og Firebird zero it's in
the third position of the second list
and so we figure out that the logic
barrier will must have the value 3 for
these lists to be equal we're sort of
almost seeing proper logic programming
already but that's getting the operators
in equals U and V so this takes two
values and makes a go that says they're
equal and I go and I so note it is a
function which takes a state which
contains s and C and we say s is the
unification of UVs those are just run
unify on on input and if that didn't
fail on us then we return unit as MC
with a new value of s that means one
answer
with a new binding and if that fails we
return m0 no I'm sir so now I can go
honest one and if we run bass when amped
estate essentially call the call the
function values returned that you can
see just there with a funny name for
them to say it has an input it should
run the program for us and notes that we
have no bindings no variables but there
is an answer one is indeed one at the
difference we guess and m2 this back if
we try and pretend that one is too okay
I'm and the same applies that I showed
you when the unify for the logic variant
was a would not but we need to be able
to bind the logic variables as well so
I'm going to introduce a function called
called fresh which takes a function and
returns a goal which declares a variable
and passes it on to the function and we
call the function with a new variable
that we make and we increase C l VAR c
sorry so we take the current value of so
you would make a variable out of it we
pass it on to the function that we
passed as an argument and we return and
we run it essentially this this returns
a goal so we run this returning this
state it's very pausing the state in and
this statement simply notes that we have
used the the variable C so the next one
will be C plus 1 so now we can do
something like call fresh with a
function that takes of our value Q which
is gonna be the new logic variable we
can note that Q is equal to 5 and if we
run that the empty state
we used to state out saying that yeah
notifiable 0rq is five that's good and
it that's it has a one on the end which
means we have incremented the counter
probably okay now in order to implement
or an and which are sort of required to
do programs that are slightly more fancy
than later they just think one thing is
equal to the other where you will need
some helper functions i'm class stream
on stream to and plus is simply
concatenation and if stream one as a
list then we return comes of car of
stream one and am+ cutter stream one on
stream T this is just a recursive
concatenation really there's nothing
fancy to it essentially if if one is a
list keep recursing i'm said we've
expended one and if one is not a little
is the empty list then we're just return
t so that means if we test this we have
list one two lists three four hopefully
we get at this one two three four good
and bind find is the M word bind which
simply if it's if the stream is the list
and plus run the goal yeah you pause the
stream and a goal in and you apply the
goal to all the elements of the stream
essentially sort of like map so we apply
goal to the start of the list and then
we recurse on the end of the
we're G and if the stream is empty then
return the empty list okay sorry
oh yes correct thank you that's it okay
so that makes it easy for us to
implement the destruction and the
conjunction just teeth to make sure we
don't get too comfortable I'm not gonna
call them over an ant I'm gonna call
them this jerk and conjure God wanna go
see which sends a function that takes a
state and and Plus this g1 all that
state and g2 of that state good punch is
basically almost exactly the same except
we bind with g2
okay so now we can get interesting just
see how much time I got left before I
get too interesting 60 minutes I think
okay good so I can go this chair well I
need to call fresh firsts I need a
variable Q and then I can say dis
cha-cha Q is 1 and Q is 2 and that gets
me a gold function and I call that win
them to state and I get chills sq1 9 q
stews that looks good
now if I change changed the destruction
to a conjunction I get no on so because
kicking up in both 1 and 2 but I can say
that Q is 1 or Q 1 that satisfies the
ant because skews indeed 1 okay so
that's some sawaki
just let me add a function because I'm
sick of calling us and I'm to say to all
the time let's make one call go of G
which just does that for us
gon to state so I just go cool go get
rid of name to state and that's the same
thing okay so let's get fancy let's
create the girl fights wait
it's the disjunction of X equals 5 and a
new goal which says x equals 5 again
what we got here is an infinite stream
of answer saying X is 5 and at this
point we realize we might have a problem
because if there's an infinity of
answers what happens if I try to run
this actually I need to call fresh
there's fresh voice ah luckily we don't
go into an infinite loop because
equation just still does not have tape
on elimination so we get a stacker if I
understand that's not good we want to be
able to handle this we didn't mention
that the the stream is supposed to be
lazy so let's add lays in this and
that's really simple actually
we just need to modify um person buoyant
so you'll be able to see essentially
what I'm going to do instead of just
returning this one immediately I'm going
to wrap it in a closure and then an plus
needs to check whether we are pausing in
a closure which is just gonna be a
function if so then we return a new
function where we
we essentially make a new closure where
we unwrap the first closure and likewise
with uh uh you need to stop them
stopping when I do super things like
this it's the inside they called
obviously there we go okay this one
should we bind instead and this should
read nothing Angie okay but that's
probably looking at workers
yes well yeah yeah yeah I thought okay
okay so Albin's now we get a list of the
first officer and a function we need to
actually make something to unwrap that
and so that's cool nice to make a
function of pull which takes a stream
and if that isn't a stream but the
function then we pull again unwrapping
it and if it isn't a function we just
return it essays and then we need a
function take which lets us specify a
number of odds is that we want to take
out on the stream this is almost exactly
like to take function in normal closure
if if we want zero and since then we get
the empty list otherwise we pull and we
recurse
come take recurse here and the cutter
and I have said okay because untick it
take all here but I'm not gonna bother
because I'm not gonna need it
so take ten like if there's ten answers
of pipes so that works we've made this
blazing out and it doesn't go on forever
alright that's another thing I could go
wrong
it's basically have sixes as well
essentially sorry Mike's failure
multiple cursors so return success and
then we make five sixes go function acts
distro five sub X and success thanks and
now take turn of cold go fives and sixes
get faster fives that's annoying I have
an infinite list of rice and an infinite
list of success and as it happens we do
depth-first search which is what Pro low
dose but Prolog is is old I'm cool and
what mini camera is a base to do is an
internet search essentially we should
get financing with five films with
success then five sixes and towards
infinity how do we do that actually this
one's really simple really simple we
just swap the order in the m+
that's it and now I got five six five
six and so on to infinity we can take a
hundred that's a lot of fights in six
days we can take 1 million and I got to
be some vicious that because we're still
on the stack but you get the idea that's
a lot of it cool huh
yeah I know I know right but this is the
closure conference I covered it in the
traditional way okay but that's actually
our mini Cameron implemented for us I'm
just gonna have to get the appender I'm
just gonna take the opportunity to copy
a lot of macros and things because I
don't want to type this out and
especially since I have 8 minutes left
so I made this for you
essentially it adds things like the run
macro which instead of meat so I think
take 1 million call goal I can just go
run - success run ten fives and sixes
and it's got the fresh macro which
instead of doing the call fresh with a
function I just save fresh I see so at
the start and we got the condé but I
think I'm just gonna stick with the
content this job to make this clear so
now I'm gonna make the append a yes I
think I have time to type it out for
maximum excitement just check that this
compose it does not take oh yeah I
didn't implement a call but that's only
required by run start I'm gonna remove
run star no yeah okay so the append a
this one is the my own manga it takes a
lot of getting use out how to write
programs in mini can run and fortunately
somebody did this before me scientist so
to copy this and try to figure out how
it works
eventually append a takes three
of the left hand and the right hand and
the output and of course the output
should be the concatenation of the left
on the right hand say let's do that with
old-fashioned disk and conjure we start
off for the destruction or and a
conjunction which stars and is kneel and
AH is out so what this says is if the
left hand is an empty list then
obviously the output must be just the
right hand because the mental is
concatenated to something is just that
something so this is that terminating
clause this is social like writing a
recursive program like in Haskell Lisp
or and then we need variables small
variables and the analyst ang of course
referring to the the address and
undeclared registers from core encoder a
means the heads and demons the tail we
use AMD for clarity head and tail a leg
fancy haskell words and now we say if
cons a on 2d is AO or not if we say that
l equals comes an D that means that what
say India couldn't going to sort of
contain here is it's gonna be the head
of al and he's gonna be the tailor
equals comes a ref out now I get fancy
now I say about out or a is also going
to be the head of out and rest is going
to be the tail amount which means that
rest has to start with D at least we
don't specify that relation but it's
employed for logic ok that's it
and we recurse
I should note that the fresh macro it
wraps everything in a conch so all all
my statements inside the fresh have to
be true and also it wraps them in in
that lacy closure thing so I didn't have
to worry that I believe I just go into
an infinite loop and blow the stack when
I just call a pen dough again him
directly here when i recurse this is
gonna be like closure of endo and DRS so
we essentially great to go which which
instead of saying l RS we say DRS and d
is l without its head and so that's
going to go through all the elements of
the like the left hand list until it
reaches the first statement that which
says the left catalyst is empty I know
that word we should have our own so I
would go out of the recursion and figure
out what the answer is so now let us do
the actual program run ten fresh qab
actually let's just do the stupid one
first let's just see if it works at all
I'm nervous about this you see list one
two list three for you and that says he
must be nice incidentally that might run
macro unwraps my most state and and just
returns the contents are the first logic
variable that only class which is care
so what's inside this list now is the
contents of queue and nothing else and
that is one two three four so it looks
like it works at least for the simple
case which any programming language
continue enclosure is it calm cut yeah
close you can do the same thing what
closure cannot see us run this backwards
which we are now about to do well close
obviously come do it because I'm writing
in his enclosure
you know what I mean um panda that was
one two three four five maybe um I also
need to say that Q's am be unlisted
might be okay big moment if I can go
party and not think about this right my
list has sense is tingling
actually my Emacs is highlighting the
wrong paranthesis which means they're
not balanced if this is right and we get
the answer empty less than 1 2 3 4 5 1 &amp;amp;
2 3 4 5 1 2 &amp;amp; 3 4 5 1 2 3 4 5 1 2 3 4 &amp;amp;
5 3 4 5 and emptiness that looks great
so yay
so that was essentially like several
decades of research on the person don't
Freeman and company in half an hour no
big deal it's cool though isn't it
anyway that was it
then go have fun thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>