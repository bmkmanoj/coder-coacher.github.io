<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Power to the (Mobile) People: Clojure and GraphQL - Howard Lewis Ship | Coder Coacher - Coaching Coders</title><meta content="Power to the (Mobile) People: Clojure and GraphQL - Howard Lewis Ship - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Power to the (Mobile) People: Clojure and GraphQL - Howard Lewis Ship</b></h2><h5 class="post__date">2017-03-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/I0vVkQfmy9w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this session my name is
Howard Lewis ship
I'm a closure developer at Walmart labs
we write a whole lot of server-side code
in closure but I sit in an office full
of iOS developers some of whom are using
our code and so I'm kind of privy to a
few conversations along this lines you
end up with a mobile device a phone
calls up to the server and says hey I
have the screen I need to get just the
customers zip code and the server comes
back with everything it knows about the
customer first name last name dog's name
dog's favorite toy phone number or alpha
sort all sorts of stuff why
just cuz history so this is the kind of
conversation you end up having I just
needed the zip code which of these is
the zip code and the server-side
developer says I don't know I think it's
called postcode why database reasons
history 30 years of architecture
meanwhile the developer might then say
well you know I also need a little bit
of order history on just the screen can
I get that oh yeah here's a bunch of
requests you can make to get that data
and I literally have heard this yeah
we're making too many requests and we're
getting complaints there's a guy in the
office who just tracks complaints about
the Walmart iOS app and yeah it's slow
and the customers notice sure I'll get
an endpoint up for you as soon as I can
I'll be about a month now our team can
get stuff up in a few days but not
everyone at Walmart can get stuff going
in production that fast so obviously if
you're a client dev here you've got a
problems one you're getting these great
big responses to little tiny requests
you know one size does not fit all big
responses are a problem problem if
you're on mobile and having to do
multiple requests to get the data that
you need is just slow and painful then
sometimes you end up with some
historically named field or column or a
piece of data coming down to you and now
you have to go
maybe scrape the response they got from
the server and changed the name around
is something that's more convenient or
sensible for you and keep track of that
when you're then maybe sending data back
to the server just busy work and then
documentation okay
sometimes the best you get is oh yeah
there's a confluence page but I don't
think it's added up-to-date you know
that's that's no fun that's a
non-starter that's the death of
information meanwhile I have a little
bit of empathy for the server-side
developer you know all my clients use
different data so what am I going to do
I'm gonna give the greatest common
denominator otherwise I'm gonna have to
have some crazy number of weird
endpoints what about documentation you
know I've got it's just code I have to
go into confluence or something and go
into a wiki write up all this
documentation find time to keep it up to
date sometimes someone changes it and I
don't know you know it's rest we're
trying to be very restful you know
customer that's one endpoint orders
that's another endpoint that's just how
rest works I think as best as I can
figure out and you know I'm bashing on
the the server-side developer but you
know they're just like everyone else
they want to give everyone what they
need they want to be good to their
clients but we got tests we got code we
got a development process we got
technical debt we're just drowning in it
why are we in the business of setting up
all these little bits of data for our
clients and that exactly is where graph
QL comes into the picture graph QL is a
way of a server-side developer saying
I've got all of this data all these
relationships just take what you need
and the client can say great
I need the zip code and I need a little
bit of order history okay
it's a query language for api's it
starts with a schema that applies a
little bit of basic names and types to
the data that you want to expose to your
clients there's a query language that
leverages that schema leverages those
types to describe what you can
what data you can get and ultimately
what kind of changes you can make to the
data there's an introspection layer
where you can use graph QL to ask your
server what data it exposes and in fact
I'll show you a demo in just a moment of
a IDE client-side IDE called graph iql
that uses that to give you the ability
to construct queries on the fly it's
incredibly effective things it's not not
a relational database adapter not an
object relational VISS or that it's just
a contract it doesn't know where the
data comes from it just knows that once
the data gets into licinia into graph QL
licinia's our implementation once it
comes in we know how to select it modify
it set it up get it down to the client
but we don't care where that data comes
from so here's a simple graph QL query
I'm looking up a customer I have its ID
I want that postcode field named because
of database reasons but I want to call
it zip code and the server is great here
is here's your data
here's that customer you asked for
here's that zip code from that customer
that you asked for
ok so for a demo I wanted to put
together a little demo I could share and
people who know me know that I'm really
big on games and there's a site out
there called BoardGameGeek that's a big
compendium of board games and reviews
and details about them turns out it has
a really really clumsy XML interface to
get out some of that data so I built up
a graph QL schema that talks about board
games and a bunch of properties of board
games like the number of players and the
playing time and also relationships you
know companies that publish board games
designers who design board games I just
created a couple of basic queries to
allow me to do a search for games
matching a search term or to get details
about any specific game and I put all
this together so let me show you what I
have now because the internet is so
lucky I pre-recorded the demo so you
I have to apologize for that well
actually give me a chance to talk about
it a little bit more okay so this is
gonna be graph QL graph iql the IDE so
it pops up and it has a couple of pains
one is where we put our query and the
others where we'll see the results and
as you type is by this point it's
already asked the server for all the
introspection data it knows all about
our schema so as we're typing it's
providing completions and validations so
if you type something wrong you get the
normal red squigglies so I'm saying here
go look up a game called certs and give
me its ID and its name and it pops up as
Jason over here another great part of
graph iql is that there's this docs tab
and you can navigate down through the
available queries and you can see
details about what a query is what a
boardgame is a list of all of the
different fields exposed by each entity
and you can keep drilling down so it's
really easy to get more information just
exactly the information you need
now in this case our search is returning
a list of matches but there's only one
match but for tiny epic which is a
series of games I like whole bunch of
matches so for each one it gets the same
selection of subfields
now I'm grabbing the ID of one
particular board game and I'm changing
the query from a search for multiple
board games to just one and then one of
the great things about graph QL is how
well it handles the idea of
relationships so there's a relationship
between games and designers and here
I've run that query and this game only
had one designer and that designers name
was Scott Elms and there could be other
data about designers designers could
have further relationships that we could
Traverse and get into the response as I
say it's a graph it's really more like a
tree but the point is is we have all of
this data is available to whatever depth
we wish to get it and we can get it all
at once that's the demo
so what was going on here is the browser
was talking to an app that we wrote in
pedestal enclosure on top of licinia at
the library we're introducing here and
it talked XML to BoardGameGeek and did a
little bit of caching of the responses
so it had to go do xml requests to its
endpoint get the data turn into closure
data and expose it so again
licinia licinia is the open source
library we've been developing at Walmart
for well over a year now to perform
graph QL and it's something that's used
internally and in production so when you
start using graph QL you start with your
schema your data types and here we're
talking about a boardgame entity and it
has things like an ID a name publish
here and lists of publisher and
companies and lists of designers in
licinia we define this using closure
data so we start with an Eden file that
defines all the details of our schema
and one entry here might be to describe
what a boardgame is describe the fields
of the boardgame and for each field
identify its type ok many type in many
cases the types are built in scalar
types supported by graph QL things like
ID string number and a few others in
other cases we're talking about types
defined in the schema here we have a
company and board games are different
entities that can be referenced and
there's additional markup to say that
this is this value is a list of such
entities so it's a list of companies for
the publishers of a single board game we
also define queries so we give each
query a name and we describe the type of
data it returns and we can also talk
about the arguments that can be supplied
to the query that guides its execution
for the search query we need a search
term for the game query which returns an
individual board game we need the
i D of the board game now these things
are called
fields and fields are look like simple
properties you know it looks like it's
just like Jason we're just navigating
dot dot as if it was a JSON data
structure or nested closure data
structure but in practice these fields
are more like functions they can have
arguments that guide how they operate
and you define the argument names and
types as part of your schema and they
operate like functions they're passed
some data and they're returned some data
so the basic process of building up the
response in graph QL is very recursive
process okay how do we get to this point
where we've asked for a particular game
and we've gotten the name and the
publishers and the name of each
publisher well we start at the root
query we use the arguments passed up and
we go to whatever our external store is
and we get a bit of data okay and
included in this is the ID the name and
a bunch of different IDs for publishers
in this case so our output response
starts with a data key and then nested
within that is the particular query
we're executing which is game and nested
with that is some data that we're still
working on now that thing we just
resolved that internal representation of
a board game gets passed down to the
next level field resolver first one's
called name it reaches in and finds a
colon named key and that becomes the
value at which point we know one another
bit of what our ultimate response back
down to the client is going to look like
for publishers we do the same thing
except we map over the publishers since
it's a list so each publisher gets the
game it's immediately parent resolved
value and we know that we're gonna get
something there and and inside it we
first handled the first publisher and
pull out its name and then the second
publisher and pulled its name
at this point we've kind of exhausted
our query and we can actually build up
this response data structure from the
leaves back towards the root and then
pass it back down to the client when the
nice things about graph QL as a
specification is you're not limited to
just one query when you send up your
your query document you can actually
execute multiple queries at the same
time so here we're saying go execute and
this is from the Star Wars example go
execute and find out who the hero is of
Star Wars for a new hope also while
you're at it go execute and see who the
hero of Empire Strikes Back is and we
see in the response there labeled new
hope yeah Luke Skywalker and yeah there
might be a little editorializing there
but yeah the but the main point here is
that yes you can do multiple things in
one round-trip to the server another
aspect of graph QL is mutations so in a
typical rest environment you have you
know you try and make it look the same
we'll cover that in a second in graph QL
you explicitly say yes we have mutations
you can read whatever data you want but
you're limited in what you're allowed to
update okay so here we're gonna change
the alignment we're going to invoke a
unmute ation now this it's expected to
produce a side effect in our external
store but also provide a value that we
can then select on so here we find out
that yeah Luke will go to the dark side
and become Darth Skywalker okay you
heard it here first
this is one of the fundamental
differences and I think one of the
things that really makes graph to you
well line up well with closure is the
rest world is trying to maintain this
idea that you can take the entire state
of some entity that's stored on the
server side in a data store you can get
that somehow down to the client the
client can make whatever changes it
wants and then the results that can be
pushed back up to the server and somehow
that can be reconciled and put back into
the data store and for you know really
simple things like blog postings and
stuff yeah you can kind of do that but
when I've done this in the past building
as compliant as I could rest interfaces
you ended up with all kinds of questions
about how to handle things like
hierarchies of data how do you handle
read-only fields you know how do you
handle data that you are a canner are
not authorized to change there were
always these edge cases that escaped us
and in graph QL it's just very natural
if you have a finite set of operations
mutations that you're allowed to make
and so the semantics of what those
mutations specifically do is clear and
you're only passing up the absolute data
you need in order to make those
operations occur now this really lines
up well with the goal of closure which
is you know closure data is open and
then once you have some data you have
functions that modify that data and
return a new version of that data and we
just add a side effect that sure we're
gonna store that on the server as well
so this is one of the reasons I think
that there's a lot of synergy between
closure and graph QL in general so let's
go a little bit further into how we
built up the BoardGameGeek demo again we
have the scheme of board games and
companies and designers and the way this
works in licinia is that you start with
an Eden file and then you load it we
loaded as a resource and then there's a
step called attaching the resolvers
resolvers we'll see in a moment are the
point where
comes into licinia so we only described
what the data looks like to licinia we
need to provide code that actually
allows it to get data from an external
store and those are called field
resolvers our field resolvers are about
going out to BoardGameGeek getting xml
data
chopping it up and turning into the
closure data and then on top of this
we're going to expose it all on top of
pedestal so again the schema is an Eden
file and there's room in a schema to
describe the objects that exist in our
system to describe the queries and the
mutations to describe new enumerated
types and to describe new new scalar
types but for this example we're just
defining a couple of objects and a
couple of queries here's that company
object one of the nice things is we can
attach a description to objects to
fields to queries to mutations and that
shows up in the introspection shows up
in graph iql the main thing you do when
you define a an object a schema object
is to define all the fields now
boardgames a little more complicated has
a lot more data going on and the key
part is this resolved part we have to
tell licinia where to get the data from
we do that by putting a placeholder into
the eden file and ultimately we're going
to replace that keyword resolved Gav and
publishers we're gonna replace that
keyword with a function and we do that
in our initialization code we do the
same thing for our queries so the
queries also need resolvers that's the
point where data comes into the system
so what is a field resolver again it's
the thing that knows your data it's a
function that takes three arguments one
argument is an application to find
context map it's just whatever you need
it to be so if you need to store
database connections or user
authentication data or the
coming pedestal request or any of that
data you can put it in the context when
you do your execute the query and it's
provided to all of the resolvers the
second argument is the arguments to the
field you know we saw that you can say
what is the we're doing a search what is
the search term we're getting a game
what is the game ID that shows up as a
map of arguments and lastly the value
remember when we were doing the example
of drilling down through the field
resolvers each resolver got the
previously one level up resolved value
that's that third argument here so in
our case to do a search we have a
namespace function called client search
we pass it in a cache that it uses
because Borgan beeps really slow and we
get an argument called term and we pass
that in and we get back a company map
that can then be selected and
incorporated into the response kind of
the same thing for getting an individual
board game and this is kind of key to
how I like to use licinia I like to use
resolvers is that these functions are
really small that we do the heavy
lifting and a component or in a larger
function and we're just got a little bit
of interface here where the city it
calls into our code our code needs to go
get data and return it now one of the
nice things about this is we can do so
much work at the repple you know I've
been very used to building services
where I feel like I don't really know
exactly what they're going to be doing
unless I come in through an HTTP
endpoint but because licinia really sets
a great contract for what's going on in
the client what's going on the server I
have a lot more confidence that things I
do at the repple will match things all
happen in production in at runtime so
here I can test that little client
library the thing that does the actual
work of talking to BoardGameGeek and
verify that I'm getting data in the
shape that I expect it to be
okay so as I said we read a Eden file
okay then we do the step called attach
resolvers this is the thing that
navigates that tree and it finds where
we've mentioned resolvers with keywords
and replaces them with actual functions
once we have that we go through a
compliation stage the violation stage
reorganizes this map does a bunch of
verifications and validations defaults
and sets it up to operate very
efficiently for execution and the nice
thing about licinia is although we are
exposing it using pedestal and we're
sending JSON down to the client the
reality is it's just a library that
manipulates data it doesn't actually
know anything about HTTP you can see
exactly what your code is going to do
again at the repple just by invoking
licinia's execute function directly so
we invoke execute we pass it the
compiled schema we pass it a string
which is the query to parse and execute
we pass it variables which maybe we'll
discuss during QA and that application
context and it will parse the query into
an executive format execute it and build
up that data structure the that
ultimately we streamed is Jason and we
get it back and this matches what will
go down to the client all this ordered
map business is an aspect of graph QL
that says the order in which Keys come
back in the response has to match the
order in which they're specified in the
request so instead of using normal maps
which aren't ordered we use an ordered
map implementation it prints a little
weird but it turns into the Jason you'd
expect
and the last piece here is that we want
to expose this using pedestal
so again licinia doesn't know about the
web tier it's just a library that feeds
data and converts it we can create
routes and pedestal handlers that filter
down to one point where we just call the
scindia's execute function so again what
we did if the repple really is very good
match for what is going to be happen
when we get a request over the wire okay
so I must have raced through this a
little bit too quickly which is great
we'll have some time for some Q&amp;amp;A we're
using licinia in production today so
we're using it for two major things
inside you receipts one is our query
service every time you go to a Walmart
and you purchase something that receipt
is passed through our code at a rate of
about 500 receipts per second and we
store it forever in Cassandra and we
expose that data now to our clients
using graph QL so if you're using the
Walmart iOS app and you are looking at
your receipt history it's hitting graph
QL it's hitting these servers now we're
hitting something like two hundred
thousand requests an hour so we're right
now we're vastly over provisioned
because we've got two data centers and
ten servers in each Center that's a lot
for the amount of traffic we have and
that's okay we of course we see things
triple over holiday we also have a
second application that will ultimately
be even bigger than this that's related
to grocery so that also is powered by
graph QL and that one is a little bit
different it doesn't map as much on top
of Cassandra as it does on top of
existing databases which is a nice thing
the idea that you can take your old
interfaces and it's reexpose them as I
did with BoardGameGeek re expose them
with this graph QL wrapper okay
links to the demos and everyone likes to
quote Alan Perlis this is a great one to
me implementing things in rest is very
complex you're sort of bridging this gap
between
the HTTP world and trying to figure out
all these semantics of webpages how does
that map to an API how is it mapped in
terms of errors and status codes how do
you deal with hierarchies of data it's
always been very complex to me graph QL
is a lot like closure the way closure
inverts problems and creates great
solutions from graph QL does kind of the
same thing to this relationship between
the client and the server it says let's
make something that's easy make
something that's simple and I think you
couldn't get there without suffering
through the frustrations of trying to
build traditional endpoints so I'm very
impressed by the designer graph QL</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>