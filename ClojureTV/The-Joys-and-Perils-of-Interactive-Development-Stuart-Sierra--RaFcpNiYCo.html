<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Joys and Perils of Interactive Development - Stuart Sierra | Coder Coacher - Coaching Coders</title><meta content="The Joys and Perils of Interactive Development - Stuart Sierra - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Joys and Perils of Interactive Development - Stuart Sierra</b></h2><h5 class="post__date">2016-04-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-RaFcpNiYCo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you on October 24th 1998 a rocket
launched from Cape Canaveral Florida
carrying a small probe the NASA mission
deep space one deep space one was part
of NASA's new millennium program they
declared the era of big space missions
was over they were going to be better
faster and cheaper from now on so this
was NASA trying to be agile and it was
deep space one was an astonishingly
small program compared to other space
missions it only weighed a few hundred
kilograms it was developed in just four
years at a cost of a hundred and fifty
million dollars compared to other NASA
missions this was the tiniest mission
they could have put on it was their
Minimum Viable Product and it was also a
testing ground for a bunch of new
technologies deep-space one had all
sorts of cool new things that NASA was
trying out it had a futuristic ion pulse
engine that looks like something out of
Star Wars and it had some new software
that had just been developed at JPL
called the remote agent the remote agent
was a fully autonomous control system
for deep-space 1 the idea was instead of
giving it very specific instructions on
how to fire the Rockets or something
they would just tell it go take a
picture of that comet and it would
figure out how to do it and do whatever
it needed to do to accomplish that goal
so quite a long time before self-driving
cars were a thing
NASA here is trying to build a
self-driving spaceship and the remote
agent was written in what was then still
a fairly obscure programming language
called Lisp and even in an academic kind
of cutting-edge place like NASA this was
quite a
controversial decision a lot of people
did not like this ADA was the
programming language that NASA used and
some comments on that and C++ was the
hot new thing so all the pressure was to
move to C++ and they actually tried they
tried to port this piece of software
just a part of it to C++ and after a
year they gave up it was too hard to
deal with C++ and to solve this problem
at the same time so languages definitely
matter when you're trying to solve hard
problems now I'm sure I don't need to
explain to this crowd clearly obviously
what they should have done is write it
in Java
which could have happened a couple years
earlier Sun had just released their
first definition of the Java language
and its environment and Java was pretty
radical for the time it had a bunch of
ideas that were not mainstream and they
had to really fight to get those
involved as jaws guy Steele later said
they had to drag the C++ programmers
half way to Lisp and there were some
really big ideas here Java was garbage
collected it had a bytecode interpreter
I mean these were these were really
tough things to sell in in the days when
C++ was the mainstream thing but there
was another critical feature of Java
that makes it especially interesting for
us and that was it had a dynamic runtime
the language itself the java language
was statically compiled they couldn't be
too radical but the runtime was dynamic
it could load new code and link it into
a running program at runtime and this is
what makes closure possible if it
weren't for this one decision none of us
would be here today so this is what
gives us the lovely interactive
development experience that we have with
closure now where we have an editor a
ripple and our application all running
at the same time all on the screen with
our highly technical tiling window
manager and we can write some code and
try it out in the repple and it doesn't
work oh right because we forgot oh we
have to load the code then we can test
it in the repple and everything works
Hey look there's a rectangle on the
screen and then we can define some more
code we can see how that looks in the
repple and test it out hey it works
great and then we might do some
refactoring so I think I want to change
the definition of that function I'll
reload it try it out in the repple again
everything still works but of course I'm
a very conscientious closure programmer
I have unit tests so I run all of my
tests in the repple and they all still
work so I commit my code
go home come back to work the next
morning open up my editor try to load my
code and darn they broke and that's kind
of confusing can't resolve rectangle
what is this weird error message I don't
know so I you know I peer at the code
for a while and sing where's rectangle
oh I see what I did I made a dumb
mistake I changed the name of the
function in one place and I forgot to
change it in the other place but my code
worked before the tests passed what's
what's going on how did I get into this
situation well when I first loaded the
code I evaluated these definitions and
got two definitions in my running
program square and rectangle then I
changed some of the code and evaluated
again and I got two more definitions in
the running program and because I've got
the same name square that function just
replaced the definition that was there
before but I didn't say anything about
rectangle I didn't tell closure that the
rect function is the replacement for
rectangle and of course Javas
garbage-collected so it's not going to
discard that rectangle function if I
didn't tell it to and the act of loading
code when I click that button in my
editor load this file all that's really
happening is I'm sending all of that
code to the repple it's exactly as if I
had typed all of those definitions back
into the repple and evaluated them one
at a time and there's nothing about that
process that indicates that I've
actually changed something all closure
can see is the new definition so even in
fairly trivial code like this it's very
easy to get into a situation where the
definitions in the running program the
things in the language runtime are not
in sync with the things in my source
files they don't match up
and this is the trade-off we have to
accept now we love the interactive
development experience it's faster it's
easier but it introduced this new
possible way our program can fail it
added a new potential source of
complexity so of course after you've
used closure for a little while you get
you get used to this kind of problem you
learn that you know periodically you got
to restart the repple just to make sure
everything still works run your tests in
a separate process bla bla bla you know
you can deal with this but you have to
do something
to make sure that periodically you get
back to a clean slate in your program
but that's boring and tedious so let's
go back to space on May 17th 1999 about
six months after the launch the deep
space one team was ready to test the
remote agent and so they turned it on
with this command sent to the spacecraft
now obviously that's not Lisp but you
know it was a very narrow channel they
had to save on bytes so this was the
command that they sent at 11 a.m. on a
Monday morning they turned the remote
agent on and lo and behold it worked
they sent it some goals it figured out
it had to fire some frustr z' and do
some things and you know figure out how
to orient itself to take a picture and
it fired the rocket and it did
everything it even handled a simulated
failure scenario that they'd given it
and everything was going great they were
so excited until midway on the second
day when it stopped
nothing silence so what do you do well
at this point Deep Space 1 was somewhere
between 45 and 60 million miles away
from the earth it took about 10 minutes
just for a radio signal to reach it and
come back so you thought your ripple was
slow to start up these guys really had a
difficult problem and they can't just
walk over and reboot the thing so what
do you do well fortunately they had
a secret weapon the deep space one
remote agent team had a ripple running
on their spacecraft it was an
interesting experience but they were
able to use it to debug the problem to
actually diagnose the problem by poking
at the runtime state of their spaceship
to figure out what was wrong in it with
it eventually they found the bug there
was a race condition in another piece of
software not written in Lisp a race
condition that that appeared in
production moreover despite months of
rigorous testing this is NASA we're
talking about and a formal proof of
correctness but there was a bug and they
had a ripple so they could find the
source of the problem upload a patch and
fix it they were able to finish the
mission with Deep Space 1 and remote
agent so back to my own slightly more
mundane problems I was working on ways
that I could have this interactive
development experience but also be able
to recover the clean state of a program
and avoid some of these things like
renaming or deleting a function avoid
some of those bugs so I worked on a
library first in a testing library
called lazy tests that never really went
anywhere and later on I revived the same
ideas in a library called tools named
space and I discovered you know what I
can actually force a namespace to be
cleared out I can call remove NS to
delete a namespace and all of the
definitions all the VARs that it
contains and then reload it again so
this allows me to avoid some of those
problems with old definitions hanging
around I discovered though in order to
make this work I had to kind of hack it
a little bit because there's another
piece of State down in the closure
runtime that keeps track of which things
have been loaded and this is actually
not even public I had to reach into a
at var in the closure runtime and mess
around with it a bit to get all of this
to work so this is kind of a hack but it
does work and this allows us to reload a
namespace cleanly and as if we have
loaded it for the first time so we might
be working on some code that does
something it has a computation and some
side-effects and I try it out at the
repple and I look at the result and it's
not quite right
so of course this is closure we like
closure we can test out individual
pieces of our program so I do that it
looks fine so I think okay what else is
going on maybe I'll add a little
debugging helper I'll write a little
macro that prints out the value and
returns it I'll insert that into my
function definition call it again and I
can see Oh obviously I returned PI when
I should have returned tau because
everyone knows tau is better than PI and
so that's the result and I thank you and
I I fixed my function and you know I get
it right I reload it I run it again and
everything works and it's great okay
good so then I decide you know what I
actually want to keep this little spy
macro so I don't want it to print
something out at the repple I actually
wanted to log something using a logging
framework so I'll modify that macro I'll
reload it and then I check my function
again at the repple and it's still doing
the old thing that's odd I know I
reloaded the definition of spy what's
what's going on well to figure this out
I have to think for a minute okay
when I defined the function do stuff
when I loaded that function it used the
definition of the macro spy and then the
function was compiled and the macro
ceased to exist once I loaded spy again
when I loaded the change to definition
of that macro I have a new definition of
the macro which is not the same one as
the function was compiled with
so in order to get the behavior I want
in order to actually see the changed
effect of changing a macro definition I
have to reload not just the definition
of the macro but also the definition of
any code that uses the macro and that's
you know this problem is not unique to
closure any Lisp with macros has this
problem so this is a general problem but
it's something a little bit tricky to
understand you have to know how macro
expansion works and especially when
macro expansion happens in order to
correctly update your code so I try that
and I see that it works but I have this
potential problem that the definition of
a macro or some other piece of code
that's used in the construction of my
program might not be the same as the
version that it was compiled with and
again this happens because I'm changing
things interactively I'll give you an
even more tricky example this one unique
to closure I think suppose I have a
protocol and I have a protocol and in
another file I have a record that
implements that protocol and then in my
repple I create an instance of the
record and call the protocol method on
it so far so good then I decide you know
what I can do this a little better I'm
going to change something in that file
where the protocol is defined and reload
it and then I call the protocol function
and I get that now personally I think
some of the complaints about closure
error messages are a bit overblown but I
have to admit that one made me blink for
a bit
can't no implementation of method draw
of protocol drawing for class richting
but I mean it's there is a definition
for the method draw it's right there I
can see it in the file it's you know
rectangle implements drawing and drawing
has drawn over why doesn't it work well
this one's a little more complicated
when I load rectangle that doesn't
either when I first loaded this code
when I defined an instance of rectangle
by calling its constructor I'm actually
creating an instance of a Java class
records and protocols in the closure
runtime both compile into Java classes
and Java classes are immutable they
can't be changed the Java runtime does
not allow me to change the definition of
a class once it's been loaded so when I
reload some code I actually create new
classes that just happen to have the
same name as the classes that were
already there so by evaluating this
protocol definition again I've created a
new drawing class that looks just like
the drawing class I had before it would
be very hard to tell them apart unless
you looked at the actual IDs of the
objects these things would appear to be
the same they have exactly the same name
but the draw function is now been has
now been redefined to refer to this new
Java class so when I try to call the
protocol method I get an error because
it doesn't know what it's linked to it
doesn't know how draw relates to
rectangle even after I evaluate the
definition of rectangle again I still
can't change an immutable class I can't
replace it so my instance are now refers
to a class that is not connected to
anything else and I get the same error
again the only way out of this trap is
to actually construct a new instance of
the record after I've reloaded both the
protocol and the record so that's pretty
complicated and again this happens
because classes are immutable so turns
out immutable things aren't always that
easy to work with especially when you
want to change them
there's a related version of this
problem that happens when you pass
functions as values to other functions a
function that's being called gets
resolved as a var so you can change its
definition and you'll see the new
definition of the var but a function
passed as a value is just a value it's
immutable and so you might see that you
have an old version of your function
floating around in your program so this
is a very confusing situation where I
have something named in my source code
but I have a named instance of that
thing in the runtime and they're not
actually the same so this is very
difficult so I thought okay well what if
I could actually figure out how to solve
this for most situations and in order to
do that I need to be able to reload not
just the thing that changed but anything
that depends on it anything that might
have used it and this is kind of tricky
because closure doesn't really know
anything about the order in which things
are loaded the NS macro is just a macro
it expands out to a bunch of imperative
code that calls load and require and
refer and makes a bunch of changes to
these mutable pieces of the closure
runtime so there's not an easy way to
just sort of say okay I change this
thing therefore that thing over there
also needs to be reloaded but I could
cheat a bit so again in lazy test
originally and then later in tools
namespace I decided okay let's pretend
that NS is actually declarative let's
pretend that it's just a piece of data
fortunately this is Lisp so that's
really easy to do I can just read all of
the source files and then look for a
list starting with the symbol NS and
then parse the contents out of that and
this is some of the code I wrote to do
that it's quite a bit more complicated
than I would like mostly because the NS
macro is very
acts in how you use it there are lots of
different ways you can write the syntax
lots of different kinds of combinations
of forms you can put inside it so I had
to write a lot of code to deal with all
those different cases I probably still
don't have all of them but I think most
of the common cases are covered I also
have to make a bunch of assumptions in
order to simplify the job of reloading
code the first is the biggest one I have
to assume that there's one file
corresponding exactly to one namespace
now there's nothing about closure the
language that says this has to be true a
namespace can be split over several
files in fact closure core is but most
of the time most library and application
code does follow this constraint that
there's one file for each namespace and
only one so I can make that assumption
another assumption I make is that there
are no circular dependencies between
functions in different namespaces again
closure itself does not enforce this but
in order to build a set of relationships
of namespaces it's much easier if I can
just say there are no cycles in that
graph so I'll make that assumption as
well finally I have to assume that the
NS macro appearing at the top of every
file is actually complete I can't have
any loading or requiring or other
changes to the structure of the
namespace happening outside of the NS
macro so things that might do
conditional loading or loading different
source files none of that's going to
work if I want to rely on the validity
of the NS macro I also have to assume
that the NS macro is complete even
though theoretically a function could be
called by its fully qualified name even
when it doesn't appear in the namespace
declaration that means there's a another
dependency from one namespace to another
that the NS macro doesn't account for
sorry to say okay just avoid that
everything that you use in a namespace
has to be required in a namespace so
again closure the language does not
enforce or require
any of these constraints but they are
true maybe 90% of the time and they make
the problem much easier to model so
given those assumptions tools namespace
can look at all the source files in a
directory or on the class path read each
one of them find the NS declaration
without evaluating it just find the
dependencies and build a graph of
relationships actually figure out how
all the namespaces relate to each other
once we have this graph we can then look
at the source files again and see which
ones changed so if one file got changed
say we deleted something we changed a
macro oops
we changed a macro we changed the
definition we made some edits to the
file we can call this function refresh
and it will reload the file
corresponding to the code that changed
and any other files namespaces that
depend on that file in the correct order
and this is not perfect it can break in
some cases but it works pretty well it
will fix the problem of lost definitions
renamed functions deleted names syntax
errors and so forth it helps us catch
these kinds of errors faster without
having to restart the process or run a
separate process somewhere so it works
pretty well it is designed to help bring
the source code on disk or in the editor
in sync with the definitions in the
state of the language runtime so that
then namespaces and VARs in the runtime
match what I'm looking at in the files
and it does a reasonably good job of
that it's not perfect in particular
since we added conditional read to
closure it's now broken that assumption
that there's one file per namespace so
I'm still trying to deal with that but
it also doesn't help me with another
problem which is that the language can
produce state out of the definitions
that I've given it so tools namespace
doesn't know anything about this
date of the application so even now I
can get into a situation where I've
written some code and I've worked with
it at the repple I've created some state
in my running application then I change
that code to do something else but I
haven't changed the state in the
application I have old state and in fact
it's possible maybe a little tricky but
it's definitely possible to get yourself
into a situation where the state of your
program could not have been reached by
the definitions that you currently have
in your source this is a pretty subtle
problem but it does happen it's even
worse if you have stateful resources
external resources in the operating
system attached to the state in your
program just for one example if I have a
web server running it's bound to some
socket and then I reload that code I
actually recreate that state again but
it tries to bind to the same socket and
I get an error because it can't because
the old instance is already bound to it
but I can't actually fix it because the
old instance was defined with the same
name as the new instance so I can't call
it and now I can't get an access to it
so I can't fix it all I have to do is
restart the repple again sorry so in
order to reload code safely dealing with
application state I realized I needed a
way to manage the application state at
the same time I needed a way to cleanly
teardown all the state the application
had created before I reloaded the code
and then brought it all back up again
and that was the library called
component so the way component works if
you haven't seen it before I said take
each stateful resource each thing that
your program needs to manage wrap it in
a record that record implements a
protocol called lifecycle and the
lifecycle methods tell the program how
to initialize that resource maybe
acquire some external resource like a
socket initialize some state even
starting a process
running in another thread somewhere then
there's a corresponding method stop that
will shut the process down release the
resource clear out the state and so on
basically do the opposite so this is
basically a pattern for managing all the
stateful resources in my program and I
compose a bunch of these components
together into a map called a system and
the system gives names to the instances
of each component in the system so now I
have names to refer to all of these
things and the components can declare
that they depend on other components by
name and that turned out to be really
important having the dependencies
declared by name rather than by type or
by some kind of concrete reference gave
a lot of flexibility but once I have
this collection of components and
they've all declared the names of their
dependencies I can build the same kind
of dependency graph it's actually the
same code that tools namespace uses for
its dependency graph except now I have a
graph of the dependencies of the runtime
initialization processes for each
stateful part of my application so I can
call the component start function on the
system as a whole and it will start all
the components in the correct order and
pass each of them their dependencies
along the way then I can call stop and
it will stop all of components in the
opposite order when I combine these two
things together tools namespace and
component I design these to work
together and I made a template called
reloaded that has a bunch of helper
functions in a dev namespace this is a
namespace that I only load at the repple
I only use it for interactive
development and there I have a var where
I can refer to the current system I'm
working on I have some helper functions
to start and stop it but the important
part is this function reset reset gives
me a single step thing that I can run at
the ripple that will first stop
the existing instance of the system then
reload any code that might have changed
using tools namespace which is now safe
to do because I don't have any running
State and then create a new instance of
the system using the new code and start
it up again now you can still get into
trouble with this you can certainly get
errors in your component start functions
that lead to losing access to your
system and having the same socket
binding kind of problem but once you've
developed them and sort of established
the structure of your application this
works very well it's very fast you can
quickly bring the whole system up tear
it down start it up again without having
to restart the ripple so it's very
useful for interactive development and I
always have a reference in the repple to
the system I'm working on I can inspect
it
I can call functions on it I can do
whatever I want now I discovered after
releasing this that one of the
challenges of explaining how this worked
was the idea that the system itself is
actually ephemeral outside of
development I really don't need it much
all I use it for is to start the system
up so in production I might have a main
or entry method that creates an instance
of the system uses it to start all the
components in the correct order and then
let's go of it the components themselves
are actually running processes like a
web server or an input loop or some kind
of entry point to the system and the
reason I did all this was to get away
from a pattern that had I had
encountered in my own code and in lots
of other closure applications I worked
with of defining functions that depended
on state that was in global VARs and
this is very convenient it's very easy
to work with at the repple so lots of
tutorials and small examples will almost
always be written this way it's very
straightforward but the downside is the
function definitions are now coupled to
that particular var that holds the state
or the resource that they depend on so
effectively I've said by doing this
these functions foo and bar can only
ever be used with that one global state
resource it's a single team they can
never be used with any other resource
I've limited the amount of reuse I can
get out of the code now by contrast the
component has a little more ceremony to
set up but it allows me to define the
functions in terms of the components
they use so they can take the component
as an argument and then pull the state
out of it
so this decouples the state of a
resource or some stateful process from
the functions that are actually going to
use it the downside of course is that I
have a little more typing to do I
actually have to D structure these
components I have to pull things out of
them and if I want to get at them at the
repple I have to pull them out of the
system object it's a little more work a
little more typing for my point of view
it's totally worthwhile so a common
response I get when I demonstrate this
is well why would I ever have more than
one database to which my answer is why
would you ever not you know I've I've
worked on a lot of large systems
enclosure and I've seen applications
grow and change over time and in that
experience any time I think there's only
ever going to be one of something it's
guaranteed that's going to come back to
bite me so there's always going to be
new behavior new requirements there's
very rarely just one of anything so I
often end up reusing different instances
of the same component within a single
application maybe giving the different
configuration or associating them in
with dependencies on other components
because components themselves are in
stanchion create many of them I get an
opportunity to reuse them I can't do
that with namespaces and VARs so another
useful feature given I said that these
things are named the names of the
components are not tied to the component
instances themselves they are given in
the system map the scope of that system
map determines the names of the
components which means they can have
different names in different places I
can say this component needs or depends
on something called database and it's
gonna call it database in its functions
and methods and whatever but the actual
global name for that thing is user DB so
potentially I can get reuse out of the
same component just by associating it
with different dependencies in the
system it's a little bit complicated to
think about maybe a little bit of work
to set up the first time but it's very
flexible the final feature that I only
discovered after I'd written this
library and started using it for a while
was just a convenient thing that fell
out of the fact that I used records and
maps for these things so systems and
components are both represented as
records and records in closure are maps
so anything I can do with a map I can do
with a component or a system this ends
up being really convenient for testing
and development all I have to do is a so
sword isso some you know new components
or some different components into my
system and then start it up and I have a
modified version of that system that I
might use for many different workflows
as I've done developing it turns out I
can even use this in systems that are
distributed so I have applications that
consists of many small services each of
which is its own distinct system running
in production on different machines but
in development I might want to run them
all in the same process I don't want to
startup 6jv ends at once so I can just
merge them together they're just Maps I
can take two instances of systems merge
them together and then start them all
together and use them for development
this works as long as I'm careful about
naming I just use the same names for
components that are shared across
systems and I just have to make sure I
use unique names
for the components that are different
this is very easy and it works very well
now in theory because components are
Maps records or map systems or maps you
can nest one system inside another and
originally I thought that might be a
useful feature so I allowed it it turns
out that leads to some very confusing
results when you try to start and stop
your systems so I've basically told
people now don't try to do that you will
get very confused about when and how
things are getting started so through
all of this I've been learning about how
the closure runtime works how
applications work how to deal with state
I don't think I've solved it I don't
think this is the be-all and end-all of
closure programming but it's worked
quite well for me and a lot of other
people for a few years so I'm pretty
happy with it but the main point the
thing that this made me realize is that
the source code is not the same as the
program this is the the realization
about working that you get working with
an interactive development language like
closure your program is not just the
code that you see in your editor it's
actually something that is created it's
brought to life by evaluating the source
code and then it has a life of its own
your program creates state of its own it
might do things that create things that
you can't even see so the reason the
repple is great is because we actually
get access to this world we can look at
the running program we can ask it
questions we can change things we can
poke at it but we do have to remember
that the thing we're interacting with in
the repple is not the same as the source
code that we're typing in our editor the
things we interact with in fact might
not be visible anywhere we have to
imagine them so if you're interested in
learning more about deep space 1 and how
it used Lisp there are some great
resources by one of the engineers who
worked on that program Ron Garrett
he wrote an essay about it and later did
a talk which you can find video of
online unfortunately it's not quite a
happy ending although the mission was
successful in fact they even won an
award for software development at NASA
that ended up being the last time that
Lisp was used on a NASA mission although
we did hear this morning that Boeing is
using it so maybe in the future we'll
have closure in space again that would
be that would be a lot of fun not so I
highly recommend this talk if you're
interested it's a great talk about
designing large systems and also working
in a large organization until then happy
rippling and watch out for some of those
perils</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>