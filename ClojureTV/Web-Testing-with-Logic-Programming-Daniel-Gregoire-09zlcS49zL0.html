<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Web Testing with Logic Programming - Daniel Gregoire | Coder Coacher - Coaching Coders</title><meta content="Web Testing with Logic Programming - Daniel Gregoire - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Web Testing with Logic Programming - Daniel Gregoire</b></h2><h5 class="post__date">2013-02-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/09zlcS49zL0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay no it's the second to last talk and
it's the last day of the cons here so
lunch is settling in to keep you engaged
before I get started I don't know why
more folks don't start with the thank
yous first I want to thank my wife and
my children for letting me stay up past
my bedtime to get things like this done
and also the National area closure user
group for fielding the first version of
this talk was a third group of folks i
want to thank and it's a little more
relevant to the talk here and we know
the community is full of them and that
is paradigm junkies another word junkie
is a negative connotation in general but
you know closure itself as we know has
quite the eclectic background pulling
from rickys amazon bookshelf and michael
focuses and you know pulling from things
to do and some things not to do from of
the languages and we've managed to come
up with a pretty practical platform
right i think that's part of the reason
we're all here we enjoy a paradigm
shifts we enjoy learning brand-new
things that also get things done for
this particular talk through a couple of
paradigm junkies we want to thank in
particular and that's these guys as we
know yesterday dan and we'll humbled us
with coins twines thrones type inference
errs from any cameron and david nolan
and community has ported that to closure
only thing you should infer from these
photos is that dan and will you need
bigger pictures online that i can pull
from I looked all I could for both you
but didn't happen so logic programming
we've seen a couple of talks yesterday
they said Dan it will give us a deep
dive in earlier today we had a good talk
on some of the high-level points in the
history behind different parts of logic
programming I want to establish a common
vocabulary in a common language and
really just center on the parts of core
logic that i use for web testing so if
you go to the core logic wit you'll see
an example much like this where we're
putting on some facts and relationships
and querying on it and i've tweaked it a
little bit so let's walk through this
piece by piece so they're all on the
same page for how core logic works so
when we first come to corelogic it's
somewhat of a black box and it kind of
should be even after we know how it
works so it's more important than ever
to keep in mind what we're responsible
for in our logic program and what the
engine is supposed to do for us let's
step through those our first job is to
create a language that defines how we're
going to relate things by default core
logic as a few relations built in for
lists another primitive values but how
are we going to talk about the
relationships in our application
domain so we start off with doing that
and we have these deaf Ralph forms that
provide for us kind of simple named
relationships we're going to talk about
men women fund people and people who
like people once we have that vocabulary
in place we can establish the actual
relationships that we're going to be
dealing with and so in this case we're
going to hard-code some values here that
we have some men women Mary and Lucy are
both fun nobody else's and Bob likes
Mary John likes Martha and Ricky likes
Lucy once we have both of vocabulary for
defining relationships and the actual
relationships to work with the data we
need to do something with that and
that's where the really interesting part
of logic programming comes in and that
is to establish expectations and I use
the word expectations it's kind of our
first keikyu over to kind of a testing
vocabulary right making assertions
adding constraints so at the bottom here
this run form is our query we've seen
this to the other examples that dan and
will gave I'm gonna pull it up to the
middle so folks in the back and see it
better so this is the really important
part I'm just walk through this piece by
piece we start with the run form now run
is our entry point into logic world
outside of which we get to be enclosure
inside of which we play it by core
logics rules we have a star on the end
tells the logic engine to give us every
possible answer every possible scenario
that makes our assertions true next in
line is the queue and this is kind of a
convention for having our escape hatch
this is our exit point from the logic
world that ever happens to get bound to
queue which is a fresh logic variable it
has no particular value at the beginning
whatever we happen to unify with Q or
buy into Q in the process of our program
is the final return value of the whole
run form that's how I get real values
out of out of logic world back into
closure rule so going next in line here
we're going to some nicely named fresh
logic variables in this case we don't
need to have an extra one but it's nice
to have one that makes sense for the
domain we're testing so we're going to
create a new fresh variable person then
we're going to ask things about that
person so first there's two assertions I
want to make is this person is the
person fun and is the person liked by
Ricky and because these phrases are side
by side and other control structures
these are conjunctive such there's an
and relationship both must be true for
the whole run to succeed finally if
those two things are going to hold we
can take the person that was found by
that logic when I'm binded to Q and
again that becomes the return value of
the entire
form back to our regular functional
programming space and the only person
who satisfies all those constraints in
this way is Lucy and will notice here
important is that it's actually in a
sequence because we have zero one or
more than one answers so Lucy is the
single answer in this case so we've all
done all that work we had to set up
relationships we had to actually define
the language for them instantiate them
and now we you know we had to run a
query over them what is the logic engine
going to give us for free first and most
simply and there's a lot more does than
this but these are the things i want to
focus on for our testing purposes i
should be able to verify facts that
we've encoded in our and our little mini
database of people so here we have is
lucy fun and cue as we said is the
return value but gets bound to nothing
in this case so it returns to get the
output of a fresh logic variable over
underscore dot numbers we saw that
yesterday with the clines just pages and
pages of underscore number so here we
have yes Lucy is fun but no Martha
Martha's no fun so verification of facts
and secondly and possibly more
interesting is that it should be able to
follow implications and sometimes people
call this making you making inferences
that word inference is kind of loaded
but it she'll to follow the implications
of the relationships that we established
in our application so in this case it
should be able to work through the fact
that the same person is both fun and
like by Ricki so let's take a grossly
oversimplified you know view of this we
know that none of these guys are fun or
like by ricky's we're going to start
with a right answer and work our way
through under the covers corelogic keeps
no wait what's called a substitution map
that associates the fresh variables
along the way with actual values and
sees if everything works out in the end
we're going to do it highly
simplistically by replacing the word
person with the person we're trying so
Lucy is the candidate is she fun yes she
is is she liked by Ricky yes she is and
so finally since she passed boot through
both those phases q having been bound to
nothing else as part of this run is
still fresh that's still available to be
bound to unified with and so Lucy comes
out as the only answer to this puzzle so
given all those behaviors given all that
kind of characteristics of logic
programming just a priori what would
incline is to think that logic
programming is even suited for testing
why would it make an interesting part of
our testing tool kit I think there are a
few areas that come to mind at least for
me so the first thing we said about the
logic engine was its responsibility is
to
do some verification of facts in our
application domain and we use the word
verify once part of what we're doing
with our testing is we're trying to
verify that values or a certain a
certain value in a certain context and
the question we ran as result shows are
we already doing some modicum of testing
by having a relational paradigm as part
of our coding so simple examples to look
at cons I know its closure where's the
cons I'm sorry so state cons the cons a
on the BCD I get a BCD nothing
surprising there how do we transform
this from a regular function to a
relational function to a goal well
Daniel told us yesterday there's two
steps first step add an o to the end all
right that's the most important step as
Craig and Dara said if you use a logic
program you should your polling should
alias the logic portion as L so you can
say alcanzo el texto el member oh it's
not entirely culturally sensitive but
it'll be good for good reading so I here
we have konso on two things we've added
the oh so it's just a convention so we
can keep saying looking between regular
functions and relational functions but
we've also attacked on one extra
parameter here and as mention yesterday
what cons would return as output we're
going to tack on is the last argument of
this relation and the whole idea is that
we're talking about a relationship
between two inputs and an output for the
idea of Khan Singh so here we have built
in that if i run this so we have q which
is the fresh variable Khan Singh a on to
BCD q should be bound to the only
possible answer to this and we get back
a list of answers with a single answer
the list ABCD so if we hard code that we
could get verification of this behavior
is true so we're already doing so if
we're testing cons ourselves like we're
writing our own Lisbon testing our own
cons we would check that this operation
gives that output so there's no meta
question as want us to keep in mind as
we work through this is what you know if
we're already doing some testing then
what's that next level of testing we're
gonna think about and get into going
beyond that there's some kind of
relatively smaller wins that we get as
we've seen from all the programs here
they're both in this example I'm from
Dan and we'll logic for term as a
declarative syntax and that gives us a
win we're trying to encode complex
conditions and complex flows that we
have a declarative syntax at hand to
kind of work through those
more cleanly perhaps a subtler point and
when we have our own applications and
we're doing high level testing so this
is where the focus of this talk is web
testing which is high level we're
testing a lot of different conditions at
once I might step through my application
three steps and I want to stop and I
want to see you know five different
conditions are true ten different
conditions are true and if we're not and
by default when we encode those
ourselves with ifs else's cons we're
adding kind of a sequential pneus to our
testing we work through each one in part
and we kind of map out the branches
ourselves but as was mentioned before
parts of mini Cameron is that is that
better I kind of like that chem parts of
our program be ordered arbitrarily and
for certain things they can't be before
certain simple things they can be so for
our regional example it shouldn't matter
whether or not you know we checked that
she was fun Lucy was fun first or that
Ricky liked her or even if we just bound
to fresh variables together made them
associated in that substitutions map it
shouldn't matter cuz by the end all the
associations will come to make you know
the right answer and then finally and
this is kind of a more but this was the
point that kind of spans beyond testing
I'm is testing exploration so at least
for myself when working with separate QA
teams one of the things that QA guys do
a lot better than I do is taking my
application and finding different ways
to get to the same answer taking
different navigational pants though an
application or exploring different
workflows which often exposes
brittleness and edge cases that I didn't
consider there's no reason why our
testing tools get also kind of open the
door to live a more exploration
especially what we're offering our tests
and so I just want to take the example
we look down here we're looking at a
query that's really a combination of a
statement and a question and the
statement is about Ricky and who he
likes and the question is about this fun
person who is also liked by Ricky and
what would it take for us to transform
this program from Moqaddas half
statement half question to a full
opening an open-ended question well we
just replaced the hard coded value with
one extra fresh variable and we're done
nothing else structurally changes so
here we have person one in person to its
s'posed a person and we find that lo and
behold Lucy isn't the only fun person
like by somebody else was also Bob and
Mary so this is a simple example of
connection transforming hard-coded
values statements and making them
questions we're going to find as we kind
of explore using logic programs for
things that maybe they weren't
originally intended for as we dial the
knob between making statements and
asking questions a lot of power
comes out of that so um this goes beyond
testing though I don't need just use
this for testing on this is showing us
we had a custom domain we defined our
own vocabulary for relationships and now
we have this kind of custom query
language for talking about fun people
and people who like people and so I
don't think this is a great revelation
for those who are to do a lot of logic
programming but if you've come to
corelogic and you say well why would I
even bother or you've learned and say
okay under the zebra puzzle i can do
Sudoku maybe from really good but what i
use this for and kind of my more maybe
enterprise or a genuinely fully
practical application and that is that
core logic among other things is a query
platform so under the covers we already
have a query language right in terms of
the relations that are part of core
logic itself but we can also build our
own custom query languages using core
logic as a platform for that given the
semantics of core logic and one of the
covers of course mini Cameron this is
all it takes to transform what would
otherwise seem an unrelated domain into
a core logic searchable space and
there's an example of this on the core
logic wiki of using the atomic and
bringing datums into the ecosystem of a
logic program so it's not that hard once
you've read people's dissertations and
listen to David Nolan stalks multiple
times even then it's look on a magic
right all right so we have these
characteristics that so a Priora we
haven't any coding yet we kind of think
this is going to work out maybe there's
some things are going to contribute to
the testing story and that kind of core
logic as a as a query platform seems
pretty interesting so move forward but
what do we get we talked about paradigm
junkies at the beginning where is the
paradigm shift where's that really big
that big win and I'm going to argue that
perhaps with using logic programming in
our tests we're going to get to a higher
and possibly correct in certain
circumstances level of abstraction and
our tests and we're going to be called a
test more and I don't mean that test in
terms of number of test cases but
actually the nature of tests and what we
choose to test so that's logic
programming just the crust of mini
cannon for logic but that's all we're
going to use for this talk so web
testing what do I mean my web testing
for this particular time in case it
wasn't clear and buy more functional
testing I was supposed to load testing
I'm a system level high level behavioral
tests that touch the whole stack as
opposed to the little unit tests or
integration tests and the final
criterion so that i can use the
libraries that I want to use is that it
should behave like real users when run
as much as possible and with these
criteria in place others
a one open source tool that kind of
treats this end to end and that is
selenium webdriver so for those who
don't know selenium webdriver is a suite
of tools used for automating
programmatically automating graphical
browsers so firefox chrome IE opera
safari and as I say the suite of tools
there's things like a Firefox add-on for
authoring tests there's a distributed
version for running your tests across
multiple computers with different
configurations our focus here is the
simple client API is that it exposes
especially the Java one and wrapping the
Java is a library called clj webdriver
which consists rly of two API is kind of
a low-level core API that's close to the
Java metal if you will and then a higher
level taxi webdriver taxi sorry API data
is a high level more terse API for
getting the same things done and so the
basis of this talk is just taking this
that same set of functions for
manipulating a browser that we'll use
for high level testing in the first
place and combining that with the
semantics of core logic bringing it into
the logical realm making our taking some
of those regular functions and adding
ohs everywhere and turning them into
logical logic functions or relations or
goals so we started with this program
and it's somewhat clear how it takes
these values and it might put it into a
search tree of some kind and traverse
that we don't really care that's the
whole point what was the corollary for
web testing well it's the web page it's
all that we have right so how is this
going to match up with our we said we
had certain responsibilities as authors
of logic programs and there are certain
things the engine gave us so how's it
going to pair up with our other program
and the web page so first what's that
language we're talking about the
relationships between values what are
the value is going to be elements in the
page browsers browsers specifications
how to relate those well you get that
for free right I wrote those so that's
the language it's a work in progress of
course and contributions are welcomed
with the sort of gives us a base
vocabulary for talking about a web page
in a relational manner next we actually
have to have data right no good but
we've already done that work right we're
testing at this point we have an
application it's full of data write the
web page is chock-full of simple things
like named attributes and then the
nature of the Dom itself is available to
us we have hierarchies and relationships
that are encoded and available to us
programmatically from selenium in its ap
is so there's a host of information
there that we can pull from through our
testing right and finally establishing
expectations so what does it look like
to write a logic program
uses web web api is like clj webdriver
all the start with a couple ones
straight from CLG webdriver I hope these
just make natural intuitive sense if I
ask for the attribute of an element say
the class attribute i get the value of
that if i ask for its tag to get the tag
text text size width and height enabled
is it enabled and then child
relationships you know does this is this
a child of the second element so we said
before what do we do first step is from
transforming this from a regular
function to a relational function what's
the first step add the O's okay and
you're done no we have to add the O's
and then we also tack in the return
value of the particular function as the
last parameter so now we're talking
about now what is the relationship for a
particular element its class attribute
and the value of that class attribute
and going down the list so let's move on
from this okay that's our part we're
writing what's going to look like when
we actually put this to use with the
engine so let's verify a fact about the
page we looked at the github login page
before the homepage of github when
you're not logged in it better have a
login link right or otherwise you're not
getting in so let's make sure that has a
lot has an anchor tag that points to
that particular URL so start with run
have our queue escape hatch set up a
fresh variable l that's going to be our
element we're talking about does the
element have an a tag okay if it does
move on and then is the href attribute
of that anchor tag github com so this is
kind of a simple way to verify is that
thing on the page and lo and behold it
went and found it and we have the that
logic variable output for Q that indeed
this is on the page so we have an a tag
it has that particular href if I were to
change the a tag and ask for a
blockquote with that we're not going to
find a block but with that and we get
the empty list for there are no answers
to this particular query alright so that
was a verification simple enough I could
have faked that out right and it's not
live coding how about following those
implications so let's take a slightly
more complex example we're going to
start here again with Q they have two
fresh variables I'm interested in
finding a child element of another
element on the page so we have el for
the child element and parent l for the
parent so the parent is going to have an
ID of header so we're talking bout some
header div on the top of the page on
github which I in the next the child
element itself will have an attribute a
class attribute of top now so
some kind of menu perhaps on the top of
the page and then I want to verify is
that element in fact a child of its
parent and at the end I'm only
interested in seeing what that child
element actually is so bind that to Q
and we'll get the answer and I think it
deserves a stop here and look what we've
done we've now managed to take a whole
domain that value see in the bottom
commented there is a value from clj
webdriver representing an element on the
page has a ul tank that's the top list
of sign up for you for free explore
everything else the top of github and we
can take this value and pipe it right
back into CLG webdriver we could click
it we could flash it to see if it's
actually there you know it's we've we've
went from closure into the logic world
we did things according to its terms we
got back real values so this is
extending core logic and it went in you
know it's not it's not rocket science so
let's test an actual app or my keynote
am Prince is the next stage of web
development so we have a menu and we
have an element with an idea of foo
inside event and I want to test the
behavior that I come to this page and i
click on foo and lights up and none of
the covers are doing that by adding a
class of active to that particular
element so a very simple behavior hoping
keep it in our minds as we go through
the next code examples we're going to
test this twice we're going to do one's
just kind of a straightforward clj
webdriver closure tools type of approach
and then we'll try see what happens if
we use in logic programming and see what
will possible effects that we give so
we're going to start by just planning
the element on the page CLG webdriver
offers us this nice way to just pass in
CSS queries and find things so we're
looking for the first Li under that
particular UL I grabbed that guy I'm
going to plot as attribute and
everything was successful what should
the value of the class attribute be
active okay so we're gonna test for that
using the is macro from closure test and
retest is that attribute in fact the
string active okay we kind of cheated
the right because if I were just a test
that i clicked the first and only the
first ten active there's never a
situation in a web app one like you
click on something and multiple events
fire by accident or like lingering event
handlers or objects emit never happens
in web development so now we needed to
be a little more little more robust here
so let's go and look at all the elements
all the list items and to do that we're
going to have to take go from element 2
elements and deal with a collection and
so will there's multiple ways to skin
this closure collection cat but we're
going to do with reduce and we're just
gonna accept this the right way at this
point so if I were to work
that list of elements checking each one
do you have the right class and if you
do I'm going to take your ID and toss it
in a list tosin and a vector and at the
end at the end I'll get back you know
the sequence of all the elements that
had a class of active and so if this
were successful according to our current
paradigm we'd get back a sequence with a
single item the string foo for the
element that had the class active and so
we can test that like this pretty
straightforward maybe I want to test a
multi-select behavior i can click
multiple things and they're all lit up
and maybe we can make a simpler
collection handling here by using filter
for example so I'll filter on elements
that have the class attribute of active
I can we just count them i'm okay with
in so that was a pretty straightforward
you know the only couple of functions
from the seal jeff ever api and some
standard closure a collection handling
and testing what's it look like we're
using logic programming let's just let's
kind of explore well first a pretty
straight translation from the functional
approach to the logic programming
approach here so grab that first element
we're going to unify them with q up
front okay and then we'll just verify
that everything we expect it's true so
does that element have a class attribute
that is active now this comes back as a
successful run if q returns to the
element that we're interested in then we
know if we've won you know that this has
been verified so the discover the first
example we've already done some
verification where is the testing going
to come in where's the is macro but
we're not quite satisfied like before
rocket test just the first element on
test all the elements but Before we jump
into trying to think about closure
collection handling here as they were we
trying to encode with this particular
line we're trying to encode them looking
for an element that happens to be an
ally and it's under this UL so there's a
relationship there that here I've
captured as a CSS query it's inside a
string perhaps a more proper place would
be as a constraint in my logic program
so this Li thing should be just an
element that has a particular tag it
happens to live under this other element
the UL so all of a sudden I now have
because i'm using run star and asking
for all the answers it's going to work
through all those elements so i get the
collection handling for free if you will
do to the semantics of the logic run so
if i take this guy and then we want to
test that say foo was the only one click
i'll just add one more constraint that
indeed the ID of the element we're
talking about is foo but as we said
before we're still verifying the
behavior but where is the actual test
where is the the closure dot test is
macro
there's a couple ways we gets again this
rye beach we could instead of having
active and Fuu hard-coded here we could
add more fresh variables and get them
kind of pulled out of the run and look
at those values like we did before you
is it or is it a list of a single foo ID
is it a said three actives but let's
keep it hard coded so we said before
we're going to explore the difference
between it you're making statements and
asking open-ended questions here we're
make a big statement here's all the
things that this program should have h
be true about and we're going to test to
see if this is true so if this is true
we said we're going to get back one
value but that Q should be one element
so we could test that the run returns a
single item in the collection of answers
but that's really not we're trying to
test we're not trying to test that we
got back a data structure with a single
element we're trying to test if this
logic run was deterministic if it had a
single answer to the query and so it's a
slightly different semantics and so we
can go ahead and make some helper macros
that rap is ending include the idea of
this is a deterministic relationship
that succeeds just one time so let's go
ahead look at that so if we add s which
is a macro available in web dev or logic
it says this run should succeed once and
only once and again it's the same as
testing if the collection is a single
item the ant the collection of answers
but the idea is we're testing for a
deterministic relationship and it's once
in one success maybe I'm testing the
multi-select behavior i mentioned before
and we can click multiple things and
have them all active at the same time I
can take out the ideas foo constraint
and say okay it should succeed twice and
only twice still deterministic but
multiple successes right maybe I want to
have some non determinism in my app
maybe I'm insane and i want to put
randomness you click on an element and
things just start lighting up everywhere
i don't care if it's you know how many
it is it just just succeed more than
once because I've randomized the outputs
this is non-deterministic behavior or
maybe I want to encode explicit failure
the s and the you by the way are
inspired from the reason schemer and
hash s and hash you as being success and
failure respectively um noticing these
last three slides I'm going to step back
three slides that the body of my logic
program doesn't change right I have the
same semantics here but I can focus on
what is the nature of the success of
this logic run
and at some somewhat of a new ones point
but it's you know I did I think it's a
different way to look at it and its
interests in the beginning encapsulate
all the relationships that were
interested in in the logic program in
the relational paradigm are already
working in and then focus on the success
is this enough no it's not enough we
have to eventually pull out the actual
values we're testing sometimes and make
sure that for example foo is the only
one but once we're thinking about this
in terms of the nature of the success of
the logic when we can work with it
differently I'm not thinking about doing
collection handling as much as okay this
should succeed and the answer should be
exactly foo or maybe there's multiple
answers and I click on multiple things
and so at least in the answers there
should be the items foo and bar that
were clicked or maybe I can pass in a
random predicate that takes in the
answer as the first argument and returns
a true or true thiruvalla c value and
that dictates the nature of success so I
the combination of things here the focus
is we're at a higher level of
abstraction when we start putting all of
our eggs in the logic program or as many
as we need to and then and then thinking
of core logic as more than just a tool
for solving the zebra puzzle but also is
really a platform for writing queries
focused on our own applications so is it
all fun and games no it's not this is
one of the few times you can actually
use keynotes built-in graphics it's
great so what are the risks and the
first ones a human factor that I think
is just worth mentioning pink elephant
in the room at least in my experience
most QA folk are not hardcore Linux
kernel hackers or working on the closure
compiler if you are I'm not talking
about you but this is doing a gulf
between our QA teams if they're separate
and developers and even wider gulf
between those and closure developers and
there's an abyss between those and doing
logic programming closer development
right there's a big gap there we're not
talking about this we're talking about
teams that arm you know companies that
keep developers as their QA and simply
switch up teams to test you to those
code or companies that have QA with
paired engineers so this is a human
problem a half problem but i think
mention the obvious here cover of dumb
magazine all right performance this is
the really interesting one right I this
is actually performed as the famous was
Alan Perlis quote
lists programmers know the value of
everything but the cost of nothing I
think we're chicky has a version of that
let's be honest there's performance
issues up front before we think through
the problem so when you're using clj
webdriver early any conscientious
closure API you get laziness by default
right if you ask for 2,000 elements off
the page you're not going to get them
unless you ask for all of them
explicitly get back a lazy seek of all
the elements that match your particular
query for example but we're using the
logic engine is going to search the page
for us if you don't give enough
information it's got to go find it right
so it has searched the whole Dom it's an
expensive operation to traverse all of
that especially in selenium webdriver so
we have to think about the generality of
our queries were passing in they don't
ask for every anchor tag if you don't
need every anchor tag we don't have any
more laziness and of course the page
science but it doesn't take a very big
page for this to get expensive in
selenium webdriver so what's the
solution to this particular problem how
can we you know not incur this cost of
searching this large space with possibly
expensive API calls well the solution
that I've added and is poor man's
constraints I say it's poor man's cause
I haven't read the papers that David is
now reading on constraints so this is a
way to constrain the logic engine to a
portion of the page before you ever
enter into your run form so we in
webdriver logic to dynamically rebind
how much of the page gets searched for a
particular run outside of the run I mean
this gives us you notice it gives
blinders to the engine only look at all
the divs or only the header or only the
content area or only the anchor tags and
then secondly kind of two layers of
control both queries that are top down
and queries that are child relationships
and if you use the library the tool
makes sense as to why they're both there
that's these guys so you'll see in early
examples on the readme for this for the
repo that these guys get used early
because oftentimes it's expensive to
search a large page for things or to let
the logic engine do the searching for
you the second side of that coin is I
kind of hinted to is that selenium
webdriver is a factor of the problem and
honestly it's a problem because there's
so much excellent work but into the
project but there are architectural
factors that make searching the whole
Dom via selenium webdriver an expensive
operation for those who don't know under
the covers selenium webdriver consists
of itself internally of a server and a
client in the server for chrome boots up
jetty and its controls the browser via a
driver and your client code that you
wrote in Java or the CLG webdriver under
the covers you think you're making
function calls or method calls
you're sitting HTTP requests to this
server for everything you do and this is
a obviously an expensive operation than
working on some kind of internal closure
data structure using regular functions I
mean because of this caching is also a
relatively small wind for selenium
webdriver in particular you can hold on
to a reference of the element you're
talking about dejection well Java object
but every time you ask for its attribute
or do something with it other call over
HTTP to that server so it's a win but
it's a small wind and I'm already doing
it in clj webdriver so to be clear
queries themselves are fast you know
it's it that the CSS queries you provide
or parsed quickly and you're finding one
thing is no big deal it's when you start
pulling in all the elements and
instantiating them as part of that query
that becomes a real issue so what's the
way to solve this well there's no way
except to get out of selenium webdriver
so I offer on a secondary namespace in
this project called raw and all it does
is take the page source from selenium it
says thank you and tosses it into in
life and now we have a regular sort of
closure maps with all the beauty and the
performance of that and the alive
selector syntax and there's a drastic I
mean unspeakable performance improvement
when you use this method so so such a
big difference I have to go back and
look as to why CLG webdriver has gotten
slower again Hugo Duncan thank you for
criterium I caught it a couple months
ago and it's been great but what do we
lose we lose the whole reason we started
with selenium webdriver which is it
gives us certain guarantees and if we
haven't thought through the problem this
might not be a parent but if you as a
tester or writing this test sequence and
you ask to click on an element and it's
there in the Dom but there's another div
that's come over it in time or it's
styled in a way that it's off the page
or those JavaScript eventing you then
you shouldn't be able to do then once we
get out of selenium webdriver and we're
looking at just the Dom structure we no
longer have those assurances that
selenium gives us so if all you need is
to verify the Dom maybe you don't even
need to be using selenium webdriver in
the first place but if you have to for
authentication purposes or whatever else
you can step out of it for a minute and
do things in closure so is this all we
can do as I mentioned before we're using
just a thin upper crust of core logic
and mini cameras there's almost no need
even see a condi up there I can even do
a nor yet right of course you can but
that's not included here so the first
thing is to think through how can we
fully leverage the mini camera and
feature set and by extension CoreLogic
there's a lot more there they can go in
and thinking about testing in the law
Arjun using our logic programs in
different ways we've explored just a few
of the features there I encourage
everyone to go read these things the
reason schemer william burroughs
dissertation I tried I couldn't finish
him and this daunting quotation from Jim
Dewey who said at strange loop that you
don't understand mini cannon until
you've implemented it yourself I hope
that's not true because I'm not going to
get there anytime soon but it's it's a
point well taken there's a lot of subtle
tea there it's not as simple as we might
even think just talking about it so
please go read it it's fun so in the
last thing i want to show and go to have
plenty of time here is if we take we
said before an interesting way to think
which i kind of consider using logic
programming for our tests is to kind of
encapsulate all the relational parts of
our testing all the information thats
related to each other in the logic
program and to test them the nature of
the success of that logic run but if we
do that and the whole thing fails what
part of that didn't pan out i had like
10 assertions which assertion was the
one that didn't didn't work for me and
so this might be a situation where this
is definitely situation or we need
better granular level reporting and i
think i have a couple of ideas where
this is going to go it's not there yet
but i think it's going to involve some
deeper diving intimate into mini cannon
itself into core logic but the last
thing i want to show so every talk on
core logic you know thank you Dan and
will has to have the part where the
program goes backwards and forwards why
so I realized this a couple weeks ago i
was like- and go backwards and forwards
and those to a certain extent right so
if you we asked to verify i found a
particular element night checked its
class attribute okay that was you know I
was going forwards and then I just gave
the attributes and I found an element
that satisfied that that was going
backwards but not quite backwards what
is the klein of web testing with logic
programming i had to find it so i have a
work in progress pre pre alpha but when
we do all arithmetic using closure
testing we do something like this five
does not equal four and we get this nice
output it does it failed and what you
gave it and what you were supposed to
have right and it actually evaluate a
minister's there's the five what on
earth would this look like for doing web
testing okay so you did something that
wasn't the right attribute maybe was
misspelled what do you get back from
that output and so I thought through and
thought maybe would it be great if
you're running a test on an application
you know your test run failed and i was
able to go okay i'm going to show you
what you had Dom wise and what you ought
to have had for it to pass so I give it
you had we're testing what you already
had how do i generate for you out of
logic constraints the Dom needed that
you needed to set the satisfy the
constraints you specified analogic run
so let's look at that this is the one
life coating burn all right this is what
you're encountering wasn't it there we
go so we're in a thing about this in
terms of closure data structures right
so let's create an element that looks
somewhat like what we'd see from bigger
please okay I did a test earlier people
said it was big enough all right let's
go here no worries let's see if we get
big enough yay nay more okie dokie house
ready for this sorry yay all right
there's not very much code I'll keep
that for later let's make this the size
of my screen here Oh
alright so let's define a tag that looks
like what we'd see if we're working with
in life it's a map form has a tag it has
some content and has adders and bergen
ignore the fact that addresses and not a
map right now it's okay
implementation-specific this is the this
is the client of web testing right so I
have that guy I can then do the things
we're doing all along so I'm going to
ask things about that data structure
getattribute oh and so I'll keep that
guy in there so we're going to verify
any things about him is his class active
and we should get back you can't see the
output that's good yes it is all right
if we were to take out some of these
values and ask questions about them so
let's keep class and let's ask what is
act and what is the value of that
particular attribute we're going to see
active okay that still works and if we
go the other way and we ask for don't
like it what is active well the class
attribute is active so if i were to then
go one step further and say okay take
this guy out I want you to find me the
answer for the purposes of everything
else I demonstrated here we'd go to the
webpage we'd find we let it search the
dom and find an element that had a class
attribute that was active but i'm saying
now we want to generate we're going to
create dom for you on the fly that's
what does that look like it kind of
looks like the data structure we
specified above i only gave you a couple
of the things to verify that the class
was active i gave you a default tag and
it's a short hop skip and a jump to go
from something like that to something
like that where you're working on
something you found a div you thought it
had the right thing here's what you're
needed and the dom on the right but
markup on the right was generated on the
fly using just the constraints in your
logic program so this is kind of where I
see different directions things going
thank you the Klein of web testing
anyway that's all I have thank you very
much
it looks like we have five minutes so
any questions excuse me yes yes simple
for me was I was simply wrapping the is
macro I'm sorry yes of course the
question was I introduced a couple of
Handy macros like s and s-plus and as as
etcetera that are macros and the
question was why weren't they functions
and the reason was that I was looking to
simply wrap the is macro and so I built
a macro to then you know delay the
evaluation things that get passed too is
so is as I said before that's right as
an S and it's friends add kind of an
extra level of testing that you had one
value that was between this range that
included these items so it's really just
to wrap closure test is the question any
other questions yes
sure so the wrong name space that i
mentioned actually works within live and
and live works with closure maps so with
closure maps sorry the question was can
this be extended to say JSON formatted
data or XML and the answer is yes that
you know we already have tools in the
closure community for transforming XML
into map structures and traverse over
them whether it's zippers or other kind
of declarative things that have been
built and so we can definitely take
those same semantics and I think we've
seen some work with maps and core logic
here with another presentation so yes
absolutely in the back
in the logic program itself you're
saying the question is can we the common
the common idiom of having him before
and after things happen around test
cases and test runs can we encode that
analogic program and I'll be honest that
I envision this part being the part
where you kind of done the actions you
plan to do in your stopping and that has
state snap sort of your application and
testing a complex condition but it's an
interesting it's an interesting thing to
consider and I think part of the work
that needs to be done with with the idea
is to build it out more into the large
and see what does it look like to
incorporate the random core logic test
run in your in your test suite and maybe
there's a place to include include
things like that to make an explicit
what's happening before and after a
particular logic run so that's a good
question definitely open for further
work any other questions great thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>