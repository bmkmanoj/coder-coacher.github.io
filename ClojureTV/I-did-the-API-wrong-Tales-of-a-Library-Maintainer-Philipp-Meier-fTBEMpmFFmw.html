<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>I did the API wrong - Tales of a Library Maintainer - Philipp Meier | Coder Coacher - Coaching Coders</title><meta content="I did the API wrong - Tales of a Library Maintainer - Philipp Meier - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>I did the API wrong - Tales of a Library Maintainer - Philipp Meier</b></h2><h5 class="post__date">2015-11-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fTBEMpmFFmw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome everybody I hope you enjoyed
lunch so I will be talking about some
not war stories but some tales about
maintaining a library which is mostly
the Liberator library which I created
and with the help of a lot of other
people I release it and it's I guess
used in the world so that's the
motivation for my talk actually yes I
told I'm the creator and maintain of
Liberator there are other people helping
me but most of the work is it's done by
me I release it to the public in 2009 I
wouldn't have expect anybody to use it
until now it's just 320 commits which
doesn't sound too much but you can
actually create quite some mess so the
problem is people are really using it
and suddenly you are responsible and
whoops changing stuff might break other
people's code so I'm not longer free to
do what I consider to be the best way to
do it when I change stuff users need to
keep up with the changes when I change
the IP I the users need to change their
quote maybe it's running into in
production and have a bug fix and at the
same time I changed the API and this
prevents people from using the bug fix
because they need to change the
implementation on production on a
Saturday evening or whatever so yeah
gives some headaches to the maintainer
and that's how it looks when people
chasing your API changes actually so
changing the API actually will break
other people's codes and backgrounds you
can see this Apple charging connector
which actually changed and then people
need to do some create some adapters to
be able to use the old stuff with the
new stuff and all this so and then in
the end I find myself like suffering
from bad early decisions because I
couldn't change the API anymore
so I got some pull requests and I got
some issues and as you can see this is
not too much compared to whatever
creasing or closure script but when you
like the single maintainer it's quite
some work that you need to to get done
and well it escalated quickly so why is
this actually bad why can't we simply
change the API so I already said people
are using it and you yeah you bring some
like back pressure to other people's
code but another thing to consider is
when you cannot change the interface
then you cannot provide the best access
to the features of your library and
users actually overlook features they
don't you they cannot like use all the
power of your library and eventually
they reinvent Finch features and
background you seeing like a egg
cracking device while you could simply
use like a sharp edge or the back of a
knife but if you don't know that you can
use knife to crack open an egg then
people are becoming very creative and
stimulating creativity in users well
while in general it might be a good idea
in some cases it isn't so it's
stimulating creativity is undesired and
then people are starting to create
workarounds it's very natural we all do
that so this all the time like we have
know whatever update and close your
corner update function recently we have
one so people are starting to write
update a lot of time or a function to
map over the values of of just a map of
function just about the values of a map
so what's the problem with the
workarounds so most of the time they are
undocumented so somewhere in some
utility namespace in your typical
project they are all the workarounds or
they're like on the spot of where you
need it and nobody understands of your
co-workers actually understands why is
it why it is done like that so it's
hidden knowledge
promotes kind of cargo cutting so you do
it that way because someone like a year
ago found out that it doesn't work in
any other way and eventually at some
point the workarounds will become
obsolete because the library updates and
ships with that feature or provides an
alternative and maybe better way to do
it and in the end it's a library
maintainer it increases the burden of
backward compatibility for every
workaround that uses use in the wild and
which is maybe promoted over Google
Groups or the slack chat so you need to
do it like that I must pay attention to
that when I change the library not only
what I have documented work but also
like the common workaround still work so
it increases my workload so what users
also doing it's like wrapping your
libraries so it's in a sense of I like
what the library can do but I don't like
the interface to it and sometimes it's
necessary when we want to make use of a
Java library for example it makes sense
to provide a closure interface which is
more like idiomatic closure code instead
of using this dot notation and all that
and we have lots of problems with that
because when the upstream library
changes and adds new features our epic
ode falls behind and maybe doesn't offer
like a nice closure interface to that
feature and you find yourself in a
situation where you have like code which
for some hard uses the nice closure of
wrapper functions and the other part
goes into the dirty details of Java
Interop so you might not want that and
actually the effect is that the work
wrapper code hides new features or maybe
hides existing features because nobody
implemented the wrapping for that
particular part of the library so then
people are something I call shoehorning
so in the background you see a Phillips
bit but as I learned by someone whose
name I will not reveal you can actually
use it to
holes in your walls well it's a kind of
like gentle violence against your eye
API but there's also square pegging I
don't know I remember this advertisement
for this about this boy who was very
successful so you see it works it can
put the round peg into the square hole
and I guess from your corner co-workers
you know that expression right after
being successfully abusing a library
because they know that you are going to
maintain this and then there's something
I I made up all those expressions so
don't try to Google that in the urban
dictionary or like that so they are also
something are called phantom box which
are box which actually well aren't bugs
for example the API encouraged the user
to make simple mistakes which are hard
to find and this is the case of
miscommunication so us library
maintainer fail to document the features
in the interface in a way that empowers
the user to actually use library in a
correct way and to use it in a fail-safe
way so for example I order five hundred
meters of cable and I get deliver at
five hundred feet of cable and a lot of
curses being exchanged over the Atlantic
Ocean we had that at the NASA I guess
and this is a typical case of
miscommunication where something in the
documentation went wrong and there's our
docstrings so I will show you a typical
example of a doc string in the wild
and then there's air ahem we had a very
nice talk earlier today I have yet to
see library including my own libraries
where I can say yes error-handling
is sufficiently and excessively
documented so that's I as the user of
the library know what kind of thing
happens in case of things go wrong so my
recommendation is to use a dedicated
error handling model for example
exceptions or special return values or
error State so we all saw that earlier
today whatever model you choose
documented the most easy model might be
to throw an exception some kind of like
fail early or yes some some ways to like
to fail early and document the case that
in every case when something goes wrong
you will have an exception that you need
to catch maybe you wrap it into
something like X info or users special
exception wrapper to make to enable the
users to catch exceptions raised from
somewhere in your library and the other
thing is please be consistent so if C
libraries which is for some cases throw
exceptions for the other case you have
to check a return value and maybe they
have even like a third way to do it in
the end ever handling is part of the
application interface so now comes like
the embarrassing part with actual code
examples it's kind I would say some like
a short-sighted interface design in the
world starting my quote and yeah we have
some guest appearance but other people's
code it's like fully anonymized due to
like legal issues so that's one case of
failures like I call like too many knobs
so when your application interface has
too many knobs people
are hesitating to use it and are being
scared of the like by the waste number
of choice so for example this is part of
the liberator documentation showing you
all the keywords you can specify for
callbacks so I had to make sure it
doesn't even fit on that screen so my
screen is a little little taller so it
makes the users have a hard time to find
out what to actually do
so which buttons must I press to make
this library work in a way that I wanted
to work on the other case Liberator has
not so many dock strings so one of the
key interfaces to the library is the
resource function and as you can see
well there's no duck string at all and
even the function signature is a little
bit of well not very suggestive
so just reading the like the interface
this is the the API on a code level you
can would not be able to make sense what
to put into this whatever key vs vector
or your argument and this leads to
something that's like that I called
before phantom box so I don't know how
many people have actually used Liberator
here so quite a few so who finds the
error
so don't be ashamed I run into that
every other day when I'm using
liberators no not self but quite a few
times so there's missing a question mark
after exists and that's why the
interface to this resource of the Deaf
resource function in the end is this
kind of like D structured map and you
can put in any keyword you like and if
it happens that you write exists without
a question mark instead of exists with a
question mark the definition is silently
ignored and now due to some unfortunate
decisions in the first place there's no
way to make this validate because it's
by design that you can put arbitrary
keyboard arguments into the resource
definition for your implementation code
to make use of them
so no way to validate that at least for
Liberator to change that to validate
except maybe adding some additional
function like or definition like you add
an option please validate the definition
and this routes out that you use custom
keywords the next problem I see a lot of
times regarding API is the case of in
composability so for example those legal
breaks compose very well when they
started to when they were invented I
guess somewhere in the 60s or 70s nobody
would imagine that like 40 or 50 years
later the same Lego bricks I have the
those old ones too would still match the
modern ones that's a good thing and then
we have this very attic map argument
slag with liberator
well they don't compose too well so for
example let's assume we're building some
kinds of database access layer and we
have function Lord entity and has like a
reasonable function signature you pass
in some kind of database analyst the
first argument and then like a arbitrary
string of options as as a map being D
structured and looks very fine and it
has lies like an
interface very suggestive keyword names
like whatever lazy loading or whatever
use eager fetching or throw in a an
error or automatically reconnect in case
of disconnection whatever and then we
see in our code that we are reese Pesa
fiying the same arguments all over the
time and of course we want to avoid
unnecessary duplication of code and we
define some default options looks fine
so far and now we try to apply that to
the load entity function and we find
ourselves trying like to apply the
values we have those default options and
we extend them for example with a query
definition and then we apply that to
load entity and well it doesn't work
because the last argument in the apply
function call is a map and when you
apply a map it will be like convert it
into a sequence and the sequence will be
not like a list like keyword value
keyword value but it will be a list of
vectors containing the keyword and the
value and another Waechter containing
another keyword and another value
actually can work around that but it
doesn't look too nice so you have apply
load entity whatever might be apply
conquered and then the merge value you
don't want to have you users do with
that so apply conquered apply function
you can use the threading operator to do
something like that but really I don't
know if that's very a very suggestive
interface for the user I don't think so
and then they are macros well macros are
nice and fine and one of the key
features of closure and Lisp in general
but they're kind of a trap it's a kind
of a trap door because once you're in
macro land you need to stay in macro and
so when you go on like the meta level of
programming you find yourself somewhere
there and it's no easy way to do like
return to the typical function
application you're not no longer like
expressing your function calls but
you're expressing like yeah you're your
code on a higher level and one of the
symptoms is that there's no macro reply
as far as I know and in closure core so
when you have a macro like every sauce
which is a very convenient macro you can
define the top level variable named foo
this also Liberator construct and you
can defeat and define all the callbacks
afterwards but in this case also we want
to maybe apply some defaults to all our
resources for example they exist only in
every other case on average there's not
even easy way to like apply those
defaults to your concrete macro or micro
macro calls so when you try that which I
guess every closure beginner has
experienced so apply the macro and all
the arguments I get a very nice
suggestive arrow arrow whooshes well
it's pretty good for closure exception
right you can take value of the macro
and even the macro name is as mentioned
this actually prevents reuse and
promotes code application or even worse
people doing all kind of magic stuff
wrapping macros with macros with macros
so in this case Liberator had to extend
the API and find a backward compatible
way to do it because we have all those
code running in the wild and they didn't
want to change this core API or this the
signature of this core macro in a way
that I people have to like do an upgrade
or major breaking upgrade so liberated
that's one thing it introduced an
optional map as the first argument so in
case the first argument with the DEF
resource call is or the in this case the
second argument the first
for deaf resources the name but the
second one if it's like a map in this
case defaults then all the other values
get merged into it and some my
suggestions better stay away from macros
so macros are pretty convenient when it
goes to like those definition macros you
see that was testing frameworks with
database access libraries that people
are providing those definition markers
but to be honest this doesn't buy you
too much because those definition
markers like these decompose into the
definition of a variable on the actual
thing that creates the value which is
bound to the variable you can do that
your own or maybe even write a macro
your own when you need it but always
provide a way a way to do without macros
so that's what they call above actually
like matter expands to plus minus some
details so as you can see we have a
simple function invocation the resource
function and when we define that we can
land up where we will land when you do
there def resource call and actually we
can drop the functionality to handle
this special case of the first argument
to resource is a map by merging
ourselves and this is another case I
often encounter in the world it's a kind
of incomplete API as I guess we all
encountered that before that we have a
nice function nice library has all kinds
of functions and suddenly one piece is
missing which we consider we yeah kind
of a key part of of the functionality
for example this might not even be
something completely missing but
unhandled a unhandled edge cases and
this is surprising to the user and least
workarounds and we saw before that
workarounds well they have their
drawbacks and also it can like lead to
the fact that users of your library
spend time searching for a particular
functionality which isn't
because they think they might not know
the name or the name of the function
might be a different one and so they
lose time just to last just learn after
hours that the functionality that we're
looking for simply doesn't exist and
those workarounds we also have an
example from Liberator this is what you
would expect how of expression somewhere
in your callback function looks like for
those not you're familiar with Liberator
so there's a call to ring response which
allows you to return like a literal ring
response map which is not touched by
Liberator anymore and it's the first
argument you can in general return a
value which is then converted to the
actual representation depending on the
content type for example - Jason - maybe
a text string or - whatever you define
and that's the second argument it
accepts like a partial ring response
which is then merged with the actual
response I don't need to understand that
to understand my point here because what
you really need to do is the following
and this is quite sophisticated and not
very suggestive and I guess people need
to learn that from some documentation
and this is nothing you will find
typically in your random dock string
right another point is that use closure
users expect nil punning that means
where you have somewhere a value of nil
and continue to work with that well
things work and you end up with a nil
value so that's a pretty common idiom
and closure and for a lot of functions
but what I saw on the wild is something
like that was looks like a very innocent
print function which should dump some
data structure maybe in the end in your
lock file and people with with a Java
background I see often to use to string
on the data and all works fine until you
staff value is nil and you have this
nice suggestive closure exception you
know reflected or Java line 301
I never heard of that before until I
prepared for the talk
so I never looked into the details
another case of like an incomplete API
are missing it's missing error handling
so the default might be that your
library or the library you use simply
true throws an exception and for
liberator
this man that the users presented a nice
HTTP status 500 internal server ever
error while this is semantically correct
it's not very helpful at least to the
application developer so since a
particular revision there's a
possibility in liberator to specify an
exception handler this has all kinds of
drawbacks on its own especially when
your exception handler throws an
exception to we had that also before
with I guess slingshot or the exception
handling error handling talk what
happens when you're like throw it's kind
of recursive exceptions but it's better
than simply like throw an exception and
have the user the application developer
to make sense of that and then we come
to state so this is a hot topic in
closure right you might ask is state
part of the API and I would say yes it
is state of the power a state the state
is part of the API because when you call
functions in your library which expect
some particular state to be of some
particular reference or handle or
whatever mutable thing to be in a
particular state you must document that
and what I see in the wire there's a lot
of atoms for example an atom's whole
state and they have you have code which
I saw we have like a system state with a
single atom and then comes another
developer and because nobody thought
about how to integrate that into the API
like on a higher level and in bigger
systems we have another atom of course
with another state and because we also
already have to act
developers feel like that's the right
way to do and you have know some kind of
axillary state and finally you have a
state manager somewhere in a statement
if you stayed at them and all that
and finally yet another state there are
some problems with that of course
there's no coordination between atoms so
you cannot have like a transaction over
multiple atoms in a well accessible way
and the functions you call when they
accept some state they are no longer
referentially transparent which means
when you call the function twice with
the same arguments you might end up with
having different outcome because the
state changes this is necessary of
course because all the computation we do
have some side effects we without side
effects we don't we wouldn't have
anything like printed on the screen or
change in the database so it makes sense
the closure provides abstractions for to
change state of course but as soon as
your library or your API has this
concept of State things become
complicated and there are functions that
accept cars some can expect some kind of
initialization and this is also
problematic because you cannot simply
call the function provide the arguments
you need to know that before doing this
you have to do that and you make sure
that the initialization step actually
was successful and could be that there
was an error and there's a silent you
thrown somewhere in a core a sync threat
or like that and then you wonder why
things no longer work
so my recommendation in this case is to
use explicit arguments as far as you can
go and use a single item to hold all the
system state so do we have this before
in the aam next all right David known is
a proposal of that on the client it's
not possible in every case but you need
to make sure that when you use multiple
items there's no simple way of
coordination and in the end I would
recommend not to pass the actual stayed
at home but a value and then in the end
your function return' another value so I
have an example small example with well
a smaller version of all those state
things and in this case we're using a
single item holding a map pointing to
the actual actual state and in this case
all those updating associate in remove
in or what is called a dis ocean
functions are your friend and this is
how a random function somewhere from a
system could look like is the idea that
the starred interest function starts
some system and for this for the other
functions you need to know you need to
update some state and well in the it
gets passed the state as an argument not
the ATM but the actual state and some
random arguments for example a file to
interest and then it starts a random
whatever background process to to
actually process the file and after that
it a sews in system said interest status
the value that this is running so that's
not actual production safe code because
all things could go wrong here there's
no error handling but what you can see
is that in the end you can use swap over
the actual stay datum on your head and
you only have one ATM and provided the
start interest function and the five
parameter and this should make the
developers or this should may make it
easier to reason about what happens in
the system it's easier to test and for
example you can use multiple functions
when you have top-level items there's
only like one instance of this 8mm so
you cannot have like multiple interests
run at the same time when you pass
around state explicitly and pass around
maybe even the atriums holding the state
you could insensate the same like
component multiple times these are
things you need to consider when you
build an API another another way to use
to do this is to use dynamic binding
also topic we saw earlier today
we define oh we're missing the default
value I guess so we define the dynamic
variable DB for example and provide some
helper function with DB which actually
boils down to a binding call and then we
have this fetch from DB whatever
function this is like typical code we
see laud enclosure and this is nice
because we can avoid for example the
endless passing of parameters or of
hands like you have a top-level database
and law handle to to Cassandra or to a
file or to whatever and when you go down
the implementation stack you need to
pass it around a lot for example we have
low-level x''k function which actually
does an SQL request to database you
might have a fetch function which is
responsible to query and this actually
calls x'q and you have a lot use a
function which does all the user loading
and this actually delegates to fetch and
you have like a authorize function as an
example which tries to load use and what
you can see is that you have to pass
this DB entry all the way down in this
case looks very natural
but in the wild it might be become
complicated when you have multiple
systems multiple databases bigger
systems like system where you processing
data are coming from one system into
another system you might have been
handled for some kind of error reporting
you want to do metrics to a different
thing so you're passing all those stuff
around well that's kind of kind of ugly
but there's a problem with dynamic
binding what if you want to connect to
more than one database
there's no way when you can bind the
dynamic variable variable only to one
value at a time so when you Pro when
you're for that please at least offer a
non binding interface to it somehow -
unless you can make sure it doesn't make
sense of more than one database for
example but I don't know if is the
library maintainer want to make that
decision for my users so how do we fix
that so this is more like it
general recommendations I suggest
out-of-band documentation autopen
documentation for me is not what your
right into a doc string on a function
level maybe it's the doc string on a
namespace level but when you have a big
library all your code might be split
over multiple name space so please
provide some kind of like top level
documentation for your library and in
this documentation explain the design
motivation why is the library providing
an interface like it is there might be
some reason I hope so after the talk you
might think more about the API and so
write it down why do you suppose or
suggests values like dynamic binding of
a variable why do you not offer to use
multiple databases at once with your
library there might be a reason explain
the model and the abstractions in the
not trivial libraries we have some kind
of data structures we have a like a
technical or mental model behind it so
for example chorusing use this notion of
a channel what is the channel you need
to document that else people were just
like copy and pasting other people's
code and try to make things work somehow
so that's what to do I don't know why so
liber8 three Liberator uses the ring
interface for example this is a very
simple but powerful abstraction for web
requests every HTTP request comes in as
a map there's a request method which is
GERD for example and some header values
okay there's maybe a body for post but
that's a how request looks like very
powerful and simple encoding and as when
you implement the Ring request handler
you need to provide a response which
also very simple map the status code a
random body value and some HTTP headers
and the actual function is a function
which takes a request and returns a
response that's very easy another
abstraction
in liberator is that it holds some kind
of processing stage who liberated us a
big decision tree and you provide
Colbert callbacks and of course somehow
during the processing of the request you
need to keep track of the of the values
of the outcome of the execution of those
callback functions and this is the
context so it looks like this so there
might be an HTTP status which was
already determined by Liberator there so
original HTTP request and representation
resource whatever even custom custom
keys in it and every decision function
looks like that it accepts the context
the current context does something fancy
and in the end it returns a context at
the update which is typically a map
which is then like merge into the
original context that's the way how you
update the results while Liberator
processes the web request and this is
actually documented so there's a section
see in the background on the github
pages and the Liberator documentation
about the execution model and this is
important because it's not something
that you easily can learn from
docstrings
or maybe from examples especially what
are you allowed to return as a context
or not okay so may applaud here that I
have done this nice documentation also
liberator provides a high-level view on
what's going on so ice already told
there's this kind of decision tree and
then you never use Liberator before it
might be not very like hidden and and
unintuitive for you so we have like this
kind of documentation in the docs a big
graph and actually there's some kind of
a debug console where you have this
highlighted the path that you request
actually took this is all part for me of
the API because this is what you're what
the developer develops against what can
you do to to work around there's too
many knobs problem you can use protocols
so this is something that could be used
for liberator instead of relying on
those
which you can easily get wrong use a
protocol which even have like docstrings
or you can use something I call micro
protocols yadda which is another HTTP
rest server library does this you have
like in this case four protocols which
have like a single method which you need
to implement is not too too easy to get
that run so when you have those the
protocol names are checked by the
compiler and the protocol implementation
function names are also checked by the
compiler and you get better error
responses on next for example just this
two small protocols so to wrap it up API
design is about users not the user
sitting in front of the computer like
the end users or the consumer but the
developers which use your library you
need to plan ahead I released Liberator
to the public and suddenly yes people
were using it and I had a bad time
because I did not plan ahead and I still
think about how could I do things right
and maybe there will be some kind of
Liberator to at some point which breaks
all compatibility but I never do that
step because I have so much to do to
maintain backwards compatibility right
now find the right abstraction when you
provide the right model to the API it
makes it easier for the user to to
actually make sense of all the things
when you whatever process numeric values
find the right abstraction for those
values when you're doing web requests
find the right abstraction for example
ring model is very powerful it's the
right abstraction I guess but also you
need to think about convenience for the
user developer on the one side and
expressiveness on the other side so when
some something is library is convenient
you might assume a lot of things like
default values or what you do in case of
error and this goes on the like goes
against expressiveness you're taking
control from the user to make it more
convenient I guess in general there's a
middle ground you have to find so micro
Commendation is an API designer forget
everything take the users perspective
assume nothing
and look how far do you get only for
example reading the docstrings this is
hard because you know the library so
well and you know how to do it but try
to be like a new user of your library or
actually find a new user of a library
maybe a co-worker and make him or her
write down what's wrong and we are like
the the bad pieces of your API and then
observe the users look what they are
doing how are they using your library
for example search and github you will
be surprised what people are doing to
Liberator and when you get those works
as designed issues which you like close
with that reason ask for context and
motivation to understand why the user
thinks it should work differently thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>