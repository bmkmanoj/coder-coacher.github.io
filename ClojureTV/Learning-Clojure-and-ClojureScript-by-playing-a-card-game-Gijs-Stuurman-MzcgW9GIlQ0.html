<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Learning Clojure and ClojureScript by playing a card game - Gijs Stuurman | Coder Coacher - Coaching Coders</title><meta content="Learning Clojure and ClojureScript by playing a card game - Gijs Stuurman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Learning Clojure and ClojureScript by playing a card game - Gijs Stuurman</b></h2><h5 class="post__date">2017-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MzcgW9GIlQ0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so my name is Kai Suman I am a
closer programmer from the Netherlands
where I work as a freelance programmer
and this is my first closure conch the
story begins in 2002 back in San Dyke in
the Netherlands where we have the
windmills in the sands columns which is
an open-air windmill Museum more
relevant is that in 2002 I was in my
final year of high school and I started
to dabble around a bit with programming
and I found this book online which is
called thinking in Java by Bruce echo
which is the first book I started
started programming with incidentally
this guy Bruce echo also wrote a book
called thinking in C++ but for some
reason I chose the Java one I guess if I
chose the C++ one I would have invented
closure 20 years later as we learned
this morning then in 2003 I went to a
university this was an NCAA also in the
Netherlands it's not really famous for
much except that it has the halls
brewery with a Buddhist beer but very
much I had to continue thinking in Java
everything we get their programming was
in Java classes were in Java assignments
in Java even if it's only tangibly
related to programming the assign would
be in Java so more thinking in Java then
in 2007 in my third year there was a
scheduled year there was a an elective
class you could take on functional
programming and I checked it out and it
was actually a quite a revelation for me
so the coaches here is from actual
actual practical assignment I had to do
I had to drag up a city bomb with their
backup where it was still on but I
distinct remember that at that time this
looked amazing this code we were
building tiny programs it's like a
Miranda Amanda so like a high schooler
well type of programming language we
were building tiny programs we could
make gooeys with very few lines of code
and everything just felt very believable
like to what we are actually doing you
have an assignment you write some code
and you fix the assignment was a nice
short feedback loop by compiling the
program and running it to me it was
revelation so I was hooked on this
functional programming idea so from
there on I tried I went to explore this
idea
and I found both a scheme which you see
on the left and closure on the right and
for scheme it's appointed on the left
you see here something called doctor
scheme which is the scheme programming
environment that you can download and
more importantly for this talk with dr.
scheme there are also a couple of
examples programs which is the gin rummy
card game so there were lots of example
programs that came with it but this is
this one I liked so for those of you who
don't know the rummy card game I'll
briefly explain it's a card game with a
regular 52 card deck you play with two
people against your opponent and on each
turn you have the choice to fill out
your 10 card hand that you have by
picking either a card from the deck
which is face down or from the discard
pile where one card is face up you take
a card from either pal you then have 11
cards in your hand and then you discard
a card again to end up again with 10
cards and the goal of the game is to the
winner is the first one to arrive at the
gin hand which is where the 10 cards
combined into combined into a winning
hand which consists of three sets or
melts as they are called so you have one
of three cards one of three cards and
one of four cards and in each set or
melt as the property that it's either a
straight flush or like a three of a kind
four of a kind so in this example I
think you have a Jack King straight
flush to you for carrying the fives and
then eight to Jack
straight flush again which make the
bottom player the winner in this end
there also some other rules which
involve if you maybe already know the
game you can do knocking and other types
of rules but this game and the game I'll
be implementing is only with these
simple rules I just explained any other
things do not apply and like I said in
the dr. scheme environment you also
these role examples in scheme so you
have to code a code there what's
actually code does here is not important
but the code was available you could see
how they made the GUI you could see how
they made into a can drop
and you could also see what the a I was
of the opponent that they programmed
this was the part I found quite
interesting and like I said I found this
sort of at the same time for my
functional programming course jumping
into functional programming so at the
same time I was also looking into
closure and then if you have any
questions about closure you can go
online and people will help you the same
still through today although now we're
no longer on IRC or most of us I guess
not now we're on slack but still you
will find the help of people to help you
out if you have a question and of course
for my regular background at university
I was mostly a Java programmer so I knew
Java and because closure vine on the JVM
I thought I'd go build something and one
of the interesting classes I ran into is
the java.awt the robot class this is a
class in the standard Java library that
does basically two things it can make a
screenshot of your desktop wherever its
running and just give you the
information of all the pixels and it has
functions to actually move your mouse
and take over the mouse so to generate
clicks double clicks and everything like
that so I thought I'd combine the two
and actually make a robot that could
play this gin rummy game like I said I
already I knew in Java with closed you
can use Java so this is a textual
closure code it just uses this existing
Java library and then the resulting
robot looks something like this
here
so on the left you see the gin rummy
game will be the different
implementation now on the right is the
robot which basically goes to loop it
takes a screenshot of the entire desktop
it tries to recognize all the cards so
it sort of knows where all the cards are
but not exactly so you can sort of see
that every card recognition goes like a
two-step process it sort of knows where
it is and then from the tiny clip of the
desktop it will try to find the edges of
the card and with that information it
knows enough to actually recognize which
card is which and for each card it only
needs to sample a few pixels in the
top-left corner to be able to
distinguish which card is which and then
the robot also has the same AI as the
opponent in the program here so then it
makes a decision on what to do and then
it gives the mouse instructions to
actually make these moves and this will
go on until there is a winner and one of
the things that needs to happen is that
your UI has sort of you have ten hands a
ten card in your hand but then you sort
of have to you're you allow to place
them wherever you like but there's no
actual placement of putting them all in
full view so the robot is always busy to
make sure that every card is actually
visible so it can see and make a
decision and this goes on until there is
a winner
so like I said the scheme code for the
actual opponent was already available so
I aborted that into closure and it was
an actual snippet from that scheme code
and if you may know the scheme is also
like a lisp and perhaps a functional
programming language but then if you
look at this scheme code this looks more
Java is than it does functional code
because here card in this card game in
the scheme code it's like a class and
it's both the combination of the actual
suit a card is the rank a card is as
well as all the code you need for
putting it down on the screen how big is
the image where does it go on the on the
on the pane and how do you do drag and
dropping whereas in closure we just put
it in a map of course there's only just
the data for a single card but this is
this is it this is how you represent a
card enclosure and of course this is a
trivial example but even the typical
example is still trivial it's also
valuable I think so you see in the
closure close a card is just the
combination of its rank and its suit and
then in the genomic version we need ten
cards per hand so I just make a vector
of it or a collection with ten of these
cards this is already a stark contrast
but I think a good example of what is
nice about closure the data is just data
and you can read this data I wrote it
down here and I think it's fairly easy
to see what this should represent
compared to what is clauses on the left
hand side then I was still university so
then we arrived in the 2010 I built this
gene for me a robot with closure and I
had to do my first like real programming
exercise for my graduation master thesis
and because I had had fun doing this
closure thing it actually worked I
decided to do this project in closure
and then I had to build a simulator that
executed semantic specifications for
modeling languages but the useful thing
here is that because I played around a
bit and made a little toy project I felt
confident enough to actually build a
project on the sort of a deadline in a
couple of months the closure and
that well so I guess what I learned
there and particularly with regards
closure the Java Interop is great I
could indeed use everything on the JVM
and this whole focus on data and
functions or perhaps our values and
functions is it's quite nice from then I
moved to it also in the Netherlands if
you look at this building you might be
thinking is that a UFO in the building
it is when I was in Ooty EFT I had my
first job out of the university I
actually joined a company where I worked
on Ruby on Rails websites at that time
there were no closure jobs available in
the Netherlands yet I did manage to
sneak in a little bit of closure by
transforming a CSV importer into a
closure program as there was a
standalone
thing so if you want to try and
introduce closure in at your job or
anywhere else find maybe a tiny piece
you could replace and go from there and
then also in 2011 a closed clip was
released which check he did this with
this quote closure rocks and JavaScript
witches both I think are true I already
knew that the closure rocked and with my
work I also had to do a lot of
JavaScript and this was indeed a way to
reach people in the browser so I was
really intrigued by this idea so once
again I wanted to to try this out so
what I did again was just get a card
game but this time make a version in the
browser so using closure script I would
build the exact same version that I had
in scheme in the browser and this of
course also meant that I could show
people this game more easily because
there is a huge difference between
telling people like yeah I used this
little game that you can find and
install million a thing or of course we
all know it's much easier to just send
somebody a lincoln and show somebody
something and there's also actually
their version you saw the robot play
against them moments ago
so in the deck of cards in the close rip
version there were our four aces as in
any deck card and I gave each of them
their own logo I'll go through them one
by one at the first one this is the logo
for scheme this of course just a tribute
because that was the original game as
well as the code for the opponent a
scheme is now known as record so if you
want to look it up online look for that
in the ace of spades has the closure
logo and now even have a sticker with
the new closure script logo but at the
time we didn't have it and the closure
script of course is what I made it in
and two things were I had to build their
first of course is just the code for
your opponent but I already had made
that in enclosure for the robot version
and then all the tricky bits with the
dom the UI the drag-and-drop the mouse
handling and stuff like that and it was
actually also quite nice to do enclosure
scripts because for the first part if
you have code enclosure already
particularly with only handles data and
functions if you just change the file
extension you can use the script code
nowadays that's even easier by just
using a co JC files and then for the
more difficult things in in JavaScript
or JavaScript applications this is quite
handy this is the ace of hearts with the
Google closure logo and if you might
have Google closure is the underpinning
of the closure script compiler and it
also has a huge library with everything
you might need for Dom manipulation
Mouse handling keyboard handling if you
want models that are always visible even
if there are any perhaps in a corner if
somebody needs it in a web app it's
probably in this library it's it's a
huge huge library but one thing I like I
said I used to work with Ruby on Rails
and JavaScript in the form of maybe
jQuery snippets or smaller snippets of
JavaScript and then if you are exposed
to a Google closure library and the way
they do JavaScript it's
completely different luckily there's a
solution there whatever you look up
anything regarding a Google closure they
always refer to this book the definitive
guide they may evolve call it the
mandatory guide because anything you
might want to know it's actually in
there and the interest also sorted
through that if you are interested in
how anything works you probably cannot
find it anywhere else online if you want
to learn how google closure works - only
the API Doc's maybe some guys which are
available online you'll you'll get
frustrated quite quickly so I would
advise to actually read this book and I
think the same thing is sort of true for
closure itself a lot of things are
probably a lot different from what
you're used to before so I suggest and I
I have done this - is to read a lot of
books about closure because then you
actually taught something in context and
whenever something is new you'll you'll
learn why that is different from what
you might be used to these two examples
another in particular you can choose any
book with closure in a title I think and
also must say that the videos for
closure are quite nice - to learn from
then the fourth ace is the ace of clubs
which is apt in this case because they
stand for the MCM closure Meetup I've
been lucky to have had a very active
closure user group nearby for many many
years and I've been there many many
times and this meetup is not just to
learn about closure to share projects
you do with closure ask questions but I
also it's where I learned Emacs because
the only way you can learn is when you
see somebody do something me like what
exactly did you do how does that work
and from then on I could learn Emacs
myself what's also been quite useful
actually for for work I visited the
meetup lots of times and almost all of
my work has come through the meetup -
referrals and things like that
and also when I first started going
there I was still a student but then you
see people there that are working
programmers and may be further along in
their career that was also quite useful
to it just see what they are up to and
from them so I also would recommend
visiting a local meetup if there is one
so this closed loop version what did it
teach me well once one thing that closed
you can run in the browser and it works
quite nice and I would advise using
books for learning and also ecology
scripts since then I don't think I've
had a job where I did not have to use
closed script because almost everything
I've built had a component that also
maybe even only internally had some sort
of web component where it was nice to
have a nice dashboard of something for
which you could use closed script so
that's been very helpful for me all
right then we get to 2012 then I moved
to Amsterdam the Netherlands which also
marks the first year that I actually got
to work with closure professionally and
I have done so since then and what I
also started doing in 2012 is to start a
blog
one thing is nice to just keep track of
what you actually in pin up to but it's
also been useful for me to actually use
as a bit of a motivational device to
make sure I actually finish projects
because I had a lot of things where I
would just start stuff and maybe look
into it like oh this is nice this is
interesting but I found it quite useful
or helpful to actually finish projects
to also get through like the layer last
20% of something and particular for
myself is something I office where if
I'm sort of interested in something and
then maybe the newness wears off then I
might not finish it but I now usually
set myself a target I cook ok at least
make a blog post at the end so make sure
you actually complete this project
that's been quite helpful since then
then in 2014 I decided to make another
project two years earlier in 2012 the
atomic was released again I thought this
was quite interesting so let's
investigate so I just again decided to
make a a card game version this time
again with a closed clip front end but
you could play it over the Internet and
then they tell Mike would be the
database for the system so that's
basically what it looks like of course
you can play this time against an actual
human opponent it's over the network but
that requires everything at least one
friend you can also play against the AI
over the network this is a useful during
development so that's why I put that in
there
this sort of what the architecture looks
like I'm not going to go into this
person completely but the important part
is that the atomic was the database for
this for the first on the front end I
used a data script which is a closure
crypt variant parts of diatomic
enclosure script it's more of a only a
data structure rather than database with
tectonic principles and what I also want
to highlight is that I do use the atomic
and date script here but what I don't do
is I do not replicate the database from
the server to the client in the case of
a card game and I've found in most web
applications you usually only want to
show people in the browser but to
actually allow to show in the case the
card game this is quite simple you
should not send out where every card is
on the table because then you could
easily find out what your opponent holds
for instance so they tell me since I'm
not going to deep dive into it you'll
just have to make do with these
descriptions by me applique the first
one is important that I I consider it
like a closure atom but then I say
database and then if you are familiar
with what CQRS is I also use it often as
a tool to just compare implementations
because trade-off is a diatomic has a
certain set of trade-offs it made where
certain things are possible in the
atomic which are maybe not possible in
other systems so I found it quite useful
if you're making any events
or system or if you're using an
adventure system with multiple different
sources to think why does the is this
not how they Tomic works and what do we
lose when we do this that's helpful if
you know that seeker has meet what I do
when I highlight in the architecture is
that the communication between the
client and the server is by sending data
back and forth and because this is
closure the data is maps and factors of
maps just regular closure data this is
this really nice and one thing that sort
of falls out of use you can take Tomac
is that this sort of becomes a
event-based system so on the client
people make actions it's your turn to do
something so you drag a card you select
the card maybe you discard a card these
all turn into events that go to the
server and the other way around
whatever happens gets broadcast from the
server towards you
so you know how to update your display
and see what the opponent is this sort
of looks like this this is just a show
that everything goes back is just
closure data you can just if you were to
print what goes over the wire this is it
but the important part is in the bottom
half where you see that each event also
has a tea associated with it which is
sort of like a point in time a
progression of states of the whole game
as everybody makes a move and this tea
is actually very valuable because this
is a web application you have a client
and a server so what can happen is that
the connection disconnects the user can
always press f5 reload the page a yeah
you just have to assume that at some
point you have to set up the connection
again and having the atomic assess
database is quite nice because in the
atomic you have both the full view of
your database at certain point in time
as well as you can track whatever
happens between point in time so in the
normal operation mode it just events
coming from the browser to the server
and the server sent events to the client
but if there is a reconnect or the first
time you load a page or maybe you reload
the page as a game is going
we can use the atomic to get a view of
the entire database which in this case
will be the entire table where every
card is and you can just send that over
so that sort of looks like this where if
you need to reset the entire table you
can just ask for the complete view at a
point in time so that's the one at T 3
and then below once you have the whole
table again you can again continue just
to receive only the events that contain
the updates yes that's what I want to
highlight about the atomic that the
power is really I think in the in having
this T so the power of T as a way of not
just describing each point in time in
your database but also as a as a
modeling tool in your architecture
because you have a reference to a
consistent point in time for everything
in your system so this became the basis
of designing the system so if you have a
disconnect you need to know which team
were you're at from which T do you want
to continue and with the database
providing this you don't have to do this
yourself by combining perhaps multiple
sources of data or or whatever so ever
you've heard that they talk just like a
database that allows you to do time
travel which I guess is true but this
time travel is also useful if you only
work forwards in time because you still
have the reference to each point in time
so I said there's really who useful for
handling reconnecting what's also useful
for handling every Fresh's see this
works so this part just basically looks
nice but this is one of those features
that if you have to build it into a
system at the at the end then it can be
quite hard but with the atomic because
you have a consistent view you can just
render it so looks like this and it just
looks nice because of the animation
this is a web application enclosure at
the time I build with ring and Liberator
I must say that since then I much prefer
the pedestal web server so I prefer to
build a closure application on the
server with pedestal so two things
that's are useful from closure here one
is that the focus on data by four with
closure is really helpful if you have a
wire in between between your client and
your server and that is that's true here
too and they Tomac isn't it like
closures time model but then for a
database then we come to this year this
is a 2017 the picture here is again in
Amsterdam this is a construction site
for a new subway line of course the
subway line is a years past you and way
over budget it's a bit similar to my
card game but I want to draw your
attention to the yellow crane you see
here so often when there is a big
construction going on
they don't just put a spade in the
ground and start to work but first they
set up everything to make it a bit
easier to work this a crane is an
example of that because that does the
heavy lifting over time I think every
way or at least I found with doing
closure that I try to do something
simpler so whenever I have a project I
also build the tools beforehand to maybe
work work with the project a little bit
easier one of those things is to always
set up a dev environment versus a
production environment so you are
developing the project you'll likely
wonder Apple perhaps you want something
that makes you code reloadable with
components but then in production
perhaps those things are different you
want different components maybe you lock
down the repple and other other
statistics I guess you have this with
almost every programming language but
enclosure this is quite important
because of the dynamic trade-offs there
are but even nicer I think is to also
build utilities that are more particular
to the project you're doing and I think
closure really helps with this you can
do you can you are designing something
you know which state you might want
represent you can also then make it just
easier for yourself and just make tools
to work with this state this can be in a
version of just visualizing what's going
on in the system as well as generating
state data for tests or just trying
stuff out with this a gin rummy game I
did this in the closure script version
where at the bottom here you see a
little table with blue and green
highlights so this shows that 52 cards
in a deck and then the color shows where
this card is in your hand or in your
opponent's hand which card is the
discard and it gives a view into the
state that helps while building it so
you can track where everything is and I
think this is easy to do because the
core of your system is representing
state and then you can also make little
tools to help you visualize this tape I
think that's quite helpful also this
year I have another interesting looking
into all these AI thinks you might have
heard of so I thought there's this
scheme opponent which has an AI maybe I
could've beat it once and for all
so the idea first was to have a to look
into neural networks and the first thing
I did was to try and find if I could
find a neural network that could
distinguish between good hands
so winning gin rummy hands and bad hands
hence deader don't win and to do this I
again have to build a utility so I had
to first get myself a collection of non
winning hands and winning hands so using
a test to check generators I was able to
generate winning hands so if you have
ten cards you need to make sure you have
a set of three another set of three and
a set of four cards that to get a former
winning hand and with the test
generators this this was possible miss
again example for making the utility to
create the data you need to build your
system and I think because the closure
representing data is so straightforward
this also is pretty straightforward
so that was the first III project I did
like okay can we distinguish good hands
and bad hands or neural networks do this
then I wanted to take it a little bit
further which is maybe we can build an
AI that learned from self play this is
something that is used in alphago and
before that they had a project where the
computer could play Atari video games
which had also learned it by self play
or with neural networks and then
predecessor predecessor of that project
is a German AI in the 80s which also
learned by playing against itself we
just sort of the yeah the project that
is a root for a lot of these AI
successes dick day so inspired by that I
thought okay maybe I can apply that to
what would it be like to have this gin
rummy game a create AI by learning from
playing against itself and the idea here
is that it's a reinforcement learning so
because it plays against itself
somebody should win and that can be a
reinforcement signal to update your AI
and hopefully converge into a winning
project so what ends what happens is you
have ever hand ten cards you have a
neural network evaluated it says is this
a good end or a bad hand and because you
want to learn from self play in the
beginning this is random so the first
evil hand evaluations have nothing to do
with whether or not it's actually a good
hand
the self play so it has the ten cards it
can decide okay I get a card which hand
do I get then how good is this hand
should I should I use this card or not
and maybe it decides okay I won't do
this but then you get into a problem
because this is a self play and the
initial evaluation of hands is random
then what this thing actually starts to
do in the beginning is it gets like to
the hand it at that time thinks it's the
best but it isn't it's not the hand
that's going to win maybe it only has
like two of the same and one straight
flush in there but it's never going to
improve because at that time it thinks
this is the best one and it doesn't get
to the signal of winning a hand where it
can update the hand evaluations that
so what you didn't sort of gets stuck in
so you write this program and you have
it running but you see no progress
because all it does is it has his hand
the ten card it will take a card from
the deck but then immediately discard it
it will take a card from the discard
pile and immediately discard it so I'm
going to actually try any new hands so
it will just get stuck on this local
maximum and then no learning actually
takes place so what I've learned so far
in this project is that if it is helpful
to create yourself some utilities and
then build yourself some tools that make
it easier during development what I also
learned is that sometimes if you try to
learn something you fail luckily I think
most of time we learn you succeed and I
had a great time learning closure so far
over these years I've been lucky now to
make a living using closure so I look
forward to learning more stuff with
closure thank you
yeah yes sure
okay so the question is when moving from
the scheme code to the closure code
could I use have could have used
mechanical translation or what steps
there or what did I have to do
no absolutely the biggest thing there is
a like I showed this hand representation
so it's a factor of 10 maps with a card
and a rank in it but then also for this
AI part you also need to figure out it's
sort of like a search I have 10 cards
and I want to find out is this a winning
hand so I need to find 3 different sets
of combinations of cards and for this
the data structure in the scheme version
was was a list so this algorithm was
always processing from the first to the
last card from left to right to the list
you might say and then if you have
closure date structures you don't
necessarily have a list you can have
sets of things you can have a map and
then in this translation if you try to
decide maybe I'll use a vector but then
I use a set to handle the cards I've
already seen or something and then you
start to translate this algorithm and at
some point you find out all they use the
list but not just because it's the only
container they have but also because
they use the list and they needed to
have like an index into into the data
structure so you saw that after a while
you figure out ok these are the things
from the data structure they actually
use and then if you maybe use a map
whereas the index is also important
positional index is also important then
you're like oh maybe that was not a good
idea so I had more I spend more time
figuring out ok was the proper closure
and representation from this everything
is a list representation it's key rather
than doing this mechanically in some
sort of proscape translation way that
ends in your question
so the question is how do I choose the
parameters for the neural network
these were randomizing
sorry I've missed the last part
well the biggest inside of how powerful
the steve-o's was actually first later I
also used a built-in fan sourcing
systems work too well you have a lot of
events coming in and then you need a
consistent view of the database build
from multiple defense sources and
because they Tomac has a SSD reference
so you can always reference a particular
point in time that sort of influenced
how I build it because at the time I
didn't know that how important this
could be but because I knew that the
atomic Haddad
that were came sort of the way I
structured the first architecture of
this this application so it the insight
came after the fact that
all right Norma Christians thank you
yeah sure overtime
well the the the origin of using a ship
there was because I saw the similarity
like okay datum week and then data
script in front it so this but fueled
more</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>