<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Physics in Clojure - Colin Smith | Coder Coacher - Coaching Coders</title><meta content="Physics in Clojure - Colin Smith - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Physics in Clojure - Colin Smith</b></h2><h5 class="post__date">2017-03-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7PoajCqNKpg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey folks I just call it Smith I've come
to talk to you about my experience sort
of diving into a textbook theme to
structure an interpretation of classical
mechanics which is sort of an odd
successor to the structure
interpretation of computer programs
which share is one of the authors and
details their work using scheme an
earlier list variant to explore
classical mechanics and they use it
especially to work with the dynamics of
the solar system there's a couple of
demos I'm going to try to get to so if
you want to click on something you could
go to the link at the top there and
there's some things you can click on or
if you're bored the authors of the book
have a quote that I want to read you
just because since you guys all bought
tickets to come to a functional
programming language conference it
should resonate with you guys and gals
one way to become aware of the precision
required to unambiguously communicate a
mathematical idea is to program it for a
computer we use a functional style to
encourage clear thinking the computer
does not tolerate vague descriptions or
incomplete constructions now reading
structure and interpretation of computer
programs SiC P is I'll call it back in
my 30s was kind of a life-changing
experience I had you know grown up with
UNIX and C then it became C++ and Java I
had never really had the experience of
doing anything with AI anything
symbolically things like immutability
you know we're just not not taught and
not understood at least by me back at
the time it's interesting to know when
you read sick beat if they don't get to
beaut ability until well into a hundred
pages before they introduce set bang so
it was absolutely right I came to D at
the right time so if the author of that
book wants to teach me physics I want to
find out how to do it too well I don't
have any any physics training I took the
minimum two semesters of physics in
college and so what am I doing here I
thought well I dunno I dunno list really
well so maybe that will just allow me to
bulldoze past all the the things I
forgot to study when I was in college
and I'll come out ahead of this actually
I find the book to be rough sledding
even if you are an excellent list
programmer and plus it's written to use
MIT
scheme which is kind of an older variant
it wants to use X Windows it wants to
use their own Fork of Emacs it comes
with a lot of kind of encapsulation
that's maybe a little less than the the
cutting edge so I thought I have an idea
I love closure or at least I think it's
the you know the the inheritor of the
scheme
energy so I'll try to put it and I bet I
would learn a lot both about symbolic
mathematics and about physics and about
closure and the answer to all those
questions is it absolutely did that
although it could take two years I'm
going to just breeze over a couple of
terms because the subject of Lagrangian
manic mechanics is a big one and we are
going to do every variety of every kind
of thing so we're just going to make
some simplifying assumptions here I'll
call it path which is a function I'll
call W which is going to map from time
to the coordinates of objects at our
systems and this the coordinates we use
dependent on the problem we're solving
we understand that this knots going to
be differentiable as many times as we
like we believed it from the position of
the objects in space we can find the
potential energy and with the position
of the velocities we can find the
kinetic energy T of the system and we're
just going to call the Lagrangian the
difference of these things l equals T
the kinetic energy minus V the potential
all right we will think of given the
path W we're going to call this sort of
infinitely long tupple the state of the
system it starts with T the time then we
have W of T the values of all the
coordinates of that time and then you
could imagine that we just keep
differentiating off into the future and
we're going to call that the state in
the Lagrangian mechanics and Hamiltonian
mechanics that we're going to be looking
at today we are content with the first
three elements of this tuple what other
problems might require more and that
doesn't break the concepts that we're
going to look at today the main thing to
think about which we are going to take
is absolutely given is the principle of
least action often called more
accurately the principle of stationary
action I'll call it the principle of
least action because that's usually what
the headings of the text
you know you'll find it under it says
well if we have this Lagrangian let's
forget where it came from it someone
hands you a Lagrangian they can say the
motion that you observe for this object
is going to be that motion formula that
path function W the one that's right if
the one that will make this action
integral minimum or maximum stationary
we'll just call it minimum for today
that works for the examples that we're
going to use if you look though at L
inside that integral sign which is our
Lagrangian it looks like it's a function
of our state okay which we go sometimes
called a local couple of the path WT W
at its first derivative so the idea
might be well I wonder if I could
program a computer to do this for me can
I get a computer to do a solve that can
be find the W that would minimize that
integral well there's a theorem that
will help us it says that a path that
minimizes that action integral I I saw
on the last slide there there's also one
that will satisfy this differential
equation which is called the Euler
Lagrange equation great if we could
convert this into code we can find a
path objects we'll take in real life
except it doesn't say where to put the
path and this was kind of the genesis of
Gerald J Sussman and Jack wisdoms
approach to coding this or to
approaching this problem with code they
also complain that you know it doesn't
seem like these things are even function
of times or functions of other things
that are then functions of time and
aren't you supposed to use the chain
rule and what do they really mean by
this and the papers in which they
discuss this votin in the book structure
and interpretation of computer computer
excuse me classical mechanics and other
papers they they often go to this
equation and say they were lying to you
this is what they really meant they
really meant we're going to start with
the Lagrangian L and we're going to
differentiate but it was differentiated
with respect to its velocity parameter
and after we have done that we are going
to paste in the function W our path
function and its first derivative and
then over on the right the same thing
will partially differentiate L with
respect to its argument in the first
slot counting from zero and then we will
paste in
you and w prime of T and then for the
left-hand thing now we have a function
of time so it makes sense to run that
through a differentiation with respect
to time and the W that works will be the
one that makes this whole thing zero so
we're getting closer to being able to
code this because we've sorted out some
of the ambiguity that was concealed in
the Leibniz notation all right well
let's just start coding maybe in advance
of knowing what's going to happen so
we're just going to adopt some
conventions here that will turn out to
be useful to you if you decide to study
the book we have our function W which
takes time and it's going to return an
up double this is just a vector that
represents a column vector so you can
think of up that's just a vector that
stands up right if you know physics
you'll you'll know that there's more to
it than that now maybe we'll talk about
that okay groovy so if we had W in
principle we could compute its first
derivative maybe by hand but let's let's
pretend the computer can also do that as
in fact we will show in order to get W
into the Euler Lagrange equation we
would like to have W converted into
something that doesn't just give us the
coordinates of the path but gives us
that local tupple time position and
velocity or T Q and Q dot so you can see
at the bottom line here we want an up to
love time we apply our function W and
then we apply the derivative of W so
let's just pretend we had a Diop eration
we would do this so really this all
looks kind of scary but it's actually
kind of simple we start with W that's a
path function we want to find out which
one of those is real but we don't apply
T to it we don't go down the path of the
bottom we go on the path to the right
we're going to make up a function gamma
that will turn W from being a mapping of
time to coordinates into a mapping from
time to our local couple and that will
be the perfectly shaped thing you can
see following to the lower right there
we could apply L so that our Lagrangian
because that's what the Lagrangian needs
well we also need to compute the partial
derivative of the Lagrangian with
respect to a couple of its variables the
first and second counting from zero
so here we are we're looking at this
expression partial of L with respect to
Q you know why do we need to know the
names of LS formal parameters is that is
that ever useful to do a derivative I
mean if you change those which you
didn't have to go to rates and redo the
math well if you're doing this on paper
and pencil with slightest notation the
answer is yes but in the system of the
book they follow a spin back in 1965 or
an influential textbook called calculus
on manifolds in which you threw away all
the Leibniz curly D notation there or
rather the fractional sort of period
notation and says no no we differentiate
things we're going to use a subscript to
indicate with which slot or with respect
to which slot we want to differentiate
so let's get rid of all those fraction
things and rewrite the Euler Lagrange
equation in this form so slowly removing
it right into something that we can we
can code there and this just points out
that the operators on functions
pervasively in this book bind very
tightly to the functions they operate on
and this is what we've this is where we
are now by the way with this talk you
can interrupt me with questions I would
not bother me at all we're almost there
so now we have something that looks
closer to something we could write code
with because we're dealing with
functions and things that take functions
in and return functions out remember
gamma we created to adapt W to the
Lagrangian and partial sub two is a
operator that will take L and replace it
with partial L with respect to Q dot in
the libels form we've got partial 1
we're almost done except you have to get
rid of D by DT and that that says go
ahead and differentiate this blob this
expression blob with respect to the
variable T so we would call that an
expression derivative and that's a
little sad I wish I had a function
derivative how could I make that happen
it turns out the problem if you think
about it you follow the books x position
is we have a function if we have an
expression involving T because we have
applied our function to time too early
so what would happen if we just took the
application 2t out and did it later this
is a theme of the book it takes a while
to get it
one of the things that makes this whole
system work as we postpone applying our
functions to their arguments as long as
we can we work in a function algebra we
work with operators on functions and
then we have data that we want to put
you know solve in a concrete way then we
can do the applications already so now
that we took the application 2t out we
can replace that D by DT with the
capital letter D which just means
differentiate this function with respect
to its only argument so you could call
this almost if you wanted a point free
implementation or a point free
exposition of the Euler Lagrange
equation and we could write the code for
that now obviously we're leaning on a
couple of things here we haven't written
we don't really have a D function we
haven't written D and we have a written
partial but Sussman and wisdom did write
those functions for us and we could use
them and so can you but the point being
is that we now this function actually
this function here Lagrange equations
this actually is the implementation of
l'orange equations in this system it's
not vague
it actually works what makes it work
well first of all we have to do naira
size the heck out of everything addition
subtraction multiplication division sine
cosine tangent logarithm exponential all
these things have become multi fins
enclosure so that they could take you
know arguments of any kind so if you
apply sine to the symbol T it comes back
unev al you ated it comes back as sine
of T if you give it sign of a number
you'll get the number I have not
namespace all these things because I
want the code from the book to execute
basically out of the box that you can
you can do that modulo the fact that the
scheme way of defining a function is a
little different than closures defin so
defined deafen you have to fix that
yourself however closure has
destructuring of arguments and ski
doesn't and this turns out to be a lot
more fun so it's more fun to do this
enclosure than it is a scheme in my
opinion okay so let's try to cook up
let's what is what could we do okay
we're going to define our first
Lagrangian L
it's a function of local couple so you
see I'd used argue into structuring here
in the red it's a function of the tupple
time queue or the coordinates and q dot
the derivative of those coordinates and
that's going to be one-half MV squared
that's so easy well what about my path
function I'm going to need a path
function to substitute in I'm going to
make a literal function so X actually is
it can be applied to an argument if I
apply a literal function to a symbolic
argument I just get X of T that's what
it will happen but I can send that
function into the Lagrange equations and
I can choose the name of my time
variable and I'm just going to call it t
and what we'll come back is the
following expression after
simplification which is part of the
system and times the second derivative
of X applied to T is if the output and
remember with the Euler Lagrange
equations whichever makes that zero is
the thing that wins the the contest
there so we have MX double prime equals
zero which means that X prime is
constant so we have constant velocity
now any physics class would do this one
for you at it's boring right you know
you do the calculus of variations they
show you the shortest distance between
two points is a straight line thank you
we already knew that it was kind of
obvious we want to get further we're
going to go further faster right so
let's add a potential in here so now I'm
going to change my L function to say
well it's the kinetic energy minus good
old-fashioned MGH which is one of the
only things I remember from taking
physics in college potential energy is n
times G times how high it is above the
floor so I'm just going to subtract that
away because will occur on G and is
kinetic minus potential so I subtract
from my one half MV squared I subtract
MGH where I just called the coordinate Q
like in the last slide well I'll call
the path Y a literal function Y which we
don't know anything about and what comes
back at the following equation mg plus
my double prime equals zero if you
rearrange that you find out that Y
double prime is minus Qi it almost
begins to feel like this is working so
let's give it a harder problem let's do
the double pendulum here this is a good
old-fashioned physics textbook double
pendulum the coordinates are no longer
Cartesian coordinates the coordinates
are going to be the two angles theta and
V I mentioned there we got lengths and
masses and yes that bottom Bob could
spit around freely it's not in P
by the upper armature of this thing so
could we find the the kinetic and
potential energy of this yes with a
little bit of trigonometry right you can
just find we find y1 and y2 which are
the heights of the two masses and do the
MGH and add that together to get the
potential energy the kinetic energy T is
slightly more complicated because we
have to find the vector sum of the two
velocities they're multiplying them by
the mass and so forth right if we did
that though we could subtract them
notice I've got minus TV in this system
the genero cessation of the operators
has has swollen to encompass everything
so sure you can subtract functions in
this thing you could subtract operators
and everything else okay great
so I cook up my own little macro called
with literal functions and then we're
going to ask for the Lagrangian score
for this thing there and because my
because I have two coordinates I'm going
to create an up topple of the
coordinates fee in theta and my time is
just called T and what comes out at the
bottom you'll see is a down tupple of
the two equations which if all of this
were set to zero then that would be the
winning path for theta and fee because
now we have two coordinates right well
okay now we have a differential equation
though that you're not going to find the
solution to in a textbook I don't think
this one has a solution and if I got
this on a differential equations class
test I would know that I was beaten
right but uh there's another way to
attack this which is numerically there's
a function in this book which they
derive carefully I'm not going to go
into it today called Lagrangian
two-state derivative what does this do
I've given it the same arguments as
before right - T and V I'm just going to
set the masses and the length all to one
just to avoid some variable in the
result here and I'm going to let G be
the acceleration due to gravity and I
get this thing out of Lagrangian
two-state derivative what do I do with
it well it turns out to be just the
needful thing we can imagine our state
couple which is one of the key concepts
of this book it's time position and
derivative so T are two coordinates and
the dots of the two coordinates over on
the right the state derivative is the
derivative of all
those things with respect to time so if
you look at the first row T goes to 1
because DT of DT is 1 the fee in the
theta go to FIFA P dot and theta dot and
then we have an expression which maps
the velocities forward in time that's
something you can integrate with any
number of tools and so how are we going
to integrate this so we're going to go
next
well I just hope it's up to Apache
Commons map so if you want to integrate
it that way you can and you'll get
numbers back all the tech all the
beautiful equations you see in this
thing were generated by the system
itself there's a function called
pointing to tech and it will convert the
expressions it gets into text form but
it occurred to me that if you can
convert something to tech you can
convert something to JavaScript almost
as easily or even more easily so let's
take that expression we had in the
previous slide and pump it through arrow
JavaScript after we simplify it and do
the state derivative and all that and
now I get this expression in JavaScript
yes it's ugly but it represents that big
blob of derivative transformation in the
bottom of the previous slide in fact
well it has all of it right if you look
at the return statement the first thing
is one because DT by DT is 1 then we
have the theta dot d dot and then we
have the velocity transformation in the
bottom ok where does all this go in real
life if you're following along here we
can take a couple of initial conditions
but the JavaScript that I got out of the
last slide I've pasted into a tiny web
app I can click my things there and we
can go and integrate it and then see a
little tiny animation of this thing and
you know I really got excited about this
project when I got to this point because
this is realistic looking it does look a
bit like how you might expect these
things to actually move in real life and
then I thought well I wonder what would
happen if I made them stand vertically
so I'm going to carefully move these
both the 100 me and say go so you might
think of this as kind of a test of a
numerical precision at the system nor
the computer there
how about supposed to be a gentle blow
sorry for that sound
I suppose supposed to sound like anyway
I've got a shift gears now because you
this is a closure conference I'm going
to talk about like how did I get this
into closure and the answer is you know
slowly and carefully but but
delightfully so I could have just
mechanically ported the system to
closure I know enough about both
languages to say okay scheme does this
closure does that I thought I'll learn
nothing by doing that it'll be boring so
I actually tried to study and understand
how the system actually worked and I
wanted to tell you all about a bit a bit
about why I closed your turn out to be
the perfect thing and I and I actually
loved doing this and and it was cool I
hope I hope you will give it a try on a
rainy day on the links on the last slide
I explained that it was actually a
little daunting to go into the skiing
code for all this because there's a lot
of it in the system that goes to the
book there's a lot of scheme code in it
I had to decide where to begin I thought
well maybe maybe just maybe the
simplifier that was the wrong place to
begin because that's very complicated so
I thought maybe I'll do Tuffle
arithmetic up-and-down tuples and all
that stuff I messed around with that for
a while but then I found that Sussman
teaches another class he teaches the
class that goes with this book a physics
class he also teaches another class
called adventures at advanced symbolic
programming and the two topics that he
delves into our generic dispatch of
operations and and data-driven
transformation of s expressions and
those turned out to be a key by
following the lecture notes for those I
was immediately able to start working on
the system so I'll get into a bit about
data I'll skip this actually so what we
what we really do here in closure is
everything is uh now a multi method
right certainly x plus and all that are
multi methods and our discriminator
function i call argument kind and then i
use i have a bunch of def methods def
methods for every operation so that we
can multiply two numbers two symbols a
number in a symbol a symbol and a tuple
two matrices a matrix in a tuple to fun
and operator and a function all these
things can be multiplied so we enumerate
all the death methods there and we
implement them so the V argument kind
returns a short vector of the operations
there so I can have I can deal with the
fact that not every operation is
commutative and it depends a bit on the
order in which the arguments are given
to give you a bit about what star can do
if I have a Down tupple and I have an up
to pole
multiplying them but gives you the dot
product if I have a matrix that we're
not going to talk too much about that I
can divide it I can divide a vector by a
matrix to solve the linear system which
is actually pretty neat so if you look
at the second output there you'll see
the determinant of the matrix is hiding
under the quotient so that the equation
has been solved by Kramer's rule that of
course is factorial time but none of the
matrices in the book are bigger than 4x4
and so it actually works just fine for
them but don't use it as a
general-purpose solver their functions
if I multiply two functions I get a
point wise product of the functions but
if I multiply two operators like at
function composition this is an
important distinction that the book
relies heavily on I can multiply to an
infinite series it gives me the coachee
product of the series which I won't have
a lot of time to get into today how many
of you know about automatic forward
differentiation oh well I get to talk to
you a little bit about it if you study
differentiation with Lisp it's even
discussed in in sicp they do
differentiation with pattern matching
they'll look for patterns in the
expression tree and say okay if I see a
star node with things underneath that I
could apply the product rule or I can
pull constants multiply it out that kind
of differentiation would not work for
this application because we need to be
able to differentiate a function before
its arguments have been provided to it
that being the case again we each delay
the application as long as we can
automatic forward differentiation works
by creating a new number system called
the dual numbers it's very much like the
complex numbers the complex numbers you
have X plus iy and the dual numbers you
have X plus epsilon Y where epsilon is
meant to be infinitesimally small so
small but if you ever square an epsilon
it vanishes there are no powers of
epsilon beyond the first to
differentiate a function I've used this
now so look at the wrist is I'm
differentiating the function X goes to
sine of x squared okay
I'll apply that to Y it but later the
differentiation happens first the D
operator turns a function into another
function where we cook the argument by
adding an epsilon to it and we wrap the
result with capital e which says extract
the terms of the results that are linear
in epsilon so let's have a look at how
that would work I apply C rather it's a
sign of my post-ops on squared so first
we do the squaring and we find we got an
epsilon squared out in red so we throw
it away to get from the sign of that
thing there we apply that little idea
over there that f of X plus epsilon is a
lot like f of X except we add a little
bit of its derivative to it epsilon
times F prime of X well in this system
every function knows its derivative so
the sine function knows that its
derivative is cosine so when it gets an
argument a multi it's a multi function
and when the multi function
specialization for sine sees that its
argument is a type differential it knows
that it's supposed to replace it with
that f of X plus epsilon times F prime
of X so we get epsilon 2y times cosine
of Y squared finally the e operation
takes hold and throws away everything
that isn't multiplied by a linear
Epsilon and so we get the corrector root
about how does simplification work this
is a long topic well this I should say
that the the system kind of comes from
the MIT late twentieth century
historical project to do symbolic
computation the idea that they had to do
this was to use it to first to simplify
things there are two kinds of
simplification assistant does one is
cancellation over the fraction bar in
order to make this happen they convert
everything into a rational function
a sort of generic polynomial then they
find the greatest common denominator of
the two giant polynomials and divide
that out of the top and bottom and then
set everything back up the way it was
before
with the cancellation having occurred
dividing or rather finding the greatest
common denominator of two polynomials
and with a large number of in
determinants is a lot harder than you
might think
and the algorithm might have in the
system as in the closure side that you
can download today is fairly naive I use
the recursive Euclid method to do this
the system that you get from Sussman and
wisdom uses a more advanced algorithm
called Zippos algorithm which I haven't
poured it over because I don't
understand it because the book that
describes it cost one hundred and eighty
dollars on Amazon and see I am really
sick of dealing with polynomial GCD at
this point it took a long time to get
this right even in my sort of Lane there
so once I was done with that I put it
down but the more fun simulation that
you're probably more curious about is
the rule-based simulation again from
their class adventures and symbolic
programming and from the implementation
here they have a sort of a rule-based
Converter language where you can
describe situations that you would like
to replace with other situations so this
top rule is trying to get square roots
out of the denominators of fractions so
it's a we use keywords to represent
variables and if a keyword ends in a
star that represents a sequence of
unknown things that can be matched so
this said if you see a quotient where
there's a bunch of things multiplied on
the top and multiplied on the bottom and
somewhere in there you find a square
root of a thing and a square root of
another thing please replace that with
the square root of a over B on the top
and then take all the rest of the stuff
you skipped over and leave it where it
was and the rule on the bottom a bitch
will recognize this is good old sine
squared X plus cosine squared X equals 1
Lee we do that there I have two laundry
machine because the GCD simplification
to clear quotients of things that exists
on the top and the bottom plus all of
this are applied in this giant washing
machine thing with many many other rules
will run over and over again until
everything stops changing and in fact
there are many if you go back
archaeologically in the code
a whole nother topic to find that
they've tried many different mixtures of
the of the system and to the settled on
the one that they they like so what
worked well foreclosure was it was
absolutely critical that you could add
behavior to existing objects in
particular
none of the system works if you cannot
make a new thing
act like a function so the ability to
override or rather to to implement AFN
for a new thing was critical in the
scheme system they send or use MIT
scheme they have a thing called an apply
hook which is something you can attach
to an object and then if the object
should ever after that point appear in
function application position the apply
hood gets dispatched not very functional
but it works for us we're much happier
to implement IFM for the types
themselves rather than have to hook it
up each time I love the fact that up
tuples and down tuples can be given the
ability to D structure as function
arguments by implementing IC Keable I
think as the the implementation air I
forget exactly how it works
we need laziness in order for the system
to work well because infinite series do
you enter into the book in later
chapters to do polynomial greatest
common devisor you absolutely must have
large integer arithmetic because the
intermediate rational function
expressions that are generated by that
GCD process can have an explosion in the
magnitude of the thought of the big
coefficients and there's a the the
that's actually as a topic of research
you can read about not mine but others
you know I this is my first big closure
project or my first closure project of
any size at all so I had I hesitated
between def record F type plain old map
do it in Java I tried them all and I'm
not even sure at this point that I made
the right choices but I it was really
critical to have a surface where I could
pick different things if I if I hadn't
had the ability to to quickly shift
between one thing and another I don't
know if I would have persevered but
always there was a fresh unexplored
alternative and eventually I was able to
get all the code in the books
cute which which makes me happy and that
was what I decided maybe you'd be
interested in hearing about it oh and
testing I have over 1500 unit test cases
I started doing that at the beginning
because you know I'm an industry and you
know the value of testing if you're at
all in industry I could not have
completed this project without writing
tests from the very beginning I needed
to change representation I needed to
make new decisions to try things out
every time I would make a change a test
broke and maybe happy because I thought
you're looking at the right things okay
have you got to this point I don't know
if I have any more time I think it a
little more time I thought I would take
you deeper into the book so I covered a
bit about chapter one which is
Lagrangian mechanics chapter two is the
physics of rotation which is fascinating
we're going into chapter 3 which is
Hamiltonian mechanics Hamiltonian in
Lagrangian mechanics you're taught you
are interested in the coordinates and
the derivative of the coordinates
position and velocity in Hamiltonian
mechanics you're interested in the
coordinates and the momenta that are
conjugate to those coordinates isn't
that just the derivative of the
coordinates well that depends on what
the coordinates are with these angle
coordinates you know n times V isn't
necessarily the real momentum but in
Hamiltonian mechanics you want to know
that there's a clever trick that you can
use to turn a Lagrangian into a
Hamiltonian and there's a Hamiltonian
two-state derivative operation there on
the lower left and these are these again
or right there and they work and what I
get on the right-hand side here at the
bottom for this driven pendulum here I
forgot to tell you what the driven
pendulum is you can see it there this is
the Hamiltonian state derivative right
so I have T and then the coordinate oh
there's a Lydia excuse me a differential
equation for the coordinate data and a
differential equation for the momentum P
sub data what we're going to do is we're
going to take a simple pendulum and
we're going to vibrate the pivot that is
hanging from with a sine wave and that
will allow us to explore chaos and
residence the way we're going to
superheroes
the book explains a modern technique for
exploring the dynamical states that the
system could enter called a plonker a
surfaces section what you do is you pick
T a period of or an interval of time
that you're interested in and for our
driven pendulum example that T is going
to be the period of the drive then we we
start we pick some initial conditions
that that leftmost blue dot and we run
the simulation through the integrator
and at the time slices bounded by T or
selected by T we're going to plot the
position and momentum coordinates the
Hamiltonian state derivative gave us and
then we're going to smash them all
together into like a portrait it's just
a flat portrait there and so that's what
we're going to do over here I can go
back to the driven pendulum example so
on the Left I have the plonker a surface
of section for the driven pendulum up
here you can set the frequency of the
drive and over here you can set how long
of a simulation you want to make there
so by clicking at different points on
clicking different initial conditions
that wait here I want to you out there
you could go back here and just do one
morsel I was going to show you oh oh so
the left-hand surface of section is
pasted out of the book so I wanted to
show you that the code we're getting out
of this system is is doing the same job
so you'll be able to see that sort of
hourglass shape on the right the right
hand is from paper by jack wisdom on the
chaotic motion of Enceladus which is one
of the moons of Saturn so the people who
created this book are actually using it
in their own sort of day-to-day work to
understand dynamics which i think is
pretty fun and it given me the sensation
of having come into contact with you
know what researchers and dynamics are
actually doing today and that's been
that's been kind of rewarding anyway I'm
going to change the drive to 1.8 Hertz
here I can find it and click around you
see you know in the center there the
dynamics aren't very interesting but but
sometimes you'll find interesting little
little cavities of dynamics here you
might notice that sometimes when I click
I get this blue mist that's chaos so if
I if I start the simulation in the blue
mist it kind of goes around faster but
there's there's obviously some chaos
here and at some point you might see
it's a little bit hard to predict that
motion if I click in the center like in
one of these areas and run the
simulation I haven't given it enough
initial energy to get very complicated
motion out of it there what are these
what are these a little quartet of lobes
over here this is this is what you see
on the plonker a services section when
you have a resonance if you look at this
thing
if you you can see that there's a
correlation between the bouncing of the
drive and the bouncing of the pivot or
the ball at the end right so the drive
is kind of going one two three four in
the pivots going at half that rate I'll
run it again there so this is more like
a child on a swing this is what you do
when you want to engage with the natural
frequency of the system and you can see
that when the drive see is at the tip
top that the the Bob will either be all
the way at the right or all the way at
the left and not anywhere in between
there's another sort of a symptom you
could see let's crank the frequency up
there and now we get when you when
you're in a situation like
if basically it's just going to whip
around right okay fine but if you turn
the drive up a new thing starts to
happen in a corner over here six point
eight not enough so I'm going to
increase that maybe eight point four now
we have something new which is the
stability of the inverted pendulum it
turns out that if you shake at the base
of a pendulum hard enough it is stable
to vibrate in the upright position like
this and what I find what I find is most
fun example on this thing as you go just
leave the zone of stability of the
inverted pendulum maybe I got too much
drive there what happens if we aren't
quite there you can get sort of a we
don't have that do it you'll see that it
almost wants to stay up but not quite no
it's not going to do it no and actually
sometimes when you have the K ah twenty
head the chaos if you have that blue
mist sometimes we won't get up there and
stay there for a while but then chaos
takes over it will at some unpredictable
time in the future you'll fall back down
where could be good next I got like
three minutes left so I want to take
some your questions I'll say one thing
the author's word another short book
they distributed a PDF called functional
differential geometry which I should
have spelled out on the slide for you
and it takes this system and uses it to
study special and general relativity
which I think which I would love to know
more about so I'm going to go ahead and
do that boy do I wish spec were around
and I started or had where around when I
started this or that I understood it
because the scheme code they don't have
any concept of type at all you know you
might function might take you know you
have a thing it's all just basically the
sort of console with a tag on it that's
it and the functions they have they
hesitate between different
representations and I had to sort all
that out it'd be fun to see this in
Jupiter I I don't know enough physics to
say it sure seems to be like the system
would be good for quantum mechanics as
well because there's all this
Hamiltonian stuff operators in a lot of
algebra and so uh you know I should take
some questions I wanted to show you one
weird trick and I'll shut up
okay you might have noticed that you
know the expansion for e to the X as a
series looks a lot like the expansion
for the Taylor series of any given
function that's sort of not a
coincidence that
because e to the X is its own derivative
well what if we rewrote this expression
just a little bit as you look at the
Taylor series on the second line there
you see H squared over two times F
double prime so it sure looks like when
you have H squared you have the second
derivative when you have H cubed you
have the third derivative and so on
using our D notation I could pull the
different derivative out and H and I
could say okay great what's really
happening in each step is I'm
multiplying H two times and I'm
differentiating twice
we're both blind by H three times in
differentiating three times so we could
call that the operator H D and indeed an
operator that just has a name in this
system means multiply by me and we
already know that D operation is
differentiation and again we win when we
can postpone applications so in the
fourth line there if I pull the
application of the function 2x all the
way out then I'm left with an infinite
sum of functions as a Taylor series and
if we also were to agree that HD to the
zero power with the identity operation
then I can write this as a pure power
series of functions which is what we can
do there and in fact that thing in red
the power series of functions we're
going to define that as being e to the
operator so you can take any operator
and you can take and you can find e to
the operator it will generate that power
series so does this work yes it does
I've multiplied the symbol H by the
differentiation operator I exponentiated
it I applied it to the tangent function
and then we apply all that to 0 and what
do you get you get the Taylor series of
ten at the point zero any questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>