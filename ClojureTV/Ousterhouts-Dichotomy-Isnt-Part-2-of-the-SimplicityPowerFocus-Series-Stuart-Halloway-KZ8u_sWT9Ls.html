<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ousterhout's Dichotomy Isn't (Part 2 of the Simplicity/Power/Focus Series) - Stuart Halloway | Coder Coacher - Coaching Coders</title><meta content="Ousterhout's Dichotomy Isn't (Part 2 of the Simplicity/Power/Focus Series) - Stuart Halloway - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ousterhout's Dichotomy Isn't (Part 2 of the Simplicity/Power/Focus Series) - Stuart Halloway</b></h2><h5 class="post__date">2013-01-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KZ8u_sWT9Ls" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is Stuart Holloway and I'm
going to be talking about power I have
the advantage of t-shirt design to back
my plate and for those how many of you
were here last year all right wow it's a
terrific
I think everyone's back every single
person is pretty cool so last year I
talked about simplicity and sort of my
goal in talking about simplicity was was
twofold
one I think it's it's terrifically
important principle in software design
and second I wanted to antagonize rich
into saying something even better about
it so I feel like I feel like sort of
mission accomplished on both fronts so
we'll see how things go this year if
anyone's trying to guess what I might
talk about next year the circles are
kind of a dead giveaway and in fact the
game plan for these kind of talks is
sort of given as well if you want to
know what the word power means you could
always you know do worse than starting
with the dictionary so power eventually
works back to the Latin and it means to
be able that's pretty good when I'm
writing software I want to feel powerful
I want to feel able how many people
would say they feel powerful when
they're working in closure that's a
great feeling isn't it it's a terrific
feeling it would be nice though to have
some rigor around what that means and I
think that that rich has done a great
job of putting rigor around the word
simplicity and and putting it into an
objective box separate from easy which
is in a much more relative box and so
I'd like to do the same thing today with
power
well this definition of power is the
etymological basis but you could also
look to the sciences so if you're an
electrician there's actually an equation
for power and you know what people say
it's not the V that
gets you it's the eye right and there's
also an equation in physics and it
actually comes down to the same thing
right
it's literally the amount of work you
can get done per amount of time amount
of work you can get done her amount of
time and this is a an important
elaboration on the notion of feeling
able right if I told you I could build a
pyramid in 10,000 years you wouldn't
think that I was very powerful if I told
you that I could build a pyramid in 30
seconds well that's right you have to
you have to specify right that's the
Delta W all right the Delta W matters
and the delta T matters as well so power
is work per unit time the other thing
that you'll find out if you look at
those definitions from electricity and
from physics is that work is directional
work is towards something and by
implication not towards all the other
compass points all right so when you're
working you're going somewhere and if
that's not where you want to be going
then working is it's not necessarily
helping you hey the old works smarter
not harder
sort of notion so that's the English
language in the science basis for the
word power what about what computer
scientists say about the word power I
have to say that I feel like I'm in
amazingly elite company being in this
room full of people right I don't feel
like I belong here I keep looking at
myself and saying should I really be
allowed in this August company of great
thinkers and in in numerating expressive
power which is what I'm going to talk
about right now I feel like I finally
found something where I can contribute
to moving the frontiers of computer
science forward it turns out that nobody
has actually categorized fully in my
mind what expressive power means in
computer science and there are in fact
seven hard categories of expressive
power and some of them have been
investigated to some degree
by academics and others have been you
know relatively ignored
probably the most common continuum of
power is in some ways the least useful
one it's the one that tells us that all
of our programming languages land at
about the same place on the power
spectrum which is which one of these
when we actually program in who works in
finite automata all the time no ok
anybody worked with a Turing Oracle on a
regular basis right where do all of our
programming languages land us Turing
machine so that's one one of seven sort
of acts you use a power that you might
look at and as you move down this list
you become more powerful and I'm going
to start using the word expressive for
this in terms of things you can express
or things in this case things that a
language or grammar might recognize
perhaps there's another one the sort of
functional power curve if you work your
way you could start with the very
austere lambda calculus and you could
work your way up through a series of
different enhancements to the lambda
calculus and end of course in the end
zone which is clearly hindley-milner
type systems right that's as good as we
can get on the functional power axis or
you could take the logic powertrain and
you could look at different orders of
logic and talk about well you can
express that in a first-order logic but
you can't express it in a zeroth-order
logic or you can say that in Prolog but
you can't say it in data log with
negation now some of you may not be
familiar with data log with negation
that's also knowable by its legacy name
which is the relational model plus
recursion or you could talk about model
power there's this great book that
breaks out different models of
programming by saying we have this basic
purely functional declarative model on
which we can add a few concepts data
flow variables laziness and cells and
you can mix and match those things each
of which gives you additional power one
of the things I really love about this
book is that they have this picture
that's showing all these different kinds
of power that you might have that puts
Haskell in the middle of the power scale
yeah Wow so there's all these things
that are more powerful arguably by this
definition than Haskell v kind of power
in computer programming is poetry power
and poetry power has to do with what you
can say in a poem and you have really
unpowered poetic styles like the sonnet
right because the sonnet does really
limits what you can say and on the other
hand by far the most powerful poetic
style is what free verse it's not limit
at all which is why Robert Frost in
poems like mending wall' is far more
powerful than a Shakespearean sonnet for
example the sixth kind of power is music
power and again computer scientists
don't spend enough time thinking about
this one I'm not sure why but you look
at the trombone and you can say you know
the trombone is strictly more powerful
than the piano because of its ability to
play tones semi tones and tones between
tones right because you have a slider or
as the piano is relatively more limited
to things that are right on the pitches
on the scale on the other hand the
guitar it's definitely more powerful
than the trombone because it can play
more than one note at a time yet on the
other hand the piano is clearly more
powerful than the guitar because it has
a broader range of notes from bottom to
top then you could play on a guitar and
what you realize is that these power
scales start to end up feeling like
rock-paper-scissors- lizard-spock which
is the final power scale that I'm going
to offer it right X is powerful more
powerful than Y is more powerful than Z
and where do you end up and the result
of this is that if you look at people
talking about feeling powerful in their
programming language you sort of run
afoul of this notion of expressiveness
versus this notion of getting work done
per unit time and let me just be clear
I'm going to come down in favor of
getting work done per unit time I
that's what that's where I want to go
with power but the conversations in in
software are about expressiveness
expressive power is kind of redundant if
you're sufficiently exploiting what does
the word power add so I may just use the
word expressiveness the rest of the way
and so where do we go wrong in talking
about expressiveness that doesn't allow
us to translate that into some reliable
objective shareable conclusions about
actually feeling powerful and getting
work done well the first problem is
we're talking about Delta W Delta T but
whose time whose time do I care about
right here are two equally powerful
representations of the number 42 as a
programmer which one of them do you want
to work with now but which one is which
one did you mean when you said that so
and once you come up with when you start
thinking about this and then this is
where people sort of punt and go well
I'm going to use the word powerful to
describe what I like and we're going to
agree that all the computer programming
languages that we use are Turing
equivalent and so we don't have anything
to say and in fact there's this notion
of a Turing tarpit right which is a
programming language which is touring
complete but which is so irritating
right it's deliberately designed to make
you feel not powerful in the sense that
I'm talking about like you are unlikely
to be able to have a good Delta W over
delta T now this is a hello world
program in a Turing tarpit language I'm
going to count to three and if you know
the name of this language I want you to
shout it at the top of your lungs one
two three all right see I didn't swear
so when you think about time you really
think about programmer time versus
computer time right if I if the computer
can do a lot of work so I don't have to
do very much work that's often going to
be a really good trade-off and in fact I
love this the actual definition of a
machine is something that manages power
to accomplish a task so when we're using
machines a machine is something that
redirects power right it changes the
direction of a force to help you
accomplish a task and I think equally
important to us I mean still even in
this picture this is a nice cigarette
rolling machine we still care about
who's standing at the end turning the
crank right we want the power source not
to come from us either the second
question is what direction is your power
taking you all of the different notions
those seven notions of expressiveness
that I talked about are power in some
direction but are they power in the
direction of some application or program
that you're trying to build I want to
think about the number of times that I
was building a web application and my
stake holder said you know the users
really like this but I'm not sure if the
type system in your language is
decidable so it just doesn't come up
very often right ditto for any of the
other things that have to do with power
that we would talk about in an academic
setting likewise nobody ever asks me to
perform a poem or play sunburst
jubilation on the guitar which I may
take a year off of my life at some point
and try to do but not today it's also
the case that even people who are
capable of working with the most
powerful in the expressiveness sense
things actually don't necessarily love
it so Robert Frost famously said writing
free verse is like playing tennis with
the neck down that doesn't sound like a
powerful feeling necessarily that sounds
more like dancing on thin ice kind of
feeling associated with power and in
fact and this is a really good piece of
news because you know sometimes we have
problems in the industry that haven't
been
Sault by the w3c but it turns out that
they have actually solved the power
problem with this piece of advice when
publishing on the web you should usually
choose the least powerful or most easily
analyzed language variant that's
suitable for the purpose I didn't even
know there was this whole thing where
they just had findings right there these
w3c findings and so this is one of their
findings which is power is bad so why is
power bad why would power possibly be
bad well power
it turns out is in many cases going to
be something that might potentially
limit your ability to compose things or
your ability to reason about how things
are going to work if you made a laundry
list of things that made it to the
status of an X considered harmful essay
these are all things that are strictly
speaking things you could talk about in
terms of expressiveness I'm sorry your
language sucks it doesn't have the
expressiveness to say go to oh your
language sucks it doesn't have the
expressiveness to allow you or force you
to do explicit memory management right
those are all expressive powers those
are all things that you can say do you
want to say them
I don't know it's that's the hard part
right it turns out that feeling powerful
as a developer comes from being able to
combine and sometimes constrain these
various expressive powers not always
constrain I'm not saying that we ever we
can never play tennis without a net
right sometimes you want to play tennis
without a net you want to use the most
powerful thing that's hard to compose
with other things and you know does all
kinds of nasty stuff so what is
osterhaus dichotomy have to do with any
of this so osterhaus wanted people to
use tickle instead of C and as part of
his marketing campaign for that he laid
out this distinction between two kinds
of languages now on the left here you
have languages really dominated by C at
the time but have a set of
characteristics they're static they
allow you to do arbitrarily complex
things with data structures they're
compiled you you use them to write
independent programs and then on the
right side you have dynamic languages
and when OCR how it made the original
argument these languages tended to have
limited data data structure capability
they were interpreted and they were used
for glue code and their languages like
tickle and Ruby and Python and so I
would ask you where on this hierarchy
should we put closure this is one of
those Zen questions that needs to be
unasked this is a crummy hierarchy and
what's wrong with it well anybody who
saw the simplicity talk what's wrong
with this either might talk or Rich's
simplicity talk what are these things
these are two big compound things right
this this characterization of the world
that's divided things sort of into two
categories which it may be the case that
there's a matrix here and that every
possible spot on that matrix might be
occupied by some language or some tool
so in the time since this idea was first
pushed we've had some newer thinking
about what it means to be powerful and
there was an essay that certainly
influenced me a lot
Paul Graham's essay Revenge of the Nerds
this is the one where he enumerates nine
powers that Lisp as and if you look at
those powers I've sort of grouped them
here so that the seven powers on the
left are things that really a lot of
programmers have access to today and the
two powers on the right are powers that
are still somewhat exclusive to Lisp we
could augment this list right this
doesn't have to be our list and if I
were gonna start augmenting this list
this is actually not my purpose today
but just a few things that I might throw
in there if I was talking about
capabilities that closure adds over the
ones that grandma numerated certainly
programming with values and a model for
identity and time you might want to talk
about polymorphism and there are
probably a lot of others that you could
put in here and all of these powers are
abstractions that you use when you think
about how to make a system right I'm
trying to do this I'm going to align
recursion and dynamic typing and garbage
collecting expressions I'm going to
compose those things together in order
to solve my problem and if those things
provide a nice basis for work I'm going
to feel powerful if they don't less so
so how would we measure a stack of these
I mean presumably we could make a list
of these for some other programming
language or some other style or some
other environment how are we going to
make that list and have any useful basis
for comparison I have three possible
proposals for that based on reading what
other people have said and thinking
about it some the first one is concision
if something allows you to express
yourself briefly and someone else has to
do the same thing in a much more
elaborate way than you're winning a
trivial goofy example was my
zero versus forty two right that kind of
I have to do something really long to
get some work done and in fact that's
the argument that Paul Graham makes in a
separate essay where he basically says I
think that maybe concision is power
right just full stop another way to look
at it though is having something to do
with locality if I have a program that
does something and in order to take
advantage of or if I removed a feature
from the language I would have to
reorganize the entire program in other
words there wouldn't be local changes it
wouldn't be just we've picked a longer
or a shorter keyword for something but I
couldn't even organize my program the
same way without this thing then we'd
have a problem a possible good example
of this would be if we took closure and
removed the identity types right so we
remove all the identities and say you
know closure is gonna be purely
functional except for Interop and if we
did that it store incomplete right you
can still write the program's you're
writing today eventually but you would
have to reorganize your programs you
couldn't make a set of local changes one
by one throughout your thing it would be
the kind of thing that drives you crazy
in the oo world where you talk about in
terms of encapsulation right it would be
a pervasive change to deal with it if
that feature was removed and finally
simplicity in the sense that a set of
powers are taking you in a direction and
if a power is complected then it's
taking you in more than one direction at
once right by definition and that may
not let you go as efficiently as you
want to go in the direction that you
want to go I could talk for a whole hour
about that alone but I feel like the
simplicity talks are already out there
and I think that that's that's a part of
that point right the simplicity makes
you feel powerful
because you are going exactly in the
direction that you want to go when
you're using simple tools now it's not
really clear whether Paul Graham's list
of powerful things works for anything
other than selling one startup to Yahoo
stores but
but in the time since then we've kind of
had this Revenge of the glue where a
couple of things have happened certainly
it's the case that these glue languages
are now used to write full independent
programs I people build applications in
Python and Ruby and PHP and so forth all
the time and these languages have picked
up all manner of object-oriented or data
structure capabilities and features and
so it might be tempting to well first
off you say if anybody finds a really
good picture of a glue monster I would
really love to add it for this slide we
could go back and do that I could not
find a picture of a good picture of a
glue monster on the internet but I loved
that the other this notion that we're
building all of our programs entirely
out of glue there's no wood or cement or
nails or anything in them anywhere so
sort of the question is hey first off in
some ways osterhaus has one paul graham
has one people are building with a set
of more powerful abstraction than we
often had on our tool belt ten years ago
and we're moving more and more arguably
towards these glue languages and so it
pays to ask what we've lost what's
missing from this world on the right
side here and I think that one of the
choices that you end up making there is
that you say you know what I'm gonna
write my system this way I'm gonna write
the application part of my system this
way but the entire system is not going
to be written in one of these languages
right what's not gonna be written in
Ruby in a rails app the database right
the database probably the message queue
system there's all kinds of you know
critical performance subsystems that are
not going to be written and conceptually
what you do when you're working in a
higher-level language that doesn't have
some urgent capability you need for some
tiny part of application is you can jump
out to a foreign function interface and
I think of a foreign function interface
as being this way to dodge bullets right
and it's awesome right this is not an
unviable way to build software quite the
opposite
it's entirely viable to say that 90% of
my work is doable in this very
expressive very close to the problem
domain high level language but 10% of my
problem isn't doable there and that
number will vary depending on what kind
of thing you're working on and I can get
to that through a foreign function
interface now we've gotten all
distributed lately so sometimes that
foreign function interface is now more
of like a JSON service or something but
conceptually it's not different right we
can punt some part that we're not able
to do over to the foreign function
interface so what's not glue and this is
where I think that post routes dichotomy
stays with us and causes problems and I
mean most of this stuff has all kind of
gotten fuzzed and munched in people's
heads and doesn't matter but we are left
with this notion that what you need to
build the hard stuff is a static
compiled language and that presumption
is borne out by a lot of applications
where the relatively easier parts are
built in dynamic languages but they
eventually call a database that's
written in C or so forth right so
there's anecdotal evidence for this
perspective but if you think about what
makes a platform powerful if you
enumerate the capabilities of say the
Java platform what does the Java
platform have what does it made of
underneath you have classes and
interfaces and primitives and byte codes
and core types that are in the system
right you actually wanna be able to use
the types that are provided may be
library things is there anything in any
of those things that requires static
typing or a specific model about how
compilation or interpretation happens no
right it's a historical fact that a lot
of systems that give you direct access
to platform capabilities do so through
languages that are statically typed and
compiled but that doesn't have to be the
case and so closure aims to provide full
platform power
I mean rich has already pithily
summarized this in the past by saying I
didn't write closure to replace Ruby in
my day job I wrote closure to replace
Java in my day job
aspiration of closure is to say that we
do not have to dodge bullets right we
want to have the full power to control
the matrix so how does this help
that's a nice 25 minutes while I drink a
beer just Rama long about power what
does this help you do in thinking about
what's happening in the closure world it
helps you I think when you're learning
closure to understand that this is a
goal because it explains things like
these paired api's like there's some API
that represents an abstraction that we
want to use reify and then there's some
other api proxy that looks like this
sort of ugly mutant side version that
that doesn't have all the same beautiful
characteristics of refi and what's going
on there when you see those things they
are often about accessing the platform
right we still want to be able to access
the platform and ask the platform to do
things but even when those things don't
fit our notion of simplicity
if the Java platform in all its
primitives already were in our view
simple then the things that closure
built on top would entirely be thin
superstructure II type things and so to
the extent that you believe that
closures approach to simplicity and the
things that it calls out in that fashion
deserve to be so called out if they're
not mirrored down at the level of the
platform that closures running on you're
gonna see some ugliness down there where
there are forms that are designed
directly to a target that likewise this
helps you see why things like protocols
and def type or a priority a protocols
and def type let you write closure in
closure which is a great example of
having a guarantee that you have
sufficient platform power right if you
can write closure and closure that's
pretty good evidence that you actually
have good access to the platform
probably the one that people ask the
most questions about is this also
explains the 1.3 numeric changes and
I'll take that separately in a moment so
let me come back to that one it also
explains and this one is a
is one that people miss a lot when
they're learning closure the complete
absence of wrappers enclosure closure
does not wrap string does not wrap
primitives it does not wrap Java classes
in general because once you're in that
game you're automatically in a world
where there's a layer below you that you
need to go to if you're actually
targeting the platform part of the
reason that this is confusing is that
people use the word wrapper very
casually I'm talking about putting
something around something and claiming
that they're both kind of the same thing
which happens a lot in some other
languages and is an asthma enclosure
there's also people use the word like
Stuart's here use the word wrapping this
morning casually to talk about wrapping
a pushback reader on a bufferedreader
those kinds of things that's not the
kind of if we're gonna use the word
wrapping for that we're gonna put some
asterisk aside and say that's not
necessarily the same kind of thing that
also may just be required by the fact
that we're on the platform in that case
as well understanding that power is a
design goal of closure and I'm gonna use
the word platform power to talk about
this also helps explain what's happening
in closure versus closure script and
what differences you might expect to see
there when you think of closure in terms
of the abstractions that face the
programmer all right all the beautiful
things that we compose together to make
systems then every new dialect of
closure is going to provide the same
ones unless they cannot be delivered on
the underlying platform in which case
they just won't be there all right the
last thing you want to have happen is
have an API that sort of looks like it's
doing the same thing but not this also
may help explain why you know I want to
take my code and transparently take it
from here to there is not a goal what
happens to platform power if you make
that your goal right if we said you know
the biggest thing about closure and
closure script and closure on the CLR
was you're gonna take full programs and
just drop them from one place to another
and have them run you immediately have
bought the game of building a bridging
layer underneath and now you're no
longer targeting the power of the
platform it also explains the one place
in my view where closure deliberately
has compromises with simplicity right if
there is something that the underlying
platform
that might be needed to write an
application that achieved maximum
performance or parity with Java and that
thing isn't simple then it may be
exposed right because that thing needs
to be there it needs to be there to do
things like writing closure and closure
now let's talk for just a moment about
the numerix so closure has always had or
for multiple releases as long as I've
been involved with it has always had all
three different ways of thinking about
numbers
the unchecked way which is the way Java
works right party on add numbers
together if they overflow you know stuff
happens the promoting way which says you
know we're gonna use numbers and if you
add together along and along and it gets
too big will magically promote to a big
integer and the checked way which says
we're going to approach the speed of
unchecked ops but we will throw an
exception if you get in trouble a lot of
people a minority but a non-trivial
minority really liked promoting being
the default why do they like promoting
being the default it made the Fibonacci
demo really easy all right promoting I
hope you have the pro mini-map in the
fibonacci demos is super easy but what's
the real problem here to begin with what
puts us in this boat is the lack of some
kind of fixed num on the JVM because you
know when I first thought about this I
really thought about the speed column
right you know the promoting versus
check to being about the speed come but
it's really equally about the type
column Java can work with primitives if
you're gonna have a language that's
gonna do everything Java can do that
language has to be able to work with
primitives if that language starts
working with primitives at any point
then you have to accept that only one of
two things can happen if you overflow
right because your type signature
constrains you as a developer you don't
see this right the developer you're not
looking at the type signature of
whatever the compiler is making
eventually under the covers but as a and
under the in that implementation detail
you have to make a choice and if you're
going to allow
the represented representation of
primitives and if you're in allow it to
be fairly pervasive and get performance
benefits from it then you have to make
the choice that closure makes in 1/3 now
the good news is that from a expressive
power standpoint nothing has changed all
capabilities were present in one to all
capabilities are still present in 1/3
what is the default is a little bit
different when we made this change we
tested dozens of open-source projects
running their tests running their test
Suites against the change guess how many
things we found where you needed to have
more than 2 to the 63rd things testing
across 20 different projects he has how
many bugs we found not I this is not to
say that you don't want to have
promoting math in some cases and this is
also not to say that this is this
doesn't have the nature of a trade-off
but it's a trade-off that is easily
understandable from a background of we
don't want to make the closure is out of
bounds for certain kinds of application
development trade-off there are a few
instructive exceptions to the power rule
so one thing you could say to quibble
with me about this is to say well I can
write a Java program that will emit the
stream of byte codes that you cannot
make a closure program emit all right so
there's not full fidelity in that sense
every single thing that gets added to
closure passes through the filter of
somebody thinking it's important enough
to do which is not just about who this
is good it's also about it's worth the
cost and it's worth the engineering
effort one of them that has come up
recently for me is creating of
interfaces if I'm going to create an
interface right there could be a really
awesome fleshed out def interface form
and closure that had all the
capabilities of Java's interface
declarations it would take somebody some
work to make that right so the cost of
introducing that into the universe is
nonzero what would the benefit be of
having a way to declare interfaces in
closure that had full fidelity to
everything you could say while declaring
interfaces in Java
not typing in Java but and that's really
it because the only thing that Java is
actually concise at is interface
declarations if you look at it if you
look at it every single word in a Java
interface declaration is actually
required and actually means something
there's no you must fill out this form
in triplicate anywhere in an interface
declaration but also ask yourself when
you're writing an interface declaration
what are you making you're making a
header file for someone to consume and
we are trying to convince the ninety
nine point seven four percent of people
who are still using Java as their
primary JVM language to consume our jar
file who wants to hand them their header
file as a closure file and say all
closures not different at all you can
just use this jar file and then there's
this thing all surrounded with
parentheses as their header file right
the interface is the last place in the
world that I want to make Java not look
like Java I want it to look exactly like
Java and I'm absolutely willing to type
that in in fact even if it was ugly I
would be willing I want to be able to
hand that to people and say look it's no
different this is exactly the same thing
you would have consumed if I had written
the library in Java to begin with of
course there won't be any methods with
the set and the names set on them but at
least structurally will be the same
there are some details of implementation
inheritance that can't be duplicated in
closure implementation inheritance is
evil if there was a compelling reason to
make it available in closure than
somebody could go and investigate that
and propose doing the work there hasn't
been there are bytecode operations for
manipulating integers separate from
Long's those are currently not directly
supported and again there's no there's
no use case evidence that there's a
performance win and there is an
engineering trade-off right there's work
that has to be done to make that happen
it's possible that you might agree with
everything that I just said I actually
don't agree with everything that I just
said I try to insert about 20% outright
lies but it's possible that you might
agree with everything that I just said
and still not feel very powerful writing
closure code there are still some things
that you could trip up on for example
the library ecosystem certainly makes
you feel powerful to the extent that it
works but there are a lot of questions
there does this does the library that
does what I need to do exist if it
exists how do I find it how does it work
how do I deploy it who can improve the
answers to these questions and this is
an example of a category of questions
that I might summarize as okay rich we
got simple and power but can we please
have just a little tiny bit of easy
somewhere it's just a smidgen I'm just
gonna I'm just spitballing here maybe
some error messages maybe some more
sample code maybe you know maybe some
better story for you know I push a
button and my code is magically on the
Internet five seconds after I decide
what my business model is maybe we need
to have a more beginner friendly
environment and the cool thing about
this is that if simplicity and power
have been done well where do the answers
to most of these questions actually live
and if you think about it actually got
these sort of broken out feeling
powerful might come from expressive
power it might come from expressive
power from the language core so working
with pure functions and persistent data
structures it might also come from the
expressive power of some awesome library
like quartet logic you're going to feel
powerful if you have platform power
right so you have the ability to access
everything you need on the platform you
don't have to go foreign function
interface to solve your problems you're
going to feel powerful if you have
libraries there when you need them and
you're going to be powerful if there are
all kinds of creature comforts in play
the red things on this slide represent
things that's still bottleneck all the
way through rich before they change and
this is a good thing and we should all
thank him for it it's an awesome thing
right that if anybody wants to live in a
language run by a standards body or a
committee that's voting there are plenty
of them out there but the core so and
this is things like oh you know we're
gonna add mutability right so it's those
kinds of core decisions and how we reach
the platform so how are new Americans
going to work those things ought to be
very carefully scrutinized by a large
number of people and change relatively
slowly on the other hand there are some
kinds of power even core conceptual
power like logic programming that may be
able to get substantially done at the
library level certainly libraries are
all done at the library level and there
are a ton of creature comforts that can
be done without touching core and
without pushing any of the platform
issues one particularly important thing
to think about here is can we offer
creature comforts that are separate that
are logically distinct from the
deployment environment I mean Paul
Graham said the whole language there all
the time that feels really awesome but
what I'd really like to have is the
badass streamlined production version of
the language there when I'm in
production and the incredibly comfy
Barcalounger SuperDuper errormsgs
version of the language there when I'm
doing development and there's no reason
that a lot of those tools can't exist
and the simplicity of closure makes it
very easy to experiment with adding
those things right the repple lets you
plug read evaluation and print you could
very easily go and make a creature
comfort environment that doesn't require
any kind of scrutiny or oversight or
consideration at the level of oh my god
this is you know a change to the court
and so I'd like to end today by saying
that if you're looking to have a
powerful experience in closure
please come on up and join us on the
latest releases please move to 1/3
please come on to the 1/4 alphas those
things are being watched regularly if
you have an issue it can be fixed
quickly they're not substantially
different that we don't have a high rate
of you know bugs coming up or anything
like that it's it's a single character
or two inlining and/or maven to just say
you know what I'm gonna get on the
latest stuff and get access to the
latest and greatest power and ask
yourself what can we this whole
community do to make closure easier I
think we've already nailed simplicity in
power I think we've done rich is done
and the community has done an amazing
job of tastefully putting this language
together and we are now at a place in
the adoption curve where it's definitely
reasonable to think about making it easy
and the first step to that is creating a
world where adding comforts is
parallelizable right it does not have to
bottleneck through changes to core and
we are there it was not fun Stewart
Sierra will tell you doing all the work
to get modular can trim the good idea to
say you know what I want to make it a
new contributing it and releasing it I
don't have to be coupled to what the
language is doing and we've already had
great success and people really taking
off and moving things forward
big thanks especially to Sean core field
for the work that he's done in helping
people move to 1/3 and it's wide open
now right if you want something in
closure I challenge you to go make it
and I can tell you that the closure day
of everybody who else who works dev and
closure core the business part of
relevance that does boring things like
running the server for JIRA and things
like that we'll do everything we can to
stay the hell out of your way and let
you make stuff and help you have a place
to put it thank you very much have a
great evening
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>