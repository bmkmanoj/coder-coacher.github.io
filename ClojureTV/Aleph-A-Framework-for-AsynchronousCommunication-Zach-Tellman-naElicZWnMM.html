<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Aleph: A Framework for AsynchronousCommunication - Zach Tellman | Coder Coacher - Coaching Coders</title><meta content="Aleph: A Framework for AsynchronousCommunication - Zach Tellman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Aleph: A Framework for AsynchronousCommunication - Zach Tellman</b></h2><h5 class="post__date">2012-12-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/naElicZWnMM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">what yeah I'm sect tulman I work for
Runa i'm here to talk to you about Aleph
which is among other things a web server
at this talk is going to be an abridged
version of the wiki that is available on
the github repository if you find it
interesting I encourage you to go
actually check that out so okay it
speaks many protocols it has funded
server support for HP server only for
WebSockets tcp serialized java objects
more will be coming the unifying
interface with this is what is called a
channel and a channel is an event-driven
q it is not immutable once a message
passes through a channel it is gone and
the idea is that this is meant to be
sort of an event or an equivalent of
seats you want to have one sort of
abstraction you want to have many useful
functions that operate on it when you
have a channel you create it with just
the call to channel you can in queue
messages into the channel and then since
there are no consumers currently it just
sits there when you register a call back
with receive it will go ahead and pass
the first message into that callback
note that it is printing out something
it is not returning any value rather
it's returning true to say that the
callback was successfully registered
when you have multiple callbacks
registered on an empty channel they will
both receive the next message so notice
that you register to call back to q1
message they both get that message
receive all is a just permanent call
back it will go ahead and receive all
messages that pass through there you go
ahead and have a channel which is
initialized with two messages you then
register a call back and receive both of
those messages immediately when you and
QA third message it will also receive
that I'll just point out that in queue
and receive all is basically just
publish-subscribe you can have many
listeners messages can multiply safely
mutability helps
here channels are unidirectional which
means that since TCP and many other
things are bi-directional you have sort
of a problem keeping track of which one
is which right if you just have two
channels you mix them up all of a sudden
sort of chaos so channel pair will give
you a pair of channels where a message
imputed the one can be received by other
and vice versa basically gives you two
end points on a bidirectional pipe for
this reason an echo server is very
simple you go ahead and receive all
messages from a channel and immediately
in queue it back into the channel this
is a very calm pattern so there is a
function that says so-called site so
your site for the channel back into the
channel and everything any sort of a
bi-directional sort of protocol
basically this just works because the
messages are whatever is the proper
thing for that protocol so now that I've
powered on through that I'm going to
talk about Tom wallpapers presentation
where he was talking about pulling for
changes where you're doing a long pole
and you want to be able to get back the
information immediately if it's fresh
but otherwise you want to just hang
there and wait for the new information
and return immediately once it's there
and I'm going to spend more time on this
I apologize if that was all too fast
again please visit the wiki if you have
sort of questions or talk to me later so
we have we start with two things one is
a ref which has the latest date which is
initialize with no and you have a
channel through which the changeless
since this is a source control thing
will flow we have a receive all call
back which will receive every changeless
as it comes through and it will go ahead
and update the ref this last one is a
little bit more complicated this is a
web request handler
and unlike rain where you have just a
pure function instead you are given a
channel into which you can reach in
queue your response so we assume that in
this case we're getting some sort of
JSON that's trying to hash so we go
ahead and get the last serial number
from the request we then go ahead and we
within a transaction check whether or
not the state is later more recent than
the one that was passed in with requests
if so we create a channel that just
contains that state otherwise we do a
cake star on the channel which basically
is just like take acceptance
asynchronous and then we return that
this channel and we go ahead and we just
siphon that back into the response so
either that will be immediate and notice
that were also doing the map star which
is the same as map except it's always
event-driven and we just go ahead and
turn that into the response and that
will go ahead and just magically work
and I'm done</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>