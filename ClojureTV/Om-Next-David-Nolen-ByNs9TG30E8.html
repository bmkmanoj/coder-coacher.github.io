<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Om Next - David Nolen | Coder Coacher - Coaching Coders</title><meta content="Om Next - David Nolen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Om Next - David Nolen</b></h2><h5 class="post__date">2015-07-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ByNs9TG30E8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">um next so this talk is about ohm but
it's it's actually there are much bigger
ideas in ohm if you're not using ohm
hopefully there's a lot of things you
can take away I think the way that we
design applications specifically how we
design applications that involve clients
remote clients mobile clients you get
radically simpler and so even if you
don't decide to use them I think there
are a lot of ideas you can take away I
can't spend too much time on how own
works today because there's just too
much stuff to cover but that's okay
again there are there are principles at
play here that are much broader than
specifically okay so the story is so far
it's been 16 months since almost first
released there are tons of users those
large projects I've seen projects with
like you know 10 to 20 thousand lines of
code of closure script which is a lot of
closure script so it's it's doing well
you know the one of the big ideas that
wasn't just to get people to adopt home
right that's almost as much an idea as
it was a library it was to demonstrate
to sort of the closure and clojurescript
uni at large that there was a more
idiomatic approach to user interface
development that it was possible to do
very nice UI programming with functional
techniques I think this is something
that's not well understood it's
definitely not covered in academia and
it was nice to see that react could take
us there and um you know push it a
little bit further but it was knows I
was also part of my intent was also to
demonstrate to the broader UI community
a specifically JavaScript that there's
just a completely different way to do it
and you know this and again almost from
my own JavaScript perspective I've been
doing JavaScript you are work for a
decade so we love react react is amazing
you know the JavaScript world sort of
considers it as a framework we don't
really care about that part of react but
we do love it on this because react
unlike most JavaScript based
technologies
around UI development react is immutable
friendly
it requires no explicit observation its
Kalista observation means that you have
a resource you have a lifecycle and you
have to be involved with adding and
removing listeners which is not fun if
you want to be immutable it also solves
this great problem which the deals with
browser quirks going back to ie 8 which
is a big deal there's still old browsers
you have to deal with
and finally react is heading in the
right direction so often you hear these
people say well why don't use some other
virtual Dom diffing thing and these
things are they're cool and innovation
is always important but fundamentally
Facebook has a lot of engineering muscle
they are working on making react to work
with desirable platforms desirable
targets and this is something that small
teams cannot offer if you've ever looked
at react native it's just a ton of
objective-c I don't want to write that
code ok own principles
so ohm has some principles this is the
basic ones it has a lot of features but
we're not going to talk about those we
want to stick to the core ideas so ohm
is single store you know you put all
your state into one place it's very
similar to the way that we think about
databases I think this has huge
advantages there's an asynchronous
rendering loop one of the biggest
mistakes that you see in typical UI work
is that people flush too soon
you flush your operations you have some
crazy event loop there's an event
cascade and then everybody's flushing
and this is the single biggest source of
performance bottlenecks people hack in
JavaScript they add debounce
all over the place it's terrible so ohm
forces you to think in terms of an
asynchronous rendering loop that goes at
60 frames a second this is not my idea
so I had done quite a bit of cocoa in
the past and cocoa has a really nice
thing called set needs display which
queues a render you're not in control of
flushing it also supports jumping to any
point in time which means that you
things that are generally kind of
annoying to do you have to use the
command pattern if you're doing doing
this an oil way but all makes it very
easy you can take a snapshot of this
state which is
efficient to compute because persistent
data structures would you hear about
yesterday and ohm can just go back in
time and again this works because react
has a nice dipping based strategy that
makes this very natural so things like
you know you do an optimistic update
server says well that's not gonna work
it's very easy to rollback and so on and
there's of course deeper implications
for rich applications so if you're doing
anything that's like a complex editor
doing undo or sophisticated forms of
undo and replay and redo are actually
dramatically simpler with persistent
data structures it one good example is
actually adobe have acquired this
product called behance and they don't
use closure script but they use maureen
on they have this crazy you know rich UI
that people can build design profiles
with and their whole undo stack is based
on closure script data structures but
ohm is not perfect very very little
software in the world is ohm has issues
and you know over time it becomes clear
what those issues are you know one of
the biggest things if you if you've done
ohm and eventually you sort of just
train yourself around this problem is
that is that ohm mistakenly I think try
to at the bottom when you make your
components it has this sort of you use
functions but the problem is you have
closures and actually reacts lifecycle
is problematic because you don't know
when those methods are gonna run and you
don't know what data you actually closed
over and so this is something that's
gonna go away cursors cursors bought us
a lot of time that bought us sixteen
months of time it was the best idea that
I had sixteen months ago and in fact it
was an okay idea it's been sort of
adopted in many places and you know
gives you this sort of gives you sort of
the benefits that you get from zippers
or lenses but the API is is around
collection access right so you have this
very natural I'm gonna get a key or I'm
an access and index and you get a thing
which tracks the location but as really
it turns out that really it was a
stopgap it was just a way to so that we
could build modular programs but it's
not like I thought they were the best
idea it just let us get to where
gonna go there's another problem which
is that ohm fundamentally you know I
like you know released it and they had a
very small set of things that I want to
prove to the larger UI programming
community which means that there are a
lot of things there was not clear
whether this should you should or should
not be pluggable and I think it's you
know clear to me now and it's not quite
pluggable enough and then there's
missing pieces there things that we just
that that just never got addressed
because no idea is I had zero ideas this
talk is very much about just stealing
good ideas and we'll talk about that
more but there's missing pieces so
seamless sync so something you know
right when it released if you were like
how do you sync and I was like I don't
know I have no idea how to do sink and
sink sink has multiple dimensions of the
first thing you're always wondering is
like well how do I get the initial set
of data from this server
and once you get the initial set then
you have this other problem which is how
do I get changes the change set some
some amount of time passes you need to
update the client because something
happened on the server you know how do
you merge those into the client
application state so there's just no
solution people have ad hoc solutions
because you know they can work around
this problem but there's no standard way
let's talk about this problem so one
thing I've learned from birch icky is
the very first thing you have to do is
describe the problem and the problem has
nothing to do with them has nothing to
do with react there's a generic problem
for all software that has to deal with
remote clients you have a server and you
have some remote client and then once
you describe the problem and it's clear
what the problem is you have to
enumerate solutions and that doesn't
mean your one idea right one idea is not
enough you have to weigh it against
multiple solutions and we're going to
talk about three that I think are really
important and there none of them are
anything that I came up with myself
one is from Facebook one is from Netflix
and the other is day Tomic and from
cognitive okay so what's what's the
actual problem so Tim berners-lee when
he invite invented the first web browser
you notice there's this beautiful rich
UI which eventually became oh it's 10:00
around this Tim berners-lee wasn't
writing something that was for generic
UI programming we already had well
understood tools
from small talk on small talk influence
systems for building a you is the web
browser was just a way to make documents
to link documents together there was no
intention for it to be any sort of
sophisticated UI system and the problem
is now that we live in the age of the
Internet and we have Android apps and
iOS apps and mobile apps that are on the
web it doesn't work right the the
browser fundamentally was never designed
for this problem and people have added
layers which addressed some dimension of
the problem but the issue is that the
apps that you're building are
increasingly becoming less like
documents and more like traditional
applications and traditional
applications have very complex state a
very complex events and it's a very
complex tree of real UI components it's
not a document and it's it's very much a
graph of UI components so so you
eventually you you you will you will see
that what's happening is that you know a
good idea for the web which is rest
people tried to co-opt it for solving
the rich client problem and ends up
being a horrible terrible fit and people
have these really convoluted you know
monstrosities that are back-end services
this is an image from Miyazaki's Howl's
Moving Castle so you know in rest you're
supposed to have a logical and logical
resource and you separate them and
they're all supposed to be separate but
the client never needs one resource and
in fact with mobile clients the problem
is quite large you cannot incur the
latency of going back over the network
because bandwidth sucks on mobile and
what happens is that people start
folding in more and more resources into
this endpoint you have a service that
just looks terrible it doesn't actually
solve everybody's problems and in fact
you make decisions that don't work for
future clients you know Apple releases a
watch now now what are we gonna serve
that this is only going to continue to
get worse I think if you've been in this
space and you've had to serve iPads and
iPhones Android tablets and so on you
know that it creates it creates problems
when you try to you know basically sort
of force rest into
serving all these different clients
there's an alternative on this is a
demand driven approach I can't get into
every aspect of demand driven design I
actually did a talk at Q con I have no
idea when that will get released but if
you want to hear more about that which I
can only dig into a little bit today I
check out that talk but effectively in
these solutions that I'm in a possible
potential solutions I'm going to talk
about today there are important
properties that must be maintained in
order to get the value proposition that
I'm talking about any system that's
gonna fix this problem that you have
today needs to have some way to
basically allow clients to have
composable demands so you the call the
clients to describe the demand but every
unit of the demand must itself fully
function as something that can be sent
to something that can fulfill that
demand it has to compose it has to be
recursive and you'll see that when I'm
saying this this property exists outside
of closure the to other systems I'm
going to talk about our JavaScript
systems and they have this property
they are composable and every basically
sub demand is itself a full demand
there's another huge issue which is all
these systems support interpretation
they don't they don't hard-code what the
demand means and this is extremely
extremely important in fact the reason
it's so important is because you when
you write the UI a huge source of
complexity is where's my data where is
it if you were here for David Lim skis
talk you really it's really nice when
you don't have to care about whether the
data is in locally in a cache or if it's
remote and in fact your UI should not be
involved in that problem at all on the
solutions I talked about allow the
component to declarative declaratively
describe what it needs but it's not
involved in where I'm gonna get it
that's something that's something else
to do this so it's really important you
have a phrase the generic phrase that's
a nice one and it's great when you can
understand in this context it means
something completely different this is
actually a great slide from a great talk
by Gregor Cazalas
I forget I mean actually forget what
it's called but go to his website it's
like one of his most recent talks Gregor
Cazalas did the art of the meta object
protocol okay so what's the first
solution one one potential awesome idea
so Facebook and had their big conference
in February and they announced this
thing called relay in graph QL a lot of
people thought the graph QL thing was
new it's not new graph QL has long been
in use Facebook is something that the
PHP engineers used when they want to run
queries they're building a social
network it's much more natural to write
queries that bbc's composable graph
fragments so they were forced into this
solution because of the nature of the
software they're rebuilding relays
innovation is to expose the graph QL
syntax to clients so graph QL was long
and play there's what was already there
they're just simply moving it to the
client and relays innovation the awesome
idea that we're gonna steal is that in
relay components are annotated with the
com-pub with these composable query
fragments so again this idea of
compositional fragments you can compose
them because they're all the same they
all look the same
well this is a relay idea and relay has
all these features and we can't get into
every last possible thing in fact this
talk is mostly about high level features
you know there's lots of details to fill
in and I won't talk about them but
hopefully this kick starts a lot of
discussions and people can can think
through the details Jason grant Falkor
this is a Netflix thing developed
completely independently a Facebook has
no relation right so Facebook Facebook
gets Facebook is as a monolithic design
even though even though Facebook is
massive right there their fundamental
design architecture is that of the
monolithic application those of you that
follow Netflix know that Netflix does
not have this design yet they ended up
in the same place they do not have a
monolithic application architecture but
they ended up with the same idea it's
you know different library you know
different syntax but it's the same idea
Netflix had a rest-based system they had
a rest-based system they worked on it
for two years it was a turd right
all the problems I talked about they
they encounter they removed it they
switch to Falkor
they just erased 90% of their code right
you can see Jafar Husain has spoken
three times about Jason Crafton Falkor
yeah 90% the networking code disappears
and you'll see in the my demo that
clearly this is not it mean it's a
reproducible thing
Jason graph is a simple data oriented
API I talked to Jafar and Jeff I said
you know I was like how did you get the
Jason graph Phalke right here I was like
well I watched all these awesome rich
icky talks and I said what would it look
like if I only if I designed my API are
on data right and that's that's that's
what Jason Grafton Falkor is it's just a
data oriented design that was inspired
by rich icky stocks simple made easy and
so on Falkor is the routing component
and this is another idea we're just
going to steal Falkor takes the simple
JSON data structure which describes what
the client wants it's just a recursive
data structure with keys and what
Netflix does is they take each key and
Thal core is a router it recursively
fans out on on the values and each value
is another map with more keys it
collects all the results and in return
something in the exact same shape the
shape of the of the thing that's
returned to the client is precisely the
shape of the thing the client requested
and the require the client only gets
what they want they don't get anything
more this is this is actually identical
to graph QL the components going to
describe exactly what they want it's
recursive and they get back the result
in the exact same shape that they made
the demand it there's another there's a
third possible idea a solution and
that's the same time I pull syntax if
you here for David slim sees awesome
talk about the atomic
this is a bit of review it's not nothing
nothing new time I pull syntax does this
right it lets you without having to
write think about think about what he
was showing he was showing oh you could
touch the entity and you could write a
bunch of code or you could just use the
pull syntax no code right no no chance
for bucks the pull syntax just describes
in a declarative way would you what you
would have had to write functional code
for are you can just get rid of that
code
do Tomic poolside pool syntax is
fundamentally just recursive select keys
so if you're familiar with select keys
from closure select keys is a vector of
keys the atomic simply makes that thing
a recursive operation
it's just recursive select keys it's not
scary recursive select keys all it is
it's just a generic simple data
description graph QL it's I mean this is
one thing I don't like about graph scale
we're not going to take this graph QL is
a string based syntax
it requires on a pass they converted to
an AST it's too much so we're just going
to use simple data do Tomic pull syntax
is simple data it looks like this again
this is just review you have a vector
you want to get the person's first name
you wanna get the person's last name you
want to get the address so the address
actually is a joint
the address is not the address is some
reference to something else and atomic
you would say is component and this pull
syntax would actually pull in all the
aspects of the address entities that are
associated with this person if I want to
for example only get the zip code then I
take the key I wrap it in a map and I
supply a new vector and I say what thing
I want but again this has this property
it's recursive it's simple the whole
thing looks the same all the way down
right so immediately you should see you
should think this can be composed I can
actually distribute fragments throughout
my program and I can build up some
larger query so let's synthesize these
ideas and to into something so this is
this is basically what own next is gonna
look like you know the details are
probably going to change I mean own X is
by no means ready but there is a working
thing and I'm gonna demo the working
thing and I think it will demonstrate
the power of the ideas behind real a
graph QL date I might pull syntax jason
graphing Falkor so this is one possible
one possible future for ohm this is a
small snippet of code and let's focus on
just a few things the first thing is
contact list contact lists no longer
takes any arguments zero arguments does
not take props does not take ops
take anything this this basically gets
us out of this problem where you could
close over something and then in a life
cycle not have clothes over the thing
that you thought you closed over so you
can't just doesn't take arguments
there's a standard interface this thing
received will will receive the same
arguments that I received before but you
can never close over things accidentally
the next thing to notice is this right
there is a static method and this is
really important it's a static method
it's a method you can invoke without
instantiating without rendering anything
and it's just pull syntax right so here
it says this component needs its
contacts but it doesn't actually know
how to get those contacts it doesn't in
fact in fact doesn't care because we
need to preserve modularity the same
modularity that cursors gave us in the
past so you we have a little question
mark contact it says well somebody knows
what I need from app contacts I don't
know then we say well we're gonna bind
that to some other component possibly
written by some other person we just
don't care who that person is and we
have to know what we're gonna render
we're gonna renter our contact we're not
concerned about what that thing actually
needs we ask it tell us what you're in
what you're gonna need I'm going to
compose your query with mine and then
finally is a small change down here
which is so while it was it was nice to
have protocols in an ohm to me and ended
up being more work than it real really
worth because it introduced a lot of
indirection own components are it's
gonna be like quiescent you might not be
familiar but quiescent is a very thin
wrapper so this whole expression that
I've written it just generates a
JavaScript class and you'll just have
these that render method is the exact
same render method you would have
written you know say if you didn't this
in JavaScript it's just normal
JavaScript class that's what this
generates so removing a lot of the
indirection that we had before which
will make debugging own programs simpler
because there's a lot less stuff to
crawl through on your sec traces
okay so give each component this is the
big idea yeah give each component a day
Tom extend types do tell might pull
syntax fragment just stolen from relay
right I just took that idea stole it I
tweaked it a bit to make it a little bit
more relevant for closure programmers
cursors disappear and we'll dig into
what that means and then we can supply
an optional server-side router so we
could add middleware whether that's
pedestal or ring it doesn't really
matter and this completely optional now
if you decide that you don't want to
have some server-side component you
don't you don't need it but that's the
beauty of the Falkor thing right
Falkor fundamentally does not need a
back-end thing this is actually a bit
antithetical to relay relay they want
they want to do this thing and I think
it's probably unwise in that you can't
use it without some other thing so ohm
is not gonna make these decisions we're
gonna be quite a bit more conservative
but if you do supply a router you will
have a more powerful system it's a
system that can do sync for you
so no cursors people I've said this is
like there's no cursors what does this
mean why don't why why why do Christians
disappeared cursors only they don't the
only reason to have them as a delivered
dependency tracking that was the only
reason they existed there that's that's
it
once you add queries to your components
once the the component specifies what it
needs you can build an index on the fly
right even even at run time you can
actually say I know the exact data
dependency path this component has
because the query just tells you there's
there's no there's no other information
the query describes exactly what the
component needs
you don't need cursors and this is
actually beautiful because now it means
that your your components just take
values there's no this weird magical
cursor thing it's gone and again again
crazy fragments because they're
associate with components building an
index of what components need it's
really trivial I wrote like I don't know
ten lines of code to make this work
other changes components can be used
without a render loop this is like
quiescent I don't recommend it but you
know for whatever reason if you'd want
to use it without a running loop you can
integrating custom stores is much
simpler so the very first thing I did
was like okay this is awesome I don't
need cursors and how hard it would it be
to integrate data script and like it
took me like you know
50 lines of code and now I can use data
script as a backing store so the store
part how do you what shape is your data
and no longer has to be a tree it can be
a tree but it can be data script or can
be something a remote like the atomic
it's it stops mattering what your store
looks like which is huge
because I can't predict what you want to
do and now you have the freedom to
decide this is the type of local cache
or remote storage that my application
has one one thing that's really awesome
though if you used a tonic and atomic
has this huge advantage and it could run
these effectively graph queries for you
so you can basically you can interpret
these keys and say well I know that this
key this part is actually something I
can run directly against atomic there's
no reason to write any code the atomic
will just do what you want and this is
huge it's awesome
it also there's a huge benefit to things
that look like diatomic or if you can
simulate what de Tomic does huge because
the atomic has an ocean of entities and
there's a very natural association with
an entity and a component that means
that for example you have some grid view
or some UI widget and you know you need
updates from the server weld atomic has
a whole sense of time I can say well I'm
at t 50 and now we're at T 100 and I can
say des Tomic I this is the entity that
I'm interested in give me the all the
changed atoms right and it can just send
you all this stuff and again this is
like a one-liner with the atomic okay
enough talk let's see demo alright so
here is what it looks like at the moment
so all next is not going to replace ohm
because again there's these huge huge
applications so I'm very much interested
in not breaking anything that exists and
having there's going to be a migration
path but so I can include the old next
bit namespace up here and it looks it
looks very similar if you've done any
Olmec there's nothing very little new to
see what's really cool though is that
here I have this I I mean a test getting
a query so I have this contact list and
it has this pull syntax fragment and
then I have contact and if I scroll up
contact has its own fragment and then we
have this
which just commented out which we're
gonna add later on the address info view
has its fragment so let's see so I go
oops oh no turn that off no hope to
start over
let's try this again sorry wait for that
sorry this is gonna be it's somewhat
slow because this is a really old laptop
so apologies for not being super fast
but notice so while what we're waiting
for this note that in the body of the
thing render looks render doesn't look
different right so render it so it's a
mate so the render part of ohm stays
exactly the same the only thing that's
changing is that we now have this
declarative thing for grabbing the bits
of information let's compile this again
okay switch the namespace boom there it
is so I said give me your query and
actually this is amazing for debug
ability you now have components where
you can always know exactly what the
component wants so down here I have a
little bit of core async I'm going to
say this is without doing anything with
the UI so I have not instantiate the UI
I'm calling a static method requires no
instantiation of the actual component I
guess I get the query for the contact
list
fetch it hit the endpoint and then give
me that data right so my request looked
like this right and then down here I got
only what I requested
so let's with again I'm not going to
update the UI yet on um scroll up here
I'm going to now include this part right
so we want the first person let the
first name last name the telephone
number now we want the address
and then if I run this again we see that
the query it composed right this is
another level another level I've asked
another component for a piece of the of
the data boom I didn't have to change
anything I'd have to go to the server
right I had to change nothing and the
server I didn't have to change the
endpoint there's just one endpoint that
understands how to serve whatever the
client wants there's no can there's no
more coordination between what did the
back-end person want to specify and what
is the client need so having done rest
based systems for a decade there's this
ridiculous long cycle where it's like
okay the endpoint doesn't have what I
want in this world the basically the
front-end people get to describe what
they need and the backend doesn't get to
do this right
there's some there's some work they have
to do around security authentication the
usual stuff but the clients are now in
control of the data they need and
actually so let's let's let's actually
add this to the front-end yeah so if
you're doing fig wheel or whatever
whoops
oh oh you're right sorry down here
no let's just register I refreshing this
well there it is I don't know why it
didn't load but that's okay but again if
you're using fig wheel right you would
just change the query and then the up
the the front-end would just update and
this is awesome
if you've done UI development this is
huge right and this in this principle
that I'm showing you right this would
work with react native right you have
the same exact same design principle
that works regardless of what client the
year that you're targeting again as long
as you're using to react to the
rendering
cuz react gets you to iOS and Android
okay so let's move on ok to do so there
are things to do
query updating is like something that we
have to work on ring pedestal day Tomic
middleware awesome
to do and there's gonna be a ton of work
on just bridging but again I think this
is big this is again this is exactly
what Facebook is talking about except
I'm showing you a demo and you can just
use even try the demo today it just
works
especially if you decide to use a Tomic
so the atomic actually now is like
actually an extremely ideal a client
sort of client a thing for clients right
the atomic is a better database when
you're building these dynamic clients
I'm done but actually no I'm not so this
is euro closure and so home next is
awesome I'm really excited about it but
I don't get to talk about closure script
very often and a lot of I'm talking
about um next just fits into a much
bigger picture so there's actually quite
a bit more to do and talk about so
Clojure scrip has got has become really
big I'm very exciting you know I get to
talk to a lot of you and it's very
inspiring but it's it's often the case
that it's hard to see what is what does
clojurescript doing where is it going
what's the bigger picture i actually
think with things like own next and if
other frameworks as i do adopt the real
a Falkor ideas there's a huge
opportunity to completely change the way
that we think about development in fact
i think we can leapfrog the sort of best
practices that are that sort of like the
industry standard you know people often
say what's what's closures killer app
and like you know I think the next
things I'm going to show it's like come
on this is Lisp like like it's like you
have killer apps inside of your killer
apps and some of these demos are gonna
show that okay so why close your script
and hopefully you'll next stuff is hope
by itself convincing but there is more
you know because I think everybody's
here because we love closure closures a
lot of fun
closure rocks but javascript is and and
we're seeing that right it's it's on
we're doing nothing and javascript is
finding itself more and more and through
clojurescript all the places where
javascript can go we can go so where
there is a big plan and so let's talk
about the big plan and because it's
finally becoming kind of clear so
closure scrip is bigger than the web i
mean it's the path to all the targets
where the JVM can't run which is a lot
there's a lot of places where the JVM
can't run and there's actually a lot of
things that have been set in motion so
if you follow me you see me tweet but
you might not understand what's the big
picture for doing all these various
things but let's
playing some of these so we kick started
off a google Summer of Code project
which is huge we've already made a ton
of progress and it's this project which
allows us to process common je s and D
and es2015 modules and you might be like
well I just want to write clojurescript
why do I need that react is not written
in enclosure script right you consume it
as this monolithic file if you want to
use react add-ons you have to consume
this even more monolithic file it's not
susceptible to all the optimizations
that you have so we're doing work that
allows us to process all these different
types of module formats and we convert
them into Google closure modules so as
far as the closure closure script
compiler is concerned it's just all the
same type of JavaScript there's no
difference between react and your own
closure script code this is huge the
other thing we're gonna do and this is
again where this is just the benefit of
JavaScript being everywhere is Java a
ship NASA or NASA one is a very great
awesome high-performance JavaScript
library and you can run JavaScript
inside the JVM and it's fast
so babel is huge it's taking off a react
has switched to Babel so react doesn't
use JSX anymore it uses babel to process
it's you know the JSX stuff so what we
can do inside the closure compiler now
is take react we can take all the
reactor modules we can apply babel to
get it back to regular javascript and
then we can use our common Jas pass to
convert it into plain old Google closure
namespaces so now react can be dead code
eliminated and it can be subjected to
things like code motion which is really
big for typical web stuff um it's just
our it's just our path and so this is
it's bigger than just closure script
right so they're tools that are getting
super popular and they're all awesome
things like fig whale things like butta
Bootsy ljs right the moment that we have
this stuff you can now use boot clgs to
build your iOS app or your Android app
you can use fig wheel to live code your
Android tablet application whatever the
idea is that this actually gives other
tools superpowers so huge shout-out to
Maria neighs she's the one that's
working on this it's amazing
she's been incredible
you know in six months when you're able
to be build iOS or Android stuff and use
react native you should thank her
another big thing that's actually a part
of this is that once you decide to
basically reach more clients how do you
compile for these plants because they're
because the clients it's not you know
you have this device and like how do you
code that device live the device is here
it's not your laptop you need to test
you don't want to you don't necessarily
want to use a simulator so this is
something I thought about a long time
ago and fortunately we have a really
great objective-c
developer in the community mike Fikes so
I worked with him and sort of inspired
him and he really you know took it to
the next level
he wrote a thing called amli and it
basically takes this amazing application
called GCD web server which was designed
by an ex Apple engineer he actually
worked on quartz composer but he left
and he did this thing called GCD web
server
it's a Grand Central Dispatch based web
server and includes a fully compliant
WebDAV server built in it and it has a
complete support for multicast DNS and
we'll see that here in a second which
means that you can basically use Xcode
install onto your devices devices on
Wi-Fi the device will actually over
Wi-Fi broadcast that it has a repple the
repple connects the device tells the job
the JVM process I'm mounting a web dev
volume and the compiler writes to the
web dev volume and this is just seamless
and so once you've once you've booted
the app you don't even need Xcode
anymore you just live code against
directly against the device so compile
sync over web dev delivers IRS repple
the connection stuff is really cool mdns
stuff is really cool it's actually I
wish we could do this as easily for the
browser but it turns out that G CDs web
server stuff actually looks it's quite a
bit simpler to set up which is crazy so
the thing I'm in a demo and sorry this
again this is a slow laptop so it's
gonna take a second the simulator is not
particularly fast to boot so I'm using
ejecta ejectives actually has been used
by quite a few companies what is ejecta
ejecta is a native WebGL components a
WebGL view and what the developers of
ejecta did is they added its opengl but
they added WebGL bindings and canvas
bindings so you could imagine you want
to do visualization
on an iOS device and you want to combine
it with react native so this would be
your arbitrary drawing surface so this
is booted up let's switch to this again
this will take a second
but Emily Emily is awesome and eject is
awesome right there's there's all these
things again this is this is something
that was something work that we did not
have to do and what I'm about to demo is
exactly the same way that react native
will work right you would you would
include a tiny little thing inside of
your objective-c thing just a bootstrap
that's all you need this for is just a
bootstrap the application it's like two
lines of objective-c and then once
you've done that then you launch Emily
and AM bleed does all the work because
GC again the GCD web server thing that
you this little cocoa pod thing it's
actually quite cool does all that does
all the hard stuff for you you don't you
not you don't to be involved and the
tricky bits again apologies for this
this is yeah running a simulator and
this at the same time is pretty intense
okay so I'm connected I'm connected to
the simulator I could have done this
over white I mean I turned Wi-Fi off
because the Wi-Fi was messing with my
demos but I could have done this over
Wi-Fi if I was developing somewhere else
what I've just done right it's there is
a WebDAV volume that got mounted the
simulator mounted a WebDAV volume and I
just compiled a file into the simulators
documents directory right so this would
this would be just the same as this was
on a device so here I'm is connected to
JavaScript core right so and this is
better than this is actually better than
what react native can offer react native
has this crazy thing where you have to
reload the entire application on this is
not it's not what we want for closure
script closure script will have the
exact same workflow that you're used to
you're in your source file you have a
ripple you can hot load code whenever
you want and again this is not this is
not this is a is not a webview right
this is a native OpenGL ES view
okay thanks so huge huge shout-out to
Mike fights so there's all these people
doing this incredible work allowing
clojurescript to go places it has never
gone before so in the last thing I'm
gonna show which is really cool and this
is super new which is close your script
and close your circuit which took a long
time to get here mostly because we
really needed a reader conditionals to
do this correctly and actually there was
a lot of optimizations in closure script
that needed to happen before we could do
this in the right way a cloture script
and closure script what's the point of
that that might seem why do we need that
because that don't require this at all I
sure know awesome demos has nothing to
do with clojurescript filing its own
reach that's the only reason to do this
it's not for cool points it's only
because there's cases where for various
reasons you you you just need to strip
off the JVM so there are so typical
things like electrons getting very
popular electron is a fantastic way to
build with JavaScript apps that can run
on Linux Windows iOS 10 you it's awesome
so in white table wanted to do this but
you know we were it took a long time to
get to where we are but that's a case
where you just want to ship something
and you just want to strip the JVM no GS
is a huge case people have talked about
this forever or finally close to
allowing this you just want to write a
shell script nodejs starts fast has a
very small memory profile which is also
good for really cool targets like
raspberry pi where the JVM is actually
pretty slow a really awesome one once we
get to the point where we have access to
the native applications on you know on
Android and iOS you want to ship updates
right you don't want to go through the
release cycle so what you can do is you
can build your application you can
include the compiled analyzer and then
it can just download the closure script
file and live update right you're able
to update the application after the fact
without doing deploying another release
and then there's a nice one which is
just reaching more people there's a lot
of people that would love to try a
ripple or trial library and actually
there's going to be support to basically
take any library and you know there'll
be an option that compile that says I
want a bootstrap which means that will
automatically add the compiler the
analyzer and the reader and so now if
you make a really cool library you can
it'll be like a one-liner to make a
ripple so people can try out your
library on a website and you won't have
to set up a separate
compilation service so right now things
like Humaira is this really crazy thing
you have to have a separate service to
do this you want to do this anymore so
let's see a little preview it's not
ready but it's still it's still totally
awesome so let's close this alright so
this again is gonna take a little while
so so what are we looking at here this
is I mean I'm not sure how familiar you
guys are with the clojurescript compiler
but one of the most complex things in
the closure script compiler is actually
actually the macros file closure is
completely different defined in terms of
macros until you get macros you really
can't do anything this is fun so this is
closure scripts net a circular moment so
this is the macros file clj score this
thing this defines all the macros do you
see things like you know Plus which in
lines and so on so all these things that
we're excluding we the reason we have
these massive set of exclusions we have
to exclude closures compilers so we can
define clojurescript ones but what's
quite mind-bending is here we have this
thing when this file is compiled as
closure script it requires itself right
it needs to require itself to generate
the macros that we generate in
JavaScript so that's pretty crazy so I'm
going to compile the macros file into
JavaScript so this is gonna get loaded
so this is a node repple so we're
compiling it and it takes a while it's a
huge file a lot of macros we're loading
it into the node.js runtime and let's
load the actual demo file now so up here
so this will be totally totally doable
use you want to build you want to demo
your library you just want a single
javascript file this is closure script
right here I have a net a namespace this
is a closure script file I'm including
tools reader because it got ported I'm
including the analyzer and this is not a
separate analyzer
right we're just loading the analyzers
that the JVM loads is exactly the same
analyzer the same compiler there's no
difference let's compile this
so we're gonna show this guy so here we
have an so again not everything works
but this does show something non-trivial
it's this is a
it's a function which takes two
arguments as higher-order we're passing
in arguments FN is a macro and plus as a
macro so all these things have to work
and again this this is just the real
clojurescript compiler we did not change
the closure script compiler to make this
work let's just clear this out let's
switch to valuate this and there we go
so that's that's inside of nodejs
that i did not does not happen inside
the JVM
and finally this is a moment that he'll
be you've all been waiting for and
that's the string but eval is trivial
right you can just pass that to eval and
there you go three okay so the huge shut
more shoutouts I mean again this is none
of this stuff is possible if it wasn't
for how awesome the community is
Jonathan Boston and Sean LeBron they
ported closure P print so this is what
makes dealing with the compiler
reasonable we can pretty print ast and
make my life much simpler Niccolo
ma'amed oh he works on tools reader the
only reason you have source mapping is
because Nikola meadow lameta worked on
tools reader we get all the source
mapping stuff through tools reader and
Andrew McVeigh and others they ported it
to clojurescript
and that's the reason I condemn also
demo this stuff today it's because we
have a reader enclosure script and tons
more people it's amazing I always super
excited I think we have like a hundred
nine contributors to closure script I've
submitted patches it's amazing I expect
there will be many more in the future
that's actually all I had today I hope
I'm running out of time so the only
thing I want to leave you with it's been
great fun I'm happy that I got to show
this stuff off my only guidance is you
know Keep Calm and take over the world</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>