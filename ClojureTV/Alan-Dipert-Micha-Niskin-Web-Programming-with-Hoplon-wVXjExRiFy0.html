<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Alan Dipert &amp; Micha Niskin -  Web Programming with Hoplon | Coder Coacher - Coaching Coders</title><meta content="Alan Dipert &amp; Micha Niskin -  Web Programming with Hoplon - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Alan Dipert &amp; Micha Niskin -  Web Programming with Hoplon</b></h2><h5 class="post__date">2014-03-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wVXjExRiFy0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone to our talk I am Allen
diaper this is my longtime friend and
opensource collaborator misha niskin
we're here to give a short a short talk
about kind of the dark arts maybe some
of you have seen army of Darkness
familiar with the book the Necronomicon
you know that we're actually not gonna
talk about those kinds of things we're
gonna talking about computers in
particular we're gonna talk about web
application programming so there have
been more than a handful of talks about
this topic we're just another way to
make webpages so advanced me they're
cool there's our info if you'd like to
pull up any of our information right now
Hopalong I Oh was the place to go to
learn why are we interested in the
Necronomicon dark spells evil magics
with the ck-mb well as web application
programmers we're looking at an
increasingly hostile platform space by
hostile I mean more complicated all
kinds of different deployment targets
now it used to be just you know ie 5.5
on Windows XP and it was good now it's
you know needs to work on Chrome 33
Firefox 25 WebKit 2 point whatever so
we're in facing a wall of complexity
when it comes to platforms were expected
to deliver to we're bad at estimating
how long it will take to build any given
application to target any particular set
of platforms I guess by we I just mean
me and Ben Misha he's worse than I am
but we're both pretty bad at it and
honestly I even the best developers
programmers I've ever met are usually
off by an order of magnitude maybe maybe
maybe three to four times
not quite order magnitude but very few
people are really good at estimating
even even the best of us so this is kind
of scary we don't know how long anything
we do will take that's weird why do
people hire us once we do have something
figured out like we're happy with
something we've shipped it oh yeah we
shipped the app works great Android 4.5
awesome
you know snowball or whatever it's
called it's no ice cream ice cream but
then the next day somebody says hey does
it work on Io
yes it should I mean you know one's
WebKit the immutable sort of WebKit they
should work but of course it doesn't
because you know one is a different
aspect ratio or whatever so now we're
facing again this this wall of
complexity and we are not able to
estimate how long it would take to port
one app to a different platform so all
of these battles are you would think are
easy ones to fight like I have an
existing app I need to get it to work on
a slightly different platform no it's
not easy it's incredibly hard and to
solve this problem we need to look
towards the dark arts dead technologies
spreadsheets are one of those
technologies spreadsheets are not just
notorious I'd say spreadsheets are
infamous I mean these are we've all had
experiences with spreadsheets they've
been around forever we kind of count on
them as or we see them as just a part of
the computing landscape this is an
example of VisiCalc from 1979 this is
the killer app for the Apple 2 so that's
what a spreadsheet looked like in 1979
this is what the spreadsheet looks in
2014 what anybody notice anything yeah
the colors changed a little what is this
like though hit us Misha Patrick Stewart
Patrick Stewart has not aged
neither have spreadsheets they're the
same thing
they have been forever for all times
Patrick Stewart has been Patrick Stewart
and spreadsheets have been spreadsheets
like Patrick Stewart spreadsheets are
amazing they're an amazing technology to
the extent that Patrick Stewart is a
technology I should have thought about
that slide but they're both amazing
unlike Patrick Stewart a lot of
programmers don't like spreadsheets I
don't know what it is you know they have
a longtime association with Windows and
sort of business stuff that seems stupid
so we disparage them openly I mean it's
honestly I it's rare that you run into
programs like dude I'm into VB macros
yeah I'm talking a strange loop about VB
for macros and Excel 97 cool like you
don't hear that no we think they suck so
we see them as it open problem like
something that we need to solve like the
fact that we have a close friend who
uses
spreadsheet like let's intervene I'm
gonna make this person a program like
I'm gonna whoa
part of that is they're not sort of
computer science he enough there aren't
really open problems around them but the
reality of spreadsheets are that they're
what people use when we let them down
when we fail someone when they come to
us and say oh hey you know how what
would it take to visualize these steel
figures and you're like well I need a
team of five a budget of three million
and four months you're like okay
spreadsheet time twenty minutes later
done they're the technology that people
go to to solve their problems when we're
not able to so if we're gonna learn from
anything I think spreadsheets are a
great place to look I took a stab here
it described it we're kind of taking a
look at spreadsheets from the from the
eyes of a programming language and
environment and I think spreadsheets are
amazing for roughly these three reasons
I mean they suck for a lot more but for
these three reasons I think they're
particularly incredible and we should we
should dive in I think they're reactive
out of the box and there's a there's
like a reactive manifesto now and we're
looking at FRP and all this stuff but
spreadsheets a bit they've been doing
reactive programming since 1979 so this
is uh something pretty incredible
they're transparent they're transparent
in the way your program is transparent
when you have a good debugger attached
it's easy to see at least for some size
of spreadsheets what's going on
and finally and I think most importantly
they're layered they present a layered
approach to computing that allows small
groups of people and teams and
businesses to work on each other to
extend each other's work easily in ways
that we have a lot of difficulty doing
with our programming constructs so
reactivity is the first thing I'm gonna
hit on here this is a screenshot from a
interview that rich Hickey did with
Bryan Beckman a couple years ago
ironically at Microsoft homeless
spreadsheet one of the things rich says
when the topic of the so-called epical
time model comes up is that you can have
a lot of semantics for managing time
once you separate value from identity so
this is the separation that closure
gives us where we separate you know the
name of something with the value that
may have it
time in spreadsheet world we do have
something like that a reference type if
you will that sort of fits into this
this worldview and that's the cell the
cell in a lot of ways and by cell I mean
you know the little box and the
spreadsheet where you type in a value or
a formula is one of these reference
types it's a reactive unit of time
management it's what gives spreadsheets
this magical property of reactivity the
result of using cells and spreadsheets
is that time does not exist in the
spreadsheet
you know if anybody's like seeing the
sicp lectures they go three lectures
without even mutating anything and then
suddenly you know you define something a
second time and time is introduced
spreadsheets there is no time they are
timeless and creepy the same way Patrick
Stewart is they're transparent so again
you know the the spreadsheet interface
is basically the an incredible debugger
it's an awesome debugging environment
you can see every of the value of every
variable and when you change the values
of these constituent variables things
change
reactive reactively you can easily see
what's going on you have data you have
formulas you have visual visualizations
backed by other of those things just a
great great debugging they're just the
natural debugging tool the third point I
mentioned about layering I think we can
we can start to see here so we're
looking at a spreadsheet and we've got a
data grid and then we've got a
visualization the incredible thing about
what we're seeing here is that you can
change attributes of the way the data is
displayed like those red horizontal bars
maybe I want them to be blue without
interacting at all with the underlying
data
likewise or symmetrically I could change
the data without changing the chart and
in fact just get yeah look at this next
screen here I mean you can add new
charts you can have n charts all
different kinds of charts here I'm
showing off like the pie chart which is
like probably not the one you want but
you know there are lots of charts and we
can attach them or plug them into this
existing data and formula without
changing the data or the formulas and
this is incredible power so that's the
tech the sort of human side of it is
that spreadsheets gives us this natural
boundary to divide labor one person can
enter the data someone who knows the
business or knows the what relationships
to look for in the data can write
formulas and then others can make
visualizations without necessarily
writing formulas or entering new data so
what we see in organizations that use
spreadsheets is these spreadsheets sort
of circulate like you know trash around
the oceans from different business units
inside the company and people tax stuff
on maybe they'll want to use it for a
report oh maybe I have a better idea for
how to do this formula I mean that's
from a like a change management
perspective that's bad but it's amazing
from the perspective of everybody has a
way to contribute something they're good
at this to this programming in this
environment so hoplon this web thing
it's a it's a framework a set of
libraries that we've developed working
closer and closer Script it's if it's
influenced by any one thing I'd say that
thing is spreadsheets so at the heart of
our framework is a closure script
library called javelin and javelin is an
abstract spreadsheet it's a way to do
spreadsheet like programming in a
closure script environment and our goal
is to try and deliver all of the things
that are good about spreadsheets to the
closure scripts programmer so like
normal spreadsheets Excel 97 we have
input cells and one creates input cells
by one one of two methods the first
method is you can call the cell
constructor and this is this is just a
function you call that returns a
reference type of cell this is similar
to how you would create an atom or an
agent or any kind of closure reference
type so here we're defining a thing to
be the cell another way to make a cell
in
with javelin as we have a macro def C
and all that does is create a cell name
end and you don't have to type the
constructor in we just have this because
our programs didn't have lots of cells
we have formula cells formula cells are
different from input cells and that they
shouldn't really be mutated you don't
change the contents of them dynamically
necessarily what they do contain our
closure script expressions which are
analogous to the formula values in you
know an Excel spreadsheet so in this
case we're defining an input cell called
n giving an initial value of 0 then
we're defining a formula cell called n
times 5 and we're using cell equal which
is the cell a formula cell constructor
macro that takes an expression and at
this point we can differ d reference
either n or n times 5 and we'll see
values that are consistent if we swap
bang on n incrementing the its value and
then dereference n and d reference n
times 5 we'll see that n has been
incremented and n times 5 is somewhat
magically but in that awesome
spreadsheet way reflects the value and
that's the value we established through
our formula sit in the same way there's
a def see there's a def see equals and
again this is just sort of a having fun
with macros little exercise javelin is
different and I think some interesting
ways from spreadsheets that you may be
used to the first and maybe coolest
difference is that cells in a
spreadsheet like we have in Excel can't
take collection values you can put
numbers and strings but putting
collection values in the cell it's not
even really possible so people have
other mechanisms to deal with
collections like ranges and pivot tables
cells enclosure script are not that way
like any other closure reference type
that you can put any value in them
including other cells functions I mean
anything that's a value which is
everything in closure script can go in a
Cell and the other difference is that
unlike a spreadsheet grid the global
scope of a spreadsheet is this 2d grid
the Scopes and names in javelin follow
closure scripts so you can create let
bounds
you know cells that are only available
inside a closure you can have packaged
cells in namespaces so that approach
that we take with javelins kinda similar
to the way people work with sheets or
worksheets in and spreadsheet programs
so that was undead technology number one
spreadsheets the other undead technology
which we were probably more familiar
with is lists lists like spreadsheets
most programmers think sucks of course
we know otherwise so I'm gonna let me
show teach us some things about part 2
so H Lisp is kind of the charting and
forms the charts on forms layer of the
spreadsheet a cool thing about
spreadsheets is that given a spreadsheet
that has formulas you might not even
understand you might be presenting
something to the board of directors or
you know like in them on TV somebody
always has to make a make a report by
Friday or whatever and they have to stay
up late but what they're doing is
they're taking the spreadsheet and they
have a Word document they're putting
content in there making graphs things
like that and pulling them into their
into their word document that they're
gonna show to somebody
- hopefully elicit some kind of action
and that's really what you know a web
application is to the UI of it and so H
Lisp is that part of it that the
charting part so HTML when you load
index dot HTML into a browser the
browser normally reads a bunch of HTML
markup and loads it into the Dom but
this HTML is already a programming
language it's not a very good one but it
definitely is like the browser has to
parse this HTML markup which is kind of
weird and then it has to build a tree
and it has to walk the tree create Dom
elements and you know put them in the
DOM and so what's I mean luckily thank
God
well sorry so unfortunately it doesn't
have a means of abstraction so there's
no way to define something new in HTML
markup there's no access to the
JavaScript environment which was kind of
bolted on after HTML already existed so
you can create all this stuff in the Dom
but there's no real linkage to the
dynamic environment JavaScript and there
no scopez so that means that you just
are basically dumping this everything
into this global tree that you then have
to fish around in using selectors or
something to find things but thank God
hTML is kind of lispy so you know what
to do these this HTML markup over here
you can see that it's syntactically
equivalent to this Lisp markup I mean
people have suggested s-expressions
instead of you know XML syntax for a
long time but what's interesting in
closure script is that you can actually
implement these things implement the
semantics as well so in H Lisp div is
actually a function which returns a Dom
element and this is all done by the hop
line compiler which takes you know dot
HL files and for each one of those which
is you know a page the unit of
compilation is a page it emits an HTML
bootstrapping kind of minimal file just
to load a javascript file which contains
all the compiled closure script and the
Dom is actually built at runtime via
program and the front-end compiles to
just static HTML and JavaScript so you
could like host it on s3 or whatever so
this is an example page this is kind of
what you know a page normally looks like
simplified but you can actually also do
this in HTML syntax the hop-on compiler
just compiles it all the closure script
anyway so that's cool you could use your
tools like if you use Hamill or
something we could do that a tricky
thing about you know making HTML into
Lisp or Lisp into HTML is how to deal
with attributes which are sort of like
metadata on functions in a way on
function calls or rather and so the way
we do it is you could either pass in a
map as the first argument or just some
keyword value pairs and it'll it's
unambiguous because we know that
keywords can't be children of an element
but they don't have to be strings the
values could be other things which we'll
see later there's no box in your
indirection or virtual Dom's or anything
like that when you call the div function
you get a native HTML div element
that you can do stuff too but the
elements implement iPhone which is the
protocol to make something in vocable
enclosure script so you know on the the
invocation semantics of HTML is a pen
child or set attribute so we implement
that so you can basically use you can
construct custom Dom elements meaning
things that have the same semantics as a
built in native Dom element like div or
span but you can construct it yourself
and then use it in markup and so this
suggests you know you can now use
functions in place of templates so no
more printf or printf like things you're
dealing with actual live objects that
you can compose in the same way that you
compose your markup originally and those
things become essentially custom
elements that can then be in your markup
and you know somebody can use those to
build other things this is an example of
that we're making a fool iment here
which takes any number of children and
makes a div with a heading element and
then puts the children in so sequences
get spliced in as children we have this
this little macro here which allows you
because there's it supports two
different kinds of attributes two
different syntax is kind of you know the
key value pairs and the map so in order
to deal with that efficiently we have
this little macro that just collects the
attributes into a map and the children
into a seek and then calls your body so
this is an example of that so here we
have a quick list custom element which
basically rolls up all of its children
into an unordered list and wraps them
with list items and if I set the class
on this thing it gets passed down to the
unordered list that that it returns this
useful so every page which is the unit
of compilation for this thing it has a
thing sort of like a namespace
declaration except instead of specifying
the namespace name because the page is
the end result you're not going to be
using it as a library so you actually
specify where you want the the page to
reside in your document root and each
list
one refers in all the things like div
span and all the things he wants you
don't have to you know painstakingly
refer them into your namespace
it absolutely frozen up again please so
we should pointed out that we include
all those things automatically for you
html5 particular sort of built-ins but
we also have an SVG namespace and some
are more interesting work lately has
been working with us PG as if it were a
list which has been pretty interesting
and that stuff is in hop on an ASP GU
namespace so here's a sample page
declaration and you can see the refer
hoplon the second line there that's
basically like refer closure if there's
something that hop-ons bringing in
that's you know annoying you you can
just exclude it and you won't see the
warnings so like div and span and stuff
mm-hmm Dom basically the document object
model is an i/o mechanism input/output
that's the only reason it exists and
events are input in other words the user
clicks on something and elements and
their properties provide output you know
you might make something red by changing
a property you might change the contents
of a text node but what's interesting
about this is if you think about it in
terms of like one-way data flow input
and output never have to mix so you
could you know have one you could have
one operation that's setting properties
without knowing at all about what events
are being listened to and vice-versa
so basically callbacks trigger updates
to input cells meaning I click on a
button that causes some input cell to
change his value we swap on it in the
callback and that eventually may or may
not percolate through formula cells to
cause an update to the Dom in other
words some Dom element might be hooked
up to some wires up to some some formula
cell and that formula cell you know
computes that it should be read so
here's an example of that I'm defining a
cell here an input cell called clicks
whose initial value is 0 this is how
many times I clicked on this button and
then I have a button and I
have the style attribute which is being
hooked up reactively to that clicks cell
over here so I'm making anonymous
funkier and I want to set the color of
this thing to be red if the number of
clicks is even and blue if it's odd then
I set an onclick handler so here is the
callback which swaps on clicks adding 1
to it incrementing it and then I set the
text of this button to inform us how
many times it's been clicked on and it
rules don't know it does things so
what's interesting here is that you know
these attributes basically they're
dispatching on value here so if it sees
a cell as the value it knows hook this
stuff reactively to this cell if it's a
function then it says ok this is a
callback so I'm going to treat this you
know I'm gonna look for the click event
and if it's neither of those if it's a
string then it just sets the attribute
on that element the attributes these
special attributes can be extended there
are two multi methods do bang and on
bang which handle input and output so
you can add your own fancy thing so
here's an example of like the slide
attribute so you can make something like
slide up or down or you know the swipe
left event you might have cup two like
hammer J s or something so you could
just implement that with this with this
multi method and then you can use those
things as if they were already included
in hop on one cool thing about that is
that what you just showed that multi
method it lets you add attributes to
components or object custom elements
that you don't own this differs from
angular where you can add custom
attributes but it involves scopes and
various machinery and web component
specs which also require that you own
the element so in this example he's
actually teaching elements that had no
idea what swipe or any of this stuff is
how to respond to these kinds of events
without modifying them so this is any
kind of an example of a what's that like
problem
the expression problem yes that thing
and when HTML is a program which it is
here you can do all kinds of neat things
so here's a function called Def values
which is basically like in let you candy
structure you know the binding form and
the expression so this is basically just
a thing that does that but it defines
the things instead of binding them
locally so we have a function called tab
a Phi which I'm not showing here but
basically what it does is it takes pairs
of things and if you think about tabs
like on the web you click on something
and it shows the content certain content
and hides other content right and then
you click on another thing and it shows
the content associated with that tab
right so there's like a an interesting
way to generalize this so if you imagine
that the real abstraction here is a
number of triggers and a number of
contents and you just want to set a
relationship between these things that
when you click on a trigger The
Associated content shows itself and the
other contents hide themselves and when
you click on the other trigger you know
same thing happens so here we have
basically we call this this function -
tabla Phi these things but it returns
them back it doesn't compose them and
this is an interesting thing because
we've been able to decouple the
relationship between the things and
their internal state from their
composition in the Dom so the UI guy can
use this this function to create the
tabs kind of relationship between
elements but he might not want to put
them into an unordered list here like I
did he might want to put like one
trigger way over here and one trigger
way over here and it might not look like
tabs at all it's just you know
essentially a tab like relationship and
he can express that and he can make his
own custom elements that you know use
this as an underlying lower-level thing
so you can progress from simple things
to more complex in a nice way you can
also do things like this so here a lot
of times people will do like you know
div and give it a class red and that
means that you know it should be red all
the things with class red and but that's
like a weird kind of you know that
that's CSS especially with the cascading
is like a weird kind of scoping system
and aspect oriented programming you know
you're setting up a scope in which you
know and and really the the purpose of
it is to
nipple 8 properties of objects you know
like I want to set the style color
property so a more direct and powerful
ways to actually define a thing called
red div and since all these things
implement iPhone and they're all in
vocable we can just use that in the dome
and so that can you can use lexical
scope there you know red div might mean
a different thing in one context than
another you can use dynamic scope to
figure out what color it should be all
the things that that closure lets you do
already it's more powerful than CSS I
believe so castra is the backend that we
use and this is an RPC an RPC ring
middleware and I close your script
client library uses edn back and forth
so you call it like functions on the
client and you know you give it closure
script data you don't it's pretty much
transparent there's no you're not making
anything be JSON or anything like that
it has affordances for CQRS state
machine pattern and it's great with
atomic because the CQRS pattern is
really amenable to polling which atomic
is really good at like reads are free so
polling is lot cheaper than if you're
calling into you know like MySQL or
something here's the picture basically
of what's going on in the client you
call this function goes through our a
little serve like our middleware and
ring and the RPC handler looks at
authentication annotations calls an RPC
function in your API namespace and
that's basically for side-effects only
it's gonna manipulate the database in
some way it always returns the same
exact query so if you were a shopping
cart site this query might be what's
your user ID and what's in your shopping
cart say but that doesn't depend it
doesn't matter what what the end point
was that you called you call login you
call you know buy a thing whatever
endpoint you call it always returns the
same exact query this makes things very
simple because now you're your Ajax call
doesn't have to know what to do with the
response it just fires and forgets all
the responses come back to the same
handler
which updates the global state of the of
the client so the API endpoints are just
regular functions but they have these
annotations on them which are similar to
closure pre and post conditions this
allows you to to compose API functions
without mocking any state so it
separates the authentication from the
invocation
so the authentication only happens when
it comes in on the HTTP as an HTTP
endpoint and also exceptions can
percolate out to the client and be
caught so this is an example of that
it's a map where you give it a
precondition and a query which is what
it returns at the end and you can call
these things from the repple and they
work just fine they work exactly the
same way you don't have to mock any
state at all this is a example
application of what it would look like
and on the client side you create
generally three javelin cells one for
the the state of your little state
machine one for any errors that come
back exceptions and one for how many you
know a sequence of currently in progress
async calls because you might want to
know if something still loading or not
you construct the remote endpoints and
call them like functions so basically
there's this make remote function that
allows you to construct the endpoint and
hook it up to the cells then you just
call it like over here you call it like
a function and you'll have to worry
about what it returns you don't have to
this part right here doesn't have to
know how the rest of the application is
affected that percolates up through
formula cells automatically here's a
picture of the architecture of what I
just described so anyone don't have
questions thumbs up thumbs down I don't
know how
yes you say that again the question is
is Castro like shore-leave
well it's an RPC framework but the the
annotations that we do to separate all
the things that have to do with the
session basically into a separate layer
that I think that's a little bit
different so like when you're at the
repple there's no session that you worry
about you don't have to mock anything
and everything runs the same so you can
test things you can you can work the app
from the repple which I do a lot when
I'm developing the funny side note the
original version of Castro is written in
PHP that sure we all talked about all
right other questions yes
sure this one no this this one
okay I'm sorry we don't have let me try
and there we go alright so Castro defy
exports this def and macro which is
really the same as defin but it just
implements these you know these
annotations here and the precondition
generally the way we do it is we set up
a separate namespace for HTTP rules and
it's basically like turing-complete
you know authentication you just call
this thing just like a precondition and
you can throw an exception from those
rules which will be caught in the client
but that only happens at the acts at the
actual end point in other words if I
call the the login function from the
client it will run this precondition
but if login itself calls another API
function internally like sometimes once
when you register someone you want to
log them in then right so be nice to be
able to just call that API function so
it doesn't trigger any of the
authentication stuff there you know it
just calls right through and so the
query the query annotation here is so
that you could return that CQRS
state query and this allows you at the
repple this function could actually
return one thing at the repple which
might be useful for you when you're
coding it but when an HTTP client
connects they get back this state you
know this state map yes question was
what is secure yeah please yeah so all
of this is to serve one end which is
basically to be able to conceive of when
we're programming the server as part of
our spreadsheet so the same way someone
who's interested in making charts over
an existing spreadsheet can just use the
existing formulas without necessarily
manipulating any of the data or formulas
we want to look at the server the same
way so in our case here the server is
the source of a value which is the
current users state we would like to be
able to take that value and aim it at UI
elements like this little box here
should be the person's name and this
the number of buddies or whatever we
want to consider the server as like kind
of a remote cell CQRS
stands for command query response
separation that ish Mortal Fowler Martin
Fowler has a good
well yeah Martin Fowler has the right up
anyway if you type in CQRS Martin Fowler
you'll get to the thesaurus documents
but basically it's a it's a fancy term
for the same kind of pattern where I
have a source of events which in our
case is the user those events are
streaming into some remote remote data
store des Tomic and we have formula
cells which are calculating the user
state and those would be the atomic
queries and we periodically want to
update the UI based on what we pull from
the atomic but we want to do that in a
unidirectional data flow kind of way
yeah thing I think to think about is
like if you have a function that does an
ajax call to the server like the login
function a lot of times you'll be saying
okay here's a callback and you know if
the server returns true then i'm gonna
do this and if it returns false then i'm
gonna do that right so but the things
you generally want to do is you know
change the state of the application like
i want to show you an error a flash
message like incorrect password or
something right but that means that like
this piece of code that sends off the
requests log in now needs to know about
what to do with the response and it has
to know where to go to do that right and
it has to now cooperate with these other
parts of your application and now
imagine that you have 10 buttons on the
page right and you could click any one
of them in any order
so now you run into all kinds of
synchronization issues like you know
should i need to disable this button
when when i press this button and so on
so now all these things have to know
about each other very intimately and
then you change something and you don't
know what's gonna happen
whereas with CQRS things just fire and
forget you send a message to the server
and what comes back is the next state of
a state machine which could actually be
the same as the current state like
nothing might happen on the server that
you care about right and so then nothing
will change or something could to happen
but you don't need to know about it here
there's something that's looking at our
state model and saying ok when there's
stuff in the shopping cart I want to
show the shopping cart
yes
the question I think was paraphrasing
how to integrate the servers state with
the client state rather how we do that
like how does it get into the how does
it reflected in the document is what you
want to know right
right yeah go for it yeah yeah so in
general there are two approaches to
doing this thing that we need to do and
I think react represents one approach
and everything we're showing you
represents another the basic bifurcation
is between two ways to repaint the UI
one is faster one is slower one may may
or may not be inconsistent one is
guaranteed to be consistent those are
the trade-offs the react approach is the
same one that angular uses a slightly
refinement refined it's called dirty
checking and historically people who
have been writing you eyes using this
approach and there's a common list
system called the garnet or there's
whatever there's papers there's papers
check them out the thing you get a speed
because you don't need to check
everything that you're trying to update
for equality like that's the essence of
data flow is we spin through these
values that are coming in and if they're
different than ones we knew about we
need to do stuff with dirty checking you
just say hey if anything in the tree
changed we know that stuff but we're
just gonna blow away anything that
existed below it without checking it for
equality so you get speed there on the
other side which is what javelin does
and which is what spreadsheets do we do
equality checking for every value that
gets pushed in and we don't calculate
this there's really no the same whether
it's not really a concept of a diff and
a spreadsheet there isn't in javelin
what we've found in in our efforts
around this and the reason we went with
spreadsheet style data flow instead of
dirty checking is that you need to be
able to write components that compose
with each other under a semantics like
the reason we invented this whole thing
is because we had a product with a front
end and we had the it was for a meal
delivery application we needed to
rebrand the the actually this is stuff
me sure worked on before I joined on I
just showed up in the very end like it
took all the credit but it was an
application it was like a ten billion
line PHP jQuery shenanigan and it had
all the logic in it encoded obviously
but it was impossible to maintain and
then the requirement came down hey take
this business logic but let's white
white label it like instead of this
being meals for you know this
demographic we want to shoot me
these people is that possible this came
down to misha and i guess your short
answer is no it's not possible
to pull anything reusable out of this
app because the logic and the viewer it
is so deeply intertwined yeah and i
think to point out also is that so about
the dirty-checking the way javelin works
is you can imagine a graph of cells you
know that are kind of organized by the
relationships to each other in other
words a formula cell might depend it
might refer to other cells so that forms
a graph but it's this this directed
graph and no no cell will will trigger
any updates if its value doesn't change
so there's like very aggressive pruning
that goes on just naturally in other
words if if an input cell changes it
might cause one formula cell to change
but if that's where it ends and that's
where it ends so if you have a lot of
Dom elements that are looking at all
these other formula cells nothing
happens because no values change however
if the values did change then you
definitely need to update those Dom
elements anyway no matter what because
they're no longer you know consistent so
I think another thing to look at
comparing these two approaches is like I
look at the Dom as this input output
device and react seems more to me like a
buffer kind of like Emacs you can type
around an Emacs and Emacs has I'm sure
all kinds of clever tricks to avoid
repainting the entire thing when you
type but it's still the abstraction is
still a buffer you know that's a
sequential thing the Dom is a little bit
richer than that in that it gives you
kind of more like a file system of
buffers you know you have this tree of
buffers that you can kind of read from a
right to individually right and so now
you can you can be treating each each
Dom element as a buffer and doing things
to them individually and once you have
if you're working with the the Dom
element itself right unlike everything
involving i/o is stateful when you have
a file handle that's a stateful thing
because you might write to it Andy to
keep track of its buffers it needs to
keep track of you know whether things
are flushed to disk or whether you could
read from it or write to it or what so
Dom elements actually act the same kind
of way and so you can do like in that
tab exam
where you can pass Dom elements to a
function that doesn't know what they are
at all and they just apply magic to them
and then these Dom elements remember the
magic in other words attaching an event
handler to something is a mutation
because it has to keep track of what it
needs to notify so that's a very
powerful thing when you're working with
the actual Dom elements because you pass
them to this one function that just
arranges some relationship between them
and passes them back and pass them as
something else you might be mixing
elements around and then you compose
them later so you're not you know you're
not bound to any particular composition
I think actually we're out of time I
think we should leave you with what Misa
just said which was remember the magic
that sounds cool but we'll be around if
you have questions wanna chat hopalong
do is the place to go and learn thank
you so much for your time and thank you
Alex everybody else</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>