<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From Linear to Incremental - Christophe Grand | Coder Coacher - Coaching Coders</title><meta content="From Linear to Incremental - Christophe Grand - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From Linear to Incremental - Christophe Grand</b></h2><h5 class="post__date">2013-01-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LtTsJkVLBqI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so Stuart Holloway is kind of exhausted
from drinking from the firehose of
closure wisdom or at least drinking I'm
not sure so he called in a stunt Stewart
to do the remainder of the introductions
and that's me so our next speaker
Christoph grand is one of the authors of
the upcoming book closure programming
not to be confused with programming
closure and according to his blogger.com
profile his favorite movies are blade
runner Being John Malkovich and the
nightmare before christmas I think this
has influenced his work on closure so
Christoph grand
thank you can you hear me or her I'm
here to document how I managed to turn a
second short computation into an
incremental one that is how to transform
11 processing into a differential
processing which is which will be able
to compute our weather too well compute
the the result of a function by only
knowing the diff which is to be applied
to its input at the french at the
fraction of the the original cost so in
the binning in the beginning that was
the first session I always been positive
when working on text details by the fact
that you can't report the the all input
file at each keystroke it it's simply
too much costly and even minor things
like changing the name of a symbol is
going to close the necessity to rip out
the old file to have a past three and
not having a canonical past three is a
real problem because in in text editor
then you have to rely on act on reg ex
and unelected and there they are all
unsynchronized and you will I on them
for things like structure or syntax
highlighting for parents matching and
even for switcher for structural editing
and I i had the infusion that there was
certainly a way to to take a stoner
passer and make and make it recompute
the pathway in sub linear seven your
time in the best case i sued that that
we should be able to work compute the
past three in logarithmic time
incremental is quite an overloaded
keyword in most of the time you will be
airing about editor saying that that
they have an incremental proceeding but
in fact what they have implemented isn't
is a respectable one they check point
the the computation along the input and
when you perform an edit on the input
you simply go back to the checkpoint
just before they did and repair the
computation from there oh there's a
deceptively there is a text editor named
ye or why I don't know how it's
pronounced which is an SQL editor which
is vegetable but which is lazy at the
same time so it doesn't have a patrick
the pathological case of whistle t-ball
passer resultant answer of the pathology
cathode pathological case that if you
make the Edit at the start of the file
you need to without everything so E is
better by being lazy but if you do
multiple edits like in the structures in
social edit where you decide to wrap
everything in in between parentheses you
have an idiot at the start of the file
the other at the at the end of the file
and so even by being lazy it from the
end of you will have to repass
everything so a presenting of i/o where
you wanted to get the full past we add
only a fraction of the original cost so
from a very very very high level point
of view a passer is simply something
which consumes a stream of tokens a
stream of characters which go which
consumes a string and it can be seen as
a simple rejection it this expression
get we reduced our step in it input
that's all and many if not all
computations can be reduced in into
something which resemble that expression
so so the problem of turning her into an
incremental puzzle seems to be a general
a general problem he so let's let's try
to search the general case and at last
college I promise too many people that
lastly we will be done would be done
before Christmas but I never precisely
which place mess so by delivering it in
June I was way ahead of this Christmas
there was some details I at the time
that I had overlooked so what I'm real
interested into is an outcome to compute
radius R step in its input prime 11 the
result of wedges passive in input and
the difference with between input and
input prime so there is a famous toward
bye guys tale about reduce being
considered slightly i'ma fool the
problem with videos is is that it it
doesn't constrain it doesn't put enough
constraints on the functions your
function can be know anything and if you
want to have parallelism for example you
you are going to want to have a natural
function and Franklin incrementalism is
the same thing because increment ism is
paralyzing with your former self so as
you should associativity is pretty good
a it early you to turn a second short
processing like the front III under
under light on your left on in through a
balanced tree and answer you have the
balance three if each node is a
nighttime of the input collection if you
know that 11 aight imma change you
need to recompute all the parent chains
which is you only need to recompute a
logarithmic number of nerdy but sadly
math functions are not associative and a
passer by definition has no change of
being associated because a puzzle take a
state and the token or a piece of
characters and return another state
initiative function need to have
everything of the same type but I stay
determined to spread some associativity
out of the Swedish so we can picture
videos like like this there's the
initial value and at each page there's f
which is combining the in the current
state with one item but if we wait the
collection to do not see the creation
anymore each item is independent and
that we see each step like like like a
pipeline which we can imagine that F and
a our partial function so we can see
rejection like the application of
several partial function EF AFBF cfd all
these functions can be composed together
to form a big composed a big composition
so here yeah I have only four functions
but if I want to generalize to any size
of input I'm going to replace the the
code to count by reduce comp over the
collection of of the four partial
functions and the collection of the four
partial function itself can be produced
by a map over the original
over the original collection so I had
the original clinic prediction I map I
map it to get a collection the partial
function that I compose and then I've
got a big function that I can pass the
initial state to and I get the result
value and the good the good news how
that comp is associative so we are going
to be able to organize the composition
into a nice three so is this incremental
yet in detail if I change C in C prime I
only need to recompute all the nodes
which are in blue so f different the
first partial function and then the
parents composite function but the
problem is that it's only the
composition which is incremental not the
computation itself indeed if we picture
the actual computation the first time we
go through the composition of the
composite function in this picture each
box is a function the bugs are with
dashed borders are compositions and red
arrow is the institution flow so the
first time we want to compute the
differential we need to go to two or
function this is this is normal and the
second time everything that is white is
odd function or nodes of the tree but
still we have to go through all of them
so it's quite ineffective but in it or
input is constant it's always the same
state with which are which is put at the
as the initializer of the computation
and since I add the infusion of
incrementalism it means that most of the
time things don't change
match so let's hard to memorize that
what I'm going to memorize I'm going to
make my eyes the wizard of map and comp
we did the resulting function are going
to be memorized this is not map and come
by themselves that I'm going to memorize
so if we memorize not since the initial
state is always the same ha I can be
sure that the second time I try to
compute the the composition of F a and
FB Cindy in the initial state is the
same I can skip the computation and go
straight to to the next but then I
stumble on FC Prime and the FC prime is
new since its new is it's not only going
to return a new value and FG this
despite being memorized won't be able to
use the cached function and so will have
to be executed again so it's better but
everything past the the idiot everything
past the item which has been modified
need to be recomputed so basically if
you have the composition three and
memorize function you have the same
behavior as for with suitable passer but
a resettable passer is far simpler to
increment so it is still not enough to
go further I need I needed to look into
F right now I have just talked about
reducing a function over a collection
without really talking about talking
about the properties of the function x
by itself so now I have to look under
the end of the road and
we have nice properties of it passes and
we certainly can use these properties to
to be able to build a better memorize so
what exactly the or function is a puzzle
step function D that is the function
which which is executed for each token
or each character of the of the path of
the input and in the case of parsley I
picked something very simple good old
allow I just put something else fish
which is the contextual tokenizer but I
put the contextual tokenizer for other
purposes purposes which which are to
make the puzzle to tour a passive answer
is going to retain the past three even
if your input is complete is completely
broken so allow allow if you remember
you your compare compare lessons it's a
pushdown automaton and that is basically
to one final state state machine with
two stacks one stack for nod and once
that and one stack for states and at
each tape the current state that is the
the state of both stacks is going to
change we are going to perform push
people on both stacks but we never look
at the entirety of the stack we only
look at the end top items of the of the
stacks and we never rely on the length
of this tax by themselves so we in we I
know motor Dean
most of the data so we really only
depend on the top actor by tens of each
stack and by construction this since
they are stack stuff accumulate during
the completed computation on top of each
of each other so at the top of the stack
you have items we which has which have
local meanings and at the bottom you
have items which have global or distant
importance so we it means that we are
able to predict what what step is going
to do only by judging the values at the
top of the stack so as long as those
values don't change we don't care about
what's below in the sack and this
property or through for composition of
our steps which mean that even if you
are replying 100 of steps as long as the
the value you need at the top of the
stack don't change you don't care about
what's below so I am able to perform
stacked stack transportation and on the
first goal if we have a stack of six
item and out of this six items tagged
only those three first are looped at and
that the out output from i will put
stack is a Z cgf we can see that the
modification on top of the stack which
is to put to pop a B and put and put z
instead only rely on the fact the
a B and C we are there so it means that
it when the next call arrived if the new
stack as a change but still at ABC at
the top I can take the bottom of the new
stack and the top of the old result and
grab them together and this is what I a
poor transportation but to do that you
need to have a kind of watermark during
the first variation to know what is
going to be useful so it's kind of
differential memorization usual usual
memorization is going to only return a
result if you pass in the exact same
argument while there I'm able to adapt
past Wizards to new inputs without free
computing the OL function and so once
again if you do that for big composition
you are going to save a lot of
computation obviously it still work like
memorization if the hint Buddhist is too
different from what you already know you
simply call the actual function so with
transplantation the execution looks like
this the first big white block is kept
like before because it's fully memorized
it is the same input so we skip it then
f FG prime need to be computed since its
new but we are able to adapt the new
well the new output value of epsilon and
since we are able to adapt it we can
skip the the effect the actual
computation of FG so here we are really
increment implemented since only the the
function which which has changed as
being were computed but in the world
case if the differential memory
memorization fail for FG will have to
recompute FD so the worst case is going
to visit the ring to add the same
performance profile as researchable
passing but it's not an all on nursing
your preference profile you there's a
lot of things which can happen between
we're computing only one node and we're
completing everything go past this point
I i have with witness some quite
interesting pattern at some times where
you you have some nodes locally which
are we computed then everything else but
this point can be reused and later on
the does there's new nodes which we have
to be were computed again because they
are not corresponding to for example to
closing parenthesis which was modified
by the first ad so two references
transportation one need two functions
the two function which which are needed
are one which approximate dependencies
between output and input this is what
what I named the watermark and it was
figured by the dashed natural red line
and Europe you also need a function to
adapt a new input a known output to a
new input
but the do is function are totally
different and the algorithm in fact they
are so dependent on the algorithm that i
have only show you the the
transportation technique for the state
stack it's a completely different
transportation technique for the not
stack if i apply the same technique to
do not stack it would be too close and
the memorization will fail every time to
track dependencies I must admit that I
used side effects I have collection
mutable creation which are interment
instrumented to tell me which items i
have looked had or which item are pushed
and so on but all this mutation is
strictly scope to the step function so
it won't leak out of the step function
and i have also changed contract of the
step function now the cell function with
on its result plus the watermark so
inside the temp function I have made
many things mutable simply because we're
at work I would everything in a purely
functional manner it was through I
provide it and i see that i was chillin
too much and too me too much too many
objects inside the step function so I'm
I made many things mutable and it make
it made things easier because anyway I
was always already do doing side effects
to track the dependencies and I also did
another modification which is that
instead of looking at only one token app
a step is going to work in a chanct
manner so as to
do we reduce memory override of the
composition to eat so just do not have
one function character and also to
reduce the what the context switches
between being the purely functional
outside of the step function and being
visible inside so the the primary API is
the buffer this is the what what path he
exposes there's the first the passer
function which which returns the guy to
your password and we simply take a
grammar specification and some options
then with the puzzle I create a buffer
it's really a buffer like a technophile
you you can add character and remove
characters in the middle of the buffer
and you do that with the edit function
and once you have an audio edit you call
pathway to perform the actual
computation and get the pathway one is
interesting property of having edit and
pass sweet is that you can you can work
in it somewhat transactional manner you
can perform several edits which are not
going to complete anything just change
the composition of the function and then
pass three is going to do the actual
composition only once so you as you
don't have computed the intermediate
immediate pathways so the
I said that input input it shanked so if
you remember hi Adi the courage the
tradition the incorporation so we choose
a correction of change my checked by
default lines or several lines if the
line south are too short and I have one
from simply one faction / from all the
updates under composition three
previously all the composition three I
have shown where twist which were easily
balance because they had a power of two
number of lives and to really implement
the composition three which needs to
grow and shrink as you add or remove
characters out of it I use a 2 33 with
where the leaves are of the of these
three are the partial function we have
seen before the hay faf BFC hg and so on
and the internal nodes are the
composition plus the de nada after you
know the length that is the length of
the of the text which is behind the
dinadh simply to be able to to know
where to perform the way I did witness
will invalidate sorry a finger three may
have faith but a it's him it's an easier
to simply use to suit at 233 and I
didn't need the privileged access that
finger to free gave gave to both ends
because I only performing truly one Dom
edits in the middle of the tree and
another point was simply that i was a
bit confused at some point between all
the trees that we are going on there was
the
past three the completion composition
three and one or two other so when we
have seen our updates perform it's a
process etc if you pair from an inset is
going to rue the composition nodes below
until it has a inner energy egg onion if
the composition adult as already enough
children the compression nut will be
played and the speed will propagate
towards the root deal it is the
observable other way around if a
composition node has only one child its
major we with its siblings so that's
only a little demo
yep
so bit crowded here
let me first increment or the card
differently I can see I can't see
anything
okay so this is a simple pasture for a
simple expression grammar where I i
define ear that an expression is either
a lift or a symbol and the symbol itself
is anything that that match that matches
the dis forget and the list is the
concatenation of and up and opening
parenthesis zero or more expressions and
the closing parenthesis here are some
option to specify that at the top level
we can have any number of expression we
want this one just for the name of the
synthetic route and I also specify that
between each token there can be spaces
so I evaluate this ok today we evaluated
tears and the TP are only 420 printing
here i'm going to create an empty buffer
for the for the parcel that's done and
if i look at the
past three of the empty buffer I get
this but I pretty print it and it's
simply root and empty would the printer
printing is going to be vectors of felt
the name of the node and then the
children so we simply have an empanada
in the world here are some l / function
to generate some random input let's see
okay it looks correct yeah
so this is the random input air
generating I'm going to try to pass this
random input what we don't see anything
so i added the dmt buffer at offset 0
and falling 0 and I add the old input
into the buffer and it takes some time
15 minutes ones and after that i'm going
to ask for the past three so the 15
minute michigan's were only for the
composition of the function so to come
to really compute the past week so to
really perform the computation it tooks
nearly 200 milliseconds now i'm going to
pair from a little edit in the middle of
the input add of the 13 i am going to
change one character to s let's let's
see where we are subs
ok so I'm going to change it one ello
certainly so let's perform the 'edit ok
it took one millisecond to to recompute
the new composition the new composition
and and now i'm going to repass the
whole thing and keep in mind that i have
performed an idiot at this at the
offsite 13 in an input which is a nearly
5,000 characters around so I'm quite at
the start of the input and passing the
all things add took 200 milliseconds
repassing to this time take only six
michigan and they have made the change
at the start of the file so really I'm
incremental if I have been with the
table I would have were computed
everything in in nearly 200 milliseconds
we can look at the at the resulting
password just to check that it is valid
or if the pretty one thing which should
take some time or now I didn't send the
comment maybe
ah ok yeah so let's look at this as a
Terp we should find an arrow which has
been changed to something else now I'm
too high air area
okay this this was a minor I did inside
the symbol it doesn't change the old
structure of the other file we can try
another kind of I've edit we are going
to add an open parenthesis at the start
of the file and see how the pastor
performs ok and now so one millisecond
again to to compute the new composition
and to compute the new past three
one-tenth of the original time and I
have changed the whole structure of the
pathway I have we based it by adding a
new know that the route 40 printing
again
there we go I am trying to find the
start
well
home window
enter a wealthy
I can't see anything
yeah this is what the new past three
looks like there are new unfinished nada
instead of what where previously we have
we are the root node under list node
because i have only inserted an open
parenthesis without closing it parsley
recognize this and generate an
unfinished nada but better that past
this point eat the whole past three okay
that's all for for the demo and so what
next I'd like to refine the way i
compute dependencies because the more
fun granted you are in computing
dependencies between your input and your
how to put the more effective you are
reusing previous computations and I'd
like to take some time to think add on
out mechanized that I think that we we
met it may be possible to automatically
derive search function from the original
function what would be also interesting
is to implement a more interesting more
beef you're parsing algorithm like gle
and finally this is my noble practice
practical practical feature I like to to
bridge with my reg ex dsl to be to make
it easier for low follower for example
which with already using posse in
Kentucky lockwise to perform all the
other passing all the virtual editing
but which has to maintain currently
her grandma which is a bit ugly when it
comes to taken definitions and I also
I'd like her so to to make the part
which are imperative a bit nicer and to
add better caching strategy right now my
memorization is just a one-shot memory
just memorization I only compared to the
previous result and I'd like to use some
some pluggable caching strategy but
Michael focus has already done done the
library so hi honey need to integrate GT
it thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>