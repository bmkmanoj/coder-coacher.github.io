<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Colin Fleming - Cursive: A different type of IDE | Coder Coacher - Coaching Coders</title><meta content="Colin Fleming - Cursive: A different type of IDE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Colin Fleming - Cursive: A different type of IDE</b></h2><h5 class="post__date">2014-11-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vt1y2FbWQMg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone so as Craig said my name is
Colin and I'm going to be talking to you
about cursive which is 90-year you might
like to use to edit your closure code so
I've been working on cursive on and off
for a couple of years now the first
public beta came out about a little bit
over a year now in October of last year
and since then the response has really
been great as Craig mentioned it's now
officially the second most used editing
environment for closure beat them by one
vote yes but it's really fantastic I'm
really pleased everyone likes cursive as
much as I do it's as I'm very pleased
it's currently developed as a plugin to
and tell EJ so you need to download
IntelliJ and install it into it it does
work with free community edition of
IntelliJ so you can just download it and
plug it in it will eventually be a
standalone IDE as well so JetBrains who
make IntelliJ a couple of years ago
split IntelliJ into what is basically an
IDE building platform and also the IDE
functionality that's built on top of
that all the Java support which is now
just a plug into that to their platform
it will be commercial I'm going to be
charging money for this just so
everyone's aware of that up front it'll
cost more or less about the same as the
as the smaller JetBrains ideas so
pycharm for Python or Ruby mine for Ruby
if you're familiar with those so it's
based on a very old Fork of like loggia
which was the original Clojure plugin
for IntelliJ and that was actually
developed by a couple of JetBrains
employees in their spare time but it was
never really a focus for JetBrains as a
company so I don't think any of their
employees actually ever were paid to
work on it for any for any reasonable
length of time and it was sort of
languishing a little bit so they got a
little bit of updates but really nothing
was happening to it so I started using
it because I'd been programming in Java
for years and I was used to IntelliJ I
didn't want to have to learn Emacs or
whatever and so programming Clojure but
I very quickly got frustrated with it so
so I forked it and I started up data but
the problem was it's all written in Java
and I didn't want to be writing Java I
wanted to be writing closure so I
gradually migrator the interesting bits
from Java to closure and now pretty much
all the interesting codes written in
closure so I'd like to put a little demo
just of some of the basic functionality
so you have some kind of idea what it
looks like
so all your basic functionality work so
things like you can get your completion
here it shows you the name it shows you
the AG list the namespace things are
coming from and this works equally for
for your local symbols here or something
for closures at core like different for
example and again you get all your
information articles in the completion
you can get your Javadoc there it
actually doesn't come up very well in
the IntelliJ presentation mode but
believe me that is actually the Javadoc
for different you can get the
information on the parameters while
you're editing your while you're editing
a particular function of vocation you
can get the source code of something
immediately in a pop-up there you can
see all the symbols that are in your
current file this is just a small file I
have as a demo so there's not a lot
there but that's you can see them all
pretty easily so the thing that might be
surprising about this too to most of you
is they don't have a ripple running so
all of this functionality is provided by
cursive by statically analyzing the
source code
so odds are statistically most of you
are using one of these to edit your
closure code so these all have one thing
well one principal thing in common which
is that they're basically text editors
they really provide no syntactic
analysis or semantic analysis of what
their of the actual program they don't
really understand closure at any sort of
fundamental level the fact that they're
so what they basically do is they will
connect to a ripple and all the
information the editor functionality
will actually come from the report from
introspecting the ripple so you're
looking up the documentation it will go
out at the ripple look up the
documentation from the metadata of the
bar that you're talking about and show
that in the editor so this has the
advantage that it's very accurate right
so you you start up you have a copy of
your system running and the editor knows
exactly what's there and and people
really like this feeling that you're
kind of interacting with your
application that your applications like
a sort of living thing but they're very
accurate only for the information that
actually exists at runtime which
enclosure is basically bars bars and I
guess Java classes as well so there
require your application to be running
where you get no editors support and I
think pretty much everyone's workflow as
you start up your editor you start up a
ripple and then you're good to go but I
think the most important limitation of
systems like this is they don't allow
indexing so indexing is really the basis
of a lot of really interesting
functionality that I think is pretty
fundamental to to be able to develop
particularly renaming for example so so
if you rename a symbol we need to be
able to rename not just the symbol but
everywhere in your and your project
where that symbol appears and you really
need some sort of indexing to be able to
do that so why would you want to use
something like IntelliJ to edit your
source code so intelligent provides true
syntactic analysis of your code so if
you're programming and here I'm mostly
talking about using Java for IntelliJ
that's the the main implementation as by
far the most mature language
implementation they have so when you
open a project and IntelliJ it will
actually parse the entire project it
will index it so it actually builds a
syntax tree for your entire project
indexes all the useful elements and that
allows a lot of really really
interesting functionality
the refactoring is a totally integral
part of the workflow of anyone working
with IntelliJ and when I'm working when
I'm developing Java and IntelliJ I'm
continuously refactoring things I'm
extracting variables I'm extracting
methods I'm moving things around I'm
pushing out parameters it's it's an
absolutely fundamental part of the way
you work and the navigation is also
totally flawless again it understands
the whole project has a little index so
it can provide all the navigation that
you might want while you're actually
editing your code this is particularly
important in Java or any sort of
object-oriented language we have really
deep hierarchies so you might want to
see things like where a particular
interface is implemented Waddle your
super classes or your your subclasses
are and all that is is totally flawless
it just works perfectly every time it
has a really interesting system of live
static analysis and the editor so it has
a system of inspection so while you're
actually working on your code the IDE is
continuously running static analysis of
your code and it marks the errors or the
warnings right in the editor and it will
often provide quick fixes for them for
them there as well and it provides what
are called intentions which which have
really tiny code manipulations just so
things like I want to swap the sense of
this if statement I'll just swap the
effing else branches and we'll swap the
sense of the of the predicate and so and
it has hundreds and hundreds of these
but for Java so the sum total of all of
this means that when I'm working on Java
with IntelliJ that I actually feel like
I'm working directly on the syntax of my
program I feel like I'm actually
manipulating the structure of my program
directly and this is because the
commands that are provided by the editor
very directly represent exactly what I
want to do so the conceptual operations
that I want to perform in my program
provided to me in the editor as as
direct commands so I don't have to be
messing around with text there's no sort
of cutting and pasting this around or
per edit or whatever the IDE I just tell
the editor exactly conceptually what I
want to happen to my program and it does
it and it does it right pretty much
every time so this is always and so
none of this comes for free obviously
there's a performance cost to a lot of
this functionality there's a memory cost
so you probably need a more powerful
development machine than if you are
using Emacs or or whatever but and all
this it's very complex functionality as
well there might be bugs in that
whatever but in a perfect world when all
that works it's incredibly it's
incredible how much that just removes
all the distractions from your
programming and it allows you to really
focus on what you're actually trying to
do because let's face it when you're
sitting down to program what you really
want to be doing is thinking about the
problem you're trying to solve and
manipulating your program to achieve
that result and this is always my
ultimate aim with cursor if I have a
really really long way to go partly
because of the characteristics of
closure as our language but also because
it's taken dozens of people way smarter
than me a decade to do it for Java so
there's a long way to go but it's
gradually getting me a bit by bit and
that's always that's always mail to my
aim if and even if I never actually get
there so this is something I see online
quite a lot and tells you it's great
Noor but I type much faster and an MX or
berm or sublime text or whatever it
happens to be there something is pretty
misguided I think I think that when
we're working on our programs our
tooling should provide support to
directly manipulate our programs we
shouldn't have to be mucking around with
text I think lack of typing as a feature
when I'm actually not typing very much
in IntelliJ it's not like I don't want
to type because I'm lazy I know how to
type
I can type quite fast but if I'm not
typing that means I'm able to express to
my editor
exactly what I want to do in terms of
higher-level operations and that's what
that's why I think we need to achieve
I think text is the wrong level of
abstractions rather than have
programmers and I can see it might be
jumping up and down now saying I have
paired it I don't need all this power
that's great cursive provides a pretty
much a full implementation of parody and
you definitely need it for any sort of
parenthesis based language but it's not
sufficient it's not really syntax aware
it doesn't really understand your
language at all peridot works
equivalently for any list based thing so
you can use it for either scheme Common
Lisp Clojure whatever but it works
equivalently for all of them because it
doesn't really understand
any of them except at a very basic level
so I think of it as the equivalent and
English of making sure that all your
sentence is in full in full stops you
have to do it obviously it's very
important that you do it but it's far
from being the most important or the
most interesting thing about the grammar
so for those of you using Emacs as a
project called clj refactor I haven't
actually used it myself because I don't
use Emacs very much but from looking at
the documentation this I think is much
more what we need to be aiming for so it
provides again these kind of
higher-level operations which are
working on specifically on the language
so one thing to notice about it is that
it's clj refactor it's specific to
Clojure and really you can't have
sophisticated tooling without it being
aware of the language that you're
editing down to a level that Parata is
not and this is another thing that I see
quite a lot never send an idea to a
programming languages job and this I
think probably comes out of a lot of
people's distaste for Java and again I
think this is also quite misguided I
absolutely think we should be trying to
have more sophisticated languages more
expressive languages better languages
and it's really exciting to see in the
last sort of five years that there are
more much very interesting languages
coming into the mainstream but I think
it is the support is largely orthogonal
to language features they really don't
have that much to do with to do with
each other and I think more
sophisticated languages could
potentially benefit even more from the
sort of support if you imagine languages
with very sophisticated type systems
Haskell ok more languages like this I
think they could have really really
amazing support in something like
IntelliJ so the main reason this sort of
support doesn't exist in languages is
that it's very very hard to develop I
mean it's really it's a huge amount of
work IntelliJ is millions of lines of
code it's easily equivalent to to the
complexity of writing a compiler for the
language and it may is probably even
more than that because it's a compiler
that also has to deal with the fact that
your ast might be broken at any time or
in fact absolutely will be broken all
the time
while the user is editing their program
plus you need a whole bunch of extra
functionality on top of that so they're
they're very complex pieces of software
these days but the fact that it doesn't
exist doesn't mean it's not desirable
and I think a lot of people conflate
that that into think going in my favor
language doesn't have the sort of
support and there must be because it
doesn't need it and I don't think that's
true I think I personally believe that
most languages could benefit from the
sort of support but it is very very
difficult to develop I don't think we
should confuse those two points so I
wanted to talk a little bit about the
infrastructure that IntelliJ provides
and now I'll talk a little bit about how
of course it takes advantage of there so
one really fundamental concept in
IntelliJ that that most other editors
don't have is the concept of references
so given some program element that's a
reference to something else what does it
refer to where is the thing that it
refers to what sort of thing is that
what can I do with them and this is
required for pretty much all sorts of
our idea magic any slightly advanced
functionality that the IDE does is based
on this so an intelligence is a cross
language so when you have some closure
source with any sort of Interop you have
symbols they're representing classes
methods and these all are references to
their corresponding java elements and
the in the syntax tree cursive also
provides some support the other end the
other direction so from your java source
if you're using RTI or api dot bar
somewhere that to call into closure from
java it provides some support for that
now and of course classically in Java
right the years there have always been a
lot of references from XML and to Java
code so the key operation with a
reference is resolved
so given something I call resolve on it
and it gives me back the thing that it
refers to and implementing this
basically simulating the language
semantics and the editor is a lot of
work so I have here at accounts around
60% of my time I think that's probably
not true anymore the infrastructure in
cursive is getting pretty good now it's
mostly I wouldn't say it's done but it's
getting to the stage where most of the
work is done but certainly in the first
year of serious cursive development I
would say at least 60% of my time went
on this so here's an example just to
illustrate and there's two little
functions there you don't really have to
care about what they do that's not so
important but so here the blue box at
the top of item check that's the
definition or the declaration of that so
you're declaring or defining rather a
function there called item check and all
the item check
elements below with the orange boxes
around them those are references to them
so if I have any one of those later item
check elements I can call resolve on it
and I'll get back the blue one at the
time and this works equivalently for
local and for global symbols and also
for symbols and across different
languages all of them so the inverse
operation to resolve is called find
usages so this is basically resolve goes
from a reference to something to the
definition of it and find usages as
given the definition of this thing what
are all the things that reference it so
the classical operation you need that
for is renamed right if you want to
rename something you need to rename the
thing itself and then you also really
need to rename everywhere there are
references to it in your program so this
is based on an inverted index that
IntelliJ maintains of all identifiers in
your program and so when you call this
operation it'll actually go through and
basically get all the words in your
program that looked like it might be a
reference to the thing you're asking
about and it will check to see whether
they really refer to it or not so
intelligent multi-core support this is
all done in parallel so it's actually a
pretty fast operation so this is used
IntelliJ actually as a user facing find
usages operation I I think this is an
absolutely fundamental tool for
development I don't know how anyone
lives without it to be honest and also
but it's also used under the hood in
most refactorings and a lot of
inspections again this is an incredibly
common operation and again anything
interesting in the idea is going to have
this in there somewhere
it has a really great indexing framework
so it actually has a couple of different
levels of indexes I'll only talk about
the one that cursive actually uses a
user thing called file based indexes
which is essentially you can think of it
as a map so it has a kind of MapReduce
architecture so I register with IntelliJ
I have these indexes and these are the
file types that they're interested in
IntelliJ will call me back saying I have
these new files of this type and then I
return back the index data
so I basically returned back essentially
a map the keys and values are totally
arbitrary data and by providing a
serializer to IntelliJ
I can use whatever types are lying so
I've provided the serializer to IntelliJ
that allows me to serialize arbitrary
closure data so this is actually really
nice so I can now index there
everything and when I look up something
in an index I get back a cloture map it
works really really nicely with Clojure
and the keys that just used to look up
obviously so implicit in one of these
index entries is the file where the data
was actually encountered so I can now I
can also I can query based on any number
of scopes so I can say get me something
from these indexes but only from
production code or running for test code
or only for my project code but not
libraries or only my library card or any
code from this library it's very very
slick and and the really really clever
bit is that indexes are automatically
updated so as you're editing your your
program obviously the index data can all
get out of date and IntelliJ is very
very good at updating those so it'll do
that when I actually ask for some
information from the index IntelliJ will
realize that some files that might be
touched by that index have been updated
and at that point that will rien de X so
for me as a user of the API the index
data is always up-to-date and that's the
piece of code if you're employing an
editor that you really don't have to
write yourself it provides some support
for refactoring but the refactoring
supporters you don't get an awful lot
out of the box so the problem is that
refactoring is even the same refactoring
for different languages are actually
pretty different so an extract method
and something like Python is very
different to Java so there's really not
a lot I can do to provide a lot of this
out of the box so what it does is it has
sort of like a workflow framework so it
has essentially the workflow that you
would normally go through to provide a
typical extract method operation for
example and you can plug into that at
different points and you can customize
for the language that you're supporting
different aspects of of this operation
at different points the one thing that
you do get out of the box for simple
cases is renamed because again the
symbol resolution works and tells you
you can just say okay you're renaming
this thing you have a bunch of symbols
that are references to it I'll just
assume you want to rename those to the
new name as well but everything as more
complex needs a bit bit of work
so again the the inspection so this
provides real-time lending and static
analysis and the editor so if you're
familiar with tools like gibbet or
eastwood they generally run offline
IntelliJ provides the infrastructure to
provide that sort of tooling live in the
air and again it's all marked live as
soon as you change something that would
produce an error it's immediately marked
and it's often this often affects
provided as well so for something like
gibbet you can imagine normally cabot
will run over your source code and will
say hey at this file this line you have
this piece of code you might want to
replace it with this other piece of code
so an intelligent actually provide a
quick fix you just go to the warning and
say make it look like this and it'll
that'll work as a really fantastic
infrastructure there are multiple
different passes with different
priorities at different stages of the
analysis most of the analysis is
asynchronous they have separate high
priority passes for the visible area
it's all run in parallel on multi cause
and when you're editing and updating
your your program it's very very good
identifying the minimal affected scope
that it needs to Rhian spec in order to
maintain those annotations accurate and
again the intentions are these kind of
micro refactorings I spoke about earlier
so inspections will warn you about
potential problems and your code things
you might want to look at things you
might want to change intentions will
allow you to modify your already working
code to produce more hopefully working
code these are often used as fixes for
inspections but they're often standalone
as well in their context-sensitive
so you don't have to remember a million
different key combinations for these
IntelliJ will prompt you and if you're
in a point where you could apply one of
these things and you can just
automatically accept them so things you
might want to do in closure for example
if you're refactoring a piece of code
and you end up with one lip lock inside
and now there you could merge those
together if you have a really long lip
block you might want to split it for
some reason if you have a long lip lock
and you realize suddenly that a variable
in the middle you want to use a fleet or
win litt you might be able just split
that out converting on a lot of a
function literal to to an F in form
something like that so again none of
these are particularly difficult or
onerous if you're good with Peres dirt
but the sort of all the operations that
you need to do to perform these
transformations
not anything to do with the conceptual
operation that you're trying to perform
and that I think that's really important
I think it's really important that your
editor allows you to directly Express
the operations that you're trying to do
so I'm going to make a shameless appeal
to authority here for those who don't
know Olin shivers he's been around
forever in the scheme world object to
doing things that computers can do and
so do I I would like my editor to do
them for me
ironically probably uses Emacs so I want
to talk a little bit about the
implementation of cursive and in
particular the most important problem
we're doing something like cursive or
implementing any sort of ID for alice is
macros so cursive works on the
unexpanded saws and obviously macros can
do absolutely anything when you expand
them and effect enclosure most core
functionality of the language exactly
macros so a lot of things you think of
as being primitives in the language
things like iffen and lit they're not
actually core language forms they're
actually macros inclusive has no way to
automatically see inside a macro to see
what it's doing so the most important
thing that generally we want to see is
what are the VARs that this macro
defines what are the local bindings that
this macro defines and what are their
scopes and often symbols that are
defined by macros may not even exist in
source code at all and this is something
that traditionally IntelliJ is a bit of
a problem with because in a traditional
language everything is defined somewhere
in your program but in closure if you
think about if you have a record you've
defined with different record it will
create a constructor function for you so
this is this thing with the arrow
pointing to the record name so it's just
a function you can use to construct a
record that has no representation
whatsoever in your program so you have
to be able to handle that which is
tricky so the first thing anyone says
when I tell them about this they say why
don't you just expand the macros it's
easy right so the problem is macros are
completely arbitrary code so they might
never terminate and you can never tell
ahead of time whether they're actually
whether it's actually no terminate or
not you can't look at a macro and work
out whether it's going to finish
that's the halting problem which is a
fundamental problem you cannot solve it
could use a huge amount of resource it
might use a lot of memory it might take
forever I might cure bunch of your disk
space
you don't really know it could format
your hard drive it could send rockets to
the moon and I thought this was sort of
I thought I was getting kind of crazy
with some of the examples here and I've
spoken that I was talking to someone at
the scheme workshop yesterday and they
told me about a macro and scheme that
will shell out and execute a C compiler
during macro expansion please don't do
that but people do do these things so
this list is actually direct from the
curse of issue tracker francesco below
me put it on there and he makes a
project called cross clj it's a really
fantastic project so he basically
cross-references and indexes a bunch of
libraries from the closure ecosystem and
he provides a website with their link
them all together it's really neat so he
actually expands all the macros and and
works out the references traditionally
doing that way and he said that those
first two that macro expansion sometimes
never terminates or it uses a huge
amount of resource or things that he
sees relatively frequently so this does
happen and even assuming you could do
that the problem is you have any macro
you expand it you don't really
understand anything about the macro
expansion and you end up with this huge
ball of expanded code at the end of it
and to automatically relate elements
from that expanded code back to the
unexpanded source is very difficult
because you your user when they're
editing they were editing the unexpanded
source and that's conceptually what
they're thinking about they're not
thinking about the macro expanded code
David Nolan told me the other day no one
wants know what they make expansions
look like so so it's it's very difficult
so the trivial cases are relatively
trivial and I guess a lot of people when
they're saying why don't you just expand
the macro so thinking about something
like a standard you know diff template
with just a syntax quote in it and
that's relatively simple you can
generally see what's going on there but
again in the case like the record
constructor function that's that's a
very difficult case to handle because in
your macro expanded and your macro
expanded code you suddenly have this
definition of a symbol and if someone
tries to rename that what should you do
you can't automatically determine that
the name of that symbol is based on the
name of the record so you really need
some sort of understanding there to be
able to handle this so what I didn't
cursive was I actually implemented
everything around an extension API and
everything internally in cursive is
based around
as well so whenever I'm adding
supporting cursive for for built-in
forms the saw uses this API as well so
it's peed off the hid symbol for lists
so you can see an example there register
locals cloture called different
different symbols so what that's doing
is that saying when you see a list with
a hid symbol and the list is a macro and
it resolves to close your diff and -
then use the different symbols function
to return to the cursive what the local
variables are and what their scopes are
one thing to notice is that the the key
word there is fully qualified so since
cursive connects you resolve accurately
you can actually discriminate based on
the fully qualified symbol and this is
important these days because if you have
a form standing with just different you
don't know it might be cloture
chordophone there might be schema
different it might be court type diff
and so there are a lot of different
things here and you have to be able to
distinguish them because you have to
treat them differently so this extension
that just functions that can be reused
they can be composed and so this API
will be opened up and all the existing
implementations will be open source as
well so the people will be able to add
support to cursive for the libraries
they use the libraries had developed or
if you have internal macro systems at
your work you'll be able to add support
for those as well and my hope is is that
by using simple functions it'll actually
be relatively trivial to add support for
new forms that look similar to existing
forms in the language so these are the
sorts of things that you can currently
you can currently teach cursive about
through extensions so local bindings we
talked about previously what they are
where they are what their scopes are
global VARs so you return to cursive
something that looks very much like bad
metadata extracting information from
forms for indexing so aliases refers
imports threading forms as this form a
threading form and if so where's its
implicit parameter where does it and
plus where does that simplicity
parameter come from and that'll be
important when I'm implementing type and
Friends class definition does this does
this form define a class and formatting
so you can actually customize the
formatting for specific forms as well
and soon they'll be adding support for
completion so you'll actually be able to
have context-sensitive completion so if
you're in an in s form for example and
you're requiring some namespace and you
have an excludes form
when you're in the excludes Victor and
your completions you only want to see
symbols from the namespace that you're
requiring you don't want to see anything
else and there are certain certain cases
we need to have interactions with
refactorings for particular forms and so
on so I wanted to a quick demo for you
to show some of this functionality and
show some of the functionality that
maybe you haven't seen in existing
systems so one great thing about
indexing source is that all this works
equivalently for for local variables for
global variables it's all just
references so one thing to notice is
that when they have the caret over a
symbol here cursive knows what it
results to so we'll highlight the
definition of the thing that your
characters over plus all the references
and again this works for locals for
Global's things from closure core
anything and one really nice aspect
about the fact that I'm indexing source
code is that all this functionality
works transparently for clojurescript
because the source is basically the same
I needed to add some support for the
interrupt forms and whatnot but it all
pretty much works as you're going to see
here in clojurescript so I can also
rename things here so I can rename this
and that will rename the definition and
all all the users so if you're renaming
something like a record it will also
rename the record constructor functions
so it'll do a lot of these auxilary
rename tasks and again this works
equivalently for locals for Global's I
can change this however I want and find
usages which is what I talked about
previously this is a really fundamental
operation I think so when I look at this
it tells me this is the only usage it
makes it but if I look at something like
print alone here for example this will
show me everywhere on my project at
print alone is used and it actually I
get a little bit of a preview there so
here I have a single file but if you
have a really big project across
multiple files you maybe don't
understand the whole project a lot of it
was written by other people this is just
an amazingly useful tool and if I want
more detail I connect
get a little preview window down here
which again is kind of small
but as I go over the usages here I get a
preview on the right so I get a bit of
context I can see what their usage looks
like so cursive recently recently
learned how to do all this for keywords
as well so when I put the caret on a
keyword it will highlight all usages of
a keyword and one last thing to notice
there is that it also highlights all
variables that are used in keys D
structuring forms and this also works to
rename and find usages so if I do a find
usages on that keyword it shows me
everywhere on my project that that
keyword is used including the variables
that are these structured from it using
a keys binding and I can also rename it
so if i rename that to first name for
example that renames the keyword again
ever in the project plus the variables
where it's used so i don't know about
you guys I am often hunting through my
project trying to find everywhere I use
a keyword because I either want to
rename the keyword or I want to change
the semantics of how it works this is
just amazingly useful it's totally
accurate it works every time so again we
have the whole project index so we can
do some quite cool stuff so here and my
completion I'm doing I'm saying Stuart
or and it's saying closure doc string
trim but instead of the name space it's
saying closure doc string as stir at the
end there and so what that's saying is
you don't have this required in your
namespace at the moment but I've seen
that somewhere else in your project
you've you've required closure dot
string with the stur alias so if I
autocomplete that there it'll
automatically answer the require this is
really really useful again like I'm
working on my program I'm down in the
guts of Earth and I know I want to use
sit difference or something so I type it
in and it's automatically added to my
namespace I don't have to be jumping up
to my namespace editing a bunch of text
adding there then going back to where I
was trying to remember what I was doing
getting back into my flow that's that's
just really annoying so that's a really
useful piece of functionality and
something else that got added recently
if I delete that Crucible also mark and
there
that that alias is no longer used I'm
actually quite embarrassed to admit how
many aliases I managed or how many
requires I managed to go back and delete
from the curse of source code so another
thing is that if curse have suddenly
seized a variable there doesn't
recognize but it can find it in another
namespace then it will also offer to
import it in the same way so that's now
required it there and this is really
really useful when you're cutting and
pasting code from one namespace to
another so you can get a bunch of code
from our namespace you paste it into a
different namespace and it will prompt
you immediately to a de lor acquires you
need to make that code valid that's
really really a really useful piece of
functionality so now that you have this
ability to add requires willy-nilly and
not even really think about which
namespace you're in or the namespaces
that your things are coming from it's
quite easy to add circular dependencies
and closure really doesn't like these so
I have a little namespace here another
file that I set up just to illustrate
this so if I autocomplete that it'll
actually warn me so again I have all the
namespaces indexed I know what the
dependencies between them are I can
trivially check your adding this new
dependency you're going to introduce a
cycle and I can show you what it is it
will actually go ahead and add the
require but it'll warn you and you'll
have to fix it
all this functionality works
equivalently for Java as well and the
interest of time I won't actually show
that but you can add the short name for
a class it will prompt you which class
you might want to import and so on and
so forth
all the documentation and navigation
works you'd if you get the documentation
for a Java symbol as if you're getting
it for a cloture symbol it'll show you
the Java doc it all works in exactly the
same way
unused imports lots to be marked and
you're in this form again I cleaned up
by when I added this the other day I
actually cleaned up like 500 imports
from the cursive codebase so the
ultimate goal here is that you should
never have to look at your own s form I
hate that thing I don't want to look at
it I don't want you to have to look at
it either ideally I for those of you who
have have programmed in Java using
IntelliJ you never see your imports
anymore it's always folded at the top
you never have to look at it the ID
maintains it and it's always quiet
because of the way closure works that
may not be a hundred percent achievable
and closure but I think we can get
pretty close to it and I'm aiming to get
as close as I possibly can this is
something else that was added recently
so so I can invoke the neighbors
function here but recursive will warn me
so these are the inspections I was
talking about previously cursive will
warn me here that the arity that I'm
calling worth is not correct so
neighbours takes its I can take two ERA
T's it can either take two or three
things so I had one that's still no good
- and it's happy with that three and
it's happy with their four it's not like
a happy and this is immediately marked
in your editor and I think this is
really important so as closure
developers when we start using a ripple
one of the things we're really trying to
achieve with the ripple is we're trying
to close that feedback loop as much as
possible we're trying to get our
feedback as quickly as possible we don't
want long compile cycles we don't have
to be waiting for a minute after we've
made a change to see what happens so
things like the already check even if
you're running a ripple you can load
that code into the ripple and closure
won't warn you right away
it'll only warn you when you try and
execute it and this inspection finds
real bugs and people's codes and in fact
I released it about twelve hours later a
user wrote to the mail
less saying oh my god there's just found
a bug in our code they had tests for it
but they hadn't found it because midge
was helped was helpfully stubbing out
the function so they had a function call
with the wrong arity real bug in the
code and the stander and again something
else to notice here as I can update this
I can add a new parameter here to our
function so suddenly the call we made
down the bottom is valid
that's not marked anymore and calls at
other sites marked as invalid so one
other thing to notice here is that
paramus marked is unused so local
variables we marked as unused if you use
them if I comment out this piece of code
for example all of a sudden size and UI
X and marked as unused this is really
really useful when you're refactoring
you're moving bits of code around it's
very easy to move a symbol rename it and
forget to update where it's actually
declared so that will this will warn you
right away you can introduce there's
some simple refactorings now so I can
actually introduce this I'll call this
and so what I'm actually doing here is I
select the expression that I want to
extract into a lip binding in this case
I want to extract this and then identify
the point in my program where I'm going
to introduce it so I'd like to introduce
it read this try block and then I'm
gonna call the loader right there think
it gets better
watch this so I decide I want to do this
so there's actually two occurrences here
so cursive will actually go through and
say hey from where you're extracting
this there's two occurrences of this you
might want to do that you want to
extract both of them so I'll say yeah
sure I'd like to that and now the scope
that it offers me has to be valid for
all the occurrences so it's a much more
limited scope that'll actually offers
made to be able to do that so I add it
here and that's my thread
and the other thing to notice there is
that normally when it adds a binding to
a new to a new let form it'll added at
the end in this case it knows that some
later value in the lip and the lip
binding actually used that value so it
has to put it before it in the lit form
so we'll actually insert it into the
correct and to the great point in the
late form and it knows that because it
can resolve the symbols right you have
to go to result symbols to do this so
here is something else I want to do this
all the time right whenever I'm often
this happens off when I'm using some so
I will have a list of things and I often
want to nest my function literals but
you can't do that in cloture because I
guess it makes the the parameters
ambiguous so again it's marked and
immediately as an editor as an error and
the editor and you get a quick fix so I
can convert the inner one xx in and then
I have to decide what I want to call it
that's a Y or I can go at the outer one
to anything
so I hope there kind of shows you some
of the functionality the cursive heads
it maybe you might have seen in other
tools what the what the infrastructure
that the cursor provides will actually
permit so if you take one thing away
from this talk what I'd really like it
to be is that our tools should allow us
to work directly on our programs we
shouldn't be working on text text is
just the wrong level I think text is a
perfectly good serialization medium for
our programs but you shouldn't have to
be working with it while you're
manipulating them our programs should
enable us to provide can to use
conceptual operations to update our
program and that means that tools need
to be language aware they need to
provide manipulations that are specific
to the language and and the fact that
it's hard to implement doesn't mean it's
not desirable you should absolutely be
demanding that your tool users provide
this sort of functionality is really
really useful it just makes your life so
much better and I guess probably a lot
of you will go off to design languages
for fun and/or profit please keep this
in mind when you're designing your
language make it easy to pass keep the
semantics simple don't have lots of
really crazy corner cases and ideally
you should really develop the tooling
along with the language I think because
I think the sort of support is I mean I
think it's the future of tooling for
languages so I have a bunch of future
plans I don't have time to talk about I
am running an unsession at 9:00 p.m.
tonight so if you want to come questions
comments effusive praise abuse that's
all welcome that'd be great thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>