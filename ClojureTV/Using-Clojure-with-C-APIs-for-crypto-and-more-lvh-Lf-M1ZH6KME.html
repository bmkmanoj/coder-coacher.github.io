<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using Clojure with C APIs for crypto and more - lvh | Coder Coacher - Coaching Coders</title><meta content="Using Clojure with C APIs for crypto and more - lvh - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using Clojure with C APIs for crypto and more - lvh</b></h2><h5 class="post__date">2016-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Lf-M1ZH6KME" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi welcome to this talk title of this
talk is C crypto enclosure I know the
one that it says on the unschedule is a
little bit different but this is about
combining closure with native libraries
so I'll make sure to put the link of
this for the slides up later just in
case you want to peruse them afterwards
so a brief introduction hi I'm all the H
I'm a cryptographer and I do distributed
systems and cryptography and generic
information security work I work at a
company called a lot of Quora we do
security programs for startups so if
you're a start-up and you would like to
do something around security but you're
not really sure where to start you
should come talk to us and so as I said
the title of this talk is secret
enclosure the subtitle is with sparkles
it's the unicode symbol of sparkles will
become clear by the end of this talk why
that is
so why closure just to deconstruct that
title a little bit
I love closure it's my favorite
programming language I'm guessing it's
not going to be a very hard sell since
I'm a closer cons but just for for the
people who are watching this later
recorded closure is great you should try
it but the other thing that's kind of
interesting is the things that I've been
doing with closure I've been doing a lot
of stuff with closure mostly in the
security space but one of the things
that I've been doing is a cryptographic
research and that's interesting because
usually cryptographic research is
something that's limited for languages
like C and very often even like see with
like assembly shivved into it rarely
depending on what people are doing maybe
even you know some go or some rust but
by and large it's a it's a systems
programming language field and closure
like certainly not a hosted programming
language certainly not one on the JVM
and generally speaking not lisps are not
well known for being useful programming
languages for doing that in so by crypto
well I already mentioned I'm a
cryptographer so that's what I do the
phrase don't reimplemented
thrown around a lot and it seems to mean
something else to everyone and in my
case it means a couple of things so one
of them for example if there's a
perfectly good working implementation of
an algorithm it's not necessarily
interesting for me to go and
reimplementation I don't necessarily
want to do
but also in many cases it turns out that
it's essentially impossible to do the
exact same thing that you would be able
to do natively to do that in software so
two examples of that for example or PCL
molky DQ and AAS and I so PCL moki DQ is
an instruction on modern Intel CPUs ASN
is an instruction set on modern Intel
CPUs and these are used to implement
portions of cryptographic algorithms so
if you're familiar with for example AES
GCM if you've ever configured TLS you
might have seen that strings pop up
somewhere P silliman QT q is used for
that the thing is you can do that
technically in software and you can
implement it correctly in the sense that
for every input you get the correct
answer but that doesn't mean correct in
the cryptographic sense which which has
stronger requirements for example to be
correct in the cryptographic sense it
has to for any input to take the exact
same amount of time and that for example
is extremely difficult to do in software
so there are good reasons why you want
native CPU instructions instead of just
reimplemented the same algorithm in in
software so why C well to be entirely
honest it's more about the alliteration
than anything it's really about the OS
ABI or the application binary interface
or quote unquote native code rather than
then C specifically it just turns out
that C is kind of the lingua franca for
doing this even if the code that you're
calling is secretly implemented in
Fortran the way that you're calling it
is going to be a C style way of calling
it so in order to answer that question
it might be interesting to ask the
converse question instead which is why
would you want to limit yourself only to
the JVM enclosure and I'm not trying to
be cheeky when I asked that there were
perfectly good reasons for wanting to
hear all of your code on on just the JVM
it makes your code really easy to send
to some new platform for example the
there were also really good reasons to
just keep your code enclosure I've had
plenty of code that I originally wrote
targeting the JVM and I renamed the file
from clj to CL JC and two minutes later
it was running in my browser and that's
awesome and you give that up when you
when you use native code that said there
are really good reasons to use to use
native libraries performance can be one
of them very often these two
implementations or you know I mentioned
Fortran
these these things are pretty fast but
it's not really just about performance
so I already mentioned you know I'm not
going to re-implement stuff for fun if
you want a large amount of linear
algebra algorithms those things have
been written in Fortran since the 70s
and they're collected in excellent
libraries and there's absolutely no
point in reimplemented them but there
are all sorts of other things so I
mentioned crypto you might care about OS
features so if you want interactive
process control you don't really get the
same amount of power that you get on the
JVM as you do if you were a native
program that might include like network
sockets high-performance i/o native GUI
features if you want to do math on the
GPU those are all things that you might
want to do from a closure program and
that you can't do by just sticking to
the JVM you need to go drop down into
into a native level to accomplish them
so let's call some some native code how
do I do that on the JVM generally
speaking so historically there was J and
I and J and I has been in Java for
pretty much forever and what happens is
you have your java code and it call it
makes AJ and I call I'll show you what
that looks like in a second and then it
runs over into C country which is a long
and arduous process which is why it's a
squiggly line and then and the second
line you're in C country you can tell
because everything is mono spaced and
you no longer get nice unicode arrow
glyphs and it calls a ji implementation
which is a C stub and then eventually
you call your library so what does that
look like when you actually try to do it
so here I'm trying to buy and getpid
which seems like a simple thing that you
want to call like if you're if you're
familiar with doing programming on on
like standard C or even like Python or
Ruby like getpid is something that's
around and get pizzas something that's
very useful if you want to start a so
processed on POSIX you need to be able
to call Get Fit and yes the GPA at the
JVM to my knowledge still doesn't expose
this because mostly just compatibility
reasons because not necessarily every
place where you run a JVM you also have
a concept of a process ID so the
interesting thing here is and I try to
highlight it is that native keyword in
Java so that makes this a J and I call
and then I call getpid I need to
statically tell it to load
particularly Brer e that is going to
have getpid in it so that's actually J
my library I'll show what that looks
like in a second
it says die Lib because I'm on Mac OS if
if I was on Windows that would say DLL
if I was on any like Linux or BSD that
would say and so and then you call a
thing called Java H which is Java C's
weird brother it comes with your JDK so
it's probably already installed on your
machine and it just generates this weird
C header file and the point is not to
like as you can see it doesn't even
actually fit on the entire slide that's
kind of the point when I'm trying to
demonstrate is like this is gnarly this
is gnarly boilerplate code this is the
simplest C call that I could think of
and it's already looking kind of gross
and then that's just a C bridge then we
still haven't actually called getpid so
you still need to require that or
include the header and then actually
call get pit and as you can see like
this doesn't even really look like it's
very very specific code like you have
that J and I call in there like who
knows what that does you have a J an IM
pointer which is for calling back in to
JVM like this is very specific knowledge
it's not easy or fun it doesn't really
look like you're calling C code you're
you're doing CNI and there's a
difference so and then eventually of
course now you just have source code
right you still don't actually have a
working get pit call so then you need to
invoke your tool chain in order to
eventually produce that s oh that that
your JVM will be running at runtime so
you're a tool your tool chain barfs some
eldritch ruins at you and then maybe
eventually you're able to call yep ed
and I found an example of this in the
wild so I mentioned that one of the
things you might want to do is GPU is
GPIO math and there's a really cool
closure library for doing that called
the and earth all Neanderthal depends on
a library by the same author called open
CL and that finally depends on a Java
library that I can only imagine is
pronounced jockle and if you go reach
into the dark decree heart of jockle
then eventually you see a native keyword
in there so there are there is
absolutely production closure software
out there that uses G&amp;amp;I right now that
is well you does it through java but
still so the problem with all of this or
rather the upside like you can use
Neanderthal it's fine you could just add
the dependency to project tlj and it
works great so J and I it's also really
performance J and I is great as long as
you can get someone else to do the
compile a bit for you but if you're in
this talk then I'm guessing that you're
possibly interested in binding your own
native libraries and that means that
you're the sucker who has to go but go
do the compile a bit right so this was
generally accepted as a problem with
j'ni and as a consequence in days of
yore ji-sun came up with J which is the
same difference
so one of the differences for example is
that there's no more native keyword you
specify the things that you want to call
by implementing an interface and then
just at runtime you can you can try to
load a library typically you'd have to
specify the name of the library in this
case I don't because skip it is in Lib C
and then you can call get pit and you
don't have to run a compiler you don't
have to like generate gnarly header
files like this is pretty good
unfortunately there's some problems with
Jana as well so the biggest one by far
is performance so I've heard anywhere
between like one order of magnitude and
three orders of magnitude like cost for
doing J and a versus the j'ni
implementation maybe that's fine maybe
you have like some really really long
maybe it's either not poor performance
sensitive or the C call that you're
doing is really really expensive such
that the overhead like doesn't really
matter that's not really the the
important part but still it's it's not
perfect there's also some missing
features that you probably care about if
you're going to bind any any meaningful
large C librarian so enter G and R
so how J&amp;amp;R works is a you know this
probably reminds me of the jan the jan i
slide but you have your code which calls
a JVM generated stub so this is still
JVM code we're on top here right and
then that makes the jan I call the Jane
I call goes over into C country there's
a J and I see bit there that calls a
library called LaBeouf Fi and Lib before
I calls your library for you now I would
understand if you're confused or
incredulous at this point because I just
told you that J and I is annoying and J
is slow and somehow the answer is like J
is like J and I but with more overhead
and you know you'd be you'd be right
maybe but it turns out that it's a
little bit better than that so first of
all that j'ni platform-specific bits
then I talked about so that that would
be the the actual J and I call that just
has to linked to Lilith a fine lip fi is
going to be the same everywhere so the
annoying compiled bits is is going to be
shared for everyone or pretty much
everyone like it probably ships with
support for your platform
and because that part is shared what
that means is there's still a sucker who
has to do the J and I compilation bitch
but it's somebody else now so that's ok
and the J and our specific part is
generated at runtime so you get the the
same behavior that you would out of J a
so it be more fair to say that you get
the J a user experience roughly with the
performance of j'ni roughly there's a
I'll go into performance more in detail
afterwards but they're roughly the same
so what does that look like like I said
it's very much the J the J a experience
so you create an interface that defines
the methods that you want to expose
there are some annotations here I'll go
into more detail about what those do
later in order to demonstrate some of
the features of J an RF if I'm calling a
slightly more complicated C function now
it's not particularly complicated but
get time-of-day just tells you what time
it is right now and get time of day
takes a time Val which is a struct that
it's going to put some some data in and
a pointer which is normally for timezone
but here it's unused so the JVM or JR
doesn't define what time vel is so
sometimes if you have a struct in C you
still need to be able to you still need
to tell Jan all right like hey here's
what that struck looks like it has some
seconds it has some microseconds and
you're off to the races
we have JRuby to thank for this and the
reason we have JRuby to thank for this
is because JRuby tried to mimic an
existing Ruby implementation MRI which
is a C program and MRI was written to do
whatever it is that C programs can do
right they're going to do all their
fancy terminal manipulation and and
socket IO and and yadda yadda yadda
because they're not really worried about
the difficulties that someone is going
to have ten years from now when they try
and implement it on a hosted platform
like the JVM and JRuby kind of said from
the start we're going to be just like
Ruby except just faster and with better
concurrency and as a consequence it was
unacceptable to say well okay we're just
like Ruby except like 90
Ruby programs don't actually work so
they needed to implement a whole bunch
of features including all sorts of file
system access things that the the JVM
doesn't provide interactive sub process
interaction which you don't can't really
do as well on JVM I mentioned terminal
control and also fast i/o because of
course if your if your claim to fame is
like Ruby but faster and then it turns
out that all your i/o Kyle calls are
slow and also turns out that most Roby
programs or i/o bound then well and also
off-the-shelf they provide a whole bunch
of stuff so they're very thankful that
they didn't choose to implement all of
this simply in JRuby they wrote
individual libraries that then JRuby bit
depends upon so for example I talked
about get time of day and get paid you
don't actually need to bind get paid or
get time of day because they provide you
with the library called Jnr Cossacks
that does all of that
I'm told that they also expose fork and
when you fork the JVM at like breaks
comically but whatever you can call it
if you'd like there's also Jnr nco which
is basically really performant native
i/o there i think that that that neo
didn't exist when they started with that
but it turns out that even with an i/o
with the new i/o system in java
both Nettie and JRuby like kind of
discovered this independently if you can
do it with native I if you can do it
with native calls you still end up being
faster than the JVM specific things and
then jnr UNIX socket just in case you
want to talk to a UNIX domain socket for
reasons unknown there's also a bunch of
tooling that they provide so Jane are
constants if you have a C library and it
exposes preprocessor constants so
they're not going to be visible in the C
code that gets passed this to pass to
the compiler that's an awful lot of
libraries very often you don't want to
just insert the magic number two you
want to know what that constant means
jnr gives you really good tools for
being able to access those there's also
J on our x86 Azzam so that lets you Shiv
some assembly in the middle of your
closure code because who doesn't want to
do that that is also how the stops are
generated so they generate their stubs
at runtime very often by literally
generating assembly okay so let's go
write some code the easiest way to get
started is with Java because that's what
all of these old example
do so if you look at the documentation
all of this you know all this code
assumes that you're running java so
let's let's serve it some Java the
library in particular that I wrote and
that I'm using as a guide for this talk
as a library called caesium which is a
closure binding on top of loop sodium
lip sodium is a cryptography is a
cryptography ography library if you're
familiar with Dan Bernstein's Knakal or
allegedly pronounced salt but that's not
gonna happen
so Knakal it's Knakal with cheese by
knuckle with cheese I mean it's in
version control it's buildable you can
probably get a binary for it for your
platform and they added a couple of
features here in there so how much Java
do I need to bind just to get an idea I
got a check out of Lib sodium and I
counted the number of header lines and
it turns out that there's like north of
9,000 header lines I wasn't very happy
about that but okay I can do that
fortunately it's mostly easy Java
because Lib sodium has a very consistent
API that's explicitly designed to be
easy to call from a whole host of
different languages so closure is
absolutely by no means the first
language that someone bound lib sodium
in there's plenty of other languages and
and it was explicitly designed to make
that as easy as possible so most of its
char star which is a pointer to well
char sir
now the problem with that is that
there's actually a lot of JVM types that
you can use to represent a char star
there's a concept of a sequence of bytes
there's not one unambiguous Java type
that you can use for that
so in jnr alone there's there's for
example there's a pointer type which is
explicitly you know char star is a
pointer
there's also buffers and byte buffers
just in in in Java
there's also string because sometimes
the thing that you're the char star is
actually human text and you wanna you
want to use a swing for that and there's
also the built in primitive a by Turing
and even then you're not really done
because what do you do in order to pick
the return type of a function right so I
can either give you a function for each
one so I can say like hey if you want a
buffer call this function if you wanted
an array back that you call this other
function or I could try and be really
clever and look at the things that you
gave me and assume that you want
something back that looks kind of the
same shape I tried that at first it
didn't really work out
because there's a bunch of functions
that take for example four or five
arguments and if you give me five
different types or four different types
then I don't really know what you want
which one you wanted and then it's you
know it's so kind of annoying to have
two functions for every for every
semantic function and then the other
thing is you know do you want a
functional interface or a mutate in
place interface I'm a functional
programmer I would prefer the functional
interface most of the time but none of
those types that I just mentioned that
you can reasonably describe some bytes
with on the JVM none of those are I was
going to say value types but none of
those are values in the sense that
they're immutable the other problem is
there are very good reasons for wanting
to bit bang in place a particular array
like if you don't for example if you
don't want your key to be copied over a
memory all over the place or if you want
for efficiency reasons you want to be
able to use the same buffer again and
again and there are good reasons for
wanting the in-place API and then in
order to get to the right types you know
given this idea that oh they're a bunch
of types and you might have whatever and
I need to be able to use them as much as
possible because I want my library to be
user-friendly there's a whole bunch of
options and all of them are kind of bad
because I might want to try and do
conversions but very often that means
that I'll need to copy because a lot of
these types are not in or compatible if
I do reflection typically it's going to
be slow there's a there's a performance
by a performance penalty for that and it
turns out that it's buggy
I found well arguably buggy I'm still
not sure if it's a bug or a missing
feature but I found a bug in closures
reflector where it was unable to find a
method that I knew existed on that
object if I do explicit methods because
there's this you know combinatorial
explosion if I do explicit dispatch on
the type first of all it doesn't
actually work most of the time because
there's hidden types that the JVM will
give you back so you can't actually just
check the type and then do static
dispatch you actually need the
reflection but the other problem is that
because there are so many options you're
going to get a very very large type and
if you have any experience with JVM
performance optimization and writing
high-performance code then you'll
probably have heard before the heuristic
number one is write smaller methods
because it's quite possible that even
though
hot spot the jet will look at your
method and be able to optimize the
living daylights out of it in reality
it's not even going to try because it's
too big and if I tell you like well
tough luck this library is as byte
buffers deal with it then that makes my
library a lot harder to use and I would
like to be friendly to my users so as I
mentioned very quickly end up with this
combinatorial explosion of symbols right
because for every return type you have
an option for functional vs. in place
and then you know all of the possible
permutations so very quickly I made you
know before you know it I'm exposing I
think I did the math on this one so I
end up with 12,000 symbols which wasn't
going to happen so I needed to pare that
down a little bit unfortunately there's
a couple of good places to start so
first of all pointer is really just
useful if you're going to be essentially
not really reading a piece of data from
jvm land you just need to like pass it
to a c function and then pass it to
another c function and pass it to
another c function and and sort of you
know down the line that way so a pointer
is very opaque and if you're ok with
that point is fine but I don't want
opaque types I want to be able to read
those bytes the other thing is strings
are straight out as I already mentioned
strings are typically for for human text
right there are sequences of Unicode
code points and I have no idea if a
thing that you're encrypted that you're
encrypting that might be human text it
could be an image it could be you know
some binary data format it could be
compressed it could be all sorts of
stuff but generally speaking encryption
algorithms work on bytes to bytes they
don't work on Unicode opens say anything
else so that leaves us with byte arrays
and byte buffers so byte arrays are nice
because they're really common they've
been in Java pretty much forever and
they're very easy to sorry they're very
easy to use for example in serializers
so if you have like a serializer library
it probably already knows where the
buyer is on the other hand a byte buffer
is newer but it does have some distinct
advantages for example it's the only
reasonably supported way on the JVM to
get in data to get directly allocated
memory so if you want a if you want some
memory that's off the Java heap you want
it to be as if you just called malloc
and your C program then
you you call bytebuffer allocate direct
that's the only way you can do that the
other nice thing is if you have like a a
binary format and you I don't know you
need to read the first two bytes because
that's the header and then you need to
read a byte because that tells you how
many bytes are following you know like
pascal style strings then byte buffers
let you do that very easily so it's very
cheap to create like a slice in memory
and should go look at that one byte or
go look at this sequence of bytes and if
you do that with byte arrays it's a
little bit annoying very often you need
to copy stuff around there's some
asymmetry there as well so if you have a
byte array you can wrap it with a byte
buffer in order to do that view thing
and that's really fast as far as I know
indirect going from an indirect byte
buffer which is to say a byte buffer
typically backed by a byte array
getting that byte array back out is also
really easy because that's just field
access my reading of the doc of the
documentation says that this isn't
really guaranteed it just turns out that
it works that way on every platform that
I've tried but then the problem direct
byte buffer which is the one where you
really really really want a byte buffer
because it's the only supportive way of
doing it if you want to go from there to
a byte array that's really slow because
every time you cross that boundary you
have to copy everything because a byte
array is definitionally lives on the
Java heap and a the direct byte buffer
definitionally does not so one of them
is going to have to budge so the way
that I solved this in conclusion is
first of all just expose I wanted to
expose everything on the underlying
object I wanted to make sure that if you
knew exactly what types you had you
could just go call the right thing and
pay as little performance overhead if
you wanted to so you have to opt in into
doing some gnarly stuff and maybe do
some type annotations and stuff like
that but at least you can if you wanted
to the in-place API takes buffers only
because the employees API it turns out
that if you wanted something in a byte
but in a byte array it's easier to wrap
so that's okay and in the cases where
you really really want to make sure that
you're going to the specific location in
memory you have it direct byte buffer so
you have a byte buffer so I want to make
sure that that API takes byte buffers
and then there's a high-level functional
API where I try and be as flexible as
possible about what you give me I make
sure that I wrap it turns out that's
always or usually efficient because
either you already have a bike buffer or
you don't but then I can wrap it
still efficient and then eventually you
get a byte array back because you don't
care where it's stored if you cared
where it's stored you'd be calling the
other API so that was a little tricky to
figure out that took that took a couple
of days of hammock time as which puts it
but eventually we got there so
performance which is you know in many
cases like I said when I started the
talk there are many reasons to do this
that aren't about performance but
generally speaking for your performance
isn't a bad one there's nothing wrong
with making your program run fast and
the short version if you remember
anything is the penalty is really small
like it's it's fine
there is extremely unlikely that you
have to care
there are knobs that you can twiddle if
you really want to make it very very
very small when I say very small I mean
like order of magnitude to x86
instructions that are reasonably branch
predictor friendly so fast and turns out
the JVM tooling for this is pretty good
so for example there's thing called JIT
watch built by the open JDK people it
tends to focus on Java but because it
deals with the with the hotspot JIT it
doesn't actually really care about Java
so you can use it about you can use it
with closure just fine you just end up
getting the the mangled names instead of
the the closure namespaces that you
might expect and you can even get
assembly dumps out of out of the JVM so
you these you pass these weird command
line flags you can send a bunch of other
ways but then you end up getting
assembly and you run that and then it
tells you okay print assembly is enabled
and you go run your entire program and
you're expecting to see some assembly
and eventually you're you're confused
because you know it's not going to
standard out it's not like writing a
file you end up s tracing that that
process turns out that you can s trace
it because on Mac OS now it's protected
from being a Java by default to the JVM
is protected from being s traced so that
doesn't really work and you have
spending a bunch of time and eventually
you decide that maybe it might just be a
good idea to read the rest of the output
of that program and it tells you oh I
couldn't actually find this this really
critical library so when I told you it
was enabled what I actually meant was
that it was disabled so then you acquire
a justice which requires getting a check
out of open JDK you need to build your
own bin utils there's extensive cursing
there but eventually you acquire that
dialog you can do this it so
okay it's it's annoying and it's a
little bit roundabout and you need to
like manually do some stuff but
eventually you acquire this so for those
of you who have never seen a an assembly
output I'm sorry but for those of you
who have this should look kind of
familiar so this is this is what happens
when you try to call count on a seek so
for those of you are familiar with
assembly you know like or maybe remember
it from a very far away college class so
here I'm you know well I'm not the JVM
is pushing the base of the stack and
then subtracting the stack point 30 from
the stack pointer or 0 X 30 and
conveniently HS this will tell you what
is there so it'll tell you what it's
exactly accessing and then there's an OP
because of course C is odd and I don't
know Intel CPUs are weird so you only
want instructions on even on even
addresses and eventually you call
something it of course tells you what
you're calling you can see that this is
invoke virtual which is a JV this is a
JVM a JVM bytecode instruction you're
calling count are you calling count on a
CKD era and eventually it restores the
stack pointer and restores already P so
if you're if you're reasonably familiar
if you've ever done any x86 assembly
this will probably look pretty familiar
if it doesn't I'm sorry but now the nice
thing about this is like this is
obviously a pretty simple call this is
you know pretty much as simple as call I
like to think of the I couldn't show the
the crypto ones on the slide because
that would not fit on the slide but the
nice thing is you know regardless of
what your what your code is what you can
now do and I've actually done this
exercise for my crypto code you write a
c program that does the thing that you
expected it your closure code to do and
your NHS this on your closure code you
see what the produce assembly is you get
clang - oh three to produce a C binary
that allegedly does the same thing and
then you see then you can very
concretely in terms of numbers of
instructions which in the cryptic
community we care about in terms of
numbers of instructions you can see
exactly what the penalty is of using
closure and it turns out that the answer
is very very little indeed
the Jnr has a number of tricks it is the
jnr has a number of tricks mostly in the
form of annotations you saw them perhaps
in an earlier slide in order to make
this a little bit faster so one of them
for example is ignore error if you've
written any C code you might be familiar
with the concept of Erno so because he
doesn't really have a decent error
amount and handling mechanism
sorry that was a value judgment but I'm
gonna repeat it because C doesn't have a
decent value error mechanism what ends
up happening is a function will return a
value that tells you something went
wrong and then you need to go reach into
Erno in order to figure out what exactly
went wrong and then you do your error
handling based on that now the thing is
that the JVM internally uses Erno so
when you call some C code that's allowed
to do whatever including user know so by
default if you call some C code the JVM
needs to save the or no value and then
when it returns it needs to check the
error no value it needs to allocate a
threat local it needs to put the no
value back because otherwise the JVM
breaks now a lot of C code does not use
right now and if you incidentally know
that that's the case then you can tell
Jnr hey I don't care about or know just
forget about it or no you don't need to
do the save and restore thing and that
lets you shave off a few cycles
there's also annotations for in and out
on so normally what happens is when you
call some C code you have to keep in
mind the value that you're calling it
with is managed by the JVM right so it
could be it could be an object it could
be a primitive but it's managed by the
JVM so it lives in j vm memory land and
in order for some C code to call it you
need to copy it first because the JVM
reserves the right to copy stuff around
and it does that all the time
for purposes of garbage collection so
you can't just like pass a pointer
around and expect that to work so it
needs to copy copy it back and then copy
it into C country call the C function
and then copy it back into JVM country
when the C call has completed very often
though C code will have certain
parameters
either an input parameter or an output
parameter by which I mean you're passing
it like a pointer to an int or something
and that functions contract is I will
put the result of my computation in the
location of that pointer that you gave
me and when you know that's the case for
example if it's an output parameter
there's no point in copying whatever the
JVM had in to see you land because most
of the time it's going to be like all
Nold out anyway so there's no point
because nothing will be reading that and
conversely if it's an input parameter if
you know that you're just passing it to
C but you're not you know you don't need
to copy it back because you know that
the C the contract of the C code is I'm
not going to change this value I'm just
gonna read it so in order to optimize
that you can pass you can you can set
these things saying that you know this
is only an input parameter only now put
parameter again this is opt-in right
like if you just bind your code really
quickly and it turns out to work fine
and it's fast enough then don't bother
but if you really want to and you really
care about those you know those two x86
cycle of cycles or instructions or
whatever then you can absolutely do this
kind of thing I just said hey the JVM
reserves the right to copy stuff around
and therefore you can't just pass a
pointer that was a lie you can
absolutely do that you just have to tell
the JVM first so jnr has this really
cool feature called pinned where you
essentially tell the JVM hey you know
that part where you thought you owned
that region of memory you don't just
don't touch it for awhile
trust me and instead that means that you
can just pass that pointer along and you
could just pass that pointed to see see
country is going to do something at that
memory location which is secretly still
managed by the JVM except the JVM has
promised to keep its hands off of it for
a while and then by the time it returns
you're done and that means that you
don't have to copy anything like you're
done so that's terrifying think about
that for a second but still though if
you have if you were to be passing a
struct so I gave the example of of a of
doing get time of day and get time of
day you pass a structure around that has
a number of seconds and a number of
microseconds and if you're doing that
then the JVM needs to allocate some
memory in order to copy that straw
into now the question is is it necessary
to to keep that memory around because
it's possible that you just by default
for example you you just copy something
in to see country see function does its
thing and then you copy it back and
after that you could free that memory
because it's not being used anymore it
might be interesting in order to make
sure it might be interesting to make
sure that you use that same location in
memory the entire time could be that
your seed library requires it could be
that you don't want to call malloc very
often stuff like that and direct and
transient let you let you tweak that
that behavior as well and again just to
repeat all of this is opt-in unless your
see a library for example like if your
seed library does something really silly
then maybe you need this for correctness
but generally speaking all of this is
opt-in you only do this because you want
to squeeze the maximum amount of
performance out which you might not care
about now everything that I've talked
about so far and I want to make sure
that I have enough time I think I do is
about Java and the JVM and the kind of
crux of this talk was but close you're
really good at it too why is that well
so my library caesium has no Java
whatsoever and that's mostly just
because I didn't want to write an e and
and it turns out that that that's one of
the decisions that I made all the way at
the beginning and that turns out to have
worked really well so first of all
closure has really good at host
interrupt right this isn't really a
secret it closure doesn't hide Java or
the JVM from you if you really want you
you can write essentially Java just with
more parens for example you know we
mentioned you need to define an
interface as in a Java interface to JVM
interface to define what kind of things
are going to be calling on your C
library and closure gives you a thing
called def interface and you can just
define get time of day that way and this
is not particularly surprising or
confusing the only thing about this may
be so if you've never seen this create
int that's just the type int so this
will say you know hey gif time of day is
going to return an integer and I take a
pass at one arguments which is a time
value or time Val here and I've passed
another argument which is a pointer the
only thing that might be really new to
people who have done type
before is that thing and that was not
easy to find that is how you do
annotations in closure so you can do
that on deaf class you can do that on
deaf interface that is yeah that was
seems to be tribal knowledge but if if
you only take that away from this talk
you know hey win right now I'm not quite
as well-spoken as as Rich's but my
understanding from one of his earlier
talks is that the closure way can
roughly be summarized as start by having
some data and then don't mess it up and
that's kind of what I did so I have some
data so specifically this is a thing
from C this is a excerpt from caesium
this is just a vector and it is a vector
that has the same shape as the Deaf
interface for a good reason because I'm
you know going to use a macro to shove
it in there but it is a just a data
structure with some with some vectors
and some maps in there like there's
nothing weird or annoying about this the
state of structure and that turns out to
be really really convenient because you
remember when I mentioned that what I
wanted was to expose every single byte
type and when I if I were to do that try
to do that in Java the way that you do
that is you take that interface that
that declaration and you copy it a
gazillion times and then you manually
replace like every single you know every
single parameter you changed the type to
be that one specific type or you use
like the C preprocessor to manually
manually generate that file for you I'm
not entirely sure which one is worse but
I know that I don't like either of them
whereas enclosure what I did is I wrote
a function that takes a vector and
returns that same vector but with a
different type annotation and then I
called map cat over some things and I
was done and that took like and I like
that function wasn't super easy to write
but whatever that took like maybe five
minutes and most importantly I don't
have a C preprocessor generating Java
interfaces also ignored right so like if
when I wanted to attach that ignore and
an error annotation to all of my to all
of my calls then if I wanted to do that
in Java then I would have to like copy
paste ignore error onto a lot of calls
if I wanted to do that in my closure
version then I wrote a function that and
it added the ignore error annotation and
I was done and another thing macros
right so I just mentioned a whole
a whole few examples of very repetitive
annoying code I have experienced binding
cryptographic libraries in Python let me
tell you those that repetition that is a
very very rife playground for bugs all
sorts of interesting things happen
because your eyes glaze over after you
see exactly the same lines but these two
little tiny differences five hundred
thousand times in the same law in the
same file so having a macro that will
just allied all of the repetition for
you is really convenient and genuinely
decreases the defect counts in your in
your software and then finally there's
the sparkles macro and the sparkles
macro is just a way to generate to
generate calls and to see and and we
will do nice things like for example it
will add that buffer length
automatically you look at the signature
to figure out if it needs to do that all
of those things are also correctly type
hinted so you don't get like reflection
warnings and stuff like that that was
really annoying if I would have to do
that manually oh yeah and it also
figures out the name of the see symbol
to call correctly based on the current
namespace it does a couple of gnarly
things but the bottom line is it saved a
whole bunch of time and it presumably
also prevented a whole host of bugs the
only critical thing from the just in
case anyone wants to know why it's
called sparkles it's because I really
don't want anyone to call that macro
what is the opposite of public API and
as I mentioned you know this kind of
stuff matters like those are those
that's where real bugs right and you
also get like in my project I now have
API consistency because I'm lazy
in conclusion closure loves native
libraries and you might not need them
most projects probably don't but if you
do don't despair it's gonna be fine
also open-source is great so I got jnr
for free because some people did some
cool stuff I was able to find at least
one bug in Jnr it wasn't game breaking
it was you know it was it was okay and
at least one bug in the closure
reflector and also as a consequence
pythons leading cryptography library now
has zero copy because the author and my
friend and former coworker got really
really jealous because I kept talking to
him about how I had at pinned and he
didn't so that was a feature development
through jealousy
so some future work that I might be
interested in is
seeing if I can get the same kind of
behavior on enclosure scripts maybe try
em scrimped in' although generally
speaking i'm a little bit in like it's
not that fundamentally javascript crypto
is bad it's just I prefer to know what
you're doing before I you know
accidentally enable that kind of thing I
would like to shift native binaries with
caesium right now I don't instead I just
give everyone a dab in an RPM that's
kind of easy to install
most of the SIS ads that I talk to
prefer that anyway and also bind all of
lib sodium I just bind the care the
parts that I care about now which is
almost everything that you care about
probably too but there are certainly
still things in Lib sodium that need to
be bound it's not hard it's just work
and I don't want to do it if you'd like
to talk to me about nonce misuse
resistant cryptography you should
absolutely come talk to me about an
ounce misuses in cryptography if you
care about crypto that's easy to use I
will talk your ear off about that and
that's what I'm doing with caesium
unfortunately I have only 40 minutes and
I'd like to end by saying thank you to
the kanji organizers I do a decent
amount of work I'm also married to the
person who runs PyCon so I have a decent
idea of what it takes to run a
conference this is not easy
Lin is very good at her job and does an
awful lot of work Wayne and Charles are
the people who gave us jnr they're
awesome and Paul Kerr is the person who
got jealous and decided to implement
cool features for Python users and
that's all I got I don't think I have
time for questions but I'll be happy to
take them outside thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>