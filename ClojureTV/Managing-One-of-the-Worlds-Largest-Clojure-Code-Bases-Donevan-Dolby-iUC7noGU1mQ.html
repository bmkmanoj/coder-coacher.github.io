<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Managing One of the World's Largest Clojure Code Bases - Donevan Dolby | Coder Coacher - Coaching Coders</title><meta content="Managing One of the World's Largest Clojure Code Bases - Donevan Dolby - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Managing One of the World's Largest Clojure Code Bases - Donevan Dolby</b></h2><h5 class="post__date">2016-04-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iUC7noGU1mQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well thank you and welcome my name is
Donna Dolby as Alex said I work for
base-2 solutions for the last couple
years my team and I have been working on
a Diagnostics application for the Boeing
737 this application is similar to the
software that drives your check engine
light in your car so when that light
pops on you need something do something
to it similar idea with the Boeing 737
this code been developed over two years
has grown to about 16,000 lines of
closure code making it one of the
largest cloud bases out there enclosure
so I'll go over a little background of
the Boeing 737 program how our software
is designed to work kind of the approach
we took why we pick closure some
challenges we faced along the way some
lessons learned and then finally how the
project was received how its how its
operating and then if we were to do it
all over again would we actually pick
closure to do that so boeing has been
working on making me more fuel-efficient
boeing 737 it's the next iteration is
the max the to meet these efficiencies
they've added new components a couple of
those new components are new engines
these new components bring with them new
sensors and these sensors are really a
technology disruption to the traditional
way that the mechanics and technicians
interface with these sensors Sara craft
is gonna go into service next year it's
had its first flight a couple months ago
you may have seen it on the news
base-2 was brought in to try and address
this technology disruption we have done
quite a bit of work in highly regulated
spaces where software development chop
consulting so it's kind of how we got to
start here so a little background on the
traditional way that the mechanics and
technicians interface with the sensors I
first have to physically locate them
which I don't know if you can kind of
see on here there's actually a little
bay here this is in the belly of the
aircraft and these are all the sensors
and actually have to climb up in here
and on the back of each of these sensors
their little screens and they have to
read those screens and then go look up
in a manual and maybe do some
calculations manually
to determine what's actually if there's
any maintenance required on the aircraft
it's a very manual process and now going
forward with the new components the new
sensors that come with those components
no longer have that display on the back
so they can't actually do this manual
process anymore so our software which is
called the onboard maintenance function
or OMF is really how to handle this
technology disruption and it's really a
disruption during both manufacturing and
maintenance of the aircraft during
manufacturing the aircraft will be
installing components and they neither
run Diagnostics on it so the OMF really
will consume all the sensor data and
will calculate any running calculations
and then display to the end user in this
case technicians or mechanics the
maintenance messages there are over
6,000 potential maintenance messages
that can be displayed so a bit more than
in your car for sure and so a way to
efficiently show this to the end-user it
really is important so during
manufacturing they're installing new
components it takes a few days to do
this and as they're running through that
installation they're running Diagnostics
tests on their the OMF solution will be
part of that they can run tests they can
get sensor information as they're
installing this it's a it's it's our
hope and Boeing's hope that this new
process is more efficient than the
current manual way of doing that and as
it's more efficient it should make
producing these aircraft faster which
with over 3,000 orders of the aircraft
you know it's important to get these all
out I don't remember the exact number
how many can do a month but it's you
know on the order of 20 or 30 a month so
it's going to take a long time to fill
all these orders beyond manufacturing
there is a maintenance component the
airlines are really asking for
improvements at Gate turn so Gate turn
is boarding and deep plenty of
passengers servicing or
loading and unloading of luggage
servicing of the laboratories and stuff
like that but there's also maintenance
component this is important to get these
times down because the 737 is used for
short haul carriers so these are flights
that last less than three hours
typically if you're in the air for three
hours but then on the ground for an hour
or more that's 25% of your operating
cost so airlines really have big
interest in getting these times down and
also it allows them to get their flights
out on time which makes passengers much
happier again the due process should be
more efficient so we'll have a direct
effect on this maintenance check so at
every gate turn the technicians aboard
the aircraft and view all these messages
it's a little history starting with the
787 Boeing had this e enabling
initiative where they want to connect
the whole aircraft and as part of that
they added a piece of hardware that
consumes all the sensors and does
basically what OMF does unfortunately
it's a huge piece of hardware that
doesn't fit on the 737 737 is a much
smaller aircraft
fortunately the predecessor to the max
the next generation or ng added a
component called the onboard network
system and this connected all the
components but it actually doesn't do
any of these calculations so the OMF
product is designed to run on the ONS
platform it will get consumed the sensor
data run it through these six thousand
fault evaluations and then expose that
through some rest interfaces that
there's a few different ways that the
sensor data that the information can be
displayed there's a there's a couple of
screens on in the cockpit and our flight
deck that the maintenance technicians
can use and they can also just plug in
the laptop or use their iPads to view
this and so we used rest to expose all
that and then there's also some human
education that could happen during the
flight we can trigger events or ground
systems can actually request information
and it'll be sent to ground stations
over satellite or cellular transmission
so initially Berlin came to us with the
787 solution the language that's defined
used to define the maintance messages
and asked if we could create a software
solution that does that so parse this
dsl and see if we can simulate sending
sensory data through and evaluate these
faults the ones who proved we could do
that
blowing awarded us with the contract
which comprised of over 1,700
requirements that define what a fully
functional OMF system really should be
and it covers things like how do you
determine a lot of faults is and that's
really the domain-specific language
basically checking that sensor values
are within certain parameters and if
they're not then it indicates they
follow it talks about how to determine
what a flight phase is the flight phase
is like your taxi n taxi out take off
crews descend land that kind of thing
those are also determined using the same
domain-specific language so there's
sensors all over the aircraft check the
weight on wheels can see if the doors
are open that kind of thing
and so we use those to determine what
flight phase ring and then flight leg is
wouldn't you board the aircraft they
close the doors and then you take off
and land at your destination
again those are also calculated using
the domain-specific language and then we
have things is actually communicating
directly with the sensor to command them
to do things when they're installing
components they really need to know what
firmware is installed on this software
are on the sensors and so we have to
understand how to actually send and
receive messages from the sensors in
that regard they're also running
Diagnostics testing to make sure the
sensors are working properly and so we
got requirements around that I think I
mentioned before there's reporting
requirements so how they get information
off the aircraft for analysis at later
times then we had some performance and
data retention type requirements and so
we kind of bucket that into our database
management and then Boeing really needed
a way to actually define these maintance
messages and configure the system so
they needed the configuration tool and
so we have some requirements around that
and then we really have this derived
requirements
that I'm calling input simulation when
we started developing this the system
that we get the sensor data from was not
full was not complete so we couldn't
rely on it to run any testing also we
needed to verify that our fault
processing or logic evaluation that are
actually working properly so we needed
to know exactly what inputs were coming
into our system and so we know that our
equations were evaluating properly it's
kind of a overview of the functional
areas in our system down at the bottom
we have our persistence service we use
sequel Lite as our database and we
needed some relational database
capabilities but we didn't need a
database that has the overhead of say
Oracle need to be something that doesn't
require any administration on it this is
running on an aircraft that has no way
to really interface with the database
itself it also need to be lightweight
where you have a pretty small system
that we're running on so not a lot of
hardware to grow there the ADEs service
sorry
the ATS service is how we communicate
with the sensors and get the sensor data
the MAF service is how we communicate
off the aircraft so they're sending over
cellular or satellite in communications
building on that we have our fault
processing and then we have this
messaging service and then the higher
levels we have our services to calculate
white phase flight legs ground testing
that kind of thing and at the top we
have a rest interface that really
reaches into all these different areas
to expose information to the to the UI's
so why'd you pick closure so we knew
once we have the prototype we knew we're
going to have an event-driven type
system we're gonna have users clicking
buttons interacting with our system
we're also going to have sensor data
coming into our system because of that
we really wanted to use a functional
reactive paradigm and that kind of
eliminates a lot of the imperative
languages really feels like a functional
language type of implementation
we also had a DSL we needed to parse
Lisp has a long history of natural
language processing closures of Lisp
syntax language so it seemed like there
might be a natural fit there also early
on we found insta parse which providing
in a BNF was very easy to actually parse
the syntax and then mapping those trees
to actual functions to evaluate them
much easier in a functional language
than say using antler with Java there
was also a parallelism that we thought
might be there we have over 6,000 faults
we're gonna be running the same sensor
data across all six thousand faults it
seemed like there might be some
opportunities to take advantage of
parallel processing turns out we didn't
actually use that the language the
syntax allowed some dependencies between
equations so some equations might refer
to others and trying to build that
dependency hierarchy I would add a bit
of complexity to our engine and we
didn't need the performance we were able
to keep up without doing this in
parallel so we ultimately didn't need
that then I mentioned before there's no
capacity for new hardware we couldn't
just reuse what was done for the 787 we
needed to run an existing configuration
which was the ons and that ons had a
bunch of Java apps on it already so
there was already a JVM so we take that
all into consideration closure felt like
a good a good match there okay so now
that we've picked closure and we've
started development I'll go over a
couple challenges we faced first one
related to dependencies as I showed you
here earlier all these lines really
represent some dependencies and this
isn't complete this is really just
notional trying to write this
programmatically when you got developers
developing different components and
parallel trying to manage a startup and
shutdown sequence like one function to
do that can be pretty challenging and
even if you get that all right first
time now you have to go back and fix a
bug and you find you have some new
dependency between some components now
you have to go maintain that startup and
shutdown sequence there's lots of places
to introduce problems there we found
Trapper Keeper pretty early on Trapper
Keeper allowed us to
to find each of these components as
Services Trapper Keeper services and as
part of that definition we can specify
what other services we depend on so I
have some code here from one of our
flight face service and all the
dependencies it has then we're able to
tell Trapper Keeper okay on startup we
want you to start up all these services
and then Trapper Keepers is able to go
through find all these specifications
there and then build its own dependency
hierarchy and start up your application
in the proper order so another issue
related to dependencies that we ran into
with circular dependencies we have on
the Left we've got this fault engine
which evaluates our our logic equation
language and one of the things that can
be specified in that language is
checking what the current flight phases
so I have an example equation here we're
looking at the presence of some sensor
data and that the current flight phase
is actually taxiing so that kind of
implies that our fault engine needs to
reach out to the flight phase service
and get some information so import some
functionality to get the current flight
phase what our flight phase also uses
the file the logic expression evaluation
to determine what current flight phases
and so that really applies that we need
to register those equations to be
evaluated with the logic equation
evaluator if we do this by importing
functions for flight phase and then
importing and then flight phase
importing functions from fault engine
your code will not run it won't won't
even build so how do we meet these
requirements of the language but also
can adhere to the language constraints
so we did is we added a messaging
service in the middle so our flight
phase service still continues register
it's equations but instead of the fault
engine going back to the flight phase
service it will request a subscription
from the messaging service for messages
related to phase changes and after it
gets the phase change information then
it can cure it you can use that as its
current flight phase and evaluate the
expressions and once it's done that
he'll then publish out to the best
things
any changes to any of the logic
equations so anything goes from active
to not active or not active to active
then over in the flight phase service we
will create a subscription for any
changes to the logic equations and
filtered even more down to just the
logic equations that we vid that we've
registered with the fault engine once it
gets all that information it can then
calculate what the current flight phase
is and then it can publish out a message
out to the messaging service saying that
this is the current plan phase so now
there's not a reach back into the
service we've broken the circular
dependency and we're still meeting the
requirement of evaluating the syntax so
I have a little bit into the messaging
service itself we built this as a pub
sub framework it's built using lamina
channels lamina is now deprecated which
we'll talk about later but so basically
what we have here on the left are some
publishers a couple publishers one for
the current flight phase and one for
logic equations at the core there is one
channel and this channel is around a
channel so nothing can accumulate in
that channel if there's no consumers
each time one of these publishes a
message into the path to the main
channel it will add some metadata of an
event type so the top everything will be
tagged with the phase and on the bottom
everything will be tagged with the logic
and then our subscribers what we do
there is when the subscription is
requested the master channel is tapped
so basically gets a copy of everything
goes in that master Channel and then we
had a apply a filter to that that will
just filter on the event type matching
the type that we're interested in and
down here is pretty much the extent of
the code so it's pretty small we have
the master channel and we have a
published function which takes an event
type and then the event and that just in
queues it into the master Channel and
then down on the subscription we tapped
the channel and then we apply a filter
and we only look for messages that have
that message type in it
alright go over some lessons learned
first performance been a couple years in
development we've had a few iterations
of performance improvement and tuning
over that time closure runs in the JVM
we picked your kit as our CPU and memory
profiling tool since it's a JVM tool as
well
primary offenders I remember have been
memory leaks so our system has to step
like seven days which doesn't sound very
long but we have a very small system
that we're confined to so any type of
small leak becomes a problem after a few
days the vast majority of our memory
leak problems have been improper use of
lamina channels so not grounding a
channel and having producers so it
continues to grow or we've had channels
they had consumers but then the consumer
went away and and didn't close the
producer so it just keeps accumulating
messages one thing I would say is it's
probably case with any of the CPU memory
profiling the way that closure objects
persistent data structures are mapped to
Java objects that can become challenging
to backtrack who actually still owns
that object like why is it still alive
why hasn't been garbage collected a
quick example of some york hit output
just recently we fixed a problem in our
mock service or input simulator service
every time we'd restart our own map
service this our input simulator would
the memory would jump up and would never
recoup she'd restart half a dozen times
then then it would ultimately crash
turns out it was again a misuse of
lamina channels we had to we were
connecting a couple channels and in that
connection there's you can specify if
the source closes close the destination
or if the destination closes close the
source and we had that reversed and so
when we lost connection to the from OMF
it was closing like half our channels
but the rest of them were still
remaining open it was pretty difficult
to find but after that then we can see
so here the orange is old gen
memory that can't be garbage collected
and down here was after that fix so it's
pretty dramatic change there alright so
after we what kind of exhausted our use
of your kit and we still were having
some performance issues we raised our
hand and I reached out to cognate tech
and asked if maybe they can come in and
and analyze our code look at her code do
some code reviews see if we're doing
anything systemic like nothing terribly
inefficient but maybe lots of the same
pattern that has mildly inefficient
things in it so a couple of things that
we took away from that was one which
should really move from one six to one
seven and now one eight and 1 6 2 1 7
introduced transducers a transducer I
like to look at what it means in the
real world so if you look at what a
transducer really is an amplifier is a
transducer so any amplifier takes one
signal applies a external source of
energy to it and boost that signal
transducers and closure are similar you
take in a collection you're doing
something to that collection and you
have a new collection that comes out the
other end you can do this here where I
have a collection on one side and we're
adding a bunch of shapes to it you can
do this enclosure one six or before one
seven using we had a bunch of these
where we were threading a collection
through a bunch of sequence of maps and
so you can get the same behavior but
that adds on each one of the iterations
to the map after each map we're stuck
with a temporary persistent data
structure something that nothing's ever
going to use so there's really no reason
for it to be persistent transducers
bypass that persistent data structure so
you don't have to take on the overhead
of every step of the way keeping track
of the the persistent data structures we
had a fair amount of this pattern where
we were threading data and many of you
leaving the data structures and so
adding changing over transducers
definitely improved our performance the
other area I really take away is we
don't need to be purely closure like we
should be using the right tool for the
right job right
we have we have an input queue in your
back you where all our data is coming in
it's one producer one consumer we're not
trying to make this parallel nobody
first implemented it we kind of had this
event queue the structure the data
structure storing that was just a
persistent queue but that brings with it
as the name implies persistent data
structures but since this is not shared
not not spread across multiple threads
there's really no reason to do that so
we just switched to concurrent links
queue going to Java directly we did see
a significant performance improvement
there and it was part of our main
processing loop of fall processing so
that's an important place to get the
improvements all right next thing I want
to talk about is a library selection so
closure is still a pretty young language
and as such a lot of its libraries are
still young and somewhat volatile lamina
for example now is deprecated we found
that out about halfway through our
development after we really fully
adopted embraced lamina has our
messaging protocol other things someone
new developers and a new community it's
kind of hard to find some libraries and
to know that maybe there's a library
that does something that you want we
have a fair amount of sequel just
embedded as strings within our closure
code if we didn't know it about
yes sequel or hug sequel we probably
have done some research to see if that
made sense to maintain that through one
of those libraries and then our reports
we have that we generate we use mustache
templates early on we selected close -
as our mustache render and it worked
fine early on we didn't need
functionally it was great it was easy to
use but we didn't need performance we
didn't think this wasn't something had
to happen in real time it was more
event-driven could take a while turns
out after the aircraft has been on the
factory floor for seven days and they've
been toggling on and off sensors and
creating thousands tens of thousands of
fault
maybe hundreds of thousands must are
closed - when it tried to render these
reports it just couldn't keep up
I think under the covers it's using some
regex and when you're dealing with huge
files
it just doesn't perform fortunately we
found stencil which is another moustache
library and we were able to swap out the
couple places so we have a dozen or more
report types we just swapped out the two
that were really big offenders so
takeaway really is to wrap your
libraries like if you're gonna adopt a
third party library you should really
put an abstraction layer around it it's
a really isolate yourself our mustache
is pretty good each each report actually
had it been pretty encapsulated it would
have been better if it was one place but
only having to change a couple places
really isolated any regressions lament
on the other hand is pervasive
throughout our code it's all over the
place so switching to quarry sync is
will be a massive change if we have to
do that both from a coding effort but
also from it's going to introduce
regressions and so trying to work
through all that will be pretty
challenging right and then there's kind
of a learning curve for new developers
the majority of developers out there are
still coming from an object-oriented
background so dealing with collections
and iterating over collections you know
they understand for while loops but you
know trying to think of your collections
and iterating of them and snaps and
reduces it's a it's definitely a
paradigm shift and the other thing is
really immutable state like what does
that even mean like when you're coming
from an object-oriented program like
what do you mean I can't change this
object how am I supposed to do what I
need to do you get them over that hurdle
and then it's understanding what how
they do it in closure with persistent
data structures and what does that mean
for my performance fortunately we've had
pretty good success when we bring in a
new developer and we pair them with a
veteran on the program for about a week
or two they come become very productive
right away and even early on kind of the
original members none of us were using
closure before and we did a lot of
pairing together and we learned a lot so
it certainly was very beneficial to
overcome that
all right so the the product is actually
out there now on the factory floor
customers very happy it's had been on a
couple flights it's fantastic to be on a
project that has actually been delivered
well I don't think I'm alone when I'm on
a software project that just doesn't
ever see the last light of day you know
it's kind of nice to actually be on
something that that gets delivered and
actually works a little bit about the
development process we found this too or
at least I did I'm sure others did
closure still concise it makes merge
requests and code reviews not enjoyable
but much more enjoyable than in other
languages I can do them and you know 20
30 minutes as opposed to hours for the
most part also I imagine if we'd written
this in C++ or Java we would have been
looking at two to three four times the
size of code base so much bigger code
base much bigger effort unit testing is
much easier in a functional language
enclosures functions for allowing you to
do unit tests it really encourages that
so it's encouraging best practices which
is great at one point we had clover is
running and we had really high code
coverage but our program our project
grew so large at some point I don't
remember which library was introduced
but one of those libraries actually
broke clover so I don't know what our
code coverage is anymore at this point
yeah that's that so would we still use
closure and I would say yes with a
couple exceptions so our mock are in our
sink put simulator our mock service we
implemented using closure there was
really no technical like advantage to
using closure it's just a rest endpoint
that's simulating can data or generating
random data could have easily been
implemented with no js' or Python or
something else and we could have taken
the closure resources that were
implementing that and put them on the
core application the core OMF
functionality also we have some
functional areas and particularly the
ground test where the implementation of
that which I have to take some credit
for not a good way it was was really it
really feels up to brannad there's lots
of maps and
or sorry Adams references that were
mutating and and this the design feels
very oh oh so I don't know if it would
be better but the way that was designed
and implemented doing it in Java
probably have made more sense at this
point all right before I take any
questions I want to recognize a couple
people this project did take a team a
couple of team members are here Tim
Clements is one of the founding members
of OMF and Jayson Tracy over there he
just joined us a couple months ago he's
the newest member on lmf we have a booth
here we'll be around for the whole show
so if there's any questions we don't get
to now you can come find us so I'll take
questions now though no bowing actually
has a list of approved languages and
closure happens to be on that list which
is which is surprising but
yeah they did yeah that's what they did
the gate yeah yeah yeah oh so the
question was basically there was no way
they were doing up the gate right there
was no way they were actually checking
that like manual going through that
popping their head up into the bay and
reading those like it seems kind of
crazy that would be allowed right with
the regulations but so one thing I
should add is that this is not this is
all really related to the performance of
the aircraft none of this stuff is
flight critical so if there's something
that's reported incorrectly
or the maintenance crew reads something
wrong it's not gonna you're not they're
not putting your lives in danger like
it's it's more related to the overall
health and performance in the aircraft
not not actually keeping it in the air
code base is 6 over 16,000 lines of code
roughly
sorry but maybe we get the mic I didn't
catch that
you seem to be doing a lot with
engineering math and transliterating
engineering math into code does it help
to be in a functional language when you
translate math into code
I think I'll defer that let's let's talk
afterwards I've Tim if you can come to
our booth we can we can talk about that
later
hello you mentioned that you had issues
profiling the application could you like
speak a bit more how you went from
actually looking at the profiling data
and identifying the real issues yes so
the majority of our issues have were
related to memory leaks so it was hard
to track down these but basically what
we ultimately found is you can see the
lamina objects here these lamina node
objects that get created way down way
down low and you can fortunately look at
the information that's actually in that
node and so really it came down to we'd
see a million of these nodes that were
in our system and it's a lot of trial
and error of looking at each one of
those and seeing ok this is a flight
phase message this is the logic message
it just or this is a ground test message
like finding those and then if you see a
whole bunch of them and and you only
expect to see a couple of them because
it should really be consumed that's
really ultimately how we tracked back
there's only a couple producers of that
so it kind of helped figure out who the
actual offender was it's not not that
easy but yeah that's basically where you
kind of find the source of it but it was
certainly difficult like the way that
the persistence data structures get
mapped to it's it's pretty hairy in
there
yeah we're using Oracle's JVM that's the
one that's actually on the aircraft and
forget what what's the paradigm we're
using for garbage collection Tim do you
remember yeah I it wasn't a big
consideration I don't think we had again
it's not a system that it was real time
or you know flight critical so it we I
don't think we've seen any problems
where garbage collection is happening
and it's impacting our our overall
performance okay you have an example of
the DSL so it's not very pretty but I
made it pretty simple here
all right so the question is what does
the DSL look like so here's an example
there's an address every sensor has an
address on it it has this two letter two
digits DL and then a number zero one
four and then an underscore and this is
called the label so there's a bus and
there's a label and then there's this
thing called an SDI which is just
basically a channel on those buses and
you can specify that can be 0 1 2 3 or X
if we don't care and then this syntax
here we're looking at basically bits 12
through 30 that should be 31 and we're
converting that to an unsigned int and
then checking it against this value 180
and then over here we have this Prez so
there's a couple operators there's Prez
which means present there's pre what's
the previous value was there's test
there's NCD which is like do not use and
so that's checking like a certain bits
on the on the message or if the message
is present and then there's this flight
phase equals taxi and so it's looking at
the current flight phase is actually
taxiing and vary it to you know
intuitive that o means and but I didn't
show it here but plus means or which
sort of makes sense but but the o mean
in the end yes
it's two-way it's mostly we mostly
consume it but we can command the
sensors to run through batteries of
tests and so we send messages to it or
we can request configuration data so we
send it a request as well and if
anybody's interested to use this ARINC
429 as the communication protocol just
in case
so certainly we ran into I touch them a
little bit with the clover äj--
like that was one tool that broke we
that we just haven't fixed and then also
our ability to run the repple with our
code and it also broke I think it might
have been something with Trapper Keeper
possibly so that that makes a little
more challenging to debug because we you
know can't just jump into the repple to
debug it we have to you know I'd print
statements or something documentation
were so er a s 9100 certified and so and
this is what it's called a QMS I feel it
just stands for but it's highly
regulated so we have a big process so we
have a ton of documentation in there I
don't know that any of its really useful
for developers coming on you know like
what's actually in the code but there's
a lot of information they're definitely
bringing on new developers pairing has
been by far the biggest help with
overcoming the learning curve of of
closure itself and then really
understanding the code base I'm sure I
can think of more so we just used the
built in closure def test and the
assertion checks it's not regulated we
have requirements that we have to have
something like 70% code coverage so you
know test is really how we test that we
have proper code coverage in that say in
that sense
yeah we don't let Tim touch the code
because they want to refactor it no we
do have some strategies like we have
we're investigating right now
moving away from lamina to say quarry
sinks so there's a little bit of an
effort going on to see what that
actually will involve there's nothing
you know necessarily written down for a
strategy but it's just you really look
to see what it's going to what's going
to involve to to refactor some code I
guess if you prescribed to the clean
coder I come approach you should always
be refactoring your code right if your
codes not flexible or if you don't flex
your code you there codes not flexible I
don't know if I fully subscribe to that
but there's certainly a community that
does so it's ramping down now but at the
peak we had I think six six closure tabs
five Quality Assurance testers a couple
s debts and then some PM's and some base
two also has the whole group of systems
engineers and so they're kind of we've
used them for maintaining like our
requirements things like that so
probably had 15 15 or more people
actually on the project at any one time
back there okay
we're all VI right
no maybe me actually I use light table a
few people use light table
I think IntelliJ or some I mean we're
we're pretty open to whatever tools
people want to use for their IDs yeah
there's not really standard I would say
if I'm working with somebody new they're
probably never using light table because
that's what I use you know with that but
they can they're free to go figure
something out themselves all right do we
have more room from time for one more or
all right one more question I think we
have a couple places where we do some
type checking yeah the rest in points
that's exactly right so rest in points
so when we're receiving data requests we
definitely do validation there yeah okay
all right well thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>