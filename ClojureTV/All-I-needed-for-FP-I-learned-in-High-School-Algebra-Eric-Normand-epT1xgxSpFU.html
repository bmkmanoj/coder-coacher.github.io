<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>All I needed for FP I learned in High School Algebra - Eric Normand | Coder Coacher - Coaching Coders</title><meta content="All I needed for FP I learned in High School Algebra - Eric Normand - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>All I needed for FP I learned in High School Algebra - Eric Normand</b></h2><h5 class="post__date">2017-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/epT1xgxSpFU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I have a daughter she's five and a
couple years ago when she was about
three she was learning to count and she
already knew how to do like 1 2 3 she
could count out loud but I mean she was
learning to count objects which is a
little more complicated and one of the
cool things about having a daughter or a
kid is that they are beginners at
everything and I love watching beginners
learn something that I already know like
I'm pretty good at counting I make it
look easy but it's not easy and just
watching my daughter I could see how
many ways there were to fail that it was
a real process that you had to get right
and I like going down into these basics
and these fundamentals and really
uncovering something that to me is has
I've done it so long it's so intuitive I
can't I don't have access to it anymore
but when I watch her I have access again
and I can say oh I see what I do when I
count because of the way she messes up
basically so let's go over this process
of counting so let's say we have some
rocks and I line them up so it's easier
to count and so here's the process you
get into a rhythm and you say 1 2 3 ok
at the same time each time you say a
word you touch a rock so you go 1 2 3 4
5 6 and then when you've touched all the
rocks the last number you say the last
word you say is the count of the rocks
as long as you do it right you don't
skip any and you don't do any twice so
that's cool we have a process for
turning some real-world thing a
collection of objects into data into a
number and then we can use that number
in other ways and I feel like this is
really fundamental to what we do as
programmers that we're always dealing
with processes and often we generate
data off of that process and just to go
deeper into this mystery let's
let's see like if we projected out ten
years and she starts collecting tons of
rocks tons a lot of rocks every day more
than she does now
because the trend continued she's at the
end of her day she empties our pockets
her bags she puts them on a table and
she counts them and then every day she
just records some information about the
day the date you know the weather and
how many rocks she collected and then at
the end of the year she can do all sorts
of cool stuff with this data she can sum
up how many rocks did I collect this
year what was the average number of
rocks per day what was my biggest week
what was my smallest month she can do
all of this stuff for instance the
number of rocks in the year she can do
that without ever touching the rocks
again and we trust we all of us in this
room trust that if she counted them each
day correctly and wrote them down
correctly when she adds them all up she
would get exactly the same answer as if
she took those rocks that she put in the
closet for the year and counted them out
with that same process she started with
and to me that's like very mysterious
she's not touching rocks anymore but
she's talking about she's discovering
stuff about the rocks she somehow
modeled some important aspects of the
rocks with this data that she's
collecting and so that's something we do
as as programmers is we we take some
real-world process and we turn it into
some other process that a computer runs
instructions in a machine and these
processes somehow get the same result
the same answer somehow they're -
they're totally different processes one
is bits in a machine it's moving stuff
around in memory and the other is
manipulating physical objects so when we
translate one process to another there
must be something that is preserved
something essential to that process that
goes from the physical process
to the to the software process so what
is it that makes numbers as an example
so useful for counting piles of rocks
that's the question I'm trying to answer
so the title of my talk is all I needed
for FP I learned in high school algebra
it's kind of a fib because like I've
already shown a lot of the stuff with to
an FP we started learning as soon as we
were born right we were playing with
little things as babies we developed
these intuitive understandings of number
and stuff like that except in high
school we started going symbolic right
with an algebra class
that's when arithmetic was no longer
just some markings for problems we had
to do in arithmetic right this adding
numbers it became talking about the
properties of these these operators that
we had my name is Eric Normand
I teach closure online video form mostly
at purely functional TV I also have a
newsletter a weekly newsletter it's free
sign up I talk about closure and
functional programming it's a mix of
news and history and other cool stuff I
found around on the internet and I'm
also running a conference in New Orleans
called closure sync it's in February
y'all know strange loop if strange loop
is about the confluence of industry and
academia closure sync is about software
and its place in the history of humanity
and I feel like the closure communi the
lens of closure because the closure
community is I think a really cool
community to talk about this stuff in
write we were obviously philosophical
programmers okay so like I said I like
going basic please don't think I'm
talking down to you or like I don't
think you know how to count or something
like that I love doing this I do it
myself with my daughter's rocks with her
you know I don't
myself I do it myself not by myself okay
so let's imagine we had a pile of rocks
we'll call it a and we add to that
another pile of rocks and that's B we
get this bigger pile of rocks we can
call that a plus B now we could also go
the other way we could start with the
small one B and add the bigger one on
top and pile of rocks at the end at
least the structure is different like
the pile is different like the
arrangement of rocks but the count is
the same right and we learned this as
kids and there's something about this
where the four combining rocks order
doesn't matter we need to preserve this
when we translate it into our
information system into our log book we
need to preserve this order doesn't
matter because we want to be able to you
know we can add up from the bottom we
can add up from the top it's all the
same right we know that so let's let's
move into the symbolic realm there's
some closure code we can also write this
and we want to say that these are the
same so we can put in equals so we've
just derived this property of addition
that the order of the arguments doesn't
matter and then we can pull this algebra
trick and say we can actually say this
about any function that we want to write
we could say hey it has this property
our order of arguments doesn't matter
and mathematicians have called this
commutativity order doesn't matter and
what the reason I'm bringing this up is
commutativity is a great property
mathematicians been talking about it for
a long time but we just derived it
really quickly and we can derive all
sorts of properties that we want these
are this is just one that mathematicians
happens have already discovered but in
your domain the one you're modeling in
your software you have to go in and like
figure out what are the things that are
important to keep another thing that's
cool about this is starting from the
formula or the Equality that we have
we can make a test check property really
easily so of course the generator has to
be right but if we got that all right
we've got a test check property that we
can now guarantee that our function f is
commutative using test check okay and
now I was gonna save this to the end but
rich talked about this in the morning so
I have to mention it so I am NOT trying
to say that that math is like the
perfect thing and we should all be
programming more math and what I'm
trying to say is that math is this
platonic world where everything is
consistent that's like how you derive
more math you just stay consistent you
can do whatever you want but in the real
world we and we're modeling real word
processes this it's much more messy we
don't have this strict line between what
is commutative and what isn't sometimes
the line is blurry
sometimes there's conditions on it
here's an example if we have merge of
two hashmaps
I could say and I'd be wrong but I could
say it's commutative it's not
commutative because what if you have key
collisions between the two maps one of
them is gonna have to win right but when
I'm programming enclosure and this is
true in most dynamic languages I know at
this point in my program they actually
is a map from over here and B is a map
from over here I know the keys and they
don't collide right that's how we
program we keep this stuff in our heads
as we're programming so if I just change
the generators and I say well if I gen
if a is a map 1 and B is a map to I can
now say that there because they have
different keys that it's commutative so
I'm just like elaborating this kind of
absolute property called tivity
commutativity and tweaking it a little
just for my purposes because that's how
my model works so we're taking the idea
from math
making it much more real-world
applicable alright now I said before
that at the end of the year my daughter
would like add up all the weeks right
she would figure out how much how many
rocks she had per week how many rocks
she had per month and that's cool she
can group them by week she can group him
by month she can group him by the whole
year she can say well how about each day
was Monday bigger in general than
Tuesday then Wednesday she can group
them arbitrarily that is the cool
property that comes straight out of
piles of rocks that's something that got
preserved so let's take a look at that
so we have these piles of rocks we have
two choices we can group the ones on the
Left first and then add in the other one
or we can start with the ones on the
right and add in the third one there's
also the third choice which is just put
them all together at once which is what
we do in closure right to have a plus
with a bunch of numbers because we don't
like to write extra parentheses in Lisp
what this means is grouping doesn't
matter I can group by month I can group
by week grouping doesn't matter just to
derive this I can group there by the
first one or the left ones are the right
ones and then I can put the other ones
around it and then I can get rid of the
whitespace and then I can say they're
equal so we just derived this little
property that we can now use from test
checker you know just keep it in our
head make a comment something like that
and then we can say for any function not
just for addition this is called the
Scioscia Tiffa T and it's another one of
those properties that algebra is talk
about means grouping doesn't matter okay
let's go deeper into this one because
the socio Tiffa T is actually a really
cool property that's that's it's not
evident from what I've talked about like
how cool it is so I'm talking about
types but I'm not beings I'm dynamic
typing right we're
closure people but dynamic typing just
like valid values for the arguments so
we see if we look at the first argument
we've got the return value of F is the
first argument to F and a is the first
argument to F which means that they have
to be the same type same here C is the
second argument and F the return value
of F is also the second argument so what
we're saying is the return value of F
and the two arguments to F have to be
the same type now I like to think of
this as as whole values this is an idea
from John Hughes and this is how I is
how I think about it if we have two
piles we combine them into a new pile so
it has all the same operations the same
properties as the individual piles had
or if we have two strings and we are two
lists and we concatenate them we have a
new list right we haven't changed types
same with merging two hashmaps where
should hash Matthew have a new hash map
we're maintaining the space where in
we're still using the same type okay
these two often get confused in high
school algebra I got confused
I still use the words interchangeably
and wrong I think it's because my
teacher and also just now me we both
used addition as the example which is
both associative and commutative so it's
easy to mix them up but it's clear to
see that the formulas are very different
and ones about order and ones about
grouping now I've talked about some
associative operations that aren't
commutative like string concatenation or
list concatenation you can't reverse the
order of the strings and get the same
answer but you can group them
differently I can do the ones on the
right and then the one on the front or
the ones on the left and the one on that
right okay but it's very hard to find a
basic mathematical operation that is
commutative but not associative
but you can make one you just compose
stuff up and so here's an example
average so we can see it's if we're
averaging two numbers it doesn't matter
what order we put a and B in right but
it's not associative so let's look at
the order that it doesn't matter just as
an example if we average 10 and 4 we get
7 if we average 4 and 7 or 4 and 10 we
get 7 same answer but if we do grouping
so we add a third number see it's gonna
get tangled up with arrows here but so
we have a and B 10 and 4 we get 7 and
then we average in that in with 6 we get
6.5 or we could go on the second line we
can do 4 &amp;amp; 6 we get 5 and we average 10
in with that and we get 7.5 so these are
different so it's the order I mean the
grouping does matter the order doesn't
matter but I want grouping to not matter
so we saw before how we could take a
property that we discovered in the world
and turn and and translate it and make
sure it's preserved into our software
but we can do this other thing where we
take a software that doesn't actually
have the property that we want and add
it in we can we can just do it you just
put it in there so we want it to be able
to be associative so let's do that okay
I often like to look at imperative code
because the answers are often in there
because if it works it must have the
properties that we're looking at it's
just that the properties are like
smeared all over the boilerplate so here
we have a function average where you
have an array of numbers and you have
you initialize some variables and then
we loop through the numbers and we
accumulate the values into our variables
then at the end we divide and we have
this kind of case where if it's 0 we
don't know what to return so here
returning mill that doesn't matter right
now I want to show this part this is
what we should focus on is that at each
iteration through the loop we have a
complete number and count for the things
we've already seen right we and we're
grouping them like from the left of the
array one at a time because we're
associative we can do that we can group
that addition any way we want but the
thing is we've separated them we don't
have that whole value property we have a
sum and one number and a count in
another so let's put them back together
let's define a function called combined
and it's got it too
it's we wanted to be associative so it's
got to take two arguments and so we'll
take those sum and count and we'll tuple
them up so I'm gonna call that tuple of
a summon account an average it's a ratio
it's the numerator and the denominator
of the average we just haven't divided
them yet we're just keeping them
separated and so we also know that the
return value has to be that same type
how do we get it well we know we're
adding up before we were grouping from
the left now we're grouping arbitrarily
so we're just gonna sum up the sums and
sum up the counts okay now we can create
a function called to average which is
going to take a number and turn it into
an average and so a single number the
average you know the denominator would
be 1 so we just derived that tuple of
number and it's n n 1 and then we can
write a function called average which
takes that list of numbers and it maps
to average over them and then it can
just reduce combined on them okay now we
have a problem that we what do we do in
the if numbers is empty it's an empty
list I don't recommend using the two
argument version of reduce we need a an
initial value there so we're asking the
question where
we start where do you start a
computation what do you like if I'm if I
tell you here's some rocks put them into
a pile where do you start you start with
like a space on the floor and you call
it an empty pile and then you start
adding the rocks to it right or if I say
here's some rocks count them where do
you start
we're programmers so we start at zero
that's what you would initialize you
think to and then you just add 1 at 1 at
1 so we have this thing in addition
where we know we're starting at zero so
we know that adding zero to a will give
us a and in general we could we can do
the algebra trick swap out the plus for
any variable and we can say that f of a
and I which corresponds to the F so I
put a subscript even though that's not
closure but that I corresponds to the
function itself right like each function
might have a different value of I and so
we can call this an identity value so in
addition the event of an identity value
of zero in this concatenation it's the
empty list etc
it just says where to start as a very
simple formula and now we know what to
put there we go back to our JavaScript
code and we see hey that's what we
initialized our values to that's where
we started at zero zero and so we'll
just put that in there now we're not
dividing them so this is okay it is a
ratio of zero and zero but we have not
actually divided them but what we have
now which we didn't have before was an
answer to the question of what is an
empty average an average of zero numbers
we have a value that we can check is
this the empty value because before we
had null which doesn't really work with
numbers you're like you're probably
gonna do some other math with
no you're gonna get a
nullpointerexception so you haven't
really solved the problem
if you've returned zero which I've done
before to you confound it with the
actual average zero so you don't know if
you have nothing or not there we have
something now all right ma noids Monroy
SAR where it's at I don't know why
everyone's talking about monads all the
time but MA noise are where it's at and
we just made one it's any operation that
has its associative and has an identity
value that's all ma no it is and they're
way more useful way more common than ma
monads and they're what they're awesome
for functional programming and we should
be talking about mono it's one maybe we
don't need to use the name but you know
there it's there okay here's the table
with everything we learned so far all
right here's another property that is so
basic like it's even silly to talk about
but like let's say I'm hungry and I
don't want to cook I go into a
restaurant I get my food I eat it and
then I leave right I'm glad I can leave
I don't want to live there I just want
to eat I didn't want to read a book so I
go to the library I read the book and I
leave I don't want to live in the
library I want to come back out I want
to go up the top of the mountain come
back down I want to get dressed and get
undressed
there's operations in the world that we
want to preserve that we can go back and
forth on because going back and forth
matters we want to be able to move into
a space where the some calculation is
possible or way easier and then come
back out because that's not where we
want the answer we don't want the answer
in that space
when I say space I mean like type right
so going back and forth matters here's
an example rich actually talked about
this I think he saw my slides which is
why his talk was so good okay so we have
some value at the bottom left some map
with my name and birthday we need to
send it to another computer to do some
work so we print it to a store
and now that it's a string we can see we
can send it over the wire I couldn't do
that it's just a regular data structure
and then he can't he doesn't want a
string he wants a data structure on the
other side so they read it in and now
it's a data structure you can operate on
and do other stuff and then you can do
the reverse for the answer right that's
awesome it's awesome that we can do this
and so just symbolically we can kind of
derive this so we have print string a
and then we read that that should be
equal to a right this is a really cool
property and we can do the algebra trick
and say F of a and G of that it's equal
to a and in that case we say G is the
inverse of F and what it means is going
back and forth matters so this is
another property that you can derive
from your code you can turn into tests
check properties you can add it to your
software and now we can add it to this
so we already have a way of taking a
number and moving it into this space
where it's an average it's a ratio we
need to be able to come back down so we
can write a function called average 2
which takes that tuple the sum in the
count and divides them right and then
our average function just becomes this
really clear step-by-step thing take
some numbers lift them all up into the
average space reduce with combined and
then lower it back down and this is a
very common functional programming
pattern ok elevator buttons
who knows what property I'm going to
talk about now so you walk into an
elevator area you press the button and
then someone else comes in button still
lit up they come and press it - did they
need to do that no but we have the habit
or we have the like irresistible urge
to press that button even though it's
already pressed but it doesn't matter
that that second press did not matter in
general we could say duplicates don't
matter for some operations so here's
another operation where duplicates don't
matter and start with a hashmap
em we Assoc a and hello and then we do
it again we know that that's the same
oops
that's the same as doing it once and it
even looks funny like why would you even
think of writing this and doing this
well I think you're seeing it backwards
if you're asking that because it's more
like I want to be able to do that and
not worry about it I don't have to care
I can do it as many times as I want and
it's the same as doing it once so we can
do the algebra trick again we can say we
know F of a is equal to F of a but then
we can go boom do it again still equal
this is called item Potence probably
guessed that because we talked about
that it's programmers it's like the one
algebraic property we're not afraid to
name and it just means duplicates don't
matter okay so let's say we want to
implement this you want to implement an
elevator button system for like the
whole hotel and we want to maintain this
item potent property so all we have to
do is use an operation that already has
idempotence and we're done
so a so John a hashmap has that so we
put in an Adam cuz it's mutable and then
we can define a function called press
now here's the thing it takes a button
ID when you're using item Potence often
you have an identity the the value has
some kind of identity if you're adding
to a set so you add this the number four
to a set twice the second time doesn't
matter right what is the identity its
itself alright for is its identity but
when you're adding to a hashmap what is
the identity it's the key right the key
is the identity
so we're gonna use that button ID as the
key to a social just put true it doesn't
really matter what we put in there and
we do some code later on we get a press
and we identify the button by its
location and the direction it's pointing
so the third floor
Northside UP button and you could press
it multiple times and we have this
intuitive note a notion that that second
and third time doesn't matter because
we're gonna give the same state so we're
done with idempotence there's more
properties that I would love to talk
about but every time I ran through this
it got complicated to explain and I ran
out of time and I didn't get to conclude
and talk about the good stuff but just
quickly a zero value when you're
multiplying if you get a zero you can
stop because you know the answer already
you have a zero so that's a zero value
is it tells you when to stop and then
structure preservation is this cool
thing if you're in a factory and you
have someone doing two operations on an
object it's assembly line right as a
manager you can go in and say hey wait a
second let's see if it's more efficient
to split that two tasks into two people
doing it one after the other so it's the
same assembly line but now you've split
that one task over but we know we'll get
the same product out at the end
that's structure preservation and so
there's the formula for that right there
okay here's the conclusions translating
these properties is what allows us to
program to translate from a physical to
a software or symbolic system and not
only do we want to preserve these things
and they're not these specifically these
were just examples right it talked about
that you can derive your own you can add
these to get those properties just like
we did with the average example
and you can discover your own properties
the trick is to make sure that they're
simple and easy to test like we had and
you can tweak the ones that that are
well-known that you find in the algebra
books because in the real world there
are these like corner cases and stuff
that you have to deal with all right
here's another thing here are some
challenges of distributed systems that
you know we all face when we start
spreading our work over multiple
machines messages are delivered out of
order well if we just had something
where order doesn't matter that's okay
messages are delivered one or more times
well if we just had something where
duplicates didn't matter now that's okay
sending tasks and combining answers well
if we had everything we needed for the
tasks to be done bundled together and
the whole value we could just send it
and then we know that however it gets
grouped in the Hadoop cluster and like
recombined it's okay because we can
combine it back together and get the
same answer where do you start when
you're starting some work when you start
at the identity value and then
serialization deserialization we need to
be able to turn it into something that
we can send and then turn it back into
data we can use okay I talked about this
algebraic properties make great tests
check properties I think I already
mentioned this right so we can test as
an example the the commutative property
of multiplication really easily it's
just this it's a great I love test check
and people always wonder like well where
how do you figure out what properties to
actually test well you just come up with
this little identity there's a little
equality and there you are you have
something to test something from the the
thing you're modeling okay that's it
it's my talk
oh I forgot something one thing before
you walk out I wanted to thank guy
Steele because a lot of these ideas come
straight from there he's sitting in the
back thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>