<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Faster Delivery with Pedestal and Vase - Paul deGrandis | Coder Coacher - Coaching Coders</title><meta content="Faster Delivery with Pedestal and Vase - Paul deGrandis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Faster Delivery with Pedestal and Vase - Paul deGrandis</b></h2><h5 class="post__date">2017-03-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_Cf-STRvFy8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello everybody before I begin I
just want to say thanks to everybody who
helped put all in closure West I very
much enjoy giving talks that closure
West because they tend to be sort of
more user focused you know more us focus
more technical less brain thottie I like
to thank all of you for jumping on this
side of the wall I appreciate that this
talk is called faster delivery with
pedestal and vase the font size is
important here because the talk really
is about faster delivery I mean that's
the primary focus of this talk and we
could sort of talk a lot about you know
why would I choose to talk about faster
delivery and maybe we would tease these
words apart what do I mean by faster you
know how does faster relate to
innovation
how does faster relates a competitive
advantage and so on or you know what do
I really mean by delivery and how is
delivery and related to value and why is
that particularly important and you know
there's some special purpose why I want
to put these two words next to each
other that would be a very typical thing
for me to do at this point in the talk
but I think this quote says it best
sustainable competitive advantage has to
be won by creating the internal capacity
to improve and innovate fast and without
let-up the constant evolution of
technology has a direct impact on
business innovate and deliver value or
be left behind and when we're looking at
the winners the best companies the best
organizations the best projects one
thing sort of stands out here they seem
to know before everybody else they seem
to learn faster they have that answer
before anybody else saw it and once they
have that answer in hand they they adapt
faster and they deliver value faster so
how is that possible now how can I get
that superpower how can I be a you know
the winning team or whatever and I think
there's one aspect of this that is
related to the reason why we're all here
today and you know there's a reason why
we choose closure
it's this programming language designed
to solve the problems that we face today
on you know these modern systems with
modern demands on modern infrastructure
now that's why we picked up closure and
maybe with closure we really are more
efficient maybe we really can do more
with less we use that phrase a lot house
we're trying to sell closure to other
people oh I can do way more with less
with closure and that's somehow better
but we should be very careful about this
phrase do more with less because there's
something hidden underneath here and the
thing that's hidden I think is
particularly more important than doing
more with less what we're really saying
is that incidental complexity in all of
its forms costs us time and that's time
that we could be spent you know we could
spend learning or adapting or delivering
value critical time so incidental
complexity gets in the way of winning it
is the enemy of delivering value and so
I think that's what closure is really
giving us a way to combat that enemy to
deliver value faster ensure there are
many aspects at play here I'm not
pretending like you know closure is the
thing that sells all of these problems
you know there's social aspects and
cultural aspects and so on but I'm
interested in one particular aspect
sharp tools that are data-driven that
enable delivery that's what I want to
talk about so today we're going to talk
about two tools designed to help you
deliver faster basically designed to
give you that competitive edge the two
tools are pedestal and vase pedestal is
a set of data centric libraries for
back-end and enterprise systems
it's a general-purpose interceptor
system that's fast secure robust and
built on well established practices
we'll tease apart each of those bullets
over the next couple of slides and then
we'll talk about vase data described
micro services that sit on top of on
pedestal there is just the interesting
aspect there is that they're declarative
vase does all sort of the hard mundane
work for you and they're fully
extensible allowing you to move that
tool
to wherever you need to it moves
development time of services from days
and weeks to just minutes and we'll see
how that's possible as we develop a
service and I have some goals and
talking about these two tools
specifically not just that I work on
them but you know I want to I want to
spread some information I think there's
a misconception across the community at
large about what pedestal really is
about what it provides you about what
you can do with it and I want to help
you all see pedestal the way that I see
pedestal and we're gonna do that by
looking only at the fundamentals we're
just gonna look at the very bottom layer
way down deep and pedestal and from
there you'll sort of understand how to
still the way that I see it
and after that we'll talk about vase
we'll sort of talk about the motivation
if I have pedestal and pedestal so great
why would I ever need vase
well there's a very specific reason for
that and after that we'll do a tutorial
building services with base and before I
go any further pedestal has a new
website pedestal die oh you can find all
sorts of things on it guides samples API
Doc's reference Docs everything has sort
of been collected from all around the
internet and put into the one site and
thank you to everybody in the pedestal
community who has helped contribute to
the site it's been a huge success so you
know pedestal is this set of libraries
for back-end development that's
something a lot of us do and it provides
a foundation for building robust
enterprise services usually HTTP
services I mean I think typically that's
the kind of services that we write
something with HTTP but pedestal isn't
actually tied to HTTP at all in fact
really nothing in pedestal except for
one small section is HTTP specific so
you can extend pedestal well beyond just
these HTTP services to other application
protocols or services like Kafka or 9p
we've done both and you can also extend
it to other transports like SCTP
reliable UDP and you DT we've done all
of those as well but also sort of built
on these core ideas and so when I think
of pedestal
I usually start at these core ideas
everything in pedestal is an interceptor
interceptors are just data structures
and interceptors compose so once you
understand an interceptor the rest of
pedestal serve falls into place we like
to say all the context is in the context
each of these interceptors take a
context as an argument that's the only
argument they take and they all return a
context the context is just a map and so
everything that controls pedestal all of
the functionality of pedestal that makes
postal seem special it's actually just
values inside of that map everything is
controlled from that context map
everything in pedestal absolutely
everything is programmed to an interface
so you can extend pedestal to whatever
you need whatever services you need
whatever data structures you need
whatever an in pedestal we favor data
over functions and we favor functions
over macros and so people compare
pedestal and ring quite often but I
don't think that comparison is
particularly useful for pedestal or for
ring you know pedestal is this generic
general-purpose Interceptor system we
just also happen to ship a lot of
interceptors that are related to HTTP
services as part of one library called
pedestal service and let me tell you
interceptors are absolutely everywhere
there's a volume of books called pattern
oriented software architecture and
interceptors have dedicated chapters in
volume two concurrent computing patterns
and in volume for distributed computing
patterns and throughout all the other
chapters they all reference back to
interceptors because of their
composability the servlet java servlets
and specifically the servlet filter is
actually just the interceptor pattern
just one implementation written in Java
and nearly all message oriented
middleware are written using the
interceptor pattern specifically for the
reasons cited in those two books
computational pipelines usually some
form of a computational dag oftentimes
implemented as an interceptor chain and
so pedestal is just an implementation of
this pattern of the inner
after pattern and more specifically the
combination of chain of responsibility
in the Interceptor pattern so let's just
dive in I think all of these concepts
make more sense when you see the pieces
come together and we'll start with
interceptors interceptors are the
building block of pedestal you can think
of them as a little Lego all by itself
there and there are map you know they're
map like so they optionally have a name
that's usually a namespaced keyword and
they have at least one of enter leave in
error and those are all functions that
take a context and return a context if
some data flows into an interceptor you
would call the enter function if some
response was coming out of the
Interceptor you would call the leave
function and if you wanted to handle any
errors you would call the error function
the creation of interceptors is
controlled by the interceptor API no
surprise but very specifically the into
interceptor protocol anything that
fulfills that protocol can be an
interceptor inside of pedestal alright
so here we have a single interceptor
it's just this little Lego block it has
this name it has an enter function that
takes the context and returns the
context in just like a single Lego block
it's not very fun to play with you know
you just may put it in your hand and
admire it but that's about as much as
you can do with it so it needs some
friends and we want to stick all these
Lego blocks together and in pedestal
when you stick those Lego blocks
together we call that the Interceptor
chain the Interceptor chain is just
about building and executing collections
of interceptors together so you can
imagine you know each interceptor does
exactly one job I want to compose all
those jobs or capabilities together and
so we get this interceptor chain and we
call it the Interceptor chain because it
is the Interceptor pattern and the chain
of responsibility pattern if one
interceptor doesn't do the job you go to
the next interceptor and so on once you
get to the end of the chain you can also
flow back and handle the leave stage of
each interceptor so a few slides back I
said the context controls pedestal so
let's talk about what kinds of control
actually exists inside of that context
this chain the chain itself all the
interceptors that need to execute
that's a value inside of the context so
let's just take some time and wrap our
brain around that an interceptor gets a
context that has the chain of all the
interceptors that should execute which
means any interceptor could add more
interceptors to execute remove all of
the interceptors to execute dynamically
change a reorder those interceptors that
are to execute so every interceptor has
full control over the system inside of
pedestal but we do this sort of thing
all the time think about an HTTP router
a router and a sort of a naive case
would look at an HTTP method and a URL
and decide can I handle that request or
not and if it could handle that request
maybe it just queues up all of the
interceptors needed to handle that
requests so a router is a really good
example of a single interceptor that
adds more interceptors after it
terminating the chain is also inside of
the context there's a sequence of
functions predicate functions and if any
of them return true execution stops and
so if you want to decide how how an
interceptor chain should execute or stop
or you can go ahead and do that as well
and pedestal is maybe most known for its
async capability is going async you know
it gets talked about a lot on the web
well going async inside the pedestal is
just a value inside of the context map
it's just a function that talks about
how you go async on any given platform
for that chain so there's nothing
special in pedestal that makes it a sink
a Pavillon a except that we chose a
design pattern specifically for
concurrent and distributed computing
that also means that you can define
async capabilities for whatever platform
you want all right you can write an
interceptor chain that runs on servlet
it sort of runs against HTTP and turn
around and run that exact same chain on
Kafka or something else and all the
signaling between interceptors and the
signaling that interceptors make to the
platform they're sitting on all those
keys and values those are also in the
context so absolutely everything is in
the context the context is in the
context all right so we've got this
chain of interceptors this is cool we've
composed all this functionality together
awesome I've you know my job is pretty
simple especially if other people have
written interceptors except this is sort
of like in a silo right it's in this
vacuum it's doing all this work but like
where is it doing this work and so we
need some way to connect an interceptor
chain to a platform and we call that a
chain provider that's pretty much all it
does right the chain provider just
connects a chain to a given platform and
supplies the initial context and the
initial context have you know the
default interceptors that always need to
execute the terminators that should
exist for this platform it usually
defines the function you know how do I
go async you know there's a key inside
the context map called async fun maybe
it maybe it defines that maybe async
works on your platform maybe a dozen so
it's got to define that and then any
sort of platform specific interceptors
you want so how do I turn closure data
structures into bytes on the wire for my
given application protocol protocol one
example of this is the servlet chain
provider that's the default one in
pedestal you know so I want to run some
pedestal chain on the servlet and I want
to use all capabilities of the platform
I want all async capability is all
signaling capabilities you know I want
zero copy requests going through my
chain that's the default in pedestal
always use the platform for whatever the
platform provides you with and when I
think of pedestal this is what I think
of composing interceptors helps me get
to a deliver deliverable result faster
you know I don't have to do as much work
all the hard work of connecting
functionalities together connecting to a
platform that's all managed for me I
just have to put my business logic into
incremental steps inside of these
interceptors well pedestal ships with a
set of modules built to build systems I
mean it really is a set of libraries for
building these robust enterprise systems
and services and so we've really just
been talking about pedestal interceptor
the module that has the Interceptor API
and other things for running an
interceptor chain well pedestal also has
a separate module called pedestal route
and you could use pedestal route for any
kind of generic routing so think about
all the different kinds of routing right
we have routing for web services we have
routing for queues we have
all sorts of different kinds of routing
you know and pedestal ships with this
pedestal route for very efficient
routing that in the most optimal case
does constant time routing and in the
general case does logarithmic routing on
my laptop that I'm presenting on right
now pedestal can make a routing decision
and apply all routing constraints in
under 60 nanoseconds so it's extremely
fast so I would say no I did all this
hard work to write this really efficient
router just don't just don't write
linear routers just go out and use
really efficient routers pedestal log is
also efficient logging but also includes
runtime and operational metrics so you
want to keep track of these
distributions of events that happen over
your system that's how we build robust
systems we want to understand the
distribution of behaviors that exist and
pedestal ships with this capability
automatically but you can extend it into
your application and the metrics
recording can be published to sort of
any metrics recorder that you want so by
default it publishes to JMX but you
could also public publish the metrics to
cloud watch or to STATS d-- or to any
other metrics report recording
capability that you would like and then
lastly we have pedestal service this is
just the collection of HUD HTTP specific
interceptors so you know this is sort of
the whole picture of what pedestal is is
giving you and this is good but honestly
it's not good enough innovate and
deliver value or be left behind and in
this pursuit we need to be anti fragile
in the world of ephemeral computing
micro services and constant change we
really need our code to be a disposable
inventory we can't become attached to
our systems the reality is they are
either going to be superseded or they're
going to become irrelevant so when
you're faced with this what do you do my
colleague Michael Nygaard has written
extensively about this in a series of
articles titled the new normal I highly
recommend you read them but that would
be a whole separate talk by itself so
businesses change
murrs change technologies evolve and we
need to minimize risk in this world by
maximizing change we need to play to the
same thing that we're scared of but
let's just take a step back you know our
tools can help us here we can make our
tools do all of the hard work for us but
we have to think about what do our tools
do well and how can we orient that
towards this problem I want to maximize
value and maximize change in order to
minimize risk well the tool set that we
have enclosure is really great at taking
in data reshaping data doing something
with it and returning some sort of a
result so if we can turn our problem
into a data problem our tool set will
work for us it will do all the heavy
lifting for us and that's exactly what
vase does it takes the creation of
services all the things that go along
with writing services plugging pieces
together and it turns it into a data
problem it's a library for writing
declarative data-driven micro services
it comes with database integration and
data validation all of the mundane data
public data plumbing it's already taken
care of for you in vase request tagging
uniform response shaping data encoding
all of the mundane stuff that goes into
creating a service that's a good citizen
that does the things you want it to do
that has all the extra bells and
whistles yeah bass does that for you you
shouldn't have to keep doing that you
shouldn't have to plug those pieces
together it's fully extensible and in
many aspects we'll see that a couple of
slides here it's been in development
since 2014 by very recently open sourced
and we could keep talking about vases
attributes I mean that's kind of fun to
do but most of those details can be
found out on the web or in other talks
or in a blog post instead I think we
should just create a service and see it
in action so we're gonna do a snapshot
version of that and I think you know why
not build a blog service that's what
everybody does here right so let's not
stray too far from the mainstream we
want people to take closure seriously
and if we want them to take it seriously
well hell we need a blog service so here
we go it's gonna be a microblog service
because a full blog service is too
involved and Plus you know microblogs
probably sell better I guess on the
internet so vase ships with a template
that works both in line again and in
boot here we're gonna start with Lanigan
and we're gonna do a line new phase
blogging this creates a fully working
service for us with all of the best
production settings offered by pedestal
all we need to do is write the service
descriptor so we need to describe our
service in some form of data and the
first thing that we probably should do
is talk about our data model or a domain
what is it that we're actually working
with in vase we use these things called
vase norms they're just chunks of schema
logically grouped by your data model so
our data model has some notion of users
and in fact now we can see the data
model for users you know a user has a
user name that's a single string and
that's how we're going to identify our
users and users also have emails that
are also a single string and the other
part of our service you know it has
blogs and blogs have titles that are
strings and you know content that is
strings and an author and an author is a
reference back to one of our users now
you'll notice here that I made title
unique you know we're gonna identify all
of our blog posts by their title so that
makes sure that people don't keep
repeating the same nonsense over and
over and over and over again it also
means that you know just like you know
you hammer out those fast emails that
are just the subject line and then end
of message with no body you know I want
to be able to write a blog service
that's like that that's like here's the
title of my blog imagine the content
enjoy so that's what we're gonna do
we're gonna build this this service
right here alright so we've got our data
model that's really good but now we need
some data validation an in vase data
validation is done using closure spec
and anything that you can do in closure
spec you can do for data validation in
vase and you're allowed to use the data
validation at any point in your service
or you're going to see that we're going
to use it a couple of times so here I'm
just saying you know what do I expect
user names to be what I expect user
emails to
and so on you know what does good data
look like for my system I want to make
sure that only good data gets into my
system and how do I shape data when it's
going out of my system to make sure that
you know it fulfills all the properties
I expect it to fulfill my favorite line
in this slide is the second from the
bottom when I started to find blogs I
get this great line of Bloggie blog blog
which you know always brings a smile to
my face blog a blog blog okay so you
know I've got some data validation I can
see how this might shape the rules
around my data but now I actually have
to do some work I need HTTP API
endpoints transactions queries
validations I need my service to come to
life I need it to do something useful
so vase has namespaced API chunks and
Here I am underneath it in the namespace
blog ev1 but it could be any namespace
it doesn't really matter and then I
define all of the routes for my service
this is where I'm going to let all of my
tools do the work for me I'm gonna
describe my service in data by talking
about sort of them than the main action
and then vase will go ahead and expand
that into all the functionality and
connect it the correct way so if I make
a get request to slash blog it's gonna
perform a query and that query has an
optional parameter called selector and I
want to make sure that selector comes in
as closure data I don't want it to come
in as a string I want to treat it like
data so I'm gonna coerce it into Eden
and then I'm just gonna run a query
against the de Tomic DB that's sitting
underneath my service all of those
details base will figure out now this
parameterize selector is pretty cool it
lets people say exactly how they want
their data let's see what really happens
when we start calling this so if I call
just slash blog so there's the namespace
phycologist slash blog the default
selector gives me all the fields of a
blog post and then also unpacks all of
the fields of the reference to the user
I'll get everything but maybe I don't
need all of that you know maybe I'm just
writing some search result page where
you see all the blog titles and so vase
allows you to write very quickly
demand-driven AP is where by call you
get to shape your data how
you need so here i've said well from my
selector i actually just need blog
titles and all I get back are blog
titles alright let's keep going let's
look at the post operation four slash
blog so if you call post on slash blog
you're gonna see we're gonna do a couple
of steps and these steps we actually
call those action literals inside of the
face those are the actions that you can
do that's those are the actions of that
vase understands but you could extend
those right there just reader literals
and you could write your own reader
literals and give these new capabilities
underneath all of these action literals
are interceptors and so think back to
that Interceptor chain where we saw each
block being composed together you can
actually see each block being composed
together here inside of that vector so
you can see how the pieces are being
added together first we're gonna
validate some data and validation inside
the vase is pretty simple you want to
apply some spec to some path in the
request I want to ensure that my request
is shaped the way that I expect it to be
shaped pretty cool if the validation
fails you get back an error result if it
passes you keep going to the next
interceptor the next interceptor is just
this generic interceptor and it's just
going to reshape the data specifically
ensuring that the author is a lookup ref
inside of des Tomic so we're just going
to change the shape a little bit and
then we're gonna perform this
transaction and transactions just look
at data payloads given a whitelist and
then they'll transact those attributes
into the DB so pretty straightforward
there too but think about the services
that you write and how much code and how
many functions are involved in doing all
of these things grabbing a request
unpacking a request looking at fields
validation data shaping requests tagging
shaping the data one more time doing the
transaction ensuring I have a connection
to the DB all of that so vase is going
to handle all those details for me okay
but let's not forget our users we also
have users they're very important here
we are slash user if I make a get
request it's going to perform a query on
my DB
looking up AI username if I make a post
I'll create some more users in my system
and if I make an HTTP delete I'll delete
some users in my system pretty quick
think about you know you're in the
meeting in that meeting you're
discussing the data model you're
hammering out that data model as a as a
descriptor here you know okay well yeah
we have users we have all this stuff and
now I can just hammer out these actions
pretty quickly and that's it let's just
take all of those pieces we'll shove
them into a single file and we're done
we have a service and we started with
our our vase norms or data model so here
we are in a meeting you know it's a
pretty big meeting I mean if we add up
all of the dollars this is costing us
right now it's pretty impressive all
right and you're telling me about your
problem you're your domain and I'm
capturing that domain all right yeah
users have a user name users have an
email all right okay so we've got our
data model and then you start telling me
about these business rules all right I'm
still typing you know I've got there's a
lot of us here so we could all be typing
okay so yep user names can be non empty
strings alright so I'm writing all these
specs pretty quick and then I sit down I
just I let vase do all the hard work for
me all right so I have some queries I
have some transactions I got to make
sure I only get clean data let the tools
do the hard work for you
and then at the very end we have some
API settings maybe you want to change
the data encoding by default vase uses
JSON but you know maybe you want to use
transit or maybe it's XML or whatever
you want to use you can set that per API
now we wrote this all in one file but we
could actually split all of this up
across many files this is just a data
structure and vase understands how to
merge all of these parts into a single
data structure so write it in a single
file write it in 200 files it doesn't
really matter it's just data and we
could also have multiple api's inside of
a single descriptor so we only wrote one
service API but everything was named
spaced so we can go ahead and add as
many services in a single descriptor as
we want maybe there's families of
services that are related and I want
them all in one descriptor I could also
write as many services as I want across
as many files as I want and vase will
merge those all to get
all of this works with interactive
development as soon as you do a line new
Vaes whatever and you fire up a dev
server as you write a descriptor those
changes will appear as soon as you save
that descriptor file which makes it very
quick to write a quick query and see if
that query returns the data that you
expect you don't have to do all of this
data plumbing get the database together
all that stuff just start up get into
descriptor write a query and see the
results so this is pretty great I'm
feeling pretty good about this right now
but let's just take a step back now why
did I really want vase here when I have
pedestal and I could do whatever I want
with pedestal vase enables services to
be disposable inventory in less than
five minutes we just made a blog service
I could easily throw that blog service
away and write a new one in another five
minutes I'm not attached to it it can be
evolved independently I could go and
evolve the data model and another
descriptor if I wanted to and merge that
in so Vaes allows these these disk ode
these services to be disposable
inventory but it's also important to
remember what's underneath of these
these descriptors it's sitting on top of
pedestal and that ensures that I can
move these services to any platform that
I need to I could always drop down and
extend rich functionality through
pedestal
that's totally open here remember these
action literals those are just
interceptors so anything that you can do
in an interceptor you can do inside the
face and we're not done we've been
working on a lot of exciting pieces
so for pedestals specifically we've been
porting the Interceptor chain and the
logging and the metrics over to closure
script that's exciting for a couple of
different reasons as it will play out
over these next bullet points internally
at cognate X we have pedestal Kafka an
intercept or interceptor chainé chainé
provider specifically for connecting
pedestal to Kafka and we also have
pedestal views generic templating that
can be parameterize by the template
engine so you know it's not married to
any engine that's great for the obvious
templating case which is HTML but it
could also template database lots
so you want to structure all of your
data payloads in ones very specific way
well we have pedestal views and pedestal
views has an action literal inside of it
which means that inside of my vase
descriptors I can do full data
templating as well whether that's HTML
or just payloads for vase we've been
looking at various descriptor formats we
saw sort of the lowest level format you
could ever write in the data itself the
data representation of a service but you
might imagine that you create shorthand
descriptors or shorthand formats that do
more work for you you know for humans
that have better error messages or
whatever so we've been exploring that in
face we've also been running vase on AWS
lambda so this is particularly exciting
you know imagine that I write a lot of
vase action literals
for various services that exist on AWS
all of our programming languages they've
been structured for programming on a
single machine
there's threads there's cores there's
functions and the moment that you try to
go up a level
you know AWS lambdas s3 Kinesis sqs
queues okay well now that's humans
plugging all the parts together but the
lesson here is you know let your tools
do that hard work for you and so we've
been proving out that with Vaes we can
write action literals to allow you to
program at a higher level to effectively
create a programming language for the
cloud so that's particularly exciting
and we have Bay's solar adding another
data store beyond atomic interface so
there's a pretty cool choice it allows
you to do recommendations free text
search but also things like geospatial
indexing so if you have a data that you
know maybe doesn't fit so well with day
Tomic or you want to do search of
recommendation applications
well now you can quickly spin these up
in base as well and the last piece that
we've been exploring is automated
simulation testing
given the description of a service so if
you start moving into the cloud if you
start building distributed services you
very quickly want to be able to write a
test that is the composition of those
small services but there is yet to be a
testing tool that very easily allows you
to say I want to test the combination of
these 5 or 20 services that's sort of a
tough problem but when all of your
services are described in data it's very
easy to look at that data and come up
with the operational space of composing
those services together so we can do
this automated simulation testing nearly
for free if you write it in a descriptor
format all right so you know that's a
lot but think about the fundamental
pieces they're just small interceptors
and they can be composed together so go
out you know write some interceptors
write some vase literals to make your
tools do the hard work for you but above
all don't waste your time battling
incidental complexities use postal in
vase and deliver value faster thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>