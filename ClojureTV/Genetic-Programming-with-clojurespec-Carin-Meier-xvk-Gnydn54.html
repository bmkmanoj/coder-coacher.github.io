<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Genetic Programming with clojure.spec - Carin Meier | Coder Coacher - Coaching Coders</title><meta content="Genetic Programming with clojure.spec - Carin Meier - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Genetic Programming with clojure.spec - Carin Meier</b></h2><h5 class="post__date">2016-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xvk-Gnydn54" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so yeah I'm Karen Meier I'm
also known as Giga squid on the
Internet's and yeah we're gonna talk
about some fun stuff today so yeah let's
just get straight into it whoops first
I'm so excited to be here this is just
such a beautiful city and I love this
dog too so I love being around all these
uh all you smart people everybody I met
has been super nice and super friendly
and all the talks have just been great I
went to bed last night with all these
ideas floating around my head and I got
more great ideas I'm still gonna be
digesting for a few weeks here to come
so what did you see first rate by hands
who saw the duck first yeah okay rabbit
alright this is the famous duck rabbit
all right same thing boo saw two faces
first yeah okay and who saw a base all
right thing I like about both of those
illusions is it's all about perspective
it's all about seeing things in
different different way you can look at
it one way and see the rabbit and you
look at the other way and you can see
the duck and to me this is kind of like
when I was a Java developer many years
ago when I looked around everything was
an object that's all I could see when I
sat out to model a problem and find a
solution it was always always in objects
and that changed one day I sort of like
he my box
and I found closure and the thing that
it did to me is it like opened up my
world it gave me a totally different way
of
seeing problems seeing solutions and
modeling the world in a functional way
it's like I could finally see the duck
and I love that I love that mineshaft I
and I remembered that feeling later on
when I was reading this article by David
Mumford he's a famous mathematician and
articles called math and beauty and
brain error areas and it's really
interesting the article talked about how
people see beauty and in particular how
mathematicians see beauty and how they
can look at certain equations and it
appeals to them and other equations you
know maybe not so much and what is that
and can you see that in the brain and
actually put these mathematicians and
MRI machines and scan them as they were
reading equations and they found out
what areas of the brain lit up and from
this David Mumford because he's a
mathematician I decided to categorize
what people were attracted to what
excited them about mathematics and he
came up with these four tribes of
mathematicians based on kind of what
they found beautiful so I'm gonna take
liberties today on that and translate it
to our profession to the four tribes of
programmers so these are the same
categories as David Mumford's
we have explorers alchemists wrestlers
and detectives so the first tribe they
explorers
so these are the programmers who really
get excited about discovering like a new
algorithm or a tool or a library or like
a language and there's subcategories of
these tribes they're the gem collectors
these are the people that actually go
out there
and they bring these beautiful things
back to share with the rest of us
oops I went to won't good for it and
then there are the mappers which in
another category and these are people
that actually go out there and they
describe and chart the new lands so we
can all follow so this is a very
important tribe then there's another
tribe called alchemists so these are
people that get excited about finding
connections between different things so
it could be totally different fields
from programming it could be like the
biological world and bringing it into
programming basically you pour one into
another and maybe have like a really
good explosion and then there are the
wrestlers now these are the people that
really they do things on a big scale
they get attracted to speed big data
you know stuff that frankly makes people
like me want to faint in the final tribe
it's kind of opposite these are the
people that focus in they really find
enjoyment and diving into the deep deep
detailed aspects of programming the
really tough problems and understanding
things at like a 200 times magnification
so of course you don't need to belong to
my thing isgetting you don't need to
belong to just one you can belong to
many or you know a couple but for me I
find that I resonate most with the
alchemist that's kind of what gets me
excited the combining things in fact I'm
a really big integration proponent when
I look around I tried to take ideas and
integrate them back into what I'm doing
all the time and then there's this quote
that I really like from the leader of
the cognitive neuroscience field
he actually came up with the split brain
theory and he in part he did that with
help of his colleagues in totally
different fields he would have come up
with this idea this fundamental idea
without that help and he said take risks
at the edge of edges scholarship and
seek integration most forays won't yield
anything but some certainly well so with
that inspiration we're gonna do some
alchemy and we're gonna combine closure
spec today with two things that I'm
interested in and the first is closure
spec and genetic programming so first a
word about why closure spec well a lot
of you are familiar with it it allows
you to describe data it allows you to
validate data and very interestingly
allows you to generate data so just a
brief overview of spec and describing
data you can describe and say foo is an
integer you would require the closure
spec library and you can s Steff foo as
an int a validation you can ask is this
data a valid foo as using s valid is one
a valid foo
yes is hai a valid foo no and then you
can furthermore ask why not why isn't it
valid and using s explained you can get
back well hi fellow suspect because it
was supposed to be an int so it tells
you what went wrong and you can also
have a specs give you example data using
exercise and it'll turn you back a the
value and the conformed value of foo
this case is negative one
okay so now the overview of spec is done
now we can talk about evolution
evolution and genetic programming so
what is genetic programming it's all
about like evolving these creatures
things through breeding a mutation but
the cool thing is with genetic
programming the creatures are actually
programs themselves we're creating
programs so in our experiment today
given some data this is going to be like
a closure vector of data we're going to
use genetic programming to evolve a spec
program to perfectly describe it in fact
we can say that these spec creatures
that were going to evolve eat data this
is how they are fit so let's take a look
at how we're gonna represent our spec
creatures we're just gonna use a hash
map and one key is gonna be the program
itself and the other key is going to be
the score so how do we score a creature
well it's how much of the data the spec
can consume without errors
that's how successfully it can eat the
data so let's look at a perfect score
we've got a spec here that let me see
it's a sequence and the first spot it's
got an int the second spot that's got a
string and we're asking it to explain
any errors in data form from the vector
one and hi it's a perfect fit nothing to
explain what about a not so perfect
score what if we pass that same spec a 1
and a true well it's gonna be able to
eat the first bit but it's not gonna be
able to eat the second bit and in the
data form of the error the port of it is
it tells us where it says in position 1
so we can use that information so a
perfect match will give it a score of
100 and anything less is how far in the
sequence that it got as a valid part
okay so now we have to randomly create
our creatures and this is fun with
closure because code is data so making
programs is a pretty fun so we're gonna
start out and give it some boundaries
right we just don't want like randomly
generate anything we're gonna give it
our data is gonna be a vector so
everything of our specs are gonna start
with s cat and we're only gonna louse
certain predicates we're only gonna
allow integers strings boolean's even
and odd but we're also going to allow
some composition we're gonna allow S
Plus which is a regex for one or more
and a star which is regex for 0 more and
and or or as compositions and we're also
gonna have some probability knobs of how
this is created so there's gonna be a
small probability that there's gonna be
like a run or that's gonna nest actually
I turn that knob down really to zero
because I got kind of messy but and max
depth and an and or or probability okay
so let's go ahead and create a random
creature so this is the point you know
like those cooking shows or they're like
and in my refrigerator I already have a
prepared so I already have a prepared
function called make random cat so we're
gonna see the result of this here make
random cat is gonna take in a parameter
of three how many positions that I want
to create the spec with so this is the
random spec that it created the first
position is an integer and it's odd the
second position is an integer and the
third position is it's a boolean okay
now we can create one of these which
means we can create many we can make an
initial population of these so this is a
function for the initial population it
takes in how much of the population size
you want and the max cat length we're
gonna make it variable because you can
have runs so yeah so it just makes a
whole bunch of those great so now we
have a whole bunch of them how do we get
them to evolve we have to get them to
change somehow if we're going to do this
whole evolution thing well the first way
is with mutation and some mutations are
good some mutations are not so good
but it's got to change so enable to
mutate one of our creatures
you use the fact again that code is data
and we're gonna go ahead and take a walk
down the creatures expressions in the
programs and we're gonna choose a
program segment with some probability
and then we're gonna swap out that piece
for a randomly generated segment so
again I go to my refrigerator and pull
out my mutate function so we're mutating
a closure spec creature here and let's
see the first fit is an integer and so
odd and second bit is an integer and
then you mutated it and it's got like an
or wrapped around there that doesn't
even really make sense some mutations
aren't great but yes they do change it
so what about breeding this is an
interesting bit
it's called crossover and you can in
crossover take two of these creatures
and swap a node from one creature to the
other creature and again code is data so
we're going to walk a walk the first
creatures expressions and at some random
probability we're gonna select that
crossover node and then take it to the
second creature and randomly insert it
there
so again refrigerator crossover function
it's gonna take two spec creatures this
time let's take a look at the first one
yeah it's very familiar it's got the and
integer odd and the second spot it's got
an integer and then the second creature
has a string in the first spot and a
boolean in the second spot so looking
between the two of them the result is
kind of a mix between the two the first
one has s NR Jerrod and the second spot
has a boolean so it's like a mix of the
first two so that worked good so what
can we do now we can create random
creatures we can score these creatures
we can change the creatures with
mutation and we can breed creatures with
other creatures we just really need a
process to like tie this all together
right so let's go ahead and do that here
is going to be our process
of evolution first we create our initial
population of how many ever many that we
want say like 100 and of course we're
gonna have our test data like our vector
of data that we're gonna want them to
devolve to so we're gonna do our initial
ranking see how valid they are on that
and then we're gonna take the top two
best scored ones of that initial
population and we're gonna carry them
over unaltered to the next generation
this is a process called as a lead ism
and you don't want too much of it but it
does it is useful in this process then
we're gonna create the next generation
by selecting creatures for this
crossover a mutation and then we're just
gonna repeat repeat the process over and
over again but wait I said you select
the creatures so how do you actually go
about selecting them that is like a
really good question I started looking
into this and it's pretty deep like
people do they're like PhD thesis is on
this and there's tons of methods but
we're just gonna use one we're gonna use
of this thing called tournament
selection although there are many other
ways to do it as well so what is
tournament selection
well it's process where you're gonna go
ahead and we're going to pick and
creatures from the whole population just
randomly and among those you're gonna
pick the best scored one the nice thing
about this is it helps promote a
diversity and the way that you're
selecting the creatures to drive your
evolution that makes it evolved properly
okay we're ready we're ready to kind of
make this final function that's gonna
have some inputs it's gonna how you take
a population size how many generations
we want the tournament size and of
course our test data that's going to
drive the whole thing and we're gonna do
this process over and over again until
we find a perfect fit or we've gone too
long it's got the max generations in the
end the perfect fit is just a score of a
creature that's
100 all right moment of truth
ready all right we're gonna evolve we're
gonna Duffy's creature specs from a
evolved function that is population
sight above a hundred or a hundred
generations a tournament size of seven
and we want to generate a spec that is a
match for a string high true five ten in
a string loop okay and then we call
perfect fit to see if we've got a
perfect fit from future specs and we do
it actually generated this so yeah in
the first spot a string high as a match
yeah second spot boolean yeah that's a
match s an integer odd yeah that matches
five ten is indeed an integer and four
is a string score of a hundred we did it
but wait but wait our generated creature
is a spec and one of these things that
specs can do is they in turn can
generate data but so if we use exercise
we could take that perfect fit for the
creatures pull the throw program off of
it and a valid and actually get some
more data from it and then we could use
that generated data to generate more
specs and then we could just keep going
around and round like this and I figure
this out and I was like whoa that's kind
of crazy so I I didn't do this in this
talk but you're welcome to go and do
this
so Genetic Programming summary real
quick what do we do we started with a
way to generate random creatures we had
a way to evaluate their fitness and then
we had a way to change them right for
the next generations
using mutations and crossovers and then
we tie this whole thing together in a
process which involved creating an
initial population right getting your
initial ranking so you had something to
start with and then using that process
over gravity on the tournament selection
to create your next generations and the
thing that I didn't mention that I
actually put in my real code is every
now and then I would just have like a
totally random creature pop up you know
and that's good that's a good thing
and we just did some alchemy there's a
lot of fun so closure spec so far is
like really cool you know what other
things can we do with it
for example you know I'm kind of
interested in AI could we use it to make
code smarter like if it had an error
like a program had an error it could
recover and like heal itself you know it
could it could rise above the mistakes
that we make as a humble programmer and
kind of make itself better you know
self-healing code that would be like
really cool from an alchemy standpoint
you know maybe it would be a little like
trying to get gold
so our next alchemy experiment is going
to be closure spec and self-healing code
so to go down this path of self-healing
code we're gonna need some ingredients
right so papers again are a great source
of inspiration and knowledge so we're
gonna take a look at this paper called
towards design for self-healing and take
from it some main ingredients that we're
going to need on this adventure
well it's kind of straightforward once
you think about it but I mean the first
thing you're gonna need is fail your
detection because you can't fix a
problem if you don't know that it
happens in the first place and then once
you figured out that you did have a
problem you're gonna have to have some
way of diagnosing it you're gonna have
to have some way of figuring out exactly
what went wrong so you can have like
some hope to fix the problem and then
once you've actually figured out once
what's wrong then you're gonna have to
have this healing process to actually
find the solution and apply it and after
you do that you have to have some way of
checking that you did in fact heal it
and have the right solution so there's
going to be some sort of validation or
testing involved in that great so now we
have the ingredients we just need to
figure out how to self heal right no big
deal we're gonna use something called
horizontal donor code transfer has
anybody heard of this crazy huh okay
cool
MIT actually developed a system called
code phage that was based on this
process so what is it this is another
thing I like about it it's like inspired
from the biological world again it's
this alchemy of bringing stuff over from
nature into our computer programming so
this is a process that kind of mimics in
a way the horizontal gene transfer of
genetic material between different
organisms so in it they use this process
called horizontal code transfer by
fixing software errors on the fly by
transferring the correct code from a
donor application
so yeah I read that cool we should try
to do that enclosure right and we have a
lot of things going for us enclosure
that can make this possible
I mean closure itself is ideal for AI
and you know has these macros that let
code modify itself and then closure spec
is interesting it adds like another
level of stuff it actually gives code
then the ability to describe itself like
what it's doing and then not only
describe itself but it can share these
descriptions with other programs through
the registry and maybe even you know
external even files coming into the
registry and also it gives code the
ability to say you know this is some
example data that it can generate from
the specs as well so here is our
self-healing code experiment we are
gonna write a small report program it's
just like a function it's a function
called report it's gonna have be made up
of three helper functions inner and it's
just gonna do something really simple
it's gonna take in a list of earnings
and it's going to output the average in
a string format in fact here it is
here's a function report to earnings
it's going to clean the bad data because
you might have some strings or something
in there it's gonna count the average
and then finally it's gonna go ahead and
display the report but there is a divide
by zero error waiting there and that
Klee and the calc a bridge and this is
what's going to drive our healing
process so our goal if we're ready to
accept the mission is when that divided
by zero error happens we're going to use
closure spec to find a matching
replacement function from a set of donor
candidates and heal the function
okay so first we're gonna need a little
setup you know we got a spec some stuff
out so we can have like a setup so again
here's our report function let's just
starts pecking out the functions first
clean bad data so it's gonna take in a
vector of anything and then it's gonna
clean out anything that's not an integer
really really simple so the earnings is
going to be a vector and we're gonna
spec that out with an S def earnings and
it's going to be a collection of
anything and we're going to spec out the
output the output is going to be a
collection of numbers because we've
cleaned out everything that isn't a
number but then we're gonna do a little
kind of tricky thing we're gonna put a
custom generator in the spec that
anytime we ask it for example data it's
going to just return back the vector 1 2
3 4 5 and I'm gonna explain why later
but some of you might guess so
I'm an example of running the function
with specs clean bad data you just have
1 2 cat 3 and it's gonna filter out the
string if we call exercise on it it's
just going to return back that vector 1
2 3 4 5 that we told it to return us
with the custom generator ok so now we
get to the more interesting part we're
going to spec that calc average function
that's gonna have that vital flaw fatal
flaw and so you know it's I'm sure you
can see here it gets earnings deploying
you saw up the earnings divided by the
count of earnings but earnings could be
like zero so we're gonna spec out the
average it's going to be a number we're
gonna spec out the function Kalka it's
gonna take in as a args of clean earn in
earnings and as the return value it's
gonna give back the average which is a
number final thing the final helpful
function display report is pretty easy
the report format is going to be spectat
as a string the actual function itself
is just taking the average and you know
showing it as a string
averages and then we can spec out the
display report function with the args
average and the return report format all
right so that all it leaves us to do is
to spec out that final report function
itself and again we're taking in the
earnings and returning back there a port
function port format sorry all right so
we're ready for like a test drive we
call report with a vector of numbers and
it gives us back the string the average
is three and if we call with the empty
vector it does indeed it's gonna give us
back that divided by zero error
okay so we're set up now we're ready now
we need our donor candidates right so
we're gonna put the donor candidates in
a separate namespace and there are
functions are there gonna be all specs
out some are gonna match but some are
not gonna match so we're gonna have to
have some logic to go through and figure
out which ones are a good match I'm not
gonna show you the specs for all that
but I'll tell you what's in our donor
candidate functions we have this thing
called bad Cal kaverin it's gonna match
a spec but it's gonna give the wrong
answer the wrong value we have bad calc
average - it's actually good value but
it's the wrong type it's gonna return
back it is a string format and then
we're gonna have like an ad or function
that's like totally totally not even
close but in that we're also gonna have
a good match and it's gonna be called a
function call better Cal cabbage and
it's gonna be the one that actually has
the check to see if the earnings are
empty and if so it's going to return
back a zero and the specs for the inputs
and outputs are going to actually match
okay so we have the setup and we have
the donor candidates we just need the
process right we just need to like tie
it all together
we need the self-healing process so this
is what we're gonna do we're gonna try
the report function if we get an error
we're gonna catch any exceptions
and then this parts a little gross but
we're gonna do it anyway we're gonna
look through the stack trace and we're
gonna find the failing function name
it's an experiment we can do this and
we're going to retrieve the failing
function spec from the global spec
registry because if we know the spec
ssin the functions name we can go get
the spec out and we have information now
about the function and with that
information from the function we can
look for potential replacements in the
donor candidates but we're going to
check to make sure that it's a good
placement first so one of the things
we're gonna do is we're going to check
the original function and the donor
effect and the donor candidates args for
their spec and make sure they're both
valid for that failing input we're also
going to do the same exact thing for the
return of the spec because we want to
make sure that there are both valid for
that failing input as well and then
we're also gonna do some validation
right we're gonna call that spec
exercise with the original function and
get that seed value you remember back
it's we just said that it was going to
be that one two three four five actor
and we're going to check that the
functions result on the keynote
functions result is the same as when we
called it with the original function so
some validation that it's it's actually
gonna work for that seed value and if we
find a match that's great what we're
gonna do is we're going to redefine that
failing function is a new function and
then we'll just call the whole
expression again and get the result back
and the nice thing is it's gonna be
healed for the next time round two and
we'll just return the result all right
so let's go ahead and we're going to
code it up with a function called with
healing and again I'm gonna go to my
refrigerator and then pull out the
function so we have this it's in the
healing namespace it's called with
healing we're gonna wrap it around our
report function and we're gonna call it
with this vector you know went to view
for five and a string a and B and no
problems right the average is three
now the big test rate we call the same
thing with that empty vector that's
gonna drive our divided by zero error
and the first thing it's gonna do is
it's gonna look for a placement it's
going to retrieve that respect
information from the function okay so it
knows all about its args and it knows
all about its return value and now it's
gonna go check candidates it's gonna
check the candidate it's a better calc
average out or bad cow average and bad
Cal coverage - and see what it can find
about it it found the candidate better
calc average so now it's doing some
comparisons it does the comparison of
the args and the return value it
compares the seed that the result is the
same it's a good match so it replaces it
calls a function again and returns back
our value it healed itself and the nice
thing is is we don't have to go through
that hole next time because it healed
itself for subsequent times - I'll call
it again and you just get back the
average is zero because of the functions
been replaced success so yeah so let's
just have like a quick summary of what
we did there and talk about it for a
minute so what we did was really simple
it was a really simple example so we
didn't actually do any validation of the
the functions of the specs that you can
actually you know define relationships
between the inputs and the outputs you
know that might have been like a really
useful level of validation to go in and
- and we also only checked one seed
value from that exercise for validation
so that was like a good spot check but
the the generative nature of it there's
nothing that stops us we could have like
done like ten a hundred a thousand
however many we wanted to get better
confidence
our function was healed also and this is
the reason that I put the custom
generator in there we neglected to use
the built-in features of spec that can
do generative testing and actually check
functions and spec actually if we had
used check or even some of the
generative exercise it would have found
the divide by zero error before we
actually even did that so that's an
important aspect of spec so yeah I think
in this kind of my experiments
and playing around with the spec I
obviously think I mean it rocks it's
it's a really great tool but even more I
just think it this is adding another
dimension that we all have yet to
explore with the generative nature of it
the central registry and you know the
generative testing as well the property
testing but I think it could be very
useful for all sorts of things and we're
just yet wrapping our heads around what
neat things that we can use it for and
this is one of things that I find really
really exciting about closure spec if
you're interested and playing around
yourself you can use it as a launching
point self-healing is out there on my
gigas grid repo as well as the Genetic
Programming with spec so you're welcome
to take it in and play with it but yeah
taking just another step back of the
whole process again I just want to
reiterate that I think we've just really
only scratched a surface on how close
your spec can be used and during this
conference I I you know I've been
surprised on really interesting ways
people have already started you spec and
I think there's many men
more avenues and fields that we can
combine it with and use it so yes to all
my fellow explorers alchemists wrestlers
and detectives closure spec has indeed
has really opened the door wide for
exploration for wrestling for detectives
for mappers yeah so my challenge to you
and I love getting all these smart
people in one room you know what can you
do with closure spec combine it with and
you know make a win so that's it thank
you
I think I do have a few minutes for
questions okay yeah so I can take some
questions I guess if you have a question
oh you have a microphone brilliant or
you can catch me afterwards if you don't
that's fine too thank you in your
example of the self-healing how would
you have stopped the healing function
from choosing bad average to or whatever
it was called that had the right spec
input the right spec output but
generated the wrong number
so in the if I understand the question
right it's in the self-healing sample
yeah how do you make sure that you chose
the right donor candidate function yeah
yeah so there is a few levels of
validation on that so we use closure
spec to make sure that the Specht inputs
matched once you ran the function to
make sure the spectra turns match and
then after that then you had the the C
value from the original function you
could run that through the function get
the result and then run that same seed
function through the new candidate
function and make sure that that matched
but if you're if you know the first ones
broken how do you know that that test is
a valid test to prove that the second
one does work so the second seed one had
if it's broken I mean the first one is
broken because it throws oh alright you
use the use the two the first one is
broken yeah it throws an exception yeah
how do you know they're not both broken
oh how do you know you're both back well
that's a good question yeah I guess you
would probably need to add some more
validation I didn't I didn't put that
one in there but there's possibility
they both could be broken yes thanks
first of all thank you Karen for now
awesome talk and I've got a question I
find this a quite obvious continuation
of your endeavors by combining the
genetic evolution of a program and South
feelings only for the case that you
don't find any donna function maybe you
can do some code level crossover and
breeding have you thought about like
going further than that directional is
just a total crazy idea yeah that's an
awesome idea and in fact someone emailed
me the other day about a possibility of
using closure spec to just generate like
spiking a function and then generating
the function itself from from the spec
and that's an interesting area I think I
think that you run into you know how
much how much do you get between you
know if you describe it well enough how
much is your program actually the
description or the implementation so you
kind of run into that line but yeah
that's a great idea and you know if any
of you have any ideas of playing around
I thought I think that'd be a really
interesting Avenue to take okay if
anybody wants
talk about anything or like bounce ideas
off me or like talk about crazy things
I'll be around I like doing that sort of
thing
so thank you again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>