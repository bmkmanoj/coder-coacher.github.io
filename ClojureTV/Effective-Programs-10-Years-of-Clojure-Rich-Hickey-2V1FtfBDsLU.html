<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Effective Programs - 10 Years of Clojure - Rich Hickey | Coder Coacher - Coaching Coders</title><meta content="Effective Programs - 10 Years of Clojure - Rich Hickey - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Effective Programs - 10 Years of Clojure - Rich Hickey</b></h2><h5 class="post__date">2017-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2V1FtfBDsLU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I feel like a broken record every time I
start these talks by thanking everybody
so I want to start this talk in a
different way by saying my son is
getting married today
in another state so right after I give
this talk I'm gonna hop on a plane go do
that I'll be back tomorrow morning so I
haven't disappeared I'm looking forward
to the follow-up talks and everything
else but I will be missing in action
briefly so now to be redundant thanks
everybody for coming ten years ago
closure was released and there's no
possible way I could have imagined this
you know I told my wife Steph I said if
a hundred people use this that would be
ridiculously outrageous and that's not
what happened
and what did happened is happiness is
interesting I don't think it's fully
understood by one today to talk about I
look back a little bit about the
motivations behind closure it's not like
when you come out with the programming
language you can you can tell that whole
story I think one because it's not good
marketing and two because if you really
want to be honest you probably don't
know it takes time to understand what
happened and why and what you really
were thinking and I won't pretend that I
had a grand plan that incorporated
everything that ended up becoming
closure it certainly involved a lot of
interaction with people in the community
but there is this closure is opinionated
this we hear this and I think it's
interesting to think about two aspects
of that one is in which ways is it and
what does it mean for a language to be
opinionated
I think in closures case people come to
it and they're like wow you know this is
forcing me everywhere I turn to do
something a certain way so and I think
that the nice way to say that is there's
only a few strongly supported idioms and
a lot of support for them so
if you use the stuff that comes with it
there's a whole story that supports your
efforts and if you want to fight against
that we don't do too much
Alex was asking me which glasses are the
right ones and neither is the answer but
but design is about making choices and
no there's a bunch of choices enclosure
in particular there's a big choice about
what to leave out and part of this talk
would be talking about what was left out
the other side of being opinionated is
you know how do you get opinionated I
mean it's not like I'm opinion of course
I'm opinionated and that comes from
experience when I started doing closure
in 2005 I had already been programming
for 18 years so I'd had it I was done I
was tired of it
but I had done some really interesting
things with the with you know the
languages of professional programmers
used at the time so primarily I was
working on scheduling systems in C++
these are scheduling systems for
broadcasters so radio stations use
scheduling systems to determine what
music they play and it's quite
sophisticated the way that works you
know you think about well over the
course of the day you don't want to
repeat the same song you actually have
to think about the people who you know
listen to the radio for one hour in the
morning and this other hour in the
afternoon when you create sort of an
alternate time dimension for every drive
time hour and things like that so as
multi-dimensional scheduling and we used
evolutionary program optimization to do
schedule optimization broadcast
automation is about playing audio and at
the time we were doing this playing
audio on computers was a hard thing it
required dedicated cards to do to the
DSP work I did work on audio
fingerprinting so we made systems that
sat in closets and listened to the radio
and and wrote down what they heard
and this was both used to attract
stations playlists and then eventually
detract advertising which is where the
money was for that which involved
figuring out how to effectively
fingerprint audio and scrub audio sort
of compare novelty to the past I worked
on yield management systems never know
what yield management is probably not so
what do hotels airlines and radio
stations have in common their inventory
disappears as time passes right you have
like oh I have a free room you know I've
got a slot in my schedule I've got a
seat on this airplane and then time
passes and nobody bought it and now you
don't so yield management is the science
and practice of trying to figure out how
to optimize the value of your inventory
as it disappears out from under you
and that's about looking at the past and
past sales and it's not simplistic so
for instance it's not an objective to
sell all over your inventory the
objective is to maximize the amount of
revenue get you get from it which means
not selling all of it in most cases that
was not written in C++ that was around
the time I discovered common lists which
was about eight years into that fifteen
years and there was no way the consumer
of this would use common lisp so I wrote
a common list program that wrote all the
yield management algorithms again out as
sequel store procedures and gave them
this database which was a program
eventually I got back to scheduling and
again wrote a new kind of scheduling
system in common list which again they
did not want to run in production and
then I rewrote it in C++ now at this
point I was an expert C++ user and
really loved C++ for some value of love
that involves no satisfaction but as
we'll see later I love the puzzle of C++
so I had to rewrite it in C++ and it
took you know four times as long to
rewrite it as it took to write it in the
first place it yielded five times as
much code and it was no faster and
that's when I knew I was doing it wrong
went on to help my friend Eric write the
new version of the National exit poll
system for the US and which also
involves an election projection system
we did that in you know a sort of
self-imposed functional style of c-sharp
and then you know around 2005 I started
doing closure and this machine listening
project at the same time and I had given
myself a two-year sabbatical to work on
these things not knowing which one would
go where and leaving myself free to do
whatever I thought was right so I had
zero commercial objectives zero
acceptance metrics I was trying to
please myself for two years just sort of
bought myself a break but along the way
during that period of time you know I
realized I would only have time to
finish one and I knew how to finish
closure and then you know machine
listening is a research topic I didn't
know if I was two years away or five
years away so closure was written in
Java and eventually you know the
libraries written in closure and the
Machine listening work involved building
an artificial cochlea and I did that in
a combination of Common Lisp and
Mathematica and C++ and in recent years
as I've dusted it off I've been able to
do it in closure and that's sort of the
most exciting thing you know I needed
these three languages before
to do this and now I only need closure
to do it and then I did the atomic which
was also close almost all of these
projects involved a database all
different kinds of databases from you
know
I say I'm databases a lot of sequel many
attempts but many integrations of RDF
databases are an essential part of
solving these kinds of problems it's
just this what we do how many people use
a database than what they do every day
how many people don't okay so this last
thing is not an acronym for a database
it's the it's there to remind me to tell
this anecdote so I used to go to the
lightweight languages workshop it was a
one day workshop held at MIT where
people working on small languages you
know either proprietary or just
domain-specific you know DARPA or
whatever would talk about their their
little languages and what they were
doing with little languages it was very
cool and very exciting we've got a bunch
of language geeks in the same room and
it was pizza afterwards so I remember I
would just go by myself or with my
friend and I'm not I was not part of the
community that did that they just let me
in but afterwards ahead pizza so I sat
down a pizza with two people I didn't
know and I still don't know their names
and it's good that I don't because I'm
gonna now disparage them they were both
computer language researchers and they
were talking also disparagingly about
their their associate who'd somehow
fallen in with databases and lost the
true way and and one of them sort of
sneeringly
whence the other and said when was the
last time you used the database it was
like I don't know that I've ever used
the database and like I searched oKed on
my pizza because theoretically they are
designing programming languages and yet
they're programming and they never use
databases I didn't know how that worked
it was part of the inspiration to do
closure because I mean people who don't
do database system write programming
languages
anybody can so you know there are
different kinds of programs and one of
the things I tried to capture on the
slide is to talk about what those kinds
of programs were that I was working on
and the word I came up with were
situated programs in other words you can
distinguish these kinds of programs that
sit in the world that are sort of
entangled with the world and they have a
bunch of characteristics one is they
execute for an extended period of time
it's not just like calculate this result
and spit it over there
it's not like a lambda function in AWS
these things run on an ongoing basis and
they're sort of wired up to the world
and most of these systems run
continuously 24/7 it's quite terrifying
to me that now these things which are 30
years old are almost definitely still
running 24/7 somewhere if they haven't
been replaced
so this first notion of extended periods
of time it means continuously as opposed
to just for a burst they almost always
deal with information by what were the
kinds of things I talked about
scheduling and scheduling you look at
what you've done in the past you look at
your research data what does your
audience tell you there they like or
they're interested in or what they're
burnt out on and you combine that
knowledge to make a schedule yield
management looks at the past sales and
sales related to particular periods of
time and facts about that and produces
pricing information the election system
looks at prior vote records
how do people vote before that is a big
indicator of how they're going to vote
again of course the algorithms behind
that are much more sophisticated but
it's in a simplified way you can say all
of these systems consumed information
and it was vital to them and some of
them produced information they track the
record of what they did and that's this
next point which is that most of these
systems have some sort of time extensive
memory that database isn't like an input
to the system that's you know fixed
it's something that gets added to as the
system runs so these systems are
remembering what they did and they're
doing it both for their own consumption
and for consumption by other programs
quite often and they deal with real
world irregularity this is the other
thing I think that's super critical at
you know in this situated programming
world it's never as elegant as you think
the real world and I talked about that
scheduling problem of you know there's
linear time somebody who listens all day
and there's somebody who listens just
while they're driving in the morning in
the afternoon and eight hours apart does
one set of people and then an hour later
there's another set of people in another
setting and you have to think about all
that time you come up with this elegant
notion of multi-dimensional time and be
like oh I'm totally good except on
Tuesday right why well in the US on
certain kinds of genres of radio there's
a thing called two for Tuesday right so
you've built this scheduling system and
the main purpose of the system is to
never play the same song twice in a row
or even pretty near when you played it
last and not even play the same artist
near when you played the artist so
they're all somebody's gonna say all you
do is play Elton John I hate this
station but on Tuesday it's a gimmick
two for Tuesday means every spot where
we play a song we're gonna play two
songs by that artist violating every
precious elegant rule you put in the
system and I've never had a real world
system that didn't have these kinds of
irregularities and where they weren't
important other aspects of situated
programs they rarely are sort of their
own little universe where they get to
decide how things are and they don't
need to interact with anyone else or
agree with anyone else almost all these
systems interacted with other systems
almost all of these systems interacted
with people somebody would sit there and
say start playing the song right now or
skip this song and we're like well I
scheduled that song and I balanced
everything around you playing it and now
you know DJ just said don't
do that the election projection system
has tons of screens for users to look at
things and cross tabulate things and
make decisions and beating all the
things you see on TV so people can
explain things to other people so people
and talking to people is an important
part of these programs they remain in
use for long periods of time these are
not throwaway programs like I said I
don't know that much of the software I
ever wrote has stopped being run by
somebody people are still using it and
they're also situated in a world that
changes so again your best laid plans
are there the day you first write it but
then the rules change
maybe there's three for Thursday's I
don't know but when that happens go
change everything to deal with it
another aspect of being situated and
it's one I think I've been thinking
about a lot more recently is being
situated in the in the software
environment and community you know your
program is rarely written from scratch
with all code that you wrote just for
the purpose of the program invariably
you're gonna pull in some libraries and
when you do you've situated yourself in
that library ecosystem and that's
another thing so when I talk about
situated programs and you look at the
programs I talked about having written
in my career one of them really sticks
out right what's that closure compilers
they're not like this they don't have a
fraction of these problems they take
some input right off the disk they get
to define the whole world right when you
write a language what do you do the
first thing what you do when you write a
language you get rid of any - for
Tuesday's right you just you can just
disallow it right you try to make the
most regular thing and then your
programming is just well now I have to
enforce the rules that I made up for
myself it's like wow what could be
easier than that and it really is a lot
simpler they don't generally use a
database although I think they probably
should they rarely talk over wires and
so compilers and theorem provers and
things like that are not like these
programs so the title is talk is
effective program and what is effective
mean it means producing the intended
result and I really want this word to
become important because I'm really
tired of the word correctness where
correctness means I don't know made the
type checker happy right that is nobody
none of my consumers of these programs
that I did professionally care about
that right they care the program works
for their definition of works on the
other hand I don't want this to be taken
as this is a recipe for hacking right
just like do anything that kind of works
so we have to talk about what works
means what does it mean to actually
accomplish the job of being being
effective and and that's where I want to
sort of reclaim the name programming or
at least make sure we have a broad
definition that incorporates languages
like closure and the approaches that it
takes because I think these problems
matter so what is programming about I'm
going to say for me programming is about
making computers effective in the world
and I mean effective in the same way we
were talking about people being
effective in the world either the
programs themselves are effective or
they're helping people be effective
right now how are we effective
well sometimes we're effective because
we calculate really well like maybe when
we're trying to compute trajectories for
missiles or something like that but
mostly not most of the areas of human
demur endeavor
we're effective because we have learned
from our experience and we can turn that
experience into predictive power whether
that's knowing not to step in a giant
hole or off a cliff or walk towards the
roaring lion or how to market to people
or what's the right approach to doing
this surgery or what's the right
diagnosis for this problem people are
affected because they learn and they
learn from experience and they leverage
that and so I'm gonna say being
effective is mostly not about competence
but it's about generating predictive
power from information and you've heard
me talk about information right it's
about facts it's about things that
happen right experience especially when
we start pulling this into the
programming world experience equals
information equals facts about things
that actually happen that's what that's
the raw material of success in the world
it is for people it should be for
programs that either support people or
replace people so they can do more
interesting things so I'll also say that
for me what is programming not about
it's not about itself programming is not
about proving theories about types being
consistent with your initial
propositions it's not that's an
interesting endeavor of its own
but it's not it's not what I've been
talking about it's not the things I've
done in my career it's not what
programming is for me and it's not why I
love programming I like to accomplish
things in the world
Bertrand Russell has a nice snarky
comment about that he's actually not
being snarky he wants to elevate
mathematics and say it's quite important
that mathematics be only about itself if
you start crossing the line right and
standing on stage and saying you know
safety type safety equals you know
heart-machine safety you're doing
mathematics wrong according to virtue
Russell and it's not just algorithms in
competition they're important but
they're a subset of what we do so don't
get me wrong I like logic right I've
written those scheduling systems I've
written those yield management
algorithms over written the data log
engine I like logic I like writing that
part of the system I usually get to work
on that part of the system that's really
cool
but even you know a theorem prover or
compiler you know eventually needs to
read something from the desk or spit
something back out print something so
there's some shim of something other
than the logic but in this world of
situated programs and the kinds of
programming that I have done and I think
that closure programmers do
that's a small part of the program
programs are dominated by information
processing unless they have you eyes in
which case there's this giant circle
around this where this looks like a dot
but I'm not gonna go there actually
because I don't do that part but the
information processing actually
dominates programs both in the effort
the irregularity is often there right
that's this information part that like
takes all the irregularity out of the
way so my date a lot good isn't gonna
like have an easy day because everything
is now perfect because I see a perfect
thing because somebody fixed it before
it got to me and I don't want to make
light of this I think this is super
critical right your best tiles coolest
you know search algorithm if they
couldn't get it to appear on a web page
and do something accessible when you
type you know something impressed enter
no one would care right this is where
the value proposition of algorithms gets
delivered it's super important but in my
experience while this is the ratio it
probably needs to be to solve the
problem this is the ratio it often is
and was in my experience in my work
actually this is also sort of bigger the
square would be more of a dot that the
information part of our programs is much
larger than it needs to be because the
programming languages we had then and
still have mostly are terrible at this
and we end up having to write a whole
ton of code to do this job because it's
just not something the designers of
those languages took on and of course
we're not done right we don't write
programs from scratch so we have to
start dealing with libraries when we do
that now we've started to cross out of
we get to define everything land right
now we have relationships and we have to
define how those we're gonna talk to
libraries and how they may talk to us
but mostly we talk to them so now
they're alliance right there's some
protocol of how do you talk to this
library and we're still not done right
because we said these situated programs
they involve databases now while the
information processing and the logic and
the libraries may have all shared a
programming language right or at least
you know in the JVM something like the
JVM a runtime now we're added
right now we have a database that's
clearly over there it's written in a
different language it's not co-located
in memory so there's a wire it has its
own view of the world and there's some
protocol for talking to it and
invariably whatever that protocol is we
want to fix it and why is that well it's
something I'm going to talk about later
called parochialism you know we've
adopted a view of the world our
programming language put upon us and
it's a misfit for the way the database
is thinking about things and rather than
say I wonder if we're wrong on our end
we're like oh no we got to fix that that
of that relational algebra you can't
possibly be a good idea okay but we're
still not done I said these programs
they're not third they don't sit by
themselves they talk to other programs
so now now we have three or more of
these things and now they may not be
written in the same programming language
right they all have their view of the
world they all have their idea of how
the logics should work they all have
their idea of how they want to talk to
libraries or use libraries and there's
more wires and more protocols and here
we don't get the database vendor or at
least giving us some wire protocol to
start with that will fix with ORM we
have to make up our own protocols and so
we do that and what do we end up with
JSON right it's not good but at least
now we have something so when I program
this is one program this is a program to
me this is gonna solve a problem and
like no subset of this is going to solve
the problem this is the first point you
start solving the problem but you're not
done with problems because it's not a
one-shot one time one moment one great
idea push the button ship it move on
kind of world visit every single aspect
of this mutates over time right the
rules change that the requirements
change
the network's change the computing power
changes the libraries that you're
consuming change hopefully the protocols
don't change but sometimes they do so we
have to deal with this over time and for
me effective programming is about doing
this over time well so you know I'm not
trying to say there's a right or wrong
way and like closure is right and
everything else is wrong right but it
should be apparent and maybe it isn't
because I think we all aspire to write
programming languages that are general
purpose
you could probably write you know with
your improvement closure actually I'm
sure you could but you certainly would
get a different language if your target
work compilers and their theorem provers
or your target word device drivers or
phone switches closures target is
information driven situated programs
right does not a catchy phrase for that
but I mean that's what I was doing all
my friends were doing that how many
people in this room are doing that yeah
so when you look at programming
languages you really should look at what
are they for
right there's no like inherent goodness
is like suitability constraints so
before I started closure
I drew this diagram which I did not that
would have been an amazing feat of
prescience but as I tried to pick apart
you know what was closer about because I
think there's no reason to write a new
programming language unless you're going
to try to take on some problems you
should look at what the problems are I
mean why was I unhappy as a programmer
after eighteen years and said if I can't
switch to something like common list I
am gonna switch careers why am I saying
that it's I'm saying it because I'm
frustrated with a bunch of limitations
in what I was usually and you can call
them problems and I'm going to call them
the problems of programming and I've
ordered them here I hope you can
but can you read it yeah okay I've
ordered them here in in terms of
severity and severity and you know
manifests itself in a couple of ways
most important cost right what's the
cost of getting this wrong right and at
the very top you have the domain
complexity about which you can do
nothing this is just the world it's as
complex as it is but the very next level
is the where we start programming right
we look at the world and say I've got an
idea about how this is and how it's
supposed to be and how you know my
program can be effective about
addressing it and the problem is if you
don't have a good idea about how the
world is or you can't map that well to a
solution everything downstream from that
is gonna fail there's no surviving this
misconception problem and the cost of
dealing with misconceptions is
incredibly high so then this is 10x a
full order of magnitude reduction in
severity before we get to the set of
problems I think are more in the domain
of what programming languages can help
with right and because you can read
these they're all gonna come up in a
second as I go through each one on its
own slide so I'm not gonna read them all
out right now but importantly I think
there's another break where we get to
trivial isms of problems in programming
like typos and just being inconsistent
like you what you thought you were gonna
have a list of strings and you put a
number in there that happens you know
people make those kinds of mistakes they
are pretty inexpensive so what were the
problems that closure took on there's
green ones and again I'll go through all
the green ones in a moment but I would
say amongst the ones in the middle I
don't think that closure tried to do
something different about resource
utilization then Java did sort of
adopted that runtime in its cost model
and I don't think that I mean I wanted
closure to be a good library language
but I didn't think about the library
ecosystem problems
as part of closure and you know my talk
last year about libraries implies that I
still think this is a big problem for
programs it's one of the ones that's
left right after you do closure in the
atomic you know let's left to fix and
the libraries the libraries are there
but not the inconsistency and typos not
so much I mean we know you can do that
in closure it's actually pretty good it
letting you make typos so fundamentally
what does closure about can we make
programs out of simpler stuff I mean
that's the problem after eighteen years
of using like C++ and Java you're
exhausted how many people have been
programming for eighteen years
or okay how many for more than twenty
years more than twenty-five okay fewer
than five all right so that is really
interesting to me and maybe an
indictment of closure as a beginners
language or maybe that closure is the
language for cranky tired old
programmers
and and you know what I
I would not be embarrassed if it was I'm
that's fine by me because because you
know I did make it for myself which i
think is an important thing to do trying
to solve other people's you know
problems and think you understand what
they are you know it's tricky so when I
discover common list having used C++ I
that I'm pretty sure the answer to this
first question is yeah absolutely and
can we do that with a lower cognitive
load I also think yes absolutely and
then the question is can I make a list
we can use instead of Java or C sharp
because you just heard my story and I
use common list a couple of times and
every time it got kicked out of
production or just rule that in
production really not kicked out it
didn't get a chance so I knew I had to
target a runtime that people would
accept so there are these meta problems
right you can try to take on some
programming problems but there are
always problems in getting a language
accepted I did not think closure would
get accepted really honestly but I knew
if I wanted my friend who thought I was
crazy even doing it like person's number
one other than myself to try it I'd have
to have a credible answer just the
acceptability problems and the power
problems because otherwise it's just not
practical it's like that's cool rich but
like we have work to do if we can't use
this professionally really it's it's
just a hobby
so we have acceptability I think that
goes to performance and for me I thought
it was also the deployment platform
there's a power challenge that you have
to deal with and that's about leverage
and I'll talk about that later
and also compatibility again that's part
of the acceptability but you know
closures ability to say it's just a Java
library kind of was big I mean how many
people snuck closure into their their
organizations to start with right okay
success
and then there are other things I
consider to be absolute non problems and
the first of these is the parentheses
right how many people and it's okay to
admit right everybody has a story how
many people thought the parentheses were
going to be a problem and now think that
was crazy thinking yeah which is fine I
think everybody goes for that everybody
looks at Lisbon's like this is cool but
I'm I'm gonna fix this part before I get
going before I start before I understand
the value proposition of it at all
I'm gonna fix this and that's just
something about programmers I'm not sure
exactly what but I don't believe this is
a problem and in fact when we get to the
middle this talk you'll see I think this
is the opposite of a problem this is the
core value proposition of closure and I
think things like par make it go away
whatever that is as a bad it's a
terrible idea and it's not good for
beginners to do that you know to try to
solve a problem that's that's a feature
the other thing I considered not a
problem is it being dynamic right I
worked in C++ you know we had a thing
that we said in C++ is that if it
compiles it will probably work right
like they say of Haskell and it was
equally true then as it is now but we
really did believe it we totally did and
it's it doesn't help it really does not
help for the big problems the top the
big wide ones okay
so problem number one on that list was
place oriented programming absolutely
this is the problem almost all the
programs I wrote lots of the things on
that list were multi-threaded programs
you know they're crazy hard in C++ just
impossible to get right when you adopt
the normal mutability approach immutable
objects so this is the number one self
inflicted programming problem it seemed
you know clear to me that just that the
answer was to make functional
programming and immutable data the
default idiom
so the challenge I had was were there
data structures that would be fast
enough to say we could swap this for
that and the objective I had the goal I
had was to get within 2 X 4 reads and
4x4 writes and I did a lot of work on
this this was actually the main research
work behind closure was about these
persistent data structures and
eventually I found you know I looked at
Okazaki stuff and you know the fully
functional approach and none of that
gets here and then they found Bagwell's
structures which were not persistent
but I realized could be made so and they
just have tremendously great
characteristics combining the
persistence with the way they're laid
out the way memory works they made it
they made this bar and I was able to get
my friend to try my programming language
and we you know we don't have this large
library of pure functions to support
this and you know immutable local
bindings basically if you fall into
closure your first turtle is not the
parentheses right it's this this
functional paradigm everything is gone
there's no immutable variables there's
no state there's no mutable collections
and everything else but there's a lot of
support right there's a big library you
just have to you know sort of learn the
idioms so I think this was
straightforward the critical thing
that's different about closure is by the
time I was doing closure the people who
invented this stuff had adopted a lot
more right I think most of the adherence
in the functional programming community
consider functional programming to be
about typed functional programming
statically typed functional programming
is functional programming and I don't
think so I think that this is a you know
this was clearly in the 80/20 rule and I
think that split here is more like 99 1
the value props are all on this side and
and I think closure users get a sense of
that they get a feel for that this is
the thing that makes you sleep at night
ok problem number two and this is the
most subtle problem and this is the
thing that annoys me the most about
statically type lying
is they are terrible at information so
let's look at what information is
inherently information is sparse it's
what you know it's what happened in the
world does the world fill out forms and
fill everything out for you all the
things you'd like to know no it doesn't
it doesn't and not ever is probably more
correct the other thing is what can you
know what are you allowed to know so
it's not good answers to that whatever
you want right it's open right what what
else is there what is there to know well
I mean what time is it right because
every second that goes by there's more
stuff to know more things happen more
facts more things happen in the universe
so information a crease it just keeps
accumulating what else do we know about
information we don't really have a good
way of grappling with it except by using
names when we deal with information as
people names are super important right
if I just say 47 now there's no
communication going on yeah we have to
connect it and then the other big thing
and this is this is the thing I struggle
with so often right I have a system I
made a class or a type about some piece
of data then over here I know a little
bit more data than that
do I make another thing that's like that
if I have derivation do I derive to make
that other thing what if I'm now in
another context and I know part of one
thing and part of another thing what's
the type of part of this and part of
that and then you know this is explosion
because these languages are doing this
wrong they don't have composable
information constructs so what is the
problem with programming in a way that's
compatible with information it's that we
elevate the containership of information
to become the semantic driver okay we
say this is a person
and a person has a name and a person has
an email and person has a social
security number and there's no semantics
for those three things except in the
context of the person class or type
whatever it is and and often depending
on the programming language the names
are either not there right if you got
these product types where it's like
person is string X string X int X string
extra accent explode explode product
type like a complete callous disregard
for people names human thinking it's
crazy or your programming language maybe
has names but they compile away right
they're not first class you can't use
them as arguments you can't use them as
lookup vectors right you can't use them
as functions themselves right
there's no compositional algebra in in
programming languages for information so
we're taking these constructs I think
we're there for other purposes we have
to use them because it's all we were
given and it's what's idiomatic right
take out a class take out you know it's
hype and do this thing but the most
important thing is that the aggregates
determine the semantics which is dead
wrong right if you fill out a form
nothing about the information you put on
that form is semantically dominated by
the form you happen to fill out it's a
collecting device it's not a semantic
device but it becomes so and what this
what happens is you get these giant sets
of concretions around information you
know people that write you know Java
libraries you look at the Java framework
it's cool it's relatively small and
everything's about sort of mechanical
things Java is good at mechanical things
will mechanisms but then you hand the
same language to the poor application
programmers who are trying to do this
information situated program problem and
that's all they've got and they take out
a class for like everything they need
every piece every small set of
information they have right how many
people have ever seen a Java library
with over 1500 classes
yeah everybody and this is my experience
my experience it doesn't matter what
language you're using if you have these
types you're gonna have and you're
dealing with information you're gonna
have a proliferation of non composable
types that each are a little
parochialism around some tiny piece of
data that doesn't compose and and I'm
really not happy with this you know in
programming literature the word
abstraction is used in two ways one way
is just like naming something isn't is
abstract
I disagree with that abstracting really
should be drawing from a set of
exemplars some essential thing right not
just naming something and what I think
is actually happening here is we're
getting not deed abstractions you're
getting data concretions right
relational algebra that's a data
abstraction datalog is a data
abstraction rdf is a data abstraction
your person class your product class
those are not data abstractions their
country shion's so you know we know in
practice courses just use maps what this
meant actually was closure didn't give
you anything else okay there were there
was nothing else to use you there were
no classes there weren't the thing to
say def type there weren't types there
wasn't algebraic data types or anything
like that there were these maps and
there was a huge library of functions to
support them there was syntactic support
for it so working with these associative
data structures was tangible well
supported functional high performance
activity and their generic what are we
doing closure if we have just some of
the information here and just some of
the information there and we need both
those things over there we say what's
the problem there's no problem I take
some information some information and I
merge them I hand it along if I need a
subset of that I take a subset of that I
call keys and you know select keys and I
get a subset I can combine anything that
I like there's an algebra Assoc
with associative data the names are
first class right keywords and symbols
are functions they're functions of
associative containers they know how to
look themselves up and they're reified
so you can tangibly flow them around
your program and say pick out these
three things without writing a program
that knows how to write Java or Haskell
pattern matching to find those three
things that they're they're independent
of the program language right there are
just arguments they're just pieces of
data but they have this they have this
capability and the other thing which I
think is a potential of closure
it's realized to varying degrees but the
the raw materials for doing this are
there is that we can associate the
semantics with the attributes and not
what the aggregates write because we
have fully-qualified symbols and
keywords and obviously spec is all about
that
all right Brill this and coupling this
is another thing it's just my personal
experience the static type systems yield
much more heavily coupled systems and
that a big part of that time aspect of
the final diagram of what problem we're
trying to solve is dominated by coupling
when you're trying to do maintenance my
flowing type information is a major
source of coupling in programs having
deist you know a pattern matching of a
structural representation in a hundred
places in your program is coupling right
like this stuff I'm seizing up when I
see that the sensibilities you get after
twenty years of programming you hate
coupling it's like the worst thing and
you smell it coming and you want no part
of it and this is a big problem the
other thing I think is more subtle but I
put it here because it lets you see this
is positional semantics don't scale
what's an example of positional
semantics argument lists right most
languages have enclosure has them too
right who wants to call a function with
17 arguments nope
there's one in every room
nobody does we all know it breaks down
where does it break down five six seven
at some point we are no longer happy but
if that's all you have right if you only
have product types they are going to
break down every time you hit that limit
all right how many people like going to
the doctor's office and filling out the
forms right don't you hate it you get
this big line sheet of paper that's
blank then you get the set of rules that
says put your social security number on
line 42 and your name on line 17 that's
how it works right that's how the world
works that's how we talk to other people
no it doesn't scale it's not what we do
we always put the labels right next to
the stuff and the labels matter but with
positional semantics we're saying no
they don't you know just remember the
third thing means this and the seventh
thing means that and types don't help
you right they don't really distinguish
this float explode explode explode
explode at a certain point that's not
telling you anything so you don't scale
but they it occurs in other places so we
have argument lists we have product
types where else parameterization right
who's who's seen a generic type with
more than seven type arguments or C and
C++ or Java yeah well you tend not to
see it in Java because people give up on
parameterization
right and what did they switch to spring
now I mean that's not a joke that's just
the fact right they switch they switch
to a more dynamic system for injection
right because parameterisation doesn't
scale and one of the reasons why it
doesn't scale is there are no labels on
these parameters they may get names by
convention but they're not properly
named when you want to reuse the type of
parameters you get to give them names
yeah just like in pattern-matching
that's terrible that's a terrible idea
and it does not scale so anywhere
parameters anywhere positionality is the
the only thing you've got you're
eventually gonna run out of steam you're
gonna run out of the ability to talk to
people or they're gonna run out of the
ability to understand what you're doing
so so I think types are an anti-pattern
for for program maintenance and for
extensibility and because they
introduced this coupling and it makes
programs harder to maintain and even
harder to understand in the first place
so closure is dynamically typed you do
not have this burden of proof you don't
have to prove that you know because I
made something here and somebody cares
about it over there every person in the
middle didn't you know mess with it you
know mostly they don't mess with it I
don't know we have what we're protecting
against but we can prove now that you
know there's still strings over there
the constructs are open right we much
prefer runtime PI morphism either by
multi methods or protocols to switch
statements pattern matching and things
like that the maps are open there need
to know what are we doing closure if we
don't know something we just leave it
out we don't know it like this so maybe
this maybe that I mean if you actually
parameterised the information system it
would be maybe everything right maybe
everything no longer is meaningful it
just isn't
and and and then nothing is of type
maybe something right if your social
security number as a string it's a
string you either know it or you don't
jamming those things to two things
together it makes no sense
it's not the type of the thing it may be
part of your front door protocol that
you may need it or not it's not the type
of the thing right so we the maps are
open we deal with them on a need-to-know
basis and you get into the habit of
propagating the rest
maybe you handed me more stuff should I
care
no the UPS comes truck comes and my TV
is on the truck do I care what else is
on the truck
no I don't I don't want to know but it's
okay that there's other stuff so the
other part was you know language model
complexity you know C++ is a very
complex language and so is Haskell and
so is Java and so this you know most of
them closure is very small it's not
quite scheme small but it's small
compared to the others and it's just you
know the basic lambda calculus kind of
thing with you know a mutable you know
functional core there are functions
there are values you can call functions
on values and get other values that's it
there's no hierarchy there's no primer
ization there's no you know existential
types and the execution model is another
tricky thing right we're getting to the
point even in Java where it gets harder
and harder to reason about the
performance of our programs right
because of resources and that's
unfortunate you know at least one of the
nice things about C was you know you
knew if your program krest it was your
problem and you just figure it out but
you knew what it was gonna take up and
RAM and you could calculate things and
it was quite tractable and that matters
to program programmers right programming
is not mathematics and mathematics you
can swap any isomorphism for any other
in programming you get fired for doing
that right it's different right
performance matters is part of
programming it's a big deal so making
this something at least I could say it's
like Java and blame them was fine but it
also meant that all the tooling helped
us write all the you know all the Java
tooling works on works for closure I
mean how many people use you know your
kit and profiles like that are close
that's pretty awesome
to be able to do that all right now
we're into the really nitty-gritty of
things I didn't like and therefore I
left out this type thing it's it goes
everywhere and the name I came up for it
is parochialism right this idea that I
have this language and you know it's got
this cool idea about how you should
think about things you should
think about things using algebraic data
types or you should think about things
using inheritance it yields this intense
parochialism right you start to have
representations of things manifestations
of representations of information that
they only make sense in the context of
this languages rules for things and they
don't combine with anybody else's ideas
right you smash against the database you
smash against the wire you smash against
this other programming language because
you've got this idiosyncratic local view
of how to think about things RDF did
this right and they did it because they
had this objective right they're trying
to accomplish something we want to be
able to merge data from different
sources we don't want the schemas to
dominate the semantics how many people
have ever gotten the same piece of mail
from the same company and been like what
is wrong with your databases dudes right
yeah what is wrong what's wrong is one
company bought another company right now
they're the same company they now have
these two databases in one database your
name is in the person thing and in
another database your knee is in the
person table and another database your
name is in the mailing list table right
who knows that mailing list table name
and person name are actually the same
piece of information nobody they have to
have meetings I mean this is a big
dollar this is a big ticket problem it's
not it's not a small it's not a laughing
matter
right these big companies have giant
jobs trying to merge these systems
because because table Pirozhki ality
it's the same as classes and algebraic
data types it's the same problem it's
not a different problem it's all like I
had this view of the world and on the
day I decided how the world is I decided
that names were parts of person and you
decide that names are parts of mailing
lists and now we need to fix this and
you know how a lot of those companies
fix it they introduce the third database
usually an RDF database as a Federation
point so they now can figure out these
two things are the same and eventually
they will stop sending you two pieces of
mail the same piece of mail twice right
so there's this subject-predicate object
and obviously you can see the influence
of this on day topic right but it goes
further right I would say that the more
elaborate your type system is the more
parochial your types are right the less
general they are the less transportable
they are the less understandable by
other systems they are the less reusable
they are the less flexible they are the
less amenable to putting over wires that
they are the less subject to generic
manipulation that they are right almost
every other language that deals with
types encourages this tyranny of the
container I talked about before we have
a choice enclosure I think people go
either way right there's two things one
is the container dominates the other is
just sort of the notion of context
dominating the meaning like because I
called it this in this context it means
that but we have the recipe and
enclosure for doing better than that
which you use name space qualified keys
with name space qualified keys
we now Khmers data and and know what
things mean regardless of the context in
which they're used and and anything
about this thwarts the composition I
talked about before and in particular
because we're pointed at this program
manipulating program ideas you'll see
later it makes this harder so closure
has names they're first class this is
you know stuff that was in Lisp it just
dominates more because they became the
accesses for the
associative datatypes and they were
fucked they are functions in and of
themselves keywords being functions is
sort of the big deal they don't
disappear they're not compiled the way
into offsets we can pass them around we
can write them down a user doesn't know
closure can actually type one into a
text file and save it and do something
meaningful with our program without
learning closure we have this namespace
qualification if you follow the
conventions which unfortunately a lot of
closure libraries are not yet doing of
this reverse domain name system which is
the same as Java's all closure names are
conflict free not only with other
closure names but with java names
that's a fantastically good idea and
it's similar to the idea in rdf of using
URIs for for names and aliases help
let's make this less burdensome and
we've done some more recently to do more
with that then there's this distribution
problem here's where I start saying
taking a language specific view of
program design is a terrible mistake
because you're in that little box you're
ignoring this big picture as soon as you
step back now you have this problem you
have to talk over wires how many people
use one you know remote object
technology well I'm really sorry
because it's brutal right it's very
brutal it's incredibly brittle and
fragile and complex and error-prone and
and specific how many people use that
kind of technology to talk to people not
in there not under their own employee no
it doesn't work that's how the internet
works right distributed objects spelled
right the Internet is about sending
plain data over wires and almost
everything that ever dealt with wires
only succeeded when it moved to this and
this is very successful why should we
program in a way that's all super
parochial if we only need to eventually
represent some subset of our portions
but some subset of our program may be a
subset we didn't know in advance over
wires if we program this way all the
time we program the inside of our
programs as let's pass around data
structures and then somebody says whoo I
wish I could put half of your program
across the wire or replicate it over six
machines what do we say enclosure that's
great I'll start shipping some even
across the socket and we're done
as opposed to I got to do everything
over so there were plenty of
inspirations and examples for me of this
runtime tangibility it's one of the
things that I really got excited about
when I learned common lists coming from
C++ small talking common lists are
languages that were obviously written by
people who were trying to write programs
for people these are not language
theoreticians that you can tell they
were writing they were writing gooeys
they were writing databases they were
locked writing logic programs and
languages also but there's a system
Sensibility that goes through small talk
and Common Lisp that's undeniable and
when you first discover them especially
if you discover them late as I did it's
it's stunning to see and I think it's a
tradition that's largely been lost in
academia I just don't see the same
people making system
and languages you know together it sort
of split apart and that's that's really
a shame because there's so much still
left to pilfer from these these
languages they were highly tangible
right they had reified environments all
the names you could see you could go
back and find the code the namespaces
were tangible you could load code at
runtime I mean one thing after another
after another right in the whole perlis
you know quip about you know any
sufficiently large C or C++ program you
know has a poorly implemented comma list
it's so true again spring right you
eventually as you get a larger system
that you want to maintain over time and
deal with all those complexities of you
know I showed before you want dynamism
you have to have it it's not like an
optional thing it's it's necessary but
what was particularly interesting for me
and implementing closure was how much
runtime tangibility and situated
sensibilities were in the JVM design the
JVM is actually a very dynamic thing as
much as Java looks like say c-sharp or
C++ the JVM you know it was written with
an idea of well we're gonna embed these
programs on set-top boxes and and
Network them and need to send code
around that you could update their
capabilities that's like it's situated
everywhere you turn and the runtime has
got a ton of excellent support for that
which makes it a great platform for
languages like closure and thank
goodness you know that the work that the
people did on self and it didn't die
that it actually got carried through
here not everything did but it's quite
important and it will be a sad day when
you know somebody says well let's just
replaced that JVM with you know some
static compilation technology and I'll
tell you targeting the JVM and and the
CLR it's plain the CLR is static
thinking and the JVM is dynamic thinking
so there are situated sensibilities in
all these the last problem on my initial
slide was concurrency and I think mostly
concurrency gets solved by being
functional
by default the other thing you need is
you need some way to some language for
dealing with state transitions and
that's the epical time model I'm not
gonna get into this again here but I've
given talks about this before so closure
has this and and it was a combination of
those things that let me say I think
have a reasonable answer for my friend
if he says how can I write a real
program with this I could say here's how
you can write a real program including a
multi-threaded program and not go crazy
so there's lots of stuff I wanted to
take from Lisp and you know I think I
talked about a lot of these it's dynamic
its small it had first class names it's
very tangible there's this code is data
and read print and I'll talk a little
bit more about that but there's the
repple and I think that still people are
like the repla school because I get to
try things and that's true but the
repple is much cooler than that it's
cooler than that because it's an acronym
it's cooler than that because read is
its own thing and what closure did by by
adding a richer set of data structures
is it made read print into a superpower
it wasn't just a convenience it isn't
just a way to interact with people it
isn't just a way to make it easy to
stream programs around or program
fragments around it's now like here's
your free wire protocol for real stuff
how many people ever sent Eden over a
wire yeah how many people like the fact
that like they don't need to think
that's a possibility they can just do it
and you know if they want to switch to
something else you can but it's it's a
huge deal eval obviously we know it lets
us go from data to code and that's the
source of macros but I think again
it's much bigger than than the
application to macros and finally this
print which is just the other direction
but let's Pat a bunch of things that
needed to be fixed in my opinion it was
built on concretions you know a lot of
the a lot of the design of more
abstractions and see lossless stuff like
that you know came after the
underpinnings the underpinnings didn't
take advantage of them so if you want if
you want polymorphism at the bottom
you have to retrofit it if you want
immutability at the core you know you
just need you need something different
you know from the ground up and that's
why closure was worth doing as opposed
to trying to do closure as a library for
condomless the lists were functional
kind of Mia mostly by convention but the
other data structures were not you had
to switch gears to go from you know a
social with lists who you know a proper
hash table and lists or crappy data
structures sorry they just are they're
very weak and there's no reason to use
them as a fundamental primitive for
programming I'll also packages and
interning were very complex there the
other part about closure that is
important is leverage no I'm running out
of time I'm gonna talk about that or
that so the Eden data model is not like
a small part of closure it's sort of the
heart of closure right it's the answer
to many of these problems it's tangible
it works over wires it's not
incompatible with the rest of the world
there's two other languages have maps
associative data structures and vectors
and strings and numbers and so it seems
like a happy you know lingua franca and
why shouldn't we use the lingua franca
in a program why should we have you know
a different a different language it's
actually not that much better and you
have to keep translating all right
here's the final thing Simon Paton Joe
it's an excellent series of talks listed
these advantages of types because this
is a big thing that's left out of
closure there's no types right they
guarantee the absence of certain kinds
of errors which is true and he would say
he does say this is the least benefit of
static typing they serve as a partial
machine check specification and partial
is the operative word here
it's very partial there are a design
language right they help you think you
could you have a framework in which you
can think about your problems they
support interactive development like
intellisense
but the biggest merit he says is in
software maintenance and I really
disagree with just a lot of this it's
not been my experience the biggest
errors are not caught by
type systems you need extensive testing
to do real-world effectiveness checking
names dominates semantics a to a list of
eight a list of a it means nothing it
tells you nothing if you take away the
word reverse you don't know anything you
really don't and to elevate this to sale
this is an important thing and we have
all these properties it's not true it
just isn't true there are thousands of
functions that take a list of a and
return a list of a what does that mean
it means nothing and checking it I mean
if you only had a list of A's where
you're gonna get something else to
return I mean obviously in return mr.
base unless you're you know getting
stuff from somewhere else and if your
functional you're not how many people
like you I'm out having below ever used
a UML diagram tool right it's not fun
right it's like no you can't connect
that to that oh no you have to use that
kind of arrow no you can't do this no
you can't it's terrible I'm regretful is
much better you draw whatever you want
what are you thinking about draw that
what's important write that down
that's how it should work right yes
intellisense is much helped by static
types and performance optimization which
you didn't list but I think this is one
of the biggest benefits we love that in
C++ and maintenance I think it's not
true I think that they've created
problems that they now use types to
solve oh i pattern match this thing 500
places and i want to add another thing
in the middle well thank goodness i have
types to find those 500 places but the
fact was that thing I added nobody
should have cared about except the new
code that consumed it and if I did that
a different way I wouldn't have changed
anything except the producer and the
consumer not everybody else who couldn't
possibly know about it right that's new
so I mean for young programmers I mean
if everybody's tired and old then this
doesn't matter anymore
but when I was young
when I was young I really you know when
you're young you've got lots of free
space
I used to say an empty head that's not
right you have a lot of free space
available and you can fill it with
whatever you like and these these type
systems they're quite fun right because
from a from a you know endorphin
standpoint solving puzzles and solving
problems is the same it's like gives you
the same rush the puzzle solving is
really cool but that's not what it
should be about I think that I think
that this kind of verification and
whatnot it's incredibly important but it
should be a la carte right depending on
what you need to do depending on the
amount of money you have to spend
depending on what you want to express
you should be able to pull different
kinds of verification technology off the
shelf and apply it it should not be
built-in right there's a diversity of
needs as a diversity of approaches to
doing it and diversity of costs in
addition I think to the extent these
tools can be pointed at the system level
problem and not some language
parochialism you get more bang for your
buck I have a Google view speck to speck
a wire protocol yeah there's gonna be a
lot more of that going on and I won't
talk much more about speck but the next
version will increase program ability so
finally information versus logic the
bottom line is where are we going in
programming right the fact is we
actually don't know how to drive a car
we can't explain how to drive a car we
can't explain how to play go we can't
and then therefore we can't apply
traditional logic to encoding that and
make a program that successfully does it
we just can't do it we're approaching
problems in programming now that we
don't know how to do we don't know how
to explain how to do like we know how to
drive a car but we don't know how to
explain how to drive a car and so we're
moving to these information trained
brains right deep learning and machine
learning statistical models and things
like that use information to drive a
model that's full of imprecision and and
and speculation but that is still
effective because of the amount of data
that was used
to train it at making decent decisions
even though it also couldn't explain
necessarily how it works these programs
though are going to need arms and legs
and eyes right when you train a big deep
learning network does it get its own
data does it does it do its own ETL no
right it doesn't do any of that when
it's made a decision about what to do
how is it gonna do it well when we get
to Skynet it won't be our problem
anymore
but for right now it is and I think it's
quite critical to be working in a
programming language that is itself
programmable that's amenable to
manipulation by other programs right
it'll be fun to use closure to write you
know to do brain building but it'll also
be useful to be able to use closure for
information manipulation and preparation
as well as to use closure programs and
program components as the targets of
action of these decision making things
in the end real-world safety is gonna
come from experience it's not going to
come from proof anybody who gets on
stage and makes some statement about
type systems yielding safe systems we're
safe means real world that is not that
is not true so this is what's really
interesting deep learning and
technologies like that are pointed above
the line above that that top 10x they're
pointed at the misconception problem
they say you know what you're right we
don't know how to play go we do not know
how to drive a car let's make a system
that could figure out how and learn it
because otherwise we're just going to
get it wrong so I'm going to emphasize
that we write programmable programs and
the closure is well suited to that we
have a generic way to nth information
and emphasis we have an Eric way to
compose arguments without adopting the
type system right it's hard enough to
drive a car if you have to understand
monads to your you know it's just not
going to work
a reified system is subject to dynamic
discovery and I think spec combined with
the rest of closure being reified is a
great way to make systems that other
systems can learn about and therefore
learn to use and of course we have the
same ability to enhance our programs
over time so I would encourage you all
to embrace the fact that closure is
different and don't be cowed by the the
proof people write it is it's not a
programming it's not a solved problem
okay logic should be your tool it
shouldn't be your master you shouldn't
be underneath the logic system you
should be applying a logic system when
it works out for you I'm encouraging you
to design at the system level right it's
not all about your programming language
we we all get infatuated our programming
languages but you know I'm actually
pretty skeptical about programming
languages being the key to program I
don't think they are they're a small
part of programming they're not you know
the driver of programming and embraced
these new opportunities is gonna be a
bunch of talks are in the conference
about deep learning and take advantage
of them
make programmable programs and solve
puzzles problems not puzzles so thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>