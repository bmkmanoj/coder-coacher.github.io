<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Paul deGrandis - Unlocking data-driven systems | Coder Coacher - Coaching Coders</title><meta content="Paul deGrandis - Unlocking data-driven systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Paul deGrandis - Unlocking data-driven systems</b></h2><h5 class="post__date">2014-11-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BNkYYYyfF48" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'd like to talk today about the merits
of data-driven systems how they're
realized in production systems and some
tools and techniques to aid in creating
data-driven systems and this is really a
hodgepodge of topics and themes that
stretch across a lot of previous talks
some of other conferences somewhat
previous conscious you know you know
those topics they're gonna be things
like dsls and preferring data over
functions over macros and we're gonna be
talking a lot about declarative systems
and declarative programming and and how
that declarative programming actually
gets realized in closure and to get
started I'd like to talk about the value
of values you know a lot of people have
previously talked about data all the
things but what they often describe are
the merits of programming with values
and I think those are good merits
they're certainly worth sharing and
they're definitely worth repeating again
and again and again but I want to talk
about something a little more I want to
talk about systems that are captured in
data entire systems that express their
components or their interactions or
their behaviors or maybe all of the
above in data and this is really a
spectrum right now and one it of the
spectrum we have systems that capture
absolutely nothing in data and maybe you
interact with those systems using
function calls or you know a DSL that's
backed by macros at the other end of the
spectrum our systems that are fully
declarative through data and you
interact with those systems using data
structures but the values in your
programming language and I want to
explore that spectrum I want to think
about the outcomes and the conclusions
we can make as we travel towards that
data driven side and you know mostly
this talk is really about what's next if
you're already programming with values
if you're on this path of programming
with values that path has to go
somewhere
certainly programming with values is not
the end of that path it's merely the
beginning and so you know what's next on
this path where else does this path
actually lead to and to motivate all
this stuff I'd like to talk specifically
about consumer reports now before I go
on I'd like to thank David roubini and
Jonah Benton for allowing me to explore
these topics and build the projects I'm
about to share with you today
they're fantastic individuals Consumer
Reports is an out
totally fantastic company there are
consumer reports employees here in the
crowd talk to them you know find out the
exciting things they're building the
cool tools they're using it will
definitely be worth your time you know
Consumer Reports is in this process of
transforming themselves into a digital
first consumer focused company now to
transition a lot of other companies are
trying to make right now as well you
know what does that really mean it's
sort of buzzword right well let me give
you an example winter is just around the
corner and for me that means a lot of
snow I live in New Hampshire and last
winter all I had was a shovel and it was
terrible and I'm pretty much done using
a shovel for the rest of my life
so this year I'm determined to get a
snow blower I will definitely have a
snow blower by next weekend you know so
maybe I go to my local hardware store
for me I think that's a Lowe's or Home
Depot or something like that you know
and I go to the snowblowers and in front
of me there are ten snow blowers and
they all roughly look the same right
they have the same general shape they
have the same general parts most of them
are even the same color you know so what
snow blower should I actually buy I have
no idea
well imagine I take out my smart phone
and I open up the Consumer Reports
application and now maybe I take a
picture of all the snow blowers all
right I scanned the barcode of all all
the snow blowers or maybe I just tell
the Consumer Reports app what store I'm
in and it happens to know all of the
inventory for that store you know and
then I you know I say what I'm
interested in and how often I'm going to
use then you know I live in New
Hampshire and that's a lot of snow and
all of a sudden Consumer Reports app
says hey this is the snow blower you
need to buy and guess what it's on sale
and go ahead and buy it all right that
is a digital first consumer focused kind
of application it's delivering immediate
value to me the consumer and it's using
all the assets that Consumer Reports has
to do that so this is the sort of
transition that they're going through in
order to build those kinds of
applications though we need to fuse
together a lot of streams of data and
some of that data you know you own and
some of the data you have to get from
remote resources that you don't own
right who here builds HTTP services just
to access data right in the world right
there's a lot of hands in the world of
this rich client application so much
work goes into building just these sort
of simple data services
and that's really what I'm gonna start
sharing with you today I want to share a
story with you about building three
projects around this theme about
building these kinds of applications and
the first project sort of shapes up and
gets started like this
Consumer Reports wants to allow mobile
and application developers to construct
these kinds of applications but they
have no knowledge of back-end systems
are you know the my new show or the
incidental complexities or the
technologies or the techniques to
actually build these back tent back-end
services nonetheless Consumer Reports
says they should be able to do this you
know as they're building this app they
should say oh oh you know in order to do
this I need this data source I need data
that looks this way I need to be able to
access it like this so they want to
construct these prototypes without
back-end experience they also want to
free their data they want to allow
different teams to evolve the data model
however they need to to build these
kinds of products to deliver this kind
of functionality you know in the world
of the relational DB you know maybe
there's a data architect or a DBA or
maybe a very small few of them and
they're sort of the gatekeepers of the
data and you can't go changing that data
model all willy-nilly without breaking
everybody's stuff right so Consumer
Reports recognizes this and they want to
move into a different direction a
direction where you can evolve that data
model they want to talk about producing
these kinds of prototypes in terms of
hours and not days or weeks and this
really speaks to you know rapidly
iterating rapidly experimenting and
getting immediate feedback finding that
immediate value in sort of continuing on
with that direction you know and when
Consumer Reports recognizes that systems
age and they evolve and they can do so
gracefully and they want to end up with
an architecture that can age and evolve
and do so gracefully while achieving all
these things and this is sort of how the
first project shapes up these are the
high level goals the dreams if you will
for building this product now let's go
up a layer of abstraction here let's
consider the hypernym this is a great
problem-solving technique right consider
the general case of glossing over all of
these details these are great goals to
target companies from the smallest start
up to the largest enterprise
target at least one of these four goals
like who doesn't want to develop stuff
in hours instead of days or weeks I
think that's everybody here right I'd
rather work only hours and not days or
weeks on something you know I would like
to evolve my data however I'd need to to
get the job done man if my job was doing
nothing but declarative programming and
expressing the semantics or the intent
of a service I would I would not have to
do any programming whatsoever I would
just sort of magically create services
all of the time all right so these are
good goals to target and so internalize
that you know put yourself in the
position of trying to build this problem
and how would you do it how would you
start to tackle this problem how might
you cut it up you know how might we
build a system that you know can
declaratively Express services or can
evolve the data and I really think we
should start thinking holistically about
problem domains consider all of the
goals together and how they play off of
each other
it's really more about the harmony here
a system is more than the sum of the
components it's about how how all of
those components will play off of each
other you know so how might we do this
how might we do this all together and
let's really question our nouns you know
as we're thinking through the design
space here and as the team was thinking
through the design space you know we
really started questioning our nouns
what do we really mean when we say
service what is a service what are the
properties of a service that the
behaviors the actions the quality
attributes what does it mean to be a
service and can we draw a box around
that can we constrain what it means to
be a service because if we can it's a
much easier problem to solve you know at
this stage we were really imagining our
ideal future we were spending a lot of
time in design imagining the ideal
future in the ideal future these
problems don't exist we don't even think
of them as problems because in the ideal
future we're just building systems like
this already so imagine that ideal
future figure out all of the parts that
are missing and build your way back that
was sort of the mentality we had so what
was the RI ideal future well we built
the service that holds other services
all right and we called it the container
service and those other services are
purely declarative described in data
using Eden they to describe the things
that you would expect services to
describe things like schema and routes
and you know a single service
description was actually versioned so
you know a service could describe
multiple versions of itself
we also constrained what it meant to be
a service for us a service could only do
five things as we looked at the general
case we realized all of these services
only do five things they respond with
static data they redirect to another URL
they query the database and they return
the results they transact data into the
database or they validate some data
payload you know so you might say to the
service is this a valid us mailing
address and the service would come back
and say yes it is or no it's not here
are the fields that are wrong and here's
why they're wrong you know so we
constraint a service to be that for this
project now in order to achieve this
vision we needed all subsystems to be
able to be described in data as well
that's sort of a requirement here so
pedestal and atomic were natural choices
for us pedestal is a set of web
libraries for building very robust very
fast and secure web services in its main
interaction point the route definition
is purely data they can be described
only using data so that was a natural
fit here we could just drop it right in
and use it and same thing with des Tomic
its main interaction points and in it
its major components are all data
described schema transactions queries
all data and so we use those
technologies in the master container
service you know took care of all the
incidental complexities about building
services it normalized all the response
formats so the response formats were
normalized across every service that
meant you know composing services
together was very natural it was very
fast to build these clients it also took
care of things like giving consistent
error handling across all services
basically every low-level detail about
building services was handled by the
master container the master container
also allowed for live-up certs
you could go ahead and evolve a single
service description and continue to up
cert service descriptions or versions of
a service as the system was running you
know this is sort of what we ended up
with
and let's just think about those four
goals for a moment real briefly no is
this system declarative can we just
describe the intent of a service we
definitely can right it's just sort of
this data description and you know can
we evolve the data model well you'll see
in a bit that we definitely can I'll
prove it yeah and you know can we do
this in hours instead of days or weeks
well it's just a data file right it's
just a piece of Eden I can create a
piece of Eden indefinitely less than an
hour so creating a service takes less
than an hour you know and can we evolve
the system well the master container
allowed for live up certs so we could
evolve the system however we needed to
we could evolve it service by service or
across all the services at once and it
evolved very gracefully so let's take a
look at what this might actually look
like or you know what we ended up
building and I understand this is very
small you're not meant to read any of
this but we call this thing vase because
it's a very small container that sits on
top of pedestal and is very limited in
what it can hold now let's dig into this
and look at the structure a little bit
more at the very top of the service
description is the service name and this
is the global identifier for a service
so it identifies it in a given container
after that was the schema definitions
the schema definitions could be you know
the standard atomic schema definitions
but base also had a shorthand in the
form of a reader literal and you could
also talk about schema dependencies here
so the different chunks of the schema
could depend on you know other chunks of
this schema and this meant no creating
schema or sort of attaching it or
growing it was a very natural process
after that are the versions of the
routes the route definitions and these
are standard pedastal route definitions
so let's zoom in on one and see what it
actually looks like so here's the route
definition for slash users if you make a
get request it will result in a query on
the on the database and the the results
of that query we returned and if you
make a post request it will transact new
data into the database and here you can
see how we actually constrained what it
meant to be a service all those five
constraints are actually captured behind
reader literals and that's how we can
compose these actions
and data we called them action literals
we're gonna talk about some conclusions
of doing this a little bit after the
route definitions where service
properties these are things like the
HTTP headers you want to forward or the
schemas that you depend on in this
particular version of the API and at the
very bottom of this file is yet another
version of the service it's a very small
version version two so let's talk about
some conclusions about doing this about
capturing services as data well on the
surface we're programming with values
and we get all of those great benefits
of programming with values it's very
easy to generate and consume these
service descriptions in closure let's
talk about more about those reader
literals right the mechanism we use to
constrain our service definition the
mechanism we use to box things in is the
same exact mechanism that allows the
entire system to be open for extension
you'll never get pigeonholed in by using
a system like this alright so that was a
very powerful insight that we made the
entire system ends up being fully
extensible through that same mechanism
and you know when you capture the
service definition as data a lot of cool
benefits sort of fall out of that it can
go anywhere data can go you know can be
stored in a file read from a file sent
over the wire stored in a cache you know
stored in a CDN can be stored in a
database in fact let's talk about that
last one a little bit more storing it in
a database so vase already sits on top
of des Tomic and we store all the
service descriptions inside of des Tomic
and as live up certs are happening
we're actually storing that new version
inside of de Tomic which means if you
look at the database as of some point in
time you see all of the services that
existed at that point in time because
the services are just data along side of
all of the other application data so you
get this full code and data rollback
through your entire day Tomic DB that
you're sitting on top of now vase can be
tossed a DB value so you could roll back
the DB at some point in time get that DB
value and pass it back to vase in vase
will say okay well I'm gonna just run
with this one now so you got full
that'll roll back think about how hard
that is to do in the systems that you
know you're creating today outside of
doing something declarative like this
it's a pretty difficult problem to do to
get exact point in time code and data
rollback you know but what other things
can you do once your service description
is captured in data well you can query
it you can query and analyze it you can
use data log to enforce service wide
properties across the entire thing so
there's a lot of literature about using
data log to enforce the presence or
absence of properties and programs
but very little literature and doing it
out of systems wide level or service
wide level now when we originally
designed this system we thought oh yeah
you know we'll be able to see what API
is actually changed the most or what URL
has changed the most or how much churn
happens in the schema well we didn't
quite realize how powerful that query
piece could actually be we could start
saying things like if I change this
schema what urls are going to break
think about how you'd do that in your
systems today if I go to your work on
Monday and I go and I change the data
model can you immediately tell me what
systems I just broke that comes down to
program analysis that's a pretty hard
problem to solve and it's you know it's
not fun to try to solve it and here it's
just a day Tomic query and we got there
because we chose data first you know you
can also start to impose these business
rules on your services - you can say it
should always be the case that a query
only gets triggered from a get request
queries should never be triggered for
post or put or delete how would you do
that in your system today how can you
prove that to me today well again that's
program analysis but here that's just a
day Tomic query it's a pretty simple
daytime of query to write as well so
this was a really powerful technique a
really powerful thing that you know we
didn't even understand how powerful it
was and like I said we delivered all
four of those goals in addition to
having all these cool aspects fall out
of it being data and when we delivered
it to consumer reports they said this is
awesome you know you solved all these
things you built this thing I can
iterate really fast awesome and then
very very quickly said but what about
our data
you know as awesome as the system is it
doesn't have all the value we actually
need it to have we can't actually build
anything with it unless we have our data
and so we began our second project and
our second project was a day Tomic
import project we needed to get that
data into those services somehow and it
needed to be data source agnostic some
of this data came from JSON files and
some came from DBS and so on and so we
built this data agnostic import tool and
that data agnostic piece was actually
extensible through a multi method so you
know if you had a new file type or data
import source you could go ahead and
extend the system and so we imported
stuff from JSON files XML files sequel
dumps and live JDBC connections and we
used this multi pass design one pass
through the data the tool actually
reflected the structure and type of the
data so it sort of discovered what I
thought the schema should be and it
generated a schema on that first pass
and it generated in a format that it
could be dumped directly into a service
description so awesome now I don't even
have to write schema anymore this is
great and then on a second pass with a
schema in hand now it would actually do
that import that that reflection on the
structure of the data and the type of
the data that was also a multi method
right so that was also fully extensible
you could teach the tool how to reflect
new value types into schema or how to
interpret new structures of data and all
the knobs to control the system were
also data-driven they're sort of
declarative just like the service
properties were so so this is pretty
exciting it's pretty cool tool to use
and you know we we imported all of this
consumer reports data well when I find
it
you know astonishing is that to import
all of the product data and of the
review data for consumer reports took
less than 30 seconds to get it into the
atomic so that that meant that somebody
completely knew an application developer
or a mobile developer could walk up to
this system and thirty-seconds get all
of the data and then in less than an
hour write a service description that's
crazy to think about 30 seconds to get
all that data less than an hour to build
an entire
service so we delivered that to Consumer
Reports and they said now this is
awesome
and then very very quickly said but what
about rich client apps so you can see
that it's very hard to please consumer
requite spy
you know we began our third project and
honestly at this time and the sort of
the project life lifecycle I'm pretty
much ready to walk it in you know I'm
pretty exhausted I thought pretty hard
about all these other pieces really
focused on the design I'm gonna walk it
in I'm gonna write just another closure
script application and say you know
here's close your script it's pretty
cool but I have a very serious
personality flaw and that is if somebody
has some expectation of me you know if
somebody sets a bar you know I have a
personal challenge with myself not just
get over the bar but let's see how far
how I can actually get over that bar I
really get competitive with my own self
in my peer at the time Timothy Baldrige
not knowing this personality flaw said
to me well clearly Paul you're going to
do data to describe to clients right
that's the very logical thing that you
would do next and you know I took a deep
breath and I said yep we're gonna do
data describe clients and so we did data
to describe clients but if I was going
to build a data described client tool if
I was gonna build an application with
this technique on the client side for
Consumer Reports I didn't want to build
just any application I wanted to build
an application that already existed I
wanted to create a baseline that we
could compare the two approaches against
so we would have some idea of the
metrics between these approaches and the
client that we actually created is this
one right here it's sort of the Consumer
Reports ratings application and I want
to draw your attention particularly to
the table at the bottom where you know
there's prices and their scores and
there's some sort of rating mechanism
and there's products listed and then
there's all these filters on the left
hand side and you know I also want to
draw your attention to that filter brand
you know the filter as you type kind of
filter where I type in the name of our
brand and it starts doing fuzzy find on
all of the brands that match that right
so I want to build this application in
that application is all of this code
right here 26 lines so using data
describe clients and only 26 lines I can
rebuild that entire
and immediately you can see this is a
cell oriented application you know it's
a cell oriented system so making an
application is no more difficult than
making a spreadsheet at least in my
opinion but the cells at the very top
they hold the data and they can hold any
kind of data you know they can hold a
mutable data static data or they can
hold data that they fetched from a
remote resource like data they fetched
from a server they can hold data they
extract it out of the Dom they can hold
any kind of data and right underneath
that is the UI and the UI binds those
cells to interactions labels and
displays and it's completely independent
from the cells completely independent
from the data that binding actually
happens with a reader literal so you're
sort of seeing the power of these reader
literals again you know the the UI has
no notion of the cells above it has no
notion how the cells are actually being
bound and so I can take one UI from one
app and stick it on the cells to another
app where I can take the cells from that
other app and stick it on top of this UI
and that will actually work all of this
sits on top of court async and react j/s
it's fully extensible through react
components so I can go ahead and extend
and reuse the UI by by creating react
components or using other react
components and the cells that's actually
fully extensible through a multi method
if if you need to define a new kind of
data source for your your system you can
extend it through a multi method what
you end up is with this complete app
reusability I can reuse any piece of
this from the smallest UI component to
the entire UI structure from the
smallest cell or data source to an
entire set of cells I can reuse all of
it and what's particularly impressive is
that these twenty six lines replaced
over 2000 lines of JavaScript and over
1000 lines of HTML 26 lines replaces all
of that and that happens when you start
thinking declaratively about your
systems so let's think about some
conclusions we can make about doing data
described clients well the first thing
that's very obvious is there's no
closure script compilation involved
right you get this data description and
it turns into an instant
location so they can be loaded as fast
as you want they can be loaded and sent
over the wire they can be read out of
local storage they can be fetched from a
CDN it takes ten milliseconds to render
an entire application at the rate of 10
milliseconds for a single application
you can start flipping through
applications like you would flip through
TV channels you can actually make 30
frames per second of animations of
multiple applications all stacked on top
of each other so you can really stretch
this metaphor as far as you want but it
also means we no longer have to make
these gigantic monolithic rich plan
applications we can start splitting it
up into smaller app descriptions and
tackle it piece by piece and then reuse
parts of those smaller descriptions
across each other again the data
description for the client is just data
and it lives as data on the browser so I
can open up a JavaScript console and
change that data structure and I will
see the results immediately in the
browser this really speaks to the
experimentation or the creation or
shaping of an application I get this
instant feedback feeling as on creating
applications and that happens because we
chose data first we get all the same
benefits from the server-side as we do
in the app side this can be versioned it
can be rolled back it can be cached all
those things sort of apply here and it
can be queried and analyzed just like
before well let's think very carefully
about that query piece you know we don't
have day Tomic and closure script you
know but what do we have what tools can
we use to analyze the structure of a
data structure or a query a data
structure we have core logic right so
we're going to use core logic we're
going to build a query system using
nothing but for logic so what would that
even look like the system is already
declarative and now we're going to build
another declarative uber declarative if
you will syntax on top of this using
core logic and that's exactly what we
did we had the cells we had the UI and
then we introduced variations and
variations use a CSS like selection
engine that's backed by a core logic to
select different spots of the
application and perform updates or
transformations at that point so you no
longer have to actually specify
you know the the exact place in a data
structure you can just express it as
some CSS selection now you'll see I make
a couple of selections of nothing that
selects the entire application including
the variations so variations could
technically modify themselves if you
really wanted them to here you can see
that the variations are named we have
four there's limit results limit
products no search and simple score and
they can be applied however you need
them to be applied they can be combined
however you want to combine in they're
completely independent from each other
so I could say load this description and
show me that description with the limit
results in the no search in fact let's
see what that actually looks like so
here I am in my JavaScript console at
the top I say refresh the description I
want to refer to the description with
something I fetched from the server
slash dev slash buried app ddn and I
also want to load the following
variation limit products simple score
and no search in the entire application
turns into just that right so you
remember the application you saw a
couple of slides ago well if you load
all the variations you get just that
application right there so this is a
very powerful technique to to check out
you know different pathways or different
concepts of an app that you would maybe
want to mix and match across now I want
to change the pace of the talk a little
bit I want to change the direction of
the talk and I want to talk more about
the the project metrics and how we
actually did this and how we work
through the design phase I think that's
helpful for people to hear about and
we'll start with the metrics so we
talked about three projects right the
the service properties the service
description the de Tomic import in this
application description each project was
only built by two developers
in each project from the very first
initial kickoff to the absolute final
deliverable took 16 to 24 days that
includes all of the tests all of the
documentation all of the code absolutely
everything 16 to 24 days we were
functionally complete on every single
one of these individual projects 12 to
16 days and the design time took four to
eight days now in cognitive terms four
to eight days is one to two weeks and if
you look at the last bullet points
you'll see something very interesting we
spent half of our time in
half of our time was just imagining that
ideal future just working through the
actual design on how this system would
actually come together and once we had
that design it was pretty easy to take
that step forward to make it
functionally complete it was just a
matter of typing it in but the effort
was really on that design and once we
were functionally complete we could
obviously continue to evolve the problem
the solution domain however we need it
to now this really speaks to you know
what does it mean to be agile you know
agile doesn't have to mean take the next
ticket off the wall you know and
implement it right in fact if that was
the process we took I don't think we
would have gotten here I don't think
these numbers would exist and I don't
think we would have found these systems
because then that mentality of you know
take the ticket off the wall and
implement it
you're not afforded the ability to think
holistically about the problem you're
forced to actually think about the
smallest potential thing right in front
of you and you never see all these other
opportunities to play the the problem
domain off of itself
you know agile to me means remove the
most risk deliver the most value and
keep iterating on that and I really
think that's what we did here right we
delivered the first project in consumer
reports that this is great
that's a lot of value you have removed
some risk but now there's more risk in
front of us we need data and we kept
iterating and iterating and you know
these are pretty impressive numbers for
just two people but we did have some
superpowers right we had closure and
closure script and atomic and pedestal
and and core logic and core icing and
all this great stuff and like any
superpower
over time you learn different ways to
harness it and this really calls back to
Timmy Wald's keynote from last consc
these are simple tools and it's all
about how you apply them and that's how
you get utility out of them the ways you
use those tools are actually motivated
by the constraints that are in front of
you
they're the constraints that are imposed
upon you the external ones from your
problem domain and they're the
constraints that you impose on the
solution the internal constraints and
all of that is extracted with Design
Thinking there's real power in those
constraints
it really helps focus you right it helps
create the ability when we said a
service could only be five things
we really constrain the solution domain
and there were some some serious power
in doing that when you combine these
superpowers when you use them together
their effects are multiplied right when
you use closure and atomic inclusion
script together extra bonus points but
when you start thinking holistically
about how the play off of each other how
you can use you know the properties of
one to increase the properties of
another their effects become exponential
so it's really about thinking
holistically if you just have drums and
bass and guitar you don't have a song
you have a lot of chaotic noise and I
know that because I've made a lot of
chaotic noise in my last time but you
know once they start becoming harmonious
once they start playing together you
have a beautiful band or a beautiful
song you know a good design is holistic
in that same sense so so what steps did
we actually take to be data-driven how
did we actually work through the design
well I'm going to give you the exact
steps we followed and they sort of shape
up like this the very first thing is to
be exploratory really investigate the
unknown no idea is too wild at this
point right really stretch out and
explore everything and as you're doing
that think holistically how do all of
these new ideas that you're exploring
play off of each other how do they
complement each other how do they fit
into interesting dichotomies in your
problem space or how do they match up to
interesting pieces in your solution
space again the system is more than just
the sum of the components it's really
about this harmony write it all down
like I said we spent half of our time in
design we were writing design Docs you
know we were writing all of this stuff
down and we were just constantly sharing
it with each other and reviewing it and
you know the best thing that we wrote
down was the hypothetical use we were
literally living in that ideal future
before it even existed we were writing
service descriptors before we had any
system that could ever run them or make
them work or whatever now we were
imagining this ideal future we were
living in it we are saying is that an
ideal feature we would want to live in
does that actually fix our problems we
were writing it down and that's that's
the most important part here
constrain your design space once we were
writing it down we were figuring out did
we write
too much what can we take out what can
we remove how it's simple can we make
this thing really embody the principles
of bliss right it's all about how simple
can you make it in how can you combined
it accept new barriers to produce a more
focused more expressive higher quality
products those new barriers are gonna
give you that laser focus you need to
get the job done right the first time
through and really think critically and
slowly you know we were really reviewing
each other's work the to developers
myself in and another developer we were
reviewing each other's work constantly
critiquing each other coming up with
better approaches or have we ever
considered this or maybe we should go
read that paper you know really think
critically and think slowly through all
of it you're gonna be balancing through
all these points a lot as you go down
this declarative path and then envision
the outcomes than the possibilities we
knew ahead of time once we had written
that ideal usage of the of the data
description for the service that we
could query it we knew that going in we
knew that we could put it into a
database it and see how it changed over
time what we didn't realize is how
powerful that that concept could be how
powerful the query could actually be
you're gonna be surprised but do your
best to envision where somebody's going
to go next with your system if you
create a system somebody is going to
make the next logical step after it and
it's your job to figure out what that
step should be and help with guide them
in that direction so really envision
these outcomes and possibilities and if
you follow all of these steps if you do
these things you will unlock data-driven
systems
thank you very much
there is no time indicator this year for
other speakers usually we have the Craig
and Dara clock of superior timekeeping
right about here we've got four minutes
all right four minutes so I can take
some questions that's actually what I
was expecting so in the front sure
yep
sure so his question was you know we
talked about rich client you eyes and
you know I talked about not doing it in
enclosure script but I used this actual
data structure his point was that you
know while closure is data right closure
code is data and the only reason why you
couldn't use just closure code is
because you actually don't have the
closure script to compiler written
enclosure script but so he he thinks I'm
going to limit my Express ability by
forcing people in there and I am
artificially right i constrained on
purpose the system right I use those
constraints to say it is a Cell oriented
system you can only do this kind of
binding but the way the bindings happen
where a reader literal they're fully
extensible so you could go ahead and
write any extension you want to the
system the cells could be extended
through multi methods the actual
bindings can be extended through reader
literals and the UI is fully extensible
through react components so it's not
actually limited by anybody's
imagination you can think of any system
and extend it what I did purposefully
constrain the system to focus people on
building simple systems if you let
people have full expressiveness of
closure script you're not going to get
26 lines you're going to get 200 lines
and I know that because it took 200
lines of closure script to write the
thing that runs the thing right so 200
lines of closure script allows me to
write 26 lines of an app description so
it's really about the constraints to be
able to focus as far down as you
possibly can on building the simplest
system while still allowing it to be
extensible he wants to know if I can
approve if I can prove the assertion if
there's any open source stuff so it was
our hope to have this open source by the
cons we're still working through some
details of that but hopefully some of
this stuff will be open source but
there's lots of literature about and you
know a lot of books about design that
you know there's a lot of power and
constraints so we took that approach
here another question
so his question was have I considered
creating a UI or an application to
create the actual service descriptions
now that it's just data management I did
not only because you know we're sort of
limited these were proof of concepts to
see if these techniques actually work so
for me my UI creation toolkit is a text
editor because it's written in text but
you know there's no reason why you
couldn't create any tool that could
generate this data right I could even
write more closure programs that
actually generated this thing because it
is just data so whether it's a UI or
another program that is the intent that
now that it is just data anything can
generate it and it and it can be
composed right you get all the
composability of data as well okay
actually that's it that's our time all
right thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>