<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing Made Simple - Tony Kay | Coder Coacher - Coaching Coders</title><meta content="Testing Made Simple - Tony Kay - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Testing Made Simple - Tony Kay</b></h2><h5 class="post__date">2017-03-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Odp0M39g-LM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">i'm tony kaye I work out of Bend Oregon
which about three hours sort of
southeast of here I'm going to be
talking to you about testing today and I
appreciate that we're all coming back
from lunch and might be a little muddy
headed and and you know I hope I hope I
say enough interesting and entertaining
keep you awake and I promise that you
know if you get through this testing
session there will be cake okay so I
love this quote this is one of my my
favorite quotes of rich Hickey it's one
of the first talks I watched when I when
I joined the closure community was
simple made easy and he makes this joke
with with guardrails you know we say I
can I can make change because I have
tests who does that who drives the car
around banging against the guardrails
who's really making a comment about how
the test-driven community talks so much
about testing driving your design and
that really strikes a chord with me that
that is a thing we kind of promote when
we talk about testing and it is a little
misguided so I really I really liked
that but then you know as you think
through it a little more we do make
guardrails and we make guardrails for
good reasons and when you look at this
picture how fast is the traffic moving
on this road it's probably not moving
very fast right the the cost of making
mistake is relatively high there's
little protection and there's a lot
going on all right so this this idea
that that we never want tests obviously
if you're here I hope that you agree
with me there's there times when we want
guardrails but we probably don't want to
build our guardrails like that and this
is often what we do right this is why a
lot of us feel a lot of pain about
testing is we build tests that
essentially just we trip over them
constantly they cause us a lot of hassle
they give us kind of low benefit and you
know but at the same time we shouldn't
really judge the benefit of the
tivity from the results of our worst
practitioners you know so when I hear I
don't value writing tests you know as
hard things went wrong I just ended up
deleting them all I get it done without
tests well okay that's a valid
experience I've had that experience I
have I haven't deleted untold numbers of
tests I have made tons and tons of
mistakes when testing and and so I have
a lot of compassion for for the it
didn't work well for me so I stopped
doing it however why do we expect
anything but bad results from something
we're just learning I mean after all
define testing and I would challenge you
to try this exercise screen record
yourself and do it long enough that you
forget you're doing it so go for a
couple of hours and then go back and
look what you were doing how much time
did you end up fiddling with it in the
repple how much time did you end up
clicking through a UI how much time did
you end up seeding data into a database
you could try out the thing right we
spend a lot of time testing and we throw
it away and you know do you really get
twice as much done when you don't write
tests right we essentially do bad
accounting and then say tests are just
more expensive excuse me
so one thing that was really when I
proposed this talk and it got accepted
my my first reaction was oh crap now I
know I'm kind of right a talk that
people don't go oh that sucked you can
almost smell the psychos fear around
testing especially in the closure
community it's it's a it's a really
polarized issue and I found that that
people problems really are very often
the biggest problems you've got you know
this this you're the expert figured out
attitude from whatever business you work
for and they might be asking you
questions like why you're writing tests
that's not getting my feature done right
you have this this hostile thing you
might be hearing that from other
developers as well but
had bad experiences there there's a lot
of just culture around this and failure
and and problems and I've you know in my
career I calculated this out when I was
writing this slide I've met about about
3% of the engineers I've met were any
good at testing and it actually
practiced it long enough to get good at
testing the rest of them were just like
yeah I tried it for a day or two and
that don't again
so you know we don't teach this it's not
something any I think everybody I've
ever asked and and I would love it how
many people had a great experience
learning about testing in college one
two three
ouch right this is really at the core of
the problem is we neither give ourselves
permission to learn it well nor are we
taught it so that that's where I'm
trying to get here with this talk is I
need trying to show you where you can
get demonstrated value and for me the
best value I get is what I propose to
talk about talk to you about and that's
simplicity and I mean test simplicity
like this right when I look at this test
you get it you know what this test
afford it's accurate it's self-contained
it's relatively well labeled you might
have mixed feelings when you see the car
but you can't argue that this you know
this isn't a good test right so however
you know most of us when we first get
into testing we're we're used to playing
with the repple reused to clicking
through the UI and so when we write our
tests we do this can't wait to throw
browser straps a cat this right we write
this big convoluted thing that requires
a ton of setup and you know really tries
to test it the way we think it ought to
be tested because it's kind of our habit
of testing the whole wad the whole
complicated thing and so our tests very
often look like this big complicated
mechanism and you're not going to get
wide coverage easily or affordably with
this but at the same time if you're
writing software for an airliner or a
heart monitor
you might be stuck with this right you
might really need to test a system that
costs a lot to test and so that's not
what I'm talking about here if you're in
that space and work in that space I
build web apps
so I am kind of trying to narrow the
focus - there are cases when this is
what you need to do and it's it's a bit
harder to do it's more expensive to do
it gives you you know a more predictable
not more predictable more trustable
result on a very specific hard problem
so so I kind of want to narrow my
problem focus when I teach people to
test I first start with an analogy I
love the onion analogy right if you're
writing clean soft or what you're doing
is you're building abstractions and
you're sort of layering those
abstractions I've got some some little
thing that I build and then I build
layer above that and as I get to the
third layer I don't talk about the that
low layer anymore I'm now at a higher
level of abstraction etc and I often in
my analogy I say you know the side
affecting one of the things that I
really love about Haskell is it tries to
separate the side affecting stuff from
the pure pure stuff in a very strict
sort of way and we can get benefits of
that we don't necessarily need a type
system to enforce that for us but I do
like the idea that when we go to
interact with the database there's a lot
of complexity there there's schema
there's networking connections there's
all this stuff isolating ourselves from
that as much as possible and getting as
much code into pure functions is great
right pure functions are a little easier
to test but well even when well designed
a software system has combinatorial
complexity each of these layers has
behaviors and we've stacked them all up
and that's an exponential growth problem
right ten behaviors here x 20 there x 30
there x 10 here x right we can't write
all those tests and then um so you know
we can sorry so when we do this most
people are good at testing the edges
we're we're good at testing the layers
where things are isolated things are
pure but then this happens right we pick
up the onion and we just take a big
bite out of it we're like the Tootsie
Pop owl for onions the older people are
laughing at that joke so instead you
know we we say let's let's try isolating
these layers let's just beep fry those
suckers right let's make them tasty we
separate them out we can get kind of
high confidence that some of these
pieces are in fact tasty and we can gain
back some of the the speed and
simplicity of moving through these
things but it's not magic
so ultimately what I'm trying to talk
about with this is the trade-offs
between unit testing and something else
right so this is kind of sort of a
summary of these things if I involve
less code and or less behaviors well the
grand total of those if I add those
together that's a linear problem I still
might have a lot of tests but I can get
high confidence and localized behavior I
can say that thing does what it's
supposed to do and I'm really confident
that all of the things that's supposed
to do are right but I have questionable
confidence in the global behavior but I
get a low cost per per behavior on kind
of the left side of this graph on the
right side I've got more code involved
my total behavior is an exponential
problem I'm probably not going to cover
very many of them right I've got kind of
a high cost for behavior but I have high
confidence in those few properties in
the large and kind of lower confidence
in the in the smaller ones I'm going to
talk about some examples here a minute
but this is kind of the general thing
I've got in my head but even without
combinatorial complexity it's still not
necessarily easy take sine we know this
function it's pure give it an input
gives me an output we've understood it
for hundreds of years this is a Taylor
expansion that the more terms we add in
and very rapidly converges we get a
value when you look at the fast sine
implementation it's about 800 lines of C
and this is the implementation that's in
most Linux standardly C libraries do we
just trust that this is working we wrote
this 800 lines and maybe did a quadratic
curve approximation now well we just
know it's right because Matt well it's
800 lines of C using base to
approximation of numbers that I'm going
to use to calculate structural stresses
and steel hmm I think I want tests for
this right but how would you test this
how would you test time
hopefully you wouldn't just press the
release button and wait for complaints
to roll in right this is often what we
do and all right I think in this case
probably not the good thing and very
often this is what you do right you
write some test case and you say all
right expected should be the sine of an
angle let's give some examples good
enough right I run clover edge it tells
me hundred percent cover I've covered
all the lines of code and right now am I
done is it right well why did you choose
those angles is that a good enough
sequence of samples okay generative
testing right this is the thing we want
generator tested for this what does that
look like well it looks like behaviors
and properties right you still have to
say what the things boasts to do that's
the hard part right so you have to think
about this what does it do for small
angles what does it do for large angles
if I throw a double that has a really
large value at sign well all the small
digits in that right if it's something
to the e to the 300th or something am I
going to get an accurate result from
sign I should probably specify how it
should behave there I should specify
what the range is and you know when I
think through this the only way I know
to test this is either to make a really
large table of stuff I know or write a
slow implementation that uses that
Taylor expansion right to give me an
accurate a result as I want that I know
slow and compare that to my fast results
with some you know epsilon that says
it's got to be within this this range
but notice what I just did there I said
in order to test this I have to write
another version and this is very often
what you do in generative testing you
you know it's one of the techniques so
let's talk about generative testing
and what the pros and cons are here so
the one I'm just talking about here's
the third one down trusted
implementation I can have maybe I get
one for free Reid rapers talk at closure
West Computers to go talk about a case
of this where that we're at was actually
a pre-existing trusted implementation
you go against but I could write
something where I'm pretty sure I can
get in this case as much accuracy as I
want and then write a property that says
you've got to be within 1% of this for
this range fine generative testing done
but they didn't have to write twice as
much code in that case and the test it's
also good for checking invariants if
you've got you know a system where
something's going wrong my file is
becoming corrupt it's really good if you
can model hey throw a bunch of
operations at it and the property is the
file is never corrupt great it works
really well for finding those it gives
you a minimized case you can debug it
it's good for in this case kind of
debugging a problem with the system it's
also good for reversible operations
marshalling things where you want to
throw arbitrary data structures at it
finding arbitrary problems and stateful
systems and you really should watch
these talks this is a tool it's a great
tool it's not it's not a panacea it
doesn't solve all your problems so learn
it but getting good at other approaches
is still important so I have a very
short list of rules I don't like giving
people a whole big complicated mess of
stuff to try to remember and do this is
a task that's hard it's something that
does require you turn on your brain and
think through the problems but there are
some ways of simplifying and that's the
whole point so the first one is be
critical about what and how you test to
know your tools if you don't have that
and right the more tools you have in
your toolbox the better you're going to
be at it and ultimately what I'm looking
for
unless again I'm writing something
that's a heart monitor or something is
is you know low cost high benefit I'm
going to choose a layer of abstraction
I'm really going to stress the unit
testing but I'm really going to try to
get to the unit and that's the part that
I've seen most people struggling with
and not doing well they think their unit
testing because they're using a unit
testing library but
not actually unit testing there they're
grabbing these big chunks and biting the
onion so don't clump things try to
really separate out the specific things
you're trying to show and be really
clear about those and that brings you
specificity you really want clear
language to target the interesting
things and this is a little troublesome
in a male-dominated field because it
means you have to use your words we're
not necessarily always good at that lack
of descriptive accurate detailed
language around tests really makes it
hard I've got a head scratch I go and
look at a test ins like that what were
they trying to prove here the test is
failing but now I've got to go
reconstruct the logic of what you were
doing when you wrote the test that's a
nightmare don't do that to yourself or
others because you're going to be your
own worst enemy when you come back and
look at your failing test and you don't
understand it or you look at your test
and it says one thing but it's actually
proving another so you don't want these
things to be obscure you don't want to
make people rediscover things and so my
general rule is name the thing under
test and then actually type out an
English sentence about it
right there's enclosure clojurescript
test there's a testing clause you can
you can use to put a that sentence in
your output of the test this is what's
wrong I feel so strongly about these two
things being able to isolate things
really well and being able to describe
them really well that we actually
maintain an open source library called
untangled spec and it's really just thin
wrappers around closure and
clojurescript tests everything in those
libraries works in it and it just adds
some extra reporting support and some
helpers for isolating and the only
reason I'm even mentioning it is because
I'll show you some examples here in a
minute that use it and you might want to
know what it is that I'm using there so
again the most important features
isolation and description okay and feel
free I'm actually Manning the Navis
table out here in the in the main area
so feel free to come by and talk about
any this stuff we'd be glad to show you
more details so let's look at some
examples the first one is a react based
example we do
full-stack closure closure script
development and there's this thing you
can do we use aam next there's this
thing you can do where you use macros
and define your react components and
there are these special components I'm
calling an s-1 and s2 here that let you
switch in the UI amongst alternatives
right they're known as unions are
actually in on next the Union if it is
part of the query but close enough so
the idea is when I first start the app
one of these things that in view so
that's the green stuff the green stuff
is the stuff that's going to be
available as the thing starts and at the
switching nodes a and Y here are
alternative things that could eventually
show up on the screen but aren't
currently in view now the way things are
structured I can set up the
initialization code so that all of the
states that these things need end up in
my application state during startup if
they're in the green but the blue ones
aren't actively in the tree and so I
don't see them so the algorithm that I'm
trying to write here walks this graph
essentially this tree really and tries
to find unions and initialize the blue
nodes that's it and this is what it
looks like it's a fairly large piece of
code the first part is to search through
the tree and the yellow thing there is
the only thing that matters I care that
this side affecting thing happens for
the blue nodes now when you look at that
first of all I would say that some day I
might refactor that and break it up into
pieces but ultimately this is an
abstraction that's just trying to make a
very simple thing happen walk the tree
find blue stuff call merge on so if I
try to test this with the bite the onion
thing what I end up doing is I have to
initialize the entire application get it
going and then
invents write write write the tree out
run it and then go and look in the
application database and check the CRA
are those two things in there and the
other way I could do that
it's a great a test that looks like this
now we're back to the complicated grown
producing test right what I'm doing here
essentially is I'm using with read EPS
down here at the bottom to stub out
merge States so I don't have to actually
initialize the application but then I'm
having to keep track of what got called
and what it got called with and did it
call it did something get called it
wasn't supposed to be called right I
don't want to reinitialize those that
are already called there's a lot of
extra noise here I've got high noise low
signal there's only three things I care
about here that when I call merge
alternate Union elements it merges two
things so I've sort of dipped my onion
rings in lime jell-o or hey so it's it's
really hard to come up with an idea
about making onion rings not tasty
chocolate pudding that might be good
lime jell-o okay so I could Paula Deen
pixie dust right you sprinkle them on
anything just like yeah it's pasty so
this is what it looks like an untangled
speck so what we've added is a stubbing
system that allows you to very concisely
say I'm going to step out that's what
the wind mocking thing is notice I'm
using my words here the specification
for merge alternate Union elements I've
got a little comment above showing an
ASCII art graph telling me which nodes
aren't aren't present when mocking merge
state it's going to be called one time
and it better be called with the state
of a and then it's going to be called
another time that's what they want X is
for I can specify how many times it
should be called and on the Left I'm
capturing the argument so I get argument
capture I get order I get the ability to
assert on the right hand side and then I
can actually return whatever I want to
return from that right hand side that
will be the real return from the stubbed
thing so it's sort of like a scripting
system for the things that you don't
actually want involved at at the moment
right and so this reads very clearly I
run the thing on our and it should merge
a and Y and nothing else and that's
something that's implied here by the
scripting system if you you know read
the documentation it tells you that the
merged state if it were called any more
than this the test would fail and tell
me merge state was called more times
than you said it should be called
okay and this happens all over the place
in our programs we have a lot of
orchestration code right these are all
the middle layers right there talking
between layers they're saying alright
when I do daily processing well okay
when it's Tuesday I want to start weekly
billing how do I test that alright well
I could set the system time to Tuesday
and I can start up the database and I
could run the thing and see that it
starts the billing ouch right that's
really painful it's really kind of
expensive and so very often what we do
is just write it we try it out once and
we just say and now and forever that's
good but what happens when somebody
comes in and messes with this function
that is using power and fur and they hit
space and indent it and the parentheses
change and now it doesn't get called or
it gets called every day right we do
want some protection for these kinds of
things and same sort of thing right I
can say when day a week gets called it
returns Tuesday and then start weekly
billing gets called I don't care what it
returns I'm basically using that to
assert that it does get called and the
test will fail if it doesn't and then I
call daily processing this is low-cost
it tells me exactly what I'm asking for
it gives me the rule looking for but
this is not without problems and those
of you have done much testing hopefully
already see the problems with this the
two big issues with this are am I
fooling myself right I just said day of
the week returns Tuesday if I was doing
this test-driven right well maybe that
returns to maybe I didn't remember it
right maybe I was thinking of some other
function that uses keywords for the day
of the week and I happen to use a
different one that returns numbers well
now my test is going to pass but my
program is broken right so this is this
is kind of a problem
the other issue is I always have the
potential because I'm partially mocking
here and those who have played with
testing for a while know what I mean by
that but essentially think about
this code what happens to this code if
you're if you're doing programming well
well you never really you don't really
change it unless the specification
really changes but you might add things
to it
there may be a new thing you need to do
in daily processing that's a perfectly
thing and daily processing is a side
effecting sort of thing that might talk
across networks might decide to talk to
a new database might talk to a job
scheduling system when I add something
to this and now I rerun this test that
side effect the thing that I haven't
stubbed out happens and my test hangs or
chokes or crashes for a bad reason so
that's the thing that that is a second
problem here so those are the two main
problems with this this sort of testing
and I want to point those out because
they're both addressable so the first is
addressable with closure spec and in
fact untangled spec includes this and
it's mocking checks if there's a spec
for the function it verifies it so I
kind of think of this as the bloomin
onion of our onion rings right let's PI
the onion rings back together so that we
have some faith that that we have at
least connected them correctly right I'm
not saying this thing connects to that
thing and pretending pretending it's one
way when in fact it's another so that's
one way of solving the first problem the
second problem is a little more
challenging but essentially it boils
down to having some way of either Auto
stubbing the the things that you've not
said anything about or asking for
explicit there now if you're if you're
doing tests around these functions
that's not really that bad of a result
if you think about it if you really are
covering the thing with tests as you add
behaviors you should be adding tests and
care if you're driving it or not and
when you do that you can go back and fix
things up so it's not perfect but it is
low cost and it does give you kind of
high value for for that that cost so I'm
going to do one more example it's a kind
of a real example in the wild I went and
dug through closure core and I found
this
so the instance method and I've stripped
out the there's a big doc string or
there's a bunch of metadata that was
here that I stripped out for simplicity
and in this case I've got a native JVM
call and I don't care what mocking
system you use you can't mock that out
right you're stuck with it that's that's
a low-level call to a C function that's
written in the JVM now I do trust that
the JVM works because if it doesn't work
all bets are off rate once you once you
go outside of your onion to the context
that your onion is hanging out in you're
not responsible for that stuff working
right that's supposed to be tested by
others and the existing unit tests for
this look like this and this is a common
problem an open source software in
general I have the same problem with the
open source projects that I work with is
you take contributions people give you
tests and you're like all right well and
covers the things sort of and good
enough I'll keep it but what's wrong
with this test means technically there's
nothing wrong with it in the sense that
it it runs and passes and does tell me
something but do I really when I say
test instance am i am i meaning to test
that one plus two is along that I mean
this is math something I'm trying to
test here no is the result of the plus
operator something I'm trying to test
here no great so there's a lot of noise
here I'm really kind of confusing the
reader I've said I'm testing instance
but what I'm really testing is that some
of the built-in types come back as the
right types and I'm sort of getting
instanced by inference right that's what
I'm getting so what about this I could
say instance is a pass through call to
the jvm class is instance method I could
read the source code I've got metadata
that points to it I could find it pull
it in and then just compare yeah all
right well at least this test is very
tight it proves exactly what I'm saying
about is instance it's just a
pass-through call it's a pretty name for
something that already exists but how
it's not terribly expensive but it's
also not super cheap so you know I might
choose to do something like this might
choose to do something like this if
inference is enough right the original
test I saw well then why not just say
that again use my words instance is a
pastor called the jvm instance method
that I'm inferring by testing against
string how long did that take me to
write it took me longer to write the
sentence explaining it than it did to
write the test it shouldn't fail for bad
reasons does state the assumptions it's
got a clear label
you can be the judge and perhaps when
you judge this you maybe think do I
really need to test for that no no
we've got programming languages now that
have I mean they continually improve our
power they give us tighter abstractions
less minutiae to deal with it is easier
just to get stuff right you know having
no test is a valid answer if I look at
instance and I say you know what if
instance breaks all this other stuff is
going to break do I really need to even
waste the ten seconds writing the
instance test that's a valid argument so
you know I'm not one of those zealots
that says you must test and cover
everything you bring right it might
already be covered now there's a
programming language so you might argue
the other way about super emulators I
want to make sure all my constructs have
some coverage again you're the judge and
you're also the person spending your
time and money so I just encourage you
keep that that to a minimum and then you
know it's now a loose bag of working
parts do we put that in our Santa sack
shake it up and get working software no
we don't it often does work I've gotten
really good results of this I've built
you know pretty large modules for
software systems with these techniques
and release them to the wild or run them
and played with them and found no
problems whatsoever
and then when release to the wild what I
get back is it doesn't do this right and
we go and look and we actually specified
it wrong we actually said it should do a
and really the users want it to do B all
right you can't avoid that that's that's
going to happen and you also have you
know you run into things like
concurrency and all sorts of other fun
things you can't really test those in
this way so again it's not a panacea but
for a lot of web app development and
business software this does get you good
results so I'm essentially advocating
turn your time of fiddling with it into
something a little more productive and
reusable a little more leverage and one
final thing about testing and design
because this is one of those things
where do my tests help my design and you
know designs really should come first
but good designs are generally easy to
and so what I found is when you use your
words when you enumerate the things that
a thing is supposed to do in detail
where somebody can come behind you a
week later and read it and know what you
meant
it means you were really thinking about
it it encourages you to spend more
hammock time less time typing well any
more time typing English book but less
time coding more time thinking about
what it should actually do that's always
a good thing
and the other thing is I've really found
that if you're writing a test and you're
going oh my god this is so hard to test
it probably means your design is bad you
haven't decoupled something you have a
decoding complected it right you haven't
made it simple and by the way the cake
is lie</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>