<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Challenges for Logic Programming - Steve Miner | Coder Coacher - Coaching Coders</title><meta content="Challenges for Logic Programming - Steve Miner - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Challenges for Logic Programming - Steve Miner</b></h2><h5 class="post__date">2013-01-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/y6WKr9j76kw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so I'm Steve miner our topic today
is challenges for logic programming and
this is going to be a little bit
philosophical no code involved so we'll
ease into Saturday morning I hope that
works out okay for you
so first any talk about logic is and
have a prologue so opening a little bit
of a pun I don't know maybe it's too
early for that so last year at the
conger there's a lot of enthusiasm about
logic programming dan Friedman and
William Byrd kind of stole the show here
with an unsession about Minnie Cameron
and then they were back again this year
and put on another great show I love
watching those guys they do a great job
and they've done fantastic work
Ambrose bionaire Sargent gave us an
introduction to core logic and then he
came back again this year and he showed
us some work that he's based on his
understanding of core logic and added
the typed closure and this was all based
on our core logic library that was a
port by David Nolan he's done fantastic
work he gave another talk last night at
the unsession that really really was
worth caring about some of the new stuff
that he's adding to core logic
especially the constraints I think
that's really important so he's done
great work and I really encourage you
guys to follow what he's doing and talk
to him about that
also Jim Dewey I think was my first
introduction to mini Cameron when he
talked about on a blog post maybe a
couple years ago so it's been a while
and he's also done some recent work on
adding the fork/join support core logic
so there's a lot of great things
happening around logic programming for
the closure community a lot of
enthusiasm but there's also some history
that we that I want to go over in the
old days of logic programming when I
when I first was introduced to it this
the enthusiasm here kind of reminded me
of how I felt way back then so we'll try
to bring that all together
so here's a there's a outline for the
talk I'm gonna go over some my personal
experience how I came to study logic
programming will have some try to bind
it bring it into the historical
narrative about some of the history
there's always some boring filler in the
middle that you know maybe you don't
have to worry about then like any good
show wouldn't have a dramatic conflict
and we'll bring in some of the critics
about logic programming I think we have
to kind of face some of that and see if
we can address some of the difficulties
that people have with logic programming
then we have an unsatisfactory ending
that's just the way it goes and in the
real world here so if I challenge this
since this is a closure talk I think we
always have to start with a definition
by challenge what I mean
I think the dictionary definition of
objection or query as to the truth of
something often with an implicit demand
for proof and the big challenge here why
should you learn logic programming okay
that's that's another another burden on
the programmers do you really need it
what what's it what's it good for and I
like the idea of saying a challenge so
we're trying to say logic programming
has to prove itself to us okay so the
proof and logic kind of go together all
right
okay so let's step back 25 years ago I
was a young Lisp programmer and I kind
of top of the world
I loved Common Lisp I was all in on that
working on expert systems and planning
systems and really you know at the time
I felt that's all I need comma list was
great but I had a boss who was kind of
an expert in Prolog and he introduced me
to Prolog and it was not something I
necessarily wanted to get into right
away but I figured it was worth learning
you know a lot of us here kind of
collect languages try to try to see what
other people are thinking about and it
can expand your your worldview if you
learn some other languages so all right
so I was in a learn Prolog now I had a
really good example most of us getting
into logic programming you know only
have some toy examples
well I was working at SSRI there was an
Alps project I hadn't worked on it but
my boss had been in charge of this and
it was an expert system that did
automated air load planning so knew how
to load big cargo planes for the army
and it was a classic expert system where
they had spent a lot of time with the
the loadmasters who'd you know the
humans who who had done this planning in
the past and they put together a system
that really delivered and could load
planes the car who loadmasters were
happy with it it was a field to system
and you know the army was using that so
I had I had this example this is a real
serious system that works okay and a lot
of us approach logic programming we
haven't seen anything like that so I
want to tell you that you know people
have done some great things this was
also done by a small team of prologue
programmers at SR I there was really
only one prologue expert at the
beginning and you know a handful of
recent college graduates who put this
together so it was another sign that
that maybe there was something to this
logic programming and I was gonna learn
it and I had you know fortunately some
really good people around me that
already knew about logic programming but
still I gave away all right
this I've had a little a little too
touchy so as I say there's a cultural
challenge okay when you're learning
logic programming I was coming from
Common Lisp and yeah I was maybe I'm a
bit coffee a bit full of myself where I
thought you know what do you need beyond
Common Lisp I've you know s-expressions
I have macros C loss or the Common Lisp
object system if you haven't seen that
you haven't really appreciate object
programming I know we in this community
we criticize object programming but take
a look at what what the Lisp world had
with the Common Lisp object system
there's a lot of amazing technology in
there so I was I was all in that's how I
learned object programming through a
lisp and that's a little different than
starting with Java so there's there's a
lot to that so anyway I have full
control of my world okay that's what a
common list programmer
you you own everything and you can do
whatever you want
Prolog was a little different for me
getting into that it has strange syntax
I mean we can get past that pretty
quickly but it was different and it was
like why do they do something different
you know haven't they seen Lisp and you
know some of them had some of them then
unification and backtracking and we look
at that and I think it's often Lisp
programmers look at something where
somebody's done something and say yeah
that's that's pretty cool they say I
could have done that I could do that a
lisp you know so what was it matter and
and really I had done logic programming
already enlist there's there are several
you know popular Lisp systems that could
do logic programming but Prolog I think
was something special there was there
was something interesting to it where
they they had refined it and was
simplified down to what really mattered
and it was worth taking another look at
the world of programming through through
that lens of logic programming so I say
as a cultural challenge I said it
reminded me of dance with Wolves Kevin
Costner was a Civil War Union soldier
who got connected with I think a Sioux
Indian tribe but he came to appreciate
you know the Indians seemed like a more
primitive culture but he came to
appreciate that maybe even though they
were simpler not sophisticated as the
Americans there were maybe they were in
touch with some deeper truth something
something important about life
or for a more modern take on that
there's avatar but a similar kind of
idea so that's how that's how I felt
going into the prologue world I felt
like I was leaving a lot of comfort a
lot of my sophisticated tools behind and
I was learning a more primitive way of
looking at things but then after a while
you accept that there is something
something special to to getting down to
the logic so my logic programming with
what I'm talking about you know my
history there was with prologue but
really we can think of logic programming
a little broader any kind of programming
system that's inspired
by logic and typically we have you know
facts rules and queries that we can deal
with and in particular the rules define
relationships between objects and our
computation is going to be done by
deduction and that that last thing is I
think the hardest part to get a good
feel for where we're trying to we don't
have a lot of control over what's then
happened we're trying to just state our
problems and ask our queries and let the
system figure everything out for us so
that takes a while just to just to let
go and you have to do more work up front
to express yourself so now to try to say
a little bit more about logic program
have an analogy here a few weeks back I
had the privilege of meeting this fellow
of pearl Fryar now he he has three acres
around his home of topiary that he's
been doing for close to thirty years you
may have seen he's been on PBS they made
a documentary movie about him a man
named pearl great character a really
interesting guy if you've ever had a
chance he lives in Bishopville South
Carolina it's not far from my 20 if you
ever have a chance to stop by visit he
just you can look him up on the web he
has a website he says his home is open
if you want to come and look at his
garden anytime and if he's out in the
garden he'll talk to you and I spent my
wife and I my wife so a gardener and she
she knew all about him I didn't know too
much about him but we spent an hour just
walking around he was talking to us and
he's very philosophical about creativity
told us how you know how that however he
does is topiary and this was very the
reason I bring this up is because he
just says he says there's just two
simple processes he has his a technique
you can bind so you can pull the
branches together and time together bind
them together so they grow together
certain way and he can prune so he cuts
things and from that just those two
simple operations
he creates these wonderful topiaries and
and there's a lot of creativity has a
lot of course that takes a lot of
discipline and patience to make this
work some of his topiaries take a couple
years to grow into the form that he
wants but the idea of just those two
simple operations that's all he has to
create all this wonderful stuff that
that to me was the connection to logic
programming it's very simple it's at the
base but you have to spend some time and
have a little bit of vision about to see
what can what can come out of your
program okay
and he has this great creative flair
where he can Kurt take you know just the
standard bush and create something new
and different
we asked him you know can you teach how
to do this and he says it's not it's not
really that easy to teach I can tell you
the techniques but for you to create
something that has to come from your own
inner creativity and I think there's
some there's some of that in logic
programming where it takes a while to
get to the point where you're
comfortable creating your own problem
you know problem description and
understanding what's going on where
you're not controlling it we're
typically as programmers in control of
what's happening and we're always
thinking okay we can you know sequence
these kinds of operations and get the
result we want
but in logic programming we have to let
things grow naturally a little bit we
can we can form our statements to get
the get the results we want but it's a
it's a little different way of looking
at the world so and I was learning logic
programming this is the book I started
started with the art of prologue this is
a great book I really highly recommend
this if you haven't seen this or if you
could find an old copy the art of
prologue by Sterling Shapiro from 86 I
found this quote when I was getting
ready for this talk says in Prolog
programming in contrast perhaps to life
in general our goal is to fail as
quickly as possible
and yeah that's I mean it's kind of a
fun quote and there's something to that
where you know we're trying to we're
exploring typically we're lowering some
kind of search space to find an answer
to our query and you know if something's
not gonna pay off we want to you know
make sure we get out as quickly as
possible this is important especially in
prologue where where the ordering of
clauses mattered when you get into core
logic I mean this is this is to me an
interesting idea that we don't want to
depend on the ordering of clauses in
core logic the mini cannon cannon way of
doing things trying to be more logical
and and avoiding this kind of procedural
artifact so Shapira also did a lot of
work in current prologues and I was
fortunate to have had the opportunity to
take a class from his shapiro where he's
talking about concurrent prologue so
that again I mean I'm not there talk too
much about that today that there was a
lot of kind of mind opening
interpretations of logic programming in
the concurrence base and and how you can
map you know Prolog procedures into its
own little process
and we use a kind of a pipeline approach
so you can have a network of connected
processes to do confirm Prolog
programming Sparrow also consulted on
the fifth-generation project and we're
going to talk more about that in just a
little bit so following on for some of
the ideas in the art of Prolog what are
the benefits of logic programming so I'm
an advocate for logic programming and I
think it's after learning going way back
I'm really happy to have a chance now to
come back to logic programming in a
sense closures brought me back to Lisp
too because I've you know the
introduction said I've been around doing
a lot of different programming languages
I started in a Lisp and moved on through
small talk and Objective C and Java and
now if
back and I'm really happy to be in a
lisp again in closure I think has done a
fantastic job of taking some of the
older ideas and and presenting them in a
new way and mixing things so you can
really bring together all these
different aspects of programming things
we've learned and now bringing core
logic into that that's another important
tool so back to the benefits here we can
the main thing about logic programming
is it forces you to have a precise
statement of your problem so really
you're doing all your work upfront if
you can describe what you're talking
about
then the solution can just kind of fall
out of that so Sapiro says spending
spending time on creating a precise
statement of your problem can be an
intellectually rewarding experience so
when your professor tells you something
is intellectually rewarding that usually
means it could be hard okay
so so I want to I want to tell people
it's it's okay if logic programming
seems hard at first I think I think
there is something to that it's
different maybe if you haven't had
experience with it
but stick with it and you know maybe
you'll get the intellectual reward that
Shapiro was talking about another aspect
just looking at logic programs there's a
certain elegance to logic and and logic
programming that's you know hard to
quantify exactly but I think when you
look most of us can look at logic even
if we don't understand everything about
logic programming we look at some of
these you know nice solutions and say
wow that's that's really great and it's
a way of way of just recognizing simple
simple expressions in the power behind
that logic programming now that comes
partially from the idea we have
declarative semantics right logic we've
been you know thinking about logic for
hundreds of years
we have a sense of what it means to
express something in logic or experience
in mathematics and science and computer
science logic is very important and we
accept that as a way to kind of explain
ourselves you know to the rest of the
world and some days so it's our common
common language so if you have these
declared semantics you have an idea of
what your program really means but of
course it's important to be able to
execute that program so we can take that
same program where we are just talking
about what's true in the world what do
we know and we can run that program we
can ask queries and get answers so we
have a procedural way of interpreting
the program to me that's that's kind of
the the core idea behind logic
programming is that we have this duality
of a natural kind of logical
interpretation we understand the meaning
of our program kind of independent of
any any you know computer or running it
but then we can also just take that
express you statement of our problem and
get results okay so that's very powerful
and Shapiro is saying you know that
duality is kind of a key concept
throughout all kinds of problem solving
we like to take problems transform them
and say well this problem is really like
some other problem that we understand or
we say this this statement can be
interpreted in multiple ways and we're
looking for useful dualities and
computer science and logic programming
is one of those kind of special cases
where we found something where we can
take our declare of semantics and run
those programs it's also once you get
something that works in a logic program
it's very flexible as Dan Friedman likes
to say you can run you can run your
program backwards okay that's that's
something especially you can't find
anywhere else outside of logic
programming then the last item I have
here is
verification by proof you know for years
and years programmers have wanted to
prove that their their programs worked
and people put a lot of effort into that
now it turns out of course that's that's
a hard problem you can't really do that
in general you can't you can't guarantee
that your Prolog program will terminate
but there are areas you can prove you
can prove some things some things are
true because we have a logical
specification we have a chance to prove
so that's why I say maybe there are some
some areas some some areas that you just
can't handle so anytime we talk about
proof I'm always reminded of the Don
Knuth quote he sent some solution I
figured what it was but he said a
solution to a colleague and he had a
little note be aware of the bugs in the
above code
I've only proved it correct not tried it
so I think that's something only Don
Knuth could say all right so now I'm
gonna switch gears a little bit and try
to bring in a little bit more of the
history and what was going on around the
time when I was learning logic
programming so this is the cover of book
the fifth generation
and the fifth generation was book
subtitle artificial intelligence and
Japan's computer challenge to the world
this was written by ed Fagin Baum Pamela
quartic and 1983 so a little bit about
Edie Feigenbaum background whose press
are at Stanford whose founder of the
knowledge systems lab he was a Turing
Award winner for his AI work he founded
some companies in telecom and technology
he's really well-connected in the
government industry so he's I don't know
very very important an influential
person around AI and and computers
science in general so he was one of the
authors so people pay attention to what
he writes I think he was writing this
book really aimed at the layman I think
probably aimed like American kind of
government officials and he had to you
had an idea that they should know
something about what's going on in Japan
so the fifth generation now when
computer science scientists hear about
anything like fifth generation what's
the first thing you think of you try it
I think you're probably saying what were
the first four generations all right
okay so I'm not going to say right now
because I'm hoping our Alan dipper is
going to be having another trivia
question later and maybe I can win a
book but you can you can think about
that and we can talk about that later
what were the first four generations so
the fifth generation project Japanese
government sponsored this project they
have the government department called
MIDI or the Ministry for International
Trade and Industry so that helped for
Japan that was kind of their their way
of setting Industrial Policy and you
know Japan had been very successful in
steel and automobiles and consumer
electronics they done you know amazing
work in overtaking America in a lot of
respects there and now they were setting
their sights on creating a whole new
generation of computers so this was
going to be based on parallel hardware
they adopted logic programming so Prolog
based software they were all in on logic
programming now this is really a
different different way of looking at
the world they said well we want natural
language interface to our computers
right Japanese that you know didn't work
as well on keyboards to say say like
English so they wanted to get beyond
that that issue of you know typing in
the computer weird I use natural
language and Feigenbaum talks about
their approach saying we have a
knowledge information processing system
or kips so we're stepping beyond just
you know computing just with numbers you
know
you know a lot of programmers were just
Fortran programmers at the time we're
we're gonna deal with knowledge so that
that still is a little bit of an open
term but but it was the idea is we're
gonna leapfrog everything that the rest
of world had done so now this is a
diagram copied out of his book a picture
out of his book and it's a little
distorted it might be hard to read so
I'll just say at the top was the natural
language interaction they also of course
you know can do speech pictures
basically anything you want it you can
imagine right well we'll throw that on
top then kind of the this just below
that the top half of the diagram here is
all the software they're gonna do now to
me the interesting part is they were
doing the the lower half of this diagram
is all supposed to be hardware based so
they were gonna have you know a Prolog
machine okay so and and some kind of
hardware that was specially made to
handle relational database interaction
with their Prolog so this is very
ambitious at the time you know we were
we looked at we were used to having
specialized Hardware so so like I had a
symbolics list machine and there were
several different vendors of list
machines so that were custom built for
Lisp so it's it's not not so strange
that they thought they could build you
know they wanted to build custom
hardware for Prolog okay now the world
has changed of course we don't we don't
think about doing custom hardware now
for our programming languages but that's
their model back then and at the bottom
and we say VLSI architecture so that was
that was still kind of new back then
that okay we have these big integrated
circuits so they were gonna build fancy
hardware and it was going to be
specialized for Prolog so this
initiative you know had mixed reactions
around the world
Feigenbaum saw the u.s. falling behind
what the Japanese were planning to do I
think that's real reason he wrote this
book was trying to wake up
America that you know something's
happening here we're having a challenge
from Japan and we really should do
something else here in America from
reading the book I get the impression
that maybe he talked to IBM and was
disappointed that IBM just you know
didn't care about what was going on
yeah IBM was on top of the world then
and there they didn't see any reason to
worry about all this fancy logic
programming right they were just worried
about you know shipping their next
generation of computers the list Packers
I knew were really skeptical and I think
this is a natural thing if you're you're
into one technology you think you can do
anything you need to do and that
technology you know somebody else says
they're gonna jump past you because they
have something new something better a
lot of times the initial reaction is oh
yeah that'll never work I have I have
what I have and I'm happy with Lisp so I
don't think prologues and take over the
world but the Prolog proponents were
really excited about this this was their
chance they you know they had been
working for years I guess Prolog started
around 1972 we're now into the 80s and
you know they felt like this was a
chance to really validate their take on
how to program how to do computation so
people were excited there are a lot of
kind of leaders in the field I know
Shapiro consulted Feigenbaum consulted
with the Japanese so a lot of the top
programmers Prolog programmers had some
connection there but in in Shapiro I'm
sorry in a firebombs book about the
fifth generation he said even before the
Japanese had announced their project
Europe had been cutting back on funding
for pure science and they really weren't
in any any position to respond to what
the Japanese were planning to do and
Feigenbaum thought that that the West
and America in particular needed to do
some kind of response but Europe wasn't
gonna do it and some of the top prologue
and actually come to the US and we're
continuing their research in the US
because they they didn't get the funding
they needed in Europe but so in the u.s.
you know DARPA was in charge of most of
the funding for computer science
research and well I'll say is DARPA was
kind of changing their attitude towards
AI and we had the AI winter's coming and
maybe it already started to pull back on
funding I didn't really understand this
at the time but but it did have it did
really have an effect on what we were
doing kind of in the research community
that DARPA wasn't there to give us as
much money as they used to so there
would say as far as I can tell there was
not a any big coordinated response from
the US or Europe addressing what was
happening in Japan and then the plans
for Japan and I think Feigenbaum was
disappointed about that so far as I know
the only concrete steps that were taking
at 5:01 wrote his book people talked
about it a lot and a few people like me
decided we should learn prologue just so
we know what was going on so now we're
to switch gears a little bit and talk
about this paper it's kind of famous or
maybe even infamous generate a lot of
discussion called the development of
logic programming by Carl Hewitt and I'm
talking about a version I found that
from 2008 the subtitles what went wrong
what was done about it and what it might
mean for the future so it generated a
lot of response and it was critical of
what was going on logic programming
okay so who's Carl Hewitt I'm gonna have
to speed up here a little bit but he's
famous AI programmer for he done the
planner language back in 69 so that was
a procedural embedding of knowledge he's
also famous for developing the actor
model of computation and more recently
he's been working on a system called rec
logic that I don't really know all the
details about that
maybe it'll pay off down the road he's
now a visiting professor at Stanford so
there's a quote from Hewitt talking
about prologue prologue was basically a
subset of planner that restricted
programs to clausal form using backward
chaining and consequently had a simpler
more uniform syntax that's kind of a
backhanded compliment for prologue it's
they're kind of like what I did but not
quite as good but the the prologue
people had a response to that this is a
quote from the birth of prologue another
article you can find on the web
the lack of formalization of this
language talking about planner are
ignorant of Lisp and above all the fact
that we are absolutely devoted to logic
meant that this work had little
influence on our later research so I
think in the academic world that
constitutes a zinger so so Hewitt in the
end the prologue people didn't see the
world you know the same way and it
really bright people with a different
outlook on on how to handle logic in
programming so Hugh I have to speed up a
little bit here so here not talked about
his planner system and and said ok so
Prolog is maybe a more controlled
approach but you know he had problems
there now this is the this slide here is
you know we could spend an hour talking
about what went wrong and this is from
Hewitt's perspective he's critical logic
programming I think it's worth you know
all of us advocates of logic programming
to to talk a little bit about the
criticisms of logic programming his
first item he says clausal form hides
underlying structure of information and
to me this is a direct assault on logic
this is saying ok things that I know are
logically equivalent he's saying that's
not really the way humans reason that's
not really the way we think and that
that's you know I had a bad reaction
when I first read that I said no no no I
can't accept that you know don't you
know how hard I work to understand logic
and now you're throwing it out the
window so that's a difficult one I would
say I want to keep logic it's important
to me
I have to have to say that the rules of
logic still work I just have to work
hard to make sure that I I stay within
logic and he goes on to say that
practical domains of knowledge are
inconsistent now this is like saying you
know you can't handle the truth this is
a this is this saying real world doesn't
admit to being described by logic
because you know we're just not good
enough at understanding our problems and
I I want to say there's some truth to
this okay this is a maybe we'll call it
a pitfall I'll accept that there's a
there's an issue here
but I don't want to give away logic I
think the logic is too important I think
we can spend some time engineering and
working on our problems to understand
and make them work within logic so we
have to we have to accept that there's
an issue here but I think we can get
past it and I think it's probably
important to keep this in mind when
we're working on our logic systems we
can't afford to be inconsistent right
and then the last item was proof by
contradiction is not sound sound rule of
inference for inconsistent systems so we
know that we have to we have to be
consistent we can't do anything in logic
programming if we're not consistent so
you know he would saying you know big
systems tend to be inconsistent right
people develop different modules
different ways and we throw that all
together and maybe maybe it just doesn't
work so I think we have to address that
from the engineering point of view but
this is a serious issue and there could
be a lot more discussion about that so
my take on what what he's getting at is
and I've done this I built logic systems
and it's like building a house of cards
sometimes you know it can be it can be
brutal it can be easy to make a mistake
and the whole thing collapses so this is
this is an engineering concern we have
to work hard to avoid our brittle
systems and some of that might be
keeping avoiding throwing everything in
to one huge logical database
I mean that that's I think where you get
in trouble because you can accidentally
change things in one area that somehow
affect other other areas so we'll see we
maybe we can be more modular and I think
Cameron the Canon Mini Cameron approach
helps you maybe it'd be more modular
alright so now getting back to this is
Hewitt talking about fifth generation
project so he's using this I'll just
make this fast he's saying quoting
robert kowalski about how great
prologues gonna be because it's it's
powering the fifth generation project
and this is a way to prove the unifying
role of logic programming qual ski says
computation can be subsumed by deduction
and Pat Hayes quote computation equals
control deduction so here it disagrees
he wants to handle maybe he's working on
a weaker form of logic that he thinks is
is closer to humans reason and he says
ok well let's take the fifth generation
as the test case can logic really do
everything can it be everything for you
you're only programming language is
logic programming and of course we know
that the fifth generation project failed
I have some other reasons for that
listed here but Prolog took the blame
and that's that that kind of hurts right
because this was a big system we were
Japanese were betting on Prolog to power
their system it didn't work so a lot of
people just concluded well I don't want
to I don't want to mess with that logic
programming it's you know it didn't work
for the Japanese why should I bother so
I think I think we can get past that
there are lots of other reasons that the
fifth generation project didn't work and
maybe you know let's be honest maybe
logic programming shouldn't be your only
programming language but maybe maybe
there's another way to look at the get
the benefits of logic programming
without being all in on logic so I had
some yeah even though that we had a
failure of a fifth generation project
there's still a lot of things that logic
helped to inspire and you can run down
through this list
lots of
lots of success here in specialized
areas but the last item here data log
data log was a simplified Prolog and
that has kind of made a comeback it
simplified a guaranteed termination had
some simpler limits on what you could
express but it's been really popular
among database people and we know now
here des Tomic has adopted data log Mike
Michael focus gave a talk a strange loop
about the rebirth of data log so I hope
someone's live tweeting right now and
saying focus just got a shout out at the
cons okay so I'm waiting for it I
haven't
I wasn't that strange leap I haven't
seen his video but I saw his slides so
it's definitely worth taking a look at
data log now Haskell internal is
functional program but internally it it
uses functional programming I'm sorry it
uses logic for the type inference so I
have to move along quickly here how now
the big question was a challenge was how
why should we learn logic programming
and I want to say that closure could
help answer that question why you should
learn it we have a great open community
here
David Nolan's done some really great
work bringing core logic to closure
functional programming I want to say can
be a good host the Mini Cameron has
already shown that you can do logic
within functional programming so your
functional programming your your your
kind of control and all your common
needs for programming can be done in a
functional way but you can have a part
of logic interacting with that and we
all know the value of value of values
the other special thing about closure is
that it runs everywhere plus the browser
so you know if you're if you're doing
research on logic programming and you
want the world to adopt some of your
ideas maybe come to closure and show off
all these great things you've done also
I think concurrency can can be important
so in other ways about how we can meet
the challenges just awareness people are
getting exposed logic programming just
hearing about it here at the cange and
among the closure community
I think we need to prove the usefulness
to engineers all right
so we're a lot of a lot of people in
this room are just interested in
technology and exploring and that's
great so we're gonna try out logic
programming but we have to show kind of
the rest of the world here's a big
system that works okay and and like
before I had this the benefit of seeing
some big systems that worked in Prolog
and so we're moving toy problems are
great for illustrating issues but we
have to get some some big solutions to
so people can see that and closure
adoption I think closure is jumping on
board of logic programming that's great
I think maybe we might have to do a
little work to make that a smoother
transition for people then I'll end here
just showing you pearl Fryar again
because I love this analogy that topiary
is kind of like logic programming so I
hope you take a look at that and give
logic programming a try okay so that's
all I had for today thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>