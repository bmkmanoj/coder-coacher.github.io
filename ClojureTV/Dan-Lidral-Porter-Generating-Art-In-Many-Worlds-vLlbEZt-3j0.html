<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dan Lidral Porter - Generating Art In Many Worlds | Coder Coacher - Coaching Coders</title><meta content="Dan Lidral Porter - Generating Art In Many Worlds - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dan Lidral Porter - Generating Art In Many Worlds</b></h2><h5 class="post__date">2015-04-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vLlbEZt-3j0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Dan Linville Porter I work at
puppet labs here in Portland and I'm a
huge fan of generative art so generative
art is art that has been produced in
whole or in part by an autonomous system
rather than directly by a human being so
for example this could be coming up an
existing text and rearranging it at
random bigger than new text you could
compose a song by interpret say the
digits of pi as musical notes or you
could build up an image by running a
physics simulation of charged particles
and tracing their paths and the reason
that I love generative art so much
especially computer generative art is
that I think it's a great way to build
your computer programming and mathematic
skills through iterative experimentation
in a process that looks remarkably
similar to goofing off and the iterative
experimentation part is key I mean this
is this is one of the things we all like
about Lisp
right we get a workflow that has a near
instantaneous feedback loop so it's
really easy to try something out and see
what happens and trying out a lot of
things and seeing what happens really
quickly is a great way to build
understandings and further than that
it's just it's really fun to do when
there's no down time you're never
twiddling your thumbs waiting for a
computer you just keep keep at it and
that's a great way to do a lot and learn
a lot so my agenda here tonight first
I'm going to introduce you to a
particularly rich vein of generative art
known as iterative function systems or
ifs is for short I'll show you how ifs
is are defined and used and introduce
you to my favorite ifs B diong ifs once
you're familiar with how iterative
function systems work we'll start to
play around with them by exploring their
parameter space and if you're not
familiar with that term I'll define what
that means I'll show you some problems
that arise when we explore the D on ifs
is parameter space in particular and
I'll present a tool that I wrote to help
with this problem the many-worlds
library so I don't have much time so
let's get right to it
iterated function systems so to have an
iterated function system
you need to start with a function
surprisingly enough and the salient
feature of this function is that its
domain and its range have to be the same
thing that is it takes inputs from some
set a and gives you back more members of
the set a as output and that's what lets
us iterate it take the output and feed
it back into the function as input all
of the examples I'm going to show you
will be two-dimensional ifs --is so the
functions will all be from r2 to r2
it's what mathematicians call r2 and
what normal people call a flat surface
so this is an ifs function the s ifs
function it takes one point as its only
argument a two vector with X&amp;amp;Y elements
and it returns one of three points with
equal probability that's what the rand
nth part is doing the first point it can
return is relative to the input point it
has half the x value and half the Y
value so it's it's halfway in a line
between that point and the origin the
second point it could return is again
that halfway point except this time it
shifted over by half a unit and up by
half the square root of three and the
last point it can return is again that
halfway point except a shifted
vertically shifted horizontally by one
unit so the three points are either a
halfway point a halfway point shifted
over and up or a halfway point shifted
entirely over so we're probably going to
get some sort of triangular structure
when we seed this with some value and
then run at thousands and thousands of
times and when we do that this is the
shape that emerges the sierpinski
triangle isn't that cool I think that's
really cool like all that we did not
done class
I didn't make this up all that we did
was define you know a really short
function like it's short enough to fit
in a tweet which is the standard of
shortness these days and we got this
we've got this really complicated
structure out of it and this is this is
why I like using ifs is a lot in
generative art is you tend to have these
properties that you get really
complicated behavior out of very
succinct function definition so moving
along to the DeYoung ifs this is the D
on ifs function again we just take one
point as input and this time we always
return the same kind of point we don't
have options but it's a little more
complicated now the components of the
point that we return are the differences
between some trigonometric functions of
the input points components after we
multiply them by some parameters a b c
and d and we're going to stick the
parameters to always be within the range
from negative pi to pi so if we were
going to go ahead and graph this we
don't actually know enough yet to plot
it I mean before with the sierpinski ifs
because we were having the components
each time we knew that the things that
we added to them were essentially the
limits and so that defined how big that
our graph was but with the DeYoung ifs
we don't know its range yet so we don't
know how big to make the space to plot
it and if we choose wrong then we won't
even see the ifs at all or we'll be
zoomed in on some part of it or it'll be
some tiny point at the middle of the
frame so we have to figure out what the
range is and we'll do that by
simplifying the equation a little bit
we'll replace the inputs to the
trigonometric functions with generic
variables alpha beta gamma and Delta and
you might know about trigonometric
functions is that no matter what their
input values are we're always going to
get out of them a number between
negative 1 and 1 so by replacing the
trigonometric functions with their mixed
max in the minimum or maximum outputs as
necessary we can figure out what the
ranges are so the maximum value will be
1 minus negative 1 or 2 and the minimum
value will be
negative 1 minus 1 or negative 2 so now
we can go back to our plot and we can
add limits on the ranges and we're all
set to go right well not quite we
haven't defined the values for our free
parameters we had those parameters a b c
and d in the function definition and we
can't do math on letters we need some
numbers so I'm going to just pick some
parameter values don't worry too much
about what the actual values are I just
picked them because I know that we're
gonna get a cool result out of this and
so we'll see this with a few thousand
random points and then each frame we're
going to add a few thousand more points
in the DeYoung ifs and see what sort of
state builds up
pretty cool huh
I mean I don't know what you were
expecting but the first time I saw that
the young ifs I was not expecting this
we have a really complicated shape with
a whole lot of detail in it and more
detail emerges as we continue to plot
more points we get some fine strands
that stretch around the range that only
show up after we've plotted it for a
little while and I just find this to be
visually beautiful now we've only made
one particular instance of the D on ifs
because we just picked some point some
parameter values more or less at random
and if we change those parameter values
then we're going to get a different
shape pretty neat huh I mean it's it's
got some similarities to the previous
shape there's there's still a bunch of
sine light curves that are composing
this but they're in a totally different
arrangement and we see we still see it
has the same property of having detail
that only gets revealed as we plot more
and more points and we only end up
plotting on the order of a few million
points at the end of this image if we
let this run for a long time with a few
hundred million or a few billion points
and we add in a color ramp based on how
many points have hit a certain pixel
then we get an image like this
and again all of this came out of a
really succinct function so let's take a
step back because we're about to go into
parameter space so what parameter space
is is it's the set of all possible
values of the parameters of a system so
in the diong system in particular we had
those four parameters a b c and d so
let's start building up our parameter
space we start with just you know a line
representing the value of the parameter
a and then once we add in parameter b we
end up with a square because we have two
degrees of freedom we can change
parameter a whether or not we change
parameter B but of course we're not done
when we add in the C parameter we're up
to three dimensions we have a box and
then when we add in the D parameter
we're up to a tesseract or a hypercube
which is what happens when you take a
cube and then you add and a whole bunch
more cubes off in this direction you've
never encountered before in your life
so we've only sampled from two points
within the DeYoung IFS is parameter
hypercube and in each point that we
sampled we saw a different shape for the
DM ifs overall and once we're aware that
we're sampling points from parameter
space one next approach that you might
think of is well why don't we define a
path through parameter space rather than
individual points we'll define like a
Bezier curve or something because that
is easily extendable to four dimensions
and then we can move along in parameter
space and in each point in parameter
space which will be a frame of our
animation we'll go ahead and plot out
the D on ifs and see what happens as we
move through parameter space hopefully
we'll see the D on ifs changing in some
way as well so I don't know about you
but thinking in four dimensions kind of
makes my head hurt so we're gonna pick
some concrete values for the C and D
parameters which collapses our parameter
space back down to two dimensions which
is a lot easier to grasp so now we
animate along the a this line then the a
B plane of parameter space and we see
that the D young ifs animates as well
and it animates it's really great and
kind of surprising that this happens
that we get a smooth animation in the D
on ifs when we do a smooth animation in
parameter space when I first found this
out I made a whole bunch of videos like
this one this is a with a few more
points some nice blending modes and at a
higher frame rate but the basic idea is
the same now when I made a bunch of
these videos one problem that I ran into
is that you can find a lot of paths
where the dianna ifs does something like
this it compresses down and compresses
down and compresses down until the
entire system just is in a tiny little
point or line and that's not very
interesting to look at so now we have
this problem of like how do we find the
good portions of parameter
space and how do we stay in them and
avoid these boring portions where it's
not very interesting to look at well for
reasons I won't go into depth about here
some mathematical characteristics of the
Dione ifs make this a little hard to do
it defeats a lot of simple heuristics
that you could come up with there are
always some points tending near the edge
of the images so it's hard to make a
bounding box roll around all of them and
more complicated heuristics like say Oh
75% of the points are close together and
we know this isn't very interesting well
that requires sorting the points
geometrically which gets to be very
expensive and what I was using these for
is I was in college and I was doing
visual performances at dance events so I
was trying to project something
interesting on the screen 30 times a
second responding to the audio input and
these more complicated heuristics
interfere you can't do that at 30 times
a second especially because you're
trying to sample as many millions of
points as possible in order to get some
good detail into young ifs while you're
doing this live so that led me to come
up with the many-worlds library and the
basic strategy behind many worlds is
that the most reliable way to know if
some path or point in D on ifs parameter
space is going to be visually
interesting is you kind of just have to
try it out and see if it is and
many-worlds lets you do this by managing
the curve that's used when we're
animating the DeYoung ifs so we have
some curve we're moving along it within
our sketch within our program but that
curve has some fixed length and
eventually we're going to get to the end
of it and then we need to pick a new
curve and so what many-worlds lets you
do is allow us to preview many possible
new curves and select the best one at
which point we can move ahead up until
the next curves end point and repeat the
process over so when you get many-worlds
all set up you get a control console
that looks like this one this started
at the top you have some timeline
controls that allow you to scrub through
the timelines of all of your different
potential paths or worlds and you can
see how each world responds at each
point in time and when you so you can
scrub forward and backward you can just
play you can change the speed at which
you're moving through time and once
you've found a path that you like the
best you can go ahead and select it so I
think right here I'm about to select the
middle one and once that happens it
resets all of the other worlds to have
used that point retroactively Lee and
then you can move along ahead up until
the point which they've all reached the
end of that curve and each pick
different new ones and again diverged in
their behavior now I want to close with
some salient points about how the
many-worlds library works and the first
is that it's just a quill library so if
you have some quill sketch and in its
state is easily reducible to some
collection of numbers it should be
pretty easy to use many worlds and then
you get this control console with the
ability to interactively explore the
parameter space and build up cool
behavior incrementally for free and the
second is that all of this is happening
over HTTP so you could use this in live
performance by having say one computer
that's running the presentation world
that's actually hooked up to the
projector and you can have another one
that's running all of you different
preview worlds and they're communicating
over HTTP so you can do a lot of preview
generation without worrying about
bogging down the live performance and
finally this I like to think that it
continues in the tradition of Lisp and
in the vein that it it facilitates
interactive exploration and it lets you
do things incremental II like before I
thought of this I would just generate a
lot of paths and then after the fact go
through and see if each one was
interesting or not and this lets you
build up one incremental e which is a
lot faster so the many-worlds library
you can find up on github under my
github account which is a periodic I'm
going to be at
the party at puppet labs later tonight
so you can talk to me there if you have
any questions or if you just want to
talk about generative art which I always
love to do and you can also reach me on
Twitter or my handle is at a periodic if
that is more your jam so I hope that
this has been entertaining and maybe
informing and have a good night</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>