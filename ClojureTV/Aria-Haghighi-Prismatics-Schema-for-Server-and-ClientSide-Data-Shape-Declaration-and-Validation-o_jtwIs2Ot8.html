<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Aria Haghighi - Prismatic's Schema for Server and Client-Side Data Shape Declaration and Validation | Coder Coacher - Coaching Coders</title><meta content="Aria Haghighi - Prismatic's Schema for Server and Client-Side Data Shape Declaration and Validation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Aria Haghighi - Prismatic's Schema for Server and Client-Side Data Shape Declaration and Validation</b></h2><h5 class="post__date">2014-01-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/o_jtwIs2Ot8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah hi everyone as Alex mention my name
is Arya I'm the co-founder and CTO
prismatic and today I'm going to be
talking about schema for data shape
declaration validation i'm going to try
something a little different this is
actually a smaller group than like a
large University course and I'm used to
taking questions in that environment so
I'm actually going to try to take
questions as I go and we'll see how that
works and it might have to get shut down
um so let me give you a brief summary
about what I'll be talking about today
I'll be talking about an open source
library that you can go grab today
called schema it's at that URL up there
if you go to the it's it's shorter than
the words if you if you go to the
prismatic github page you'll see tons of
closure libraries schemas one of them
and schema place with some of the other
open source releases that we have I'll
talk about that a little bit later um
there's a lot of different goals of
schema but kind of the primary simple
one sentence answer is we were trying to
get a lot of the benefits that you might
get from a statically typed language or
some contract like things as you saw in
the previous talk with a little bit less
of kind of a hassle that we did
encountered with other with other
similar tools and I'll go into depth
about this i think schema occupies kind
of a weird space where it's it isn't a
type thing it's not quite a contract
thing but it plays a lot of different
roles so um the roadmap for today's talk
will go as follows i'm going to first
talk about why we bothered to write this
library what kind of pain points were we
running into and and why did we actually
think schema would address some of those
next I'll actually talk about the the
purpose what's kima actually does what's
his actual function how do you actually
use it in practice I'm gonna do a whole
parade of examples of schema just so you
can get a flavor for the variety of
things that you can express with schema
and finally I'll talk about some
extensions of schema which which I think
are really exciting and one of the best
things about it is that you can do
things like automatically generate
objective-c classes from schema and I'll
talk a little bit about that towards the
end of the talk so first let me start
with the eternal question why why bother
writing yet another
library and I think it's always
important to you know before you tell
people to use anything explain to them
why we bothered internally and prismatic
to actually build this thing um and so
the story goes something like this you
know prismatic has been using closure
since it's early days actually in the
first cons I gave a lightning talk on
infer and at that time secretly
prismatic was being worked on enclosure
and so we've been using closure you know
for over three years we've been using
closure script and production on the web
app for the last year and so closure has
been great for us it's been it's been
extremely powerful and the initial team
of people who were using the language
had all used the language previously and
it was extremely productive for us we
were able to churn out ideas really
quickly it was it was fantastic and what
started to happen is as the engineering
team grew you know 27 people now we
started running into some problems right
and so the all the newer engineers are
I've trained a lot of people in closure
now and a lot of these people are people
who you know have never seen closure
before the problem wasn't that closure
was difficult to learn or had a steep
learning curve because everyone learned
the language relatively quickly the the
problem was they would all go off and be
able to write simple programs and
understand things the problem was
actually reading and understanding a
large closure codebase that's where we
started running into issues with newer
engineers and so I want to talk a little
bit about what it's like to read you
know read fresh closure and you know the
kind of stumbling box and productivity
issues you might run into so um here's a
function I've emitted the actual source
of the function and when you're when you
come into a fresh namespace and you want
to understand what this thing does you
have to ask yourself what does share
counts in this particular example what
kind of data is that what does that look
like what does this updates thing even
mean what is this thing actually
returning now on my next slide build I'm
going to actually show you the source
code and it's not a complicated function
but I want you all to i'm going to take
30 seconds I can only people read it I
want you to be cognizant of how long it
takes you on so you understand what
those data structures look like
why don't people are raising their hands
as soon as they recognize it just like
it a sense of the distribution of
recognition time
a lot of questions okay that's that's
that's good enough and so whether or not
you actually you know you got to the
what this this function is trying to do
the point is it takes a little bit of
time and this is actually a relatively
simple this is a relatively simple
function I'm things get much more
complicated when you're dealing with
actual inherent domain complexity as
well as kind of parameters which aren't
just data structures but kind of
resources that are tied into databases
and all the kind of things that actually
happened in real production systems and
so you know what happens there what I've
noticed and I've spent a lot of time
watching just just watching a new
engineer going to go into a code base
and what where they actually spent what
they spend their time doing and a lot of
the times they're playing manual apropos
like the Emacs function so you know
someone will take a function which is
much more complicated than this that
ties in to kind of you know has some
parts of it as interacting with a
database and some of it is a an in cash
resource and again all the things that
you get in real production environments
and you know they'll they'll they'll
actually go and find call sites of this
function to try to guess and understand
exactly what the arguments are doing
right and sometimes that's not even
enough you have to actually go down
again and and and this becomes a real
nightmare right and obviously obviously
there's lots of ways that one could
imagine mitigating this problem but I
you know in reality you always end up
with this in my experience you always
end up in situations where people spend
a lot at least a lot to some amount of
their time doing this um and so this
brings me to talking about closure and
teams a little bit a lot of you know
closure you can be extreme you can be
very expressive enclosure and that's
actually great for writing it's some of
what makes it great to write can also
allow you if abused to write things that
aren't readable right that's not to say
it's any really different than any
higher ordered language I think a lot of
powerful languages have this attribute
where you can start saying things that
are fairly complicated and difficult to
read even if kind of the expressions
themselves are relatively terse and it's
important and on this is obvious anyone
who's actually worked in kind of large
software teams and built large code
bases but teams need consistent ways to
read a code base and communicate a
something
right and so you know you have to think
about what is it in an enclosure code
that lets you communicate what something
is actually doing is that the variable
names is it doc strings and and a lot of
those things you have to ask is how do
you make that consistent um and so you
might ask yourself and this is a
reasonable thing why not write a doc
string right why not write a doc string
why not name your variables more
expressively why not do all those things
and all those things are valid but I
think they have downside so again i'm
going to give people about you know 30
seconds or so to read this again and and
kind of raise your hand when you
understood the doc string and what the
data structure is being involved are
okay we said about the median of the
distribution so that's probably a little
that's probably a little bit better
right i mean i think for most people you
know it's you're always gonna at some
point have to look at the source code of
a function right that's just at some
extent that's unavoidable it's just a
matter of you don't always need to read
if if you if your response to something
is you have to read the source of
everything you work with then that's
never going to actually you know you're
never actually gonna get anything done
it's good to do that for crucial things
to understand them when you're deeply
working with them but at some point you
need to be able to understand something
like this without actually reading the
entire source and the doc string does a
reasonable job of that um there's a lot
of downsides using a doc string
obviously right and and this text is
actually again longer than the actual
function itself I didn't need to point
that out and so an adept closure
programmer an experienced one would
probably be better off with the function
than the doc string maybe me uh except
that the doctoring actually communicates
constraints that are not inherent in the
code itself for example that the for
instance that the share type has to be
one of Twitter Facebook or email or
whatever right and this is actually an
example from real code it's an example
kind of you know code that was sort of
rushed but you know not code that
someone SAT and did refactor it over and
over again and made really beautiful
which is not the case in a large code
base for everything you write um and so
there's there's issues right i mean code
changes faster than documentation
everyone i think that's something we can
all probably agree with to some extent
there is zero compiler runtime
validation right there's nothing that
actually ensures that the natural
language string you put has anything to
do with the codes actual execution
there's this other kind of subtle issue
and which is kind of within a namespace
or a cross across a code base there
these common data structures that you
use and you know not all of them can
easily be expressed by records
especially if they happen to be nested
for some particular reason and how is it
that you share kind of explanatory force
across docstrings of a namespace is a
little difficult you can say something
like it's like this parameter this other
function takes but then you've lost kind
of your local context have to go jump
and look at the doc string for that
function and again it's important to
kind of have as much local context as
possible being as context-free as
possible is useful when you're when
you're trying to just improve people's
productivity and
efficiency and there's this other issue
that's a little more subtle which is
there are many natural language
descriptions which describe the same
data structure so i can say i'm matt
from string to double i can say a string
double map blah blah blah blah blah and
these small kind of linguistic
variations don't seem like a big deal
but when you're trying to get towards
consistency it's actually really
important that you have you describe
things the same way and that there's a
single simple representation of these
things okay so that's why not a doc
string it and here's a question many of
you are probably wondering oh sorry
actually now we're going to talk about
what schema is and and what it actually
what it actually is trying to do the
exact thing that schema does so um here
I'm going to actually use schema to
encode some of the data structures the
shape of the data structures that were
used in that last example so here's a
bit of that doc string again that
everyone just looked at and now I'm
going to put a namespace up just so you
guys see we're going to use schema
schema works in both closure and closure
script so this is a little throat
clearing and now I'm going to take just
the share type part of it which says I'm
a keyword and I'm an imam of Twitter
Facebook or email and that will get
rendered like this right and so these
are this this this this schema is
encoding the same set of data that that
natural language string is intending to
encode right this says I'm a thing that
can only be one of these keywords and
kind of nothing else right this is all
straight forward you've all probably
seen enums and other languages before so
now let's let's actually take this whole
share counts data structure which is a
little more complicated so I'm gonna
here's the schema for the entire share
accounts i'll give people i'll give
people a little bit to actually just
read that really quickly and then i'll
describe each piece of it so um first
off there there is a thing here that
says i'm named so schema / name dress /
named and it says I'm along and I
represent a share count now the fact
that it's named the fact that its name
it doesn't do anything for checking
anything it's only for readable
validation errors it's only because kind
of when you talk about along the
function you want to communicate the
function of a law
rather than just its type and so later
on we'll see when we do validation that
we want to say oh you didn't actually
give me the right kind of thing for a
share account right um so this entire
map actually just says this just simply
in cozy idea that I'm a schema from a
share type which is itself a schema that
enum from the previous slide build to
along right and so this whole thing
actually in you know more or less
encodes the same thing that's in that
doc string and because these are simple
deaths you can actually use them in a
way that we'll see in just another slide
you can use these you know at the top of
the namespace to communicate these are
kind of the domain objects that we're
working with again you might say why
isn't this like a record and I'll just
point out that it's because it's because
of the the nested data structures here
this kind of stuff is harder to get into
records and i'll talk about records
again in a moment and what schema has to
do with those but really briefly the
entire the entire user data structure
yeah there's one more part the entire
user data structure is itself along that
that maps of share counts and again
we're naming the key in that map after a
user ID so let me go through this
example one more time with something a
little trickier what is what was it
updates the updates was a sequence of
triples of the user ID some kind of
share type and a delta like a count of
delta for shares and so all again in the
example portion of the slide I'll I'll
kind of walk you through how to build
these kind of things but here's what it
looks like really quickly again we'll
describe it again in more detail in a
future slide but it's basically encoding
that you have one long one share action
one long and there's descriptive names
for each element of that tuple and so
now I'll show you a schema defense Oh
schema defend does something that looks
a lot like a typed function but it's not
a type function and in fact the syntax
is similar so schema / stephane says
basically it works like definite that
it's going to actually you're going to
optionally be able to specify satisfying
schemas for all the parameters in the
return of the art of the actual function
so here this is saying I return a thing
that status
the user share account schema this here
is saying updates the parameter updates
is a sequence of the user share update
schema okay and so this this looks more
or less like like it's typed in fact i
think i think this symbol if i'm not
mistaken is the same as core not typed i
actually took it from using scala for a
while but um so yeah but that they
basically means i satisfy that means i
satisfy a schema okay and so now I'm
going to talk about validation so so far
everything I've told you about a schema
is that it's just describing data it's
just glorified formal documentation
which make no mistake is really valuable
I actually think the primary benefit of
schemas are even working you know one of
the things you get from a type system is
actual a kind of documentation that is
actually really useful for teams it's
not necessarily worth all the downsides
but it's certainly a benefit and I think
documentation is really valuable but but
scheme it is more than documentation it
will actually check things for you so
again we'll look at the share counts
again and what you can actually say is
you can say at the repple or wherever
you can say schema please validate that
the users share counts this schema
actually is happy with that data right
and so this is not going to work out and
but let me briefly tell you what schema
validate will do so scheme eval d
concretely will just return the value if
the if the value passes passes the
schema and I'll talk about how that
information is encoded a little bit
later and otherwise it's going to throw
hopefully an informative exception about
where exactly things went wrong and so
in this particular case if you've been
kind of paying if you've been looking at
the schema and the data it doesn't work
out and in this case you're actually
going to throw you're going to throw a
runtime exception because the innermost
the innermost share count is actually a
double rather than a long and so you're
going to get you're going to get an
exception that says the schema name
share count is not actually you didn't
give me an instance of java dot lying
long you gave me what's actually a
double all right there's actually kind
of a bunch of different kinds of error
validations that can happen this is this
is kind of the most straightforward ones
there's ones that will pinpoint at a
large nessa data structure exactly where
things went wrong
hmm but this is just to give you a
flavor of the fact that these things
will actually check things right and so
a little more about validation you can
actually you can actually just put a
single form in a test namespace and turn
on validation for every schema deafen
and schema def record which I'll talk
about a little bit later and what that
does and there's a very there's a
flexible validation policy which is in
practice what you actually I think often
what you might want you don't want to
check everything it's too expensive
especially since this checking is
actually occurring at the moment at
runtime but you can turn on validation
throughout your tests you can if you
want turning on globally you can turn it
on for individual functions you can
force a function to never validate blah
blah blah blah blah so there's there's
kind of a flexible thing depending on
where you actually want to check things
which in practice we found particularly
useful okay um here here's the question
many people are probably wondering why
have you heard of static typing I mean
this seems like a lot of what you're
doing there's core.typed there's there's
there's there are ways to get you know
compiles Gino traditional compile time
typing enclosure those things are great
and schema has some relationship with
that stuff that we'll talk about a
little bit later on but it's a
reasonable thing and as I alluded to
early you know types are actually useful
for some things right there there there
really they are useful for documentation
they're useful to compile time checking
they do things for you right there's a
reason why all those programming
languages exist but it's actually the
case that this isn't exactly what we
want right i motivated the beginning of
this talk not by saying I want compile
time checking throughout my entire
application what I really said is when
someone is using a namespaces is as a
library builder or a service builder the
client of a namespace I want them to be
able to quickly get in there understand
what they need and go build what they
want right and that doesn't inherently
imply types although types is one
solution to that um there's some there's
some downsides right I don't actually
want to type my entire program I don't
want to go and annotate all of the forms
that are necessary to check a namespace
at compile time and what I really just
want is is people to be productive as
quickly as possible and for there to be
Santa
about communication and some validation
where it's crucial and I'll talk about
where I think validation is particularly
crucial hint it like the previous talk
API endpoints is a great example where
you might want to turn on validation so
let me just briefly now i'm gonna i'm
going to have a slide where i'm going to
there wasn't room on the slide to
actually put a header um there's a
prismatic github repo that's called ends
practices which is kind of our
collection of what we've experienced
having closure and production and the
kind of practices that really work for
us and so I'm actually gonna walk you
through one about how we like to
structure namespaces particularly
towards that end of allowing someone to
come in and understand what's going on
as quickly as possible and so here's
what the the kind of you know schema for
a namespace looks like so here's an
example namespace so let's say we're
building some kind of matrix operations
there would be a part so I'm going to
use the term pragma I use the term
pragma force when I separate out a
namespace or a file I you know I get
that from objective-c land or whatever I
don't um there we have standard names of
pragmas and so one of them is actually a
schemas pragma which which basically is
a list of schemas which are relevant to
the interface of a namespace now you
know I'm not using the term interface in
any formal sense other than these are
kind of the the objects of the objects
that are actually used throughout the
namespace and are part of the the
functions that are meant to be that
cross a namespace boundary right and so
we will actually list all of those out
up front so that people when they come
into a namespace can understand what
kind of objects are being dealt with
their names these can also have their
there's a def schema macro that will
actually put documentation on them which
can be available in the metadata so you
can not only get what the structure of
the data is but what its intended
semantics are which is you know in some
cases and equally amor so important than
the actual structure of the data and so
in this particular example we're kind of
dealing with matrix machine learning and
so there's a sparse feature vector which
is just object to double and again again
I'll go through all the schema examples
you can do but this is basically
encoding a map from objects two doubles
two
and a labeled example is a pair of a
double and as far as feature vector and
so that's all great and then the person
who's writing the namespace can have all
sorts of functions that don't require
any scheme is whatsoever you're just
you're just writing normal closure code
you can choose to put schemas for
communicative reasons if you want to but
they're not essential and then we have a
thing called a public pragma and the
goal of the public fragment is to say
that these are the functions which are
meant to be used externally now this
isn't this isn't kind of traditional
packet you know namespace visibility
issues right it's not that you can't use
anything we don't use death and dash or
whatever we don't use any of that stuff
this is just the community it's just
it's just having a formal way of
communicating like these are the things
you're actually supposed to use and the
contract the the contract that we
enforce our name space there is is that
when you have public when you have
things that are in the interface of the
public part of a of a namespace that all
of those functions should actually be
either schema ties or they need to
return records or they can be type
hinted they have to be a thing where
someone can understand inputs and
outputs okay now the rest of the file
can do whatever the hell it wants to I
mean code review will will you know
drill out kind of bad things there um I
would actually say as a whole this is
one of the most important decisions that
having this namespace structure was
actually one of the most important
decisions for team productivity sounds
like a small thing doesn't sound like a
big deal but the mere fact that there
was an easy way to read this and under
and for all the functions that are meant
to be used you can easily get schemas or
def records or whatever kind of thing
that communicates what that object is
saved tons of productivity you know I'm
not quite prepared to go into like an
exact quantitative that i actually have
measured times on these things before
because I I do a lot of this but it's
super important and if you're working
with the largest team I don't know how
to define largest I think having
something like this is crucial so that's
about how we use schema so to connect up
with the last slide the point there is
that this isn't typing we're not this
namespace isn't going to have all of the
things which are used by the public
functions the quote-unquote public
functions are not going to have
annotated forms and everything we're not
trying to compile time check this thing
right we have will have tests on things
and and we don't we don't necessarily
certainly think in a lot of cases that
compile time type checking makes sense
but again this is for communication
right this is for teams to be more
productive um so another nice thing in
the design of schema which we'll talk
about a little bit later is we were
interested in doing more with schema
rather than just formal documentation
one of the design goals was to actually
use these descriptions to do other
useful things so I'll give you a quick
example schemas are also data right so
this was this was something that we
thought about from the start because
we've had a lot of frustrations with you
know I've used quite a bit of you know
Scotland type languages and I like all
those languages but they're there I had
a lot of issues with using them and
ultimately that's why closure is my
favorite language is because there's
things that it gets right that other
languages don't um and so here here's an
example of kind of a simple schema for a
document saying prismatic and here it's
saying I'm I'm a doc I'm the map that
has these fields and these are kind of
the what the value schemas are and this
is what the server thinks a document
looks like and it's got things like
features which is some you know crazy
machine learning thing or or fetch
statistics which are internal metrics
for when this thing was fetched and how
slow and blah blah blah things that a
client doesn't care about right the
client might only need for instance to
know about the title and the date right
and so um and so what the kind of thing
that we would do is we want to we want
to have a schema for what the
client-side doc looks like right so the
server-side representation has some
schema the client-side doc is is
basically we just want to take these
fields right and so because schemas are
just data we can actually just say this
and this is a schema you can use it in a
schema ties deafen and you kind of
actually get to you know in some sense
again I'm speaking kind of you know is
an illusion you can kind of like do data
structure operations on your type
declarations so to speak right i mean
this is this is the similar idea you can
actually just say select keys on this
and just give me the title on the date
and there's other cases where as you'll
see later on schemas can encode things
that that traditional type systems
usually can't things like how long the
string is and and these other kind of
more contract like things and so you
know you can take something and say the
backend doc has the the text of the
articles of string the client-side doc
for legal reasons need to be needs to be
a
string which is at most you know 200
characters or whatever right which is
which is important to make sure we don't
ship down kind of the entire publishers
content or whatever and so you can you
can say things like that and and if I
were to describe scheme a little bit it
kind of sits on the continuum between
looking a little bit like types but
actually having some of the facilities
of traditional contracts and so schemas
are data and that will come up again in
the extensions part of the talk now
there's there's a long parade of
examples that I'm that I'm going to go
through so a schema works in both
closure and closure script and there are
some kind of base cases of schema so you
can say something is a number or
something as an integer you know this is
all you can do that's that works in both
closure and close your script if you're
on the next slide I'll talk about some
platform stuff but this is kind of
generic you can say I'm a key word right
that's actually what Keanu Reeves will
say like the matrix thing so so strings
so you can say something's a string and
so these are all kind of like atomic e
element checking things and you can say
something is anything right that this is
a schema that is kind of like loose and
free and so these things work in both
closure and closure script so the reason
why we have the funniest / string and a
slash number rather than just using kind
of Java types and I'll talk about that a
second is because like some of these
schemas are actually shared the actual
scheme is some sales are shared between
the closure in the closure script code
and so when you want to have something
that works in both environments you want
to use these kind of shared base cases
I'll talk a little bit about platform
dependent schemas right so in enclosure
land you can actually have any class be
a schema which encodes I need my data to
be an instance of Mike lot of my class
right so that's that's pretty
straightforward it's a little bit
different in JavaScript land in in
JavaScript land you know you want to be
able to say the element that you gave me
its prototype function is is is I come
from that prototype function right
because JavaScript parcel differently
and so you could say for instance if you
get an element by ID enclosure script
that's going to validate against Jaya /
element for instance okay um most of
everything else I will tell you and I'll
try to draw out the points where they're
not everything else is basically the
same between closure enclosure script
there's just these platform dependent
things that they are useful sequence
schemas so you guys already saw a
sequence schema but I'll go through a
few examples um if you want to say I
have a homogeneous sequence of strings
you you just merely say um this is a
vector of s / strings again um we're
using the vector notation for like
visual you know clarity but this doesn't
actually mean I have a vector of strings
it means I just have a seat I have a
Sikh of strings so let's say you wanted
to say I have a pair and string a number
right so if you wanted encode
traditional tuples again you guys
already saw this before but this s / one
says I expect a single element in a
sequin I match against a sequence single
element in a sequence and so you would
encode a pair like this again schemas
are just data so if you there is in fact
I think an s / pair which will which
will do something like this with a
single simple call but this is just
again to you know for the purpose of
learning you can you can write schemas
you can you can take a complicated
structure and write a schema that
generates that so if you wanted you know
to put these two ideas together if you
wanted to say I have a sequence of pairs
right then you would you would write
something like this this starts to get a
little messy i would i would argued want
functions which generates schemas at
this point to encode stuff like this but
you know it all works out okay um
function schema okay great so on there
are actually function schema so going
back to this old example that everyone
knows and loves and remembers this is
when you have a schema ties function you
can actually act ask for its function
schema right so you can actually say hey
what kind of what kind of function are
you and this funny arrow form at the
bottom you can actually you can ask this
thing for its schema and the the
right-hand side of that expectation is
that the first argument is the return
type and the second and third argument
of the parameters of the function so on
this is actually useful in a quite a few
places how many of you've used our
plumbing library and graph and stuff
like that so like you can actually if
any of you've used them enough you've
run into this issue where you need to
actually see like what the function
contract is of the entire thing and so I
think a recent we've recently updated
all the graph stuff to use schema so you
can actually have some complicated
computational graph and pull out the
function schema to understand kind of
where everything is going and that's
super useful the way that we use graphs
are in fairly complicated contexts like
all of our web services or graphs and
you know it's useful to be able to pull
this information out there's also other
uses I'll talk about with respect to
court typed in a moment here's a kind of
a little more of a fancy schema example
let's say you wanted to accept a
sequence that starts with a string it's
followed by an optional keyword and
followed by any number of numbers right
so there this is like command line
parsing or something like that right you
run into a lot of cases where there's
you know there's some fixed number of
elements or whatever and some of them
are optional and so here's what that
schema looks like you say I i expect a
single string an optional keyword and
then any schema at the end is
interpreted kind of like a splat right
and so you can imagine encoding kind of
regular expressions of arguments and
things like that and that's how you do
stuff like this there's actually tons of
places where this is actually super
useful to communicate kind of how what
kind of sequence of function expects
okay map schemas so you guys already
seen map schemas but I'll go through a
handful more examples just to clarify
what's going on if you want to encode
kind of a simple map like string the
number that's what that looks like if
you want to encode a nested map that
just looks like this and this is all
pretty straightforward an interesting
choice that we made that I think in
practice is really useful is when a
schema has a keyword an actual instance
of a keyword as one of its keys that
means you must have this key right and
this solves kind of one of the pressing
you know there's tons of places in the
code base where we D structured map
arguments and a key had to be present
right even if we were using records or
whatever with optional keys we had no
way of validating kind of like if you're
going to have this key it needs to be a
string or whatever right there was tons
of
kind of boilerplate e-type code to
communicate that and so here you can
actually just say for instance I'm a map
that must have an a string and if I have
a B string it needs if I have a beaky
rather it needs to be a string and so
you can communicate that relatively easy
that way and this has been super useful
for kind of just shortening up the
amount of code that we have for
validation ok um now we're going to get
into territory where schemas can
represent things that are hard to
represent in a lot of type systems right
so any function can actually be used as
a schema which basically has the obvious
interpretation of data which passes
which have returns at ruthie value from
that function will pass the schema so
you can have a prime schema which will
only work on on prime would prime
numbers right and so here you get into
the territory where in contrast to like
a type system there's no guarantee if
you ask if you ask a schema to validate
that will finish in finite time right
because you know just for fun go home
and try to encode counter-examples to
the twin prime conjecture as a you know
you can do that and validate might take
a while to return you should go have a
coffee but um you can start saying you
can say these kinds of things that are
difficult and we actually make heavy use
of this it turns out for a lot of the
API endpoints we have constraints that
are not you know necessarily just type
constraints like this string needs to be
at mostest long otherwise we're gonna
get sued right or or you know you can
say things like oh um this the sequence
needs to be a certain amount so I
believe in the previous talk there was
an example where you wanted the list of
cities to be within some range and so
that's an easy thing to quickly to
quickly check and add in the system okay
um schema algebra everyone wants your
algebra right before lunch right so you
can you can say the obvious things like
I satisfied to satisfy the intersection
of two schemers or both schemas where
the data validates both of them and so
for instance returning to an earlier
example you know I told you that the
vector notation for sequences really
means I'm a sequence of an element and
if you wanted to say I must be a vector
of an element this is this is how you
would do that if you wanted to say you
know not that I ever recommend anybody
for any reason to do this
don't ever do this but if you wanted to
say I'm I'm either a homogenous sequence
of strings or integers right I you know
there are a few places where stuff like
this happens then you would say I'm
either a sequence of strings or sequence
of integers right and the the this will
actually do exactly what you expect so a
s / maybe is I'm either nil or if I'm
non nil than I need to satisfy the
schema right and from these examples you
can see how to do those two things right
if I told you you needed to write a
schema which is a sequence of a
heterogeneous sequence which can each
element is either a stringer along or
whatever you could see how to do that
and be straight forward okay schema
record so I alluded to this earlier so
you can we can do things like have a
slash def record or schema / def record
which does exactly what you'd expect all
the bass keys gets schema satisfies a
schema and there's actually more going
on here you can actually provide schemas
for the optional keys as well which in a
couple cases we found it being
relatively useful so and this is exactly
what you expect right so if you if you
call s / validate with the right things
nothing's happens and it'll throw an
exception if you actually try to make a
record that actually violates that
actually violates a schema um the other
thing that's really cool here is you can
optionally use Zack Tommen's a Potemkin
a library to actually do the deaf record
generation and that will support like
primitives which you know we found for
performance we weren't using records in
a couple places because we needed you
know we need reliable primitives and
some of our records and with a Potemkin
we can do that the other thing that we
do that we ran into is as long as we
were kind of making a new def record
macro we we also worked on some of the
factory functions so um you know we
there's there's a kind of different
factory function which is generated here
which is actually much faster you know
probably just because that I don't know
how much it's been optimized or not but
it's a lot faster at least for the use
cases we've run into and so for us we
were running into places we're trying to
make a lot of Records and and and the
generic map to record name function was
a little slow and so the s / Jeff record
makes a new one that that seems a lot
faster and you can go check
the implementation to see what's going
on there there's also a strict map to
record which will actually throw if you
try to provide extra keys you can also
encode this via the optional thing so
there's a couple record extensions that
we've personally found useful and
allowed us to use records and kind of
more performance critical environments
okay and finally on the last part of the
talk extensions so as I said schemas are
data you can do lots of interesting
things with them so Stephen schemas are
extensible at the core schemas just a
simple protocol right the scheme of code
itself is this protocol a bunch of
implementations for kind of closure a
bunch of closure types like you know a
persistent vector etc etc and the
protocol just has two elements that I'll
let people read while I kind of jabber
on there's the the check the check
element of the protocol which just is as
you'd expect something which doesn't do
anything if you work if the data works
against the schema and otherwise it has
to build a certain kind of exception
which is meant to be informative in
validation it's an image of it la meant
to return a validation error which
describes exactly why this thing doesn't
match why this thing doesn't match the
schema there's also an explained
function which expands the scheme is
something human readable for the purpose
of you know someone going into a
namespace and maybe they can't read the
code they and they want to see kind of a
splattered out human readable version of
the schema so they just and what's going
on okay so that's all it is and so you
can actually obviously extend schema to
two other data types and so here's
actually a real world pull request this
is actually a real pull request on the
github repo that was incredibly useful
and we've actually made use of so this
is extending schema store regular
expressions and so i'll actually splat
out the real code here you know some of
this you know this some of these
expressions at the top here like pound
plus CL J&amp;amp;C ljs those are the CL JX
things for because its kima again works
enclosure enclosure script so here's
actually the money form there's some
other stuff going on so that you can
return informative errors but really all
it's saying is you know if you're a
regular expression and you want to
validate against some data then you need
to be a string and we need to be able to
regular
find you pretty sane right and that's it
and so now you can actually use schema
in all your def ends everywhere and so
here's some here's a great example you
can say you can say s / validate Lex
against Alex be and that'll obviously
work and you can say things like this
and that'll obviously work and this is
all straight forward where it becomes
really powerful is is when you actually
need to encode contract like behavior in
a function so here's a quick example
here's a function which is meant to send
a bunch of emails to people and the
argument the the schema rather of the
name to email is a map of strings of
presumably the person's name to an email
regular expression yeah and and everyone
everyone's written failed email regular
expressions before but you get the idea
everyone's tried it it's okay but like
the idea is that using being able to say
this and have it look and act like look
look like types in the sense that you're
you know you're you're quickly
communicating exactly what this function
is taking is super useful and again like
I urge everyone to go Andrea vent the
veal and write one of these yourselves
here's a trick err on the side of over
accepting anyway so yeah and so that's
actually you know again we urge everyone
if you've got ideas for different
schemas to go ahead just issue a pull
request were pretty reasonable about
accepting accepting them with a little
bit of conversation and etc etc um so
here's kind of another example that we
actually use currently in production
schema client and so remember again I
told you that schemas are schemers are
just data right and so mmm we can
actually take schemas and we can
actually do interesting things with them
and generate interesting things for them
so one of the things we decide is we
write iOS apps and you know we're
running in Android app since etc and and
you know if we can prevent ourselves
from writing as much objective c and
java as possible we're for it and so we
actually can take schemas and we can do
things like actually automatically
generate objective-c classes from a
schema declaration right we can pull off
the same trick and take the schema
schema data's and we can actually
generate Java code from them we can even
generate
eight because we have a bunch of
validation we can even do some form we
can even do some interesting validation
both client and server side and so we
can generate these classes and we can
actually write functions which map map
to these domain objects from actual from
from json data and you know it doesn't
have to be JSON data can be eaten or
whatever you want but this is this is
what we've been using and we found this
to be incredibly incredibly useful for a
variety of reasons you particularly at
iOS you you want to have you know stuff
map to classes for a variety of reasons
and um and so this is actually something
little release really soon and we found
super productive when schemas change
nobody has to go and change all the
client-side classes to do things stuff
just kind of you hit a button and stuff
just automatically happens um and
there's many many many more
possibilities so one interesting one is
there's actually no reason why a subset
of schemas can't just generate Cortot
type annotations right there's nothing
no again you know as I alluded to before
there's things you can say in schema
which which cannot which which cannot be
you know generate valid cordon type
annotations for instance right like
predicates for instance server um but
you can actually write a schema schema
which which checks you know which not a
hundred percent but checks that you can
actually tell when when some schemas can
actually make court type schemas right
we actually have a lot of schema schema
as we have schema schema strep Objective
C we have schema schemas for java the
check that the actual schema can in fact
render kenneth hagin writer career
objective c so generating cart IP
annotations is one interesting
possibility another one is you can
actually take again a subset of schemas
and generate generate data for the
purpose of generative testing so quick
quick check style things right so you
know if you have some invariant like you
know I you know you want a round-trip a
function and you've got a schema for
what the input of that function looks
like you can actually in certain cases
generate a bunch of data in order to use
for generative testing and that would be
super useful I think um and kind of a
little you know another another project
which is related to the schema client
stuff is we actually have yet another
library that we're contemplating open
sourcing where API methods have all this
metadata about their route you can
compute the route and what some of the H
p you know what kind of content type it
returns as well as the schemas on on on
query parameters as well as bodies and
posts etc etc and what we can actually
do and we're quite close to doing is
actually taking the the closure web
server stuff and generating an entire
API class that that is not only the
domain objects but actually the
functions which do kind of the
asynchronous call and put stuff into the
schema and kind of take care of that
entire interaction so something I I
didn't have time to go into entirely is
that schema schema has been really great
for kind of having shared shared objects
between closure and closure script where
you know this like the nodejs dream
realized or whatever where you know we
can actually it's literally the same
library that is used in both closure and
closure script to say this is what a
client-side doc looks like or whatever
right and and it's it's been great for
communication and also just for sharing
kind of development efforts okay um
thanks that's it and I've got a couple
minutes for questions if anyone wants to
talk to me rather than eat
yeah a little bit yeah i mean i don't
recall exactly because this we started
doing this like nine months ago or
something so I'm a little hazy on
exactly what we were looking at the time
but yeah I remember we looked at a lot
of things and I recall I think that that
was something we took inspiration from
yeah
yeah no I think no we haven't that'd be
interesting to do I think it'd be a
little difficult but yeah that would
certainly be interesting the question
was have you looked into actually
looking at error cases and automatically
generating the schema from examples so
kind of the reverse of the generative
testing stuff right any data right so
just taking example calls and just
guessing what the schema is you know
that would be interesting I mean I think
like the unfortunately there's a lot of
possibilities that if you have a strong
prior on simple schemas maybe that might
work out yeah that we definitely
interesting yeah yeah no so currently
yeah I wouldn't be difficult to make it
like a post hooker or some kind of
hooker see I think at the moment it's
just you know it's oftentimes the same
engineers and so they'll just when they
change that class they'll they'll have
to rerun the schema client stuff there's
also not necessarily one no one I guess
it's when something deploys to prod or
whatever that like them you know so yeah
no we don't do anything fancy like that
yet although we probably should
that's a great question so it depends it
depends on a lot on what we're doing so
for instance like there are places where
a ski there is just a project which is
just the schemas and that depends on
like how broad the clients are so to
speak right so and it depends on how
much interaction somebody like for the
API it makes sense to have your own
project because people aren't looking at
the API code the clients aren't looking
at the API code to figure out what's
going on in a case like that matrix one
it makes sense to have it there with the
functions which actually use it since
the the consumer of that namespace is
going to you know want to look at those
as well so it depends a lot on like
whether or not you're just getting data
or whether or not you're interacting
with functions which actually yield that
data ah so the question is can you use
spring to mean can you zoom in to
generate to do a spring parser I'm I
don't know enough about spring to know
the answer to it oh yeah I think that's
I think it's certainly possible right i
mean if the answer is something is
something possible in schema the
predicate answers probably almost surely
yes whether or not it's possible in some
get a more structured way that you can
get useful errors out of is a different
issue but I don't know if top my head
it depends on what's happening so just
validating is just you kind of go into
you hit one that works for the purpose
of error things you can you can you can
choose to say I satisfied this I
satisfied you know I didn't satisfy any
of these schemas or for Anne's you can
say i SAT aside the first woman on the
second one or whatever so it depends a
lot on context like what you want there
I think that's all the chiming I mean
alright thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>