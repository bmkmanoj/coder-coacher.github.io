<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Om Next - David Nolen | Coder Coacher - Coaching Coders</title><meta content="Om Next - David Nolen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Om Next - David Nolen</b></h2><h5 class="post__date">2015-11-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MDZpSIngwm4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so this talk is about ohm next
I have a lot of slides so we're just
going to get started it's gonna move
really fast I'm not gonna give too much
context I'm sorry that I may say
something's you know heard before but I
have a bunch of other talks that are a
much slower pace that I recommend
watching if some things are confusing
and then come back to this one okay so
most of you I distribute applications
that have a significant non-trivial UI
component in the mainstream they look
something like this you have some
mutable code on the server generally
written using some rest framework you're
communicating JSON so it's some ad hoc
message exchange format you've encoded
some date on the wire you're praying
that the client will parse that
correctly
the client is generally written in some
mutable language often JavaScript with
some mutable framework and so it's not
surprising that you run out of your
complexity budget really really really
fast and if you've done this enough
times as I have with traditional system
you may be a little bit excited about
excited about doing it a different way
so you may say well let's do something
conservative let's let's switch out this
the the message format was something
that has stronger semantics just just
the foundations like dates you know what
to talk about dates anymore we can move
dates across the wire and that'll be
great
it doesn't really fix the system and
then so you may you may attend closure
khanjan you're really excited about
simplicity and simpler systems and you
decide you're going to use closure on
the back end and then and then the back
end team is really really really excited
because like it's easier to test it's
easier to reason about maybe you take it
a step further than used a Tomic and
then you know party time on the back
backend and the front-end people they
start getting jealous they're like oh
the backend the back end they're having
so much fun we want to have fun too we
also want to reason have more reasoning
capability about the front-end and you
may decide to use closed your script to
achieve this and maybe react now sorry
let me turn this off so this is awesome
right you you magically have a great
system sadly that's not the case
you want you what you will magically
have a nice system and why won't you and
the problem is in the previous diagram
while you may have increased your
ability to reason about the server side
component and you may have increased
your ability reason about the client
side component nothing in that diagram
with the exception of transit really
gave you any more confidence in the
relationship between these two parts
Ricci has a bunch of great talks I think
this is one of his more underappreciated
ones and this this talk is very much a
riff on the language of the system but
with a sort of UI centric focus so what
are the problem statements always good
to start off with part problem
statements these are what I see as
problem statements so it's definitely
I'm a bit biased with my background in
UI programming but I see them as you
know there's a lot of ad hoc stuff you
look at a code base and there's a lot of
ad hoc stuff just about like how does
how do the client and the server even
speak to each other
do you have random components making
requests and then and then usually when
this happens that means usually those
components are caching a state and and
this really construe Bute to the problem
that there's no it's all all the
communication itself is ad-hoc there is
a deeper problem I'll be on this which
is the client-server relationship often
requires too much out-of-band
information for example how do you how
can you know when you make a request to
AWS how do you know what you're gonna
get right there's you don't you have to
read the docs that's the only way to
know all the information about the
relationship is out-of-band
and so you want to fix this and that's a
big idea no next there's a side thing
which I don't have enough time to talk
about which is that react is great but
you know we're not cargo kelting react
react actually creates a lot of problems
and people don't want to talk about this
and I talk about all the time the react
rendering model is a waterfall model
it's great for doing functional stuff
but you have this issue where if you
want to go back up the component tree or
you want to move sideways react makes
this really annoying and this is the
reason why things like flux and redux
exist they're all trying to fix this
problem with this waterfall design and
ohm has I tried to actually really solve
this problem at the same time as I
solved some other things there's some
assumptions ohm is very opinionated
there's some basic things I'm not gonna
explain them that's just what I believe
single app add a map state it's just
awesome this is just a great idea it
makes it easier to test your application
and reason about your application over
flushing is bad Oum uses a asynchronous
rendering loop we try to render at 60
frames per second we don't want people
to be in charge of flushing this is a
new thing this is quite different from
the previous version of ohm and now I
believe that visible asynchrony is bad
so in early ohm tutorials we often would
use core async for something I just
think it's a it's a bad idea the ohm
next model is completely synchronous you
need a synchrony but it should be
outside the components themselves
components look pure and they look
synchronous asynchronous is completely
at the edges of the system
a visible event model is bad so having
used many UI frameworks in my career
I've just come to the conclusion that
that event models are terrible and they
don't they don't fix any real problems
what what usually happens is that people
wire things together there's one little
event somebody clicks a thing you have a
massive event cascade and you really are
looking for how did this happen who
changed what and so on next completely
throws out any visible event model and
so we'll see how we can still recover a
synchronization of the UI without that
okay so what's the goal the goal is
actually really simple I have two things
that I want to accomplish with them next
one is that clients should be able to
make precise non-trivial reads simply
this is not something that's easy to do
in most systems you want to be able to
actually say this is exactly what I want
because I want to a render and
immediately I don't want to transform it
and this should be easy to do there
shouldn't be a lot of ceremony around
this the other thing is that this is
something that actually some of the
systems that support the first thing
like relay and Falkor they don't support
the second thing that communicates
clients can communicate non-trivial
novelty in a simple way so it turns out
the goal is actually a labyrinth right
so even though the previous two things
sounds simple
they sound desirable while they create a
host of problems if you want to achieve
those things and so when you look at
home next you might be why was it done
this way and this talk is actually
showing you if you want to get the first
two things you have to solve all these
other problems in order to get there so
let's talk about some of the obstacles I
mean some of these should be
yes if we're gonna do this what does it
mean for clients to make precise
requests what does it mean for servers
to handle precise requests what does it
mean for clients to communicate
non-trivial novelty what is it going to
look like how do servers communicate
identity so this is interesting problem
right so often clients want to support
the user constructing some non-trivial
piece of data but the client doesn't
have identities for those things yet so
when you send it to the server
how are you gonna keep those identities
in sync most people just give up and
this actually itself introduces a lot of
complexity because the client has some
piece of state that it needs to update
once the server knows the truth
integrating novelty and client once the
novelty comes back how do we update the
UI stuff like that another interesting
problem is local state right so there's
there's there's state that the client
wants to represent which has no
reification in the database like what's
the currently edited thing you probably
don't need to put that in the database
this is something that's only present on
the client and does the problem of local
state complicate these other decisions
we may make for these previous things
once you think about client local state
then you have this problem like well if
you solved it our optimum optimistic
update simple and optimistic update is
update the client we know it's probably
gonna succeed and just send it over the
wire and everything will be okay and
this is good UX design what about
testing if we do all this stuff are we
gonna make testing harder we're gonna
make it easier
what about standard UI patterns you have
often have recursive UI components do
any of the decisions we make make this
easier or harder
what about caching do any of the
decisions that we make caching easier
harder so Falkor and relay for example
currently have no good story for using
traditional HTTP layer caching or
client-side caching and then and then
how flexible is the system you may be
building a gnome next thing and decide
actually I want to have the same schema
in DES Tomic and data script and I want
to pull something for the atomic and
just transact it immediately it's a data
script you might not start your project
out why maybe that's what you want to do
how easy or hard is that to do custom
server you may decide to be more
conserving the back and you want to use
Postgres you start with Postgres
then you realize it's just way easier
with a Tom equate better with economic
how hard is it transition at any day Tom
it and then other other concerns like
I'll talk a lot about a request response
cycle but there are a lot of
applications these days that want to
have live streams so it's an easy to
have to subscribe to some live stream of
events being you know from the server
and integrate that into the the request
response cycle without creating a lot of
complexity I'm gonna answer all these
questions I have 93 slides I hope you
had a drink a lot of coffee we're gonna
go really really really fast so what do
precise requests look like so home
solves us with query expressions what
our query expressions are simply a riff
on de Tomic pull they're not exactly de
on atomic pull because we need to be
able to do more things the way that pull
works you have to use sort of use it in
combination with query and we actually
want the pull syntax to be good enough
for basically generic query and as well
as mutations and we'll see this but the
point is is that you can bottom out in
de Tomic pull pretty fast so you can
have this these queries and they bottom
out and atomic pull and it'll just work
or pay discrete data script as well okay
so the idea here is we co-locate query
fragments on UI components via static
methods we stole this idea from relay
write this is exactly the way that relay
and graphic you all work and this what
this means is that you can take the
route view of your UI there must be a
route view the bottom of your UI and we
can ask that the thing the class is
going to render without even
instantiating it we can ask the question
what is the total demand for everything
in the UI that we're gonna need to
display once we get the data back from
the server this is awesome this this
really answers the how write components
are no longer involved in getting the
data themselves we now have a very
powerful model for always be able to get
exactly what the application needs and
we only need to make one request which
is huge if you're talking about mobile
clients so it looks something like this
I've you know sort of hidden the parts
that don't matter you make a little
static method and you have this date
Tomic like pull syntax on your query
because it's just data
it's just eaten data we can recursively
compose this right we can just ask the
other
types that are involved in the UI what
their sub query is and we can just build
this whole data structure simple reads
looks like diatomic pull here if you say
you want to read this address of a
street just a keyword you want to get
somebody's first name there's another
thing that we support which looks a lot
like the atomic lookup refs we call
these idents because they serve another
purpose in ohm which is it allows two
parts of the UI they represent the same
logical identity to be automatically
kept in sync and we'll see this later
we support parameterize reads if you
have a query syntax you need to be able
to take a key of some key you want to
parameterize it this is exactly the same
as URL parameters ation this is a two
element list what's the what's the key
you want and what sort of other things
do you want are you shouldn't there's no
there's no there's no restrictions on
this on the what can appear and their
parameter part is just like URL
parameters it's up to you what those
mean joints so this is big so this is
this is definitely treading into
relaying Falkor territory well the
problem with rest space systems where
you really have this clean or source
full thing is that well how do clients
get related resources it was fine back
when people had fast internet to just go
back for more stuff but as as on devices
that are more bandwidth constrained this
is not really that great and actually
what happens is that people in order to
solve this problem
they just arbitrarily put some random
collection of related resources behind
some resource and it's never the right
set right the client will probably want
something out so even when you do this
clients still need to make multiple
round trips so we're gonna get out of
that so here this is what a joint looks
like so I might want to get to do items
and then I can recursively sub select
the properties that I want from that
right so this is just Turtles all the
way down alright so once you have a
query expression you need to be able to
evaluate it and so we we call this
parsing it's very similar to routing but
I called it parsing because it just
seems more natural you go from some
query expression to some other value
parsing is just evaluating a query
expression we take query expressions to
some Edin value but it's important
understand this even value is the UI
data tree
that you're going to render you're not
going to do any more transformations on
this thing so the query expression gives
you the thing that you can supply to the
UI component and you're done there's
nothing else to do now what does this
look like here's the most simple parser
so we make a read function there are two
types of parsing functions one is read
and one is mutate so read is very clean
it's side-effect free it takes three
arguments it takes an environment it
takes some key that you're currently
parsing and it takes any parameters if
they were supplied well you can make a
parser just by saying here's the parser
here's my read function and here at the
bottom I say on an empty environment
because I'm not supplying anything yet
given this query expression give me the
UI data tree back and in this case it's
just trivially fubar right so the
function simply says these are the
values that we supply for particular
keys then you have I change this slide
just a tiny bit and what happened here
right so I instead of returning a value
I return to remote true and parts no
longer returns anything because it can
there's nowhere that it doesn't know
what that is it doesn't know what that
thing is
right it doesn't live on the client yet
so we can change that then we can add
well we want the query expression that
we can send to the remote thing and so
this takes query expressions to query
expressions right so this is the message
that you can send and all this stuff is
automated right it's automated Oh next
will automatically run the query get the
UI data tree render what it can compute
the thing that it can't figure out and
send it over to your endpoint that
you've specified okay so what does what
does handling precise requests look on
the server what's a bit like this notice
it's it's surprisingly similar to the
client part right so this is just the
Falkor idea and Falkor you have these
routers that live on both client and
server and so we just again just all a
good idea so here we have a read
function which returns something for two
dus lists the to do list key notice that
the environment now takes something
meaningful it's the connection in this
case des Tomic and then whatever the
pool syntax query is going to be that we
pass along right so now you have a way
you have a unified language of both
client and server right so we're
starting to see that we're
nating this problem where the
relationship between the server and
client is meaningless
now it's meaningful and then you can
construct the parser and you can pass
along the connection and so on and so
forth
right so this is because the parsing
code is that you know dot CLG C file so
it works both in closure and closure
script okay that that's that sort of
demonstrated the requests sort of the
read cycle so now let's talk about
communicating novelty because clients
need to change the system
so it looks something like this so this
is a transaction query it's just a query
expression but the difference is the
very first element here is a two element
list there's a symbol and the symbols
this has to be this way the symbols name
mutations and you can pass along
parameters like you could pass along
parameters of keywords this is the thing
that's going to change the system right
and this is often non-identical this may
change many things of your system
there's this interesting thing here and
this is why we can destroy the need for
a visible event model and this is again
we're just stealing ideas from relay in
Falkor so you run a transaction and you
wrote the client and you know what keys
you care about you know what keys are
gonna change right so there's no event
cascade what's gonna happen is this is
going to submit something in the server
and then you're gonna say I want I know
this is gonna change let me reread these
keys and we just update so there's never
an event cascade to look for right you
always run a mutation and you specify
the keys you want to read you might be
wondering well how do you know what you
want to read and we'll demonstrate that
in a second so here's the simplest
mutation function notice that the
signature is exactly the same as read
you have an environment map you've got
the key that you're mutating or whatever
that thing mutation is named and then
whatever parameters you can't run this
mutation locally we just return remote
true the parts of runs in remote mode
and it returns this thing we're gonna
forward to the server so let's handle
that a mutation request so here we have
a mutation it doesn't look it's a really
good it's almost identical to the way
that reads look except you have returned
a map that has a value which we'll
explain in a second but it has an action
the action that will actually apply the
mutation and this has to be in a thunk
and
side of a function because we really
want parts to be side-effect free we
often need to run it in multiple
multiple times you may need to compute
multiple remotes and of course we need
to run it to compute what we're gonna
render so down here on the server side
we run the mutation and what it's going
to return is we ran this mutation and
here the set of keys you might want to
reread right we don't want to force the
client to reread this right so Facebook
and Netflix already figured this out
Netflix needs to work on set-top boxes
mobile phones watches desktop computers
right there's all kind of types of
display information that may change
different clients will want to read
different keys and so they already
thought through this problem that's the
path they took it's a good idea we're
just gonna follow it we communicate what
might have changed but it's the server
who observes ok if I do this this
changes this is what I care about and
this is what I want to reread there's
another thing that's interesting here is
we have the lookup breath pattern this
is this pervades this pervades all next
it's super useful this is how the
commute that server communicates
identity this is how identity is
represented on the client to element
vectors
well this which brings us to the temp ID
problem so so own necks just just copies
des Tomic because the atomic has this
really great thing where you can build
up a transaction right you can build up
the entire transaction you can use temp
IDs to say these are the links between
the data and then you transact it and
then you Tomic tells you this is how you
go from the temp IDs you had to the real
IDs but this is awesome right this is
awesome you have a model now for clients
to create non-trivial novelty committed
to the server the server can say these
are this is a temp ID transition and um
can automate the entire thing for you
you don't have to delete temporary data
right user builds up data server
communicates identity done right this is
not your problem anymore
again removes it incredible out of
complexity if you ever done anything
non-trivial this problem is terrible so
what does it look like on the client
what will happen so here's here's some
state we'll explain the actual layout in
a second but notice there's like this
temporary oh my D thing right who cares
what I was represented
it's just something that the server can
understand we'll write we write
something on the server that creates
some novelty and then one will say well
we got the old ID and here's the new ID
the one that we know about the one
that's the real one and just passes us
back along home next season your
mutation returned a temp ID transition
boom done there's nothing to do there's
no code you have to write right there's
just a way to move identity back to the
client it's awesome because I live in
New York and you know network
connectivity is very spotty right with
this model I just showed means that you
can basically build non-trivial amounts
of novelty you never have to talk to the
server until you absolutely have to and
this is great when you have slow
networks and it's great when you don't
have any networks at all
what about client only state so here's
here's a huge problem which is that you
have state which you'll never you'll
never put in the database it'll never be
there there won't exists there I'll only
be on in the client again things like
temporary transitional actions and stuff
so relay doesn't support this at all and
in fact I chatted we're like well what
do you what do you all do about this and
and users have to hack around it because
they want it but they can't represent it
Falkor actually does support this it's
great they do this by nesting data
sources and all next supports this very
well it means that you can actually have
graphs that are that will never get sent
over the wire you may have some keys and
they never exist on the server and you
can parse them and the remote parts
store doesn't need to know anything
about it right this this allows us to
preserve a separation but then also
share the things that need to be shared
so it's a unified data access model we
just steal the Falkor version right we
just do what Falkor does it supports
this merged view of client only state
server State so what does the client
state look like right we haven't talked
about that we saw that a little bit in
the previous slide but what has to
happen is you have to take trees because
the server responds trees right this is
true for both real and Falkor but you
need graphs right you need graphs you
need to update graphs this is actually
one of the biggest flaws in what the
original home is they have to work with
trees and this was very obnoxious and it
create lots of problems it's also the
problems react have to work with trees
you want to work on grass
these graphs are easier to update so
here's some data that got that the
server responded with or maybe you
created it and the problem with this
data it's very typical is that this is
great to render it's very nice for
rendering but you have duplication so
updating this is complicated you have to
remember all the places you want to
update this thing and you don't want to
do this there was actually earlier
versions of them next where we tried
where I tried to make this working they
gave up and I realized that relays
Falkor were just correct you want
normalization so Falkor it's a bit
annoying and so there's a lot of I
didn't want to do the boilerplate that
Falkor requires Falkor you have to build
the normalized representation manually
it's not fun
relay just does it automatically for you
and it's able to do this because it has
queries the queries give you enough
information to do it you do need one
other thing which is you know when I'm
at a node what's the identity for this
node so you can replace the replace the
value with a link and you supply this
and again this actually has a dual
purpose you can have the same logical
identity rendered by two different
things and because they have the same
identity on next and keep them in sync
so has a dual purpose it allows us to
normalize the tree but also has to keep
things in sync and it's automatic you
don't have to do anything so what does
it look like we just replace that first
thing with a link a two element vector
looks like a lookup breath and we moved
it into a table notice that the vector
is something we can use with get in
right get in just works and so that's
another point the other point in using
the two element vector now we get to
Mary and we want to replace both both
both both instances right we there's
links now for both those cases and we
move into a table we merge the keys
because different components are gonna
want to read different keys right we
create a merge thing a merge map and now
if you don't want to update Mary you
only need to do it in one place and the
UI will always stay in sync all right
doesn't matter how many times the same
identities appear in your UI there's
it's very simple there's it means
there's no complexity around identities
and keeping them in same and once you
have this format what again what stops
you from putting your own keys there
nothing right you get a response to the
server and you know you have some keys
that
you don't want to put in the DB and this
is trivial just add a key
you know what the representations and
links are add a link right you now have
a way to create a merged view of the
state that's here the state set that's
there okay so now that we know that we
can do this what do optimistic commits
look like right we want to run some
transaction and then we also want to
send it over the wire this is all the
code for an optimistic commit that's it
it's just this one thing right we have
the transaction at the bottom this
action which transitions the local state
and then we just say remote true and um
will automatically pass that on get the
data and if it's the same nothing
happens and that's pretty cool okay
testing what are the implications so
it's a lot of this a lot of new stuff
that you probably haven't seen before
and what does this mean for testing it
actually has huge implications for
testing so having worked on UIs for a
very long time the testing story for you
is is generally a bit of a joke right
it's in order to get sophisticated
testing if you use really sophisticated
complicated frameworks most people just
give up and they just have you know QA
teams sort of labor on all these
different types of devices often you say
well we can't test all the devices so we
only really test three the three that
people actually have right the testing
story for you is is you know pretty
comical so but how can we gain
confidence we know why it's hard but how
does what I just showed make it any
easier how can we know with confidence
that our UI state transitions are gonna
be the same everywhere well what did I
just say parsing gives you the UI data
tree right so functional programming is
gonna rescue us um next parsing creates
the UI data tree your components are
pure functions from the UI data tree to
the render Dom right there's a direct
correspondence completely direct right
you don't need to look at anything you
can prove properties of your UI without
ever looking at anything at all and so
we're gonna use test check to show cool
demo they're actually much cooler demos
and the one I'm in a show but you'll get
the basic idea the other thing is
because the query expressions are
themselves data
their data you can generate them you can
generate transactions you can basically
generate transaction streams right and
so it doesn't matter you know I may I
may use a gesture that triggers a
transaction I may use a mouse that
triggers our transaction I may use a
Braille keyboard it triggers a
transaction who cares who cares how we
create it we can model all users just by
generating transaction streams it's
important that test track is actually
monadic because if you're gonna generate
these streams and you want to model the
user you need to be able to thread state
and so test test check has a good answer
to this problem because you know they
really thought it through so you can
verify now that the UI data tree will
have the properties after the
transactions are applied and we'll
demonstrate this I again there are much
cooler demos that I have but I don't
have that much time you can ask me about
this later so here is some data
it's a friending application and I want
it I want to prove some properties I
want to prove that if I not prove but
gain confidence that if I add a friend
or remover fred is the UI data tree
consistent is it still consistent so
here we have some people and they have
friends and of course friends are also
people right so here I'm gonna render a
friend and we have this identity
function which takes this you know will
take what things that appear here and it
gives us an identity for that thing and
the query says you know I want I want to
read ID in name person
notice that the identity function for
persons the same as friend because we're
gonna want to keep these in sync if
somebody changes our name you want to
change their name everywhere and then
this person has a query and friends is
computed from a different component so
this is the recursive composition of of
queries and then we have the root the
root of the application in this case a
trivial application which is people and
we're going to do this and so if I can
go home get query people well that's the
total query feed application and then we
keep scrolling down and we see reads
they look exactly like what we've
already seen we have mutations here's an
adding friend mutation we update the
atom so on and so forth it's pretty
straightforward and then down here we
have the parser we've already seen that
a parser is always constructed from a
read and a mutate function and here we
have
a generator which creates jet random
transactions random we're modeling the
user and so we can go sample 10 right
these are the transactions we can we can
just use these on the UI state and we're
done right we can just run this stuff so
I want to be able to prove in my UI that
it's impossible for a person to appear
in their own friend list this should be
impossible
there should be no path no user
generated path for this to happen and
look at this so this we're not looking
at anything we can just prove it right
or really be very confident not prove I
keep saying for you not through John
Hughes gonna be very annoyed that I said
that so here we make a parser if we
supply read and mutate here we say take
the initial data normalize it create the
state atom we take the randomly generate
transaction we apply it to this state we
use the parser again to get the UI data
tree that must cook that's the
conclusion of running that transaction
and then we run this check is it is
there any place in this tree where a
person appears on their own friend and
friendless and so I'm gonna demo this
so we're yeah so I do a quick check I'm
ready to go 100 I'm gonna go prop no
self rending I'm gonna run this again
and what's cool right so the awesome
thing about property based testing is
that here's some random thing that it
generated and then it shrinks it to the
minimal you user interaction that caused
the failure right yes
a person can add themselves as a friend
so I go up here to add friend and I
review the code and I'd see you oops I
forgot to say only if ID is an equal to
friend and I returned this and I save
and I wait for fig weald update boom
right
you have an entire model for modeling
users right you can model streams of
user interactions and you never have to
look at anything and test check can give
you the
the whole sequence of user interactions
right and the reason this can work is
because ohm neck says the way you should
moderate application is that parse
returns the thing that you will render
and you should not change that thing and
that gives you really powerful testing
capabilities okay
I would rather thing the idea here is
right right what what this will let you
do so that when your QA aying your QA
important stuff like are the animes are
the animations smooth right all right
this is a style look good right you
you're actually doing Quality Assurance
you're not you're not having them you
know these basic bugs right you want to
eliminate this massive class of bugs and
again you want to eliminate them
universally you want to know that it's
not going to be the case it doesn't
matter where your application runs okay
so we have this crazy syntax and does
this make some things annoying like if
you've done a lot of UI programming
inevitably you have to use recursion
somewhere so is it kind of is it bad to
use these queries and does that make
that does that make it harder to write
things like outliners things that are
naturally recursive and you know direct
reviews and so on and so forth
no because day Tomic already solved this
for you right day Tomac has this
recursive little thing and this just
works and people are already building
systems using this right they can
naturally write recursion into their
queries and here is this UI element will
actually invoke itself right again and
again and it just works it's important
that it just works oh this didn't work I
probably would have not you know done
them next at all this had to work okay
what about caching right so this is this
is a big thing because when I worked at
the New York Times we you know I enjoyed
my time there and I enjoyed working in
rails rails was very productive but
rails is not that fast
people know that this is not a problem
but it's ok busy you canyou can solve
that problem with the caching layer
right and being smart about caching we
used varnish and I saw I really saw the
value of this it may be the case that
you're building a system and you really
can't make the query faster and you need
to implement some form of caching so
caching is good really in Falkor
throw out traditional caching techniques
they just throw them out you cannot
apply them in their current state and
when I saw this I was like well I could
go there but I really
suspect that nobody will want to use
these systems until they solve this
problem I said I think we can solve this
because our query expression is data and
that gives us a lot of power so we don't
want to do what rely on Falkor did do
because they introduced a lot of novelty
they're already talking about things
that I don't want to hear things like oh
there's gonna be a client-side TTL and
all this other stuff here like our
timeouts and cache eviction policies and
you can play a strategy don't wanna do
any of this right the browser already
solved this problem there's all this
stuff inside the browser and things you
can do with HTTP layer that solve this
problem for you we don't want to go
there so um next out-of-the-box supports
traditional HTTP caching and you can
just reuse the existing technology this
is very much like this is the system
that we live in let's reuse the parts
that work so we solve this with the
notion of multiple remotes so you've
only seen one remote and we can solve
this by supporting the idea of multiple
remotes and basically you can take your
total query and you can identify where
things should go this part of the query
tree goes here this part of the trick
create tree goes there we can and
because it's Eden and because we
actually clojurescript implements
closure persistent data structures and
in fact they hash the same way we use
the same murmur three hashing algorithm
you can know that this purse stir on
this Eden data structure will always
hash the same you can shop 256 the thing
you're gonna get a stable URL so imagine
I'm making a live dashboard it's gonna
include posts photos graphics this part
of the query this portion of the query
is dynamic just the users favorites
whether the currently logged in user has
favorited some some item in the stream
that has to go to the dynamic dynamic
endpoint right it just has to be served
for every single user but the large part
of the application isn't dynamic every
user is going to see the same thing the
same stream so we can just elide that
part per stir and then just do the shot
256 and you're gonna get the same URL on
every single client and then it's back
to the traditional caching you've known
and loved for many years so we just fix
that problem
okay so customization
so you might want to customize client
storage and so on next supports this out
of the box a lot of people like data
script so we make it work
data script is fully supported people
are already building things where they
have the same queries they have the same
schemas and again they can just hit an
endpoint get back this you know the
entity map tree and they can just
transact it immediately into data script
and it just works pretty cool sorry I
skipped that last point but I said it
server-side what about server-side the
next model is actually back-end agnostic
it's completely back-end agnostic you
you know you don't have to use closure
if you don't want to I think it's a
terrible idea but you can do this it's
going to be easier for you if you're if
you're back in language supports transit
so that's kind of like the the minimum
requirement what's nice is that that
supporting HTTP caching relieves
pressure for server-side novelties so
you may have an existing system you will
use it with closure you really like the
idea is by own necks and HTTP caching
will allow you to transition over time
to a database that's better suited for
this model of programming right so when
you're when you get there you'll build a
swap in the atomic and it won't really
be a problem okay
streaming last sort of customization
thing um next just out of the out of the
box the way I designed it it just
supports side loading right so you may
have a request response cycle but then
you decide okay we need this real time
feature will subscribe to a stream and
you can just say I want to subscribe
this it's a little query on the stream
and then the server can send it to you
and you can load it from this side and
it just works because it was designed to
work so yeah fix that problem update
model doesn't change so what's the state
of the project a design phase is done
it's actually been done for quite some
time a lot of it was just fixing all the
bugs and more bugs are happening so we
gotta fix more bugs but there's not much
more design work to do oh we are rapidly
approaching beta it's great and that
people are really really using it trying
it out now the part the biggest problem
is this lack of documentation this is
probably the first time that I've sort
of enumerated the big picture and why um
next works the way that it works
and over time we were actually probably
do a lot of documentation so it's clear
how the various patterns like you know
things like well show me the optimist
update example show me how to defer a
query so on and so forth and that's
gonna appear rapidly in the next you
know a few months I'll conclusion so my
conclusion is that you our program
committee arrived made radically simpler
I think relay and Falkor just delivers a
ton of inspiration of how you can
simplify the thing I think you can push
it further and that's what I've tried to
do with them next reel and Falkor are
great now we can take it to the next
step and then I believe that you could
probably take it even further than that
but whatever we're doing now I don't
think it's great so whether or not you
use ohm next I think your UI system
should have the properties discussed I
think each one of these things are do
not random features right they're trying
to solve a whole host of problems that I
counted over and over again when I was
building you eyes I just just huge
thanks to the closure script community I
mean it's one thing to have an idea and
it's one thing to have a community
community really validate the idea and
really take it and basically make it
real
it wouldn't would not be up here with
all this stuff if it wasn't for the
amazing closure script community really
really pushing these ideas and and also
sharing them I think it's what's really
interest when I start with closure
script I was like okay closure escapes a
little bit crazy but it's kind of cool
because I like closure but it's really
in the past year it seemed it seems to
me now that actually closure script and
closure are sort of actually have this
opportunity to sort of actually really
push UI programming for it it wasn't
obvious that that would be the case but
I think collectively I've seen so many
amazing ideas happen I think we're
actually at the leading edge of UI
programming which is awesome so thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>