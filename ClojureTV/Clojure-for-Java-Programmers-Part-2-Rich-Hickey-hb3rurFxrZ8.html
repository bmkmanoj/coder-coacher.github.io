<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Clojure for Java Programmers Part 2 - Rich Hickey | Coder Coacher - Coaching Coders</title><meta content="Clojure for Java Programmers Part 2 - Rich Hickey - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Clojure for Java Programmers Part 2 - Rich Hickey</b></h2><h5 class="post__date">2012-12-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hb3rurFxrZ8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so let's look a little bit about
jaw a little look at Java Interop
because one of the great things one of
the other great things about closure is
it sort of solves the library problem by
adopting the library of Java you know
all new languages have this problem in
that well depending on the implemented
if they're implemented on a sea bass
they're starting from nothing they're
writing their own runtimes their own
garbage collectors or own evaluators
their own libraries etc etc and this
tremendous amount of wheel reinvention
so closures approach is to say you know
these libraries are written if you could
leverage them in an idiomatic way you
would be done because for a lot of
things not everything there's not a big
syntactic benefit to one language or
another closing a file
it always looks and smells a little bit
like closed file the parens might be in
a different place there might be a dot
there might not but it's just it's not
that rich a thing and many library
things are like that so closure sort of
has a hybrid approach the first phase is
use Java directly you can use Java
directly in closure no wrappers you
don't have to write your own library it
shouldn't make you feel too dirty if you
like Lisp and I'll show you you know how
how that looks if you have a higher
level abstraction you want to make it
look a little bit more like something
you would do in Lisp you can build on
top of it if you need to but when you
see how closure both lets you access
Java and how closure brings Java things
into its world you'll see that you often
don't need to do that so first thing
that math.pi dot we saw was a special
operator and it says we're going to
treat the rest of this like it's Java in
particular we're going to look at the
second thing in the list and look to see
is that either a class or not if it's a
class this is a static thing rather
going to be accessing a static field or
a static method if it's not a class
this is an instance thing so that first
call is a static call right now hi I'm
just a dot math bye
that happens to be an access to a
variable yes in this case closure adds
some friends because it does wanted to
limit things it doesn't want any magic
syntax so versus a direct field access
there going to be a pair of friends at
it but for function calls it's no more
friends or dots than Java and we type
that in and that's what happens I'm
going to show you some neat things right
away because that's what's cool about
closure the first thing is somebody
asked earlier but what about
concatenated calls right you can say in
Java this not that not that and you
could say that enclosure to by saying
dot this whatever and then surrounding
that with dot the next thing whatever
right and doing the list kind of thing
with growing shells of calls but I think
I mean I know most Java programmers
would not be happy with that but that's
where macros come to play because there
it was really easy for me to write a
macro called got what it means is read
this is if you put dots in between
everything so this is system gap
properties get Java version key and it
returns that and I can put as many
things in that list as I want that turns
into the nested set of calls to the
first thing but you don't have to write
that you can write this if you have
other patterns that you like you can
write macros for those too but this one
comes in comes included dot so that's a
this is an instance of alright once a
statical and in statistical right Chris
get properties gives you a property
object properties object and that's a
method get new yes
dot dot is just a macro there's no
language thing it's not in the compiler
it's not special syntax it takes those
forms and turns them into the first one
that turns into a nested set of the
first thing the first thing is the only
primitive Java member access thing that
exists in closure other words that dot
upfront in the top is the only special
operator this is an ordinary macro code
that it's not special you say def macro
you saw me say def something there's
something called def macro where you
write something it looks like a function
but it's designed to take forms and
return forms but I can't describe def
macro more detailed than that tonight
def macro it's like a function
definition but its arguments will be the
forms that are up here in its invocation
new does what you think it allocates a
new thing there's also syntactic sugar
to make that smaller notice you can
scope you guys and you can do all that
stuff
no more parens and whatever and they
print and do whatever but of course no
one would be satisfied with that because
one of the nice things about closures so
let you fix Java so let's look at a very
macro called do to write how if I had to
have you had to say this thing dot that
this things out the other thing this
thing that they're looking listing
method oh my god I hate that so as soon
as I'm in closure I don't have to wait
for Sun just give me with or some thing
to make that go away I made it go away
when a macro called due to what does it
do it does to this first thing all these
other things
you can just say that's due to this
first thing all the other things as if
it was the first argument to all those
other functions if those functions the
macro will put them in think about what
you could do if you could do this in
Java you could you could make
abstractions for all those patterns that
you can't get rid of automatically
closing files and things like that
exception handling patterns that you
want to put in logging policies you can
encode them all in macros and they're
going to be uniformly applied everywhere
and when they need to fix them you can
fix them in one place as opposed to
everywhere where you put them manually
this is a better way to write Java so
what happens when I say this it turns
into this again don't get too confused
by these generated things but I want to
show them because it shows you how
there's a program behind this there's a
way to say generate a symbol for me that
we haven't seen before and ends up with
the number on it
let some identifiers be that first thing
this is a macro right the use of dot and
a name is a macro it's a macro for new
so this is the same saying new jframe
but let's to write a much more
declarative style so let somebody that
fire your new jframe then do because we
want to do a bunch of steps so this is
the way you make a block of expressions
for side effects because these are all
side effects right adding something to
the frame hacking it and showing it so
do these things again that's that first
impact dot the thing instance call
not the thing that dot the things
showing let's say doctor thing over and
over and over again finally return to
thing this is what you have to write in
Java this is what you have to write in
closure and it writes this for you
there's lots of other stuff like this at
a higher level the integration with Java
is very good you know I said before
closure strings or Java strings the
numbers are big in number the
collections all implement collection the
collection library in Java is
particularly good and one of the nice
things about it is that they defined as
optional all of the non read-only
functions of the collection interface so
closure implements the read-only part of
the collection interface which you can
it can implement the mutating operations
of the collection interface because it's
data structures are immutable but it
does do that so you want to take the
closure vector and pass it to something
that you know copy from or any of the
job functions to take collections it
will do it also all closure collections
are iterable so they do that I mean they
are because their collections but so you
can use them there those functions when
you say fun whatever that yields an
object that implements callable and
runnable so you can pass them directly
to the executives framework to swing
callbacks directly usable in Java and
bye-bye calls to Java that need objects
and implement particular interfaces
there's much more of that but you can
just presume if I could make it work on
the semantics we're correct I've done it
so that you can you can interoperate
from another interoperability thing like
you are hosting closure or if you wanted
to extend closure like I've shown you
maps and sets and some other things most
of them are written in Java you might
have some really cool
data structure you want to implement
seek there's an interface first seek
it's called I seek if you implement that
interface seek and first and rest and
every function I showed you before and
every other function in the closure
library will work on your data structure
you implement a three function interface
and you're done you interoperate with
closure that's what it takes to add a
data structure to closure and you can do
it you don't need to ask me
similarly there are interfaces for
everything else I persistent collection
I persistent list I persistent map and
everything else interfaces for
everything you can extend closure
yourself the other way the sequence
library already works on a lot of Java
stuff with no work for instance that
seek first rest and all those functions
work on anything that's Java iterable
which is all the collections in Java
they work on strings directly and they
work on Java arrays of both objects and
native types so all of that library you
want to call partition on a hash map you
know Java hash that you know or you know
Java lists or all those functions will
work on Java stuff you can implement and
extend Java interfaces and classes in
closure closure does not really advocate
treating closure like Java or really the
creation of classes with members and
things like that
closure likes interfaces and emphasizes
implementing interfaces you can extend a
concrete Java class mostly because there
are unfortunately defined Java libraries
that force you to do that so I had to
support it as a design thing I don't
support it but you can do it because you
have to I mean everybody seen it's funny
you know the guys who did Java util
collections they're awesome right you
look at like stream
all the concrete classes in there no
interfaces it's terrible so but you have
to deal with that stuff and I accept
that so you can do that I've recently
added primitive support where the speed
is exactly the same as Java leveraging
hotspot to get a dynamic performance in
lining that they do I don't actually do
it
in fact closure does not emit byte codes
for for instance integer arithmetic I
don't do it but I've created the ability
to call a static method that does that
and hotspot will dynamically inline that
and it's exactly the same as if my
compiler wrote integer plus and the
speed is just as good and the speed is
stunning
in fact it's faster than any Lisp I can
find with all the declarations in place
a hotspot is outstanding so what does
this look like what's a bigger thing
look like well this is a this is
actually a Java example right the
Celsius thing anybody know this one I
think I had some had some stuff here so
oh I should show you this so here let's
look at uh let's make sure I've loaded
some library system imports here now I
have a Java GUI stuff so this is that do
two jframe making a jframe oh there it
is holo world but one of the things
that's cool about closure so this I put
that do two jframe add label pack show
inside a variable so I could talk to it
some more so that's it here hello world
but I can call set size on it all right
you doing this in Java today I don't
think so so dynamically talking to your
UI app and tweaking things and changing
the layout manager or whatever you can
do that all in closure of course this
isn't quite legit right I shouldn't be
calling subsides outside the Oh
threat right so there's a utilities
thing utilities invoke and wait now look
what I have to do to make this
consumable by that interface does
everybody know this does anybody do some
programming swing has rules the rules
are you can't talk to you I stuff from
arbitrary threads because swing is not
thread safe so they have a thing that
says give me runnable and i'll go and
run it in the art thread where it's okay
then I'll return to you and I'll make
you wait until I do it and that's called
invoking wait
so because closure functions are
runnable I can call that just like this
this pound sign here is just even
shorter syntax for fun but you can
imagine this says fun I can't really
explain that right now but it's just
another macro like thing so then we can
do that and that's using invoke and wait
and passing a runnable from closure it's
not that simple in Java that's for sure
okay so now we have our book we have the
swing example so what are we going to do
we're going to do some imports that's
what imports look like notice how that's
also shorter than the Java version of
the same thing where you'd have to
repeat important point apparently we're
going to define a function def fun is
sort of combines def and fun so you
don't have to do two separate steps that
fun we're going to define a function
Celsius takes two arguments we're going
to let a bunch of local names be values
we're going to set up the frame
this is that new with their arguments
then we're going to add an action
listener now this is another macro in
those this and that are connected so we
saw that was dot convert action listener
as the canonic for this macro
interpretation of dot allows you to put
the method first which lists programmers
prefer if you don't like that you could
say dot convert button and action this
thing I don't do that I don't dictate
you do either both are supported so this
is a list view way to do stuff which is
what are you doing goes first to who
goes next so an action listen to the
convert button now we see dynamic
creation of an instance of an interface
right we have to implement action
listener so proxy is the thing that
allows us dynamically on the fly do an
implementation of an interface we're
going to proxy action listener
this could be a list of interfaces and
at most run flats so that you could
extend a class here or implement
interfaces there's a name of our method
right are we know ceremony or nothing
clearly return type will type the Argos
whatever and then I just put the code
okay which in this case is just going to
hope this is code for brown white
conversion so that's a step and the most
that can take multiple expressions it's
going to evaluate to the last one but
you can do things for side effects this
is a side effect right setting an action
listener is modified convert button then
we did the due to trip where this would
be all this lines of frame doctors
framing up that frame that the string
like that or we're going to take the
frame set its layout and size it so it
should we sure
so that code is here
so I already did this import so I could
do this other hello world thing so I'm
just putting my cursor around the
Celsius and I'm pushing the key that
says evaluate this that compiled the
function Celsius and that's what that
tells you there is now the Celsius
function exists and this is a call here
this is a call to Celsius it takes no
arguments will do that and we get the
Java sample Celsius converter
so that gives you a taste of what it's
like to do Java programming enclosure I
find it a lot more fun than Java
programming job alright and now there
you get very fast coverage of functional
programming so Bulger's dynamic embraces
the JVM we've seen that it's less right
it supports functional programming and
concurrency and they sort of go together
although there's a lot of value in
functional programming without the
concurrency I don't really think there's
valid concurrency without the functional
programming so what do I mean by
functional programming I mean in this
case mostly two things I think the term
functional programming is erroneously
applied to some languages including
sometimes - Scala that's just meaning
having first-class functions functions
as values closures and functions you can
pass to other functions making our
returning functions from functions but
the but real functional programming is
about side-effect free functions and
immutable data it's about saying every
function is is literally a function of
its arguments that produces a new value
and nothing changes in the function
nothing has past changes and nothing in
the outside world changes now obviously
we can call closure we can call Java
from closure and do all kinds of side
effects so what I'm talking about here
is what closure provides in addition to
allowing you to make a mess in Java
closure gives you the recipe for doing
functional programming correctly so we
mean immutable data and the first
questions we saw that's what I just said
yes could you do this by convention a
little bit one of the problems with the
mutable data as we'll see if I can talk
extremely quickly is having data be
immutable isn't isn't enough you need it
to be you need the ability to create
things that appear to be modifications
efficiently like you can make immutable
data by copying everything
just will never change this I'll make a
full copy every time I need to make a
change that's not practical and it's not
going to perform well so the immutable
data is trickier than you think there
are a couple of flavors and functional
languages there's some that are very
strongly statically typed to have very
intricate type systems in particular
Haskell they're not for everybody some
people love it I think if you're
mathematically oriented and your
programs are like calculations this
tremendous fit in a language like
Haskell if your program has to talk to a
database on the screen and the web and
all this other stuff I don't know that's
as good a fit and people do web
programming in Haskell but I don't see
it in addition I think there are
expressivity problems to type systems
until you become omniscient which is not
going to be anytime soon
then is dynamic functional languages
which are actually very rare I think
Erlang you know certainly led the way
here and closure is another example of a
dynamic language that's functional so
now you're combining dynamic typing with
immutability different pairing why do
this okay because it makes your programs
better much better concurrency
completely aside I have completely
changed over to functional style
programming even when I'm stuck in
something like c-sharp or Java because
your programs are better you can look at
them you understand what they do this
function it takes these things it
produces that you don't have to look
anywhere else to understand what's
happening and as you scale up that
property becomes incredibly valuable
versus being in the method of some class
that has a bunch of fields trying to
figure out how you got there or how to
get back there in order to test it I
think functional programming is
essential for concurrency how many
people have read Java concurrency and
practice fantastic book absolutely
fantastic how many times as he mentioned
immutable in that book tons the problem
is it's hard to take that advice in Java
because there are no
mutable classes and there are no
persistent immutable classes like I'll
describe so it's hard advice to follow
but it's certainly I mean he's not
advocating functional programming but
his advice about immutability works for
functional programming if your data is
immutable
you don't have concurrency issues they
can't exist because you're not changing
something that's being shared there are
other benefits to functional programming
that don't accrue to closure because
closures not purely functional because
you can't prove something about codes
you can't prove it never calls Java some
of the things you can do with Haskell
you can't do with closure on JVM there's
a couple of choices but not very many
Cal would be one that's going to give
you the Haskell like experience I don't
know if so much about it except it's
that kind of a language and on the JVM
Scala I think gets a lot of talk in this
area but I'm not sure they're
immutability story is consistent enough
to deliver here
I'll go easy because I don't know
closure however is as a functional
language all those data structures I
showed you are immutable and persistent
so what does that mean well again if you
have an immutable data structure or
something you want to pretend was
immutable all you have to do is not ever
change it the trick comes from well you
usually have to change it or you at
least you need to make a modified
version of it and what is the cost of
making a modified version of course if
you could modify it from an efficiency
standpoint it's pretty easy you know
just take what was there and put
something else in place that brings into
play all the problems of how do you
understand your program and a bunch of
problems for concurrency what it so
there's something called persistent data
structures and here the board
persistence has nothing to do with
databases a lot of times people hear the
word persistent they think we're storing
something on disk that's not this notion
of persistence this notion of
persistence is this the collection is
immune
when you produce a new version of the
collection the old one is still
available and when you do that all the
operations all the performance
guarantees of the operations imply by
that collection type are still true of
the new version and the old version
right which means you want to add
something to a vector okay well I
promise you adding something to a vector
was near constant time
you can't copy the whole vector and make
that performance guarantee right because
copying the vector is linear time so
somehow behind under the hood closure
has to have a way to produce a new
version of the vector without modifying
the old and without breaking the
performance guarantees which are you
know the ones I said before look up
clients for hash tables and insert them
and access times all those guarantees
have to be maintained so by implication
the new versions cannot be full copies
right that's just logic all the data
structures have shown all the data
structures in closure are persistent
they have these characteristics they
maintain their performance
characteristics across quote
modifications and they they have some
interesting implementations which I
don't have time to talk about if you
wanted to look up how I did it you could
look up array mapped hash trees and
Bagwell and you can see the
implementation underneath the hash map
in particular and the vector I also have
a sorted map and that's just it's kind
of a standard ripple red-black tree with
login access and lookup characteristics
so how does this work well the way it
works is that the new version has to
share some structure with the old
version right in order to not have a
full copy you have to share something
with the last version and that's called
structural sharing and that's how you do
efficient copies you don't really copy
very much at all you build a new little
bit over here and have a point at the
old bits because everything is immutable
and final
there's no chance of interference if I'm
making a modification to X and you're
making a modification to X and we end up
sharing state with it well because it
could never change we can share state
with it because we're never going to be
corrupted by a change to the thing we're
sharing and so on and so on and so forth
that means they're thread safe means
they're iterations safe there's no
concurrent modification exceptions or
any of that nonsense
so how does that work well in general it
works and I can't describe the
implementation of these things in less
than two hours each but in general it
works by path copying these kinds of
data structures under the hood are trees
and when you make a modification what
ends up happening is you had this tree
the inside of a hashmap
the rest of the street if it ends up i
no longer pay attention to the old
version what happens the parts of that
going to get TC so it's not like we
accrue infinite references to things and
keep around forever the things we don't
really use anymore get TC so if I never
held on to this over the rest wouldn't
because the new one is still pointing to
them but if I did keep it around the
person accessing this one would be
totally happy nothing happens in their
data structure and so on and so forth
does that's just a general idea ok ok so
far so all of the closure collections
have those properties
I'm not making a copy right same kind of
a thing
you're still a path copy right I'm going
to end up with a pointer to a tree
where I'm going to change nothing's
going to get garbage collected until
it's all the references remember these
are all nodes so that garbage
collections per node not for the whole
entity
linked lists are easy because everything
happens at the head and you know that's
it's actually the trivial canonic
persistent data structure is the Lisp
linked list the the other two it ends up
the vector and the the hashmap are
similar structurally they're both hash
array map trees it's just that in the
case of the vector I know what the keys
are all the time they're always integer
indexes so it is a different
implementation but logically it's not
different
oh well there's some other details but
now that these were hard data structures
to write these took me you know years of
research and work but the performance is
good and the benefits are unbelievable
being able to just freely give somebody
something and they can use it any thread
they want and nothing bad could ever
happen and they could make incremental
changes for minimal cost just put you in
a completely different world in terms of
the way you can look at designing
systems all right so now we'll put that
into context I think even if you set
concurrency aside using those kinds of
data structures and taking a functional
approach to writing your programs is
going to give you much much better
programs much more reliable much easier
to test and understand and maintain but
when you put concurrency in the loop
there is no longer any contest nothing
compares to using this kind of a
strategy in designing your program so
let's talk a little bit about
concurrency what do I mean when I say
that I mean interleaved execution
simultaneous whether it's actually
simultaneous or simulated simultaneous
the key thing is that operations will be
interleaved some of some will happen
some of another will happen and we need
the program to see consistent data and
to produce consistent data no matter
what the interleaving is there are
simple scenarios in which that's easy to
achieve as you get more data as you get
more sharing it becomes much more
difficult as you get into operations
that involve more entities again the
difficulty level increase
everybody here is a multi-threaded
programming knows about deadlocks lakh
orders and everything else it is hard
there are other things that you can mean
when you talk about concurrency and
particularly you can mean parallelism
I'm not talking about that here my dens
of closure does have some neat parallel
stuff I just recently added that's built
on the fork joint which is beautiful
parallel Map Reduce all those functions
I showed before you can get automatic
parallel they'll use every CPU in your
machine you still say Mac sweet ok it's
my favorite slide I'm going to have this
in every talk I do from now on it is my
opinion that object-oriented programming
as delivered by Java etc is not a good
default way to structure your program it
simply is not and believe me I'm not
sitting from the outside saying that
right I was one of the first people who
program in C++ and I've worked in that
language for lots of years and was
expert in it done tons of stuff in
c-sharp and Java and I have had it is
not right and there are many reasons why
one is it is spaghetti code
encapsulation does not change that
ok encapsulation just means I'm in
charge of the spaghetti code it does not
change it from being spaghetti code
which is all the side effects the
inability to look at a function and
understand what it means or to look at a
piece of data and understand how it got
there it's hard to understand it's hard
to test all of these testing frameworks
is that about an inherent problem of
programming or is it about a problem of
the programming languages I think to a
large extent it's the latter right all
these mock objects all these things you
need to get back into the same place so
you could try to execute a test is is
all built around the fact that these
languages are not really giving you a
good default object-oriented programming
was born in simulation you know it's
pretty good for that then it was used by
framework does
who had to provide interfaces to staple
things like the disk or the screen or
sockets well guess what
object-oriented programming is pretty
good for that too because there is
actually really state that corresponds
to these objects then they wrote these
nice frameworks then they gave you a
language that lets you do that then what
is every application programmer do they
don't have to abstract the screen that's
in the library there have to do the disk
or the sockets what are they doing
information well guess what that isn't a
good object at all a person class or an
account class that's ridiculous thing
right you can't change an account
anymore you can change the day of the
week it is the day of the week tomorrow
that's another day it's a different day
it's not this day plus a day or this day
you know it will it is this day plus a
day if you do it functionally but it's
not this date changed with an additional
day so yeah but but it's the whole
language implies here's your class here
your fields by default on our final
write your you're set up to do the wrong
thing so it's hard to test understand
and reason about from a concurrency
standpoint it's a complete catastrophe
it's a disaster it's unworkable right
eventually you will die with locks
you'll either die trying to make them
work trying to understand them or just
from the stress it's not going to work
so as a default architecture for a
program I think it's not very good but
doing the right thing taking the advice
of gets and making the stuff immutable
it's really hard because it's not
idiomatic in Java right it just simply
isn't everything in the language is
telling you do something else
let me let me keep going I agree there
is a need in real programs to have
things appear to change absolutely I you
know and that's an area where I think
closure you know disagrees with Haskell
where they're trying to say well you
know we really don't want to do that and
you know if your program is
fundamentally a calculation I think you
can get away with that most programs
I've written are not calculations I've
written your broadcast automation
systems at the run 24 hours a day and
there's all kinds of all kinds of state
and all kinds of things that have to
appear to have state but there's a
difference between appearing to have
state and having state and we're going
to see what that is so what are the two
ways of doing this one is the
conventional way right which is the way
you have to build a program in
traditional object-oriented language you
have references to objects and those
objects can change you have direct
reference to a mutable thing okay
what is your op what is your obligation
when you're trying to make that
concurrently safe you have to lock right
because you have to keep you from making
these changes while you're trying to see
something consistent or while you're
trying to make something consistent cuz
you're all changing the same thing the
same space so you have to lock and you
have to worry and everything about it at
least in Java today and languages like
it which is you know everything is
manual and by convention there is no
language support helping you do this
correctly so now
there are some locked free data
structures but if you look at well where
I'm going to talk about transaction over
in a second but there's there two
different things locked free data
structures usually don't support
composite operations but transactional
memory does let me let me keep going so
the conventional way is that everybody's
looking at the same space and that space
you know can get scribbled on by anybody
else and there's all this quickly I'm
scribbling on the space and you know
wait I need to see it don't scribble on
it I'm trying to understand it that's
how your programs work today
it's crazy especially when there's
multiple spaces and now well I started
to scribble on this already
I scrambled on this and I need to
scribble on that what are you going to
do crazy so there's another way and
there is another way right we don't have
direct references to things that can
change
we have indirect references to things
that can't change and what we can do is
make those references refer to other
things that can't change and we can do
that atomically so the other model that
makes it appear that things are changing
in your program is that you have
indirect references to immutable data
structures that are persistent I'll
explain it in a second and you have
concurrency semantics for those
references in other words you can say
the only thing I'll let you change is
this box the box is going to point to
something they can't change and you can
change this box only by atomically
making a point to something else that
can't change and closures provides three
kinds of boxes or references that all
have concurrency semantics in other
words they all have rules about when you
can change what's in the box
and none of them require any manual
locks for the for the programmer so this
is the this is your this is your program
today right you've got a reference
directly
which has random who knows what in it
because as soon as somebody else can
have that same kind of a reference they
could be changing it and the only way to
turn those question marks into something
concrete is to stop the world from
touching that thing while you either
touch it yourself or read it yourself
there's no other way okay
so ensuring a consistent object
completely Falls to the programmer it's
completely manual and by convention and
as you get more objects and more objects
that need to be changed in a single
logical unit of work this fails this is
the closure way in direct references to
immutable objects so we have this box it
has the reference to a thing the thing
of a person that's a mutable persistent
data structure ain't never going to
change so now let's say I'm the user I
need to read it I can look in this box I
get a reference to it am i whirring no
cannot change if well I got this out
let's link to the box so I care no I
don't care
there's never an inconsistent object so
how do we fake change okay well we
change so we know everybody that's
looking at that box is seeing the other
thing then atomically we update which
means we change the box from referring
to the one thing to referring to the
other thing and if if that change of the
inside of the box is controlled with
concurrency semantics you're done
are you suggesting the
no no no no no no not at all
what you have a reference in your
program is the best and any point in
time you want to you can say give me
what's in the box and at that point you
get around that no addresses get swapped
out from underneath you but the contents
of the box may change so all you need is
concurrency semantics for the box and
you have a working system that the
program is named to worry about so
closure has three kinds of boxes I don't
have enough time to really describe them
all but I'll just say generally what
they are there's a kind of box that
allows you to isolate change within
threads in other words I have my views
the world in my thread you have your
view of the world in your thread you
can't even see my view of the world I
can't see yours in other words we have a
logical box called Fred but when I'm in
my thread I see a different contents of
the box than when you're in your thread
you see your own box the mapping there
logically is thread-local storage okay
so there are boxes that are implemented
in terms of thread local storage
that's a concurrency Samantha it's a
concurrency semantics that guarantees
isolation within threads now let's take
on the harder problem the harder problem
is we'd like multiple threads to see the
same set of things to see changes that
each other makes more sharing and there
are two kinds of boxes and closure that
do this one are references Refs
I should they're all references the
boxes are called references there's a
particular kind of box that's called a
ref a ref is transactional the rules for
ref so that they can't be changed except
in a transaction and what they allow is
first shared synchronized coordinated
changes between threads I want to change
these three boxes to be whatever they
will keep anybody else from doing the
changing those boxes until you're done
or maybe they'll change them and you'll
have to try again
so that's transactional the other thing
it has is agents where every individual
box is completely asynchronous you can
request a change and eventually that
change will happen but you can't see it
until you go
for later and the order of those changes
being made is non-deterministic outside
of your single threat noise you send ABC
you'll get ABC if somebody else since D
and E they can get in Philly it's
exactly the change semantics of actors
but the implementation is much different
than scaler or or allowing actors so I
call them agents you can't do
synchronous changes that way like I'm
changing two things so let's talk about
the most powerful of closures references
which are the transactional ones would
solve the hardest problem the hardest
problem is I want to move something from
here to there and I want it to be either
here or there
never in both places and never in
neither place in order to do that you
really need to access two separate
things so that's a hard problem with
locks because you have no lock
acquisition order and things like that a
what locks cover which objects and the
way its closure does is with something
called a software transactional memory
if you've ever used a database it's
really easy to understand it's like a
database it's a transaction you say
start a transaction do some stuff right
and the promise of the STM is that
either all those things will happen or
none of those things will happen notice
you're going to see all the effects
you'll see none of the effects so if you
look at it from the acid properties its
atomic and it's isolated there's no
consistency because there's no like
constraints on the data that's the thing
I could add there's no durability
because if we're in memory with this
stuff so every change made to rest
within a transaction occurs or none do
and no transaction sees the operations
of any other transaction so it's exactly
like a database except it's in memory
what's the result of that well some
transact and transactions are
speculative what if we both try to
change the same box well only one of us
is going to win the other one's going to
have to retry and those retries have
done automatically
STM so you're going to go back in you
may see well now I can't do what I
wanted or I can do it I just I'm going
to do with new data new information what
that means is that inside a transaction
you have to avoid side effects I can't
enforce that so if you print in a
transaction you may see it happen
multiple times if your transaction is
getting retried so don't print
oh yeah I mean a lot of the closure
infrastructure is employers is I think
pretty nice Java library all the data
structures are written in Java the STM
is in Java you can use it all I mean
when I was building it I had to test it
and before I had closure the language I
had closure to the library so yeah you
can
well retry until it can't and then there
are sort of limits there's retry limits
and timeouts and things like that to
govern give up no it looks like a
function call and it returns yeah I'm
going to show you that in a second yes
Nestea transactions get absorbed by
parent transactions they don't have
independent commits so it's not like
true nested transactions but the fact
that they get absorbs means it absorbed
means it is very composable so if you
wrote a unit of work which was
transferred from account to account and
then you needed a shuffling transfer
which you know transferred from A to B
and B to C and that called transfer
twice if you put that in a transaction
all those transactions would be one
transaction and the whole set we got to
succeed or fail together the difference
between doing this and doing programming
concurrent programming in Java with LOX
is night and day it's just a completely
different world because this is
automatic the language is going to do
this for you if you put your things and
reps and your things are immutable you
can't do it wrong and you can't forget
and you can't get your locker order
wrong and you cannot deadlock
yeah that's cool
debugging your manual locks I mean there
are tools for helping you do that I'd
rather not even go there not that I'm
aware of no I mean the lock analysis is
a research problem still even with
static information in a statically typed
program and with lots of declaration
help you still don't really know the
order of operations because you have to
track all the flow control on your
program so you don't need to go there at
all with closure these mechanisms are
completely independent of that kind of
stuff and if you look at the STM you'll
see some really hairy Java locking code
but I had to do it and now you know so
I'm going to show off a little bit here
a little demo I'm not going to have time
to explain the code but I'm going to
tell you what the program does it's a
simulation of an ant colony and the idea
is that there's a world populated with
food and ants and the ants are foraging
for food
they're trying to bring it back to their
home they're going to drop pheromones on
the way as they're working they're going
to sense pheromones and try to you know
follow them it helps them do path
following or finding food or finding
home they're going to sense food and
obviously try to acquire it and they're
going to sense home or they're going to
drop stuff off the trick here is that
ants act independently in multiple real
threads and green threads or prepend
threads or round-robin or tick every ant
faking it this is real so you could do a
simulation without doing this but what
this does show you is what if there were
50 or
I have 50 threads trying to modify the
same data space because that's what
these ants are doing they're walking
around and looking at the same spaces
they're picking up food I mean somebody
has to pick it up somebody can somebody
can occupy that space and the other one
can there's all kinds of collision
problems there's all kinds of multiple
cell problems because when an ant does
is it looks around itself to see is
there stuff so it may look at three
cells well those three cells may overlap
a little bit with some cells that other
answer looking at so there's overlapping
irregular data usage patterns this is a
really really hard concurrency problem
as opposed to like we all know we're
going to touch this and max all all
going to touch this and then that that's
an easy concurrency problem this is a
really hard concurrency problem so the
ants act independently just to make it
harder will mono thermal and evaporation
so the pheromones are evaporating in
parallel and of course we should have an
animated GUI and we should do it in less
than 250 lines right so this is a this
is the code and again I can't walk
through all of this but I do want to
show you what a transaction looks like
this that's complicated
this simulation uses both the agents and
the STM but I'll just going to show you
the STM so going to look at turn here
and what turn needs to do is modify the
place that the antis is at and really
all you need to do to have something be
transactional is to put it in a do sink
you just say do sink and you do whatever
work you want manipulating wraps and
this at sign is dereferencing a rep so
this is actually going to take it and
ant in a transaction and change its
change its state of course it doesn't
really change just Pierce or change to
anybody who looks in the same place so
that's all it takes you say do sync and
do your work they're bigger transactions
down below take food would be a good one
so take food you're potentially you're
potentially fighting with other ants
this is an example of some code that's
designed to be called in another
transaction so you can see i'm
dereferencing well maybe you don't save
it all these app signs are dereferencing
a box
get me the stuff that's in the box right
and then these things this one
decrements this altar call actually
changes the place to have a different
amount of food in it so that's going to
be need to be done in a transaction but
you notice I didn't say do sync right so
what should happen if I call this and
you do you get an error so that's what
you want you don't have to manually do
enforcement closure does enforcement if
you tried to call this outside of a
transaction you would get an error it
happens to be the case that this gets
called inside a bigger behave function
which does it and other things inside a
transaction so automatic enforcement
this is the kind of language level help
you need that you're not getting from
Java so they move around they take food
I already show it off a little GUI code
before but you can see you know it's
rendering and painting and doing image
drawing you know buffered images and
all that stuff it's really pretty
straightforward Java there so we have
loaded that so here's our world home is
this blue box on that graphics guy so
that's the part of my my primitive
graphics we'll create a set of ants and
will establish the food so the fruit of
the red dots and then we're going to
send off behave actions to the answer to
answer agents so the ants use the agent
system to act in parallel and they use
the transaction system to coordinate
modifications to the world that's a
really simplistic description so we
started off the ants they all start at
home and they start wandering around the
green is the pheromones that they're
dropping and then I'll start up another
thread which is the evaporation thread
which will cause that to evaporate it
was this whole thing turned green whoa
my rep has 69 threads so there's a whole
bunch of ants there all have their own
thread they're all interacting with the
environment there's no way to see this
because it's moving but at no point will
two ants occupy the same space take the
same food place food in the same place
all that works and there's no calls to
lock or anything else no because this is
set up to be real-time in those if I let
this run as fast as it can
it would you wouldn't really get a good
like the answer moving effect but it's
taking more than 100% CPU so you do know
it's doing something right and see 120
but there was there actually are some
sleeps in there and to paste this thing
so that you get the sense of motion
but this may not be the kind of program
that you write but what this implies for
programs that do use multiple resources
from multiple threads is enormous just
saying do sync putting your stuff in
references and saying do sync around
your work and doing your work in any
order you want and knowing nothing bad
can happen to you is just a completely
different world but it all goes together
this couldn't work if what was in those
references wasn't a persistent data
structure because you need the ability
to do that in transaction modification
that's speculative modification
efficiently if everybody that read a
transaction had to copy the data that
they were going to slam back in there
who would not scale so the persistent
data structures it all goes together
closure is of a single mind and it's
designed to you know to get here I mean
I think there are lots of value to
persistent data structures being able to
use a map like a list and recursive
things but you couldn't do with a hash
table in Common Lisp you can do that
with maps you can use it because they
are structurally recursive the maps and
the vectors is very neat but this I
think is almost impossible to do
otherwise and know that and know that it
will work I mean you can think you check
below your law borders and you know you
wrote down on napkins what to do when
but the next guy gets in there and
changes your code and who knows if the
program still works and that's what
really happens in multi-threaded
programs so we'll let that go
so that's a pretty small program and
there's it's not cluttered with
threading stuff you start threads you
say agent go do this it's often another
thread off a thread pool you know it
uses old Java goodness on underneath
there's a whole lot more to closure I
went pretty fast and I have just
scratched the surface I haven't shown
you all kinds of things that has
metadata there are ways to write loops
that are functional it has destructuring
as somebody asked before it has list
comprehensions which you might know from
either Haskell or Python there's a whole
set of things for relational algebra all
functional that allow you to do things
like joins of these maps and sets of
these maps there are multi methods which
are like generic functions but are even
more general than allow you to do things
like polymorphism without type
hierarchies basically saying the
function to call when you get these
arguments is a function of the arguments
which is really what dispatches except
it's always a function of the class of
the first argument that's just a very
narrow subset of what real generic
dispatches which is dispatched based
upon some characteristic of the
arguments find the function then call it
closure supports that supports
parallelism as I said before I haven't
shown you namespaces they're functional
zippers XML support any questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>