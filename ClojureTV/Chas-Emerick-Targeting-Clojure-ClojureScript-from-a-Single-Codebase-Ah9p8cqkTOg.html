<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Chas Emerick - Targeting Clojure &amp; ClojureScript from a Single Codebase | Coder Coacher - Coaching Coders</title><meta content="Chas Emerick - Targeting Clojure &amp; ClojureScript from a Single Codebase - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Chas Emerick - Targeting Clojure &amp; ClojureScript from a Single Codebase</b></h2><h5 class="post__date">2014-03-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ah9p8cqkTOg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is chaz emmerich some of you
may have seen my name or my handle
floating around the closure community
for a while and I'm happy to thank you
so today I wanted to talk with you about
something that's sort of on the surface
a little mundane perhaps but it's I
often find myself dealing with these
sorts of bits of plumbing and this one
in particular proved to be a
particularly challenging bit of plumbing
but one that I think has turned out to
be produced a very positive outcome so
what we're talking about is targeting a
closure and closure script from a single
code base and generally people refer to
that as portability I'm sort of going to
use that term although i think there's
there's a lot that's wrapped up in the
term portability that i'm not going to
speak about here necessarily so just
forgive that sort of semantic shorthand
but before we get into the how for a
second i just want to back up and talk
about why you would want to do this and
this may be obvious to many of you but
too many people it's not so the so you
know the common trope about why you
would want to have a single language and
obviously closure and closure script are
not the same language but people see /
ends and like to conflate things but the
but but a but a typical trope is that
you want to have a common set of
validation routines on the client side
on the server side and well that's sort
of true I think that's a really horrible
use case to provide as a motivating
example of why you would want to have a
degree of portability between your your
your code targeting two different
execution environments in particular
compared to
closure you know closure script targets
the JavaScript language and JavaScript
environments these days are completely
usable as a general-purpose a
computation medium so what this means is
that you can deploy closure script
server side in node.js for example and
no jess was founded on the principle
that javascript is a reasonable language
to build arbitrary computations upon and
there's a large set of libraries that
allow you to do all the sorts of things
that you might do in closure and on the
JVM using servlets for example and all
the libraries that come along with that
and do it on the server instead using a
JavaScript runtime and in our case
closure script but beyond that you know
client-side applications targeting
browsers now have at their disposal wide
array of facilities that just five years
ago simply could not be fathom that
everything from far more advanced
accelerated graphics options to database
and storage options that really are
roughly equivalent in power to those
that you might find on the server side
and at the end of the day JavaScript
environments can go where the JVM can't
and so if you like the abstractions and
the leverage and the power that job that
closure provides but you do need to be
in some environment where you can't ship
a JVM or where you do want to take
advantage of some of the unique
characteristics of certain JavaScript
environments like the browsers then you
really do want to have a certain amount
of efficiency targeting both your
back-end systems and you know those
those distributed client-side
environments that that you need to reach
so now why do we need to think about a
solution for portability at all right I
sort of said flippantly that once people
see / ends they assume that things will
just sort of work out natural
obviously maybe not obviously that's not
true but to understand where the
differences between closures closure
script cropped up you have to understand
to a certain degree the history of
closure script so the first commit on
the project was three years after a
closure became public and the effect of
that is that it was built with the
benefit of all the experience that rich
and everyone else in the closure
community had gained over those years
and building closure using it and really
sort of coming to grips with the
strengths of it as well as some of the
weaknesses that you know one might want
to address in a new language that had
the same kind of syntax semantics and
leverage that closure has so for example
clojurescript assumes that protocols are
available whereas protocols and closure
only landed i think in 13 and this this
means that there's a simpler easier set
of base abstractions that you have
available for use and closure script
compared to closure which relies on a
host construct Java interfaces to
provide that those those base set of
abstractions also in the in the process
of building closure script portability
was almost explicitly not an objective
from the beginning closure has been
characterized as a hosted language and
what that means is is that the host is
not hidden it is all the facilities that
provides that are useful are used as is
within the higher-level language either
closure or closure script and this means
for example that you don't use a closure
string in on the JVM you use Java
strings and likewise for JavaScript but
in the process of because portability
was not an objective in the process of
sort of refining those based
abstractions for example through the
protocols there's a whole bunch of sort
of off by one naming differences which
you know if you're moving from closure
to closure script it's very
straightforward to you know find a
corollary function in the core namespace
or to identify protocols and closure
script that correspond to the Java
interfaces in enclosure but if you're
trying to build a single code base that
targets both environments this is sort
of the very first thing that you run
into especially when doing maybe more
sophisticated things like providing
protocol implementations for custom
types and things like that aside from
the the naming question there are some
very material differences between
closure and closure script one that
people are sort of confronted with
immediately although perhaps they aren't
sure why why things worked out the way
they did is that clojurescript has a
hybrid compilation model what that means
is that the macros that are used that
that you use including things as simple
as if let for example those are written
in closure and macro expanded enclosure
prior to the actual closure script
emitter getting getting ahold of them at
all and because there's these sort of
dueling namespaces in your name in your
NS declaration you actually need to
bring those macros in using a different
different directive essentially and so
this is this is one thing that that
people sort of butt up against
immediately whereas if you put you know
require macros or use macros in a
closure script file even if all the
names are exactly the same you can't
load that enclosure clear script doesn't
have any runtime namespaces and so that
can be an issue depending on what you're
what you're doing in in detail and then
of course again it's a hosted language
just like closure and so there are
there's all the issues and baggage that
come along with targeting the JavaScript
host that means there's a bunch of
missing primitives in particular numerix
and things that aren't primitives in
Java but we sort of like to treat them
as such like the arbitrary precision
numerics there's a there's a less
capable execution model
in this I'm largely referring to the
fact that javascript is single threaded
fundamentally although there are some
other details that you end up bumping
into and then you know all the other
things that JavaScript provides in its
good graces so we need to work around
all these things and so if you are
convinced of the benefits or necessity
of targeting these two platforms with
the same with with the same code base
then you need to have a way to address
them of course you could just not
address them within a single code base
and have one code base for closure and
one code base for closure script and
people do this it works there's
obviously a cost associated with this so
for example you know some of the some of
the most popular nearly language level
libraries like core async take this
approach where they really are working
with the host environment very directly
and so there's perhaps not as much
shared code that you might want to
deploy to JVM closure versus closure
script but there's a there's a there's a
resource toll there and personally since
I am largely working on my own or with a
very small set of collaborators and
contributors having two separate code
bases is sort of infeasible in terms of
just the economics of things you could
carefully keep portable and not portable
code separate right and this is a
typical pattern where you might have the
implementation detail bits for each
target platform in a separate namespace
and then a common API that refers to
each depending on some some runtime flag
or some
fly be provided in the course of
compilation and this basically works but
the problem is that when building real
applications as soon as you need to do
something that is Hosty or otherwise not
portable you end up having to
restructure your application and library
to avoid having that host e'er
non-portable call in your portable
namespace and so you end up having this
sort of proliferation of name spaces
that are being created strictly to
satisfy the portability concerns as
opposed to focusing on the domain that
you care about and if you manage to
avoid doing that you end up having sort
of like a lowest common denominator code
base where you are where you're not
taking advantage of the things that your
target environments offer and this can
have implications both for performance
and for functionality there one of the
earliest options for addressing
portability in the closure script world
were these things called crossovers in
line C ljs build and what crossovers
word would sort of handle the require
macros and use macros declaration
differences and assume that your writing
is sort of portable perhaps lowest
common denominator code and copy them
copy that file from its dot clj position
to the same corresponding file name with
a dot C ljs swapping out that use and
require macros bit this worked for some
people in some areas since i've started
maintaining line c ljs build and given
my work in other areas I've sort of
declared that this is deprecated and
should not be used it was a severe and
clever hack to begin with but it's not
something I think that we should be
using anymore so the final option that
I'm going to talk about is that you
write code once you do have a single
unified code base that targets these
very divergent
execution and deployment environments
and then you translate that single code
base as necessary to cope with the
target environment differences on either
side and this is called pre-processing
in other areas so if anyone has ever
done any C or C++ programming you should
be very familiar with the c preprocessor
and other preprocessor systems and they
are very straightforward you have a set
of source files that represents your
single unified code base that you have
written to hopefully target multiple
runtimes or execution environments you
have a compilation environment that sort
of describes which which target you are
compiling for you have the actual
preprocessor which takes in that
environment and your source files
produces a set of environment specific
source files that suit the target
runtime and then those go on to your
actual compiler to do the work of
compiling for that target environment
and so you know there are there's plenty
of examples to see what what C
preprocessor macros look like and this
works it's the way things have worked in
terms of writing portable code bases in
other environments for decades and
there's certainly a trade-off here in
terms of the sort of real estate that
you need to accommodate these
portability directives but at the same
time there's also a benefit that when
you are going through and maintaining a
portable code base you're not looking
for an implementation of a function in
five different files if you have five
different target environments there's a
there's a benefit in terms of keeping
portable code together so that you can
address issues and bugs across all your
environments very readily within the
same within the same frame essentially
the correspondent concept it's called
feature expressions this is something
that's existed in common lisp and other
lisp implementations for near around 30
years I think and this is an example
pulled from the Common Lisp I perspec
where you have a set of features the
list bem spice symbols here identify
features that might be found in a
runtime list in a common lisps case of
different features that are available
and when the compiler sees this form it
uses the hash plus or hash minus forms
to look up the name symbol and if its
present then the annotated form within
the expression is spliced in if it's not
then it's removed and Common Lisp also
has support for conjunctions and
disjunctions of these symbols which this
third example shows so if you type this
expression into a common lisp compiler
or interpreter and define these these
these feature symbols as described here
then you'll have totally different forms
that are being compiled so now CL JX
getting it into the meat of things is a
library and lining and plug-in that
implements feature expressions for
closure and closure script and it's a
fairly faithful implementation of this
so it operates entirely outside of the
reading macro expansion and compilation
of closure script this is important and
I'll show you why once we start looking
at a couple of examples because even
reading closure code implies that you
are within a run time that does things
like aliased namespace keyword
resolution and things like that so you
really do need to be performing this
feature expression transformation prior
to any closure or closure script
component or compiler even looking at
the code second of key sorry so though
so though so the transformation rules
are applied to a lossless representation
of your code so if you've played with
the reader at all you'll know that when
you read in some closure code you sort
of lose a lot of meta information that
we all find important it's like the
formatting comments that sort of things
so if you read it an expression and it
printed out using PRS or something like
that you lose again formatting and
comments clj X uses the S jacket library
from Christophe Grand who's been helped
quite a bit in recent months and years
by Colin Jones and maintaining that and
so what that does is it ensures that
when the CL JX transformation occurs you
don't lose the comments line numbers
column numbers of the code that is been
actually being passed on to the closure
and closure script compiler and one of
the most important parts here is that
when you use CL JX you use it you see it
but your downstream dependents do not so
this means that you can use CL JX to
write a portable closure enclosure
script library and the people that use
that library never have to know that you
use CL JX at all so when you jar up the
result of clj x's transformation there's
no dot clj X file it's just closure
files and closure script files and those
can be consumed downstream by anyone
without touching or even knowing about
CL JX and i said as i said it's it
provides a lining and plugin which we'll
see in a second and also has integration
with n rebel and it's its process looks
exactly analogous to other preprocessors
like the like the c preprocessor we have
dot CL JX sources it's critical to use
that separate file extension because
that's
CL Jack's identifies CL JX code you have
configuration and or a a section type on
your end rebel connection that's all
managed by CL JX and that sort of
defines whether you're targeting closure
or closure script clj X uses that
information and your sources to produce
closure or closure script sources or
both depending on certain bits of
configuration and those are passed on to
the closure and closure script compiler
entirely separately and so now to start
taking a look at what this looks and
feels like in practice this is the NS
declaration from a CL JX library that I
maintain called PP RNG it's a portable
see tible random number generator api
for closure and closure script necessary
because the default random number
generator in javascript does is is not
suitable I needed this because of my
need to use property based testing at
the time read raper simple check now
test check I produced a closure script
Fork of it it's actually portable
closure and closure script a simple
check called double check and this is
one of the components i needed a sea de
belÃ©n de mer generator so that i could
rerun failed property based tests in
javascript given the seed that was used
to start the random data generation so
we see here there's directives the hash
plus CL J&amp;amp;C ljs these correspond exactly
with the common list feature symbols
that we saw earlier and therein you can
use these to annotate any form so in
this case there they're only annotating
lists here the require require and
import list within the namespace
declaration but you can prefix any
symbol keyword list vector map any form
enclosure and closure script with one of
these
annotations in order to identify whether
they should be included or not included
given the given the configuration of
your environment so when you transform
that input targeting closure it's going
to we're going to bounce back and forth
you can see very clearly it's I
mislabeled the slide this Atari
enclosure script so it's so it's
stripping out the forms that are labeled
as targeting closure and leaving only
those that target closure script and
likewise when targeting closure it
reveals the obverse and now notice that
the line number positioning remains the
same this is critical in maintaining a
correspondence between the line numbers
reported in stack traces for example and
the original source forms so this means
that when a downstream user of yours
gets a stack trace and they do a you
know navigate to definition based on a
file name and line number they're
actually going to land where that
exception was thrown as opposed to where
it was thrown from a potentially mangled
set of sources that were produced by a
transformation that doesn't do this kind
of line and column number preservation
so knowing this let's let's take a look
at an example here just going to
demonstrate how you use CL JX let's make
this from line again it's just another
task that you run very similar to line C
ljs build if you're using this in a
pipeline that includes closure script
compilation then you would just add you
know comma C ljs build once or test or
whatever whatever your objective is CL
JX is going to find all of your CL JX
resources transform them based on your
configuration
put them where you tell it to put them
and so here's what it produces on the
left here we have the original input
file the CL JX file that implements the
sea tible portable random number
generator and on the right is the
closure script output of cl JX and so
you can see that all the line numbers
correspond properly it's stripping out
all the bits of code that are annotated
as being annotated as target enclosure
and you're left with a closure script
file that you can pass along to any
tooling that expects a closure script
file including the compiler and likewise
for the for the for the for the closures
side of things right so that's pretty
straightforward and what I also want to
show is
something that I'm particularly happy
about what you might imagine is that
since this is a from what you've seen so
far a lining and plug-in that integrates
with that sort of workflow on the
command line is that it's just working
with files on disk so it takes to CL JX
file produces closure and closure script
files and then the respective compilers
pick them up on the other side that
workflow is fine but I like rebels I
assume you like rebels and so I
certainly don't want to constrain your
use of clj x2 when you're running lining
and task for example and so I managed to
integrate CLG X into n rebel using some
n Ruppel middleware and very
straightforwardly what we want to do is
load and a bow clj Xcode just the same
way that we about closure and
clojurescript code when we have a
closure or closure script rebel open and
further we want to not just be able to
provide clj xcode to be loaded and
evaluated we want to require namespaces
that happen to have been happen to be
implemented using CL JX locally without
running that CL JX trance transformation
ahead of time and so this is this has
been done and works well using a piece
of and Ruppel middleware that hooks
closure core load and the corresponding
function in the closure script compiler
and this is safer than it sounds there's
there's a little bit of sleight of hand
here but the but the but the functions
being modified here haven't actually
changed enclosure since version 13 and
so swapping in our own our own
implementation of these from CL JX is
reasonably safe and similar caveats
apply or a similar situation hold with
closure script so going back to our
example here so I already did a clean
and
just to just a show there's nothing on
my sleeve here there's no closure
sources here there's the sea Emmerich
PPR ng clj X file but no closure so I'm
in my closure rebel but i can still
require oh right
that's bizarre
later
now I'm hoping that the demo gods don't
kill me
and they are killing me
hmm
oh that's why
excuse me momentarily
I this this PPR ng product has actually
been stable for quite a while so the so
the N rebel support it was using an old
version of cl JX
works so now I can load thank you so
it's that's a that's a reasonably recent
feature the addition to support loading
CL JX code in closure rebels was added I
think in version 03 to the support for
the closure script side of things is
actually only on the most recent
snapshot that's something that I very
recently put together and so this works
this works very well and so my work for
the past probably year or so has been
focused entirely on building a set of
libraries and an application that are
sort of sort of aggressively
sort of aggressively portable and I have
a feeling that impress has crashed
it has
anyone know what that process name is
ok
excuse me so yes so the so the N ripple
middleware support works it's safer than
it sounds i've been using it personally
for probably the past three months or so
and again working on a set of libraries
and applications that are sort of
aggressively cross aggressively portable
between closure and closure script and
it's actually been started to be used
fairly widely as these things go in the
community a couple of very well-known
libraries including prismatic schema use
CL JX and are written entirely in CLG x
so they can be used both enclosure and
closure script and so just to close i
want to talk a little bit about some of
the shortcomings of this approach and
maybe some of the sort of unexplored
opportunities at it that it offers one
thing is that a CL JX does not have any
does not provide any story in terms of
writing portable macros so as i was
saying before there's a hybrid
compilation process going on here where
when you're targeting closure script
your macros are implemented in and
executed within closure and so if you
are writing a macro that you want to be
able to use from both closure and
closure script you need to emit code
from that macro that is targeting
closure and closure script respectably
CL Jack's does not say anything about
this it's not looking at your macro
files which are necessarily closure and
so you need to handle that aspect of
portability on your own using the
environment provided to your macro for
example to detect whether you're in
closure closure script and then do a
straightforward switch in real
applications if you are not sort of
strategic about your use of the end of
the hash plus or minus annotations you
can go a little crazy with them
depending on the granularity of
portability that you're in
menting and get a fair bit of line noise
so what I generally do is I use the
preprocessor essentially annotations in
ways that minimize this it can get
pretty rough especially when you are
implementing a set of protocol methods
for a type just because you really do
need to interleave names of protocols or
interfaces and their implementation but
that's this is this is sort of just the
cost of doing business in this area in
terms of opportunities the feature
expression facility that CL JX provides
has a good deal of flexibility and there
is a provision for providing your own
custom transformations of code at this
level and so it's possible to if you
were so ambitious to provide a an
implicit renaming set of rules such that
for example you no corresponding
protocol and interface names could be
rewritten automatically without any
annotations whatsoever I'm not going to
recommend that you do this or similar
things using the transformation rule
flexibility that's available but it is
there and probably should be used with
caution and restraint but it is there if
you need it and then something that I've
only thought about and not worked on at
all is that I don't know if anyone here
is familiar with the hash racket
facilities in the racket language and
the power and flexibility that provides
to implement new types of syntax within
racket but I believe that clj X perhaps
with a couple of tweaks could be used to
provide this same level of control and
flexibility for us in the closure sphere
and that's something that I might tinker
here and there with so that's all I
wanted to talk with you about today I
appreciate your patience and
understanding with my slight technical
foibles but there's a couple resources
for you obviously CL JX
there has been discussion among some
people about the feasibility of rolling
feature expressions into closure and
closure script as a native language
feature which would remove the need for
something like the CL JX librarian
plugin there's a discussion with a
number of people although i don't think
anyone sort of from an authoritative
standpoint on the topic and for those
interested in history there's the Common
Lisp I perspect that describes what
feature expressions look and behave like
in languages of days of yore so I'll
take any questions if there's I think I
can take about two questions now if
anyone has one
the question is do I see any any way
that macros could be written portably
foreclosure and closure script there are
ways they are not pretty both from a
sort of usage and workflow standpoint as
well as from an implementation
standpoint I think I think the real the
real hope is that the closure script
compiler ends up eventually sometime
hopefully soon being able to run in
JavaScript as well and that would allow
you to have the same compilation load
model with enclosure script as you do in
closure that's my hope I rather not try
and skin that cat because it's actually
fairly fairly gnarly any other yeah you
didn't mention this but you know the
middle drain of having to work with code
that looks similar but is not exactly
the same as a problem because
and the other thing is I've been
thinking that it would be really nice to
to find you know however many dozen
things people who are extremely commonly
common idioms and Tori's grip like
printing out a line of text or something
and put inconvenience
yeah so though so the question is about
you know is there any you know thought
or plan or approach to sort of
addressing common use cases for example
you know printing to printing out text
to the appropriate console and things
like that so that we could obviate the
need for annotating there those
ourselves within our portable code bases
you know going back to the notion that
closure and closure script are hosted I
mean it's there are always going to be
other things that aren't going to be
portable I sort of think of this as a
typical 8020 problem where everyone's
eighty percent is different right and so
there are certain there's there's
certainly room for someone to build sets
of libraries using something like clj X
to provide these kinds of rappers or
higher level abstractions that are
portable between closure and closure
script and if that's something that
people in the community want to do then
then by all means the tools are
certainly available I think it's
probably going to be a tough thing to do
in any kind of general sense and so yeah
any yeah one more
sorry what
Oh
so the question is whether i use double
check for testing CLG x itself or code
bases that use CL JX o that I UCL JX
yeah so nearly all of the libraries and
applications that I've been working on
for many many months are all written in
CL JX and ever since i got the property
based testing religion thanks to read
and you know sort of just did the work
to make it so that i had a portable
property testing tool which is double
check in closure and closure script yeah
I use it extensively and I I can't
imagine doing testing any other way at
this point in ok thank you very much I
appreciate it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>