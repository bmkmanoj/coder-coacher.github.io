<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>miniKanren Philosophy - William Byrd &amp; Daniel Friedman | Coder Coacher - Coaching Coders</title><meta content="miniKanren Philosophy - William Byrd &amp; Daniel Friedman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>miniKanren Philosophy - William Byrd &amp; Daniel Friedman</b></h2><h5 class="post__date">2013-01-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fHK-uS-Iedc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we're going to start for
describing the entire language and then
after that
if we have a minute or two left it's
going to be completely interactive as
the other stocks have been there are
just a small number of operators so
we're going to start with the easy ones
there simbolo cimbalom bolo absolutely a
little change of pace here which
basically says if I ever get a value I
will be a symbol and then we have
another one called oh sorry wait wait no
you need to run I know
well we haven't you haven't introduced
well pretend like I have by showing it
to them this will get one value and it
will basically say I don't know what I
am but I do know that I will be a symbol
someday so we can do the same thing for
a number oh you could sort of guess most
of how that would work and then we have
another little one called
no oh we have no and we do have no okay
go ahead and it will take a symbol like
say closure what did that it's a five
that's a nice touch no food so this sort
of gives you an idea of that you can
keep a particular symbol from ever
entering a data structure of any flavor
now we do have those simple control
operators I hope some of you are
familiar with them one is called fresh
which introduces fresh variables and the
last one is called conde which allows
you to have lots of answers as you'll
see very soon we didn't
the most important operating language no
we didn't I think it's time yes we also
have a unification which allows us to
give values to variables in various ways
and we have this unification which
allows us to say two things will never
be the same
okay do we have edge okay okay hold on
let me do the fresh okay
and there you are so was it underscores
you did you say what an underscore zeros
underscore says I don't know what I am
ever going to be just it just hangs out
there okay so that's it wait oh yeah
have you done the Conde yet no oh well
there you okay all right so you can
unify X with five and now you know five
instead of underscores here okay let's
do a kind of you real quick real quick
one quick Conde just for the fun of it
okay so some tactically Conde looks like
conned scheme
all right so let's do that I guess okay
so if you say run one that'll say you
will get back at most one answer if it
exists and if you want you can do a run
two now in this case we have two answers
so in the first Clause of Q which is our
query variables associated with x and y
and in the second case that's associated
with five and if we want to get all the
answers for sure we can do a run star
and this gives us back a set of answers
and there are no more answers and it
didn't go an innocent loop which is nice
so that's a proof that those are all the
answers there to be had because our
search is complete and interleaving
so now what we're going to do is we're
going to take a very very simple program
and for some of you who have heard our
talks we use the pen we're going to use
something slightly different we're going
to use something called rember from the
little list bird that simply removes the
first symbol that matches in a list very
very straightforward and can't ask for a
much simpler recursive program so we'll
is busy writing it there if this is
empty we'll return the empty list if the
car of the list is it's the thing we're
looking for we'll return the coder of
the list and the last case we will
simply write member ex-cons Caravelle
cons Caravelle oh yeah
Thanks yeah okay okay so that should
work we all believe and then we run it
and let's find out perfect and there
we've seen that it removes it so simple
enough now we want more answers than
that so we're going to rewrite it in
mini-camera
and let's see what happens so the way
that many kind of works is you're just
not allowed to make nested calls so
we're gonna rewrite this entire thing
without using any nested calls so here
we go whoa okay okay the first step was
first step first step rename it
okay and somebody once asked me what is
that Oh in the end write that remember
oh so I thought well maybe this is a
good place as any to tell you it is the
top of a question mark
just a piece of creativity okay it's in
and question marks indicate really
predicates and predicate simulations
have a lot to do with each other and
we're talking about relational
programming or so second thing to do
second thing change the contact on D no
no and now add Oh add an output variable
of course so every function which took n
arguments will now become a relation
that takes n plus 1 arguments very
simple very straightforward ok now we'll
change the canta canta and we will
change the null to equal equal the empty
list to L and well now that we know we
have the empty list we have to give out
some value and if we look at the right
hand side of the definition of rember it
will be the value that's associated that
we want to associate without and of
course out philosophically is like sort
of the wrong name because totally wrong
because there's no such thing as in and
out variables than main cameras like
yeah they're just variables but it comes
from a function so thinking about it as
an out at least for a very short time
while you're writing it is not a bad
idea
and then you have to forget that you did
it okay now the next line is really
simple we introduced a couple fresh
variables for car and cooter because we
see we're going to use them and now we
say is actually you don't need the a
let's get rid of that day ok ok so now
we're just going to find out what what
the list looks like well it's got an X
in it if we're successful and it has a d
in it because we might need it
and in fact we do so what we're going to
do is simply associate without that D
and we've removed it and that's all
there is to DNA I use as cars and
cutters so helps you to know that ok now
we come to the last line and the very
first thing we do is we throw out else
goodbye else
okay now the next thing we have to do is
we have to get our hands on the car
encoder so we will do a fresh ad and
then we will just do the obvious here
which is just do a call to REM burrow on
the cutter yeah of course that bar and
then do a rember o D res we have to add
an inner recursion value and finally we
will do the Association of the original
a with the result of the cutter and
we're done
oh no we basically did was move all the
nestings that's all we did oh yes we do
did I think that would be X yes yes very
good okay so now we're done we have
implemented it and we've shown you how
to write a recursive program the whole
language is now at your fingertips
that's it okay so all we have to do now
is try it out so we want to know if we
get the same answer and sure enough we
do so every program that ran that way
before runs that way now except that
there's an extra set of parentheses
because we are anticipating wanting more
answers so let's see what happens if we
do want more answers good enough and
there they are what we said we were
going to remove B from the list and
there it is again it's not a very it's
not a very good system it has weaknesses
so we'll what can you do about that well
I think when we remove that else that
could have been a problem okay so don't
just throw away the else okay what else
you got
ah now we use our dis equality
constraint and lo and behold okay so
it'll never be the same as X yeah so
what does else mean in our original
program else means that the tests and
the previous clauses all failed so this
is the idea of a Dijkstra guard if
you're familiar with that in fact we now
have some technology called D match so
you can write your scheme programs on
the way to translating to mini can write
using Dijkstra guard form so that you
can reorder your cond Clause as any way
you want and this is something you might
want to have and closure technology or
some some closure it was a very simple
macro yes I'm sure like baby could do it
steal it be my guest
you know but it's nice when you're
translating from closure to core logic
to make sure that your clauses can be
reordered any way and you have to make
sure that you have tests there making
sure you don't end up on a clause when
you should because a mini cannon all the
condi clauses are tried independently ok
so just because the first line match
doesn't mean the second one will be
tried also so we have to make sure that
the second and the third clauses here
don't overlap okay so let's see what
happens now oh did I okay you'd think by
now could read our minds really
and acquitted we wrote a curried style
it would work it works okay so now we
only have the one answer we don't have
any bogus information floating around
okay so we can now move on to we want to
okay so at this stage what we want to do
we didn't even show wearing backwards
though oh let's run it back yes of
course don't forget okay all right I'll
actually like fix this program has a
subtle bug in it
yes bug that makes you take forever so
when you run things backwards you must
use will birds law which is all
recursions have to sink to the bottom of
your code okay so anytime you have a
fresh with some recursions in it move
the recursions down no harm because the
ordering doesn't really matter except it
does okay what did you do
right wait a minute what is that babc
oh that must have been what you started
with in order to get ABC back and then
you have a BBC yeah that's actually
right and it works because it's trying
to put the bees anywhere before so maybe
you should run it with oh you did run up
its stars so those are all the answers
yeah I didn't mention that star means
all the answers okay so you have to be
careful when you use it because all the
answers can easily be infinitely long
shall we show wonder if you wish
don't be good okay so let's do okay
there's ten answers those are ten very
abstract answers we have sort of
variables everywhere we can and then we
can get all the answers and I'm gonna
quit that before my computer okay I make
a little shift now and we're going to
look at a scheme
not many Cameron but scheme interpreter
it's gonna be a very quick look all
right you get to see it almost okay but
it's a vanilla scheme interpreter doing
scheme okay except there's one little
operator up there called fix because
it's not the best thing to have
self-application
get generated later on when such things
so there's nothing terribly hopefully
confusing about this code oh I have one
over here don't I and not going to
explain it you know it's it's it's it's
rampant and it's a standard definition
so we can move on sure run in okay let's
demonstrate that it does factorial or
something like that you know you know
that it does factorial really without to
work so if you see the answer 120 that's
a really good sign that's like a mini
Cameron program you have to fill in the
data okay so we have the empty
environment and the factorial 5 program
and there we are
1f okay good all right so obviously
that's not the exciting part what we
want to do instead
is what are you going to do Emma I don't
know
I don't either okay that's just
something simple in the regular intern
in there in the regular inference sir so
we're gonna I'm going to show you the
inference sir and for those of you who
have seen the st. Louis talk we had a
little fun with an infant sir and
unfortunately we had a little fun with
it yesterday too and this morning
something seems to be a miss here so
we're gonna have to forgo using the fix
in here but fear not we have plenty of
interesting things to show you in any
event well to set it up correctly mm-hmm
so Dan and I had this great idea for
this cool new mini cannon technology we
were going to show off today and it was
we're gonna show it to you but it was a
bug finding technology and it worked so
well but it found the bug inner
inference that we were using to help
show the bug so yes we actually use this
to find the bug but we haven't fixed the
bug yet it's gonna be very simple in
fact if you want to leave it up on one
let's go you can't do that I think you
can leave it up on one screen then you
could have the benefits of debugging on
this side while we're showing these the
rest of the the fuzzer
technology oh excuse me sorry no all
right so what we want to do now is do
you want Astro training yeah would ya
let's just let's do some type
inferencing just make sure you commented
out the fixed lines please so of all
things our fix needs effects it's broken
okay
so what do you want to type-check down
oh I don't know how about lambda X
lambda Y times X Y lambda X lambda Y
times oh you want okay you don't want an
application yeah times X Y and I will do
that in the in the empty environment
which is we're using the same order that
we used in the interpreter so it's an
expression and an environment but here
of course we want to get back a type so
let's give ourselves a type oh you've
already produce the type okay so that's
the type it's a function that takes an
integer and returns a function and it
also expects an integer and so on well
we could do something slightly better we
could oh yeah you want to go ahead just
make something up let's just take that
type we generated yeah sure generate a
program with that type and there is the
program now notice by the way there is a
program there but there's also some
deals that had to get made to make this
work so we had to agree that certain
things were going to be like symbols
certain things were going to be numbers
certain things were not going to be the
symbol lambda and stuff like that and
from there we can produce one answer but
are there more programs perhaps that
have that type that's fine now what did
we do star there I was gonna do like ten
thousand one Mississippi
oh that was fast okay so here comes our
thousand programs that have the type
power no no has like couple Arizona's
like error in arrow int arrow int arrow
int
yeah yeah okay so our type inference
server for the most part works you don't
have to worry about it anymore
because we've taken fix out of it okay
so now what we want to do is use this
list of correct programs and hand it to
the interpreter that we wrote in scheme
okay so here's what we're here's the
basic idea
if you write a type inference or a
mini-camera in which we've done many
times but also on one of the production
languages I'm working on for research at
GPU programming language functional GPU
programming language that we want to
embed in closure eventually we have a
type inference or written in constraint
mini Cameron which has mini Cameron with
a bunch of constraints in it the cool
thing is if you write your type
inference or in a very pure style then
you can run backwards right okay so this
expression here will generate a hundred
well type terms in your language okay so
these are these have a romantical
structure and they type okay so once you
have that then you can use that as a
fuzzer right so you can take your well
type terms and you can run it through
your system to try to find bugs or if it
turns out that your system is actually
correct but your type inference is wrong
you'll find errors that way too which is
what happened with us but can you do
although this works well in theory one
of the problems is that many Cameron
tends to be very lazy when trying to
generate terms so you say hey give me
one program this well type don't say ok
a number a number is a well type program
ok well that's fine that's good but and
then you say ok give me a second one and
I'll say ok hash T as T is a good
program this well type right so it
doesn't really exercise all the corner
cases of your system ok so we thought
it'd be really cool if we
could sort of amp up our fuzzer a little
bit so last night we decided to
implement cond P P stands for
probability even though we're not
actually using probabilities we just
request that you give numbers P stands
for probably works probably works
don't forget when you when you do this
you need to remove the fixed line oh
yeah so we want to show off the company
oh okay so con P is a you can see the
whole piece of code right there it's
beautiful it's not bad I would I have my
things it's in tax case we won't get
into that but it's easy to rewrite this
without the sin tax case and there's a
little helper here called prefix um
which basically says I've got a list of
values and I will add them and keep
track of at where the accumulator that
I'm adding them to goes and you produce
a list where the numbers just get bigger
and bigger and then it's finite of
course so everything's fine and it's a
very small little program and we're
talking really small like the entire
system is under 40 lines of code that we
publish you just call the code closure
because that's where we are and it'd be
much easier to remember
but anyway so all we've done is change
cond e to have a number associated with
it for each line of a con D and that's
it and now we can run this program and
presumably since there's a big giant
number where the 2 is we should get back
a lot of tissues and that's a very small
number god bless you
and very few knit a few
I guess nothing happens keep talking so
so we're going to expect that there's a
lot of two's in this thing so let's see
what happens help the people in the back
okay oh you're large in it yeah that's a
good idea
okay so
all right so now you can have this
little example so if we change these
numbers to all ones this means that you
have the same probability of getting any
of these answers back one two or three
right but if we want to make one of the
answers more probable then we can just
kind of wait it and if we want to put
floating number floating point numbers
or or what you could put any numbers you
want in there yeah so as long as they
work with addition that's all okay so we
can really skew it in one direction or
another mm-hmm I guess here we're not
gonna see too many threes yeah okay so
the cool thing for me about this program
that confi was we actually didn't have
to change any mini-camera code at all
like we just could add code so if you
want to add your own notion this is what
we were trying to tell everyone get the
right definition of your language and
then have it be flexible you know you
guys have all learned how to use
inflexible languages at one point in
your life but you're not doing that
anymore are you so that's what we you
know that's what needs to happen we need
to be able to have the ability to just
write the 40 lines and call it a day
okay okay so should we show off the
interpreter because we actually have a
working interpreter yes I think I can
show up this is a little bit yeah this
is like kind of the idea what the fuzzer
here so so what we wanted is good
answers right so we're going to numbers
on them yes yeah so so one problem when
you're trying to generate interesting
answers with mini-camera and running and
interpreter backwards one of the classic
problems is that it tries to generate
these simple terms like hash key or
whatever and you don't get too many
procedure applications those
applications are the interesting types
of terms in the lambda calculus so we
can wait heavily application so I put a
20 here and one for lambda terms which
are only values in this language and
then one for four variables and actually
I'll show you what it looks like when we
put all one's four
it's not very pretty so if we just try
to generate some programs here and their
values so let's do like ten of them I
guess okay so you'll see because this is
probabilistic we can get the same answer
back we have overlap but a lot of a lot
of the terms are just lambda they're
very boring but very flowing some
variable in some body that's right
so if we want to skew it a little bit we
can put in when you put in 20 and see if
this works any better
oops
now it takes a little longer but now you
can see that our terms are much more
complicated so for example that one has
lots of applications in it so by our
hope is by using this technology you can
easily create fuzzers and if you want to
create some gigantic terms you know
without having to enumerate all of the
smaller terms first you can easily do
that rent through the rest of your
system so this is hopefully an example
of how the purities remaining pure like
a lot of people will ask well with logic
program that's great but what is running
backwards give you well it gives you
lots of flexibility if you're going
ahead and specifying the type system you
may as well use that to be able to
generate terms of arbitrary complexity
there well type that you can then send
through your system to just rest and you
also have the well it's coin time so
let's let's learn a little bit about
Cline's okay so okay so the only
difference between these two systems as
we've added two new to expression types
get rid of it we got rid of the number
so the problem well that'd be
interesting you might think but not
today so we have added two new
expression types to our language you're
both I'm sure you're familiar with both
of them one is called quote and one is
called list and the only thing that's
sort of interesting about quote is it
says no quote closure in there because
it turns out that you can generate
expressions with the word quote so if
you like because it doesn't know that
you're going in or out it doesn't have
any idea what you're doing the thing
just works on its own so the issue here
is we have to have that knowÃ¶ quote
closure to just allow us to have some
tag that we're in charge of and that's
the tag we've chosen okay now the others
are just kind of obvious uncertain you
know not trivially obvious but obvious
given the time
yeah this natto natto is not a nympho is
kind of neat because it allows you to
have things like lambda lambda lambda as
an expression on a language the first
lambda says I'm a lambda the second lamp
is just another name for a very nice
variable and the other one is that same
variable so you get the identity
function for example if you do lambda
lambda lambda and you can play all sorts
of crazy games like that now how do we
know this is a necessary because it was
generating a lot of gibberish and we
could deal you know we didn't what to do
so we had to add this thing called not
an fo that says I am NOT in the lexical
scope at this point in time remember
when you're running things backwards you
get a little busy okay it's quite tricky
stuff okay we'll do one I have anything
about this yeah so when we demoed Mini
Cameron last year at the unconference
thing your unconscious thing us to
Holloway may be here somewhere
yes okay he asked if our system because
we can run our interpreter backwards
just like we can rent items for
backwards he won he wondered if we could
generate climbs and a client is a
program that when you evaluate it
evaluates to itself and I thought that
was a good good problem and so did Dan
so I went off to the hotel room and top
top then I got like a working version
that night that kind of work but not
really and I show the next day but then
we've spent basically the last year I
guess it almost exactly yeah yeah better
version and Eric olk helped us a lot and
really that problem was responsible for
the addition of simbolo
and number Oh Noah and Noah that was a
great problem you know so let's move on
to an example could be do that yeah okay
oh nice I can just remove it just coat
it out or something oh yeah you know
what a throne is by the way it's up
there it says don't tell them oh well
okay one all right okay
ready mm-hmm okay okay so the question
is we've got the Saval Expo thing which
takes an expression an environment and
then you get some output answer like
that okay and then the question is how
can we use this program to generate a
program that evaluates to itself so so
what can I write here for X well for
environment we want it to evaluate in
the empty environment so we don't care
about we don't want any variable
bindings in place but what expression
can we have and what output can we have
to make sure that we're gonna generate a
program that evaluates to itself the
idea is QQ okay
that sounds good okay so we want the
same expression as the input and the
output okay there it is believe it or
not there it is I don't believe it Dan
how can we find out I don't know let's
see what if we evaluated that so here's
the thing here is the program that is
grabbed from that okay I'm gonna call it
Q I have to quote it so it doesn't
evaluate prematurely okay so this is our
Q person you don't I know you don't but
I'm just right that's a little joke I
know don't ya doesn't like me using
available
I don't even see what's on the black
book whatever okay you evaluate this
expression what do we get back oh that
looks familiar
all right now let me prove it
ooh okay so that's a pretty good proof
can you generate more than one I don't
know yes see how about - how about
twelve twelve all right 300 5-0
all right not too bad anyway these are
all legitimate coins that couldn't
possibly be anything else in fact
considering the shortness of that
program it's like almost frightening
okay but what is a what's a throne how
about wine first oh right what's at wine
I bet by induction you could figure out
how to do Thrones or cod rinds or Quinn
tines you know little induction you'll
be all set and what is it wine yeah okay
I always get confused why n-- blinds are
when you have two programs P and Q where
P and Q are different and where P
evaluates the Q and Q evaluates to P do
you think we can event generate those
all right well how would we do that
I would part of the description oh you
did I'm sorry okay so let's say your
output is our query variables gonna be R
and we have P and Q is program so how do
we write this program so the usual is to
evaluate B evaluates to 0 and then Q
evaluates to P and since we'll said they
have to be different let's make them
different
and let's watch it run
oh my god what happened
haha slight fail hold on no whoops hold
on you want to make them laugh yeah they
forgot will birds law no no that didn't
that that was fine oh you've been
showing me I forgot that Kay like what
to give a value for yeah actually it
actually generate a client but it it
wasn't was a very interesting okay so we
have two programs here alright okay so
you got that expression that okay so
let's define Q or no P you have to go
all the way again you have the quoted so
I'm gonna grab this whole thing it has a
quote no nope nope no what we final
thing that's it that's it I've done this
for all right let's be and then I trust
them q okay all right so let's see here
we got P and we have Q all right let's
see if this works so should be able to
eval P that should be equal
yeah equal to Q right hmm shall we go
for broke here oh okay sorry I'm getting
nerd chills okay
Oh
okay so you you get the story and by
induction you can play your heart's
content and as always all of the code
and the description and maybe the
improvement in fix will be available on
wills github and you can all play with
it and have some fun with it yeah grinds
are on github and we're also gonna put
up well on the Conte will also be a fix
that my login the type converter that we
found I bubbly the syntax case will
survive yeah anyway so that's a yes
that's it and please make your programs
be pure and run them backwards and be
awesome</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>