<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Clojure for Java Programmers Part 1 - Rich Hickey | Coder Coacher - Coaching Coders</title><meta content="Clojure for Java Programmers Part 1 - Rich Hickey - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Clojure for Java Programmers Part 1 - Rich Hickey</b></h2><h5 class="post__date">2012-12-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/P76Vbsk_3J0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm Ricky I'm here to talk about
closure which is a programming language
I wrote for the JVM this particular talk
is oriented towards people who program
in Java or C sharp or C++ in particular
that I'm not going to presume any
knowledge of Lisp so you might find some
of it tedious although I am preparing
for a talk I'm going to give at E coop
to the European Lisp workshop where I'm
going to talk about the ways closure is
a different list so maybe some of this
will be interesting to you in that
respect but that's the that's the nature
of this talk it's going to be an
introduction to the language a flyby
tour of some of the features I'll drill
down into some of the others I started
to ask this question before but I'll
just ask it again to sort of see is
there anyone here who knows or uses any
flavor of Lisp Common Lisp scheme or
closure
okay so mostly no I presume a lot of
Java for anything in that family C++ C
sharp Scala anyone you must be playing
with it right how about functional
programming languages like ml or Haskell
this strict guys anyone a little don't
really want to raise their hands about
that one okay that's good in particular
I think coming from that background
you'll understand a lot of this straight
away how about dynamic programming
languages python ruby or groovy yes
about half and like ask before closure
we have a few people with their their
toes in the water the other key aspect
of closure that would matter to you if
you're a Java programmer is whether or
not you do any real multi-threaded
programming in Java or in any language
yes
so some so you use locks and all of that
nightmare stuff
I'm a practitioner I programmed in C and
C++ and Java and c-sharp and Common Lisp
and Python and JavaScript and a bunch of
languages over the years way back this
same group I think it's the same lineage
was the C sig and when I first started
to come I started to teach C++ to the C
sig and it became the C++ and C sig and
eventually the C C++ and Java sig and
now the Java sig so back in the 90s
early 90s and mid-90s
I taught C++ and advanced C++ to this
group and ran study groups and I've come
back tonight to apologize for having
done that to you and to try to set you
off on a better a better track so we're
going to look at the fundamentals of
closure and it will be also of Lisp in
many ways but I'm going to say closure
don't take offense all these things or
many of the things I say are true of
closure or true of many lists I didn't
invent them they're not unique to
closure but some things are that we'll
look at the syntax and evaluation model
this is the stuff that will seem most
unusual to you if you've come from a
compile link run language and one of the
curly brace c derive e's like java then
we'll look at some aspects of closure
sequences in particular and the Java
integration which I imagine will be
interesting and I'll finally end up
talking about concurrency why closure
has some of the features it does and how
they address the problems of writing
concurrent programs that run on the new
and indefinitely you know it for the
indefinite future multi-core machines
and I'll take some questions at some
point in the middle will probably take a
break I don't know exactly
it's going to go so what's the
fundamentals of closure its closure is a
dynamic programming language and dynamic
has a lot of different meanings in
particular it's dynamically typed that
would be an expectation you have of
Python or or Ruby or groovy it achieves
that dynamic nature by being a lisp and
I'll talk more about that I don't see a
lot of people who know Lisp here but
that doesn't mean there isn't a bias
against list so how many people have
seen list and said oh my god
I can't I can't believe the the
parentheses and I would say I'd hope you
put that bias aside for the purposes of
this talk it ends up that for people who
have not used Lisp those biases or have
no basis and for most people who have
given it a solid try they they vanish
and in fact many of the things that you
consider to be problems with lists are
features down the line but having said
that closure is a very different list it
seemed tactically much leaner than a lot
of lists it has fewer parentheses and
uses more data structures in its syntax
and as a result I think is more succinct
and more readable so maybe the time to
try Lisp again another s of closure is
that's a functional programming language
and again I'm going to talk in detail
about these things for now you can just
say that means to focus on immutability
in your programs to write programs
primarily with immutable data structures
and if you're coming from another list
this will be an area where closure is
definitely different I mean different
decisions about the data structures in
closure the third leg of closure you
know it sort of stands on four points
its dynamic its functional it's hosted
on the JVM and it embraces the JVM its
host platform there are ports of other
languages that sort of just sit on the
JVM their reports and for instance Khan
was that sit on the JVM but they don't
really connect very well for a number of
reasons one is they're implementing a
standard the standard was written before
Java was written and you know there's
just no merging the type systems on the
other hand closure was written for the
JVM and so it's very heavily integrated
with it so not only does it reside there
which is a benefit because you can run
it if that's your environment but it
embraces it which means the integration
is good and it's pretty transparent to
go back and forth the fourth aspect of
closure is the concurrency aspect you
know I work in c-sharp with guys writing
broadcast automation systems they're you
know they're multi-threaded they have
all kinds of nasty stuff going on
multiple connections to sockets lots of
databases you know data feeds from all
kinds of places and it's not fun writing
programs like that that need to share
data structures amongst threads and to
have them get maintained over time and
have everybody remember what the locking
model is it's extremely challenging
anyone who's done any extensive
multi-threaded programming with the
locking model knows how hard it is to
get that right so closure is an effort
on my part to solve those problems in an
automatic way with language support and
the last thing is you know it is an open
source language and it's very
transparent to implementation and
everything else is up there for you to
see we started to talk about this before
why use a dynamic language some people
are very happy of the people who are
programming Java
how many are happy about that they like
Java they have no complaints ok not too
many it ends up that I think many Java
programmers look at people who are using
Python or Ruby and being very productive
and I think justifiably envy their
productivity the succinctness the
flexibility they have and in particular
how quickly they can get things done
and it's it ends up that that is a fact
of the static languages especially the
ones like Java that they're inherently
slower because of the amount of well
some people call it ceremony that you
have to go through to communicate with
the language it slows you down so
flexibility is a key thing you would
look for in a dynamic language
interactivity is another key point again
this goes back to Lisp Lisp has pretty
much always been an interactive language
and that means a lot of things in
particular means that when you've got a
lisp up and running you feel like you
are engaged with an environment as
opposed to you know shoveling your text
through a compiler phase to produce
something else out the other end so that
interactivity is kind of a deep thing
the repple is part of it that means read
eval print loop and I'll talk about that
in detail a little bit dynamic languages
tend to be more concise that doesn't
mean that static languages can't be
Haskell in particular is very concise
but the curly brace languages are not
concise Java is probably a great example
of a language that's not concise and
that's just not a matter of tedium it's
a matter of where is your logic how far
apart is your logic how spread out is it
can you see what you're thinking about
or is it in pieces as it spread out by a
bunch of things that are not about your
problem dynamic languages are definitely
more suitable for exploration there's a
certain aspect in which static languages
are like concrete that's a good aspect
when you're trying to you know finish in
some systems you know concrete is going
to be more resilient you know it's more
resilient to change it's more structured
and it's rigid on the other hand that's
not necessarily the kind of materials
you want to be working with when you're
trying to figure out what your what your
structure should look like in the first
place so dynamic languages are better
for exploration and in particular what I
what I like about dynamic language
and Lisp fundamentally and I think in a
way other languages don't achieve is it
lets you focus on your problem you can
with Lisp and its ability to do
syntactic abstraction suck everything
out of the way except the problem and
for me you know when I discovered lists
but I was pretty expert C++ programmer I
I said to myself what have I been doing
with my life it was that that big a deal
so there are many dynamic languages I'm
going to talk about closure and I will
do you know bashing of other languages
but I will try to highlight why you
might choose closure over some of the
other options because in particular now
I think it's it's a great thing that
there are many dynamic languages
available for the JVM and dynamic
languages are supported as a concept in
the Java community you know at Java one
there was plenty presentations on Jai
thon and JRuby and groovy and these
other languages and Sun has you know
hired some of the developers of these
languages and given it you know kind of
official support as something that's
viable to do on the JVM so you're going
to see mixed language programming being
accepted in Java shops so how do you
pick I think you can categorize
languages in one dimension pretty
straightforward
are they a portable language that exists
somewhere else or were they written for
the JVM ports have a bunch of challenges
one is there is a canonic version out
there because most of these languages
are not defined by a specification
they're defined by canonic
implementation so there's C Ruby right
there's C Python those are really the
languages and the other things reports
which are have to struggle to follow
along with the C version the other
problem ports have is a lot of the
infrastructure for the languages
especially the ones that don't perform
very well are written in C in order to
get the library performance they need
the support libraries for Python or
written in C so
an effort support Python to Java means
having to replicate those C libraries so
there's that I would say the main appeal
to reported languages if you already
have an investment in Ruby or Python or
you have to really love the language
designs that's a good way to go here I
would say if not if you're just starting
from scratch you may find that a
language that's native to the JVM is
going to give you better integration you
know the version you're using is the
canonic Persian the canonic version of
groovy is the JVM language the canonic
version of closure is a JVM language and
I would say of the two groovy is going
to let you do what you do in Java except
a little bit more easily fewer
semicolons more dynamic there are some
builders there are some idioms there are
closures sort of the fun of dynamic
programming and a lot of the similar
syntax to Java so I think if you're just
interested in dynamic and want to
continue to write programs that are like
your Java programs groovy can't be
touched closure is not about writing
programs like your Java programs closure
is about realizing what's wrong with
your Java programs and doing something
different and so you'll find some of
that through the talk so closure itself
it inherits from Lisp and expressivity
and all against I think is unmatched
depending on your mindset you may or may
not agree but there's a certain
mathematical purity to lambda calculus
and the way it's realized in Lisp the
uniformity of the syntax is elegant
closure also has very good performance
again I'm not going to get involved in
any language bashing but I'm pretty
confident no other dynamic language on
the JVM approaches the performance of
closure in any area and is unlikely to
but everybody is working on performance
certainly
we've converted them their java program
is there so the performance is good I
made a point before starting the talk
that the objective and objective of
closure is to be useful in every area in
which Java is useful that you can tackle
the same kind of problems I don't write
web apps and put stuff in and take it
out of database kind of applications I
write scheduling systems broadcast
automation systems election projection
systems machine listening systems audio
analysis systems and I write them in
languages like C sharp in Java and C++
and closure can be used for those kinds
of problems doesn't mean they can't also
be used for web apps and people did that
right away with closure and database and
new UI stuff but it has that same kind
of reach and one of the nice things
about Java is it has a wide range
closure has direct wrapper free access
to Java some of the ported languages
have to use wrappers because those
languages have their own object systems
that imply a bunch of dynamic features
that they have to glom on top of Java
objects when you interoperate with them
closure was designed to provide direct
access to Java
it looks like closure but it's direct
closure being a list is extensible in a
deep way and we'll talk a little bit
more about how you get some tactic
extensibility through macros and then
closure I think is completely unique
amongst the languages on the JVM in
promoting immutability and concurrency
much more so than even Scala which is
often talked about as a functional
language but isn't deeply immutable it
sort of as an option closure is really
oriented towards writing concurrent
programs and immutability for its other
benefits outside of our concurrency so
how does closure get to be these things
it is a list again put what you think
about list aside I'll explain what that
means in depth as I go into each of
these points but Lisp in general is
dynamic okay in that way interacting
with an environment having a repple
having sort of introspection
capabilities on the environment being
able to modify things in a running
program or all characteristics that make
a dynamic a fundamental feature of all
lisps if they want to be a lisp is that
code is represented as data and again
I'll explain that in detail there is a
reader which is part of the
implementation of code is data sort of
something in between your text and the
evaluator being a list means having an
extremely small core you'll find when
you contrast closure to other languages
even the languages there's you know
theoretically lightweight like Python or
Ruby closure has way less syntax than
those languages far less complexity in
spite of the fact that they appear easy
lisps generally have tended to emphasize
lists closure is not exactly the same
way it's an area where closure differs
from list in that it frees the
abstraction of first and rest from a
data structure the consul's and in doing
so offers the power of list to many more
data structures than most
lisps do so there's that sequence thing
and I'll talk more about that in detail
and syntactic abstraction again we have
abstraction capabilities with functions
or methods and most languages
lisps take that to the next level by
allowing you to suck even more
repetition out of your programs when
that repetition can't be sucked out by
making a function
okay so we'll take that a little bit
more what does it mean to do dynamic
development it means that there's going
to be something called a repple a read
eval print loop in which you can type
things and press ENTER and see what
happens I guess you should probably do
that so this is a little editor it's
kind of squashed in the screen
resolution but down below is is the
repple this is closure in an interactive
mode and we can go we can say plus 1 2 3
and we get 6 we can do other things Java
like I'll show you some for that later
but the general idea is that you're
going to be able to type expressions or
in your editor say please evaluate this
I mean I can go up here to math apply
method I and hit the keystroke that says
evaluate this and you see below we get
that and that's kind of what it feels
like to develop I'm going to show you
even more after I explain what you're
looking at because like I don't want
this talk to be yet another where people
are shown Lisp and not having how to
explain to them what they're looking at
so we're going to do that first but you
have this interactive environment you
can define functions on the fly you can
fix functions on the fly you can have a
running program and fix a bug in a
running program and that's not like
being in a mode in a debugger where you
have the special capability to reload
something it's always present if you
build an application with some access to
the ability to load code either a remote
replica nection or some way to do that
you're running production systems will
have this capability to have fixes
loaded into running programs in general
there isn't the same distinction between
compile-time and run-time compiling
happens all the time every time you load
code every time you evaluate an
expression compilation occurs so that
notion of phases of compilation is
something you have to relax when you're
when you're looking at a language like
like closure and I'll show you the
evaluation model
second I talked a little about the
little bit about the introspection but
that's that's present you're sitting at
a repple closure is they our closure has
namespaces you can get a list of them
closure has symbols you can get a list
of those you can look inside the
infrastructure that underlies the
runtime and manipulate it and that's
what I mean by an interactive
environment I just don't mean typing
things in I mean there is a program
behind your program that is the runtime
of closure and that's accessible if I
say something you don't understand you
can ask for clarification endeavoring to
try to come up with the ideal way to
explain Lisp to people who have never
seen it and this is what I have come up
with which is to talk about data lots of
languages have syntax you can talk about
Java you can talk about here's main and
here's what public means and Static and
then you could dig into arguments to a
function and things like that but we're
going to start here with data in
particular data literals and I think
everybody understands data literals from
languages they're familiar with you type
in you know one two three four and you
know that's going to mean
1234 to your program so closure has
integers they have arbitrary precision
they can get you know as large as your
memory can support and the promotion of
small integers to larger integers while
arithmetic is going on is automatic it
supports doubles as the floating-point
format those are doubles those are big d
double java doubles when you type them
in there they're right right there Java
doubles but they're the big d doubles
all right so one of the things you're
going to see about closure is everything
is an object ok all numbers are boxed at
least until you get inside of the report
I can unbox them
but it's a language in which numbers are
box unlike common lists where you have
access under the hood to use tagged
integers and tagged numbers which is
more efficient than allocating them on
the heap no capability of doing that in
the JVM there's been talk about it the
manigott which is stunning to me
apparently the guy there's this guy John
Rose at Sun who really does understand
this very well and it's talked about all
kinds of really neat features which if
they make it into the JVM would make it
stunning like tail call elimination and
tag numbers but in the absence of that
numbers are boxed so that everything can
be an object and can be treated
uniformly you have big decimal literals
you have ratios 22 over 7 is something
it's not divided 22 by 7 it's a number
it's a number that's not going to lose
any information versus dividing 22 by 7
and either truncating or converting into
a floating-point format where you will
lose information so ratios are
first-class string literals or in double
quotes
they are Java strings same thing
immutable no conversions no mapping
being again being a native JVM language
means I can just adopt the semantics of
Java literals I don't have to take
strings from a language spec that said
for instance they could be mutable I
have to force it on the JVM by having my
own type and conversions to and from so
because I'm Ana mutability oriented
language I'm very happy with Java's
definition of a string being an
immutable thing so closure strings or
Java strings yes
no try Frank have you ever seen it
oh you will love it you can add all
kinds of Units and figure out how many
you know balloons of you know hydrogen
it would take to move of camel across
this much distance it's amazing
units for absolutely everything old
ancient Egyptian unit it's it's really
it's fantastic the guy is just a fanatic
about precision making sure you don't
lose anything but you can you can
arbitrarily multiply all kinds of Units
everything is preserved everything works
correctly fantastic
Frank Frank Fri NK but no Frank Frank
Frank is a language for the JVM it's its
own language but it's a lot of fun I've
seen the guy talking he just he has some
great examples you know some involve how
many belches it would take to move a hot
air balloon to the moon and things like
that okay so we have string literals and
double quotes we have characters or
preceded by a slash backslash so that's
a character literal and that's a big C
character Java character now we're going
to get to two things that are possibly a
little bit different because they're not
first-class things in Java
one would be symbols which are
identifiers is they can't contain any
spaces they have no adornments symbols
are used as identifiers is primarily in
code but they can be used for other
things as well they're first-class
objects like strings if you have one of
these things you can look at it and it
will be a symbol closure Lang symbol
Fred and Ethel are two symbols that's
correct
the other thing closure has our key
words which are very similar to symbols
except they always designate themselves
so they're not subject to evaluation or
mapping to values by the compiler like
symbols are so symbol might be something
you would use for
you can make Fred be equivalent to five
you could never make : Fred be equal to
five : Fred will always mean itself so
when it gets evaluated the value of the
keyword Fred is the key word Fred it's
sort of an identity thing and they're
extremely useful they're very useful in
particular as keys and maps because
they're very fast for comparison and
they print as themselves and read as
themselves that'll make a little bit
more sense in a minute there are
billions this is different from from
Lisp although there is still null is
false nil is false but in addition there
are proper true and false mostly for the
purposes of interoperability it ends up
that you can't solve the nil becoming
false problem at least I couldn't so
there are true or false
and therefore use in interoperability
with Java you can use them in your
closure programs as well but conditional
evaluation in closure looks for two
things it looks for false or nil which
is the next thing I will talk about nil
means nothing it also is the same thing
in closure as Java no didn't have to be
but it is so you can rely on that
so nil means nothing and it's the same
value as Java now so when you get back
nulls from Java they're going to say no
an illest traditional Lisp word but I
like it because also traditionally in
Lisp
if you can say if nil and that means and
it'll evaluate to the else branch
because nil is false well it's not true
so that's another literal thing that nil
there are some other things there are
regex literals so if the reader reads
that it's just a string regex exactly
the same syntax as Javas preceded by
hash will turn into a compiled pattern
so at real time you can get compiled
patterns which you can then incorporate
in macros and things like that which is
which is very powerful and shows how
that delineation between compilation and
runtime is a little bit fungible yes
correct and there's a good reason for
that and the reason is empty list is no
longer as special as it was once you
have empty vector and empty map however
the sequencing primitives the functions
that manipulate sequences return nil
when they're done not the empty list so
that aspect of being able to test for
the end of iteration with if is still
there so closure sits in a unique point
he's asking about aspects of closure
that differ a little bit from Common
Lisp and scheme because there's like an
a long-standing fight between what
should the difference between false nil
and the anti list be should they be
unified they are in common less should
there be some differences there are some
differences in scheme closure actually
does some of both there is false
however nil is still testable in a
conditional it does not unify nil and
the empty list which is a difference
from common list however all of the
sequencing or list operations when
they're done return nil not the empty
list which is an important thing for
common list like idioms where you want
to keep going until it says false as
opposed to having to test for empty
explicitly which you have to do in
scheme does anybody know scheme here you
know but you know both so you know what
I'm talking about
for everyone else I wouldn't worry too
much about that because you wouldn't
have presumed no would have been the
empty list right probably not
okay so those are the atomic things they
can't be divided right
that's what atomic means right you can't
there's numbers in a composite thing but
there are composite or aggregate data
structures enclosure and they're kind of
the core abstractions of computer
science one is the list and in this case
I mean very specifically the singly
linked list and even more specifically
the singly linked list in which things
get added at the front so when you add
to a list you're adding at the front the
list is a chain of things which means
that finding the nth element is a linear
time-cost right it's going to take n
steps to do that on the other hand
taking stuff on and off the front is
constant time because that's the nature
of a singly linked list so it has all
the promises all the performance
promises of a singly linked list with
stuff at the front and it's literal
representation is stuff inside
parentheses separated by spaces there's
no need for commas you'll see some
commas commas or white system closure
there completely ignored you can put
them in if it makes you feel better or
makes things somewhat more readable but
they're not actually syntax or not
considered by the evaluator so any
questions about lists stuff in parens
right well these these condoms the one
is between one two three four five and
Fred Ethel Lucy are actually English
comments but but there are some comments
for instance when we get down to nap
seriously comments inside the data
structure those are ignored those are
white space
I don't support any commas inside
numbers the printed representations of
numbers enclosure are those of Java
in Lisp no and let's figure out the
front
what cons a onto something mix a the
first thing in that list and that's true
of closure to yes absolutely not all of
these data structures are unique to
closure I'm only giving you some very
high-level descriptions of their
representation and their performance
characteristics but we're going to find
out later is all of these things and
that in particular I'm talking about
adding to lists all these data
structures are immutable and they're
persistent which is another
characteristic I will explain a little
bit later so these are very different
beasts and they have excellent
performance yet they're immutable and
it's sort of the secret sauce sauce of
of closure without these you can't do
what I do in the language
yes
that's correct again what what how this
gets interpreted we're going to talk
about it a little bit right now what
you're looking at is a list of three
symbols you may end up with in your
program a data structure that's a list
of three symbols you may pass this
through the evaluator and say evaluate
this in which case it's going to try to
interpret it's going to try to evaluate
each of those symbols and find out its
value and treat the first one as if it
was a function but we're not going out
there yet so this that is a list of
three symbols the list at the end is a
list of one symbol and three numbers so
header it up heterogeneous collections
are supported in all cases I necessarily
show them everywhere but they are it's
not a list of something it's a list can
contain anything and any mix of things
okay with lists the next thing is a
vector uses square brackets that should
imply I would hope for Java programmers
and people from that domain array write
square brackets mean arrays well they do
now
so a vector is like an array in
particular it supports efficient indexed
access okay it's an expectation you
would have of a vector you wouldn't have
of a linked list that getting at the
fiftieth guy is fast it's not going to
be 50 steps to do that and the closure
vectors meet that performance
expectation fast indexing in addition
it's a little bit like Java util vector
or ArrayList in that it supports growing
and in this case at the end and that
also is efficient as efficient as your
expectation would be of ArrayList that's
a constant time operation to put things
at the end similarly it can hold
anything the first is a vector of five
numbers the second is a vector of three
symbols
No all the collections can be
heterogeneous okay so far so that's
going to behave like an array in terms
of being able to find the x element
quickly and finally as a core data
structure we have a Maps okay and a map
is like good well it's like Java map and
or any kind of associative data
structure in providing a relationship
between a key and a value each key
occurring only once and having a map
into a value so the way they're
represented is in curly braces and
they're represented simply as key value
key value P that again the commas don't
matter so they're white space they get
eliminated for instance in the second
map you see there that's a map of the
number 1 to the string Ethel and and the
number 2 to the string Fred you don't
need the you don't need the commas and
the expectation with the map is that it
provide fast access to the value at a
particular key there are usually two
kinds of maps you would encounter in
ordinary programming languages one would
be sorted write some sort of sorted map
in which case the axis is going to be
typically log n right to find a
particular guy and how many things are
in the map because they use trees or
red-black trees and things like that and
closure does have sorted maps the one
you get from the literal representation
like this is a hash map and the
expectation of a hash map is constant or
near constant time lookup of values of
keys and that maps to hash tables so
what you have in the closure literal
Maps is the equivalent of a hash table
it's fast okay so far
introduce another 8 another key a will
be replaced you want to correct there
only one instance of a key in a map is
that your question yes so if you were to
say the function that yes it's probably
a replacement I say in the same thing
yes I don't think it's an error that's a
good question I might type it in later
for you ok
yeah it's the same thing yeah it's the
same well there's no Associated value so
Fred will be there so let's talk about
sets the fourth thing I'm showing you
here is sets sets are a set of unique
values each value occurs only once in
the set and really the only thing the
SEC can do for you is to tell you
whether or not something is in it
there's no Associated value it's just
does the set contain this King you have
a question there are sorted sets and
half set same thing as with the maps the
sets here are hash sets so no the order
is not retained you can request the
sorted set in the order will be the sort
order okay
what is the test for equality equal the
equal sign is the test for equality and
equality means the same thing for
everything enclosure
it means equal value you'll see the
closure definitely de-emphasizes
identity and completely in fact there is
an identity function and I have yet to
use it closure is about values identical
contents are identical from by equals
that's made faster than you might
imagine by caching hash values but
equality is an equality value enclosure
immutability helps certainly well it's
if you've ever read Henry Baker's paper
on ygal closure implements ygal finally
if you haven't and don't worry about it
somebody has equalities equality of
value all right yes
hi Rob
no you can get you can make arrays and
you can interact with Java arrays that
are a race of either objects or native
arrays you can say float array and the
size and you'll get an array of floats
so you have the ability to do Java stuff
I'm going to emphasize the closure data
structures because they let you do what
close will let you do you can access
Java but if you start accessing mutable
things some of the things closure can do
for you we can't do doesn't mean you're
not allowed to do them but there's no
point in me showing you how to interact
with the Java right except to show you
the syntax which I might later so the
last point about this is that everything
nests a key in a map can be another map
it can be a vector anything can be a key
or a value because of this equality
semantics there's no problem having a
vector or a map whose keys are vectors
that's perfectly fine so if you needed
to use tuples as keys your pairs of
things as keys that's just completely
doable
well you can get the hash of a vector
I didn't correct right well it depends
on what you're doing I would imagine
that really complex structures are not
frequently used as keys but they could
be can that be helped yes the fact that
these are hash by default means that
once and once only the hash value of
some aggregate structure will be
calculated and that will be cached so
there's a quick hash test otherwise we
do the deep value check but again I
don't think you're going to encounter
complex data structures as hash values
that often but using kind of small
things like couples or other small maps
as Peas is a tremendously useful it's
really really handy to not even have to
think about that I think we got one
other closure program or arrived who can
possibly attest independent of me how
closures performances house closures
performance yeah
right well now there's some extra
numeric goodness in there but these data
structures are pretty good what's the
reality the reality of these data
structures is I've tried to keep them
all within one to four times a Java data
structure the equivalent Java data
structure in other words hash map vector
well similarly lists are pretty
straightforward
so they're within striking distance the
b-side is in a concurrent program there
is no locking necessary for use with
these data structures if you want to
make an incremental change through data
structure in a certain context there's
no copying required to do that so some
of these other costs that would be very
high with a mutable data structure
vanish so you have to be very careful in
looking at that the other thing that's
astounding to me at least is that the
lookup time again the ad times are
higher than than hashmap but the lookup
times can be much better because this
has better hash cache locality than a
big array for a hash table okay
we're all good on this people have to
move a little bit quicker yes more
quickly
there is destructuring yes I actually
won't get to talk about that today but
there is destructuring
there is not pattern-matching okay but
there is destructuring to arbitrary
depth of all of these restructuring
means a way to easily say I want to make
this set of symbols that has in that I
express in a similar data structure map
to corresponding parts of a complex data
structure on past closure has that
that's has some really neat
destructuring capabilities all right so
what's the syntax of closure we just did
it I'm not going to talk about
semicolons curly braces you know when
you have to say this when you have to
have a new line or anything else because
the this structure of a closure program
is a data structure or a series of data
structures there is no other stuff there
are no rules about where things go there
are no precedence rules is nothing else
you write a closure program by writing
the data structures I just showed you
that's it
I'll show you so you write a program by
writing data structures the data
structures are the code that has huge
implications it's it's you know it is
the nature of Lisp there's a fancy name
for it called homo iconicity and it
means that the representation the
program is done in the core data
structures of the program which means
that programs are amenable to processing
by other programs because their data
structures so I'm not going to talk
anymore about text-based syntax because
there is no more now many people claim
of lisps well this has no syntax and
that's not really true it doesn't have
all this little fiddly characters
impacts necessarily there is syntax to
the interpretation of the data
structures you know there's you're going
to see a lot of lists they have
different things at the front the thing
at the front will tell you the meaning
of the rest all right so let's talk a
little bit about evaluation so how does
this all work
this is we should all know from Java or
many other languages like Java yeah we
types our program into the text file
when we save it and then we we send
those characters of that text to the
compiler who has very involved you know
abstract syntax tree and parser and
lexer that interpret the rules of the
language this is what constitutes a
character this is what constitutes a
number and then furthermore you know if
you've said if and you put parens and
then you set some stuff and you put a
semicolon and you happen to put else
then you're still in this construct
called if things like that it knows all
about that and it deals with the text
and it will tell you if you you've met
the requirements in terms of it being a
valid program and it will turn it into
something that can run in the case of
Java that's something we'll be bytecode
and we'll go into a class file or or
file we know this
right and then this is separate step
which is called running we take that
stored executable representation we ask
it to happen usually within this case
we'll say you know Java - something
class file and it will run and it will
run and then we'll end and it'll be over
and we could try again if we didn't like
it that's the traditional edit compile
run be disappointed start over Oh
correct but I'm talking about the
development process right yeah we know
yes the run time is just that until it
you realize it's not working and you
have to ask everybody to please wait
what for our damage while we fix it
right that's the difference if you read
about Erlang which is getting a lot of
press they'll tell you about phone
switches and how that's really not
allowed there's and Lisp was doing this
for a very long time with this kind of
live live hot swapping of code and
running systems I think it goes more in
this case it's less about the production
thing then it is about what's the nature
of developing your program because as a
developer you know seeing it run and
saying oh that was bad wonder what
happened I wish I had run it in debug I
wish I put a breakpoint somewhere
interesting and I'm really sad that I
spent an hour calculating that data and
dropped it on the floor because I have
to do it again with breakpoint in that's
a lot different experience than keeping
a program around and having that data
stay loaded and fixing your function and
running it again without starting over
so that's what happens in closure you
take the code text could be characters
there is character representation and
what you showed you there can be
represented in characters and ASCII it
does not go first to the evaluator
notice something called the reader and
this is the
or part of what makes something a lisp
which is that the reader has a very
simple job its job is to take the
description I just told you
you know keyword starts with a colon and
a list is in parentheses and the map is
in curly braces and it's pairs of stuff
its job is to take those characters and
turn it into data structures the data
structures I described you start with
the paren you say stuff you close the
parentheses are stunned with it so what
comes out of the reader are data
structures and what's unique about a
list enclosure is that the compiler
compiles data structures it does not
compile text it never sees text what the
compiler gets handed is maybe a list
with three symbols in it or a vector
with five numbers in it that's actually
what the compiler has it has a data
structure in hand with actual data in it
not text and it compiles it in the case
of closure it is a compiler there are
many well there are actually many lists
that are interpreters but how many
people believe that Lisp is interpreted
it's really easy to make an interpreter
for lists that would take those data
structures and on-the-fly produce the
values they imply but closure is a
compiler in a particular closure
compiles those data structures to Java
bytecode right away there is no
interpretation in closure so it's a
compiler it produces byte code just like
Java C does and because it's an
interactive environment it presents that
bytecode right away to the JVM to
execute an execute right away and you
can see the effect yes
when you're in the repple you have a VM
right you have one thing so yes your
environment is your program your
compiler is in your program yes
yeah they're most commercial some
commercial lists give you tools to take
out the compiler in production mostly
because they don't want you giving away
their compiler normally there's no
reason to prevent that because it's a
useful thing to have particularly when
you want to load code later to fix
problems you can need that compiler
there so in closure there's no strip out
the compiler option will see that there
is a core of closure the data structures
are written in Java
the special operators are written in
Java and then most of the rest of
closure is written in closure
there's no native code closure it's
completely a pure Java project right
there's no native code there's no C
libraries there's nothing it's all it's
all Java either written generated by
Java itself are generated by closure it
does not turn off the verifier or
anything like that
in order to get performances there been
some schemes that tried to do that
though just completely legit that way so
when we have this separation of concerns
between the reader and the evaluator we
get a couple of things one of the things
we get is we don't have to get the text
from a file right we can get it right
from you you just saw me type right into
the repple an expression never went
through a file it never got stored so
the first thing you get is this kind of
interactivity but you can just type in
stuff and say go that's a big deal I
mean if you've been programming in Java
or C++ long enough to remember when the
debuggers didn't give you the ability to
evaluate expressions at a breakpoint you
remember how hard that was that's you
always have that capability here to have
expressions directly evaluated when else
do we get from this well we get the
ability to skip the characters
completely for instance it's quite
possible to write a program that
generates the data structures that the
compiler wants to see
and have it send them to the compiler to
be evaluated so program generating
programs are common thing in this kind
of an environment whereas this kind of
stuff when you're doing it with text is
really messy well I mean it's that's a
that's a security policy thing whether
or not you expose this in a production
system so I'm talking about
you could if you needed to you could
have that over a secure socket channel
and have it be just an administrator who
knows what they're doing have that
capability because the alternative is
down in your system if you don't have
that and of course opening this in a
production system that's completely a
policy thing has nothing to do with the
language except if your language doesn't
let you do it you can't do it so so it
does the other thing is that these data
structures you might write this program
directly then you might say I like this
program let me take those data
structures in this thing called the
printer which will turn them back into
that which you could store and so we
could sign off on and say this is the
canonic program which our program
generated that we're going to use and
we'll block that down and do whatever
yes
no they're in memory data structures the
ones your program would would see so you
know an instance of closure Lang
persistent vector to the compiler
while it's got a deal with it figure it
out this is one more thing that this
allows and this is the secret sauce of
all lists including closure which is
what would happen I mean it's fine to
sit at stand alone and write a program
that generates a program but what would
happen if we said you know I work we're
handing these data structures to the
compiler he would be great participated
very small program and give it back
different data structures then
very easily in the extension of our
language because this entire it's going
to know how to do with no cipher
it's going to know what to do in the
vector it's going to know what it means
and a couple of other things but
there'll be new things that will think
of that we'd love to be able to say
right when you have something you love
to be able to say in Java what you have
to do you have to bake son and wait for
years and helping other people beg for
the same things and you get that's it
you have no say you have no ability to
shape the language in list that that's
it's about getting you in the loop and
in fact the language itself has a
well-defined way for you to say this is
a little program I'd like you to run
when you encountered this thing I don't
want you to value away I'd like you to
send me that data structure I know what
to do with it different data structure
and you evaluate that that's called the
macro and it is what gives
lisps and closure syntactic abstraction
and syntactic extensibility
yes it can there are namespaces
enclosure and they allow me to have my
cool function and you have your cool
function box cool function yes so that's
what makes Lisp amazing it's something
that I won't have time to dig deeply
into tonight if you can come away with
at least the understanding that that's
how it works
that's how it's possible and the fact
that these are data structures here here
makes it easy you could theoretically
say oh I could write something and if
the compiler could hand me the abstract
syntax tree I could navigate it with
some custom API and do whatever it's not
nearly the same though when what the
compiler is handing you on those three
data structures I just showed you that
every program knows how to manipulate it
has a wildly huge library that directly
can can manipulate so that's how this
works try to speed up a little bit in
closure unlike Java everything is an
expression so you know a job is the
difference between declarations and
statements and expressions there's no
distinction in closure everything is an
expression everything has value
everything gets evaluated proofs of a
value sometimes that value is nil not
particularly meaningful but everything
is an expression so the job of the
compiler is to look at the data
structures and evaluate them there's a
really simple rule for that it's a
slightly oversimplified but in general
you can understand
this way all those data literals I
showed you write symbols numbers
character literals vectors maps sets are
all evaluated by the compiler to
represent themselves except lists and
symbols lists and symbols by default are
treated specially by the evaluator so
when it reads a list of a list of
symbols in particular it's going to do
some work it's not just going to return
the list of symbols to your program it's
going to try to understand them as an
operation which I'll show you in a
second so symbols it's are going to try
to the compiler is going to try to map
to values okay like variables like you
know in a variable you can say int I
equals 5 later in your program in Java
you say I job is going to try to figure
out oh that was that's 5 that's the eye
you set up there
same thing in closure when you use a
symbol in your data structure closure is
going to try to find a value that's been
associated with that symbol can be
associated with it through a construct
called let sort of the way you create a
local name or through death which is
where you create a global name or it's a
list and it's going to say this is an
operation of some sort I have to figure
out what to do with a list so how does
that work well again we said what's the
data structure it's it's parens it
starts with something it may have more
stuff or not but from the evaluators
standpoint all that matters is the first
thing the first thing is the operator or
up that's going to determine what to do
and it can be one of three things it can
be a special out okay this is magic this
is sort of the this is the stuff that's
built into the compiler upon which
everything else is bootstraps so some
things are special I'm going to
enumerate them in a second it can be a
macro like we saw before there's a way
to register with the compiler to say
when you see
my cool thing go over here and run this
function which is going to give you
something to use in the place of the my
cool thing Paul and the third thing it
could be is an ordinary expression it's
going to use the normal means of
evaluating expression and it's going to
say whatever value that yields on the
treat as a function an attempt to call
with the calling mechanism of closure
which is not limited to functions but
you can its main purposes for functions
so for people who know lisps closure is
a lisp one it is a list one that
supports def macro well and the use of
namespaces and the way that quote works
makes that possible and everyone else
can ignore that well what what it's
going to encounter is it's going to
encounter a list and the first thing is
going to be the symbol Fred Fred is not
a special operator no Fred and closure
let's say no one has registered a macro
called Fred then it's going to use the
rules we said before what about symbols
to find the value of Fred we're
hopefully someone before has said Fred
is this function
they will keep evaluating its going to
evaluate that expression but there are
other function like things or callable
things enclosure in addition to
functions I'll show you that in a second
so let's take down into each of these
three pieces yes you have an error that
runs out it'll say it's not a function
effectually what will happen is it will
say this is not a function if you said
Fred is is deaf Fred won so fred is the
number one and you've tried to call Fred
or use Fred as an operator it's going to
say one is not a function probably with
a not very illuminating stack trace
okay so special operators there are very
few I think you know one of the things
that's really cool about lisps and it's
also cool about closure is you can
define most of them in terms of
themselves one of the great brilliant
things that John McCarthy did when he
invented lists was figure out that with
only I think seven primitives you could
define the evaluator for those seven
primitives and everything you could
build on them like the core of
computation it still gives me goosebumps
when I say that is a beautiful thing
it really is and if you've never looked
at the lambda calculus or at lists from
that perspective it's quite stunning his
early papers are just great and they're
just brilliant in a transparent way so
let's look at a couple I'm going to show
you two and they're going to list the
rest of it def would be one how do we
establish a value for a name there's a
special operator called death it takes a
name now that name is going to
simple obviously that can't be evaluated
right because the whole purpose of this
special operator is to give it a value
if the compiler to use normal evaluation
the main position you'd have a problem
because you're trying to define what it
means how could you do that so one of
the things about special operators that
you have to remember and it's true of
macros as well is they can have none of
their arguments like the arguments might
not be evaluated in fact def doesn't
evaluate the name it uses it as a symbol
and it associates that symbol with the
value it does not evaluate the symbol so
this is a simple way to say if I say def
name some expression the expression will
be evaluated the name will be mapped to
that value or bound to that value when
you later go and say name you'll get the
value it was used to initialize it you
actually can do that more than once you
shouldn't do that more than once unless
you're trying to fix something
in other words def should not be used as
set but you can use def to define a
function later you can use it again to
fix it so the things that are defined by
def are mutable at the root and it's
probably you know it's the only escape
hatch for that dynamic change in closure
that's not governed by transactions or
some other mechanism okay so it
establishes a global variable again
there are namespaces I don't have enough
time to talk about that but it's all
subject to nature so if you're in a
native spacing to find the name that
it's in your namespace that's distinct
from that same name in another namespace
namespaces are not the same as packages
in common list
they're very much different in
particular symbols are not inherently in
a namespace symbols are have no value
cell they're not places they're just
labels and there are bars which are the
places
more like common list of symbols if is
another thing that's built in and if you
think about if in your language which
you may not have ever done right if you
thought about if is why couldn't it be a
function like I say if some test
expression
why can't if be a function I mean it
looks like a function well it doesn't
actually look like functioning in java
but why can't it be a function excuse me
it should only evaluate one of these
soon that's why in a function evaluates
what all of its arguments so if you try
to write it as a function you would have
a problem because functions evaluate all
their arguments so it has to be special
and there's a special enclosure to it
evaluates the test expression and then
depending on the truth or falsity of
this and kind of a generic sense
this is new for boss we will only die
like one of those students
no it doesn't have to be else can be
missing in which case it defaults to nil
so if it's another example something has
to be special I can't evaluate all of
its arguments and then we have these
others in fact this is it right there's
something that defines a function
something that establishes names in a
local scope a pair of things that allow
you to do functional looping to create a
link in your program something that was
create a block which will do what you
expect from Java set will rebind a value
and quote bar kind of special purpose
for list manipulation things so I'm not
going to get into the tonight question
yeah
of deaf macro deaf macro is bootstrapped
on this oh no there is deaf macro and
it's defined a couple of pages into the
boot script for closure which I might
show you we have some time yes yeah this
is that why are you doing this for yes
now it ends up that enclosure macros are
functions and so there's just a way
there's a way to bar say this function
is a macro and it will be treated as a
macro instead of as a function okay so
that's a tiny set of things in fact when
you take out the stuff related to Java
it's an extremely tiny set I don't think
I made it down to seven one two three
four I have more than mccroskey set but
I don't have dozens so how could this
possibly work this is not enough to
program with this No
so so we need macros okay
there are planning supplied with closure
and what's beautiful about closure and
ellipses you have the same power that I
have right macros when you see the kinds
of things that are implemented enclosure
as macros you realize the kind of power
you have as a developer because you can
write those same macros you could have
written them you don't have to wait for
me I'm not son this is not Java you want
to do something you have something you
want to express a certain way you want
to extend the language that way if you
can do it with the macro you can do it
without contacting me or asking me for
the favor of adding a feature for you
which means the language is much more
extensible by programmers if we remember
we're getting data structures passed in
the compiler so it looked at the first
thing and somehow there's a way and I
can't show you that tonight to say this
name designates a macro and associated
with that name then is a function the
function expects to be passed the rest
of the stuff that's in the parenthesis
so we have this cool function my cool my
cool macro maybe it expects to be passed
to things the things that gets passed
are not evaluated it gets passed the
data structures that the compiler got
passed because the compiler is going to
say you told me you know how to do this
here are the data structures give me
back the data structure I should be
processing so it's a transformation
process where the macro is handed the
data that's inside the parens as
arguments to the function that the macro
is it will run any arbitrary program you
want to convert that data structure into
a different data structure you can write
macros that look stuff up in databases
that go and ask a rule-based system for
advice most are not that complicated but
the thing is it's an arbitrary program
transformation there's not a pattern
language it's not a set of rules about
this can be turned into that
it's an arbitrary program a macro and in
this way it's like a common list macro
that given the data structure it gives
back its own replacement replace me the
expression that began with me with this
and then keep going which may yield
another macro and another round of that
or it may yield something an already
knows how to process yes no this is
happening at compile time this is part
of compilation right the compiler got
handed this data structure it said oh it
begins with the macro name hands it to
the macro it comes back that
transformation occurs it keeps compiling
then you get byte code after you get by
code there's no more talking to the
macro so macros replace themselves with
another data structure and then
compilation continues so we can look at
a macro you'll notice on the list of
primitives there's no more or is not
primitive in closure and in fact if you
think about or or is not primitive or is
now criminal primitive logical operation
you can build or on top of if right the
or I'm talking about is like the double
bar or in in Java in that what happens
if the first part tests true what
happens the second part not evaluated
right still got that magic thing but if
already knows how to do that if already
knows how to do a conditional evaluation
of only one of two choices which means
we can define or in terms of if and so
this is what happens so or is a macro
when it's expanded by the compiler it it
returns something like this illicit or X
or Y and this is what comes back another
data structure
to the lab which we haven't seen so far
but let says it takes make this name
mean this inside like a local variable
except it's not variable you can't bury
so let's do that and these why this is
because this is going to be some
expression it looks like X here but it
could be like a call to calculate some
incredible ly difficult thing that's
going to take an hour which is it
probably will repeat that more than once
in my expansion because it would
calculate that thing twice
so we're going to take whatever that
expression this put in here is made up
it's good machine pick name so it makes
it very one that says if that is true
like you can took an idea that's true or
turn it otherwise it's going to do what
and that's the implementation of war if
the first thing is true it returns it
well in fact in Java you don't get a
good value but in closure you get the
value that was true
all values can be placed in a
conditional not just boolean's and it's
subject to the rules I said before if it
is nil or if it is false
you'll get the else if it is anything
else
7 the string Fred anything else is true
so closure like most lifts lisps allows
any expression to be evaluated as the
conditional test no I talked about that
let's say this extra right a well a
macro will make sure it only gets
evaluated once I could have put if X X Y
yes no this is the answer to the
question I could have
X X otherwise Y then if X had side
effects and happen twice then it's not
well written a crow this is a Louisville
Metro where it needs to use that
expression twice which by the temporary
value a temporary area to the value
which means once here so if I had a side
effect it would happen only once if it
took a long time it would take a long
time only once
let actually takes at the topmost level
it takes n arguments the first which has
to be a vector of pairs and things you
can have multiple expressions this is
once so and then that is a block so it
actually can have multiple expressions
in this case there's only one it returns
the value of what well this is a macro
and all it's going to do is give the
compiler back this and the compiler has
to keep going with this in hand now let
will let establishes this name to knock
inside yeah
then when let runs the series of
expressions inside lat run and the last
of them is the value of the let
expression and this case is only one
expression inside the back
in this case it's like one expressions
and so the value of the if expression is
the value of the left which is what we
wanted really you know we want this to
mean or in X is the end
yes and well it's one of the beautiful
things about the system which we'll see
clarified in a moment is that all
expressions are bound so we don't have a
lot of complexity with precedents and
terminators and things like that it
started with the brand it ends with the
matching paren later big boolean in fact
it has to be big boolean false if it's
coming from Java I test to make sure
because an improperly constructed big
boolean may not be boolean dot false new
bullying is wrong and in fact not only
is new boolean wrong but the reflection
API in Java uses it exactly that way so
it returns multiple different values of
big boolean false I I have a patch that
looks for that because I got bit by that
already so it will make conversions of
big boolean falses that aren't boolean
dot falls into boolean Davos
I'm sorry I didn't write Java I only
wrote closure so but the point here is
that this seems like a primitive thing
like if the language doesn't have it
you're in trouble it is not if I hadn't
find it somehow left out or you could
have added it you could have written the
macro that does this job and add it or
to closure I'm sure I forgot some things
in closure you could add them many
things in fact we saw how tiny the
special operators list is and or cond
all kinds of things are built on top of
these things as macros and/or functions
and and after the point of the special
ops you can't add a special operator
but you can add a macro
right right
right you're going to get a reference to
the expansion inside of the expansion
correct that can be challenging it's
it's still an area I think that one of
the things that's good about Alice is
because you have the ability to work in
the small and to say I just wrote this
little component of the slate
I'm going to run this right now I don't
have to wait till the big program that
contains this runs your ability to do
that immediate unit test to make sure
that thing is working is good on the
fifty thousand foot level propagating up
for macros the source of the problem in
the macro is something that's being
worked on some compilers do it pretty
well for common list it's an area I hope
to enhance in closure but it will always
be more challenging than a function and
that's why Mac macro writing is not for
new newcomers or the inexperienced part
of the team it is language design it
definitely is on the other hand without
it you're limited to the abstraction
capabilities of functions which are
limited think about how much you repeat
in Java think about how much code you
repeat to close files and job
think about it think about how many
times you've written the exact same
thing
I mean having your IDE spit it out is a
little bit handier but when you decide
oh I need to change my policy about
doing this I want to check something
else all that generated code is not
amenable to you know to fixing so those
kinds of things that can't be whose
redundancy can't be eliminated by
functions can be eliminated by macros
and that's something you want to do
because the b-side of this is if you're
doing all that stuff by hand
yes it's transparent you get this
debugger error okay you did that by hand
we're all over your program right
because you didn't have a macro that
generated it you don't have one place to
fix you have n places to fix so there's
a but but you still have to find
everywhere you have to fix it yeah and
these things are idioms everybody that
programs in Java has to know this these
idioms are only by convention and have
to be manually replicated
it is an attempt to address those
cross-cutting concerns but it's still
unproven as to whether or not you people
will describe them there those things in
advance because what tends to happen is
that you don't know it and then you say
oh I'm doing this all over the place and
then will you implement an aspect is
there a policy is there a way to
describe an aspect that will insert it
everywhere it's needed it's a very
challenging problem I mean I think
aspect oriented programming programming
is interesting but it's different so
anyway there's trade-off with macros yes
it may be less transparent there on the
other side when you fix the macro you've
fixed every usage of the macro probably
gets an easier thing I mean start with
special operation macros mostly because
that's the evaluation order but
functions exist and they're they're kind
of straightforward the first thing about
functions you need to know is that their
first class values their values like any
other methods in Java are not first
class
you can't put a method into a variable
you can't pass a method to a function
there are special things in lisps and in
fact in most dynamic languages today
functions are first class which means
the function is of value to mean 5 and
of course I don't need to do that but
I'm showing you a dad right I'm a symbol
to a value now I'm going to show you the
death of a symbol as you are two values
special operation both fun and when fun
does is it creates a function object
this is going to turn that code into
something that gets compiled into a
function that takes one argument and
multiplies it by itself it's a it's a
regular function it's going to be an
instance of a Java interface that takes
an argument it's a real regular method
in the end in Java you'll have an
invalid arity problem okay I need to
move a little bit more quickly so Alyssa
let's hold the functions for a little
bit let me let me move forward so this
fun I can't describe all of the features
of fun that's exciting and rich thing
but we can take as being fun as a
special operator it takes a vector of
the names of its arguments
and then it contains the set of
expressions which will be the body of
the function the last expression is the
value returned by the function there's
no return statement in closure so when
we say Square five it returns 25 okay
this is a function call again we said
what does it do it says is Square a
special operator now is it a macro we're
going to say right now it isn't so
what's the value of square it's this
function object okay call it and pass it
that the value of that okay so the
arguments to functions are evaluated so
it's going to pass square the number
five square is going to multiply it by
itself and return 25 so functions are
first fast there are other things that
are like functions in other words the
compiler says you know can I call this
the answer is true of funds it's also
true of other things in particular one
of the neat things about closure is that
maps are functions because if you think
about maps mathematically they are
functions maps are functions of their
keys given a key a map should return the
value of that key and it does enclosure
so maps or functions sets or also
functions vectors are also functions
vectors are functions of their indices
ok that's cool stuff and when you see
idiomatic closure some of it is quite
beautiful because of that relationship
so we'll try to summarize this things
that would be declarations or control
structures or function calls or
operators or whatever in Java all our
uniform enclosure or any less in that
there are lists where the operator is
the first thing in the list so we've
reduced all of this variation
look at each one int I equals 5
establishes I as a name whose meaning is
the value 5 that I does that as well
awareness doesn't say it's a definition
whatever some rule about the shape of
this thing says it's a definition
including closure that says that's what
it means okay if X is equal to 0 return
Y otherwise return Z
when is this end I'm assuring the rest
of the program is this done got me you
don't know I don't know
right because you could say else else
right else else if right we go I
couldn't see how say else if and then it
could say else right we have to keep
looking forward we could not have had
enough right it's not closed
in addition without these returns it
doesn't yield the value this is a
statement in Java right there is it
there is an if conditional which is an
expression at two different things
enclosure if guess first you know it
takes three three things
that's a function name you can have
question marks and names closure is much
more liberal about the symbols that can
appear in names but not completely local
because I need some symbols for myself x
times y times Z one of these
mathematical operators again another
special thing about Java then they can
go in between things and there's
precedence rules all other kinds of good
right what's happening multiplication
first also you'll notice multiplication
can take multiple operands more than two
it's not just a binary operator it's an
area operator foo X Y Z this is what
function call right people complain
about none right you move it from here
over there same thing same town what
you're talking about
and you're not gonna see curly curly
curly curly curly curly curly yes you
may see friends that but it's better I'm
telling it does it keeps your program
near itself you have to go down to the
next page to see the next step and then
this member access I'm going to talk
more about the Java interoperability but
same kind of thing different number of
parentheses no different number of dots
no but first because that tells closure
we're doing some Java stuff here that
has its own special interpretation
because dodd is a special operator we
saw before so there's a tremendous
uniformity there's a lot of value to
that uniformity you know I know a lot of
programming languages and every time I
have to learn
arcane whatever the rules are syntax and
this thing next to that means that and
this character means this and you can
have a semicolon here but not there and
it better be indented by the same amount
or whatever it is I really get angry now
because if there is no reason for that
it is not better than this and if you
use this for any amount of time you will
not disagree because there's no one who
has who does
I'll show you later if I only have
another hour I have to go much faster
every ready so let's hold the questions
until like a question time unless you're
really confused but just general
interest things will hold because I may
cover it one of the things that is
typical about lists is that a lisp is
that it has a rich library for
manipulating lists but it ends up that I
think in my opinion it's a shortcoming
of lisps traditionally that those
functions are limited to a particular
data structure which is the singly
linked list because the functions that
underlie that abstraction are broader
and there are three of them the first is
I like to obtain some sort of sequence
like thing from some sort of collection
one thing that's abstract way to say
something given that sequence like thing
I want and need only two functions one
is to say give me the first thing the
other is to say give me the sequence
that is the rest of this sequence in the
case of C if there is no stuff it
returns nil because nil means nothing
which means you can say C call and you
can put that in an if expression as a
test thing and because nil returns
logical false you'll know there's
nothing to do that's an important idiom
of common list closure preserves unlike
scheme we have to say M
if it's not empty you will get back an
object that object only makes two
promises you can call these two
functions on it right this function
promise is one thing there will be a
first element because we're recovered if
there's not a first element here so if
you say first of the seek and it's and
this is not known means you have a seat
you get back a guy the first thing in
the sequence if you call the second
thing you can do with the seek is you
can call rest on it which says give me
the sequence that represents the rest
not including the first thing of course
if there's no more what should we get
nil right because we sit here nothing if
we have nothing to get nil otherwise
we're going to get another seek this is
an extremely abstract way to talk about
lists but the advantage over
Common Lisp and scheme lists is they
would promise that the return value of
this thing is a concept and that is a
real limitation because now I can make
seek work on absolutely everything seek
works on lists because they have the
structure but it's possible to create a
seek object if you think about it errs
and I don't want to make this analogy
extremely weakly right there's a way to
walk through a vector right similarly
there's a way to walk through a map
there's a way to walk through a string
there's a way to walk through a file and
it ends up that seek is supported on all
those things you can walk through Java
arrays all the closure collections
strings files everything and you can use
these two operations to move around this
abstraction of list this and which I
call a sequence because a list is more
of a concrete thing is is bound to lists
in most lisps classes hearts a
but is not enclosure and it's I think
one advance one advance of closure in
the list world which means that you can
apply these things to everything so what
was this mean well this is kind of
primitive I mean walking through what
step by step but what it means is that
you can build a library on top of these
primitives that provides a lot of power
for manipulating data structures without
loops I'm just going to show you a tiny
tiny little bit but it should give you a
feel for what it's like the program
enclosure if you would think about what
it would take to do these things in Java
for instance I have a set of things I'd
like to have everything except the first
two things right we say drop 2 from
whatever the collection is that happens
to be a vector it could have been a list
it could have been a string or drop the
first two characters whatever it is
there's a way to abstract out the notion
of walking through it drop means leave
out that many and give me the rest as a
sequence tape is the opposite it says
only give me nine of these things look
at the second function cycle cycle the
function takes 1 2 3 4 in this case to
take any sequence Abul thing it returns
an infinite list an infinite sequence of
those things around your round in a
cycle how could it do that
is that going to chew up all the memory
of my machine cycle it sounds like a
really scary function it does that
because if we go back to this definition
of this is there anything about the way
I describe the operation of these things
that says that the rest of this thing
has to exist I could make up the rest
right when you ask me right and how much
of it would I have to make up just one
more thing the thing I give you has to
have one more thing in it and it's ok
and it could delay the calculation of
the next part till the next time you
call rest
that's called laziness and in fact all
the sequence stuff I'm showing you
foreclosure is lazy which means that you
can write sequence functions that return
infinite sets and you can use them as
long as you don't try to consume all of
them you can consume a little bit of
them so in this case we're making it
puts out at one two three four we're
taking the first nine things from it
this looks like a weird weird abstract
thing but I've had plenty of programs in
reality I've had to do exactly this
thing round-robin you can use it to
round-robin work dispersal you can use
it to get distributions in cycle it
seems like some theoretical isn't this
cool you can make an infinite sequence
but it really has utility it ends up in
real programs and it goes on and on
interleave does what you think won from
this sequence won from that makes a new
sequence again one of these could be
infinite right you'd only make as much
of this as you needed to match the
length of the non infinite one partition
split this up into pieces think about
the loops to do this stuff you end in
Java you have to write every one every
time right never mind the laziness part
now we get to a more interesting
function which is math okay now we're
not talking about map the data structure
we're talking about map a function which
is again from Lisp land which says take
this function right so the first
argument of map is a function value and
apply it to pairwise
you know the sequences I provide so in
this case we're going to call the
function vector and we're going to call
it on a and 1 then we're going to call
it on b + 2 + c + 3 + d + 4 + e + 5 and
vector makes seconds out of whatever
you're passing so we're mapping vector
across this pair of sequences to
vectorize corresponding elements of
those sequences we get a set of data
structures back out of this so math is a
very powerful thing instead of saying
for each blah blah blah do this and
stick the answer into this collection
you say just map this function across
this data and I'll give you back a set
of new data the result of applying that
function to each thing you can also
apply it against multiple sequences so
this is doing maybe I should have done
something this complex here apply is
also very interesting and it's a unique
thing to to lisps and and languages that
are dynamic apply says I'm also going to
pass you a function all I want you to do
is take the next expression of figure
out the sequence it yields and then use
that as the arguments to a call to this
function so we're going to apply the
function stir and stir says given any
set of things turn it into a string
concatenated into a string and
concatenate them all back together into
a string so we want to put that together
and what interpose does is it says
so interpose asdf to turn SDF and to
sequence and return characters so we
have the character a and a comma s and a
comma D and a comma F in a comma seven
things report names with three finger g7
thing we say apply started that which
means string concatenate them as if
these were they were the arguments to
stir those if I called stir and set stir
a comma s comma D comma F comma F it
would make a string out of them well I
can just apply it to this sequence as if
I called it with those arms and we will
do the job I get back a single string
with that in between again if you don't
quite get these it's okay I'm just
trying to show you the power and the
succinctness of this reduces another
function that takes a function it says
apply this function to successive pairs
of the sequence you're given taking the
result of each application and using it
as the first argument of the next so if
you if you say reduce with plus you're
going to get the first two things plus
each other and then take that and do
that plus the next thing and take that
and do that plus the next thing that's
what reduced us so this is effectively
is summing this range range it's a
function that returns a sequence of
numbers and you can you can you know set
where it starts and where it ends and
how how it steps and things like that
this is obviously a much higher level
way to write programs than you do in
Java yes no did your head hurt so I
don't know what is good
yeah let's take this would be a good
time for a break because they may have
any questions on this real quick
right and psycho returns a sequence
which has only got one in it and the
recipe for producing the rest of the
cycle sort of like a delayed function
that's what happens inside cycle it
doesn't produce an infinite list
obviously it returns an object that
satisfies it returns a sequence correct
okay why can't you call stir directly
well in this case well I'd have to write
a s comma D Kafka right it's then you're
gonna then you're passing stir a
sequence and what I want to do is is say
take that sequence and pretend it was
the arguments to start not an argument
to start but but M arguments to see
because that's the syntax of closure
slash comma is a character literal for
comma quote is used for other things
that's why I don't use it for character
literals I ask take a break</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>