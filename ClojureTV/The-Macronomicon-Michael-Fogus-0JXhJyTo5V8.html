<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Macronomicon - Michael Fogus | Coder Coacher - Coaching Coders</title><meta content="The Macronomicon - Michael Fogus - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Macronomicon - Michael Fogus</b></h2><h5 class="post__date">2013-01-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0JXhJyTo5V8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Michael focus is a man of many times he
is e as am I making all that noise ask
for the mic alright so yes he's an
author he currently has an epic number
of worthwhile books on a service called
Goodreads just more books than you could
ever possibly read in a lifetime I don't
know he does he has his own Lisp
implementation Folger he keep an eye on
that but but most most impressively I
think this is the only person I know
with his own emoticon which he uses to
sign emails and books so if you get your
book sign you can find out what that
looks like and he will tell us the
secrets of
so one day the acolyte came to the
master Mac Rajasthan seeking wisdom the
mackeral mackeral Aegis name was PI mu
and he saw the acolyte coming and he
knew that he sought knowledge and he
said to him
stop what is the true power of the macro
and in in an act of thoughtfulness the
acolyte stuck his finger to his chin and
immediately pi mu brandished the knife
and cut the finger off and of course as
you can imagine the acolyte screamed in
pain and and and cried and gnashed his
teeth and he and he said this guy's
crazy I got to get out of here so he
started running in PI mu said stop I ask
you again what is the true power of the
macro and the acolyte went to place his
finger at his chin again and the finger
was gone and he was enlightened so as a
child I spent a lot of time on the
Commodore 64 and I probably betray
myself as a child of the leisure class
that I had this this this this this
luxury and one of the early programs I
wrote was a baseball statistics
calculation program and and one of the
nice things about this was that we would
play games in the neighborhood and then
I'd run home and I type in all of the
statistics that my friends and I had
accumulated throughout the day and then
we could walk we could we could we could
we could see how we were doing over the
course of the summer and the nice part
about this program was it would it would
store the the new games in memory and
then at the end when we quit it would
dump it out to disk everything and then
so the next time that program loaded it
had all the statistics that we had
entered and and all previous statistics
and and so that was really my my first
exposure to a program writing program
and that is exactly why I'm here today
and a store mentioned I did write a book
but that's less important so yeah we're
talking about program writing programs
and and for anyone with thought with
some number of experience in the
computer industry you've come across
programs that write programs and and and
some examples you know - more or less er
extents they give you that that
capability but these are tools and
really what I'm talking about is
language level program manipulation so
let me talk about a little bit about
some of the popular cases and and so I
will start with with C and and and C a
long time ago had had an interesting
property and so you could you could you
could define a preprocessor directive
from any any random sequence of
characters and so what that means is
that you could you could replace any any
block any string of code and you're in
your program with with with anything and
so this was crazy
I mean unbelievably crazy said there
wasn't this was causing all kinds of
problems so they they thought of a fix
and instead they they they limited to
rather than random strings of characters
it was more along of a expression and so
what this what this allowed you to do is
describe preprocessor directives that
that could that could be direct
replacements in your program text but
there were problems with this because
the replacement the way that it parsed
was very different from the intent
whereas the intent was more along this
line so every C programmer knows that in
order to get around this she just Jam a
bunch of parentheses around everything
and so eventually you'll you'll get this
right but it's not exactly right because
you can have you can have expressions
that cause side effects and so all bets
are off when this happened there's not a
lot you can do here I mean I'm sure that
someone's figure this out but it's it's
I got out of C a long time ago and and I
haven't been following that the state of
the art in crazy preprocessor directives
but there are other things that give the
same kind of behavior but in in a
slightly different way and want to C++
and everyone's heard of the term
template metaprogramming and and an
interesting an interesting example of
that is a factorial that occurs within
the templates of a C++ program so at
compile time the factorial of a constant
is is calculated and outputted so this
is pretty good but C++ gets allows you
to do this in a number of ways giving
you a number of tools and one is it has
values another is it gives you functions
branching type things and recursion and
you know this this is starting to smell
like Turing completeness to me and and
and you I have a little rant that I like
to give about Turing completeness is and
and and if you're on the internet you
know that any conversation about
programming languages eventually
devolves into a talk about well this
language is turned complete and so it
can do anything that other language can
do and of course to an extent that's
right but I mean even though that's not
the exact meaning of Turing completeness
but the meaning is known that and and so
but there's a problem with that and
there's a problem the problem is one of
diminishing returns and and so even
though this may be Turing complete you
wouldn't want to write a spreadsheet
program in this so let's talk about Oh
camel for just a moment and oh camel is
actually very interesting it's much more
in tune to these other two that we talk
because given a piece of Oh camel code
you can manipulate you can deal with
that in one of two ways you can deal
with it directly like this or you can
deal with it as it as an ast and so what
but no one wants to write there there Oh
camel in this way so they really want to
deal with this so what Oh camel gives
them as a quoting mechanism but what's
kind of special about the quoting
mechanism is that it has a tag and the
tag describes a processor for that bit
of code and so this is actually very
interesting because you can get a lot
done with this and you can do some very
interesting things with syntax with this
over with this Oh camel mechanism but
there's a there's a there's a there's a
this is you're dealing with Oh camel at
a level that is is is not the way you
would typically deal with with Oh camel
code but that's not why we're here we're
not talking about Oh camel we're talking
about Lisp and specifically we're
talking about Lisp macros so last year
Christoph gave us a great talk I thought
it was a fantastic talk and and and and
and and I don't want to libel the talk
by oversimplifying it i really suggest
you go and check it out but it at its
essence it boils down to to to the use
cases of macros legitimate use cases of
macros and one would be creating binding
forms another creating control flow and
then some icing at the end so if i'd
misrepresent you christoph please just
just bear with me there's a point to
this but before I get into dealing
directly with this I want to talk a
little bit about the history and so you
know we saw this the very first talk of
the day had this in it um and this is
this is the original Lisp eval and it
dealt with with you know
basically one tiny increment above the
lambda calculus so it's interesting but
it's it could be more interesting and
and and there was a man named Timothy
Hart who came along and and there's this
there's a PDF out there and it's just
it's incredibly blurry it's very hard to
read but in it he describes a macro
capability that extends that type of
eval with a little bit more and if you
look at the end you'll see that it now
has a macro form and a macro and in in
this early form is a function of one
argument that takes a data structure and
spits out a data structure as simple as
that
and but the real key is right here eval
eval and so on the first D in the in ER
in ER eval is when the manipulation
happens within the function the second
eval evals
the the results of that manipulation so
that's kind of cool I have a I have a
lisp online it does this it's really
stupid but so macros are kind of cool
but in the cases that Christophe
described you don't really need macros
in fact if you have a language with
light weight function literals or blocks
you can do that stuff without ever
dealing with a macro and so for example
Anakin in the case of control flow the a
similar Ruby equivalent would just deal
with a block and and and it works
effectively the same way I guess and and
likewise for bindings taking a sequence
and and binding another a number of
names to it corresponding to elements
within the sequence is is it's likewise
fairly straightforward and and and it
looks just as clean as the macro case so
control flow and binding maybe not a
compelling case for macros just maybe
let's bear with me so what about icing
what about the icing part well there are
other languages that provide a
great level of icing slathering on your
language and one is Scala and I wrote it
I wrote a Scala I want to quote this DSL
that is my greatest contribution to the
scholar community ever and it
this is Scala code this is Scala this is
not basic this is Scala and so using all
kinds of tricks and and and evil I've
managed to coerce Scala into looking
like this but there's a problem with
this I mean besides the obvious and and
and and it is that that you're not
really dealing with basic it's the
pieces of Scala just poke through and
for example there are some symbols
laying around here and and and and
there's some implicit conversions
happening and and and you know there's
some closures over here and and and some
map lookups and it's all held together
with this kind of like trampoline at the
end and and and and while this is a
great thing
I mean outstanding thing it suffers from
something we call the mapping dilemma
and and and I give a picture of this
book because it to me it perfectly
describes a mapping dilemma and and in
this book there's this there's a story
called the man who came first it's the
greatest time travel story I've ever
read and and in it a man goes back in
time you know not that long long enough
so that even though he knows the
language and he knows some of the
cultural aspects of the time that he's
he's put into no matter how hard he
tries his his own prejudices just sort
of poke through and that causes constant
friction so it's that poking through of
the underlying I don't know mores that
that sort of describes a mapping dilemma
I bet I won't talk a lot about that I
mean other people talked about this but
I want to go back to the these use cases
that
we started off with and although these
these may be legitimate use cases for
macros I have other ideas I mean a great
man once said that that you know
anything you can do with macros are
legitimate but it's it but bear in mind
I mean this is this should go without
saying that it's all a matter of
cost-benefit analysis so while I say
this
it's a double-ended gun be careful so
let's think of some other ways that we
can use macros and I'll add to this the
list and one would be adding abstraction
transformation optimization which is
really sort of a subcategory of
transformation and true power
awesomeness basic would be an example of
true power awesomeness but let's think
about this for a second any any time
this is gratuitous I'm sorry anytime you
want to define a macro you have to you
have to go through a CI I like to go I'm
not going to prescribe anything this is
what I do what do I want what the heck
am I trying to do so just for a small
example I want a way to define local
bindings it sounds very familiar I'm
sure you're you're aware of something
called lek but really do you need a
macro in this case yeah but I'm going to
just briefly describe a different thing
I have a library called called um UNK
that is just a memoization library and
and it was really tempting to make the
the the memo the memoization builder a
macro that just looked kind of nice but
really it was just it was just a
function that took some some functions
and return to function and so that's
exactly what it is didn't really need a
macro in that case so I didn't use it so
the next next thing to think about that
I think about is what does it look like
so that's always where I start
if I'm trying to do something I write
the thing that I want the the the
greatest thing that I could think of
that I that I want when dealing with
macros and then when you do that how
does it actually work so this is just
this is just a nested if you if you know
JavaScript this is this is very familiar
just a nested function calls that that
pass in the arguments and provide proper
scoping and so once you've really gone
through this thought process what's left
to do just type just start typing and
eventually the implementation will come
out so that's it that's that's the whole
thought process but one side note it's
as simple as that one one thing that I
that I do want to mention is that that
was kind of ugly I mean that's not how
we do it enclosure we do it slightly
differently so you know our binding
forms look you know they're paired
implicitly so you know to get that it's
just a partition two away but that
that's we all know that by now you've
read the book so okay I I wasn't going
to put this into the top but I couldn't
control myself given given our
illustrious audience members and so I am
going to talk a little bit about hygiene
enclosure although this is a matter of
ongoing research and you know this guy
agrees with this guy but he disagrees
with that guy and and so on and on and
and so we never really get an answer to
the hygiene problem not yet but hygiene
can be described in a real simple way
that is well it's it's it's a few words
whether or not it's simple is another
matter but I just want to give an
example of how closure deviates from
hygiene and and the degenerative case
one is just a simple macro that returns
some keyword when when the thing it's
given is truthy so the problem here of
course is that in this naive
implementation if you have a var that's
defined somewhere and and this macro is
somewhere else it's going to give you
the wrong answer the problem is because
the the way that closure works the
symbols are expanded to be you know
qualified and and so there was a problem
with the original illumination which is
easily fixed but this is this is
definitely a case of of Hygiene that you
might hear used on the use on Usenet
perhaps so scheme schemers are always
saying things like oh well proper
telltale calls and and and hygiene and
unhygenic and they use it in this sense
and this is definitely true where
hygiene means clean and unhygenic means
dirty or rotten and and and and that's
that's that you you can you can make a
case for that but there's a different
sense of hygiene I think which is
illustrated in the degenerative case -
which is where you're doing something
like an a wound where where the
definition of a local it is is available
within the body and so it's sort of
magic the way this happens but it's not
really it's just you're breaking hygiene
for specific purpose and and so now
you've still shadowed the original
original definition of it but you've
done it in in a kind of a weird way it's
not it's not textually obvious what's
happening here and so that's part of the
problem with this but so in closure we
use it we do a slightly different thing
where we we provide binding forms when
we're trying to do this kind of stuff in
that that that solves that particular
problem but there is there is a use even
though it might be small and and and
it's not it only happens maybe once
twice and closure core itself where you
want to break hygiene but that's
definitely a different sense of hygiene
where it's more you know a sanitized
versus rolling up your sleeves to get
stuff done
- so providing that window into
unhygenic behavior but you know that's
just a side note really what what I'm
going to talk about is the use of macros
and a little bit of the abuse and so I
used the word dsls earlier and and I
quoted it and there was a reason for
that because a lot of what we're doing I
don't really agree our dsls and because
dsls created as as embedded dsl x'
especially are very very hard and not
only are they very hard but they're very
hard to make robust and they're very
hard to make so that the the input that
the language details don't bubble up to
the top and they're very hard to make
that provide useful error messages so I
really don't want to talk about DSL as
in this talk but what I want to talk
about and this is what macros I think
are great at are creating mSL's which
are mood specific languages and so I
didn't I didn't invent this term but I
like it and and basically what it means
is we want to be able to write a
language that makes sense within a given
context and and and the the way that
it's used in pre Martos papers is very
very restricted within within blocks
context but I'm not talking about that
I'm talking about trying to create a
language that makes sense within a
certain context and one one example is a
library that I created called Trammell
that has exactly zero users not
including myself and so I went through
that that process I described earlier
and I'm not going to go into great
detail but I think it's useful to
enumerate the things that I wanted to
get done and one was a new pre post
impacts another was a D complected
contract from functions
I wanted invariant on records and types
and references and definitely better
error reporting and some other stuff
that it's
but really did I need a macro and the
answer is yes and the reason is for a
specific thing and one and it's called
second class forms is any if you're
unfamiliar with second class forms it
could be described easily for any
language that is above the pure lambda
calculus there's something called a
second class form and in the case of of
Haskell perhaps would be maybe I don't
know a type annotation but in closure
and in specifically the case of trammel
it's this pre and post map now what that
means is you can't get the pre and post
map in there as the result of an
expression it disappears it disappears
for a compile time and and and and does
and and and and adorns the function that
that that it's attached to so this is a
great example I mean I can sit then I
can say I can pitch on the mailing list
and say hey I think that that pre and
post condition should look like this
instead of this and so I can do that
round and around and around but really
why should I I have macros why do I need
to wait for rich to do that I have the
power he gave me the power and I'm going
to abuse it I mean use it and so yeah I
mean I used macros to provide a new kind
of pre post syntax it's a little bit I
mean it's a little bit more compressed I
mean it and and it's this little vector
thats hanging off at the end of the art
list and so for a square function it
just describes that the square function
accepts a number that's not equal to
zero and produces a positive number
simple well I should hesitate using that
word it's easy so another thing that I
really wanted and this is this was more
important to me than the other thing and
I could have done I could have just used
the regular syntax of this but I want to
de complected contracts I wanted to
define a function and then later on
apply a contract to it and and this is
kind of what it looks like you know if
you're doing the Gregorian last day of
month calculation there are certain
thing you can you can
right that and in a completely separate
place you can write the contract order
you can do it right underneath it
doesn't matter it'll find out where it
is and it'll it'll apply the contract
after the fact a third thing that I
wanted were record invariants and both
this and the other thing do some really
evil stuff that we can talk about later
but the the it the fact that closure
even allowed me to do this it's just
astonishing
but that other stuff has nothing to do
with macros but this is I think this is
somewhat lacking in the the way that
closure handles pre impose conditions
but again I didn't it doesn't matter
because I had the power to add this if I
want it and so finally I wanted better
error error reporting at the moment if a
precondition fails it just it throws an
assertion exception but I really wanted
to know if it was a pre or post
condition I really wanted to know I
wanted to be able to assign blame you
know which which function through this
so what function through that then and
at the moment it's kind of a hack the
way I do that but with with new
capabilities it seemed to be coming down
the pipe like load bearing exceptions I
think I can get more contact contextual
information out of that but there's
there's a technique that I used
throughout this whole library and and
then actually it's used a lot and and
that I find simple of simplifies the
matter of writing macros and I like to
call piecewise transformation so if you
look in the Trammell source you'll see
this kind of pattern throughout and
you'll actually see this pattern in the
closure core also where you you
disassemble a data structure that comes
in such as a body which is just a data
structure comes in to a macro and it's
it's incrementally manipulated in pieces
and and and eventually built back up
into the thing that the macro is
producing you can you can even go on the
closure core and see how this is done
and this is just a
a piece of that macro but in in the book
I talk a little bit about a macro called
as futures but I don't go into this this
piecewise transformation at all but the
premise is you you have this macro in an
action that produces a result and the
actions are distributed over some number
of futures and then afterwards after
they're done you can you can use the
results in a body so a use of this might
look like this which is switches you
know not not all that compelling but it
it's simple it fits on the slide but if
you want to sum the factorials of a
bunch of numbers you can distribute that
across a number of futures and and and
deal with the result but the important
part is the implementation and
specifically in the let and and and what
what I've done is I've sort of split it
up and dealing with the left-hand side
and the right-hand side in different
ways and then reassembling them into the
the the body and and what I always try
to do when I'm writing macros and I
don't always succeed it's actually a
little bit difficult to do is to try to
get the last thing in the macro to look
exactly like the thing that it should be
when it comes out and it's not it's it's
it doesn't apply to every macro because
they're all different and and some are
more complex than others but what this
approach allows me to do is something I
like even more and that allows me to
along this piecewise transformation to
attach functions validation functions on
the parts and report errors on the bits
and pieces of the of the transformation
along the way so this is this you know
maybe you could experiment with this or
maybe you have a different way for
writing macros but I found this very a
very good way from for me to wrap my
head around what was going on but back
to trammel so what what is underneath of
trammel and this is really what the the
beauty of Christoph's pockets and and
and he says
that for any macro make sure that your
base is solid and you're building on
something that that is is composable
that makes sense and and and that's
exactly what I'm trying to get popped by
here and that's this is this is teased
out and something I want to call the
primacy of semantics and and what that
means is the most perhaps the most
important thing in any program is that
it does what it's supposed to do and
regardless of any other thing that
that's that's what we should focus on
and a long time ago you know great
computer scientists talked about this
specific thing so at the bottom it's
something called
I like to call contract which is the
simplest thing in the world - some some
crazy web of try-catch that I built that
I'm not showing here that that assigns
blame but at its essence it's just this
simple thing that's a function that
takes a function and some number of
arguments that has that has the pre and
post conditions attached and that
delegates out to an original to another
function and so what this allows you to
do is a constrained function is just the
partial application of the contract with
the function that you're trying to
constrain and what's kind of cool about
that is you can then piecewise compose
these things one after the other so you
can take a piece of a contract here and
a clause of a contract there and bang
them together apply them to a function
and it just works well one thing another
thing that I actually like even better
than that is it provides contracts on
higher-order functions and so I can with
this with this macro I can define the
constraints on a function that take a
function and define the constraints on
the function that that function takes if
that made any sense
you deserve a cookie so yeah that's all
it does is it describes a in-place
contract and that during that delegation
prior to the function
going in to the the function under
constraint it applies a contract it says
it's as simple as that but the cool
thing about all of this and it would be
worthless
if if I couldn't do this is that given a
single command it all goes away it just
disappears
so that's kind of cool that's that's
actually something that macros are very
very good at and we can think of other
cases of this and for example logging
statements if you if you have a macro
that provides a locking capability you
definitely want to have that during your
your development and and perhaps staging
modes but you might want to turn it off
at production and macros give you that
switch so let's talk a little bit about
programs writing programs writing
programs and to illustrate this idea I
want to talk about another library that
I have called minder binder and minder
binder was sort of influenced by another
language called Frank and if you're
familiar with Frank great I mean it's
it's it's a wonderful language if you're
not go check it out it's it's really an
awesome thing and one thing that it does
is that it defines it deals with units
and unit conversions at in a first-class
way so unit conversions are you know if
you go to the NIST website they have
these huge documents about unit sizes
and how they relate to each other and
base units and so there's one way of
writing a library that provides unit
conversions it's just to write a bunch
of functions you know meters to feet or
meters to yards or whatever and you just
just just keep type and never stop
typing because you will never stop
typing if you if you're trying to do it
this way so you know you get your unit
conversions feet the meters and then
what if you want to do centimeters the
shackles or ramzan and change the
fathoms what if you want to do
abbreviations what about if there are
different kinds of conversions
you wanna do you mean you see where this
is going right and so do you ever feel
like you're being boiler plated alive I
do I do often I'm working in rails so
one thing when you're when you're
dealing with boiler plate one thing that
that that you there's there's a
consideration and and and I'm going to
talk a little bit about velocity and
since I'm dealing with velocity we're
talking about a number of tasks over
unicorn's so you do a task one to take
certain amount of unicorn's the second
time you do it it takes a less number
lesser number of unicorns so if a third
time comes along and you say well you
know maybe there's a better way to do
this maybe I can maybe I can eliminate
that boiler plate in some way this is
where macros can can help you and
although the third time maybe longer
than the second time I would say that in
subsequent number of implementations
it's actually going to save you a lot of
time will along a lot of unicorns over
the long haul so if we're talking about
semantics maybe the best thing to
describe a library of the kind that I
wanted minor binder the be what would be
to just look at the specification and
and you know just pipe out all this
functions I mean here it is it's right
here this is exactly this tells me
everything I need to know but that's
that's less than satisfying because
really this specification can be used
directly you just put some parentheses
around this specification and that's
exactly what I did I
I took that specification and I sort of
manipulated in a little way and made it
look somewhat like closure code might
look and this is this leads into
something I like to call the primacy of
syntax I didn't I didn't invent any of
this all of these terms are someone
else's I'm just stealing them and John
shut the the author of the kernel
language talked about this but it boils
down to this
anything that anything in a language
that is semantically useful and used and
used systematically can eventually finds
its way to the level of syntax and and
even Java does that it just takes a
while and so I wanted to design a a
syntax that went along with the semantic
meaning of these these specifications
but really what are we dealing with you
we're not syntax is nice but really
we're dealing with data and it's just
data it's all data and rich talked about
this yesterday and and he's thought
about this a lot harder than I have but
the fact that the the code is data I'm
not going to use the word homo iconicity
but the fact that macros deal on the
level of data and the data is
corresponds to source is the whole
reason that that I'm giving this talk
and and but there's more to it than just
macros as rich said you could it
provides a system that is variable and
that you can attach metadata to so this
is a very powerful idea and and and
there's two ways to approach this you
can you see it even in something like
lining in that takes the specification
of a project and feeds it into an engine
that does some stuff I mean that's data
so the length specification is data and
if you squint a little bit it comes out
I mean there's some there's some data
hidden in there so miner binder uses
that data to build up some interesting
behavior so let me ask a quick question
what's the fastest way to multiply two
numbers anyone have an idea what is that
that's pretty fast yeah but there's even
faster way you just take the answer and
you put it there
okay now whether that occurs as the as
the result of a table lookup is is
there's this distinction there with
macros that lookup can happen before the
code ever executed so Tapani at compile
time and that's exactly what I tried to
do and so I created a messed up I
created an MSL called F units of that
takes that specification as a base unit
and and and provided a description of
the unica version so within a meter
there's this there's a certain number of
inches which is a fractional value and a
foot is is is 12 inches and so it's sort
of you know it's interrelated and and
this this exactly this this this MSL is
motivated by a let-up a book called lead
over lambda and it's a bit of this is in
in the joy of closure too but I really
thought that this was a powerful idea so
what what what this gives us is the
result the result of that is a map and
the map is flattened and and and the
meter is equal to one meter that's the
base unit in inches and it's and it all
relates back through some compilation
time manipulation and that map is then
fed in and results in another macro and
now that macro is just a lookup so given
your unit and a quantity it does a
multiplication at compile time and it's
used like this and what comes out the
answer the answer comes out this is all
happening at compile time so I've taken
this specification and reduced it to a
value and now if I want to I can
generate all of those feet to meters and
blah blah blah which the bodies are just
constants and if I really wanted to
which I probably will if I wanted to go
from one kind of unit to another that's
typically the result of a function so
then you can Jam all this stuff together
and you can create I wouldn't say so
thing is as comprehensive as Frank but
you can get something that's pretty nice
and that's what I'm shooting for so I
can't believe I actually had enough time
so if you want to learn more there's
some books that talk about this kind of
stuff and there's some papers and and
websites and you can view my source
these slides will be available after the
talk and so yeah I want to say thanks to
everyone especially rich enclosure core
but also my colleague Jamie kite who
really took a mountain cyclopean
mountain of slides and turned it into
something that was worth looking at and
and and there's a lot of other people I
want to thank and and and thank you
that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>