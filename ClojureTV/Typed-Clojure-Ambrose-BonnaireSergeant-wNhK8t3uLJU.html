<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Typed Clojure - Ambrose Bonnaire-Sergeant | Coder Coacher - Coaching Coders</title><meta content="Typed Clojure - Ambrose Bonnaire-Sergeant - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Typed Clojure - Ambrose Bonnaire-Sergeant</b></h2><h5 class="post__date">2013-01-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wNhK8t3uLJU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yep so I'm here to talk about a project
I've been working on for about a year
now called type closure and yeah I'm
amber is in this talk I'm going to be
giving some motivation why type closure
exists and what kind of problems you can
solve with it and I'm going to just jump
straight into some hands-on getting
started so you can start playing around
with it yourself and hopefully with some
rappelled demos that don't go horribly
wrong so as closure programmers we like
to verify our code as as being correct
and generally we need a combination of
different techniques which to get higher
confidence so we've got things like unit
testing designed by contract and
generative testing and you often we use
these things in combination so popular
one that I uses a unit testing and
design by contract they work very well
together they don't really conflict so
one particular tool that's that's not
well represented in the closure
ecosystem is the static type checking
and that might seem obvious because
closure is designed to be a dynamically
typed language but there have been
recent advancements in this field of
research that are make this last
question a good question can we build a
tool that offers static type checking
for closure so before you wonder about
that so why would we want static type
checking at all so I basically found
these two use cases that that I I think
it's pretty obvious that type systems
can help you so one is that using
programming and more abstract
programming styles like magnetic code
and conjure code and these are quite
well suited to having static types and
another one that's probably more
practical is a java interop because Java
is a statically typed language every
time we call a method of field
constructor we have static type
information that we can we can look up
so that that's really something that
other tools haven't taken them they
don't use that information and a type
checker could use this so if i was going
to build a types of foreclosure what
would it be like so that the the goals
that I had for
closure was that I should understand
most closure idioms and that basically
means that we to port a bit of untyped
code to be typed we don't want to change
its structure we don't want to rewrite
it so it's basically going to be we add
we add type annotations and that'll be
sufficient to type jacket we also want
to take advantage of existing closure
code allow some sort of mixing between
types and on type code we want to make
sure type checking is optional as well
and that goes back to my first slides
where I was talking about combining
different testing techniques so
basically if type checking is not
optional and we failed type checking
then we probably want to I don't know
boot up a ripple or use design by
contract so I use some combination of
tools so it has to be completely
optional to to allow that to happen and
another one of my goals was that I want
to run on the the latest version of the
closure compiler and not have to fork it
so surprised there's an existing project
with almost all of these goals for
another another language called type
racket and type racket is a sister
language of a racket and racket if you
don't already know is an implementation
of scheme and type racket supports many
racket idioms and it provides one of
this novel features is that it provides
safe interoperability between typed and
untyped code and this basically becomes
a bit tricky when we when we have
untyped code typed code calling untyped
code and we have a higher order function
being passed in and then if we get a
type error at runtime who do we blame so
there's there's a blame calculus that
basically covers all these cases and
there's an implementation of this
calculus in Nam Tae bracket so it's
probably the most interesting thing
about Todd racket and if you want to
learn more about that seat am Tobin hot
starts awesome PhD dissertation so type
closure type closure is an optional
static type system for closure it's a
mostly based on type racket and I've put
some closure specific extensions and
I've
mainly built this for two projects my
honors project for bachelor computer
science supervised by roland Davies and
there's a accompanying honors
dissertation which I've submitted for
marking and should be available at the
end of the month but there is a link in
the type closure to read me if you want
to read it the version I submitted and I
also made type closure a proposed type
pleasure as a google summer of code
project 2012 and i was mentored by david
jesse is in the back now and yeah thanks
david for mentoring me so this is the
the boxes and arrow referent
representation of what's going on in
type closure so on the Left we have some
some code coming in so this is just raw
forms lists and vectors that represent
function implications so we're passing
this into the closure compiler which is
the the ugly Java compiler that Chris
alluded to so that one particular phase
of the the compiler is the analysis
phase and usually you pass code into the
when you when you perform compilation it
goes to the through the analyzer and
then you use the analysis results to
emit java bytecode so type closure takes
takes the result of analysis before a
mission which is an AST of java objects
and then I pass it through my little
analyzed library which basically gives
me a closure script like a nested map
representation of the AST and then type
closure performs type checking on that
AST and the result is a st with some
extra static type information i'm not
sure how useful that is but yeah
hopefully there's some more boxes that
go off to the right in the future so
type pleasure is just a just a library
it's on closures and as this github URL
so it you just put it in lining in and
you just start importing some bars and
that's that's basically it doesn't get
much more complicated than that so there
are two main operations to run the type
checker the
one that you use the most would be other
check NS and that that would perform
type checking on a specific name space
and the workflow would be you open up a
ripple in a namespace and you you would
do your type annotations and your
regular over the top of your untyped
code then you'd run check NS and it will
check your namespace so there's also
another form called the CF check form
and that's pretty handy for raffle
development you can pass it a form and
it performs static type checking or you
can give it a form and a static type so
what do we need to annotate to get type
pleasure to work so there it the two
usual rules with the things that use
local type inference which which type
closure does so the first rule is that
we need to annotate all global VARs that
are referenced or defined in the type
namespace so when we come across a death
or a Defen in type namespace we have to
already know an expected type and also
function parameter types must be
annotated and they're never inferred so
if you don't annotate the the type for a
function parameter it's just defaulted
as any which is the top type it's kind
of like object in Java but it's slightly
different to object in type closure and
we'll see that later on and many other
positions can be inferred notably local
bindings so to annotate of are you just
use this and function and you yeah might
as well just bring up a ripple actually
so I'll show you what happens if you try
and check a definition that doesn't
already have a an expected type we get
this lovely untied far reference so it's
it's saying I haven't found it I haven't
found a type associated with this bar so
we can annotate it and say okay I want
my my function to be a function that's a
number to a number and then when type
closure checks this definition it uses
that expected type
and this is that basically what code in
type closure looks like it's just normal
code in the black there and this is some
old core logic stuff that I found might
not be in core logic anymore but
basically the thing to take ways that
the bits in blue are the type
annotations and you haven't really had
to change anything in in the black but
of course that you're going to have to
annotate some parts but this is one
example of what it might look like in a
type namespace so the other important
thing to annotate is these functions so
you have two two main ways to annotate
functions so you can annotate a complete
function type by using an form and this
is useful for type checking closures
anonymous function syntax and forgiving
complete function types that have their
both the the range and the UM that sorry
the parameters and the result type and
we can also infer the result in using
the FN arrow f an arrow macro and that
basically allows us to just give the
types of parameters and the result type
is inferred so we can check a anonymous
function so say one that takes a single
argument and just adds one to it and we
can say ok we expect this to be it again
a boring number two number and I should
just note that this number is is the
java.lang number and its its its scope
that way because that's how closures
scopes the you have java.lang star is
imported so yeah we reuse the the
imports that that the current namespace
can see and I've actually got a bunch of
imports here as well the closure Lang
symbol and all that so this is in scope
when I when I write my types so let's
just run this so yeah it'll there's also
a shorthand for rapid development you
can also give the expected type as the
second argument to see if and also the
the the function shorthand we can just
say we've got a function with one
argument which is a number and then
infer the result type as there's extra
information here but this is the main
bit here it's a function with a number
to a number and yet all the usual stuff
is supported with the FN arrow but I
recommend using an form or almost always
except for when you have functions that
are so short that you'd probably use the
anonymous function syntax but if you are
then you need and form anyway so yeah
it's it's just that very specific cases
so type closure supports Union and
intersection types and particularly we
have an onion on tagged union type and a
union type is a it's a it's it's a type
with a set of functions and an
expression is of that type if it is of
at least one of the members of that of
that Union and the the dual that is the
intersection type and if an expression
is of an intersection type it is of it
must be at least yeah it must be a
subtype to each one of its members so
i'll just show an example for that so if
we have a type 1 we can assign at the
union type either neil or number because
one is a number then that's a valid
thing to do we can also say one is the
intersection of a long and a number
because it's both of those things but
yeah because one is a java.lang long but
if we say if it's a java.lang.integer
then we get a type error because it's
it's not a java.lang.integer even though
it is another
so this is some code I've taken from
algo monads and it's for those
interested is the M bind of the maybe
mon ad and it's basically an interesting
case of using unions and function types
so it takes it's a function that takes
two arguments if you see in the black
code there and the the type of the first
argument is it's either nil or it's an
ex and the X here is 0 it's a
universally quantified a type variable
which means that we read that all X Y as
for all types x and y then this so we've
got a MV is either a union of sorry it's
a union of X or nil and then f is a
higher-order function so we write that X
X actually takes the sorry F takes the X
and returns a union of Neil and wire
then the return type corresponds to the
the body so we can return either Neil or
why so we can abbreviate type types by
defining type aliases and we can also
parameter eyes our type aliases by by
using type functions which are basically
functions of the type level and for
example we have this any integer alias
which is included in a typed closure and
this is basically representing the type
that the types that would return true
for the closure core integer ? predicate
in enclosure JVM so java.lang.integer
long begin begins just short by it so
it's just an abbreviation and you'd
write any integer so a bit of an ad-hoc
hockey option type but it basically
models the way that that closure uses
the option type is is using this this
type function here so
this type function it takes an X and
then returns the union of Neil and X so
if we call option with any integer then
it's just like a function call but
except X is now a tight so any integer
is passed as X and then X is
instantiated as any its jaw so these two
types are equivalent yep so the bit more
about Universal quantification I think
I've covered everything actually but
there's a the type for some it it was
pretty similar to the one we saw before
parameterize ago that too two types and
we can very often infer what these type
type parameters are but if we some
reason we can't infer it we use the inst
form to manually instantiate a
polymorphic type so we can just check
the types that we have already just by
um by looking up with with CF and here's
a badly formatted type signature for
some and we can if you just notice that
it said it's got a its universally
quantified at the moment but we can pass
this to inst just to choose them short
types we can instantiate it and all the
x's are replaced with ents and all the
wires are replaced with the bullion's
but usually you don't we don't have to
do this and this is inferred using local
type inference so type close your users
ordered function ordered intersection
types and this is it type type bracket
uses this and basically allows us to to
specify multiple era tees and multiple
combinations of parameter and return
types in a single function type and the
way it works is when you check a
definition with a function type each
each arity must must type check for that
definition and when you invoke a
function that has a an ordered in
section function type it kind of works
like a pattern match so if you invoke a
function and you know the types of the
parameters you're passing you just check
each one of the the era T's against
against the parameter types you're
giving it and the first one takes
precedence over the following ones so
this actually becomes crucial for typing
things like the sequence abstraction
like first so first has three cases with
the actual semantics of first time if we
pass Niels our first we get Neil if we
pass an empty collection to first we get
Neil and if we passed a non-empty
collection we get the element the first
element so the first case of this
function section type handles the case
where we either parsi a Neil or ad or an
empty collection so if we read it from
the left of the the red red box we have
either a union or that is we have a
union that is new or it's an
intersection of a sequel X and exact
count 0 so exact count 0 is the typhus
the sequences that are empty and if we
match this we can safely say it's always
going to return new and Neil is the the
type for new in in type closure and the
second second arity says if we have a
type that that is both a sequel X and is
a count range one or is has account
greater than one then we always get the
the type that C cabool is parametrized
by and usually with a function
intersection type you'd have your most
general type at the bottom so it's kind
of a catch-all case so this this is the
union of Neil and sequel X is more
general than the other ones and it
describes all the possible ways to use
first and also the the the result type
is the most general
those the union of Neil an axe so we
have an inference strategy called
occurrence typing which is developed for
a type racket and one of the key things
about recurrence typing is that you can
add extra propositions to results of the
result types of functions and there are
two you can add two propositions in
particular you have the then proposition
and that is it is used if the result of
the test sorry if the if the result of
the expression that you get back is true
and the ls proposition is used if the
result of the expression is false I'll
just give an example for actually first
his is the sick type and seek uses
occurrence typing too I to convey the
the length of a sequence so we know that
if if we get if we get a true value from
seek we know that its parameter is of
count range one or it has has one or
more account and if we if we get a
negative if we get a false value from
calling seek we know that either so the
way to read these propositions is that
there is is a positive proposition so
and then the the the the number of the
parameter is on the right so we say
either the zeroeth argument is new or
it's it's an exact count of 0 so or it's
empty so these two functions actually
work quite well in harmony in type
closure in the way you'd expect so let's
make it local winding a and just to sign
it that the vector with just one in it
let's give it a less general type so
type closure can recover what type it
originally was so let's just say it's a
sequel of number so if we if we test on
seek of a we should know that if we go
down the then branch it's of
one or more otherwise it's empty right
so so let's say I just I just want to
return some number so let's save if
we're going down the then branch it's
going to be one otherwise let's return 0
and let's say the expect to type is a
number so this type checks but we can we
can look at what types are actually in
third for for each branch by using print
end so pretend takes a debug string and
then just print stuff out to the
standard output and let's do it for both
both branches so printed some reason
prince everything twice which I have a
bit around to fixing but yeah and when I
was doing this I found a bug so I'll
just explain so we're down the then
branch let's just get a little more when
we're down then the then branch we know
that a is going to be non non empty so
the the type for a down the then branch
is actually the intersection of sequel
number and count range 1 so that we've
actually got a more accurate type here
but the bug I was talking about is that
down the else branch we haven't actually
updated the type but we have a
proposition environment and we've added
these these propositions here here
should look somewhat familiar from from
the else of seek so except for saying
the zeroeth argument we've actually
instantiate adil so we have the two
propositions that a is nil and a is is
empty so yeah at right now I'm not
updating the type so so the main thing
is that with pre and where you can do
you some static debugging and just check
out the types and propositions that are
currently in scope
so type pleasure uses some of the theory
from type racket to type put to express
types about variable aritee functions
and there are two main kinds of well I
guess keyword parameters of the ugly one
but the two nice and cons are uniform
variable aritee and non-uniform variable
arity so uniform variable aritee is
where you have a rest rest parameter
that can be expressed with just just
some type like say plus and minus is
just any number of any number of numbers
but a non-uniform variable aritee has a
has a non-trivial relationship between
its arguments so functions like map and
swap bang have non-trivial relationship
so with map for example as as the rest
parameters grow to the right that our
first argument to map has to match match
the number of rest parameters by the
number of parameters you have in your
first argument so we can express this
with a theory called variable aritee
polymorphism but the two types ferd
using just the normal uniform variable
aritee we have closure cord divide here
and the way we express it is a divide
must take at least one argument so we
say okay we've got a number but we've
also got a number star and this any
number of numbers zero or more and and
then we return a number and constantly
takes takes some type x and then returns
a type it returns a function that takes
any number of wires and then returns an
X so there's the star again so i'm not
going to completely explain how this
works but the gist of the type for map
is that we have a dotted type variable
that scoped with the the dots so b is in
scope as a dotted type variable and that
that means that we
and put it to the right of dots and the
dots can only only appear to the left of
an arrow immediately to the left so
there are two sides to the dots that on
the right we have we have the bound in
blue and on the left we have the the pre
type on in red and the subtle see here
is that the B is actually in scope as a
regular type variable in the red but
don't worry about that the cool thing is
that you can do something like this so
we're mapping over these two collections
and this is just untyped at the moment
but we say we just want to get the first
argument and just return it so we'd
let's allocate some types
so the cool thing is we've inferred a
pretty accurate type for that and we
also haven't needed to redundantly give
the type for map there's just one type
for map and that expresses all the
possible ways of using map yes this is a
research-based Steve Strickland and for
lesen Sam tahajjud at Northeastern
University really cool stuff so we can
express maps with known keyword keys as
heterogeneous map types and that the the
main thing to know about these types at
the moment is that they only record the
presence of keyword keys but not their
absence so this buys us Asajj associated
keys a dis oh Sh get but not merge
because as we merge say we're merging
three maps the maps on the right if we
don't know that keys don't exist then
they could overwrite keys though that we
want to be certain types so that this
this theory gets pretty complicated but
o camel is just a treasure trove for
this and I've managed to avoid any of
the complications my supervisor is at
Oak Amal not so he's given me a whole
big list of things to read so I'll be
busy next year but we could here's a
type for the the reflection interface
for foreclosure closure has the closure
reflect namespace and we have this
closure reflect / type reflect function
and it takes a class and then returns a
map with three keys these flags bases
and members and yet we can we can define
an alias that that represents this map
and then we the actual type for the type
reflect is right there but the things
to note is that I haven't got around to
adding keyword parameters so it's just
any star but it's interesting to note
that I have heterogeneous map types
which is probably enough to to implement
keyword parameters so I'll be thinking
about how to implement that in the next
few months but hopefully won't be too
hard so let's just show you how this
works so let's reflect on the the object
class so the type we get back is a is a
reflect map and we saw the type for that
over here so what we can do is we can we
can look it up and we've got a the type
that we expect so what we've got get
let's get there was one really cool
example actually just give me a second
let's find it
haha
yeah this is cool right so we can so
let's get all the members that are
methods so we can define it a sorry a
predicate called method ? and using this
this type here it basically gives you
the propositions that if this returns
true then we know that that the first
argument is a method if it returns false
then we know that it's not a method and
then we can give this give this class
methods function that takes a
reflect map and then returns all the the
methods so the interesting thing here is
that we've d structured the RS which is
the reflect map we've taken the members
then we've filtered over the members
testing if it's an instance of method
then we've given it a set and then we
get this extremely amazingly accurate
type yeah so this is all all the
currents typing with a bit of
heterogeneous maps and yeah I think that
is pretty awesome that's one of the best
use cases for occurrence typing just did
the idea that you can recover types in
this in this filter is is pretty awesome
yep so we can give types to data types
and protocols and this is I'm not sure
the best way to do this at the moment
but basically with protocols you can
annotate each method even the first
argument as you'd like is that there are
problems between it when you but you
want some sort of type inheritance
between protocols sometimes because you
just you you need to know some extra
information so that's kind of a problem
I need to look at as well I won't
elaborate on that at the moment but say
if we have a data type closure reflect
field we can annotate expected data
types types for data types and other
namespaces using the and data type form
and this also works in data types in
your own namespace but the difference is
that if it's in your own namespace then
it's going to be type checked but the
definition will be type checked but if
if it's not then the definition won't be
so oh yeah so close reflect field has
four fields has the name type declaring
class and flags and we've given the the
types for the h of the field and type
closure allows us to perform type
checking on constructors just the raw
form or the the arrow form just thinking
I don't think the map arrow form is
supported at the moment but actually the
records don't actually aren't supported
at the moment actually it fuel is a
record but it's also a data type so we
can get away with with looking up the
field of of this I chose the wrong name
for field everything is field field
field
oh man but anyway we've got the the the
field name FLD name death there is a
simple because we've we've looked it up
and type closure can infer that knowing
that FLD is a field and we've looked up
the field so this this is one of my
favorite bits of type closure the Java
interoperability so we utilize Java
static image addicts Java static type
information when we interact with Java
and that probably the most interesting
part is that Neil is separated as a
static type from null so in Java when
you have a reference type the compiler
thinks great it could be null at any
point and you're on your own make sure
you just don't do it wrong good luck but
type closure tries to go a little bit
further and and separates nil and
reference types and this all works
pretty nicely with with the currents
typing which is actually the crucial
crucial part and say we have a
java.io.file and we we we run we
instantiate a new instance of it with
the name a so a constructor just just
normal Java constructors don't ever
return null that's just one of the
guarantees that Java gives you and type
closure recognizes this so by default or
just all the time constructors I never
know so you just have to say F is a file
and type closure agrees with you sure so
by default method in vacations aren't
nullable and this is because type
closure takes the most conservative
approach and just assumes that all
methods can return null so this is
actually semantically correct for the
get parent method
of F of file because if we don't if we
haven't defined a parent then it returns
null if we have then it returns a string
so this is actually a decent type for
this but get name is it always returns
its name so it's always a string so it's
never null so what we need to do we need
to add it at an assumption to type
closures database of assumptions and we
use this dysfunction non Neil return and
it it takes a symbol representing a java
method and then so that the second
argument tune on your return is either
the keyword all for all era tease or
it's a set of integers the integers
correspond to the the arity that you're
talking about and then type closure
remembers ok if we're looking up the
java.io.file get name but for any arity
then we know that it's not going to
return nil and this is actually a just a
static assumption and that if it really
does return null then type closure isn't
really helping you and this is a good
motivation for adding a runtime check
for say a debug mode of closure and you
could added a null check around this get
name yeah just to make sure that null it
never gets never gets called in and
we've seen the this static debugging
with a print end and I've shown filter
sir
so this go back to our example here we
can also work out which propositions an
expression is going to add to the
environment if we if we go print filter
set I can remember how to use it debug
string so it takes a debug string and
end a form and it to to closure it's as
if you just passed that ck but to type
closure it'll it'll print out a debug
string here let's get rid of the Duke it
all right so here we are the the two
propositions that are that are going to
be so remember we're looking at this
expression here and we're asking which
propositions are attached to this that
expression and the answer is that we
have a filter set with the then
proposition of if it's true then a is
account range one and if it's false then
it's either nil or exact count 0 and we
can also another and form is very useful
for static debugging as well so say if
we was we weren't quite sure that first
was going to be a number here we would
add and form number and yeah may not
look like it but that did statically
typed check it's a bit too zoomed in to
see but there are actually parts where
closure isn't isn't quite it's a bit too
flexible to be the type pleasure to to
catch all miss users say it that's it
thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>