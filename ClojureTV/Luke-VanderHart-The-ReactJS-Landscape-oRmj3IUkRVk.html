<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Luke VanderHart - The ReactJS Landscape | Coder Coacher - Coaching Coders</title><meta content="Luke VanderHart - The ReactJS Landscape - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Luke VanderHart - The ReactJS Landscape</b></h2><h5 class="post__date">2015-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oRmj3IUkRVk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Luke van der hart I'm going
to be talking today about the react j/s
landscape so I'm sure a lot of you are
at least familiar with the name or act
right now I'm you're familiar with ohm
this is something that's got a lot of
attention recently and I believe well
deserved attention the purpose of this
talk is to talk to you about why it's
gotten attention why that attention is
well-deserved and what your options are
when you're using it from closure react
itself as a JavaScript library so
there's actually three closure script
libraries that wrap them in various ways
and they have very different
philosophies and opinions the goal of
this talk is to give a quick overview of
each to give you a flavor of what each
is about what the individual opinions of
each one is what some of the design
decisions behind them were and hopefully
give you the ammunition you need to
decide between these three libraries
when you're developing JavaScript you I
enclosure script I'm not going to
unfortunately have time to go in-depth
on how to use each of these it's just
not time for that in 40 minute talk but
the goal is to give you a flavor and to
talk about some of their similarities
and their differences so first we have
to ask the question what is react what
why are we why should we be interested
in this library what is it I'm an
according to its website it is a
JavaScript library for building user
interfaces well that sounds useful but
if you've been in the space at all you
know here are some other libraries for
building user interfaces that have
exactly the same description in fact
there's another painting that comes to
mind when I think about the JavaScript
landscape and it's this one I really
have no idea what's going on here at all
so a better question we can ask
ourselves is why react why should we
care about react what distinguishes it
from the crowd of all the other
libraries out there so this is a very
very terse but correct statement about
react react utilizes a virtual Dom to
performing Lee able immediate mode style
updates to user interfaces in a browser
environment well that's a mouthful
that's that was the shortest expression
of reacts value proposition that I could
come up with but definitely needs some
unpacking in plain English react lets
you write user interfaces as if you were
not working with something slow and
mutable it lets you pretend that you're
working with something fast and
functional which to me is a pretty big
win but let's unpack those two aspects
we mentioned before the virtual Dom and
immediate mode style rendering so what's
the difference between the DOM and the
virtual done well pretty much the the
virtual Dom is better faster stronger in
every way unshackled by the constraints
of reality that's actually not a bad
analogy every time you do something to
the real Dom you have to reach into the
browser and mutate this state which is
an expensive operation the browser's
doing a lot it's got a render it's got
to adhere to this massive spec and so
every time you update the Dom in the
browser you're doing a lot of work the
virtual Dom on the other hand is really
lightweight java objects you have no
constraints on how fast you can
manipulate the virtual Dom other than
the speed of your JavaScript engine and
JavaScript engines are getting really
fast so typically the virtual Dom is so
much faster than the regular Dom that if
we can work with it it's a big win also
immediate mode rendering so this is how
i learned a program thanks tor would
probably say this is why i am still
crippled as a programmer and can't
understand haskell but this is you know
this is how we learn to program you
actually specify all the your pixels and
then you just iterate over every pixel
on the screen and write the pixel that
you want to be there and there's a
certain elegance to this approach
because there's only one code path I
don't have to worry about what was there
before I don't worry about any kind of
transformation I just I have my screen I
have my data that i want to write and i
just stick it right to the screen i can
just regard the previous state this
makes my code vastly simpler you don't
have to worry about what you're
overriding you just have to write what
you want to write and so this is how
react works as well so this is the
fundamental model of reacts interaction
path you have your code your code
renders virtual Dom react handles the
reckon so
react has something called the component
model that gives some structure and
helps you arbitrate how your code
generates a virtual Dom then react has
this thing called reconciliation or
react to dom dipping we're in react
calculates the minimal set of dips to
take your virtual Dom and commit it to
the real Dom but it can do that in a
very very efficient way because if it
knows all the whole structure of the
virtual Dom and it knows the structure
of the real Dom it can make as few
changes as possible to reconcile and
bring the virtual Dom into alignment
with what you want that's quite powerful
and then of course from the real Dom you
get events right and your events
eventually call back into your code
which then has the option to rerender a
more virtual Dom which can be reconciled
and so on and so forth so this is this
is the react model but it's also going
to look pretty familiar as flux to those
of you who have looked into that and
flux is really more of a way of doing
things than it is a particular library
and these are both libraries from
Facebook by the way so what is the
virtual Dom well it's composed of react
elements which are element nodes they
mirror pretty much the normal Dom nodes
we think of you have dibs and paragraphs
and spans and all that good stuff in a
react component is a custom element know
that you write in the virtual Dom and
components are really what is central to
react when we think about the act of
writing a program in react what we're
really doing is we're defining
components the components are custom
elements you write the component
specification of the component class
instances of that component become react
elements they live in the virtual Dom
and react actually utilizes them when
it's generating the DOM and even to some
extent when it's doing Delta's with the
real real Dom it it utilizes the extra
information that you can give it in the
components to enable be a little bit
more intelligent about the way it
renders so if you're real Dom or your
virtual Dom looks something like this
you're sticking some components in there
you'll see you have the same actual
element nodes the actual structure that
will get
the real dom is the same but we stuck in
some components and what the components
do is they give us control which they
give us an additional control over how
our component renders they give us
encapsulation so the general structure
of an component and I realize I'm going
over this very very quickly it on time
to be able to use it just from this talk
this should hopefully give you an idea
is a component has properties which are
the definition of the component they're
what make it what it is they are set by
whatever built it I'm set by that
construction time typically that specify
how this component should look and
should be and should feel components
also have private state that they can
update themselves and typically state is
only updated from within the component
itself only the member functions of the
component so to speak would update the
state and then we also have a few
different functions we care about render
renders the process of generating
virtual Dom underneath this component so
components are responsible for managing
their own children typically so this is
great for providing encapsulation if I
say I want a blog post on my screen then
I can just put in use this blog post
component and I don't have to worry at
that point what the children of that are
the component is responsible for
managing its own children and that's
built using the render function the
other function we care about is should
component update should component update
is pretty important it gets even more
important as we'll see because it's it
looks at properties it looks at state it
looks at any changes to the properties
or steak and it calculates whether we
even need to do anything so this is a
means of getting a lot of efficiency
because if nothing's changed then not we
don't need to re-render the DOM and we
can actually just ignore that whole
subtree of the Dom underneath this
component which gives us a lot of
efficiency there's also lifecycle hooks
I'm not going to talk too much about
those in this presentation but they're
just ways of saying Oh after we render
do this before we render do that before
we reconcile the Dom do this and that
etc now one note i will make because
this is kind of confusing terminology in
the react docs react component render is
the process of generating a virtual Dom
on the top level render method which
takes a react element and a Dom
container is the process of applying the
virtual Dom to the real Dom so as our
tree uses the word render they mean
completely different things one is
generate the virtual Dom the other is
applied the virtual Dom to the real Dom
so I just want to make a note keep those
two things separate so why do we care
about react Jeff's enclosure script that
was a whirlwind overview of some of the
quick benefits of react well we care
about it because they just go together
really well there are other things that
go together really well in this case
what goes together really well is
immutable objects and should component
update this is what let's react from
closer script a lot of times be even
faster than react from JavaScript
because in JavaScript if you want to
test of two objects are equal you have
to do a deep walk if you object to test
if it's the same because somebody may
mutated a little leaf note at any point
the immutable objects you can just check
identity or check a quality and closer
script has very good support for faster
quality checks on immutable objects and
so we can very very quickly eliminate
vast Suede's of our virtual Dom from
needing to even calculate the virtual
Dom or needing to render it and this
gets us a lot of efficiency that's one
reason that closure script to react go
very well together the second reason is
a functional style functional style
programming so reacts enables a view of
the world that goes something like this
the view is a function of the data and
this is the the future that is closest
to my heart if you really only remember
one slide from this presentation or one
statement this is the biggest value
proposition to me so programming in a
function to program it in a functional
way into using react to do so is it lets
you think about the world this way and
we're going to see that more as we
explore some of these other libraries so
next we're going to talk about the three
libraries that are available wrapping
react foreclosure script there is oh we
know about own there is reagent which is
quite nice i've been using a little bit
more recently and then there is
quiescent which i actually wrote i'll
talk about some of my motivations for
doing that and how it differs from the
other two but first i want to show you
an example program that i wrote that
actually demonstrates all three of these
so give me a second to flip over alright
so this is a game tic-tac-toe but I was
doing tech talk shows an example and it
turned out it's pretty boring so instead
I was I actually went under Wikipedia to
look at the rules smells like is there
any way to make it more interesting and
it turns out there is a quantum
tic-tac-toe so instead of just playing
in one square you create a superposition
of plays and it's formally equivalent to
play multiple games of tic-tac-toe at
once each player has to create an
entanglement between two squares and you
just proceed playing like that oops
until you create a cycle of
entanglements and then you have to
collapse the superposition which forces
a classical interpretation of the game
so you can read the rules I'm wikipedia
it's it's kind of cool it's very
complicated to play it's hard to wrap
your head around but it's fun and
especially if you're playing with any
physicists it was actually first
published in a physics journal as a
teaching tool and there's a number of
features of actual quantum mechanics
that it demonstrates quite well so it
actually might help you get a little bit
more of an intuitive understanding of
how quantum superposition and collapse
works so go check it out the reason I
mention it here is that there is a
repository on github down there at the
bottom I just made it public that has
this game written in it's got one back
end and then it's got a front and
written in every single one of the
libraries we're talking about today so
some good examples and that's where my
examples are taken from so anyway
continuing on with that the code
snippets we're going to see will come
from from that example program
so first a couple disclaimers talking
about this I'm very biased I have strong
enough opinions that I actually put a
lot of work in and wrote my own library
on this stuff so I'm going to talk about
the other two I'm going to try to do
them justice I do have a lot of respect
for them but I do have certain opinions
that can't help but leaking through so
just keep in mind i am the author of
quiescent and i'm going to i'm not going
to back down from being in that place
i'm also going to compare these
libraries based on emphasis not based on
capability a lot of these libraries are
really flexible all of them have
shortcuts that allow you to do things
that they don't support as part of their
normal workflow so i'm not gonna like if
i say like oh wants to do things this
way well you know there's give me
somebody say no you can actually use
this function in this function then
implement that protocol and then you can
make it work that way sure i'm going to
talk about what the libraries emphasize
kind of what we're the the path that
they lead you down as opposed to you
know just the sheer amount of problems
that they can do the other disclaimers
that things move really fast if you
follow you know the library authors on
twitter you'll see that there's new
versions of this stuff coming out all
the time a lot of women say about omen
for example is probably obsolete already
but this was all accurate as of two
weeks ago when i was writing this
presentation so you know keep that in
mind so we're going to ask a number of
questions about each of these libraries
going to ask what opinions does the
library have and we're going to talk
specifically about application state
where it is the state live and how is it
updated to me that's one of the most
fascinating aspects of these libraries
and one of the big discriminating
features that we really want to talk
about and then of course how do you
engage with library what are the API is
what does it actually feel like so the
first one we're going to talk about is
ohm ohm really was responsible for
bringing react to the public
consciousness even even react itself
owes a lot of its current popularity 20
min some of the evangelism that people
were able to do around that I'm
particularly David Nolan and ohm is
really about giving you the full power
of react so there's a number of opinions
the dome has on you want to stay pretty
close to reiax component model they like
the component
you want to operate in that way you want
to define components which are kind of
like objects you want the full power of
react you don't want to eliminate
anything that react gives you and you
want to expose that all but you do want
to work with the mutable data is a key
tenet of them as well and we do want to
get the benefits the performance and the
conceptual functional programming
benefits of working with immutable data
and also if you've watched David's talks
we do want the good parts of
object-oriented programming so um has a
lot of features that are geared towards
giving you things like encapsulation
modularity reuse writing components that
can be reused in a variety of different
contexts this is Ohm's goals so States
curses curses are strange beasts they're
fun cursors are how oh man is its
application state they have an
underlying atom so enclosure terminology
they are identity types they arbitrate
updates the application state whenever
you want to update your application
state you do so through the cursor using
the transact function actually they
provide local access to the application
state value for encapsulation so you can
update the state in a localized way
without knowing what your broader
context is and this gives you
encapsulation lets you write components
they don't have to know where they are
from the top level and cursors also have
the interesting property that sometimes
they can burn he behaved as pure values
you can use them just like you would a
closure map or a vector if you're in a
render context they actually behave just
like values you can still transact to
them but you can also do things like a
social to them or call get on them just
like you would any other closure map
another key feature of omens so you've
got two kinds of state to think about
you've got your application state which
is your top-level cursor or cursors it's
kind of global to your application and
lives lives at the top level and drives
top-down rendering whenever the
application state changes of course it
forces a rear ender then you've also got
component state in component state is
directly maps to reiax concept of
component local state this is private
state
that is available to a component that
can update independently if you update a
component state that will trigger a rear
ender but it doesn't have anything to do
with the application state so it's for
local transient things that you don't
want to escape the context of an
individual component so using oh I'm not
going to take the time to explain this
code in great detail but this is kind of
what defining a component in home looks
like you write a function that reifies
any number of protocols the one protocol
you have to implement is i render or i
render state if it's a stateful
component and that's a it's a function
or it's a it's a method on your
component object which we refine here
that return some virtual Dom and then
you can build up some virtual Dom DOM
div is a function that builds up at
virtual Dom you can specify attributes
and then you can use on build to nest
other components so that I have another
component called board and I can build
so here I'm rendering out the game
rendering a bit of called play area run
your new board so this is kind of what
writing and um component looks like then
you get a set of render roots so this is
actually my main function and the way to
do it is you get an atom that is going
to become your route application state
wants you to use a single atom as your
route application state and you say
route and you give it the gate that a
component you give it the atom that is
your state and then you actually specify
a location in the real Dom that it binds
to and from then on updates happen
automatically if I update that game
state Adam it will update the screen
without me having to do anything else
this establishes a live reactive process
where it continually updates and then
what I want to update something so here
for example I have a little table cell
and if I want to click on it I can set
up a click handler and when i get the
click i can actually transact my game
cursor all updates 20 applications state
have to go through the cursor every
component gets a reference to the cursor
and i can simply transact to it
so I and then this function is actually
into my domain model for the quantum
tic-tac-toe game and it as in a good
functional game each game state is a
function of the previous game state
which means I can just call transact
which has similar semantics to close
your swap and invoke my play function on
that and off it goes so that's kind of
the really high level gist of omens a
lot more obviously there's you should
read the documentation or go look at
auxonne it to actually use it but
hopefully this gives you a little flavor
of it I would give a few cautions about
using gnome and things that we've seen
use it only for front-end rendering we
actually came on to a project one side
I'm trying to clean it up a little bit
and what we found is they used a classic
model view component architecture which
is great and they have their views
written in home components every view
object was a gnome component well so far
so good that that makes sense the
problems that their models were also own
components and their controllers were
also own components that's not really
what ohm is designed for the best way to
use ohm is to keep keep it as the view
layer only every component should
directly represent something on the
screen it should be an actual widget
that renders on the screen the it's
tempting is particularly if you come
from an object-oriented background like
I did when you're writing closure to the
minute you get something that looks like
an object and even if there are great
parts to the you know if you're using
the good parts of argument oriented
programming there's a great temptation
to start using it for everything again
and start structuring your application
that way and I believe that's a
temptation that should be resisted the
other thing is keep components simple
home exposes a lot of awesome
functionality there's lifecycle methods
there's component local state don't use
that stuff unless you have to every time
you do that it makes these objects more
complicated more stateful and before you
know it you've got a big object-oriented
system with a lot of really heavy
stateful objects that all talk directly
to each other that's going to be a mess
keep them light and simple using just to
render data out don't use state unless
you have to and you will avoid writing
code that looks
like that which it is possible to do a
gnome it's possible not to certainly but
that's that tends to be one of the
failure modes of writing an application
you know is to get something that looks
like that all right next slide we're
going to talk about reagent our reagent
is very cool I have been liking it more
the more I've used it and it's got some
really neat features that it's just very
clean and very clever in ways I really
appreciate so what are reagents opinions
well you want things to be clean and
easy when I say easy here I don't mean
it disparagingly as some people in
conclusion world say well that's easy
not simple no this is easy in the good
way it's easy to use and it's not
incredibly complicated either it's or
it's not complected either and you still
want the hard thing to be possible but
within this simpler paradigm so it's
actually a way of thinking about how can
we get the same capability that react
gives but simplify the API is a little
bit rather than kind of having one to
one with all the features of react like
ohm does we were going to back off and
say well what are some simplifying
abstractions we can make so the key part
of the key feature that reagent gives
you is special adams reagent defines its
own adam type that you use throughout
and this is where the magic comes in i
got to say i love reagents name because
not only in modern chemistry is it
something that facilitates a reaction
even though we're talking about reactive
programming and react that's clever but
in medieval alchemy reagent was
something to help you transmute one
element to another element one type of
atom to another type of atom and it
doesn't need use a different kind of
atom so I don't know I am appreciative
of that naming effort so reactive atoms
are what region gives you they have the
same API is a standard Adam the
difference is that they track
dereferences whenever you dereference a
reactive Adam it does the magic it
establishes a link across time rather
than do referencing being a one time
event and now establishes
dependency and said the code that i just
rendered by directing that adam now has
a causal dependency on that so if that
Adam ever changes that means that I need
to go reup date this component as well
so if you do reference in Adam ones
while you're rendering excuse me then in
the future updates to the atom will
automatically cause a rear ender of that
component so the dereference the act of
dereferencing establishes a reactive
link which is kind of cool so it gives
you structures like this so in ohm and
as we'll see in quiescent your
application typically looks like this
you've got one atom that's your main
application state and then you have a
bunch of components that I'll build from
each other and the first one gets the
value of the atom and then they all
drive kind of drive top-down building
but reagent lets you structure your
application like this if you want to
wear this component depends on these two
atoms and this component depends on that
item and this component depends on that
Adam and so we've kind of unified the
concepts of global application state and
local component state just based on how
many people have references to the atom
if you have an atom know only this
component uses well that item is
effectively that local component state
and if you have an atom that kind of
drives the rendering from the top down
then that Adam acts more like a global
application state which is pretty cool
it's it uses the same idiom for multiple
concerns which I do appreciate and it
does end up simplify and code
substantially so what does it look like
to use reagent well you define your your
application state as an atom again it's
a reagent Adam it's not a closure Adam
and then you can write your components
as render functions now you'll notice
this is very very lightweight compared
to what we saw with ohm and that's
because reagent does a lot for you it
implicitly creates components and it
uses a hiccup style markup syntax
vectors with key words that represent
the Dom nodes so that all you have to do
is
right render functions and then for
example if I return a nested component
reagent automatically looks at that says
well that's that's a function so I'm
going to assume it's the render function
of a component and behind the scenes it
actually creates the react component for
you so you aren't working with the
reacts component model directly instead
you just write these functions and it
feels more like writing a functional
program and then anywhere you want you
can do reference a reactive atom which
means that whenever that changes it'll
rear-ender this component on the screen
which is kind of cool and it's similar
to ohm you set up a render route you
render you got to give it a little
fragment of markup so this is actually
mark up here it's a div or sorry it's a
um it renders a single component I have
a component called screen and then it
puts it on this you give it an actual
real Dom element to anchor to and again
this render sets up a dynamic process
such that it renders that component
you'll notice I don't actually care
about my application state here the
components do you reference it
themselves but this sets up the
reactivity so whenever any of those my
reactive atoms anywhere in that render
process change it will force an update
of that component and of all the
components underneath so pretty elegant
pretty nice i encourage you to go take a
closer look at it and at its
documentation some cautions about
reagent don't use too many atoms this
feature of reactivity is really nice but
if you're not careful what you might end
up doing is writing a program that
effectively has a large number of global
stateful variables which each atom
really is right so this is a powerful
feature but use it judiciously I would
recommend either use one or two as your
top-level application complication state
holders and then render top down and
just pull out values from that or have
an atom that is scoped to a single
component a single instance of a
component even and use that as the state
holder for that component so use it to
emulate components State don't have a
bunch of top-level global things that
you're dereferencing all over the place
willy-nilly
because that's going to lead to a more
messy program and one that has the same
pitfalls that we're all aware of in
programs that have a lot of stateful
places closure like state localize your
state into as few places as possible and
that definitely holds true here have as
few atoms is you can get by with the
other caution just don't dear f your
atoms in every single component so this
one's a little bit trickier to
understand but if I have a top-level
application State Adam it's possible to
dear f that in every component in my
application but that's not actually
necessary what you can do is direct that
in your top-level component and then
pass the values from that on to the
children and that's actually much much
more efficient because that means that
the children will only render when they
need to remember each component has a
should component update based on the
values that it gets passed well if it's
dereferencing an atom and the atom
changes then every component has to
rerender every time the atom changes
whereas if we are careful and only
dereference the atom in the top-level
component and then pass values to our
child components because region
components are not forced to direction
Adam they can also just take values be
passed values to render then you're
going to get some more efficiency there
so that's just a caution don't don't do
ref more often than you have to I'm and
that's reagent I like it you should
definitely check it out there's been
some good experience reports I've seen
if people using that an extra to talk
about quiescent I got to get a drink
so quiescent is a library that I wrote
not because I thought the other
libraries were not good they are but
there are a number of opinions that are
a little bit different from the other
libraries um which is you like
functional value oriented programming
cursors and reactive atoms are all kind
of addressing the problem of how do we
hold state and Kristen saying well what
if we didn't worry about holding state
what if we just worried about
programming with values and you want to
do your own app state management you
don't want your rendering library to be
concerned with how you manage your state
maybe I want to use an atom but maybe I
don't want to use an atom well with the
other two options you're kind of forced
to use an atom because that's the idiom
that they use quiescent you can store
your state however you want Crescent has
also has an interesting opinion
component local state is bad we don't
want a bunch of state living in a bunch
of components all over the place this is
a controversial opinion to make certain
things granted a little harder to write
but it also means that our we're hearing
closer to the idiom is the program is is
the view as a function of the state all
rendering is top-down so when you render
a crescent application you have your
application state Yuri render that new
of you you have your state rerender
interview your components have no
activity that's happening automatically
there's no reactivity happening except
from that top level I want to apply my
view function to my state and get a new
view so that's why it's called quiescent
because it doesn't do anything
reactively nothing happens unless you
explicitly tell it to it doesn't give
you say it I it just doesn't unless you
work with values so interestingly it
occupies kind of a different place in
the whole system in omen reagent they
kind of manage this whole process of
having your application state and
getting the values the data out of your
state and then turning that into
components and then rendering that to
the Dom that whole process is handled
with quiescent it really only handles
the middle process the process of taking
your data and turn it into components
and then also gives you some tool
we're writing it to the dom but what it
does not do is know or care where these
values came from right you could create
the values every time you could storm an
immutable object you could storm in an
atom you could store them in a database
and request them from the server kneel
on every to request doesn't care it
gives me flexibility there and you know
we talked about the view being a
function of the data that's true of all
of these libraries but quiescent tries
to make out a little bit more explicit
this the this is the primary API of
quiescent the render function will see
that more this is actually exactly this
form take my widget my my component it's
a function of the data that because of
my view and then i can just render the
view to the screen so it's really trying
to make this the central idiom of it so
what is defining a component look like
we've got this macro it's a thin wrapper
around a function you can also write a
function to define component give it a
name give it some arguments and you have
a then similar to ohm you build up
virtual Dom components it's a little bit
different you just call child components
as functions you call their constructors
like a function you can pass it values
through you can pass closure maps as
attribute maps interesting thing about
Kristen is the the first value of that
you pass in to a component is the value
the immutable value upon which is
rendering is based any subsequent
arguments that you pass it will not use
that as a driver for whether the
component needs to rerender or not so
here we go and create a screen it's
built on a game this game is a value
it's just a standard closure map and
then it knows if it sees this if you
call screen again and you pass it
exactly the same game it just doesn't
need to re-render because that under the
hood is handled for you by react
comparing with should component update
to see oh my driving value doesn't need
to cause an update or it does if the
game Adam for example changes that will
not cause it to pre-render it's just
useful for passing
like communication channels or things
that are going to remain the same for
the lifetime of your app are useful for
additional things so again go read the
documentation for that we don't time to
talk about it incredible detail here
here's what rendering looks like now
interestingly you'll notice the Crescent
render function doesn't establish a
persistent rendering process this is a
key difference it renders it once which
means if I want my application to render
more than once i have to call render
multiple times right so quiescent gives
you control over when you render and so
a common ATM and this is what I do and
take back toe is I didn't render on
every frame and rendering is actually
efficient enough if nothing's changed if
this is a totally reasonable thing to do
I'm calling quiescence render function
60 times a second and it just works
because react is smart enough to know
that if my game state which I'm dear
effing there hasn't actually changed
don't it goes no further it doesn't
actually rerender anything but I can
call the render function on as if I
don't care whether the whole application
had rendered and was already ready or
whether I have an empty Dom all I do is
I just call render I'm not component on
my state and it just makes it true and
that brings us back to the immediate
mode rendering I don't care what was
there before I just want to render my
data my value onto the screen and then
of course I recursively call it so i
render multiple times so you know what
are some costumes about korea said well
it's a little bit lower level than the
other libraries it doesn't give you as
much you have to write your own render
loop for one thing you have to come up
with a way of managing state so you got
to choose good higher level idioms you
got to build on top of it a little bit
more know what you're doing a little bit
more and you may have to abandon it at
some point in my abandoned I don't mean
stop using Crescent I mean use either
some other library or just go write some
raw react components it all of these
libraries by the way combine reasonably
well so you can have a whole tree of
creation components and then a little
react component that you write using
javascript api at the bottom level and
if sometimes necessary to do that with
crescent you can't do everything through
chris and crescent deliberately blocks
off certain features of react from you
in the name of functional purity
because react is not itself functionally
pure has stayed all over the place but
say you really really really need state
and you just can't forgive a way to do
it without using state you may have to
abandon this that is something i should
mention about react is about crescent
too is it does kind of have a philosophy
that if it matters to your application
at all it should be in the top level
state so even like you know the toggle
state of individual low-level component
that's not encapsulated that's actually
just part of your eyes state should just
live in the top-level application state
another library want to mention i don't
have time to show examples is Q I'm
basically just giving it a shout out all
the other things we saw lets you build
react components by calling functions
and composing virtual Dom as data or as
function calls q lets you use existing
HTML as a template in the style of in
live for those of you who have done that
so if you actually want to work with
designers or work with somebody actually
want to work with markup that looks like
markup to use the way to go it's usable
from Omri agent and quiescent it's
pretty easy to plug into all three of
those so give that a shot so what's next
we've talked about these three libraries
these are all good paths forward based
on your personality based on your goals
of the project I could see using any of
these three on a project depending on
what you like if you like
object-oriented programming you want to
keep the good parts of that you want
really rich power you think about ohm if
you want something that's just simple
you can get it going it's easy think
about reagent if you want hardcore
functional programming think about
quiescent but we have three good paths
forward and I actually kind of consider
the problem of taking values and
rendering them to the Dom to be sort of
a solved problem for the first time in
my life I actually enjoy browser
programming using one of these libraries
so that's that's pretty cool but we're
not done we have to worry about state
management and that's something that
some of these libraries address a little
bit but I still think we have a long way
to go because an application ultimately
you have some sort of persistent
say you have a database right and then
you have some sort of application state
your domain model your the state of the
application itself and then you have
your UI state and then of course you
need to render your UI state into the
DOM and so this part your UI state
rendering to the Dom that's what these
libraries address but they don't address
any of these upstream concerns and
there's a lot of question marks what are
these are they tuple stores are they
atoms are they flat data are they deeply
nested tree data what about the channels
between them are they chorusing channels
are they over a network if they're over
network are we replicating state using
some sort of replication technique or
are we using restful HTTP requests are
we using when we you know the process of
mapping back and forth between your
logical model and your UI model is that
something that you want to do using
functional programming or do you want to
do it using logic programming there's a
lot of cool things you can do with logic
programming rules CoreLogic that we
could use to map between these so I
don't have any good answers here this is
just something to think about going
forward and I would encourage all of you
to think about it I see this as the next
big problem that I would love to see
some good solutions and some good
libraries out there in the closure
script you I space two views in
combination with these other three
libraries that we have to build some
pretty effective patterns for building
user interfaces enclosure and closer
script and i think it's a it's a it's an
exciting prospect and there's a lot of
interesting territory to explore thank
you very much that's all I have</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>