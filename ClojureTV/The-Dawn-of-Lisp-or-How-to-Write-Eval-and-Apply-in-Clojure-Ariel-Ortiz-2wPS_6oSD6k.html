<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Dawn of Lisp, or How to Write Eval and Apply in Clojure - Ariel Ortiz | Coder Coacher - Coaching Coders</title><meta content="The Dawn of Lisp, or How to Write Eval and Apply in Clojure - Ariel Ortiz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The Dawn of Lisp, or How to Write Eval and Apply in Clojure - Ariel Ortiz</b></h2><h5 class="post__date">2017-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2wPS_6oSD6k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello my name is ray Lourdes you can
call me Ariel I work at tecnológico de
Monterrey the Monterrey tech back in
Mexico and today I'm gonna give a talk
title the dawn of list or how to write
eval and apply in closure ok let's start
talking a little bit about me
first of all I'm an educator you can see
in these photographs in the upper one
this is the university that I work at
we're located north of Mexico City and
the one beneath is a photo of myself and
my class programming language course
that I'm teaching the semester this is a
class in which I'm currently teaching
using closure and I'd like to say hello
to all my students that hopefully will
be looking at this video later on I'm a
language geek ok I really like
programming languages since I started
programming that's what I really enjoy
enjoyed doing best in my classes since I
started actually teaching I've taken
into account that I've think I've used
somewhere around 18 different high level
programming languages you know almost
three decades I've been teaching I
actually started using a little bit of
common lisp when I was an undergraduate
student but I sort of didn't get the
hang of it but it was until 1994 when I
actually went to a conference on using
scheme in education and I got the
opportunity to hear there to listen to
some talks by Daniel Friedman from
Indiana University by Robert Corky
Cartwright from Rice University and this
other guy called Ian fergenson
from a company called schemers Inc and
they really sold me the language
they really convinced me I sort of had
like a religious conversion at that
point and I started using scheme into my
classes that same year in 1994 I
discovered closure somewhere around 2009
I think it was probably in some forums
and read it I read about it I was using
a lot of Java at that time so it made a
lot of sense to start using Lisp
together with a java virtual machine so
that's why I started using closure in
2011 I incorporated closure into my
programming language course and I'm
being using it since so we're gonna talk
today basically about two things first
of all we're gonna give a very brief
introduction of the origins of les maybe
some of the details that I'll be
explaining are familiar to to many of
you and then we'll spend a little bit of
time the rest of today's talk explaining
how we proceeded to implement a lisp
interpreter using closure very much
modeled around one of the original
definitions of this language so it
starts with John McCarthy okay he was
working at MIT and he published in the
April issue of the communications of the
ACM in 1960 this paper called recursive
functions of symbolic expressions and
their computation by Machine part 1 John
McCarthy says that he planned to write a
second part but he actually never did it
okay here he explains actually what this
Lisp programming system is about how it
could be used to program recursive
functions at that time languages that
were available like Fortran usually did
not support recursion so this was a
novelty and basically what McCarthy
wanted to do was to incorporate some of
the idea that along so church
explain in this other book Alonzo Church
is an American mathematician that in
1941 published the calculate of lambda
conversion so basically he expressed
here how to represent or use functions
to do computations you might remember
that Alonzo Church worked also in a few
years before that with Alan Turing and
they got to the conclusion that the
Turing machines the universal Turing
machine were basically equivalent to the
way that he was proposing to use
functions okay but McCarthy actually
well basically discovered I wanted to
propose that it was much easier to think
in terms to think in terms of functions
or using functions instead of using the
Allah of the Turing machines which were
a little bit more complicated to use at
least in even in a conceptual level so
McCarthy actually carried out to take
his ideas and make them run in the IBM
704 so his plans were to actually have a
running compiler for this mainframe
computer remember at that time most
computers actually were ran using punch
cards so you would actually have
something like this not really sure if
this is real or if this is just a joke
okay
but notice here in the upper part of the
the the punch card it has a bunch of
closing parenthesis I mean in in current
systems putting more closing parenthesis
and required where typically produce a
syntax error in your code but I don't
know if this was valid in those systems
and alissa systems at the time so well
it says here you can tell the lisper the
Lisp programmers they have pockets full
of punch cards with closed parentheses
on them ok once again I'm not really
sure if this is a joke of this was
serious but even those at that time
first systems were programmed in Lisp
using punch cards ok Steve Russell
was also working at MIT I'm not too sure
if he was a student or he was working in
some other manner at MIT and he saw one
of the drafts written by McCarthy
explaining how Lisp should actually work
and he saw the formal definition and it
said well this could actually be
programmed in the computer and he took
it into account to actually develop and
program the first list system as an
interpreter basically McCarthy told him
that that was not the purpose of his
formal definition of the language but it
was an interesting exercise that he took
basic formal definition and converted
into a program and this is really what
what makes this definition
fairly interesting fairly neat so Steve
Russell you might remember him he was
one of the co-authors of space war which
was one of the first video games that
were were available you can see here in
in this photograph a terminal that was
actually running space war this I think
it was a PDP one running there so Steve
Russell also had a hand on implementing
this game and implementing the first
version of a lisp interpreter so
somewhere around 1962 this manual got
published by MIT written by John
McCarthy and some other people and the
interesting part of this programming
manual is that it had section section
1.6 that was titled a universal Lisp
function and basically explained here in
a formal notation how we could define
basically Lisp in terms of itself this
is actually about the bottom half of
page 13 of this manual and is if you
happen to be able to look at the details
you can see that this is not using s
expressions it's using something that is
called M expressions or meta expressions
that were basically like the ideal
notation that
John McCarthy wanted to use for his
language but for simplicity sake it was
later converted into s-expressions that
uses basically parentheses as we know in
in most Lisp dialects okay so you can
see here in the upper part I don't know
if you you're able to read it it says
eval quote this was the start up
function okay everything in theory
started from here and this one called
applying and this one called
eval okay so as you can see there are
two main functions over here apply in
eval there's some auxiliary functions
here okay but that basically was the
full definition of the language in
itself this is not necessarily meant to
represent the first implementation but
basically it gave in in formal notation
and give an idea it gave an idea of how
you could implement Lisp using the same
notation okay so this well this is
really what we're gonna be working with
it's really interesting to note that
Alan Kay who who was the author of who
is author of the small talk programming
language and later on 2003 he was the
winner of the ACM Turing Award he
basically had this to say about the
piece of code that we saw or the formal
definition that we saw just a moment ago
it said let's defined in terms of Lisp
this
these are Maxwell equations of software
I remember the first time that I
actually saw this quote about this
interview that Alan Kay had a few years
ago and when I read it I'd say wow that
must be something they found only I knew
what Maxwell equations were okay so I
checked those out in in Wikipedia and
this is a the image that you see the
equations that you see here yes I
discovered that they had to do something
with with physics these are a set of
partial differential equations that are
basically the foundation of a classical
optics and classical electromagnetism
quantum field theory and electric
circuits so I don't really understand
then I feel a little bit ashamed of this
because I'm an engineer by training and
I don't know if I slept over the in my
physics class when they explained this
but I don't remember actually ever
hearing about Maxwell equations so in
general what these equations say science
okay so basically it's a it's a big deal
even if we don't necessarily understand
it okay so let's quickly review how eval
and apply work in enclosure so we're
gonna be talking about these two
functions so it makes sense to actually
understand how they work
eval you send a piece of data okay in
this case a list okay if you see it the
list is actually quoted so it's not
evaluated this list can be produced
whatever way you want okay it's a
processed and a full piece of data in
closure and once you send it to eval
well it proceeds to evaluate it and it
gives you the corresponding result
interesting thing here is that this list
could have been created using cons or
any other operation and at the end you
just send the value and it works okay
this contrasts how eval works in other
languages if you used Ruby Python or
JavaScript all these languages also have
an eval function but they usually just
receive a string okay in the case of
Lisp and closure specifically you have
to send a full valid data structure okay
you can't send a string I mean you can't
send a string but evaluates just to that
string so that's not very interesting
and applying might look a little bit
similar okay
applies in its simplest form it takes
one two parameters the first one is the
function that we want to apply and then
it takes a list with the arguments that
we want to send to that function okay so
this also gives us for the apply form in
the ply function in enclosure is a
little bit more elaborate than this but
this is the simplest way that it can
actually work okay so it's an
alternative
of using the traditional way of calling
a function which is opening a
parenthesis and then specifying the
function that we want to call and then
the parameters in this case we have a
function that allows us to call a
function in certain contexts this can
come in handy okay before we go to see
the code of the interpreter let's just
mention how memory locations work in in
the 7:04 mainframe IBM mainframe
computer a register at that time really
meant a memory location okay and it's
basically what we would call a word
right now it was composed of 16 bits
okay 15 of those that were could be
referred to as a contents of the address
part of the register number and contents
of the decrement part of register number
notice here that the word register
refers to a memory location it's not
what we currently understand as a
register a part of the CPU okay where we
store information for very fast access
okay here when we're calling or we're
referring to registers it really means
memory memory location okay so we had 15
bits for the c8r the car and 15 bits for
the CDR okay
remember the address and the decrement
were not necessarily where there were
actually not registers okay there were
just a part of our words in memory and
we also had other three bits for the
prefix and tag that were used for some
other complicated operations to index
our arm memory stuff this is more or
less how this could have looked in in an
older system here we had a bunch of
memory locations each of these rows is a
memory cell we would call them now cons
cells because whenever you call
constants is what the function actually
returned okay so a single singly list
linked list like this one okay could
have been represented in memory
something like this you would actually
have a root binding here okay referring
that this list started in address
three so in a dress 103 here you have a
with in the car part of the console and
in the cooter you would actually have
the location where this continued so
this follows in a location 105 so here's
the location 105 and here you have a B
which is the one we're displaying here
and then we would continue in the cooter
of this location and 101 and finally
when we find a nil will be represented
with this diagonal line here this means
that the list was actually ended okay we
also had another list which we call the
free list the free list represented us
another list that was with all the
contained all the cells that we had
available okay so anytime that we
actually called comps the free list we
basically return what we had in front of
this list and we updated the reference
to free to the next element in that list
okay
here what you see in in grey these would
be actually cells that were no longer
accessible from our program so they
could be at some point recycled so the
original paper that McCarthy wrote said
that there was a reclamation cycle okay
and he later explained that he used a
term reclamation cycle because the term
of garbage collection although it was
already used at that time didn't seem so
like worthy of scientific articles so
they decided not to call it garbage
collection at that point okay but that's
how informally most people knew it okay
so when the free list actually gets
totally consumed okay we typically stop
the world at that point and in this
first system there was an algorithm
called mark-and-sweep that was actually
carried on which consisted basically in
in reviewing all the cells that we had
available in our memory and we had to
mark all of those that were directly or
indirectly accessible using
are available variables or bindings
local bindings or global bindings that
were still alive and we marked them or
they basically mark them changing the
sign of the word and once they did that
anything any cell that wasn't marked was
actually integrated into the free list
so that it could be used again from
whenever we actually called cons again
so this is how this looked more or less
okay it's worth mentioning there garbage
collection or the recycling process took
several seconds okay so at that point it
seemed like interesting to see that this
algorithm was taking place but it's
usually very very inefficient in
practical terms it took quite a long
time to actually execute so let's talk
now about the rules that we're gonna be
using to convert the Lisp 1.5
specification okay into closure so
basically I translated what you saw just
a moment ago the code that we saw or the
formal specification that we saw a
moment ago I translate into closure
following these specific guidelines
first of all I needed to convert all the
EM expressions into s expressions we'll
see that just in a moment okay I
maintain basically are all the
definitions that we had and trying to
make them as similar as possible to the
original so every time I called a
certain function I try to use the same
function or something very very similar
okay so basically try to do the most
faithful conversion that was possible
using closure the original
implementation uses dotted pairs
something that we don't have in closure
and can explain that in a moment so we
needed to take those away because we
don't have them in closure and also I
added a dollar prefix to all global
identifier x' to some constants and some
functions so that we can quickly
identify them as something that we're
doing
as part of the implementation strictly
speaking the dollar sign according to
the closure documentation this is only
used when you're referring to an
external java class that happens to be a
nested class okay so sort of using the
dollar sign in a way that is not
compatible to the way that closure says
that we should use it but it works I
hope not to break anything in the future
because of this decision okay and
finally I added some wide space to make
the code a little bit more legible so
the definition the formal definition
that we just saw a moment ago is very
very compact I took the liberty to make
this to add more space to make a little
bit easier to understand okay so we have
here M expressions and s expressions so
that you can see the difference so when
we call a function we use something like
this F then we open square bracket one
semicolon to semicolon 3 and then a
closing bracket this as an S expression
is a normal Lisp
way of expressing it so we would have F
one two and three we use spaces we don't
use comas although technically closure
does allow you to use comas because
they're basically cool into wide spaces
if we were referring to a conditional
okay here we have two clauses in our
conditional these are actually verified
from left to right we check the first
one if the expression that we have here
happens to be true we return whatever
follows hit this little arrow okay if
this expression happens to be false okay
we go and analyze the following close
another following Clause or whatever how
many clauses we have left in this
specific example here we have T which is
a special symbol that represents the
truth value so this is like an a default
or an else clause which if none of the
previous ones happened to hold true this
one will okay
and this is how it looks as an S
expression okay so we have the use of
cond and the clauses are included in
and parentheses and then we have the
condition and the resulting associated
value about dotted pairs here this is
something that you can do in in many
Lisp dialects you can do a cons of
something that well any piece of data
with something that happens to not be a
sequence or a list okay so what happens
here is that you get a dotted pair okay
which graphically you can imagine
something like this the car and the
cooter or the first or the rest happens
to be in this case a symbol you can't do
that in enclosure okay so whenever we do
accounts of two elements life the second
element happens to not be a list we
actually just place it as if it was the
second element of the list okay so this
is a provision so that our code works
well in closure okay so we have some
simple definitions in the code okay all
this code is available and at github
I'll give you the link at the end of the
talk so if you want to see in more
detail you will be able to so for
example in the case of the dollar T this
is something that represents true if we
check the the code here the definition
is varying straightforward
okay so dollar T represents true okay
and the same thing happens with the rest
of the definitions that we have here
this dollar F represents false this
dollar nil represents the empty list
this dollar cons is the provided or the
equivalent of standard cons operation
but this one can allow you to cons two
symbols together atom is a predicate it
returns true if the given argument is an
atom Adams it's worth mentioning here
don't have anything to do with the
closure reference type atom these are
very old traditional atoms basically
saying well anything that can't be
divided is an atom so symbols were Adams
also the empty list was considered
and Adam anything else was considered to
not be an Adam okay so this returns true
if it's an Adam if it's not returns
false equal EQ was used to compare two
symbols if they are the same it returns
true if they're not the same to
transpose and we had no okay notice that
I'm not ending these with question mark
even though they're predicates null
returns true if the argument is an empty
list false in other cases and once again
I I decided to use the same names as as
much as possible just with the dollar as
much as possible than the original
specification okay then we have car and
cooter these represent basically as we
saw the first in in a in a cons cell the
car represents the first part the cooter
the second part okay and we had actually
some combinations of these okay so
whenever you see for example this last
one this represents the car of the
cooter of the car of your argument okay
so a lot of scheme and Common Lisp users
really like this possibility of
combining car including just one
operation and they usually say that
that's why they do not like using first
end and rest as we do in enclosure I
personally like first and rest more I
think they're much easier to understand
but I'm keeping these names just because
I'm trying to be faithful to original
publication and if you look at any of
these for example car maps directly to
first ok cooter directly to to rest and
for example this last one I use the
composite closure function to do first
the car than the cooter then the car key
in the same order that we have here but
just remember these are actually applied
in the reverse order in which we read
them ok so instead of doing first the
car we do first this car we first do the
last one ok we have some more elaborate
definitions ok we have for example this
thing called cond this is my version of
cond and basically this is a macro
really
wasn't required but once again I did
this for the purpose of maintaining the
original syntax the cond enclosure
doesn't require and actually would be a
syntactic error to add these levels of
parentheses here but the traditional or
the standard definition in in list
unless 1.5 required actually to put each
clause in its own list okay so I'm using
this one to return to that original
syntax once again I know that this might
seem fairly ugly to too many and once
again I did this just to maintain it as
faithful as as possible and this is a
macro that just converts this into its
equivalent if so it actually works
fairly similar to standard cond in
enclosure but it requires that extra
group of parentheses just to maintain
the spirit of the original definition
okay then we have this thing called
perilous okay this creates a list of of
pairs so allow me to just demonstrate
how this would actually work so if we
have here perilous you would actually
send two lists here the first one would
be a list of symbols that represent
variable names and then the second would
represent a list of values any values
and it would actually reserved or was
receive excuse me third parameter that
actually represents an existing list of
of pairs that already exists okay so
this function as you can see pairs the
this symbol which is gonna represent
basically a variable to its value so it
goes with one the Y goes with two the Z
goes with three and the rest of the list
is basically the same thing that we send
over here okay so this is going to be
useful when we pair together the formal
parameters of a function with their
actual
parameters okay or though though
arguments then we have this other
function called a sock okay
this works to get an element from
association list we're going to be using
association lists a lot in a moment so
you use it like this you put a sock you
put what you're looking for and then
you're specifying a list containing
pairs like the list that we obtained in
the previous as a result of previous
function so let's say that you had an
association list like this okay and here
we're saying I want to look for the key
X okay in this association list and
hopefully we'll find it and it will
return the full pair including the key
and associated value okay if you try to
find a variable or a binding that does
not exist the result is actually
undefined explicitly what happens here
is that it produces a stack overflow
because it never assumes that we
actually can have an empty list at the
end okay so you shouldn't actually try
it without with a symbol that doesn't
exist in the Association list okay so
this in other words this works similar
to in spirit at least to a closure map
okay so we're just trying to get the
Associated key and n value and in a
group of pairs okay so that's what a
sock does the next function is called
f-con okay this is an evaluation of the
condition so this one works like this
okay you specify I've con then you send
here a list of clauses let's say that we
have two clauses here the clause can
have something like an expression like
this add some a and if that's the case
let's say that we return quote yes
that would be the first class second
clause would be let's say true and if
that's the case let's quote no okay so
this is a imagine that it's a cond
taking the Conda way so here we have the
first clause here we have the second
clause and we want to evaluate this in
certain context or environment okay and
the environment is just this association
list that we've been looking in just a
moment ago and we just need to indicate
what the values of the variables that
we're using are so we're using an a here
so let's say that a happens to be the
symbol X and we also need to define T T
has to be equal to true value okay so we
evaluate this and it says yes this means
that a this symbol X is an atom so it
returns quota yes but if this happened
to not be an atom for example if we put
this inside a list okay it now should
return us no okay so that I've gone
basically does implementation of their
evaluation of the different clauses of a
condition okay and we have this thing
called EV list which is a value eight
list and this one is going to be used
later on to evaluate the a list of
expressions so for example let's say
that we say I won't Adam a here as a
first expression and as an as second
expression cons of B and C okay so this
is a list of expressions that have not
been evaluated so far and I'm gonna
provide here an association list that
says a is equal to Adam X and B is equal
to Adam Y and C is equal to the list
WZ okay so we evaluate this and as you
can see adam of a because a is a symbol
excess return is true and cons of a see
if B is y and C is
WZ it actually returned a list with why
wnz okay so Eveleth allows us to take a
list of expressions and it will call our
eval function okay using whatever
Association lists with variables we
provided okay and they will one by one
evaluate this once again this is going
to be useful when we look at the
implementation of apply an eval because
in some moment we need to evaluate all
the arguments that are sent to specific
list okay
so let's proceed just to see now these
two functions apply in eval we're gonna
see them with a little bit more detail
so here if you look at the applying let
me show you first them the code okay
once again these are the the functions
that we saw in the formal definition a
few minutes ago okay so you can look at
this I'm gonna see Clause my Clause
basically because it's a little bit
complicated to understand at first the
code here so first part is gonna take
care of of saying if remember applied
takes first a function and then a list
with the arguments and then an
additional parameter here that
represents the the bindings association
list with the bindings out we want to
take into account so first thing we're
gonna check if fun is an atom if it is
we're gonna check if it's the car the
cooter the console the atom or equal and
if it's not an atom then we're gonna
check if it's a list containing a lambda
as a first element or a label we're
gonna see that label it's gonna be
useful to define recursive functions
okay so if we look at this quick link R
of this okay assuming that my my list of
parameters are this okay so here too to
implement car we just need to return
this element here which we obtained with
the car of the car of X okay some in a
similar way okay this is how we can
implement cooter and hope we can
implement cons okay here we call our own
implementation of cons with these two
values I'm using here the colors when I
say car
flex and I put something in the same
color here this is what in this specific
example that what we would actually be
getting okay and whatever we see there
in blue means that's the final results
okay then we have here Adam EQ and any
other symbol this is the way that they
actually get implemented once again
you'll have a chance to look at the code
if you want to or look with a little bit
more tranquility these slides also as
well the interesting part here happens
when you have a lambda expression okay
here when you find a lambda okay you
evaluate the body of the lambda and you
create a list of pairs taking the
parameters the formal parameters and X
which would be our list of arguments
okay so we bind these together and we
append them to our associate so
associative list that we had before okay
so that's how lambda gets translated and
specifically label okay label it was
actually introduced because we want to
have a recursive call so we want to make
use of the same function so we create
here what is a label and basically what
this does is that it extends our
association association list I'm sorry
the Association associative lists that
we have here okay
and we have the AE at the bottom okay
and we add a pair with the name of our
label and the body well or the Lambs in
this case that we're joining here
together
okay so we're adding basically that that
symbol that there that by binding to our
list of bindings or our association list
okay then we have here the
implementation of eval eval if you send
a variable it looks for that variable in
the Association list so this is where we
call a sock okay if you're implementing
quote this is very straightforward
remember here eval is gonna be taking
care or special form so basically takes
care of the lookup of variables about
quote and in this case we only get the
value that we care here without any
further evaluation and we also have here
the cond which just calls the other
function that we just defined a moment
ago the F com
okay the last part here done in eval is
when we call actually the second-to-last
part that we need to do here is when we
have the first element of e is a symbol
but it's not quote or cond
so here we delegate this to apply which
actually knows how to do that we get
that first symbol as the function that
we want to call we do the evaluation
here of the of the arguments and we send
the same associative list to apply ok
and now finally the last part that has
to do with eval here in this case we
know that e is is a list okay but its
first element is not a symbol so should
be something like a lambda or a label
well what we're gonna do here basically
is call apply with the car of E which is
the thing that we have in red it's a
lambda or a label and we call the EV
lists with the cooter of V which is what
we have here in in green okay and we do
the evaluation of those parameters and
we send that together with a so let's
we're almost out of time so let me just
do a few quick examples here so if we
want to check how eval works in it's
very simple way we would actually call
car for example here of a list L and
then specifying in the associate
associative list okay that L is a list
containing whatever symbols you want
okay and this has to be quoted as well
okay so Caravelle l being this is is a
okay no big surprise there if we try
let's say cooter mmm okay we get the
cooter of oh well okay let's see
something a little bit more complicated
let's say that we what we receive here
is is a lambda expression okay this
lambda expression is gonna take ex-cons
it to another list with X and with with
nil okay and what we're gonna do here is
send the corresponding list of bindings
and here we're gonna say that nil is the
empty list okay so that that sir our
bindings our list of bindings okay and
let's see if this works
oops I'm sorry I needed to I'm sorry I'm
missing lambda receives a parameter I'm
skipping that sorry so here we would
specify for example let's say quote of
of a okay so now it gives us a quote of
a was the value for the parameter X and
we just cons that a to the console value
of nil okay and let's do last example
because we already ran out of time let's
say that we now want to check how a
label works let's say that we want to
implement this function called map car
map car is actually like map the
ordinary map function that we know okay
but it was originally called map car and
here what we're gonna do is we're gonna
say this is a function okay that
receives two parameters a function and a
list okay and the only thing that we do
here in this lambda is define a
conditional where we're gonna check
first if the list is equal to nil the
list L is equal to nil and if it is we
return nil there's nothing else to do
here and otherwise okay put a true here
we're gonna calm
the result of calling F with a parameter
car of L okay and we sent here the
recursive call map car of same function
f but now with the cooter of L okay so
hopefully this should be an
implementation of map we need to specify
here the parameters that we want to use
let's say that we have a function called
OOP
and a list called LST okay so the only
thing that we need to do here is provide
the binding so dupe is gonna be
basically the same function that we had
just a moment ago
cons of ex cons of X and nil that's the
first binding second binding is the
value of list let's say that we have the
list a b c and d and the value of nil is
the empty list that we use and the last
buying that we need is true which needs
to be bound to true value and as you can
see this is the answer we applied the
function label to this okay ABC and D so
it dublicate seach of these elements
okay so that was a much more elaborate
example here okay so hopefully that
would give you a good idea of how this
actually works okay thank you very much
for your attention and if you want the
slides in the code you can check this
here
or use a QR code here thank you very
much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>