<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Michael Fogus - Zeder - Production Rule Systems in Clojure | Coder Coacher - Coaching Coders</title><meta content="Michael Fogus - Zeder - Production Rule Systems in Clojure - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Michael Fogus - Zeder - Production Rule Systems in Clojure</b></h2><h5 class="post__date">2013-12-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1E2CoObAaPQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so it's good to be back I missed I
missed the Kahn's last year and I've
regretted it for a year so it's nice to
see everyone again new faces and and old
faces see I want to talk about a
something I've been working on for a
while called Zeta it's a production rule
system and I'll talk about what that
means for you know as an introduction
but the agenda is I'm gonna go over some
polina preliminaries talk about
perspective talk about some complexity
and give an overview and then some
ranting and raving got I've got to add
that in there and I'm actually gonna
give a demo and then talk about what
what the future holds so first off I
have to say that I'm very disappointed
in the presentation so far and and with
with Bodil not speaking we're kind of
lacking in many ways and so I think I'd
try to make up for that in the beginning
here so here's a cat the wu-tang cat
here is a pony
thank you I picked the right one I hope
yes thank you
I'm not pony savvy but here's rich he
he's face palming some demotivational
images can look over that for a second
and here's a picture of Elvis with
President Nixon this is this is one of
my favorite pictures and and it sort of
brings to mind I like to talk start my
talks with telling by telling a co on
and I'll tell : with this in the
background and I think it'll be
appropriate so the master and the
acolyte were standing together and the
master said to the acolyte why do you
never ask me questions and the acolyte
said well my previous master I asked him
questions and he answered he had answers
for me about everything and he said well
really well What did he say
one day I asked him what is the
fundamental nature of Buddhism and his
aunt
he says masters well what was the answer
well the answer was ping ting comes for
fire and the master says well that's a
that's a very good answer
do you know what it means and he says
yes of course I think it means that in
ping ting is the god of fire and and
obviously if he would come for fire it
be nonsense so the fire is always within
him just like Gus Buddhism is always
within us and the master said I knew it
you didn't understand it at all he says
well what's wrong with it well would you
say instead the master says we'll ask me
he says what is the fundamental nature
of Buddhism and the master says ping tin
comes for fire and the student was
enlightened so with that in mind we can
move on to Alaska question what is this
this is a logo this is the closure logo
right you'd think so but it's not it's
not at all it's a lens for viewing
computation
so the the good kind of lens we're not
gonna talk about the other kinds of
lenses so let me give an example of how
this is true one day rich looked at
databases through his lens and he had a
good idea likewise I looked through the
lens at distributed simulation and also
had an idea and now hesitate to say that
it was a good idea but it was an idea
and it's the system called Patagonia and
Patagonia is something I put together
for my work and it really does try to
follow closer principles that Patagonia
was the topic of my other talk
submission and that's the one that was
not accepted so I won't go into this but
let's just say that I've found viewing
systems through a lamp that kind of lens
was was was appropriate and it was very
useful for me but one thing that I did I
also looked at through that lens were
trees and apple trees specifically and
it really gave me a realization as I was
building that system that in fact I came
up with what I would call focuses first
law and the first law is in the same way
that an apple tree apples so to should
your systems tupple now if we have this
system Patagonia and we have information
flowing between the nodes I found
something that was extremely useful was
to have these things be tuples tuples
like the atomic tuples and so whether or
not that was a good idea is irrelevant
it was an idea that let me solve a
problem and and I felt was a very
elegant way so what we do this I think a
lot of people here do this we look at
systems and and and computation through
the lens of closure and one of the
things that we do while doing that
is called colloquially D complexing now
if we as an overview for those of us who
don't know I don't know who that would
be but if you complex something they
would be tangled they'd be twisted D
complexing is a way of pulling these
things apart and making them discrete
elements that can then be composed more
elegantly rather than than tangled so
one thing that we can look at through
that that lens of D complexing are
transients and so transients closure
transients of things that that provide
limited mutability thread isolated
changes they're not persistent and
they're not references but the what you
get out of that by using transients are
speed boosts you would hope anyway but
the thing is that that transients
complex it twists up a number of things
and one of them is it has a change
policy baked in and it has a sharing
policy also and it has a it's sort of a
reference policy I guess you could say
in that it isn't a reference but by
twisting all these things up you you do
get the speed but you also get something
that maybe you didn't intend you were
looking for something that was kind of
awesome and you got this
now don't get me wrong I love I love
transients and I'm a man I'm not trying
to put them down I'm just saying that if
you look at things through that D
complexing lens that the transients are
good exercise at least now rich looked
at transients through that through his
lens of closure and he came up with
something called pods now pods doody
complex the reference policy in the
change policy and there's a gist
floating out that probably is still live
that has an entry and an early
implementation of pods by rich and I've
looked at that extensively and actually
have used it in my system with some
minor changes and I and and the pods and
Zeta also D complex the sharing policy
so you know the pods are our reference
type they they allow you to specify a
certain kind of change policy and a
certain kind of sharing policy and as an
overview you know pods to integrate with
pods you extend some protocols of course
and when you when you're writing into a
pod it goes through this makes a
transient they you always start with a
with an immutable type and you send it
into the pod and it becomes a transient
thing there's a shareability check can
it be shared the really base check here
would be you know is it happening within
a sort of the same thread if it if it's
not that maybe we want to throw
exception maybe not I don't know but
that eventually becomes a value inside
of the pod and when a reader comes along
it shareability check is is once again
performed and a value and and an actual
value rather than a chant transient
thing comes out so that's that's kind of
nice I mean I've found them to be
extremely nice but it leads me into some
ranting now D complexing is extremely
nice and I think that in the in the
closure community we tend to follow a
policy of
making small libraries and and and
providing them publicly so that people
can take sort of a la carte and and mix
these these libraries together but
recently I've been kind of down on that
because what I found is that while the
the at the core our libraries are built
to be easily composable really they tend
to be built just because they're easy to
build and they don't really integrate as
well as well as they could and one of
the things that I have found is that
it's let it's it doesn't happen much
enclosure but I think that it's becoming
more prevalent is that people are
starting to make more and more libraries
that offer functionality that is almost
exactly the same but slightly different
here and there but it's a minor ramp
it's not a big deal but it did lead me
to another realization which I like to
call focuses tenth rule and I'll let you
guys read this I don't I won't read it
but I've found that many systems out
there are implementing partially a
production role system now the one that
I happen to pick for the for the for the
rule is ops five which is one of the
earliest production rule system if not
the earliest it was invented in the 70s
as all good things were myself included
by charles 4g it implements it's an
implementation of something called the
Reedy algorithm which I won't really go
into for this talk maybe in a future
talk but it happens to be incredibly
efficient for matching over large
largest data sets now and it was
initially used to implement an expert
system that was a system configurator I
believe for VMs but I might be saying
that wrong maybe someone who correct me
later if you want to know more about ops
5 you can you can check out these books
I was talking to Brendan Ashworth
yesterday and he said to me that he's
very angry at me because when I
recommend the book to him he winds up
reading it and hating it so buyer beware
but these can probably be had for about
a penny on Amazon so so to give just a
slight overview of ops 5 and how it fits
into this this talk is that now let's
say you have you have a piece of code
and and and you're using de Tomic so up
at the top there you have your your
schema elite it of course in a function
that just takes a username and generates
a salt and and stores that the username
and the salt and the database now
something along the line triggers that a
call to that function and it might be
say composure route or something like
that you know you you you've got a
request and you're performing this
action on the backs back in an ops five
an analogous analogous piece of code for
that is you know at the top again you
have your schema but the way that the
relationship between a username and a
salt is described happens differently
and that and and that happens as a
production and a production can be
viewed as there's this there's some data
in the system and it matches some form
and when there is a data that matches
this arrow says that this is the thing
that should happen when when when a
piece of data matches and what happens
is when we have a a username with with
no salt attached
in our production our knowledge base we
want to go ahead and add a salt and and
don't use this salt in production please
this is my salt and and the thing that
triggers it is really just the the
addition of some knowledge to the
knowledge base the production will match
automatically and and that's what the
Reedy algorithm took care of it made
that kind of match extremely efficient
even in the presence of growing data
now speaking of decomp letting going
back just of just a moment to talk about
that there's a paper out there called
the called out of the tar pit and I'm
sure raise your hand if you if you've
read this paper I mean I'm sure a lot of
people here have I highly recommend the
paper it is in fact I would say the
decomp lectors manifesto if such a thing
exists and it it describes a way of
interacting with the system via you know
really by storing things as relational
data and then performing relational
queries over the data and and and
figuring out this the the the way the
the shape of the system not not to libel
the paper I mean it's obviously much
deeper than that there's things like
feeders and observers and all this
really cool stuff that you could you
could you could spend a year reading it
and and and and trying to figure it out
but the there is one problem with the
paper and and and the problem is that
they don't really have a good story for
how to describe data change within the
system and there's not really a language
for that as described in the paper and I
really think having thought about it for
a while I think that one way of maybe
approaching that that shortfall of the
paper is is to use a production rule
system as a way of describing the way
the data should should change shape over
time and so what I did as I said I
thought about D complected I thought
well maybe maybe I better there's a
better approach and D complexing to get
there
and that's that's Rican flexing so Rican
flexing is you know you think about
Legos and you have these one pip Legos
and they they're very versatile and they
can they can perform almost any task
that a Lego bottle a model builder would
want to do except that they are not
really appropriate for every task I mean
if you're trying to build an arch over a
door you wouldn't want these these one
pip Legos you would need other things
and so you could build many structures
with the one pips but it might be more
appropriate to have larger structures to
build your Lego models out of taking
that a little bit further rich if you
listen to rich and Stu talk about the
atomic they'll talk about how you take
the they're helping to enable putting
brains into your applications so you
have instead of relying on a big server
to perform your queries for your query
capabilities right in in the system and
and while I think that that is that is
brain like you're still sort of losing
some of the relationship between data
and the the behaviors that act on it by
by taking sort of a functional
programming approach and splitting up
your design space over an area of many
functions so rather than being brains
it's sort of a bucket of neurons right I
mean it's we have our data and our
function and in between the way that
they meld is is via behavior it is
called behavior and the behavior if you
think about it another way you know data
is a tactical thing and functions are
tactical behavior is strategic this is
the things you're actually trying to
accomplish data is data and function are
somewhat merged in those two things and
there's a there's a good quote I kind of
like and it it it is very appropriate
for the way that production rule systems
work in it's by a a chess player
an older chess player and he says the
tactics is annoying what to do when
there's something to do and strategy is
knowing
what to do when there is nothing to do
and and I'll try to illuminate that a
little bit more as I go when I
especially when I give the demonstration
of the capabilities so as an overview
this is this is what Zeta looks like
this is not an up-to-date image because
you know I don't show inner cues and all
kinds of stuff and function call names
are slightly different now but this is
this is basically how it looks you know
you have the the meat of it up here in
this box and the box is called an engine
and you know you have your facts and
your rules and your working memory you
can you can you can watch that stuff and
and and the stuff that coming out of the
right side there is is the specification
of the the system so when you when you
dereference one of these things you're
going to get out of is effectively a
snapshot of what the system looks like
at that at that moment so that's that
that's mostly accurate and you can hook
into Dave comic which I'll actually show
you can query that date on ik you can
query the and you can query the the
engine so when I the reason want some of
the reasons that I made
Zeta is that I'll talk about now so the
driving principles are I really actually
just needed to do something one of the
things I needed to do was to build sort
of intelligent systems that simulate
experts interacting say you know you
have a bunch of experts in the room and
they're drawing stuff on a whiteboard
and they're they're augmenting each
other's knowledge so the the interaction
between the experts is is is more
powerful than than any of the experts by
themselves so I use data as you know
creating expert systems that live within
that padagonia system and and provide
services and and and and model behaviors
another thing is another driving
principle is the data data is awesome
you know I don't have to say that to you
guys I mean you guys know that right
I did want it to be a data-driven system
he wanted to be fully described via data
and if you read the second edition of
joy of closure we talked about data
programmable engines and so this is sort
of that follows that model where you
feed data in and and something happens
as a result of that data it's it's sort
its pseudo interpretation I guess but
everything is driven by data I didn't
want to invent anything so nothing here
nothing you'll see here is novel it's
it's actually looking at systems via
that lens that I talked about and sort
of taking some good ideas and trying to
put them together to solve some problems
protocol orientation I really won't get
in into that very much time constraints
and and it's sort of an evolving thing
even today but I've rewritten the the
core of the engine multiple times and
they've all adhered to this sort of
protocol and they've they're they're
they're swappable and and I've really
found by leveraging the protocol
focusing on protocols I was able to
really get a lot of power out of that a
pattern matching so the one thing that
you'll see in production systems is that
very often they're they have a pattern
like pattern matching language and I
wanted to adhere to that as well you'll
you'll see that in a moment but the the
thing that I like about the pattern
matching is that you have a piece of
data and you can you can sort of draw a
sketch of the kind of data that you want
and the engine will go out and and
retrieve that kind of data for you and
and perform actions based on that I want
it to be a library one of the one of the
nice things about closure and Lisp in
general is that you can get extremely
powerful capabilities just by by making
it a library so and immutability of
course I mean I wanted things to be by
looking thinking immutably from the
beginning I think that I was able to
really come to a system we we try we try
to follow that I try to follow the the
principle of immutability it's not
always 100% possible and in and zeta it
wasn't but there's an appearance of
mutability which is which is just as
good I suppose from an outsider's
perspective and it should be fast and it
is fast and I've been benchmarking it
over time and I think for a lot of tasks
that you can solve with something like
core logic it doesn't solve the same
kind of tasks well always be you can you
can have an intersection between the
types of tasks you can solve with core
logic but it's it's comparable with core
logic speeds so I'm very happy with that
so yeah let's let me
let's give it let me give me a demo
let's see what it looks like so I need
to switch my screen around is that it
that's it that's that's smaller than I
thought but named we'll work it out I'll
do some selective highlighting along the
way so you know to use data you just you
just you just pull it in like you would
any library and Zeta schemas look very
much like a de Tomic schema so you can
see you know you have your right ididn't
identifier you have your type of the the
data that that you would you want your
relation to be you know there's a
cardinality and and this was making it
look the atomic like was by design
because I wanted to leverage a lot of
the same schemas that I was that I
already had that I was already using and
so while it's a work in progress at the
moment I can take these Zeta schemas and
transform them into de Tomic schemas and
populated the atomic database along the
same way as you see there's no there's
no doc string like like all good
libraries
so let me talk about this is there's a
this is called a fave schema which is
just a way of saying there's a favorite
food someone has a favor of food and
it's a type keyword there's only one
well you can only have one favorite food
this is this is sort of the the atomic
example you know the pizza people like
pizza right and this is another this is
another relation type and it's a it's a
hungry relation so it's a type it's a
type boolean and it just says it's the
person hungry they can either be hungry
or not so we're not it's just the
cardinality one no duct string and a
plant schema the plant schema is what
does what does a person plan to eat it's
a type keyword and we'll see how that
works out the cardinality is again one
and but the really interesting thing are
these things called rules and they look
very similar to the the Ops five rule
they have a left-hand side which is
which are the things that are matching
so you have you have things that look
like tuples and and one of the ways I
was able to get a lot of speed out of
the system is by making a making an
assumption of the way that the data is
shaped so I don't I don't allow
arbitrary data I allow tuples like a
date like a day Tomic datum so you have
a thing you have a person that this
logic variable gets bound to some person
ID their favorite food is bound to some
favorite that's pretty straightforward
especially if you've seen the atomic you
probably know this now this is this is a
constant here so it says when the person
hungry value for the same ID is is true
then we want to do this thing and what
this thing down here is it says all
rules returned a sequence of things and
and and what this is returning is a
vector a sequence of tuples but only one
tupple and so if if a person has a
favorite food
and they are hungry then there's going
to be a new Tuffle inserted into the the
Zeta system that says they plan to eat
that favorite food so that's all that
says for that ID there's a favorite and
that's the thing they plan to eat
we will you'll you'll see other things
that you can put into this sequence that
gets returned from the production rule
but for now that that's that's pretty
good right and we'll get into that other
stuff later so um the the data that goes
into it is is just or just these tuples
like I said this is a this is a nice
little convenience tag literal that I
that I created that I'll talk about in a
couple minutes so you you the the seed
data that goes into this is just for one
person the person's favorite food is is
a Nabi and I don't know if you've ever
had a Nabi but it's fantastic I suspect
your code is I saw her this you've had
you've had no visa okay
meal plan so this is this is this is
this is the Zeta engine and so I was I
was talking to rich the other night at
dinner and he said that he's looking at
production rules often and and they've
just he likes them but it's never used
them so I think that's that that's
that's kind of a story that I hear a lot
and I think one of the reasons is
because very often production systems
are a holistic and and they say you have
to do things a certain way so if you
want to use this production system it's
all or nothing that's not true for all
production systems I just want to say
that that that that is a that is a
characteristic of many so what what I'm
trying to do here is this is a library
and the thing the production system
itself is just a reference type a new
reference type called an engine so you
feed in the schemas the schemas that I
described above any rules and any facts
you don't you can supply any number of
these things and populate them as you go
if you if you want so to look at it a
meal plan is it's dead okay oh I know
why I like when it happens
I didn't I didn't evaluate it so now we
have a meal plan we go ahead and get a a
snapshot of that and it's it's the
current state of that engine so it has
some rules attached to it it has some
data and we can take that that that
snapshot that we got of that dead engine
and we can populate in another engine
I'm not going to show that because it's
not it's not entirely interesting just
showing it but maybe another day I'll
talk about how that's done but one thing
to look at is the screen doesn't show up
but that's a good we'll get into that
later
so queries queries are just the the that
datum structure it can contain logic
variables and it can contain constants
so here's there's one thing that we can
do is we we can query using the same the
same type of shape as the the rules
themselves and one thing that I really
miss about using the atomic is that you
know I'm constantly querying it and
getting data out of it and doing
something with the data and then and
then putting it back into the database
so this is sort of you know this is
reconnecting those three stages we want
to use the same we want to use this the
query as as a way of triggering
behaviors so this is this is a query
called all favorite food and and we want
we don't care what what the idea of the
person is we just want to know that they
have a favorite food so if we go ahead
and evaluate that and then we query all
we query off of a snapshot of the the
database and we get the one thing the
one person who likes the nabe so that's
nothing really all that interesting
about that but we can also have
parameter queries which is somewhat
analogous to des Tomic rules but it
doesn't work quite the same and and all
of this this query language looks like
datalog it's not it's not recursive so
rich if you were gonna ask that question
the answer is no it's not it's not data
log its I intentionally did not make it
recursive because it confused me too
much
so this is specific specific fear of
food and it takes an argument and you
can pass enough a specific paper of food
and that argument that's passed in
becomes the target value on the match so
there's a favorite food and it should
match that same that's specific food
that was passed in so when you do a
query you can pass in the arguments at
the end and yes of course
there is that one person again but what
about we can ask does anyone like not
to--and and of course no one does who
would so sorry I'm sorry if you like not
to so yeah we you know what about
assertions what if we want to put data
into the besides just seating it you
know we can see it in the beginning but
as a system runs we want to put data
into it so again you know it's an ID a
keyword of value an entity attribute
value if you want to think about it that
way you know we can generate IDs I use
uu IDs as the ID field but you can use
anything that can compare with another
thing and you know just doing a Gen ID
is will return a you idea it's not other
than interesting but this is kind of
cool one thing I found in des Tomic that
I just created something like this that
would that would do the right thing but
is that keeping same IDs among related
and datums was was was a little bit
cumbersome I just added this little
thing in there and then and now it works
and so I don't know what it's like now
so maybe it's different but these tag
literals can you can put a tag in there
and it'll give you something called a
cursor which is just a way of taking
within a single transaction all of the
things with same tags will be will get
the same ID and if it's an underscore
then it'll just get any idea it doesn't
really matter now and you'll see how
that works so you know to create a fact
you just create a vector of the stuff
that you look event so here's a fact
that says you know there's some person
out there who's favorite fruit or tic
tacs and to put that into the database
you make an assertion which is just the
same
thing that seemed tupple a sequence of
tuples goes in and a new version comes
back out a new version of the the engine
comes back out now of course it's in
that pods like structure so the pot
itself is updated but you do get that
you do get that new version out if you
need it so to do a query you know we
check is there someone that likes Tic
Tacs of course there are and you can oh
it's data it's data as you would expect
it's just a vector and so you can you
can pull it apart and then let's say you
want to say that that person who likes
Tic Tacs I hope this is I hope this is
easy to see it's not it looks a little
bit jacked up but we'll have to work
with this so you know you want to say
you grab that idea of the the person
that matches that query
that'll fail if I don't do this there we
go and now you make an assertion and now
there's a person who likes Tic Tacs
who's hungry so one thing you couldn't
see on that is that there was that there
was a part of that returned engine that
said fires and fires there the number of
rule activations that occur based on
some data being put into the the engine
so you know we can we can have a new
query that's called hungee and if you
have kids you use words like hungee so
hungee is you know we do that and
there's a couple people who are hungry
one who likes Tic Tacs someone who likes
knobby and there's a little convenience
function that just takes the tuples so
every every query that happens against
data returns just the wrong tuples and
this is this just a way of tying it back
together into a map it's sort of like an
entity thing but not as awesome so you
recall the rule the for the plan lunch
was that there's a favorite food person
was hungry and when that person whoever
you create a plan so now that we're
gonna make that person who like nah be
hungry and so they're they're going to
fire and we can't see that of course but
just I assure you that they are now they
have a plan for lunch and we will show
that by going to all plans and doing the
couple map and favorite food to Tic Tacs
they're hungry true and they have a plan
to eat but it can't see that but it
looks like this they they have a
favorite food tic tacs the same person
is hungry they plan to eat nabe that's
not right they've plenty tic tacs this
person Navi true plan to eat Navi so you
know so look at that all the plans na ba
tic tacs okay so that's that that's
that's a real high-level overview of
what it looks like there's a couple of
cool features and I don't have a lot of
time but I'll sort of buzz through those
one thing that is kind of cool is that
Zeta allows negation so there's there's
relationships between data fundamental
relationships between data and one would
be you know and in that previous model
if a person is hungry they want to eat
something and so using those rules we
can make that association between the
the fundamental Association but there's
also an association between certain
types of data and the non-existence of
data and so what data allows is
describing that that kind of
relationship so we have a we have a
schema there's a username as a type
string there's one there's a and there's
a salt isn't this is sort of like the
ops five example it's also a string and
there's one so the rule is called detect
unsalted user and it's very difficult to
see and there's the doc string I finally
put one of those in so there's a user
they have a user name and the user by
this fancy metadata says they do not
have a salt so if we put you would you
would think if we put if we put a user
into there with a user name we would
want to salt so that's what that says if
we have a user name with no salt go
ahead and and an assertive that there's
a salt so we want to partially populate
by saying you know let's let's go ahead
and put a user in there with just a name
and of course I did the wrong thing
again
okay now we got our stuff go ahead and
assert that we get a new version the
database we go ahead and create a go
ahead and create a query that looks up
all the user names there's just one
focus we go ahead and create a query
that looks up all the salts let me go
ahead and look and there is a salt in
there now because of that that rule that
said that when it doesn't that a
relationship does not currently exist we
were going to make it exist
I'm not going to skip over spreads
because I think we can get that later de
Tomic integration this has proved kind
of useful though it's not as as nice as
I would like it to be yet but we have a
de Tomic database out there somewhere
we'd go ahead and I've created it and
gotten a connection to it and to find
some schemas and this is this is just
the description of the unsession so
there's an unsession that has a title
and a description and a tag the tags are
enumerated types and there's another
thing that says am i interested am i
interested in it so there's a boolean
out there in the database that says I am
indeed interested in that unsession and
these are the tags you know there's
there's a tag core async and Hadoop and
music and I've gone ahead and put the
schema into the database and added some
data which are some on sessions the
query sink on unsession and closure and
Hadoop on session and and the back ends
with closure script core async so I've
also created an engine that has similar
data similar schema data except it has
except it only tracks tags and it only
tracks it tracks tags and it tracks
interest which is a boolean am i
interested or am i not interested and
so the way to get at the day Tomic
database is to define something called a
tap and a tap is defined basically just
as a query over the transaction report
log and so this is this is probably the
most useful of of queries for
integrating with Zeta and it basically
just says based on a certain tag that
you're interested in go ahead and pull
up the values for that tag and and and
and the the the the entity attribute
value tupple and go ahead and populate
it in so while I'm really interested in
tying it together is the the tag key so
if I go ahead and add the data into the
day Tomic database I've set up the tap
and I query the date on m'q database I
go ahead and I see that there's some
there's some tags in their core acing
but then I also query the Zeta database
if those tags are also in there and
additionally if I add new stuff into the
D atomic database it automatically shows
up in the Zeta database and now if I'm
going to look at the schedule for Zeta
that Zeta has built I can go ahead and
do that and you can see I say I'm only
interested in the core async stuff so
there's a lot more to show I think I
wish I had a little bit more time but
there's there's more to say about this
and one is you know it's it's not just
the way of doing data rewrites so right
now I've really only showed using Zeta
as a as a rewrite engine but you can do
arbitrary computation and I and and and
I do that in one of my examples I
couldn't get to but it was you know a
blocks world of implantation so there's
this there's this classic AI program
that says here's a here's a pile of
blocks here's a pile of blocks the goal
is
I want to put some block over in this
pile on top of another block in another
pile and it does that all via rules and
I can show you that after if you're
interested during lunch so yeah that's
that's that's all I have I this is an
ongoing project and I and I hope that I
have more to show in the future thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>