<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Navigating ClojureScript's Fire Swamps - Peter Schuck | Coder Coacher - Coaching Coders</title><meta content="Navigating ClojureScript's Fire Swamps - Peter Schuck - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Navigating ClojureScript's Fire Swamps - Peter Schuck</b></h2><h5 class="post__date">2017-03-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tpXfASdPteI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello my name is Peter cook otherwise
known as spitting cops to do more on the
Internet
sorry how you can find me on closure in
slack IRC or on github work for bending
works you may as a software consultant
mainly working as closure and closure
skip troubiing rails and JavaScript and
I'm here to help navigate everybody
through closure scripts fire swamps all
this is as of closure script 19.4 94 and
feel free to ask any questions that you
have
anytime during the talk there's plenty
of time for that and it will help
enlighten people in the audience and
they're at home viewing this so let's
get started that the closure script
really seems inconceivable especially
few JavaScript developers coming into it
JavaScript developers see subsequent
incremental compilation with hot code
reloading state inconceivable they see
fully accurate source maps that are
generated in subsequent times and say
inconceivable and you see accurate
advanced dead code elimination and cross
module code code motion and then say
inconceivable and I think that word does
that mean what they think it means but
of course this is one step away from
saying nothing can stop me met now in
terms of prideful boasting in hubris so
nemesis is going to come and strike me
down for all this so that we encounter
our first Rous that is not a function
and then we are going to spend hours or
maybe even days trying to figure out a
bug in our X turns so let's start our
journey through closure scripts flyers
locks and first let's pick up one of our
assets in Google closure library because
when we're having fun storming a castle
this imposing and foreboding that we
want all the assets we can get not just
a Holocaust cloak and wheelbarrow so I
think Google closure libraries like a
pretty comparable to like the standard
library batteries included libraries
that you would see like Ruby or Python
that it is really full-featured and it
ships with closure skips closure scripts
and you can use it the same way you
would any other closure script library
namespace you just use it in a require
inside of your namespace macro and it is
JavaScript code
for the Google closure compiler so that
it will work really well with advanced
optimizations and it's a really great
standard library except for the
documentation which is pretty much only
written that like the API level seems to
be written only for like IV IV auto
completion and not really for any sort
of end user documentation the source
code however is written pretty well and
very readable so that if you really want
to understand what the this particular
portion of the closure library is doing
I would recommend going down through the
source code that but you should really
take like at least an hour to to go
through the closure library there's
really great buried gems
there's Ajax both classic and using the
new fetch API that there's lots of
asynchronous functionality that you can
get debouncing delays and throttling in
there and there's whole swathes of
methods for dealing with date time and
time intervals which are developers
favorite things the elapsed time that's
it it makes up for a lot of deficiencies
that the JavaScript dish doesn't cover
and one of the like best namespaces that
I would recommend that you look at is
goog objects which has is just for
interacting with JavaScript objects in a
very safe to reverse way and if nothing
else you should really use Google jacket
and Google it set in place of a get and
a set which are just primitive uh
accesses and modifiers for arrays they
really weren't written to do any sort of
object interaction at all and not really
that safe or what for especially when
you want to do a bit use advance
compilation and Gudda fine is one really
really well
well buried gem inside of closure
library that you can use it to
parametrize
your builds like inside of here you can
to call it with the goo-goo font you
define macro and right here we're
sending our timeout and our HS call to
be 300 milliseconds and that's just for
development but and when we need to
change it in our builds then we
can change then we can override that
with the closure defines compiler option
and we're here we're sending we have to
folder qualify the namespace of our
symbol and then we're setting the
timeout to five seconds over 5,000
milliseconds instead of the 300
milliseconds and we can use this to get
feature flags in our closure script
builds with all the unused features
getting compiled away to decks on
religion and elimination in our
production code but there's like a few
tricks that you have to do in order to
get this dead code elimination that for
boolean values you have to type int
whenever you're using them so that right
here when you're using admin we have to
type in boolean when we're comparing it
with if to make sure that the other code
is that it was eliminated and for string
values you will have to use either if or
cons in order to get the dead code
elimination and you have to compare the
strings using identical instead of the
closure equals Google closure cannot
done it doesn't understand the equals
for dead code elimination so you need to
use identical do the comparisons for
string values and now to probably one of
the like darkest and most dangerous
Parsons of closure scripts that I've
ever seen the extra integrating it with
external javascript this is JavaScript
that the Google closure compiler does
not touch at all and and say we have
this JavaScript library that has just a
foo object that has one method bar and
that we call this a library side of
closure scripts pretty simple and like
everything is working really fine inside
of development and testing works just
fine QA works great we build it and ship
it to production no errors in our
compilation and then we get an error in
production where we see that food up
that we see that our users at now
arguing this era of food that W is not a
function and we look inside our compiled
JavaScript and we then see that it just
glued at W and the question is what
happened to Fuu dot bar that we call
them side our closure script
the answer is that the Google closure
renaming that in advanced optimizations
that it will take the generated
JavaScript of food bar and try to
minimize that code size as much as
possible renaming food bar into silver W
and so what we need to do is inform
Google closure about all about the
external names that we're going to use
and we do this through a file of
external names or an external file that
we then write here saying here's a foo
object and its function its method bar
has one parameter and you can see all
this extra annotation alongside the bar
method that is not technically needed
but externs are much more than our
preventing renaming our that they also
provide the Google closure compiler with
a lot of information like type in ting
and telling would functions are not
going to have side-effects that allow
you to get like the benefits of closure
ship code like Dedic elimination and
like inlining that you could get from
closure script code for your ex turns as
well so with our externs know we get the
food up bar function you pass it to
google closure pilar it reads it's
externally up bars not allowed to rename
so the compiled JavaScript is just
screwed up bar what we need to to have
that work and so all we really need to
do is to originally annotate all the
api's of all our JavaScript labs yes yes
who here like we really like to do that
for all the JavaScript libraries so
unfortunately this is the case for like
95% 99% of JavaScript libraries that
you're going to have to do all the
manual work there's like nothing written
for you at all but there's like a small
portion of JavaScript libraries have had
externs written for them but you'll
still need to manually load up the
library and the external side of closure
script and of course the externs writer
aren't the JavaScript library developers
so there will be corner cases
of where they haven't covered the whole
API or accidentally had actually miss
wrote the X turns and that you'll have a
very uncanny valley effect and many
unhappy hours debugging if they did the
X turns wrong but the best case scenario
is if that someone has wrapped all the
JavaScript and all the X turns inside a
closure script wrapper this is what CL j
FJ s does so that you can call this
javascript library just as you would a
closure script library and not have to
worry about like manually wiring
everything up but you can see that this
takes like three different sets of
developers to synchronize and get all
this to work that you have the library
writers themselves the people that write
the X turns and then people that wrap up
close your script library inside of
closure scripts and you have to repeat
this for every single version of a
JavaScript library and JavaScript
libraries say very very sick as we all
know so this is so this is this is why
we like cut in the pit of despair and
like only the most popular JavaScript
libraries are readily usable it's
because the JavaScript just community
just changes very very rapidly and we
need to synchronize all that X turns and
detail in order to get this actually
usable so I happy to report that we can
escape the pit of the spare with two
methods we can use closure scripts X
turns inference or a library called clgs
oops
and X turns inference was added to
closure script as of 1.9 dot four five
six and it's a can be turned on with the
interns compiler option which turns on
the X turns inference and also generates
all the external into a file of inferred
underscore X turns es and we tell the
enclosure script to yell at us when
we're using inference wrong with the
warning and fur option with it and there
are three types of inference warnings
currently that's a we get we get warning
if we're caught if we're trying to use a
unknown JavaScript object type we get
another warning if we're
trying to use a method or property on a
the base javascript object type and then
we get a warning if we're trying to use
a method or property that is not
specified on a object that I specified
in our experience but is not actually
the method of property is not inside of
our externs so like for the first
warning say we have this cloudy function
that we have outside parameter and we
call get clouds on it but then we'll get
the warning of Kenna and for target type
four and this is telling us that closure
script has no idea what outside is it's
a unknown type as far as its concerned
so we need to tell it that this is
actually going to be a weather type of
outside so what we do is we just type
int the outside with a as a JavaScript
weather type and we this is type ending
the similar vein of closure to get speed
ups and the second warning is say that
we get the results of the get clouds at
theta and then call gate type on that
then we get the warning of adding
external object floor and this is saying
that we're adding get type to the base
javascript object type in other words
object get type which is not what we
intended to do at all and this is
because as far as I can tell for closure
script X turns inference says that
whatever returns something from a method
that it's going to be the base
javascript object type unless otherwise
notified so what we need to do is say
that get clouds returns a clouds object
not a base javascript object type so
there's two ways to do this we can wrap
get clouds inside of a closure script
wrapper function and then type hit the
return type of that function so that it
is clouds and then we can use this in
place of directly coloring the get
clouds method logic on the object and
this won't get compiled away during
advanced optimizations so you don't have
to work really worried that you're
bloating your code size about this the
second way is that we need to add the
return type of clouds to get clouds and
we
- then add clouds to our external file
as you can see here we're putting in the
Jayhawk of returning clouds on get
clouds and adding the clouds and the get
type let's function for get clouds for
get type and the final warning is say
that instead of get type we say we're
going to call frog on clouds and then we
get the warning of cannot resolve
property and this is because we've told
we have clouds and our experience with
get type but we don't have frog in our
extern so close your ship is saying hey
this frog method I have no idea where
this is coming from so either you have a
typo inside of your closure script code
or title inside of your externs
you have to resolve this so we can
either change frog to the correct method
of get type or we can add frog into our
externs
and those are how we can help
closure script extra inference the right
experience for us and clgs oops takes
the different approach thing we're going
to sidestep externs inference all
together by using string names and the
idea is to use string names via google
object-- get or a get that the advanced
compilation
does not touch string names so it just
leaves it alone and all compiler options
work with string games
so in our cloudy function instead of
accessing get clouds directly we're
going to cut reprieve the get clouds
method via google object get of the
string name dynamically call it with
call slide the outside object and this
looks like a lot of fun and brittle
works for us to do just to get to work
with externs
so CSS oops provides a lot of macros for
automation there's au get which you can
retrieve properties from javascript
objects like right here we're retrieving
500 square feet from our houses floors
living room and then there's a set where
we can set javascript object properties
like we're now we're setting our floor
of our living room to be 300 square feet
and then oak all which we can then call
javascript object method
with six number of arguments and right
here we're in the car and we're playing
I spy and we see I fly a red barn so
that we can call it and get return of
the correct thing that we see and then
finally there's all apply where we can
call javascript object methods with a
very attic number of arguments here so
we have the bill and we want to total
yep yep
it says if you pass it a vector I
believe you would have to go to the
documentation for that but I believe
there you can there is like three ways
that you can call this but I just did it
with the simple string name I believe
you pass it a vector you should be able
to call it with multiple nested
arguments no problem right and if you
see here we're tooling it up with a very
big number of arguments and we're
getting six back as the results for our
total and seal just oops is not just for
automation that it has a number of
runtime and compiled down validations so
that make sure that you're calling it
correctly and that there's no like typos
and that the objects exist and that your
will complain at you at the level of
nesting that it finds an air act and
that once you turn on Vince the
compilation it generates the same code
that you would like hand roll if you are
using string names yourselves and this
is also very useful for navigating
JavaScript objects like that you would
get returned from a JSON API call
there's two access modifiers you can
protect your keys with there's the
question mark or soft operation access
modifier which will return nil if the
key does not exist instead of having a
runtime error and the prefix of
exclamation point or a punching access
modifier which will set a JavaScript
objects key does not exist instead of
doing a runtime error and I like to
think of the question mark our soft
access modifier as being like get in
where if we want to get our homes living
rooms color
that does not exist that will get will
just get a nil value instead of having
its have a runtime error the same way
that get in allows accessing that's data
this is keys for a hash map and for the
apunching access modifier that like
think of it like to search in wherever
you want to set our houses living rooms
color to red on this empty JavaScript
object that will turn on all those that
will create all those keys and create
the nested objects the same way that
associate will do for a empty closure
script hash map and so this these two
methods allow us to quickly use external
javascript libraries without having to
go and write a whole bunch of
annotations or typing all the external
files ourselves but keep in mind that
these only prevent renaming that they
provide absolutely no information do
Google closure at all so that this
really hampers the use of advanced
compilation basically you're saying just
ignore these portions of my closure
script code and that so Google closure
really can't do any sort of the
optimizations that make closure scripts
really nice to use at all so I would
recommend to prefer clgs libraries or
externs files worth where they are they
are much easier too they're easier to
work with and use and they provide the
Google closure compiler a lot
information so that you can get some
really nice performance and code size
gains but when unit exists and you
really need to use that a JavaScript
library for your application then I
would recommend going to closure script
externs inference are sealed yes yes
oops now that were gone through that
very treacherous and dangerous fire
swamp of closure skips let's revive
ourselves with the miracle pill because
we're only mostly dead not all the way
did and talk about compiling node
modules that
this is as a foolish gift master is not
actual version release yet as of today
and Google closure compiler canal like
compiler no modules and we see really
big benefits out of this that Facebook
reacting to react Dom ships 53 kg Japan
minified and with Google's floating
filer we can get that down to 32 kg to
solidified about 40% savings and code
size so that's really great and this is
through a new compiler option called NPM
depths where we just pass it a map of
our libraries and the version numbers
and we just can use react in Vietnam
just like we would any other a collision
script library that we and also note
that we are calling react and react Dom
as namespaces not as global JavaScript
objects so you want to use them like a
closure script namespaces as opposed to
the clgs disk style of calling a method
on a global JavaScript object just take
note of it and now for all the caveats
addendums and little hoop jumping that
we get to go through because this is a
alpha feature so there's going to be in
many sharp edges that closure script
does not manage the JavaScript
dependency graph at all so yes you can
see that closure scripted can like tell
the closure script libraries like
rainbow and prism and manage their
version conflicts just fine but there's
this shadowy netherworld of the
JavaScript dependencies that they're
trying to use and color skip cannot
track or manage those version conflicts
at all so these libraries will just
generate lots of bugs and errors since
they're using very different versions of
those two different libraries and so
what I recommend is if you are going to
like not all use NPM depths and ship it
as a library that rapid is the same
style as tlg SJS that just do one node
module and mark the version of your
closure script libraries the same
version that's a JavaScript library
because otherwise there's really no no
way for Clojure script to tell where the
version conflicts are otherwise
but like application development is the
really big winner here because if you're
just importing all your no dependencies
in your application then you can manage
them through NPM our yarn instead of
trying to have closure skips do what it
was never meant to do at all and that
you can get the minimize your code size
for your production application because
I think Google closure Canada goes
through traverse the graph and find the
common dependencies and the magic that
way and now for all those fun hoops that
we get to jump through that first we
need to have a node module called module
depth loaded we can install it to be
these commands to either NPM our yarn
this is needed so that we can get all
the nodes the files inside of node
modules that are direct dependencies
need and also the experience for known
may be needed and this is because a lot
of JavaScript libraries nowadays use
node to compile to their final
production version of JavaScript and
like they use some internals of node
like reacts uses process and that node
end in order to tell if it's that
compiling to production or to
development and all these externs are
available at this URL and finally we'll
need sealed yes just libraries for
extern still and this is the fact that
many java javascript libraries will
dynamically export the names through
meta programming and the Google closure
compiler does just static analysis an
aesthetic inference
so all those dynamically and meta
programming they generated names are not
visible to Google closure so the X turns
tell Google closure that these names are
going to be used in this JavaScript
library but even if you can't see them
so those are all the hoops that we get
to jump through and now I'm going to go
through how to make the miracle pill
from scratch because this is again alpha
level feature so there's going to be
sharp edges and bugs that you're in
encounter so this will be very useful
when you're debugging about how the
actual steps that we go through in order
to generate these NPM
dependants compiled these known modules
and first step is as wise man once said
wise person once said first to create a
miracle pill we need to create the
universe or consult the universe we need
to install react and react some either
through NPM our yarns you can do it
through these commands and also note
that we need to lock down the version
with the little at sign saying it's that
particular version of react during the
exam and then next we need to create the
recipe for a miracle pill and this is
done through a route JavaScript foreign
Lib where we set up all of our
dependencies and our exports see here
that we're requiring reacts and
requiring react them and then we're
exporting reacting react them and then
we need to collect the ingredients for a
miracle pill and this is done by put it
passing our route for and live in to
field just close your node inputs and we
just specify where our route form live
is located that here's the namespace and
it's a common J's module and then pass
that into node inputs and then finally
we're ready to create the miracle pill
that we have to take the result of no
two inputs and pass that into the
foreign lives compiler option of our
build and then we get exactly the same
result as MTM depth that the only
difference is that we acting like Dom
are inside of the are on the root
namespace of live NPM depth instead of
being their own separate namespaces and
that's pretty much like the only
difference and this is like still very
very alpha but it's not just like clear
script developers that are pushing this
and working on this that major players
are working on integrating Google
closure that react to its the fibre
build system is working on this that
angular through its offline template
compilation is also working on this and
typescript is working on Tia fickle a
touch compiler that compiles typescript
code to Google closure compatible code
and now that that we've gone through the
extra on JavaScript libraries and node
modules let's take an axe relaxing tour
through the fire swamp of dynamically
loading closure script modules that that
closure get modules are proudly
straightforward to use they've been
around for like two years now at least
and we just like say here's a module
name and here's all the namespaces that
we want inside of our module and Google
closure does like majority of the hard
work and cross module code motion makes
it so that we get good code splits like
right out of the box and we may have to
do a little bit of work to get them
optimal but right off the bat they are
pretty good but dynamically loading a
closure script modules is a very big
mass of object-oriented boilerplate that
we get all this module management
object-oriented style where we have to
first instantiate a global singleton
module manager then we set the loader on
the module manager then we have to set
the our module dependencies and are also
the you are eyes on the module manager
do that then we get to go through all of
our modules and call this set loaded
function to mark it as this module is
actually been loaded once is called and
that's just all the MAL general
management bookkeeping that's we're not
even to getting loading our modules at
all so here is a desire to end result
that we want at the end of this that we
have our route module and we just call a
function load module that those are
extra module and then fires this
callback once the module has been loaded
and the tricky part is that for
development which is when we have no
optimizations that the modules is not
available that we can to do the module
code splitting there and also that
development those all of closure cube
namespaces automatically so that we have
to do a few extra steps in order D if
it's working for
that first we have to put all our
modules inside of preloads and this is
the fact that we don't want to that the
only other way to get our modules to
load correctly inside development is to
put them inside of our root namespace
and not ever use them which does not
really strike me as a clean code that we
want all of our module dependencies to
like live in our build that inside of
our actual code and then yeah you can't
ignore all this fun stuff that's just a
working model of a working code example
of how to do this but this is how you
load modules and development that
they're automatically loaded so every
100 milliseconds we'll just go and do
another query of is the module loaded
and then we then fire off the callback
if the module has been loaded and for
learning modules in deduction it's much
simpler all I said
much less code that all you have to do
is call the execute on load from the
module manager they're all done then we
have to tie this all in a nice pretty
bow at we have to say which modern will
lower we're going to use are we going to
use production or are we going to use
development so with that we use closures
of fines there
told you it was a very good berry gem
and then switch it out so that we
compile away the unused module loader
and I think it would be really nice if
someone would create a closure script
library to like have all this facts I
did it's called Colin McMullan removes
about 50% of the boilerplate that is
around there and it's available at the
github under Benny works and con what -
modules if you want to look at it and so
we've got up through all the fire swamps
of closure shipped and we come back out
live we should feel it very proud of
yourself and I want to say before I get
my thanks that people when they think of
poaching it really only see one Dread
Pirate Roberts and I really want to say
that there are many red Pirate Roberts -
including scripts that there are many
people that make it the warm welcoming
community the great language and the
nice ecosystem that has to use like to
give thanks - and turning in hillebrand
for
helping me understand clgs oops and
externs in general like to thank Antonio
Martino for helping me with my
presentation and also for helping me
understand compiling known modules I
think David Nolan for being me with this
presentation and understanding some of
the darker corners of closure script I'd
like to thank Allen brought her I hope
that's how it felt to aim for his a blog
post on dynamic module closure module
loading that's where I got like 90% of
my information from and finally like to
thank Martin clutch for his
parametrizing closure skip builds blog
posts where I got majority of my googa
find information from and finally that
sealed this presentation I put this in
the public domain so you can use any of
these examples I really want these
features to be used in well-documented
static leadership so feel free to grab
any of my examples or its things in this
talk and any questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>