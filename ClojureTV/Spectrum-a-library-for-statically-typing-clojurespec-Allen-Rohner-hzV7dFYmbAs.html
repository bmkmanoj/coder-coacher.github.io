<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spectrum, a library for statically &quot;typing&quot; clojure.spec - Allen Rohner | Coder Coacher - Coaching Coders</title><meta content="Spectrum, a library for statically &quot;typing&quot; clojure.spec - Allen Rohner - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spectrum, a library for statically &quot;typing&quot; clojure.spec - Allen Rohner</b></h2><h5 class="post__date">2016-12-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hzV7dFYmbAs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi thanks first time I've been at the
big room before so hope I live up to it
great so how can everybody hear me in
back yep great okay so I built a thing
it's called spectrum it's static
analysis for closure that's back so
basically you just use spec as normal
and then instead of running your
generative for tests or instrument or
that kind of thing we'll check your
annotations at compile time
so there's a function you use at the
repple and it walks the source code
awesome right I got some bad news
predicates are types so you know if you
have the predicate like string you know
that oh you can convert that to
java.lang string spectrum is a static
type checker for closure
sorry stew so you can thank Chaz
emmerich for this wonderful meme but
don't panic it's fine we're gonna go
through why this is okay and maybe not
such a terrible idea so the workflow you
write your normal closure source code
and then you write some more code to
prove your code works well we already
have that right it's called closure test
and test dot check and closure dot spec
and I can keep naming testing libraries
but the point here is that you know
we're already used to this workflow if
you write some code and then you write
some more code to prove that it works so
this is just one more thing right
nothing nothing special about that I'm
gonna try to approach static typing here
from a node dogma perspective you know
I'm treating this as just one more tool
to improve your code quality you know
you'll hear in the community oh I don't
believe you'll never hear somebody say
oh I don't believe in unit testing but
you'll totally hear them say I don't
believe in static typing so we're gonna
go through some of the arguments around
this so the current status it runs it
checks basic closure source code so I
have you know it has unit tests and I
written hundreds of little fake
namespace definitions and things it self
checks itself it has some false
positives but it has caught real bugs in
itself and it's not recommended for real
projects yet you know you can download
it you can run it you can poke around
with the repple but it's there's still a
lot of missing call it convenience stuff
and there's some specs that'll check in
some and it won't so do some polling the
audience research here so raise your
hand if you've ever written production
code in a conventional statically typed
language that's nearly everybody okay
closure another dynamic language again
nearly everybody now we get to the fun
ones Scalla or haskell or another strict
language okay so that's maybe 20% of the
room at best and then scheme schema or
spec that's you know 30 percent of the
room and then the fun one core type
spectrum type scripts or another
optional static type language like
nobody so you know five percent so we
have all these opinions about our static
typing is great static typing is
terrible and when you apply it when you
try to apply that argument to closure
you know obviously we don't have much
data Oh fun one shit bugs too production
that's I've definitely done that so
notice that we have you know arguments
for and against and yet everybody is
still breaking production and they will
continue with spectrum like I'm not I'm
not saying this will fix every problem
or even many problems so why did I do
this to prove hacker news wrong
so yeah you may be you may be familiar
with a blog post why Circle C is no
longer supporting are no longer using
core.typed so I wasn't at Circle I was
the one that introduced core.typed I was
the one that set up the are supported
Ambrose with the the original
Kickstarter and we used it for awhile
no longer with the company I'm not I
wasn't there when this decision was made
and I wasn't there when the blog post
was written but I was there for the
grumbling about you know what didn't
didn't work and I agreed with the vast
majority the blog posts and I think
Ambrose would agree with it too as far
as I know Circle talked to him before
they wrote it but then the hacker news
comments these are probably too small to
read but so many people got this wrong
the blog post wasn't saying that
optional static typing can't work it
wasn't saying that you know bolting on a
type system can't work it was it mainly
came down to practicality you know
circle needed to ship code today
core.typed was being worked on you know
part time by a PhD student like it's I
have no doubt that it can work it was
just it what it wasn't developed enough
at the time so basically all of the
spectrum is a long reply to hacker news
saying you were wrong and but but more
seriously I wanted another option for
code for improve my code quality so we
take a step back you know why are we why
are we here why are we at this
conference why are we using closure why
are you listening to me talk about
static typing we we care about making
better software faster and cheaper you
know we we all know about the NASA
techniques you know if you really want
to you can write almost perfect code at
the cost of you know a hundred thousand
dollars a line or whatever but nobody
here wants to do that and honestly most
people here don't need to do that you
know I don't think anybody here is right
as launching rockets so you know the
nest rules don't really apply to us so
you know whatever whatever software you
work on we have this big messy problem
you know and we have all kinds of
techniques for trying to solve the
problem so obviously the first one is
thinking it's a good technique if you're
fine then you know this is your
algorithm this is nobody here's Fineman
so we have all these other all these
other techniques you know thinking we
have high-level languages unit tests and
you can probably come up with another
dozen of these and kind of like edge
cases you know are special cases if you
have no edge cases you are you have no
special cases you might you might be
solving the problem correctly if you
have 12 special cases you're probably
not you know you can come up with
another dozen live for this and so it
tells you each one of these things might
help but none of them is perfect you
know and part of that reason is our
source code isn't all the same you know
you have different functions you have
different kinds of code you're using
different system architectures so so not
every you you don't want it unit test
everything and even the things you can
unit test you don't always want to you
know so you know famously you don't want
to do unit test a distributed system you
don't want a unit test anything with
races you don't want to unit has
throwaway code you don't want it test
unit test prototypes so every every
technique in that big list doesn't work
somewhere you know so likes to has these
tweets these interview questions you
know think of a time where you you know
so a fun interview question here would
be for every technique come up with a
situation where you wouldn't want to use
it or where it wouldn't be as effective
as some other technique you know so code
review you know the technical term for
code that it isn't amenable to code
reviews you know it could say it's bad
code but you could also say maybe it's a
really gnarly function and the person
there's you know one person who wrote it
and then there's you have junior
employees who aren't as experienced in
that code base gender and testing is
great use it in a lot of places you know
we've seen lots of good talks about
how and when it saved people but then
you wouldn't want you wouldn't use it
for like you know the account settings
page or new UI you wouldn't use it for
you know I do this state transition this
state transition and then the final
result is this and then you know could
be completely fair static typing doesn't
work everywhere it doesn't work when you
eval it doesn't work when I had better
lane examples for this but I guarantee
you there are places it doesn't work if
you have caught if you have gnarly types
you know so so one of the things we'll
see is you can have a messy closure not
closure not a messy codebase but when
you you build your system without types
and then you try to introduce it later
you might end up with a lot more kind of
weird types than you would have thought
of if you'd done it up front so just now
we were just talking about how there are
different kinds of quality techniques
and they work even they don't work as
well in every situation but then there's
another access to this which is York
your code might need more or less
quality than my code you know what is
the cost of making a mistake in your
software that's gonna be different from
the cost of making a mistake in my
software you know so you know firing
rockets into space versus Twitter like
it so if you say you know if you get on
if you get on Twitter and you say you
know this is the one true way to write
code like really you know who are you
talking to who is your audience you know
are they are they firing rockets into
space or they you know yo app you know
the messaging thing that sends use dear
buddies so that you always need context
when you talk about which advice and you
know which techniques to use you know
because aside aside from how much
quality it's like well maybe I'm
building a distributed system
maybe I'm building an Internet of an
embedded system you know maybe yeah
so then and then on top of that even in
the same project
you're correct restore correctness
requirements will change over time you
know so like when circles started I we
had when it first launched we had 20
used 20 using companies and probably
half of the more startups with no
customers either so you know if circle
is unreliable they didn't care you know
now there are 10,000 companies using it
so then at some point in the middle
circle went from complete toy to if we
mess up lots of people are gonna have a
bad day so then that's in one project
that you know one kind of software it
the quality had to increase over time so
again with the context you know what are
you building it's like how much quality
do you need how much time
what's your quality budget you know how
much time are you willing to spend on
this and I don't really like the answers
of like oh well closure has a circle has
to be correct now so you should use you
know Haskell or address or something you
know some extremely strict language but
then over here when you're still in the
prototype phase it's okay to use Ruby
you know rewriting in the middle is not
an acceptable answer for we need to
change how much quality how much
correctness we're spending on the
product so you need a tool that can grow
with you okay so now what you know we
still have a messy problem and we have
you know thinking covers a lot of this
but it's not gonna cover all of it and
then we have all these other techniques
so then another circle story sorry this
I think this is the last one circle uses
containers to run a customer code so we
used a thing called LXE which is you
know predates docker but you know when I
say LXE you can just imagine doctor
because they're based on the same Linux
primitives so we want to test this we
want to make sure it works but testing
LXE means starting and stopping
containers which means writing to this
Linux root device node so we wanted you
know we were we were eating our own dog
food and all
all the circle tests run on circle so
then if you're running the tests inside
a container you can't run you can't hit
this root device like okay so we can't
run inside circle we can't run oh and
then we couldn't run on a max because
those are max versus Linux so then you
know you don't have a devil exceed node
- right - so this was actually what led
us down to using core.typed in
production because oh you know it's like
you can write you can run an emulator
and we did you know so it's like I'm
gonna make I'm gonna stub the the
expected inputs from this LXE thing and
then but then you now you're just
testing your emulator because it's like
okay you know I told you to give me a
container then you gave me a container I
think great and that that's not finding
new bugs it's really just regression
testing because so like one of the fun
bugs we found was that Alexi was had
race conditions in some some operations
so if if one user request comes in and
you start making a detainer and then
another one comes in at the same time
the kernel will deadlock and one of your
user threats will die so how do you
write a unit test for when I do when
they have a race condition with these
series of steps my thread never returns
like what's the unit test for that
what's the generative test for that you
I mean you can't do that so we were
looking for more options the static
typing doesn't have to be terrible a lot
of people when they say oh I don't like
static typing what they're with a lot of
the times they'll say in their head you
know I don't like Java typing so let's
go through some of the things that can
change so there's a lot of emotional
baggage about static typing and it's not
very the terms aren't very clear so it's
just different you know like any good
closure talk will define our terms
so rather than static and dynamic let's
talk about implicit and explicit so you
know closure prospective at say is
implicit implicitly typed
and everything has a type system you
know because I one definition I heard I
liked was of static typing was the
author's expectation of types at runtime
it's like well that's not written down
anywhere so so we have implicit versus
explicit types you know Java is
explicitly typed because on every single
function you say it takes an int and
returns an int right and then before
before spec in closure you would just
say oh it's a function and maybe you'd
write something in the dock strings then
another axis we have is mandatory versus
optional you know again in in Java every
single every single function has to be
typed so that no say it's mandatory that
you type everything and then the third
axis is just is the Express is the type
system expressive it not enough you know
can I can I write down the things that I
want to to prove or the things I want to
require then finally a structural versus
nominal so an example of a structural
type would be like in Java of you know
the user class you know capital u and it
has these fields so then that the type
of that comes from the fact that it's a
Java class with name user as opposed to
like within spec when you have s keys
you say this is a map with these keys in
it
so then any map that happens to have
those keys in it is now de-facto a user
so the closure version there is
structural typing because you're looking
at the contents of the thing to decide
what type it is and as I said it really
everything has a type system it's just
whether you wrote it down you know you
can you know imagine you're interpreting
a closure program in your head you know
there are types there it's like this
function sometimes takes an int and
sometimes takes a string well it's just
now we can express it with with spec so
continuing with the arguments against
static typing so compiling often complex
performance and correctness you know so
people say oh I want a compiled static
language
and there's kind of two different
concerns there one is I want a fast
language and the other is I want correct
code but you know if you don't have to
use you don't have to use types when
compiling right we can we can compile
code that's just you know function takes
an object and returns an object that's
what Java or that's what closure does by
default you know technically it's
compiled we emitted bytecode you know
technically correct of course that's not
what people often mean because when they
say I want fast code you know typically
when they say I want a compiled code
they mean I want fast code and it's just
two or three orders of magnitude easier
to you know to emit bytecode with the
types in it so then you avoid the you
know the runtime check of oh is this
object a string okay then I can call
this method on it
so if we if we compile the code with
type tags it gets so it's it's
significantly easier now of course now
we have you know VM or v8 and the JVM
but writing those things to get them to
the speed was you know man
decades probably so now that we've
alright so the point I want to make
there is that we can separate these
things and we can think about
performance versus correctness and which
things you actually want and why are we
doing this so I'm gonna make the
probably directionally true but not a
hundred percent statement that Jabez
type system is more concerned with
performance and correctness and that
Java's type system exists to make java
run fast they're not there and they're
more concerned about making Java code
fast than about ensuring the correctness
of your programs so when you think about
oh I want a statically compiled language
you know for code correctness you're
probably not getting that right now as
we all know Javas type system isn't very
expressive and then of course it's
mandatory like if you saw a language
that enforced you know
100% docstrings on every single function
in your code base you get grumpy about
that
you know oh I have a hundred percent
generative testing on everything even
the account settings page on the UI like
that's kind of silly so of course when
you get to that with you know with your
type system oh oh static static types
are making my code more correct but
you're stuck in this situation where
it's typically not very expressive and
you have to use it everywhere so it's
not not the great not the best so let's
talk about closure spec first I'm gonna
be clear I'm not trashing spec I think
it's good I think you should use it
again
you know consider the context but I want
to talk about the trade-offs mainly to
talk about what spectrum does
differently so instrument you know you
it recompiles your functions you use it
at runtime it's not recommended for use
in production so then you use it at
development time and test time it's only
as good as your test coverage right so
if you have you right let's say you
write specs everywhere and then your
your unit tests only run half of your
code it's not gonna check the other half
that didn't get run you know those
assertions won't get checked it's
unlikely you'll ever hit a hundred
percent coverage yeah
just because the vast majority of code
bases never get anywhere near 100%
coverage and test it doesn't check
return types and then the the checking
is weaker than generative testing so an
example that we have you know good old
function foo and we have two two types
two specs for the same function here we
can see the top one food takes a map and
returns a string and in the second case
it takes a map of keywords that has to
have a keyword bar and returns a string
now if you're only doing an instrument
testing the first the first definition
will will pass the second definition
will only get caught if you run
generative testing or you spectrum
and this matters because it allows spec
to lie to you you know you you have to
run generative testing to get the full
the full strength test so you know if
you're shipping specs in your open
source libraries I recommend using
generative testing gender testing so
then we use it a test on you know use it
at the repple use it at your CI it's
thorough like you know you run a million
different things through it it will
catch bugs when downside is it's slow
you know if you can go from you know a
fast unit test might run in one
millisecond and I typically see 30
second tests on the single on a single
simple pier function generators can be
very hard to write so let's talk about
that the generators are best when you're
testing fast pure functions if your
functions aren't fast or they aren't
pure you're probably not gonna have as
good of time writing generators is
sometimes hard and some examples that
impure functions anything with side
effects so database connections third
party API is that you don't control slow
IO protocols so you know you say this
function will take anything that
implements protocol foo it's like well
any thing that implements the protocol
foo you know so you can you can add for
example you can have a bug in your
generator where you only return things
that implement foo and bar and then you
call you know you take your instance
then you call accidentally call a bar
method on this object it won't catch
that the other thing it won't catch is
that you know protocols are designed to
be open dispatch so then if your
generator only generates you know one or
two instances of this thing you know
you're you're probably you're not
getting full coverage on everything that
could be called with that protocol
webdriver
this was fun thing I hit so I'm my
current project I'm doing some selenium
webdriver
so I had you know I'll try spec and hold
write out all the
i SPECT all the methods so I had this
thing that's you know give it a
configuration map of oh I want a chrome
instance running on Linux and then it'll
spin up an instance of selenium of this
class but the problem is the when you
create an instance of this class it
spawns a instance of google chrome and
then your generator does that you know a
million times a second so so this was
with me hitting controlled queue as fast
as I could you know trying to keep
everything under control and it's like
wait a minute this is funny I should
take a picture of that and then finally
you're the test coverage depends on your
generator coverage so in instrument when
we're looking at instrument we saw that
the the coverage depends on your unit
tests and in generative testing the
coverage depends on how good your
generator is exercising all of your code
now again I'm not saying don't use
generative testing it's good and it's
useful in a lot of situations it's just
not the answer for every situation
so it's also worth pointing out that
Haskell you know popularized generative
testing it's like they have the static
strong static type system and they said
you know what we need generative testing
so you know neither of them is enough
and even together there probably is
still not enough okay so the spectrum
trade-offs advantages it's faster than
generative testing it has broad coverage
so it'll analyze every branch of your
function it analyzes all returned paths
checks all protocols reads correctly it
can be more strict so it can check Java
Interop can check the contents of VARs
you know so we can do alter of our route
and binding check the contents of atoms
you know like swap and you can write a
spec for you know this is an atom of a
map to it you were doing int and
contents of Cori sink channels oh so
point out the bottom of three here are
speculative the Java interrupt stuff
works these three could work
the code map and higher-order functions
this does work and I'll show an example
of that and then a thing I really want
to do is translate pre and post
conditions into specs and then
statically analyze anonymous functions
because right now there's not a
convenient way to to do that inline
disadvantages it's viral so once you
start checking you know if you say
statically analyze this function every
function that you call inside of it must
be tight I handle that as much as I can
and I try to make it as optional as I
can but if you have something that
doesn't have a spec then it's like well
the output of this previous function is
unknown and then you past unknown into
the next function you know what is that
gonna do you know so I'm gonna try to
make that configurable but at the end of
the day you're not going to get good
results unless everything is typed this
totally does slow down development time
anybody who says static typing is faster
is that they're not right
I had I spent many nights writing
spectrum where the tests were green and
I was trying to add new types or trying
to add new specs to the code and
wrestling with it it's like wait a
minute
all my tests are green like what how is
adding this type going to solve my
problem in some projects and some
namespaces that trade-off is desirable
so one of the great things about
optional typing is that you don't have
to add you don't have to put it
everywhere and you shouldn't put it
everywhere you know but like with the
LXE thing you know we can check only
that namespace you know we couldn't unit
test that namespace because we're
couldn't run that stuff but this gives
you an option to put to make some parts
of your code more strict and that is
useful the other downside is
implementation complexity a type checker
has to know every aspect of the closure
semantics I
I wouldn't say learned new things about
how closure worked but it definitely
reinforced some details and oh I didn't
know that was in
that way so riding a type checker was
definitely a learning experience I
recommend it
and then finally some legal specs are
harder to type so we have foo again this
this time it takes in two even numbers
and returns an even number and we're
just doing a simple ad so we can make
this type check but by default it won't
because you know of course the spec
doesn't know you know the properties of
even numbers and it doesn't know that if
you had two even numbers you get an even
number back
we can teach it this but that's
something you'd have to teach it so now
I don't expect this is gonna be a
problem in the vast majority of the time
you know I expect I'm hoping that like
90% of specs that are seen in the wild
will check as is but there will be some
small things that will have to be
adjusted so let's get into how I did
this so type checkers aren't that hard
so it's really it was a four-step
process so it's conform tools analyzer
flow and check so conform is a
reimplementation of closure dot spec the
differences spec takes value conforms
values conform or my conform works on
literals and specs so I this function
par spec that turns a closure that's
back into my and call them spec T's you
know respect because it's speculum sorry
for the puns but uh so you know can't
conform you know is this an in three
that works but then this the second line
normally you would expect to see you
know a value or a variable you know does
this variable X conform to Spectras well
we don't have that at compile time at
compile time we have literals and other
specs so then we can say yes this end
conforms to an int and the rules for
deriving adders not that hard you know
that's an spec and or spec and that's
you know standard standard logic there
so then that means you know I have to
know how to parse all of closure dot
SPECT
so the second step as tools analyzer
thanks to that everybody who's worked on
that this was complete lifesaver
excuse me so we take the analyze form
you know so here's just a simple string
three and so you know he takes any
quoted expression and returns data so
here it's you know it's saying oh we're
invoking a function the function is the
VAR closure dot string here are the
arguments here are the arguments passed
to the function and this works on
anything takes depths you know takes
namespace declarations everything then
it the main thing the more the important
thing here is this op invoke you know
there's like twenty op codes or
something if you go to the github it'll
show you all of them you know local
variables function parameters everything
so they're all disclosure maps and it's
all just data so the second step of the
process
I'm calling flow so it just walks the
tools analyze your data and attaches new
metadata in places that I care about
importantly it attaches this returns
back to every expression so we this is
the same output but now you see there's
on the function there's the spectrum
flow FN spec and then so that's we've
looked up the spec for string I've made
up specs for most of the closure core
stuff until they the official ones get
shipped and then in the arguments you
can see oh that's a constant so we use
this we use this thing called value
three so that's a spec representing a
literal value and then we can see the
return expression there turn of at the
bottom here the return SPECT is the
result of calling the string function
result of calling string function
returns a predicate you know a thing
that's string because that's the return
value of the function so then slightly
more involved example you know function
foo takes in it returns an int so we
take the we take the input spec we D
structure the function arguments so now
we know that the X in the function
parameters vector is an int
okay then we get to the let block we say
okay start on the right-hand side get to
that dad that inner X on the the inner X
inside the ink we walk up walk up the
tools analyzer you know it's this big
nested tree that you can't print when
you have a big thing like this so walk
up to that and find the X in the
parameter vectors say oh that's an int
so then the lower X is also an int okay
ink on an INT is an int so then we
assign Y to be an int and then on this
on the lower Y we say oh well walk up
until we find a variable that resolves y
okay that's an ax let block that has it
has a speck of int so we're gonna return
an int or you follow that it's it sounds
annoying but at the the algorithm is
actually pretty simple
so then checking is just walk the tree
again and we just call conform on
everything so this is the spec to
conform rather than closure at spec
conform so we can form that function
that the inputs to a function conform to
their input arguments and we conform
that the the return value of like a
function definition matches the last
expression in the body you know it's
it's just run conform on all the things
so closure you know we use a ton of
higher-order functions and so I thought
that a a checker that didn't account for
higher-level function higher-order
functions was going to be not very
useful so we have this you know we have
mapping range five here so you know take
the numbers from zero to five add one to
them what is the return type of that so
this is my my my closure that spec into
an interpretation for what map is gonna
look like of course this isn't official
you know this is just my best guess at
it and it says it takes an argument
that's either a function or a keyword
and then
it takes zero or more seeks and then it
returns a seek or function and that's
about as good as you can get with the
current spec grammar because you don't
have logic variables and but you know we
have we've all used map before and we
know that you know map takes a function
of in core type notation this would be
map takes a function from X to Y it
takes a collection of X's and returns a
collection of Y's and then you know that
the function has to accept one argument
and you know that the input to the
function has to map the type of the
collection we don't really have a good
way to express that right now
and we don't have a good way to express
the transducer case in court typed
either so solution for that and calling
it transformers so these are so spectrum
is pluggable mostly I'm hoping you don't
need to plug in to the types of so much
but trying to make the power available
there so transformer is a hook into the
checking process for a specific function
so if you if you're checking a namespace
and you have you know ten calls to map
you're going to get called ten times
once with the exact arguments to that
specific call so you get the original
spec and then you got your job is to
return an updated spec and you can do
all kinds of fun things here so in this
case in our map example we can look at
the type of the function they passed in
and they look at the type of the
collection and then say okay well based
on the output of the mapping function
the output of the map has to be a
collection of the of their turn thing
and then the based on the input of the
mapping function the collections all
have to be this type and then you know
if you get past you know three three
sequences you can say oh well the
function needs to take three arguments
now and this is done during the flow
step so then that means that the
check-in will just work automatically
this is pretty cool
so we can check the type of this and it
says it is a collection of class long
the reason for that is if you pass the
reason it says class long there it's ink
is polymorphic so if you pass it along
you get back along if you pass it a
double you get back a double so in this
case it knows range returns a collection
of intz I passed an int to ink so I get
along another cool thing I can do is
about branch prediction so we have this
function you know maybe ink so it takes
it takes an argument that is maybe nil
or maybe an int and then returns may be
nil maybe in it and so on this ink here
if you pass into a null two that that
would be that would be a type error
right because you're not allowed to
you're not allowed to Inc null so when
we go through the if statement if says
if X so you know if we put on our you
know closure if at the interpreter in
our head that would say indeed then
statement X is true or X is truth E and
in the else statement X is policy so so
this already works it will update the
types on the then and else branches and
it will also recognize it'll also
recognize predicates you know so like if
you had if int or if string or whatever
that enables that right now so earlier
in the hallway to Gary asked for a slide
on edge cases so where's Gary there we
go so let's talk about even you know so
even as a closure function you can use
it as a predicate so how do we you know
how do we handle the case of can I pass
an even to an int well it turns out if
you look at the if you look you know
even the even the function only accepts
integers so then you can look at the
definition of the integer function to
see what else can it take so then we
know that just for free we know that if
a thing is even it also I can also pass
it to any and I can also pass it'll
it'll work anywhere I can pass any and
it'll work anywhere I can pass image
and then for the closure implementation
I had to do some extra magic to say you
know there are things that are true in
closure that don't appear in dot clj
files you have to go digging around in
the in the Java files and so if a thing
passes integer that means it is it could
be any one of these java.lang classes
you know could be java.lang into long
whatever so i don't expect you'll need
to do much of this and incidents or so
I'm not going to talk about it because I
expect that's only gonna be limited to
the closure core dealing with things in
closure core user code shouldn't have to
mess with that dealing with covariance
so this was a real thing that I had to
deal with or I'm still dealing with this
code is in progress but I'm pretty sure
I can make it work so the output of
tools analyzer JVM that's as a JVM
analysis thing you know it's a big it's
that big nested map and I have I have a
big nested I have a big spec for that
and then so that's in the first step of
the complet of it the flow process and
then after I go through flow it's like
well it's an analysis but then it should
also have this returns back but then you
have these functions that say oh I
passed in and a tools analyzer analysis
and I get out a tools analyzer analysis
but if you look at the source code this
actually doesn't care whether it gets
which kind of analysis it gets it's if
this key is here I you know I do ref the
key and you get the thing so it turns
out without covariance this is not very
useful because it basically without this
it would implicitly downcast your
functions you know because I passed in a
flow analysis but then it says I'm
returning in a tools analyzer analysis
and that doesn't have these keys so
though the way to fix that is to do the
flow again with the new arguments you
know so when we did the original flow
process like with Inc X that we saw you
know we say oh the first argument is an
int well in this case you know first
arguments
- as a tools analyzer and then we'll run
it again with a flow analysis and see if
the return value is different if their
turn value is different than you can use
it
so understanding spec this doesn't work
yet but it should be very easy to write
you know so this is the problem that
everybody everybody ever has complained
about you know I get a random thing off
the wire you know the user posted me
some arbitrary code you know what is it
and how do i how do I pass that into my
clean well typed code well the answer is
so you know here we have the JSON read
string and then I want to say if that's
valid data then call called stuff that
uses it
spectrum can very easily be modified to
understand this you know because we
already do branch prediction we already
understand other predicates so if you
have any any closure core predicate and
actually any predicate that's used you
know in types
that'll work now but it doesn't
currently understand you know as valid
and Eskin form but that's an our patch
so getting closely on this the awesome
about this types equals code equals data
is amazing
most other type systems will start with
a much more limited type system I didn't
have that flexibility because you know I
don't control spec and but the important
part there is so spec is just arbitrary
closure code so now I'm using arbitrary
closure as types I'm sure the I'm sure
the academic programming language people
will tell me this is you know a complete
nightmare and you can't prove anything
they're probably right about you can't
prove a hundred percent of things but
you can prove a quite a bit of
production code and that's useful to me
you know so I'm sure they're going to be
I'm sure they're going to be things that
are true that I mean it's already the
case that we deal with code that it's
true that you can't prove and now that
limitation will also apply to the type
checker but I'm okay with that
this also introduces dependent types
so--that's types where the where you can
have data as part of your type so for
example a standard you know the one on
one example of this is I have a list of
length 10 you know
so now length 10 is now a part of your
type so then you can do things like this
function takes a non-empty collection or
this function takes a collection and
returns a another collection of the same
size this is incredibly powerful and
this isn't just limited to spectrum like
this is a thing you can do with spec
today I think it'd be really gonna be a
really cool talk next year of you know
all of the crazy types you can come up
not types but like constraints you can
come up with inspect that are actually
useful you know so you can say did this
function you know select sort it's
really important that your function
returns a list of the same size so going
forward I wanna say don't we shouldn't
feeder static analysis you know there's
this static you know static typing is
the boogieman kind of impression in the
community sometimes and I think that's
overblown there's all kinds of fun
things we can build with tools analyzer
you know does this function throw does
it scale you know is it is it fast is it
pure that referentially transparent you
know Rich's talked yesterday about you
know what are the dependencies for this
function it's like we can we can start
proving that we can say this function is
pure and it doesn't depend on anything
else so you know if I really wanted to I
could copy the implementation into my
not copy but I mean like I can use this
implementation as is and then if some
other part of the app uses a different
version of that function it's totally
fine because we've proven that the two
don't interact and then there's like
initialization kind of things you know
is foo only ever after called after bar
you know like you always say basically I
think when you when you read the docs
strings about you know only do this
after that those are usually areas where
we can probably do better as programmers
in terms of
you know constraints because I'm gonna
try to avoid using static typing as the
boogeyman so yeah so optional static
typing can be effective it's not
appropriate in all projects all the time
it's not effective in 100% of your
project but it can be useful in some
areas home I don't know I don't the term
is for using closure data and functions
as types but it's very cool yeah thanks
everybody who did worked on spec and
tools analyzer I think we have time for
questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>