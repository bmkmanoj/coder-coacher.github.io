<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Production Ready ClojureScript: Tales from the Frontier - Paul deGrandis | Coder Coacher - Coaching Coders</title><meta content="Production Ready ClojureScript: Tales from the Frontier - Paul deGrandis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Production Ready ClojureScript: Tales from the Frontier - Paul deGrandis</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1zdzivUmL4s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for everybody that helped pull
together and put on the Khans it
definitely shows this is an extremely
fun and engaging event and it's
definitely an honor to speak in front of
a crowd in a community that I admire and
respect so much there's a lot of great
faces here that I love seeing every year
so without further ado i am paul de
grandis and i'm going to be talking
about production closure scripts and
it's it's really my lessons learned from
building and shipping production closure
script applications I want to motivate
the beginning of the talk with a
question what makes closure great so
this very handsome gentleman right there
stunning said that closure manages risk
better than any other technology indeed
we see that closure is really built to
tackle the systems and the complexity of
the systems that we face today its
closures opinions as a language its
features its culture its community there
are all driven towards managing and
minimizing risk and complexity and its
closures Holy Trinity of simplicity
power and focus that are really the
driving factors behind that we all know
this of course but this question is
interesting in the light of closure
script do the advantages that we find in
closure translate to the areas where
closure script lives right nobody's
really asked that question does closure
script solve the same incidental
complexities as itself new complexities
is a closure script actually a terrible
idea and you can't really build stuff
with it right we haven't seen any real
data or real stories about this so
that's what we're gonna do we're gonna
constantly come back to that question
throughout the talk we're gonna look at
a case study and some metrics around
that case study will look at some
compelling features or ways you can use
closure scripts as well as the risks for
adopting closure scripting of production
system things that I got bit by and then
we'll go sort of through like a
validation process how I validated
whether closure script was appropriate
for my team and my project and how you
can evaluate closure script and see if
it fits your team or your project or
your company and then we'll sort of pull
out and look at different options
strategies and architecture decisions
that you can make because of closure and
closure script that you can't really
make with other systems and we'll drill
in on those architects
look at things like code organization
software design patterns other concerns
in the small so that's pretty much what
we're gonna do and just on the surface
closure script has some really
compelling features like you get proper
namespaces and you don't have to deal
with the idiosyncrasies of JavaScript
alright those two things alone pretty
compelling and then there's these like
meta reasons to adopt clear description
all right like people say JavaScript has
reach what does that really mean though
for closure script
well here's IBM ThoughtWorks technology
radar from October of this year just a
month ago and there you see it's advised
you adopt closure which is pretty cool
because now we're being told that we can
get into the enterprise and I guess Neal
Ford's probably excited that he
generated this exact graphic and and
then here are all the things that are
related to JavaScript so just because
closure script exists we can inject
closure into the conversation of all of
those pieces on a technology radar so we
went from one little blip to cascading
across the entire technology radar and
we can go ahead and start dominating all
those areas if we want to but I want to
talk about two other features I really
like about clear scripts and they're not
super obvious and they're not
particularly sexy but there's that they
make real impact and that's a closure as
a data format right using Eden or the
serializable chunk of closure as a data
format has baseline advantages over JSON
right you can capture things like
keywords sets things that you just can't
capture in JSON but with reader literals
the notation can be extended into your
problem domain you can capture the real
intent of the data in your problem
domain because you're using closure as a
data format and and that means a lot
right when you don't have that what
what's the outcome what do you have to
do so you end up encoding all of these
special meetings inside of JSON and then
you go through what I call the double
bar stance which is you take a JSON
string and you parse it and then you
have all this logic and machinery to
parse it again to pull out all this
special meaning it's total nonsense and
it's just incidental complexity that
we've become accustomed to but with
reader literals that whole problem goes
away it doesn't even exist anymore and
that has pretty serious impact closely
related to this is the reader in closely
to the reader as the printer this is one
of the reasons why homo iconic languages
languages rock so hard right I can
serialize anything ship it around I can
change the relationship of where I want
to put data and where I want to
interpret that data so what is the
closure function taken right close your
data and what is it return close your
data in that closure function itself
well that's just closure data
so having closure script in all of these
places that JavaScript has reached means
I can start shifting around those
relationships however I need to solve my
problem this leads to a very cooperative
Interop between closure and everywhere
that javascript has reach because of
closure scripts so when you combine
these two things with proper namespaces
and macros you render a system like
meteor j/s completely obsolete right
here's a company that had to raise over
11 million dollars to approximate the
technology that closure and closure
script are giving you out of the box one
of your goals in developing your
production system is ensuring that you
can always outmaneuver your competition
well this is a pretty good start right
this is flexible you can apply it
however you need to but more
interestingly we're seeing that some of
the advantages that we find in closure
are translating to closure script right
we're solving similar incidental
complexities but we're also solving a
whole new set right tossing problem
domain data back and forth has real
representation
so if complexity breeds complexity while
closure scripts a good way to start
removing some of that well let's see
what kind of impact that has on a real
project so the system here is the exact
same system between both of these stacks
it's a very simple web interface on top
of a search application there's a role
based authorization going on on both of
these stacks the same team built both of
the stacks and there's great library
support obviously for both stacks so the
first stack is written in Python and
JavaScript it's deployed on top of nginx
that's acting as a reverse proxy so it's
shooting out to a bunch of application
instances the server side alone is 17
Python classes it holds 56 functions it
took one month to get to a feature
complete usable prototype and it took
three months to ship a pretty
system it was later ported over to
closure and closure scripts that's
deployed on top of jetty the server side
alone is four namespaces in nine
functions if we throw in the closure
script just for the sake of it that only
goes up to eight namespaces and 21 total
functions it took one week to get to a
feature complete usable prototype that
we were iterating on and one month to
ship a production system now I mean this
example is not huge but it is the
baseline example for a web system you
would build it has roles it has user
accounts it does some action like
searching and showing search results so
this is definitely a great candidate to
try close your script out on
interestingly enough the average
cyclomatic complexity per function is
consistently lower on the closure and
closure script side and at some points
in the heaviest piece of business logic
specifically around roles it's almost an
order of magnitude lower on the closure
enclosure script side so serious impact
there but we're seeing that any measure
of sort of complexity that you take how
long it takes to grow the system how
long it how big the system is the
maintainability of the system the
branching complexity of the system it's
consistently simpler on the closure and
closure script side and that has obvious
benefits if you're shipping production
systems but there's also some not so
obvious benefits to this effect and a
recent paper published called software
needs seatbelts in airbags a study was
concerned or wanted to investigate
rather if capers Jones's case studies
still held if we're still seeing the
same number of defects in systems and
despite our best advances in unit
testing and static analysis at least for
Java and C++ projects the defect removal
efficiency before delivery is still 85%
right so we're going into production
with our systems with 15% defect still
in there the total cost of repairing the
remaining 15% is approximately on
average one third year total budget and
one third year total schedule still the
study still found that capers Jones's
numbers are pretty accurate and the
study goes on to conclude that the major
root cause to the
fifteen percent incidental complexities
for C++ that's manual memory management
and it was a great study but what we're
seeing is that the intuition in the
insight in the tarpit paper we're seeing
real numbers behind that like this has
real impact for production systems and
we're not going to change that 15
percent anytime soon that's going to
involve process change and tooling
change and approach change but we can
make it 15% of eight total defects
instead of something like 15% of 80
total defects all right and these are
convincing reports and the paper is very
good I suggest you dig it up but the
benefits have to be weighed against the
risks and they are there are risks to
develop our adopting closure script so
clojurescript is young it's just over a
year old by a couple of months the
development cycle for closure script is
extremely fast and really really short
that's because David Nolan I don't think
he sleeps and I do my best to keep up as
well and so if you if you work for an
organization or you're on a development
team where you need to lock in that
dependency and it can't change like
maybe close your script just is not the
fit for you because you're gonna want to
keep updating that changes that are
important you'll find that as you use
closure script and you sort of push it
to its limits there will be missing
protocols or missing library support
that's the most common problem right now
that you'll find is you go to use
something and there's just no protocol
implementation for what whatever you're
trying to use metadata tends to get a
little tricky at certain parts but
that's super easy to fix right because
the decision was made to implement the
majority of closure script and protocols
so you can fix that problem directly in
your project if you need to so there are
ways around this highlighted at another
talk was the exceptions now I don't
think the exceptions are that bad but
the caveat is you really do need to have
JavaScript knowledge to understand
what's going wrong when you see an
exception and there's no way around that
right now I don't think there will be
but if you really want to understand the
exception you have to really understand
what's going on with the JavaScript and
closely tied to this
the the debugging story foreclosure
script is fairly weak or non-existent
and your depends on how you interpret
that but the best combination that I've
found is a combination of browser repple
to hold some stuff together and
investigate and just usually the
debugging tools in the browser so
Firebug and Firefox or Chrome developer
tools in chrome again though in order to
really debug your closure script
application you need to have knowledge
of JavaScript in the tooling around it
so you need to be aware of that the
interactive development that you have
come to love in closure does not
translate 100% over to the environment
in closure script the browser Ruppel is
pretty cool but it it's it's not going
to be the experience that you are
probably expecting this is not really a
problem in my opinion when I develop a
closure
script application I would say about 70%
of that application is actually written
in closure using my closure environment
and only when I'm doing something
browser specific or node specific have I
switched my environment up to be a
closure script specific and I think that
that works out great for me you'll also
find some oddities they're not really
necessarily problems but there are
oddities and developing closure script
applications like the Google closure
library is written in two very distinct
styles and it's not really a problem
once you realize that there are two
styles to the libraries but there are
two styles and so you might get caught
up in figuring out am I dealing with you
know a chunk of the library in style 1
or in style 2 so those are the risks
that I really think exists in adopting
closure script and you need to sort of
evaluate these trade-offs with the
benefits so you've got to go through
some sort of validation phase right and
you just have to ask yourself a couple
of questions and the questions are
pretty simple like who I don't know why
that got dark but is this good for the
company right no don't ask that question
what are the quality attributes that
you're really shooting for right is
there some expectation for the latency
of the system or how long it takes to
get things back and forth in the system
or the throughput right
or the encryption does something need to
be encrypted and if so how strong and
when or the security do you need
role-based authorization or not and then
what about the adaptability what are the
expectations on how often you need to
change that system or modify that system
or the evolution of the system right
like how long does this system have to
run for is it only going to be around
for a year is it going to be around for
ten years those things matter especially
if you're going to be adopting a
technology that's going to be growing as
you're adopting it and what about the
system constraints the actual functional
requirements of your system right what
types of data do you have to handle what
is the data specific to your problem
domain that you have to model or what
interface are you expected to build is
there an API involved or not
what about deployment what's the story
around deployment or are you limited to
only certain types of technologies right
can you only use certain types of
technologies in your organization and
then just take a huge step back or fall
into a hammock of your choice if you one
one and ask yourself what's your biggest
problem what's the biggest thing
standing in the way between you and
shipping something today right now and
really capture that write that down and
and write down where you're wasting most
of your time and most of your money and
where you're making most of your money
right if money is your measure of
success for some people that might not
be but you know where are you spending
your resources and where are the areas
that you're sort of uncertain about
stuff or you seem like it's fuzzy or
you're a little scared of it or whatever
right write down where the risks are
happening and I'm sure you're writing it
down because if you don't double
facepalm and you don't want to let
Picard down like that and Riker poor
Riker and then just ask yourself why
right why would I use closure script to
solve this problem what does it give me
why not use technology X or something
else find that trade-off find that
balance if you have a hard time
answering why for closure script flip it
around answer why not use the power of
inversion and see if that helps you find
those answers you need to ask yourself
why three times in a row this trick
works great so I'm sharing it with all
of you so ask yourself why three times
and the answer to that third why is the
real answer that you're looking for and
it should loop back to a quality
constraint I will give you a real
example
so why close your script
well I need namespaces okay well why do
you need namespaces well namespaces help
with organizing managing and sharing
code it's also a lot easier for
newcomers to come along and sort of see
how the project is connected and sort of
work through the project okay well why
is that important well our biggest pain
point is maintaining projects we don't
have a problem shipping projects we can
ship projects but our projects has to
have to last a long time they they live
for over ten years right and we're
constantly rotating teams and rotating
on projects so we really need to
optimize for ramping up on a project
perfect those are all quality
constraints right those are all quality
attributes you want to shoot for so this
is a real reason for adopting
clojurescript if you don't get to that
third why it's not a real reason start
on something else so do that right and
that should sound pretty familiar it's
just a slight different interpretation
of the hammock driven development right
you're just asking yourself these
questions to really validate your
understanding and your learning and
let's see how this gets applied in a
real system right let's take a
hypothetical architecture of that case
study so here's a really simple box
in-line architecture and I the
architects in the room if there are any
are like crying that this is not a
standard diagram of whatever but it gets
the job done right so a request comes in
it hits this web server that's acting as
a reverse proxy that's shooting out to a
bunch of application instances those
instances are fetching data from a DB or
des Tomic or whatever you know doesn't
really matter and then they're mashing
it together with a template to build
some responses and those responses are
going back and this is cool it gets the
job done responses are hitting clients
except that the traffic for this site is
extremely spiky and the spikes are not
predictable and at the top of these
spikes of traffic we can't handle the
read load right it's probably due to
this unnecessary dynamism the data is
not changing that much and the templates
are changing that much but we constantly
have to recalculate all of these
templates for every response the biggest
pain point the biggest problem is this
design - template dance so these
designers that we have generate this
beautiful HTML in this beautiful CSS and
then it gets shipped to us developers
and we have to spend all this time
turning through it to turn it into a
template unless all this template logic
through it before we can actually use it
in a production system so just a it's a
big pain we waste most of our time on
constant SEO updates from business
operations business operations always
come in to us banging on our door saying
we need to change something for SEO
purposes that's because that's where
we're making most of our money also we
make our money from organic search leads
coming in to the site a year ago for
this hypothetical site mobile traffic
made up 12% of all total traffic on the
site and currently at this point on the
hypothetical site it makes up 25% total
traffic so Mobile is growing extremely
fast it's the fastest growing segment
but we're not really doing anything
about it right these are our problems
these are the things that we really need
to solve so what do you do right what's
the first thing that we do in any web
developer that sees this problem just
says like oh well let's just cash right
let's just handle the Reid problem for
right now well take all the static
resources we'll shove them into a CDN
we've probably should have done that to
start with anyway we'll go ahead and
cache some stuff that's really helping
right we can handle all this Reid load
now except we still have that to assign
to template dan sweet we haven't even
done anything to approach that problem
and there's still constant SEO updates
Mobile is growing faster we're not doing
anything about it even though there's a
cashier that unnecessary dynamism
problem is still there we're just
band-aiding it with a cache right we're
just sort of masking it we're not really
getting around it but worse we've
introduced a new problem and it's a
pretty serious problem we've introduced
serious cognitive load every single
single time a developer has to jump into
this site they have to think oh is this
defect happening because the cache or
not right or does this new feature need
to invalidate something in the cache or
not so let's take a step back let's
totally scrap this this is nonsense
we're doing things that are don't even
make sense let's take the lessons from
our community what if we just assumed
immutability right this is like Rich's
number one so what if we assumed
immutability what if we baked the entire
site and it was completely static
and during the baking phase we pulled in
all this SEO content from a third-party
data store and since we're on closure
now let's just assume closure and
closure script why don't we use
something like in live right then we can
take the raw HTML and the raw CSS we can
go ahead and use it directly from the
designers so that goes directly into
production and since everything is
static we can shove everything into a
CDN and we can change the DNS a name
record for WW to point to the CDN so now
almost all of the site is being served
directly out of the CDN but we've
introduced a new problem and that's user
experience right you if you saw a site
that was static and littered with SEO
specific content and you couldn't really
do much with it and it didn't feel vibey
you would know it would be a terrible
experience so how do we fix that problem
how do we fix the problem where things
actually do have to be dynamic well we
can use closure script and we'll use in
focus on closure script and reuse all
those pieces of HTML that are still
living in a CDN right and then we can
make parts of our site dynamic and so
this is pretty cool so far we're fixing
a lot of these problems that we have and
during the baking phase we can also
optimize for mobile we'll just go ahead
and do that while we bake so we fixed
that list but we can do a little bit
better let's pull things apart right
here's lesson number two from the
community pull things apart what if we
just pull that search server right on
out we can get rid of that and the
results will go directly to the client
and we'll go ahead and reuse all of our
dynamic closure script pieces and
incorporate all that so this is all
closure data now right my server is only
going to serve up closure data for
dynamic stuff the search server is only
going to serve up closure data to be
incorporated all the problems go away
because I'm choosing immutability for my
site and where we fix all these problems
but we get a lot more to write this new
decision can handle more read load it
can handle more write load it was
cheaper to operate for the hypothetical
situation and it was much quicker to
modify so we could incorporate changes a
lot faster the outcome is clear right
question
your habits question what you're
actually doing investigate history
assume immutability if that helps then
apply it whatever that means for your
problem apply it to the context pull
things apart question what can be done
here and what can be done there suddenly
we're playing around with the
relationship of the dynamic logic being
directly in the client and only serving
up closure data and that's very powerful
so let's go ahead and just dive in on
this and we'll see how the code might be
organized right so I'm going to advise
for the majority of applications we stop
choosing directories like CL J in CL Jas
because they're not telling us anything
right let's be architectural II evident
with the way that we're organizing our
code and let's still apply the same good
practices that we've previously applied
and be resource-oriented
so is that font super small for the
majority of people yes sorry about that
but it's locked in and you can read the
slides after hopefullly but we should be
architectural e evident the more you
blur the line between the client and the
server the lower that cognitive load
becomes and the more that you can use
your code organization to infer exactly
how that system is holding together
again that cognitive load comes way down
so if you look at just the top directory
listing if you can see it it says API
client config controllers routes and
server right if you just saw that
directory listing on a brand-new project
you would have a pretty good idea on how
that system probably holds itself
together and then if you look at the
full tree you'll see that the client has
flows main search in a view directory
right so flows is symmetric to routes
right flows declaratively open up
reactive data flows for the for the
client side just like routes sort of map
what's going to happen on the server
side so we're seeing symmetry between
these two things business logic on the
server side is obviously tucked away
into
controllers and business logic becomes
first class on the client because that's
really what you're doing you're doing
Rob business logic and manipulating data
on the client so I think this is one
approach to code organization again just
apply the same techniques that were used
to write be resource oriented and that
will get you pretty far another thing I
really like when I'm developing closure
script is the use of protocols and this
speaks really to the power of closure
scripts implementation and it was such a
well done design choice so we're all
familiar with protocols for those
viewing at home there's a wiki page read
it first pause the video and here's why
protocols Rock if you hit a bug I said
this earlier but if you hit a bug
enclosure script it's probably because
there's not protocol support for what
you're doing right like maybe something
doesn't implement I seek or some
printing function or whatever right so
you can go ahead and essentially monkey
patch or fix that bug in your own code
if you need to right you can always put
that workaround because the control is
inverted right you get to decide who
participates in a protocol and how but
this has great impact for the rest of
the system what if you want to make
local storage look like a transient map
you can do it you just have to extend
those protocols to local storage and if
you extend the protocols for printing
and reading those things to local
storage you can start shipping local
storage around back and forth between
the server and the client or multiple
clients whatever you want to do or what
about cookies right cookies should
probably look like a transient map as
well so you can go ahead and do this
right let's go ahead and make cookies
look like a transient map in fact this
is what one third of the shore-leave
libraries actually do it's just all
these constant protocols that we ran up
against like I don't want to actually
deal with the Google closure libraries
the way they're written
I want to write closure code and go
ahead and use higher-order functions and
map across stuff and I want to ship
things around back and forth
well you can do that because protocols
and protocols are also really great at
just capturing the core abstractions
that you want to model your system in
right the lesson here is Shore leaves
pub/sub so surely specifies two
protocols one called
message bus and one called publishable
and if you fulfill either one of those
protocols you can go ahead and define
whatever kind of message bus you want
for your system and anything can
participate in the pub sub system so you
can publish from function to function
function to Adam Adam to worker worker
to function any combination that you
want those are the ones I've provided
you but you can go ahead and mix and
match whatever you want and then you can
start building these reactive data flows
just because you have two protocol
implementations or specifications what
falls out for the quality attributes of
the use of protocols is adaptability and
modify ability people are often trying
to go after that when developing their
systems but what falls out concretely in
the code is that you have very loosely
coupled code and that the control is
inverted
for instance in reducers you don't say I
know how to fold all of these
collections you go to the collection and
you say you fold yourself if you fulfill
that protocol you go ahead and do it so
this has profound effects building
actual systems another tip I would
suggest when building closure script
applications in production is if it's
too hard to do in the client go ahead
and fall back to the server I definitely
agree that Ajax is sort of a hack right
it's sort of like a something you need
to carefully consider but there's real
power again I apologize for the small
font but there's real power and having
the ability to at any moment that you
hit a roadblock in the client you just
go ahead and fall back to the server so
the example highlighted here is we
needed to send emails to a bunch of
people and the email addresses are sort
of encoded inside of this page that
we're looking at so how would you do
this right well it's easy I'm just going
to go ahead and grab all of those emails
on the client side and then ship them
over and because of macro magic this
looks like a local function call right
well what's really happening underneath
is that there's C surf protected
and role-based authorization to send
email so that's closure data to the
server the email gets sent out through
mail gun the response comes back has
closure data and we treat it like
closure data so I'm sending a map
closure data I'm sending that whole
thing over to the server closure data
everything comes back closure data and I
can react on it I can do whatever I need
to do with it so be lazy if something's
too hard in closure script you either
need to extend a protocol or you need to
fall back to the server and get the job
done
that's just my advice if you want to
ship real systems also this isn't
JavaScript I think too often the trap
for closure script is that people want
to apply all these technologies or all
of these lessons learn from JavaScript
to closure script and closure script is
more closure than it is JavaScript if
you treat it that way your solutions
will be better you'll feel better about
yourself in the end you need to treat it
like closure just we already know the
problems that exist in JavaScript let's
not repeat them so I'll give you an
example there if you're developing a
node application you're constantly
dealing with callbacks and one potential
problem with callbacks is that you
stopped programming with values and when
exceptions happen they're not happening
in the contacts you actually expect them
to happen and you can't handle them when
you want to handle them so promises
write stack promises at the front of
your node application figure out all the
things you depend on and then program
with values through the rest of your
program and that has worked out great on
node applications in the browser I try
to throw callbacks as far to the end of
the calling chain as I can and so much
so that I will use the threading macro
and basically build up all my values and
at the very end becomes like this
special callback that does something
that is a great way to get around this
program with values apply all the
lessons and the techniques you use for
closure - closure scripts and when
you're not doing that question why
you're really not doing that and start
to shape your program in a way to allow
you to do that so here's the quick tip
list you know these are all the things
that I sort of said we're not going to
go
them again but I do want to say one
thing as I close here and that's the
more people adopt closer script the
better and better it's going to get and
the more sort of problems were going to
solve with closure script it's really
important for participation to happen I
really firmly believe in closure script
and my my goal in doing this
presentation was to give a slide deck
that somebody can take to a VP of
engineering or to a decision maker and
say look here are some hard numbers here
are some metrics here are some
techniques maybe we should try closure
script and and I really encourage you to
do that whether it's a hobby project or
something in production so without that
I've got a couple of minutes for
questions comments concerns anything yes
one of you yeah yeah so the question was
there are two styles in the Google
closure library can I give you a
description of them and they revolve
around how constructors are made in the
naming semantics inside of the Google
closure library again those are not hard
problems to get around but you need to
be aware that for some files the
constructor is named and the same as the
file name and is the top-level entity so
it gets weird when you start requiring
it or you start needing to use it in the
system the other style that's that's
buried there's usually like a making
function or a generation function and
there is no top-level entity that's
going to get in the way of a require
statement or whatever for the
constructor yeah the next question
mm-hmm
so the question was when you start
pushing more stuff into the client you
need to start versioning the api's that
are being exposed to ship closure data
from the server to the client and
specifically like that the data might
change throughout specific versions the
question went on to say is there
anything in closure closure script that
makes that easier I think closure has a
data format it naturally helps with this
problem but also I find in the
hypothetical situation again that it's
easier to get around that by versioning
your CDN correctly and so you serve up
CDN version stuff and that CDN version
stuff calls the server stuff again for
the baseline web system that you would
write it's so small enclosure enclosure
script that unless you were developing a
gigantic system of huge like over ten
namespaces I would just leave all of the
API calls in there and support all the
versions but unless that has serious
impact on your system question way in
the back
yes
yes so I right so the question is if you
have a lot of legacy JavaScript the
story becomes very different for
adopting closure script yeah it
definitely is very very different for
doing that I honestly do not have a good
answer my answer was that seemed so
daunting and backwards and I wanted the
semantics of closure that I just tossed
the JavaScript stuff away but if you
looked at how small that project was
like tossing it away is not a big deal I
can do it took me one week with the team
of three other people one week to get to
feature complete I had feature parity on
both systems so unless you have a huge
JavaScript system that you want to
replace with closure script which you
may or may not want to do right you've
invested a lot in that JavaScript and
it's probably hairy and it's got a bunch
of weird hacks in it but I would I have
no good answer for integrating closure
script into JavaScript I would just not
touch the JavaScript it's like a disease
any more questions yes how do I handle
differences between browsers this
question got asked at the bar last night
and I felt like my answer is more
colorful colorful because of the alcohol
but here's how I handle multiple
browsers Google closure does a pretty
good job at handling that problem as
long as you hit the right libraries that
you know reach far enough back to
whatever browser you need to support for
certain applications this is this should
be one of the concerns on the slides for
certain applications we just said no ie
will use will use Chrome Frame no ie and
that was our way around it and that was
acceptable because we knew our customers
very very well and we knew that that was
an acceptable thing our market share is
very small in IE and putting chrome
frame into IE is an easy solution for us
to get around but it really depends this
is one of those things that you have to
balance yourself against when developing
closure script applications but the
Google closure closure library helps out
a lot
yes that is true yeah yes
so yes the core library is completely
cross-browser but if you're developing a
serious application you're going to want
to bang on probably html5 things and
that's when you get into some hairy
issues it's trivial to do you need to
the question was what is the interrupts
story with other JavaScript libraries
it's pretty trivial to do in some cases
it's writing an external for the Google
closure library and then just creating
the right abstraction that you need
inside of your code to call the actual
JavaScript code it just turns into
regular JavaScript calls like you would
do for interrupts stuff I tend not to do
that a lot because Google closure the
library gives me almost everything that
I need and then whatever I don't need is
actually just me writing protocols to do
it in closure the closure anyway any
more questions I have maybe one more
that I can take and if not that's
totally fine all right thank you very
much oh wait yeah I'll talk to you later
thank you very much for those new class</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>