<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Clojail: Life in a Clojure Prison - Anthony Grimes | Coder Coacher - Coaching Coders</title><meta content="Clojail: Life in a Clojure Prison - Anthony Grimes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Clojail: Life in a Clojure Prison - Anthony Grimes</b></h2><h5 class="post__date">2013-01-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/juCIC0OsWI4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay important survey quick show of
hands how many people have seen the
movie The Terminator Wow
how many people have not seen the movie
The Terminator how many people don't
raise their hand no matter what happens
catch it so the idea I guess if you
wanted to think about that you know the
Terminator is really a story about ideas
and the idea is or the key idea is
machines get smart which is something
that I think that that we all need to be
worried about and I think that the best
I mean it's an idea that gets revisited
again and again in science-fiction and
the best in my opinion iteration of that
idea is in a now series I guess of books
by Vernor Vinge II including a fire upon
the deep and a deepness in the sky if
you've not read fire upon the deep and
deepness in the sky you should go out
and get them you might even set aside
your george RR martin stack of books in
order to read these books first also the
third book in the series is just out in
hardback sitting next to my bed and
there's a couple of really cool ideas in
the series the the first one is the the
notion of the zones of thought so
there's this idea that the capability of
intelligent systems is limited by where
you are in the universe and so we happen
to live in the zone of the universe
where thought is fairly limited which I
notice every day as I interact with
people and that travel is limited to the
speed of light but there are other
places in the universe where those
limitations do not hold and there are
what by our standard would be hyper
intelligences and it's a great plot
device for explaining why the hyper
intelligences haven't come to visit us
yet and we actually have no way to
measure I think that
is an unprovable conjecture at this
point right it is could be the case that
there are physical constants about
computation and the laws of physics that
don't actually are not actually
measurable from here because we're not
there and so I'm actually pretty worried
about this I've spent a fair amount of
time considering this I mean my kids are
like dad why do all the other kids
parents you know worry about you know
income taxes and you're worried about
the sun's gonna burn out or you know
these kinds of problems but I think at
least some people have to you know take
the long view and worry about these
kinds of things but the thing that I
want to say here is that another key
idea in the book is that there are
people who have a cavalier attitude
towards controlling intelligences that
we might discover or unleash and so a
lot of the problems in the story happen
because some arrogant humans awaken a
thing that's called the blight that is a
hyper intelligence and is dedicated to
among other things human scale evil
which is kind of a plot device is
difficult to understand why it would
really matter that much to the blight
but it's important for us to think about
because I when I started using closure I
thought oh crap we're like that much
closer to some piece of software that
somebody wrote waking up right I mean we
have a limit I certainly you know
whenever I see rich right a needle thing
enclosure that's longer than a thousand
lines he has to cut it and and break it
into pieces so that it doesn't like you
know wake up and become sentient and the
important thing here is that a few
dedicated fighters are out there making
sure that we have a safe place to
sequester these intelligences when they
wake up and this next talk that's what
this is about I mean Anthony is is you
know taking a sort of easy pitch with
this you know that this is just about
try closure and IRC BOTS and so forth
but actually he is the first of a
generation of fighters who are
protecting us from the machines so
without any further ado it says Anthony
Grimes and is gonna be talking to us
about closure
this actually feels pretty good feel
like God everybody's in front of me so
I'm Anthony Grimes I've been a closure
programmer for around three years I
wrote try closure try coj comm except
for the java smoke to the javascript the
design and pretty much everything else
that matters I'm uh I'm writing a book
called meet closure it's an introductory
text for people coming from pretty much
any language as long as they programmed
in at least one language it should be
out by November of 2020 I'm the youngest
person in this room I don't even have to
ask people I mean obviously in seventeen
and I'm a Stewart Sierra groupie
obviously big fan so code is dangerous
if code wasn't dangerous you wouldn't be
able to read or write to the file system
you wouldn't be able to talk to the
internet you wouldn't be able to do
anything useful at all for the most part
dangerous is good dangerous is the whole
point that's why we write code but how
often do you really think of it like
that when you're writing an application
you are your code sandbox you control
everything that happens if you want to
write to the file system you do so
precisely when and where you want you
only delete the files that you want to
leave you control everything that
happens that's why you don't usually
care about sandboxing and plus we almost
never need or want to allow anybody but
us to evaluate code on our machines and
just isn't something a lot of programs
require thing as closure makes it really
easy to get code from you know arbitrary
source isn't evaluated like in this
example we we call the reader to
evaluate it to a get code from a string
no Stewart Sierra's talk was actually a
great prerequisite to this and then we
called a compiler at runtime to evaluate
that code it's that easy to do that but
what about situations like this where
like lazy BOTS on IRC if you evaluate
something like system.exit
you kill him you know if he essence if
he doesn't have any protection against
that he dies it's that simple and it
gets worse what if you delete a file you
could just delete files on his and its
home directory is that easy something
has to be done about this
so we need a sandbox to keep us safe a
sandbox can prevent input and output
interaction with the file system
interaction with the internet prevents
the execution of arbitrary programs and
it prevents destruction of the JVM like
with the system exit call we did earlier
we got to stop things like that from
happening so the great thing is that the
JVM actually has a built-in security
architecture it is very thorough it's
been around since before I learned to
walk it was introduced in the first
release of Java back in 1995
I believe that was one year old so yeah
it's great its mature it denies access
to certain methods and classes prevents
inputting output if you want it to and
it's customizable you can pick you know
miss mix-and-match what you want to
allow and not allow basically it stops
this stuff from happening no system
exits stuff like this you won't be able
to slurp anything you know talk to the
internet here you won't be able to read
from the file system unless you
explicitly tell it you want to read them
wanted to be able to read from the file
system given just basic permissions
it'll prevent almost anything they can
cause problems it saves your computer
from evil unfortunately it isn't quite
enough for every single use case closure
the hardest part of sandbox enclosure
isn't sandboxing of the JVM since the
JVM can fend for itself
the hardest part is sandboxing the state
of closure itself at any given time like
the namespace things like that for
example what if they rebind things if
they rebind + 2 - it's gone + is - and
what if they execute infinitely an
infinite loop and your sandbox they'll
lock it up nothing's going to stop that
there are a couple of services right now
that face these problems try closure
foreclosure and lazy bought which is the
repple for your IRC channel then close
the closure IRC channel you probably use
it if not you should we'll talk about
all these things later they all take
different approaches to sandboxing and
we can investigate those and learn from
them Wow
see I edited that this morning like two
minutes after I woke up so yeah
I think you get the point though I'm not
gonna stop and go back to my room and
fix it so what we need to do is we need
to rip apart code we need to look at
namespaces we need to look at symbols
classes packages VARs and anything else
we can get our hands on we need to check
all those things we need to keep depths
from being abused because of course you
can rebind things in the namespace and
they can be used to abuse memory giving
a person the ability to death things
means they can def something in the
sandbox namespace that has the same name
as something in closure core or another
namespace they can basically ruin the
state of the sandbox namespace with it
if you allow death and everybody uses
the same namespace and it can get
corrupt furthermore if allowed they can
use it to hold things in memory that
shouldn't be held there and infinite
loops we need to simply time those out
we need to prevent long-running
operations from taking too long
we need prevent things like range 1
million and infinite loops in threads
can be used inside of the sandbox to
avoid timeouts so we have to do
something about those two we need to
kill them to make sure they aren't used
to get past the sandbox timeouts because
it can only kill the top-level thread
once the timeout is over or the timeouts
up and we need to do something about
closures Java classism the JVM sandbox
can prevent access to classes and
methods that can damage the system and
the JVM itself but it can't really do
anything against closure zone Java
classes they can be used to do stuff
like the intern here which can corrupt
the sandbox namespace the JVM sandbox is
only concerned with input and output and
the GBM itself not with overwriting
deaths in a closure namespace so
closures Java classes need to be sandbox
in some way furthermore we can't get rid
of dot Java Interop is a huge part of
closure and eliminating it means
eliminating one of the most useful
properties of closure we also can't just
rebind it because it's a special form
and you can't rebind those instead we
need to be clever and actually replace
the symbol
code before we evaluate it and we'll
talk about that short length so that's
what's needed to make it safe but we
don't really have to stop there we can
do more with this we can make it pretty
extensible because safety isn't the only
concern we can have customized
evaluation contexts for example if you
only want to block the math function
then you can do that it doesn't have to
only be things they're inherently unsafe
it can be anything you want to block
foreclosure is actually built on this
because some some of the problems
involve re-implementing core functions
and they have to block those core
functions from being used because you
could be using the cheap so close Yale
it is an all-you-can-eat sandboxing
library written by this guy and this guy
inspired by ideas from this guy licenser
and you probably don't know if you
recognize him or not eating a bit around
lately
sadly I'm missing which were inspired by
an IRC BOTS and this guy closed your bot
for you guys it can take advantage of
the JVM sandbox and sandbox is the
closure side of things like you know
sandboxing deaths and infinite of
preventing infinite loops and things
like that and it does very silly and a
very selective blacklisting like with
the customized evaluation context like
we were talking about before it
basically does everything we've talked
about so here's how you use it mining in
or cake whatever you whatever build tool
you're into the current stable version
is 0.5 points euro which I release
specifically for this conference you can
all thank me later
and here is an example sandbox this
sandbox does not actually block anything
you can see that we passed an empty set
to the sandbox function normally this
set would be our blacklist right now
we're not blacklisting anything so if we
evaluate 3 + 3 we get that back however
even though we didn't block anything on
the closure side the jvm sandbox is
still enabled by default so even though
we didn't block anything if you try to
execute system XO it won't let you do
that we can explicitly disable the JVM
sandbox if you really really want to I
wouldn't advise it bypassing the keyword
argument JVM falls
sandbox takes a set of things like
classes packages symbols sets and
namespaces pretty much any object that
can be printed to a string and read back
again like I said Stewart Sierra's talk
was an excellent prerequisite for this
this is because we embed the tester in
our dot replacement macro but we'll get
to that later it's kind of complicated
no it's very complicated I hate it so
like I said before you can block only
the things you want in this example we
are creating we have a sandbox that only
blacklist plus minus and the entire Java
math class if we try to use any of those
things the sandbox it's Angry complains
so but you don't you know you don't
really want to be concerned with finding
every single thing that can mess up your
needs to be sandbox it's unsafe so I'm
trying to do that for you we're trying
to do that for you so we have a testers
namespace that contains pre-made testers
pre-made sets of things that we found
that can be used to abuse the sandbox
the most important one is secure tester
which is a tester that blocks a lot of
unsafe things you know we add to it over
time so you don't really want to depend
on it being completely safe but if you
find any problems whether you want to
report those and then we'll fix it and
if there's anything needs to be added to
a secure tester we'll add them but it's
safe enough to you know we can use it in
IRC and lazy bought and things like that
and we don't we rarely have problems
people have to actively look for
problems they don't accidentally stumble
upon them these days anyway took a while
to get here you can also do fairly
dynamic sandboxing there's sandbox star
not to be confused with sandbox this one
is the same as sandbox without the star
you pass the tester in when you evaluate
the code every time that way you can
switch the tester and still keep the
same namespace sandbox without the star
it's actually just a simple wrapper
function around sandbox star all it does
is it partially applies the tester that
you pass it to the function that sandbox
star returns that way you don't have to
pass it every time sometimes you don't
need to it's easier but other than that
they both take the same arguments of
which there are a lot wait to see the
argument list I'm serious it's bad the
sandbox automatically destroys
long-running operations like this
infinite loop here after 10 seconds it
times out you can set the timeout by
passing the timeout key keyword argument
like in this example we're setting it to
5,000 milliseconds which is 5 seconds so
in the next example they would timeout
after 5 seconds I can't really
demonstrate that and slide but you get
it so we also do some creative things
with death to allow death we have a
extra tester and flo-jo testers called
secure tester without death because I
couldn't think of a longer name that
made sense basically it's just the same
thing as secure tester only it throws
death on the end so that it's allowed
because only recently we started doing
things you know things with death to
make them somewhat safer I mean this is
well though old debts are wiped once
they exceed whatever max death is set to
which is 5 by default that means they
are undead unmapped
here we deaf six different things in a
row we do each of them one at a time
once we get to F the sandbox realizes we
have death more than five things which
is what max deaths are set to by default
and so it unde Epps all of those
previous deaths that's a lot of deaths
the latest one F is allowed to remain
that's why we can still use it
the newest batch of deaths is also
undeath if it exceeds that number as
well for example here we're defining six
deaths all at one time in the same block
of code the same evaluation the sandbox
realizes what has been what has happened
and it wipes them all immediately that
prevents people from creating a whole
bunch of deaths in one single batch each
sandbox gets its own namespace when you
create a sandbox it creates a new
namespace by default the namespace is
just a gen sim sandbox at the end are
prefixed not at the end you can set what
the namespace is by passing the
namespace key it could be a symbol or a
string or anything you know what yeah it
can't be anything obviously but a symbol
or a string so closure actually has a
mini turn your phone off that's rude
the closure actually has a mini library
for working with the JVM sandbox a lot
of this code was actually taken from
closure bought and put into clj sandbox
which is what closed Yale pretty much
evolved from it was written by Hines
licensure don't know how to pronounce
his last name so I'm not going to try
anyway this code was adapted from
closure box code to be more library like
because it was you know it was for
closure bought so we have this little
library for working with the JVM sandbox
it is completely separate from the
closure dot course it works all by
itself if you want it to so in this
example we're defining a security
context that allows an extra permission
here a file permission we're giving the
sandbox the ability to read and write to
a file called foo normally you wouldn't
have this ability so we can use this
context instead of the default context
which just allows you to access declared
members and it we pass it to sandbox
with the context key that said you don't
have to you if the closure a part of
things you don't have to you or me it's
all in closure but you don't have to use
the closure that core part of things you
don't have to sandbox closure at all or
even touch closure you know you can just
call JVM sandbox which is actually just
in closure a about GBM and use it if you
don't want the closure all that core
part of things it works completely as a
standalone library and like I said it's
integrated into closures other things if
you want those it could actually become
a separate library at some point if
people find it useful enough to the war
alone to warrant taking it out but for
now it makes sense is to stay in there
so you can pass in it code to be in a
key
this code is code that will be executed
in the context of the sandbox namespace
but outside of any actual sandboxing
that means that even if you don't allow
death you can pass code that uses death
and that'll happen as soon as you create
the sandbox like right here that would
happen immediately and then food would
be available in your in the sandbox
namespace when you evaluate code ant
later any deaths that occur in that
never get under we already talked about
how we undeath things after a certain
amount of deaths have happened any
deaths that occur there are considered
special and they never get on death it's
great for setting up a sandbox namespace
with standard deaths and imports
depending on what your program is
actually using close Yale for I'll
actually show you a usage of it in a
little while when we talk about try
closure you can also pass bindings like
with like just like binding like the
binding macros we pass stuff like this
you can find out out to a string Rider
and made if you print line print
anything inside the sandbox they'll go
to the writer and basically this new
shortcut to using binding so that's
closure but your closure Ian's and you
probably want to know how all that work
some of you might want to leave the room
though
so let's look at the individual pieces
that make up the sandbox
starting with check form this is what
checks for bad stuff in our non Interop
code it calls separate to explode your
code then checks if any of the results
that are in tester if any are then the
code is bad now the actual exploding
what we do here is we macro expand most
of the code what macro expand most does
is it's basically macro expand all with
the exception that it doesn't macro
expand things that begin with a quote
next we ensure it's a collection with
kala file which is a great name I'm not
sure if I named matter if Allen a Matt
but it's wonderful anyway I don't care
what anybody says and all it does is if
what it takes if what's passed to it is
a collection then it just returns a
collection otherwise it wraps it in a
collection it's not important and then
we call flatten all flatten all is just
like the core flat and only it actually
works the core flatten function the core
flatten function doesn't flatten maps
and we need that to happen so we can't
use it
so we just wrote this simple flatten all
Alan wrote it it just uses a tree see
it's pretty nice to check it out so next
we check to see we check each object
that's passed to see if it's a symbol if
so we try to resolve it and get us meta
if it has meta we yield the resolved
object we yield this namespace its name
and namespace as a symbol you know if we
can and I know you know you're probably
thinking that the jokes was actually
written by Alan but no that one with me
if you've ever talked to him in the IRC
channel you know what I'm talking about
he's nuts for jokes
No if it is a symbol but doesn't resolve
the something with metadata we split the
symbol at the slash and try to you know
as qualified and try to resolve the part
before the slash if it results to a
class we yield it and the original
symbol otherwise if none of that applies
we just yield the symbol itself finally
what was passed was not a symbol at all
if what we're at in the code is not a
symbol at all then we just yield the
object of his past and we assume that
that can the tester might look for that
we attack to basically do special things
for symbols to make sure that we can
check every part of a symbol and
everything that everything that it could
be so this all results in a huge set of
object symbols classes and anything else
that was in our code and we can run our
tester against that with check form and
that's how we find out if something
that's blacklisted is blacklisted or
something that's blacklisted in the code
or no so it's time your non Interop code
is handled but what about your Java
interrupt code closure actually
sandboxes in two stages the first stage
is that it checks the code before
evaluation we just talked about that we
check the code with check form and we
exploded it was separate and all that
good stuff the second stage is that it
modifies the code itself before
evaluation so that it can sandbox things
that couldn't be checked or it could
have missed before evaluation or if we
just need to do something before we
evaluate it to replace things that are
unsafe with safer alternatives the
primary example here is with the dot
special form so what we do with dot is
we have our own specialized dot macro
that runs the tester against the object
and the class and everything like that
and we replace the dot special form in
the code the dot symbol we replace it
with a symbol for our dot macro this is
just a simple recursive walk that
replaces everything
that's what Dodd actually does it's
interesting you know so this function
returns a dot macro definition I know
it's lovely that uses our tester to
check for evil
it'll be evaluated inside of the sandbox
you'll see that in a minute
note that it takes the tester as a
string as an argument the tester is
embedded in the macro which is why we
needed to be possible to print the
tester to a string because it's embedded
yeah like I said his talk was great all
it really does is check at the object
objects class or objects package or in
the tester and if so we throw a security
exception otherwise we evaluate as
normal that's all you really need to
know about this I wouldn't look into it
too hard we try not to it's scary
it looks horrible so let's move on and
that's how dot is handled but what about
timeouts
this is func timeout this was also
originally from closure bot but it has
been it's been changed let's just say
it's been changed significantly it has a
bunch of area DS because it has you know
a bunch of arguments well I guess it's
only four but let's consider that a
bunch anyway there's a bunch of area DS
to past defaults for its arguments but
I've cut those out these slides are only
so big and what it does is it runs a
future task in a thread possibly in a
thread group if one was passed and it
gives it a certain amount of time to do
its thing if it takes too long it
cancels the task or if an exception is
thrown inside the task it cancels it and
stops the thread and it always no matter
what happens it always stops the thread
group if one has been passed and if it
thread group sometimes
so the thing about sandboxing threads is
it's kind of interesting here we can use
a thread group we can run our thumb time
out inside of a thread group and then
any thread that the code that we're
sandboxing creates will run inside of
this thread group but that does not
apply for things that use thread pools
like futures and agents and anything
else in closure that uses thread pools
killing the thread group would not kill
those things so until we until we get
more clever and figure out a way to
handle thread pools we have to not allow
futures agents and other things that use
thread pools because they can be used to
spin off threads that we can't kill so
here's the part of things that actually
evaluates your code it's a function that
returns a function that we pass the func
timeout that's what we pass to it
basically what it does is in the context
of the sandbox namespace we evaluate our
dot macro like we talked about before
and our modified code under the JVM
sandbox with whatever bindings were
passed
so that's a lot to take in so here's how
close Yale puts all that together with
the sandbox star function now everybody
be careful this might hurt a little bit
and if that code is too small I tried
everything imaginable to make it fit in
the slide and be big enough for all of
you new people to read anyway that was
without the doc string the doc string is
longer than the code the argument list
is half of it we expect all of its
arguments our keyword arguments so we
just create sane default for them here
the first thing it does is it binds star
and s star to a new namespace that we
create on the fly if the users pass the
refer of closure keyword argument and
set it to false then we do not refer
closure by default refer closure is set
to true and if it's set to true then we
automatically refer a closure inside of
this namespace that sets it up with
closure core just like you'd expect any
normal namespace to start up with but
you can pass it this false to do that
kind of do that stuff yourself if you
have a very specialized way you want to
set it up and that's the next thing we
do we call we evaluate in it it
evaluates this code inside of the
sandbox namespace but as promised it's
actually outside of any sandboxing so
anything can happen here but if you pass
prefer closure false you're expected to
setup the namespace and the coachee
passed in it you do whatever you want
okay so the next thing we do is we get
everything that is currently defined in
this new name space and we bind it to
the name in it des inside of the left
also included in this list is dot our
dot special form replacement macro well
check this later to find out what we
should
and what we shouldn't undeath since we
don't ever want to undef anything that
was defined with the in a keyword
argument and we don't want to waste time
on death in our macro so this is a start
of the function that the sandbox returns
this is what you've been creating and
using to evaluate your code and our
previous sandboxing examples notice that
it takes a tester argument here like I
said before if you use the sandbox
without the star the sandbox without the
star wrapper function you don't have to
pass the tester but if you want you can
just call sandbox star and pass the
tester every time you evaluate something
that's the this is the function that you
call to evaluate your code is the
function that sandbox star and sandbox
returns so the next thing we do is we
bind test erster to a string version of
our tester this string was produced by
printing the tester to a string with
print dupe set to true I love you
Stewart Sierra thank you for your talk
they would not know what you're talking
what I'm talking about right now if it
wasn't for you they probably still don't
but I'm trying we have defined an
implementation of print do for Pat Java
packages so that we can embed them in
our dot macro if they are contained in
the set that's the main thing we need to
be able to any object that goes in this
needs to be able to be printed so one
big part of sandboxing is that you a lot
of the time you want to you want a
blacklist entire Java packages like Java
dot reflect I think that's one of them
something like that anyway but uh so we
have a special print print method for
that print print method for that and as
long as the JVM keyword argument it
hasn't been set to false we enable the
Java security manager and this enables
the JVM sandbox for when we evaluate our
code with our mini JVM sandbox library
you almost always want that so
next in a try block we use the check
form function to check for evil code
like we talked about before if evil code
is present we throw a security exception
otherwise we evaluate the code with our
evaluator function wrapped in a thunk
timeout so that our code times out and
throws an exception if it takes too long
to execute and I'm out of water
finally we call white deaths to manage
the things that are currently defined in
the namespace this is all just fairly
uninteresting logic but what it
essentially does is it looks at what was
defined when the namespace was initiated
with you know anything that was defined
with the inner key and it takes those
things out of the equation so that they
can't be undef because we don't want to
end death though it then looks at things
that were defined in previous
evaluations and it counts them undefined
them if they exceed whatever the maximum
number of deaths allowed a sec - finally
it checks what was defined in this
particular evaluation counts them and
undefined those as well if they exceed
that number so that's how all the all
that stuff is handled but it's
uninteresting and this talk is already
too long this is slide 99 I think I've
got the longest talk so far the longest
you know a number of slides anywhere so
the result of that is a closure sandbox
it's awesome and all but we got to think
about a few things here before we use it
if being safe is important you should
take every precaution imaginable the JVM
sandbox is mature and thorough but that
doesn't mean that it's invincible they
spin around forever like I said before
before I could walk they found they
finds they still find security problems
every now and then it's understandable
this stuff is hard it's really very hard
so you want to put some effort into
sandboxing the code to the OS level
thank you
you want to put some effort in the
sandboxing the code at the operating
system level as well as at the
application level for example you can
run your code and it's own user account
I mean that doesn't stop everything but
just whatever precautions you can take
if you really really need your machine
to be safe and you're evaluating other
people's code you don't know what these
people are going to do you people are
insane you've proven that to me so many
times since I started since we started
this library anyway you're okay as long
as you use the JVM sandbox for the most
part if you take advantage of that your
computer is as safe as a JVM can
possibly make it the safety of your
computer is not really concerned the JVM
sandbox if the JVM sandbox is enabled
the worst that can happen usually is an
infinite loop or you run out of memory
and that's if closed Yale itself failed
allowing everyone to safely evaluate
code in the same namespace it's close
Yale's primary goal but that is a goal
and thus what we're working towards and
not necessarily what we've completely
accomplished we still find holes
sometimes and when we do we fix those
the thing is we can't test every
possible scenario we can only find
things and fix them as we go along it
grows over time we are limited by not
being rich Hickey and thus not knowing
about every single thing in closure that
can break the sandbox
I'm sure he's sitting over there right
now with about 20 things that he just
dying through and that's good closure
ends are drawn to sandboxes they are
drawn to them they want to destroy them
every time I mention closure in the IRC
channel someone starts trying to break
lazy buggers every single time without a
doubt they try to break it every time
it's and I mean that that's great I
encourage people to do that just if you
do break it tell me about it
a lot of people don't do that they break
it they're like oh awesome I'm great I
can't fix it if you don't tell me what
it is
so but people mostly me trust closed
Yale enough to use it in their own Pro
and their own projects so here are a few
examples of that I still have a little
bit of time I might have to skip the
last one
try closure it's an interactive tutorial
website for closure with a closure a
low-powered repple that evaluates code
on the server side it's similar in
nature to the other try language
websites like try Haskell but it has a
space in the name and I think that makes
it cooler it's built on Chris Granger's
awesome new web framework I pronounced
that right
it runs on Heroku which also makes it
cooler a bit fill like that in action so
the approach it takes is that death is
allowed and every user has his own
namespace timeouts happen very fast it
tries to emulate a repple as closely as
possible since each user has his own
namespace allowing death isn't really
that big of a deal because if they screw
up their own namespace why do we care so
here's to the code that it uses it
creates a sandbox with a tester that a
secured tester without death and also
blacklist try closure core so you don't
try to get clever and screw something up
in the actual core of the website and we
use the init keyword argument to provide
code that removes the sandbox namespace
after 10 minutes that's pretty
self-contained
when an avowal request is received we
check if the user has a sandbox in their
session and if so we use it otherwise we
create a new one and stored in the
session sessions expire after 10 minutes
so after 10 minutes the idea is that any
anything that anybody's done it's gone
they were never there credits for that
go to and ruga Sheba's he designed this
hole he designed the whole thing
the lovely design that's there now I'm
sure some of you have seen what it was
before when I designed it wanting more
using
and got to think Chris done for his
awesome jquery console used for the
repple interface and the design is
actually inspired by try haskell and we
got to think alan johnson mephesto
because he wrote the interactive
tutorial alright I think we have time
for one more example here well not skip
lazy Bob yes everybody knows about it
foreclosure is the most interesting
closure use case you solve Cohn like
closure problems and tasks in your
browser as a long list of problems are
very variable difficulty ranging from
easy to very hard it's wonderful as a
companion to any closure learning
material it's great for even people who
have been using closure for years
because it has hard problems it can
really challenge you the approach it
takes that it relies on dynamics and
boxing if a problem calls for the
reimplementation of a core function the
core function or similar functions can
be blacklisted to prevent cheating
here's the core code that it uses to
sandbox for every test in the problem
every test case it replaces the two
underscores with the user's code and
then it evaluates it in the tester it's
actually pretty simple but it's a great
concept
so the credits for that go to David
Byrne and Alan Malloy Alex McNamara and
Karen Mayer he did a lot of the
front-end stuff made it look pretty made
it work and well skip this for now it's
just it's not important lazy bought
sucks everyone
okay so here is the last slide I promise
don't get paranoid the here's some
guidelines for using closure on your own
code the JVM sandbox is your friend
always use it it'll keep you safe you
want to follow close Yale's release
cycle as closely as possible and updated
every convenient chance anytime it's
updated it means we fix something or
made something better and you want to
have that in your code as soon as
possible don't be paranoid remember that
the JVM sandbox will protect you from
real danger and if you avoid sharing the
same namespace with everybody it's much
less likely that one person will blow
away the state of the entire application
the entire sandbox for one person for
everybody I mean you don't want to allow
deaf and give everyone the same
namespace as if you do that they can
anyway they can but they will corrupt
the namespace and screw it up for
everybody and I've got a lot of I got a
couple of links up on the closure wiki
to documentation on the JVM sandbox
itself not closure it's actually pretty
interesting the JVM security
architecture is really really complex
and thorough like I said before so if
you're interested in the JVM sandbox
itself it's pretty interesting there's a
couple of links there and I'll put some
more up there and I find so here's my
thanks but I don't actually have time to
save them so read them and that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>