<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Keynote - Rich Hickey | Coder Coacher - Coaching Coders</title><meta content="Keynote - Rich Hickey - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Keynote - Rich Hickey</b></h2><h5 class="post__date">2013-01-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/I5iNUtrYQSM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so tell us a couple of stories about
rich I first met rich at the JVM
language summit I was the first one
maybe and I was already working on the
book but we hadn't met and I had
correspondent with him and had
correspondent with many of you in the
room who were on the closure mailing
list back in those days and I met him at
the summit and he came up and introduced
himself and and you know said it's
really exciting that you're working on
the book and he gave me a closure pin so
he pinned me I called my wife that night
I was like wow I finally met rich this
is really nice guy and he gave me this
pin and she was like what I mean given
things you've already heard me say she
has you know reasons to worry about my
behavior you know when when traveling at
conferences and so forth so since then I
have had about the most the most
pleasure you can possibly have writing
software in the industry increasingly
getting to work with rich on a day to
day basis violating all kinds of sacred
principles we have these agile stand ups
in the morning that are you know
supposed to last for 15 minutes and
sometimes we'll look up and he's you
know I've been talking about something
for two and a half hours and I'm
thinking don't you guys all wish that
you could be doing this it is it is
absolutely a pleasure and an honor and I
just want to get this started right I'd
like to ask everybody to stand up and
applaud before we start this for rich
and the work he's done to create closer
thank you very much is this working ever
hear me okay no how about now Oh homie
had to button my shirt missing how about
now okay
before I get started I think some of you
may have been aware we had a little
interaction on the mailing list last
week about dates and whatever and I
replied harshly to Chas Emmerich and
while I'm very sensitive about the fact
that that interactions on the devilís
be constructive the way I replied to him
was was definitely not so I just wanted
to apologize Chas I'm sorry that's
that's certainly not the example I want
to set and so had a bad day all right so
is everybody having their mind blown
that's Prince isn't it so somebody's
talking about not being able to use
computers that's my that's my specialty
yeah I'm having my mind blown - and and
I kind of expected that the thing I
didn't expect which is kind of sad it's
already been tweeted about is that a
Ambrose has better hair
okay so we have had some really intense
intense topics today and I'm going to
talk about something substantially less
sophisticated than a lot of the things
you've seen and that's closure itself
and in particular just kind of survey
areas I think would be interesting
foreclosures many of them that have been
talked about before and what I want to
do is sort of survey them and get some
of the ideas on the table but leave a
lot of time for interaction and talking
especially with anyone who possibly
might want to do some of this stuff
however I do want to say this is not a
road map I have more ideas than I have
time and and I would definitely need
help also a lot of these things or
half-baked I don't know if everybody
could read that it's a half-baked guitar
pedal which is pretty cool but most of
these things need more design time and
effort before they even get any kind of
implementation time so what would we be
interested in four core one thing
definitely is leaner we've heard we've
heard this several times already there's
a bunch of targets for closure that
would like to see faster startup times
less memory usage and things like that
and I think fundamentally we face a
attention with the language like closure
and any list between the interactive
development experience which we prize
and the production usage where are only
some of the the same tools that are
required during development are also
required and I think that some in some
of the areas are kind of clean-cut
people understand Android somebody
mentioned startup times on on App Engine
other things I personally found to be
challenging is delivering closure based
code as libraries to non closure
applications so I wasn't expecting to
get any closure overhead and now I have
either some impact on my startup time or
a memory usage or something else that
puts a lot of pressure on closure to
deliver something in a jar that's very
minimal and
while I say that's attention with lisps
and everybody should be aware that lists
traditionally have had very good tools
for tree-shaking dumping out the
evaluator dumping out the compiler and
things like that but it's not like
sacrilege or anything
most production lists have had these
facilities for decades so I think would
be worth worth targeting them concretely
I think you know there's a couple of
things one of which is just the notion
of moving ASM out currently it's bundled
in and interestingly other than in the
repla environment we don't right now do
any dynamic compilation those none of
closures constructs require compiling
code at runtime unless your program
calls eval no closure constructs require
that now is interesting in David's talk
how he mentioned the fact that that
might actually be interesting for
instance if we wanted to have logic
programs be extensible at runtime you
would need some compilation then as well
but I think that's also sort of similar
to the repple the idea of adding rules
to a running system is something that
might be rare or at least something you
might want to have a knob on so the
thing about having knobs or stripping
out metadata or a lot of these other
concepts goes down to something that's a
that sort of fundamental which is we
need multiple build targets right now we
have one we build closure we get this
one thing that we've decided what's
going to be in it it includes metadata
and all kinds of support for development
and I think we do need the notion of a
development less build for production
deployment even even if as daniel said
it's interesting and useful to have an
interactive element on something like
Android it's also interesting that when
you're done with that interaction you
yank it out before you give it to your
users so the shaking of metadata there
but I think the flip side of saying we
need to start investigating multiple
deployment targets is that we can go the
other way as well we can say you know
what there's a bunch of things we sort
of said I don't know if you
to incur the runtime overhead of that so
know where we could say yes we could say
let's build debug builds or developer
builds with even more stuff attach the
source code to every function you know
have it explain to you why your macro
call wasn't the best thing ever
various stuff like that so I think
overall pursuing leaner can have
benefits that actually want things to be
less lean but it's definitely important
area area for closure another area
that's interesting is unifying things
with closure script we had a couple of
objectives in building closure script
one of which was don't change closure
and we did that the other was not to try
to take on and solve all the problems of
making code work on both the main thing
I wanted to do was make the language be
present and be the same language and
that we did closure script is closure on
a new host there are all kinds of still
open questions about how can I write a
set of library code that's not very host
dependent once and use the same source
and get you know use it for closure apps
and use it for closure script apps even
more interesting are some of the
concepts of being able to say you know
I'd actually like a knob that says how
much of my code do I want on this want
to run it on the server and how much do
I want to run on the on the browser I
think it's very interesting so that's an
open area we can explore that now I
think looking at what kind of support is
required to write libraries where we can
share the source code everyone should
remember it's always been a non
objective of closure as Stu said I think
in his talk to support taking an entire
application and moving it from any of
the hosts any of the other hosts write
that always involves an amazing layering
of re abstracting of hosts stuff loss
everywhere you turn and it doesn't give
you anything if you run the exact same
app on net or on the JVM it doesn't
really feel any different if you were
trying to extend that to closure script
you'd really fall over and the inability
to
talk to the disk or over the wire and
stuff like that so we're just talking
about libraries like CoreLogic and
things like that that are more
algorithmic or data-driven that would
port we'd like to write them once a
conditional compilation is certainly the
leading candidate for giving us some of
the knobs we need to say where we do in
the very few instances if its closure
script do this if it's close if it's JVM
do that and I think the CLR port has
always wanted this ability to switch
things around that's the current
candidate I'm still interested in other
ideas if you say wow I I knew that from
Common Lisp days and that sucked I have
a better idea now's the time to start
talking about it the other thing I think
we can get back flowing back from
closure script effort is getting some of
the analysis results back from the
closure script compiler it was certainly
part of the design of the closure script
compiler that I you know fix the errors
of my ways and the closure compiler
which I don't think we're many but
certainly in one area they were which
was that it produces this tree of Java
stuff and it uses dynamic variables the
Java equivalent quite extensively
yielding an ast that's kind of fragile
and the closure script ast which you saw
I guess Shazzer may have showed it to
you right while while it seems verbose
actually is not those are all persistent
data structures you're mostly seeing
multiple generations of the same
structure that occurred during the
nesting so it looks like a lot for human
but it's nothing for a machine and those
are all stable persistent data
structures built in a nice way
tools have been desperate for that
output now of course the amount of
analysis that the closure script
compiler has to do is pretty low it
doesn't have to deal with types and a
lot of the other stuff that the Java
side does but it's an open question
right we can we can take the current
analyzer which again Chow has done work
to expose those data structures and try
to expose that output as data structures
more similar to the closure script
output so we can start saying okay this
is a format we can start using for tools
in both places or we could try to
enhance the closure script analysis
phase
is to do some more of the work that the
closure one does so it can do more of
that job of tracking types and things
like that so closure enclosures like the
pot of gold or the carrot or something
if it's always somewhere in the future
but I do think we've taken on a bunch of
things that really substantially move
move us towards being able to do this
and the one that we saw in closure
script quite delightfully was the fact
that protocols records and deaf type
ported swimmingly to JavaScript those
concepts the the effort put into making
sure they weren't tainted by Java isms
and Java semantics that either didn't
like or didn't want paid off because we
did not have to recreate those semantics
on JavaScript the flipside was and the
difference in the closure script
compiler for people that haven't dug
down is in in the closure compiler
currently the protocols are is a set of
macros and so the protocols actually
require a substantial portion of closure
to be alive before protocols work in
other words they're not at the bottom
they're not a compiler feature they're
not a primitive feature the way def type
is in both places in closure script I
made the compiler be able to deal with
protocols at the bottom so at the bottom
of closure script we have def type and
protocols working like I delivered to
the guys who started to work on the
library a blank quartet zlj we're def
type and def protocol and extend type
already worked because there were
compilation features what we found from
having had that is that the promise of
being able to build up the data types
and abstractions and the function in the
library on top of the abstractions from
scratch on types and protocols is
definitely there all the abstractions as
as our showed you are
Protocol's it was a complete pleasure to
develop them I mean things that would
somebody show the set of interfaces was
like 40 50 interfaces that's 40 or 50
Java files it's it's about this much
closure script all this of all the
abstractions just def protocol def
protocol def protocol different right in
a row in a single file it may be a
hundred lines you're done with closures
abstraction set and then you can
implement it per type with def type
that's completely great and the lesson
from that as we want to move forward
with closure enclosure is that we need
to move protocol down we need to make
protocol as a compiler thing and the
question the open question there is do
we want to modify the Java compiler one
more time one last time to move protocol
down or do we want to try when we take
on closure enclosure to start with the
closure script compiler and build it up
with the knowledge of the closure
compiler and that would that would
require sort of a little bit of
refactoring of hate network changing or
something something other than
refactoring of the closure script
compiler to make it more amenable to
having different output targets somebody
was talking to me in the hall about
objective-c and the closure script
compiler is tiny it's like 500 lines or
something it's really easy to play with
and and in the emitting part of it is
only half of it so making new emitters
should be relatively easy and in fact
making an emitter that emitted Java
would be a good first playground another
open area there was some conversation
about this recently is invoke dynamic
that was released in Java 7 and I think
there's a bunch of confusion about what
it is and what it can do for us and I
just wanted to try to clarify that what
it is is a way to get call sites which
is a sort of a fundamental construct for
pi morphism without runtime code
generation or generation of classes at
all
in other words the fundamental construct
on the JVM for code
prior to invokedynamic was the class the
class is a pretty big thing with a lot
of stuff you saw the header and the
constant pool and all of this and I
guess well I don't feel the work is done
you know that they're done optimizing
classes you could make classes a lot
more efficient than you have but there
are definitely backwards compatibility
issues but all of all the languages that
sit on top of the JVM really work in
user space and all we have is class
generation to sort of implement our
constructs and when invoke dynamic does
is it adds a lower-level tool in method
handles for talking about code and in
addition it sort of introduces this
whole set of a very functional set of
tools for building the constructs you
need to do dispatch without writing
omitting any byte code at all so you
have no byte code you need to emit no
classes that you need to admit and they
cut that that facility is coupled with
another sort of critical facility which
is it seems largely invisible to anyone
who uses Java but if you think through
what Java has to do you realize there
must be some magic somewhere right
because you have you have this really
fast inlinable virtual dispatch system
and you have the ability to run load
code dynamically so if you've inlined
some dispatch based around knowledge of
the hierarchy class hierarchy then you
load a new class how do you get that how
do you get that to work it would seem as
if you'd have to stop the world and
update things that were not declared
volatile and not mess up anybody's view
from any threads that would be really
cool to have and in fact the authors of
Java have it it's called a safe point
and it's used internally as an
implementation detail of the way class
loading works and so the other thing
invoke dynamic delivers is a kind of
access to that the access is not the way
I would have preferred which is sort of
explicit direct
it's just to that feature the access is
sort of tied into the to the the call
sight system but it's still there and so
the combination of these things gives us
a set of tools we can use to mostly
optimize closure because we had to build
all of our languages without this so
from a semantic standpoint we pretty
much already decided on semantics based
upon what we could do with classes so
it's not as if an existing language
could do something radically different
semantically without breakage by
adopting this a new language could
though a new language would say oh I'm
going to make method handles first-class
parts of my language and you can pass
around these pointers to methods which
we we can't do without adding new
semantics to the language but from an
optimization standpoint there's a bunch
of places where this could be used one
is in protocols and keywords or perfect
examples of where we do polymorphic call
site dispatch you know you have an entry
point for a protocol it says call this
and it frequently will see or always
will see the same type coming through
that's exactly the use case for which
this stuff was built similarly we have
keyword call sites and closure which
most people don't really realize but in
order to make keyword access fast
we have little call sites that say if
I'm if I'm using a keyword on a record
type and I see that type all the time
I'll presume that's the type and cook
you know and have a more efficient
dispatch and then only do something
different if I see something new come
through right now we have attention with
VARs between the dynamism of bars and
inlining because a var is both an
indirection and a volatile I think I've
seen great difficulty on the part of
hotspot to inline through them and so we
played with static and not and dynamic
as an explicit thing all those things
are sort of fighting the fact that we we
don't have the same kind of when you
change your code because it's the only
time we need it right when you change
your code in the repple we'd like
something that we didn't declare
volatile to magically be swapped in and
not mess anybody up and that's so
effectively what happens with class
loading but we can't do that in bars and
users
with invokedynamic we could make those
things into call sites presumably at I'm
still it's still an open question to me
is that how much overhead there would be
because right now we're just doing a
dereference so at least they'll be these
shims for in both dynamic around those
but I'm told that can all be made to
disappear and finally you can use it and
this might actually reflect more up into
the surface you can use in both dynamic
to basically say you never need to tell
me type int you just say whatever you
want to say and we'll figure out what
the types are at runtime and using both
dynamic to build little types call sites
that correspond to the methods that we
found during a one-time-only reflection
over what came in and so it's not like
this reflexively its reflection once you
say oh what did I get and what do I need
and let me build a little call site and
then as long as I keep getting the same
type through here I don't need to do any
of that work because I didn't have that
and because we have metadata we already
built a system for declaring types and
we have local inference and so you can
get a lot of this benefit for almost no
effort by just declaring one type here
or there and then after that we can
track method calls and everything else
so it's not like we're in deep need of
this but it would be nice to have this
be the backup for when you didn't say
that so that you didn't have the
reflection warning or worry why is this
twenty times slower for some reason I
made a mistake here the trade-offs
however within both dynamic are
performance right until the performance
of this is as good as the existing
methods we get nothing from doing this
the other trade-off here is it's a Java
seven enough only kind of feature so we
can't move to this we'd have to do this
in addition to what we're already doing
and but that's not insurmountable I
think as we start to see the newer
builds of seven bring the performance of
invokedynamic to parity with virtual
method dispatch that would be an
interesting thing to start looking at
and we're just in having people do that
certainly one of the things is getting
once we get a SM out we desperately need
to upgrade it we're using an ancient
version of ASM and the newest versions
have support for this so these things
tie together leveraging logic so we saw
some just terrific presentations I'm
going to talk about a very minor
application of logic here but anyone
that saw Dan's talk should be thinking
about rewriting closure as a logic
program and running it backwards and
finding start-up ideas that's the stuff
we saw yesterday was completely amazing
but more modestly you know one of the
things we saw and we saw this morning
right is moving from pattern matching to
predicate dispatch the other thing we
often talk about in the context of using
core logic with closure itself as part
of like a language thing is doing type
checking with it or you know some
variants of it I think we have an
amazing facility in metadata for
communicating about our programs in a
way that the compiler doesn't even need
to understand but to the extent we can
capture metadata captured in the
analysis phase propagated to an external
tool take the results of analysis and
pass it to something like core dot logic
I would I would expect people to do
things like what type checking does but
also much more interesting things really
to think about programs as being
queryable entities and you know to be
able to apply anything you want in a
metadata and then ask questions that
sort of cross the boundaries of was
typically possible with with type
systems so I'm very excited about that
and then David already laid out how
predicate dispatch might work out and I
think he identified sort of it once I
don't like pattern matching is a simple
sentence to say but the thing I don't
like about pattern matching it's the two
things are that it's closed right
instead of open and that it's order
complected and so those those
characteristics of predicate dispatch
being open and order independent I think
are really really strong in addition
just the kinds of things you
be able to talk about for dispatch are
categorically different with logic than
they are with pattern matching pattern
matching is this little structural thing
it's really it's really branching in the
realm of the programmers decision right
if you had predicate dispatch and a
logic system you could be doing
branching in the realm of the business
person's decision process and you'll be
able to show them the logical in program
logic part of the program and say is
this what you meant and they'll be able
to say sure if you show them a pattern
match and say is this what you meant
what are they going to say did you just
tell me that right
that's what they're going to say so so I
think this stuff is completely awesome
I'd love to see people you know help out
David and Ambrose and in taking what
they've made and applying it give them
the feedback from using it so they can
you know work on the underpinnings and
and because there's so many areas where
you can apply apply apply logic and it
really does lift your program up a whole
level towards being more declarative so
this is a fantastic addition to closure
ok parallelism certainly closure was
designed with a bunch of primitives
based around making concurrency sing and
by concurrency I mean you have multiple
things to do and those things might have
interactions parallelism is you have one
thing to do and you'd like to break it
up into multiple threads and do do it
more quickly by having broken it up we
had support for the fourth drawing
framework in the early versions that's
been horribly broken by the changes to
the fork drawing framework and trying to
deliver it in seven we need to drag the
stuff back out and revisit it in
particular you know some of the things
like parallel array are gone and the way
fork/join works has pretty much been
completely revamped
but the core concepts are still there
however I think that we need to be
careful
to assess how well fortune works for
certain kinds of problems in particular
you know I had asked during one of the
talks because fork/join is oriented and
optimized for and is really only
completely safe for IO free you know
computational loads if you were to try
to have a language feature like futures
if you want to say I want to make
futures for joint base so people could
casually use something like futures and
have them all participate in a fork
joint task tree I think that we would be
wonderful but then you have to really
consider whether or not the fork joint
framework as delivered is a good way to
do that for instance the answer to my
question when I asked about combining il
loads was no we carefully architected
our systems so that the IO happens here
and it feeds something and then
independently there's a set of stuff
that does the compute load using fork
joint now any one system can be very
cognizant about that separation of
concerns and partition you know
partition those two things but a
construct that you want to reuse all the
time can't do that very well in addition
for join for iOS is pretty good as long
as your your il counts are not that high
having threads waiting for blocking i/o
is not a catastrophe I mean people
presume everybody's like I need to make
a web server that like a million people
can connect to at the same time as if
that's the only possible use of threads
and therefore threads are useless but
it's not the case there are there are
systems that do a ton of work with you
know dozens or hundreds of pending iOS
where parking threads on them would be
zero problem and using fork/join style
logic not actually the fork/join
implementation that we got before join
style logic is a great way to do that
because it gets to my next point which
is the ideal application of fork/join is
when the branching points lead to
varying amounts of work okay if you had
this big block of stuff to do and you
need to do the exact same thing on
everything in this block fork/join is an
anti-pattern you know you don't want a
fork join you want to divide it up into
four pieces
give the four pieces to four threads if
that's the number of CPUs and crank
through that you do not want to build
the entire tree and a stack of pending
things because you're not going to get
any benefit you just added work stealing
overhead to something that was
relatively straightforward so when you
have a balanced compute model again this
question mark comes with fork/join on
the flip side we've got fork joint and
it's awesome
so I just think we need to think about
how we can build general constructs that
can leverage it without sort of creating
things that people are going to trip
over and then the other side of it is
making parallel more parallel algorithms
we had ups we had a parallel map in
parallel reduce we've had them for a
long time we want to move them to the to
the newest model but we have to
understand that and of course being a
functional language we do want to keep
parallel algorithms out of the
collections and we saw some scholarship
where they combined it and there are
some cases where that's kind of easy but
you know we don't attach our functions
to our data we apply our functions to
our data however we do need data that
has a shape that's amenable to
parallelism and lists and sequences or
not so the stuff that we saw presented
that kind of collection is completely
awesome for parallel work whether you
use fork join or not you know the
vectors have a good shape for that we do
need something that could replace
sequences for that purpose that has a
better shape so much more work can be
done there data structures that are
amenable to parallel usage and more
parallel algorithms I think would be
really really great
all right I'm going to talk more in
depth about a couple of things the first
is transience and a little bit about
pods every want me to talk about pods
last year I didn't have time so I'm
going to talk about that now especially
because I got to a certain point in this
thinking and I got busy and so maybe by
explaining it up to this point so meals
can keep thinking so again we had
somebody talked about I shouldn't say
somebody
my house name we saw data structures
that you can access from multiple
threads and then create snapshots of
which should have reminded everybody of
our transients right we have transients
and have for a while where we can take
something that's a value turn into a
transient sort of updated in an
efficient way
and then produce a value later and we've
had them for a while there are alpha
still and my conclusion about them after
using them for a while is that they do
too much they combine this symbiosis
with persistence right being able to go
from persistent to transient and edit in
place which is great and then going back
which is really a data structure kind of
job with the policy job of ensuring that
you only do that from one thread and we
want to take those two things apart we
want to separate the policy from the
data job but the other thing about
transients is they do too little in that
the promise of transients while enforced
it only comes true when you use them in
a serial fashion right that everybody
you know you say about them don't
they're not nash in place that you
actually do have to take the return
value of a transient operation and use
that for the next operation it's very
clean to do that if you just follow the
the recipe which is right and
functionally then change it to transient
and the same shaped function will work
but you have to do that and people take
transients right off the shelf they
often try to bash them in place and then
bad things happen when the type changes
between two operations which we should
be free to do and also they're going to
be surprised so the first idea is to
lift to provide some constructs to make
sure that there's no no user the user
isn't have to be burdened with thinking
about what they're doing so there's one
way I think people have seen the
diagrams of the epical time model
whatever and there's a way to look at
the use of transients similarly right
which is you start with the value this
is this is process of making a transient
from the value and we know our turns
can do that in constant time so you can
have value without disturbing it or any
of its observers you can make a
transient version and it's essentially
free and then the operations on
transience I'll call procs for now a
proc is a function of a transient to a
transient and you can prevent you can
apply these products you know
iteratively to produce new versions of
the transient and whenever you're done
you can take the transient and convert
it back to a value and what we want to
make sure that there's only visibility
to the to the values right and right now
we do that by having the transients not
implement the value of accessing methods
but again the transients are sort of
doing these two jobs if you look at this
is this nice little box around this now
box's policy right the Box says I want a
value at 1 and I want to give you a
value at the other end and I want to be
in control of the application of these
procs so what about those products I
mean you know if you try to think more
about the use of transients as a like a
calculation model you might want to say
wow you know is this is this just the
bad side effect stuff again and the
answer is is no right
they might modify their arguments but
they they are really functions of
transient to transient right they're not
what this slide pops in one piece of the
time that's amazing
they can affect the world then they
can't be affected by the world I'm going
to do all this because I don't like
popping up as long as there's some
policy enforcing thing in place it will
ensure that they can only be used where
the transient itself can't leak right so
if you think about that if you think of
a proc as a function of transient to
transient the fact that it may modify
the incoming transient doesn't matter
right because the transients can't leak
and it's really a function in producing
a new transient you have to use that new
transient for your next operation if
you're doing something like this that's
insured just like the
functional transformations in any of the
reference types is ensured to be an
atomic serialization of activity so if
you had atomic serialization of activity
that involved procs it would be safe and
in fact that recipe or that property
means that you could always turn that
kind of use of procs and transience into
a function right because if you put a
function from value to transient at the
front end and you put a function of
transient to value at the opposite end
and you do all the proc stuff in between
what is that entire thing look like to
the outside world it looks like a pure
function by all definitions because it
is one and everybody knows that but it's
very difficult for a lot of functional
languages to accommodate that right a
functional function only guarantees that
what you send in isn't impacted by by
what happens inside and what you get out
is always the same if what you put in is
always the same you can meet all those
guarantees and use transients or
mutation inside the trick is can we
provide a construct that makes that work
safe and easy to get correct so the idea
for doing this is is something I call
pods mostly because this picture is just
so awesome as is the movie so pods do
this job right they split the policy out
from the data structure and in fact we
have a new policy now the policy is just
value in value out and the pod is in
control of the process so before with
transients the data structure because
it's always wrong if your data structure
does the job it's wrong this is the easy
way to do design if your data structure
like makes decisions that's wrong so so
now we have the policy separated its
value in value out the process goes
through the pod so now the pod is the
process thing right and as long as it
makes sure that it's a coherent process
to apply a proc to the transient and get
a new transient then that whole thing
will work and the beautiful thing is
that now that you've got the policy
separated out you can make independent
decisions like you don't have to bake
in the single-threaded access policy you
can have a different policy that said
multi-threaded access is fine and it
will internally use a mutex to make that
work which is definitely a useful thing
so pods obviously can work with
transients right all they're doing is
taking the policy out and putting it
into the pod right you can take a
persistent map and put it in it will be
turned into a transient you can apply
proxy inside and eventually get a
persistent map out but the cool thing
about proxies while that's a really
efficient way to implement the proc and
that's really great the the system and
their guarantees of proxy will apply
even if you weren't using transients
right not using transients as a
performance cost but it doesn't cost
otherwise it's not a semantic difference
right we already said the overall use of
a proc is functional at either end so
imagine if you just had a recipe that
says you must give me something
immutable and a way to turn that into
something mutable that the procs can
apply to and you must give me another
recipe to take that beautiful mutable
thing and create a value out the other
side you can make a pot around that that
will make it safe to use for instance
you can make it safe to take strings
turn them into string builders append a
bunch of stuff to them and get a string
result without any potential for clashes
or even safely across multiple threads
without the goofiness of trying to get a
synchronized data structure as if there
was such a thing so that's really cool
because that means that we have a first
construct that could apply to ordinary
java stuff it could let Java stuff play
our game so this is what pods would look
look like I can't actually read this you
basically wrap a pod around at well this
is what this version did you wrap a pod
around a persistent data structure and
there it uses protocols to decide how to
turn their persistent data structure
into something that can be used inside
the pod then you send procs into the pod
so here we're sending the transient
operation cons bang into the into the
pod to modify the transient that's
inside it and when you want it when
you're done you do
and you get a value out and the value
creation coming in I mean this pod could
have been created with the giant data
structure and coming out those are both
constant time operations then this is an
extensible system in that you can say
well nobody knew about pods when they
wrote string that I can make strings
play the pod game by saying the way to
get is transient out of a string is to
return a string builder and a way to get
a value out of its string builder is to
call to string on it and then you can
make things like string cap using pods
where you reduce with the pen with a pod
around the thing this doesn't seem that
interesting but it actually still better
than the loop and a lot safer and you
can start building things that allow
multiple processes and functions to
operate upon pods remember the policy is
separate now so if we want to have a
mutex based policy we could which means
we could allow multiple threads to
participate in the modification of an
ordinary Java structure has no friggin
idea this is going on or to transience
with us we separate the policy so
multi-threaded access we can do a
tremendous amount with pods right
admittedly a multi-threaded pod would
probably use a mutex right which is like
oh there's locks but the thing is it can
do a lot of work for instance it can
ensure lock acquisition order the number
one bug bear of doing locks yourself
what it can't do is it can't fix the
lock composition problem right block
composition problem says I wrote some
code that uses locks over here another
code here I want to put this inside that
now it ends up that when you think about
the way Trane's and pods would work you
know you wouldn't really put nested work
inside that would be in conflict but the
beautiful thing is should you have done
that you can make a version of pods and
the prototype version does this it can
detect that you've done that right so it
can't solve the problem it can't make
things magically composable but can say
you did something that's not composable
and therefore i'm not going to like
happen the other thing about pods is
they give you this interesting algebra
of values two copies so for instance
clone is just this terrible thing in
Java it's just it's almost useless
you don't know when you can use it you
don't know when it's safe you don't know
that the you know why you're calling
clone somebody isn't totally messing
with the thing you're trying to clone
it's just not a sound idea and there's a
whole bunch of things that you can't
clone but if you can imagine if you had
rules for saying I can take your thing
and I can make a value out of it and I
can take or I can take yeah I can think
your thing and make something I can go
into a pod and I can take what's in the
pod and make a value coming out the
other side you can actually write clone
just like this last second last line
here just D RAF potting something and
you've cloned it no matter what it is as
long as it satisfies those two protocols
on the previous slide that's kind of
cool
like I'd like to be able to clone
iterators of course the things you're
manipulating have to be inside pods and
then you can peek a pods I don't think
this is a good idea I mean I tried it
but I think well we'll see you soon so
there are a bunch of questions around
pods this is definitely unfinished work
one of the questions is that pair of
protocol is the right thing I mean
should we bake into pods that or bake
into a protocol is the recipes for
getting from you know values to
transients this we make that sort of a
pluggable characteristic should we let
somebody say I don't actually have a
value to start with but I'd like you to
see to pod with this transient or
transient like thing or mutable thing
you know just to start with I fire it up
can i initialize it that way would you
be able to revisit pod so the earlier
slide I showed you know you come in you
get a value you do some transient stuff
you get another value you take that out
because another model that says well at
any point in time you at any time you
look at it there's like Schrodinger's
pod anytime you look at it you get a
value but but it can keep going in other
words it might produce a value on DRF
and then make a new transient and then
allow more operations and do that that's
very tricky I did make something that
does that but I don't
again I'm not sure it's a good idea the
other question is lifting pods up so you
can do more composite operations so the
big bug bears with you
locks our composability problem lack
rockers lock acquisition order and then
trying to provide multiple work that
accomplices multiple units of data
correctly right so you always had these
problems when you assistance with locks
that's like I need to move away XY and Z
you know what locks do I need to require
in order to do that it's it's very
challenging it usually ends up on you
know written on napkins or something
like that or Joe knows how that works so
there's a notion of pod groups where you
can actually say you know inside this
set of pods do this work and that would
do the lock acquisition order part which
would mean that you could safely
manipulate more than one thing this goes
way beyond synchronized and what's the
problem with synchronized makes each
individual method synchronized it you
can't actually build anything out of
that now you can make caches out of
things where every operation is atomic
you can't make anything more
sophisticated than caches out of that
because you can't combine two operations
you can say if it's not there make a
decision and do something else
unless you've turned if it's not in
there into a special atomic operation
and you can't say if both these things
are there or add these three things all
at once or the classic problem move this
from here to there and don't make it
vanish somewhere in the middle of that
that's the things traditionally you have
to use locks for but pod groups solve
that problem much more cleanly again I
think they take care of two-thirds of
the problems with locks and they call
out and identify and catch the third
however if you keep thinking about this
you realize that that seems like a
really fancy thing the pod but it might
also do too much
most most the vast majority of the
applications you see of things like this
and the things you would think about
that would work like this are in the
sort of what I would call the building
or birthing category right I'm going to
start with something empty and a pile a
bunch of stuff into it and then I'm done
I need to give that to the world I don't
want to do that in a loop with a
functional object and create a you know
a million temporary things nobody ever
cared about and have the overhead of
functional programming
when no one could see it and that
visibility thing is really critical
thing we don't actually care about
functional programming went up for
things we can't see except for the
complexity it gives us and trying to
understand how they work which is why
you still want models like this so if
you were just thinking about building or
birthing you can have a much simpler
contract where all you say is you know
like an or conjure append or something
like that just put this stuff in and
it's a one-way street it's like you can
put stuff in as a sink you can put stuff
in you can't actually do anything else
while you're doing that you can't look
at or anything it's just pile stuff in I
think Google's sawzall language has
these accumulators so it's very
functional but you know all these things
need outputs and so they just pour them
into something that they can't actually
talk to again and the beautiful thing
about something like this which let's
just call an accumulator for the moment
is that that same front-end you could
put on some pod like transient builder
thingy but you could put it also on
queues a bunch of other things you could
sort more have a more generic construct
which is just about putting stuff
someplace and I think that's that's
potentially interesting and maybe even
if you decide to do pods you want to
make this notion first-class to make it
the front end of a pod or the entry
points of pod change okay last stop
before we go and start talking so we did
talk about extensible reader starting
with dates last week and I thought it
would be great opportunity to sort of
talk which is a little bit more
efficient about what the idea here is
and we already had somebody say closure
data is much better than JSON and that's
the easy thing to say but it's an
important thing to think about why do we
think that is and is it the greatest
thing ever
yeah I agree it's better but when we saw
the enumeration what was what was on the
enumeration slide
first of all whose slide was that the
chaise longue hi yeah so what was on the
slide
you can't answer more data types right
so what would be the advantages of
closure data over JSON more data types
what else mana data those things are
pretty awesome but and so but when you
think about that what are some other
examples of serialization formats so
maybe we beat JSON already there well so
we got xml let's not even compare xml to
closure data what does xml have over
json that's one thing what else X XML
has X actually XML has X and we don't
have X that's not good so what happens
what happens when we want something we
don't have right now in closure data
when we want to talk about a date what
do we do all kinds of stuff that's not a
date right
and while while you can build two ends
of a system that do that you lose
something really critical so I'll ask
another question what's the difference
between JSON XML and closure data and
protocol buffers that's one
yeah the first set is self-describing
what's the other set if you sent me some
protocol buffer data what can I do with
it
Deb null I don't know I mean there's not
a lot useful I could do it I could save
it for you till later and give it back
to you intact
maybe so so that's a big that's a big
thing right having a self describing
data structure what does that mean for
someone when you have a self describing
data structure it means you can send me
stuff
I don't really understand I can actually
do a significant amount with it right
because if you send me strings that have
dates in it and some other strings have
your eyes in them and some other strings
have some other random stuff in them and
some numbers mean numbers and some
numbers mean dates what if I now got I
have something I need to I need to
understand the schema of in order to
correctly process render allow the user
to edit if you sent me something some
hybrid data structure and it had dates
in it I'd really know what the bigger
picture was could I make can I give the
user an editor for that oh my god not X
I prot I could not really the answer is
no you couldn't so so so you have to be
very careful right when you say I could
just use a string you could just use a
string but when you do you're moving
away from self description and self
description is really valuable so I do
think it's great that we have more types
and I think some people want even more
still and so we're using more types than
we can represent everybody's pretty how
many people are using closure data
represent things it doesn't represent at
the bottom like dates or your eyes or
something else so it happens and and
we'd like to do more of that so I think
we want to get the X in there and the
trick is we need to think broadly about
how to do that in particular I think I
should start looking at either more data
types that are kind of well-known like
date or real true extensibility like
user stuff
you end up having this bifurcation
between the serialization transport
format and the semantics that are
conveyed there and the representational
space like already we had this fantastic
very highly predictable disagreement
about what kind of date do we want to
get because there's no right answer my
different programs have different needs
different requirements it's it's
completely correct to say they need to
use different kinds of dates on the
other hand being extensible can't mean
closure is going to start making
first-class libraries for every type of
thing everybody might want to possibly
use that's going to create a tremendous
amount of weil rebuilding especially in
areas where there are good good
libraries so that's sort of the why the
idea that I'm floating right now is that
we separate the print read
representation and semantics from the
programmatic representation right Stuart
showed us sharp equals the other day is
getting kicked out of sharp equals Club
by the way as well as well what's wrong
with using sharp equals for this well I
can't say sharp equals date blah thing
that will work right it will give me
exactly what I want right is it is it
actually now self describing only to
what closure a closure app maybe what if
I sent out the closure script a Java
constructor call now so we can't do this
we need to split these things up this is
what design is design is take your good
idea find how many pieces you can cut it
up into because it will be better when
you're done so we have to split these
things up the print read representation
and the semantics of that from the
progress of programmatic representation
so one way to do that and it's sort of
like if you can do this well once you're
completely out of jail because you've
built an extensible system that is
composable is to just say we'll have
some way to say I'm giving you something
extensible and I'm using that to tag
something you already know how to read
that
sit how many people are familiar with
Erlang's trance Bert you know the
transport format what's it called
no that binary term thing BRT er T right
and then some we made Bert I'm homemade
Bert Bert is the text version of that
right yeah that uh the read it read it
guys hope github somebody cooler than me
made it but the idea behind in the
Erlang implementations really sound it
basically says we only have you know
however many types there are in Erlang
six or something but we want to convey
information about different semantics
all we're going to let you do is say use
a map in this way and that tag will
label this other data structure we
already know how to represent as being
that thing and this is the same kind of
idea we have a tag on something that's
readable and we use that to do these
first two jobs right what are the
semantics the tag that takes what that
is you know we say instant means a point
in time and all agree on that and how
we're going to print it and then the
type you get can be independent as long
as the representation you use is
something we can already read you can't
say I'm going to put these weird
characters in here so this is not what
people expect from extensible readers
they expect I want I want like I want to
make how many blood characters we have a
dollar sign do this thing you know I
want dollar sign to be some magical that
we're not talking about that at all now
we're saying we're not actually going to
give you more than one last thing the
last thing is a portal to extensibility
and then you be able to leverage
anything we already read including any
extensions that have already been made
so this is what that looks like you
could for instance say instead of saying
sharp at sign as cool as that is sharp
instant and don't get all fixated on the
actual syntax here this is just the idea
tag readable thing by saying tag
readable thing and where the readable
thing is the string with a date you're
saying this thing once you've read it
should be passed to some
that expects to get a string we all
agreed we're going to use a string with
this this this parse format for this
purpose and then the devalue they're
going to get the actual type of thing
they get back would be something they
could plug in they could register and
say when I read instance in this program
I want to get Jota instant type and is
led they made it constructing and
provided a plug from this string format
- Jota instant type that's what they
would get in the reader would allow that
but could I send this to JavaScript and
have something meaningful happen sure
could I send it to anybody
sure if we had this would we have our X
yeah this is the end game right so the
next one might be creating an array
events and the last variant here would
be the user extension point I don't know
what kind of composite thing you might
want to have because we have namespaces
we can just use namespace tags so we'll
say non namespace tags are reserved for
the language or thing which will include
things we all agree everybody needs but
if you need something else you can now
say this and the beautiful thing about
this is you're not actually saying I'm
calling some specific constructor or
anything like that you now have a way to
talk about semantically I want to send
my foods around and I can build one end
which produces foods enclosure another
end which consumes foods and closure
script another end that sends them
through some event processing system
which is completely hopefully language
independent and this is a good recipe
for that I would love for you know we
have Neil talked about all the ways to
grassroot up I'd love for closure data
as a serialization format to be one of
the roots because it really does kick
butt and with something like this I
think it's it it's now plain plainly
superior to the other options so that
that's the general idea there and now
it's time for questions
and I just make the point if someone
want to go with the accessible meter
thing it's the tag Foreman is exactly
what llamo uses for accessibility okay
if you want to see how that's
implemented exactly that yeah I mean
they may be novel to get hey I'm ripping
it off from her leg but I'm sure they
might have to guess so yes well so
there's a different reason
I'm principes use for a bunch of
different reasons and for some reason
you super care so semantically there's
no difference between array map and the
hashmap
persistent hashbrowns so in only be they
do somehow care that may be using
printing for that the other real reason
to have in print too is like your things
like although actually I mean if
restrain season yeah that's that's
basically the thing that where there's
some polymorphic nature to what you're
supplying and you don't want to have it
erased by the round tripping I think
printing is inherently a non-portable
concept but certainly any use of print
doom or and it so also people use print
too because they want something like
more concise for the human interactions
and something really
really robust constructive otherwise
yeah this is definitely better than that
has way better than charges it shortened
equals is strictly unknown stopgap thing
and there's a reason why it's a secret
really great secret at this point looks
like Wednesday greeted about what goes
into what what does not agree about what
presentable comes out this an agreement
about what instant means and what what
data structure will be used to represent
instance like there's nothing about
there's nothing else about this so you
say asking when will the plugin happen
this is no agreement about that we
haven't decided it with those victims to
be we do want something that you can
definitely insert at the bottom of
everything so that you can start a
program and have your preferred date be
used everywhere including dates and
instance use embedded inside programs
so even code reloaded will use the same
mechanism to rehydrate using the data
structure choices but it's really really
critical to not dictate the data
structures as soon as you start even if
it's to closure apps in the same company
you still may have disagreements about
how you want to you know represent
things and you should be able to make an
independent decision about that I don't
think we're to support making
independent decisions inside the same
program except through potentially
dynamic binding
I think we got off on the wrong track as
people saw that because it would be the
only definite lead on complain that's
the bet in the computer algebra area
they have the problem of two systems
that need to communicate what it would
look like a normal equation like
polynomial they're completely different
representations and potentially
different semantics who are left side
means they are is an effort called open
back been going on about eight to ten
years to separate syntax and semantics I
think you might find that useful for the
kind of communication protocol yeah
definitely it does the I detest the idea
here
so is the idea to the extensible reader
that my NS who just gets a stream of
characters and produces something from
it or no no there's some data structure
that you give it and I can't get that
data structure as a input to your
pluggable function yes I know another
topic yes your life break this idea of
burying programs like query programs
what does it mean well for what would be
an example example there's some really
simple things like how often do we use
this function is a simple question do we
ever call this function inside that part
how deeply nested
this function how we never call
dysfunction while holding a lot with an
open file again where is this data
structure used as a property like
program analysis yeah we're going
elseís that's right people pay the big
bucks for AI system to analyze Java
programs and they work exactly the same
way so it's all sort of the scope of
stuff they take the output analysis
phase and open into a database and they
give you a quarry engine I can access
that database it's that kind of idea
anything you might do with
aspect-oriented programming category or
any kind of cross-cutting concern
even simple type things by talking about
the relationship between multiple
arguments or arguments to this function
that were subsequently the results which
were subsequently passed in a function
we tried talking about constraints that
work like that it's incredibly difficult
with real systems have those kind of
constraints all the time I'm just way
far away from
which is
environments implementation I don't like
that at all
I basically is reified environments and
I don't see how they could be made maybe
it's my own
but you have to really have done it from
the bottom which Newspeak has but I
think it's something could have the
language like closure now we don't have
process environments at all yeah
my technique if you wanted to you know
the reader macro this extendable stuff
yes
yeah it depends on what you're doing I
mean if you have access to the original
nature there are definitely if a story's
like reduces definitely much faster and
there's an optimized past path for
reducing eternal reduce the next thing
I'd like to do in that area would be to
have reducers that are able to terminate
the reduction because that's mostly when
I do a partial iteration that's
difficult to do is producing produce
businesses the whole thing but as soon
as you have a partial produce then what
you do is basically hand off the job
doing the work to something that was in
terms of the data structure which
doesn't efficiently without creating
seeks and give you the answer back
that's ultimately the answer the higher
level of things like Haskell does this
amazing stuff with stream fusion I
actually use a good example of something
for which type systems really helped you
in read which struggle trying to emulate
the previous talk to talk about striving
for power you talk about things like
access 8-points devilís build sarah
that all seem to be ways of getting
closer there or both identify is the
major largest couple of things getting
closer clatter well I mean I think we
have a great platform most this has to
do with the nest of our utilization of
the platform to be more efficient not
actual access and so okay so anything
about power now to add Stu's talk but
rights worked overtime what's the worst
value of your time
never infinite no the horse answer's no
so like you can't do that and there are
very few things for which that's true
anymore so I don't think I don't
consider most the straight platform
powers which is more efficient those
things you making a leaner build doesn't
really change how we're using the
platform of course the leveraging ok
nabek now that ship is an example of
platform powered we're not leveraging
yet so we did that every 1/4 join this
came out same thing so those two data
Jordan right now yes I think it was last
year we talked about maybe introducing
some kind of new scopes for variables
there was an example where you might
have done a computation with a resource
and built up some kind of lazy see yes
sure it has escapes and you Rishi is
gone
yep does anything happen in there yes I
realized as part of that I thought not
close to solving it the fundamental
problem is yet this nested composition
problem right how can anyone know they
can to limit the scope of something it's
effective axes we've done some lazy
stuff potentially dependent on resources
and maybe you can soon Fargo maybe you
didn't but the problem is you can't
recognize what
you have has these issues how is you
decide this is a scope that's been
puzzling to go away if you return
anything because the thing to return
might be using some parts of that know
exactly how all the trees interpret and
so that's sort of one of the fundamental
problems it ends up that in in the field
what ends up happening for people is
they will casually use something like
math on something like
to a map server and letter return
results actually what they really want
is to return fully realize because they
actually do not want that connection
left over for most of the problems come
from people who do not want to lazy
evaluation of India and so our near-term
solution is actually give you a P which
maps into a vector and it just does all
the work
and so like read nested parts of a tree
you really do one fully give a fully
realized tree which is connect instead
of something waves for the bigger
problem I think there's no library style
answer for this absolutely different in
different places but I'm not nervous or
anything of something else
when I say
we don't have and so how do you get them
around but there's still a reified part
of the execution of nobody it's
happening in the runtime on your behalf
I mean closures decided way way way back
it was not having extra arguments every
function which is going to be extra
stuff gap for me to use for stuff like
that so we don't have that and we call
through things we don't control it's
very difficult to do that without a
bottom-up kind of support for it
I don't know if you can prototype it
yeah
the to array
Wow hope so really the board rewrite
guide up Rita costume depends rate that
depends on the whether or not it's
something that compiler is designed to
also understand the cloud it's an or
thought or question with another
compatible understand how does compiler
does why to say something in code when
you open up we need to apply this you
apply a book to say I want some kind of
utter persistent map implementation on
that bill pending package so what I'm
going to add this tag to it no but it
changes it if the reader now becomes
extensible says if I recall you said
you're going to register it says the tag
instant gets this kind of straight up
here they do have the fabrication magic
special tags for things alerting those
of them might as well just I was
thinking if the reader was allowing you
to register constructors for various
types would it be worthwhile or not real
trial to add you already got a hook
daresay we have a constructor now for
our standard map or standard you know
have you got better boobs I don't know
well then here what we're going to talk
about using the intuition is yes I'll
just know
the certification like just service for
example you may want to pull it into em
half of their it Java pulls it in and
may want to be heaven forbid mutable
right but you can just use it that way
they just suck at second that data
structure and give me mutable hashmaps
whenever you see it back in the binding
context I can see something like that
but you don't want to change the maps
before or native I'm not I've never
asked that what I'm saying just well so
that means you have to imagine cultures
are the things that good already knows
but I will show that tax correct right
but just building with right we're
definitely possible to make everything
I think that's what I'm talking about
with clerical programs and I think
that's exactly what that is
but I wouldn't want to limit your
imagination - what type systems
difference that's all
I think that's exactly what I'm talking
about because that's what that is right
you take a progress doesn't necessarily
indicate much I would I would like to be
able to say you didn't bother to
annotate your types but I could for you
over the logic side why not you let the
lazy guys
don't know about that that's very young
I understand completely what you're
asking for there it may be the case that
certain tags we have that characteristic
right in other words they'd have a way
like you would say it's a really huge
thing part of the agreed-upon format
would be that there's a count in front
of it makes it skippable by making a
full skippable thing that supports
nesting so the trick is usually nesting
and things like that if you ever looked
at like the shell file formats and like
that I gets much more involved right if
you want to be able to say hang on which
level on that I'll skip the entire set
different things to get over to you next
thing I notice is you expand your scope
beyond one datum right or one structure
to a composite thing that requires a set
of these things or in essence that amis
thing then the skipping job is much more
difficult right if I you know you can
always get down to say I'll just go skip
one thing you only have the ability to
skip one thing I usually desk
insufficient in the end but it will be a
starting point you certainly could say
there are really large things are going
to require they be late prefix yes
basic instruction
yeah
you can definitely consider that the
beautiful thing is there are all those
between us can never change your way
where your mo types you can do it every
life for the for the agreed-upon types
know it because could be one of these
we'll have to think carefully about it
because of course we have metadata so to
the extent the representation part you
use was a type that accepted meditator
string stuff that would be impossible
task
otherwise no they took my like a global
level in the file double you had lioness
food and you had put out there that
storage that data somewhere across
systems change bar but you still want to
be able
and upgrade to the current version and
keep going
Porter Costco something like
build a fake date and they say stick
into the name but I mean is there is a
reason why metadata doesn't work for
this okay
I would rather first that's a cool thing
about benefits of being so useful things
like this a little bit harder we forgot
to put a slot in for conversions okay
stop the metadata on there I am slab as
makes lots of joint you can call
whatever you want I want to thank
everyone again both for using closure
and for coming and I hope you're having
a good time and</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>