<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Andy Keep - Writing a Nanopass Compiler | Coder Coacher - Coaching Coders</title><meta content="Andy Keep - Writing a Nanopass Compiler - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Andy Keep - Writing a Nanopass Compiler</b></h2><h5 class="post__date">2014-01-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Os7FE3J-U5Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks very much so I'm into keeping
following in my officemate will birds
tradition I'm I'm not gonna show any
closure code today sorry but I will show
some scheme code so so so I you know I
wanted to start by saying I'm and II
keep and I love compilers I love writing
compilers and doing things with
compilers I just I think it's a lot of
fun so I wanted to start out with a
little bit of compiler history just to
talk about what the idea of the Nano
past stuff was and what the Genesis for
it is so we used to write compilers as
just a handful of passes for convenience
here I've only represented three passes
most of those compilers had more than
that but not too many more than that and
the early compilers were written this
way because each individual pass had
some work that it needed to do but there
weren't enough resources on the machine
to necessarily do that all in a single
pass and in fact there wasn't even
enough resources on the machine to store
all this stuff in memory each pass would
actually read in representation of the
program write it to the file system the
next pass would read it in and write it
to the file system and so you can see
why they wanted to minimize the number
of passes that they had in their
compilers especially when the file
system was a tape drive or paper tape so
you know not not not a great design or
not a great space to be able to do this
stuff in but computers got better and
then we could do our same handful of
passes and we could keep everything in
memory and that was that was kind of
nice but people continue to write their
compiler sort of this way I mean there
are some exceptions some things were
written with many passes but for the
most part it stayed this way and
sometimes we even never write it to the
file system we just go ahead and run it
and you know that's pretty cool this is
sort of the situation when you're at the
repple and something like scheme or
closure or Haskell or ml or whatever
your favorite repple is and to talk a
little bit about the compiler that I
worked on a single pass did closure
conversion loop recognition it began our
handling and handled multiple return
values foreign callable handling foreign
function handling direct call
optimizations and then closure
optimizations started in one pass and
then continued in the next pass and the
thing that makes this all kind of tricky
is that if I'm sort of actively working
on my compiler and I want to add a new
optimization and that new optimization
has to happen after one task but before
another task and both of those tasks are
performed by the same pass well
now I'm sort of in trouble because I
have to find a way to kind of weave that
into the existing pass without breaking
anything that's already there and so
that's pretty tricky so we sort of
wanted to do is we want to take these
things and break them up into a bunch of
small passes where each one of these
passes is just performing some single
task and then run through them that way
so as I said I love compilers but I
particularly love Nano Pass compilers
and I've spent some time working on this
stuff so just to give you a little
background on where the Nano pass stuff
comes from this all grew out of the
compiler class at Indiana University or
at least had some of its Genesis there
so my advisor can't dig who was at
Indiana at the time had gone on
sabbatical I think and Dan Friedman
taught the course and he really wanted
to get away from this sort of teaching
of passes these big passes and you know
building a compiler anyone talk
specifically about like what are the
ideas the interesting ideas in the
compiler and how can we get students to
go through them in a way that they'll
more easily understand them and so he
came up with this idea of writing these
passes that were very simple just did a
single task using like a pattern matcher
and introduced this idea of playing the
game where you hand it in some piece of
you know something that looked maybe a
little bit like scheme and you got
something out that maybe look
a little bit like scheme but had been
transformed but you could evaluate the
input and you could evaluate the output
and you could see that both of them were
the same and he called this playing the
game and so we still do this in the IU
compiler class now that particular year
my understanding at least is that the
compiler sort of wasn't a compiler as
much as it was a set of disconnected
passes so the ideas got across but they
never built a full compiler so when my
adviser Ken diptych got back and started
doing this class he said ah here's a
good idea but we have to have the
students build a compiler of course and
so the result was a compiler that was
around 40 some passes that the students
wrote over the course of the semester
and it compiled a subset of scheme down
to assembly code and implemented things
like a graph coloring register allocator
and fun algorithms like that and the
whole thing was written with match and
the representation that we used for the
compiler were lists so we're doing match
over lists and this was good worked
pretty well
but there were a couple of downsides the
compiler was a bit slow partially
because of some of the pattern matching
overhead and I don't have it on the
slide but the other sort of downside of
this was that you might have a pass that
produced ill-formed output and the next
few passes accepted it because it they
didn't know any better or they didn't do
anything that have impacted it and then
you'd have a pass fail that was five six
seven passes down the line and you would
think ah you know this tenth pass in my
compiler must be wrong because it's
where the error occurs but the problem
wasn't there the problem was actually
five or six passes ago when you had this
malformed result and so the idea was
then to create a nano pass framer to try
and address some of this and so the nano
pass framework was originally prototyped
by Kent
a fellow named Oscar Waddell and and
primarily by deepest Sarkar and they put
together a framework they wrote a paper
about it they sent the paper off they
said we
have this technique for doing
educational compilers and you know
commercial compilers and they sent it to
the AI CFP of the International
Conference on functional programming and
they said no we don't believe that you
can do a commercial compiler with this
we think you have to refocus the paper
to just say educational compilers so
that was the nanopatch the idea behind
the Nano past framework and sort of its
its first iteration some of the details
of the nanopatch framework we have
formal language grammars so we define
the syntax of each of our intermediate
representations between each of our
passes this gives us the ability to
check that information as we go along we
then define passes over these grammars
so we're able to create these passes and
make sure that they have a formal input
and formal output language when I say
formal here I'm just talking about a
grammar syntax and out of semantics and
then we made it easy for languages to be
extended so we wanted to be able to make
very small changes and have lots of
languages in addition having lots of
passes and this led us sort of Express
these tiny changes as we are going along
and the past form itself can generate
some of the boilerplate code that we
otherwise would have had to write doing
all of these sort of micro passes using
the match system so we have two forms
main forms in the language define
language which we use for defining our
languages and define paths which we use
for defining passes to this I've added a
couple of other forms with output
language that allows us to create
language forms outside of a pass and
nano pass case which allows us to match
language forms outside of the pass so
the idea there being that you know
sometimes we need to sort of separate
the two things that the passage does
reading and constructing
language forms so all this machinery
gives us some benefits first it allows
us to auto-generate some of the pass
clauses so because we know the input
language and we know the output language
and we know how they're different we
also know how they're the same and so
for those things that are the same we
can auto generate things like
recurring through forms that are
otherwise not changing but might contain
some changing form it also allows us to
choose a more efficient representation
than lists so in in scheme we don't have
some of the fancy data types so you guys
have enclosure but we we do have records
and we can use the records to make
things more efficient by making a
decision about what pattern we've hit
just looking at the record and not
needing to sort of traverse the whole
list to decide whether or not we've hit
a pattern match it also allows the
framework to check that output from each
pass is going to be well-formed and so
now if our pasts is producing something
that doesn't match the syntax we know
for sure immediately that that's not
going to meet the syntax and we can
raise an error right away and hopefully
a student or a commercial compiler
writer that runs into this can fix it or
much earlier on so as an aside we
decided that we wanted to take up this
challenge of a commercial nano pass
compiler and we did this in the context
of che scheme which is my advisors
scheme compiler and we took his compiler
and we decided we were going to write a
commercial nano pass compiler so his
original compiler looked something like
this when I first started working on it
it had about 11 passes 5 6 front end
passes one that was optionally run with
the source optimizer that's the sky in
the middle here which again my laser
pointer doesn't actually seem to show up
but though well and we sort of kept the
same front end and we kind of exploded
the back end just a bit so just so you I
can spare you counting there are 52
passes now on the back end so we went
from 5 to 52 and we added this loop here
in the back end as well where we're
doing a graph color and register
allocation which gave us some benefits
in terms of the performance of the code
that we compile but did slow down the
compiler a bit just to give you an idea
though of the order of time that we're
talking about when I started the che
scheme compile
could compile itself in about three
seconds so tens of thousands of lines of
code roughly in about three seconds well
okay to be fair I haven't counted but
it's a significant amount of code and it
does it about three seconds the new
compiler currently will compile itself
in about ten seconds
so it's still very very fast even though
it's doing a lot more going through a
lot more passes and sort of the the idea
here is that it's not the number of
passes that impacts it as much as it is
that you have some passes in there that
are just more expensive and they tend to
dominate the amount of time that you
spend so we actually the overall compile
time is only about floor by half but as
much code as we had before our macros
now that we use to define these
languages in these passes generate a lot
more code so with all that said I
thought it would be interesting for us
to look at an example and I did a little
bit of a stupid thing I was going to
talk about the class compiler that we
have at IU but I sort of didn't want to
put that code out on github and share it
because you know we we have students
still taking that class and I would sort
of feel bad if one they downloaded it
and turned it in as their assignments
because they wouldn't get the benefit of
actually learning it and the fellow
that's teaching the class right now
would actually have to try and find all
those cases and yeah wouldn't work out
well so I decided Monday afternoon that
I would write a new compiler and it's
available on github
I haven't slept much in the last few
days but it's available on github and
we're gonna compile a we're also going
to compile a subset of scheme so just
some parts of scheme here we're gonna
represent our variables as symbols not
surprising this is how we represent them
in scheme as well we're gonna have a
handful of constants true hash T false
hash F nil or no and 61 bit integers and
I'll tell you why 61 bit signed integers
in a few minutes and then we're gonna
implement handful of primitives so power
could or cons pair and null for dealing
with you know lists and pairs
bullying question mark make vector
vector ref vector set bang vector
question mark vector length box unboxing
box set which is not something that we
have the students implement but we're
gonna use it for something you'll notice
that I didn't put set car set cutter in
there so write lists are immutable we've
got plus minus times divide equal those
are all gonna operate over our 61 bit
integers the you know other comparison
operators and then EQ which we're gonna
use to for sort of identifying whether
that something is the the identity right
so is this thing exactly that thing in
memory and we also have quoted datum so
we can define constants we can define
quoted pairs which then can contain more
datum and then this funny thing here
with the hash is how we represent
vectors and scheme so we're gonna use
this to represent vectors which are
basically just fixed length arrays okay
so I said that we had a formal language
for defining these things in the
nanopatch framework so of course we have
a source language and we can define that
in using the Nano pass framework here so
we have a set of terminals and part of
how we know that our languages are
well-formed is each of these terminals
corresponds to a predicate so scheme has
a a predicate called symbol question
mark we're gonna use that for
recognizing our variables the primitives
I wrote my own predicate for constants I
have my own predicate foreign datum I
have my own predicate for to check these
things but this is going to allow the
nano pass framework to check to make
sure that when we construct a new
language form all of the parts of it are
of the correct type then we have a set
of productions that are are the
expressions in our language so the first
few productions here are standalone
primitives references to variables and
standalone constants and quoted datum so
these all look like s expressions but
underneath all of this we're going to
create records for anything that's
structured so this quoted thing here
there's actually going to be a record
created for it with one field
then we have our branching things if one
armed if two armed if or and not and of
course we could implement or and and not
as macros but our language doesn't have
macros yet so we have to actually define
those as compiler passes and the
dot-dot-dot here just means we're gonna
have zero or more of these things so or
has to have zero or more elements and
and has have zero or more elements and
these of course are each getting at a
record associated with them as well and
then finally we have set bang mostly
because I just think assignment
conversions kind of fun I don't have any
particularly love of set bang but then
we'll have begin so that we can do more
than one thing in our ifs let let rec
and lambda and of course function
application and the square brackets here
they mean the same thing as the round
brackets we just use them to so that we
don't get confused when we see the
bindings so I'm sorry if it's a little
confusing I know that closure uses these
to mean different things
so schemes a little bit yeah you know
everything's a parenthesis in scheme so
so our target language for this is going
to be C now normally you know I target
assembly but again I did start this
Monday afternoon and I felt like you
know writing the register allocator
while it's a lot of fun also tends to be
a little bit of work particularly
remembering how to get it right and I
wrote some of this on the plane I knew I
wouldn't have reference to everything
that I that I needed so I decided to do
it and see mostly so that it will do the
register allocation for us so I went
home Monday afternoon and I wrote a
bunch of code and then I got on a plane
I wrote a bunch of code and then I kind
of finished up the last details of this
over the last couple of days and I got a
compiler that looks a bit like this so
again to spare you the counting there 27
passes here and this takes us from our
source scheme language down to C and we
generate C code and just to zoom in a
little bit the first thing that we're
gonna do is sort of parse and rename and
it's a little unfair to say parse we
call this parsing in scheme but really
we're gonna use this
reader to do the reel from string
parsing and we're gonna use s
expressions and turn them into our
internal record representation and we're
also going to rename variables so that
once they're in the compiler they're
always unique that's gonna that's
helpful for us because then we don't
have to worry about that later
then we've got some steps that are just
gonna simplify things we're gonna remove
our one-armed if we're gonna remove
and/or a knot we're gonna make the
begins explicit in the bodies of our let
let Rekha and lambda we're gonna inverse
Aida raw primitives which is a really
fancy way of saying that when we see us
primitive standing or standing by itself
we're gonna wrap a lambda around it with
the proper number of arguments and we're
gonna call it and this is mostly just so
that we can move all of our primitives
in to call positions so that we can do
what's called open coding them in other
words we're gonna generate the C code to
do those directly rather than having
some function that we're going to call
for the primitives then we're gonna
quote our constants remove our complex
constants so where we have structured
constants we're going to make their
allocation explicit and we're gonna
identify the assigned variables so that
we into assignment conversion and we're
gonna turn our light Rex into things
that bind only labels to lambdas
optimize direct calls is just a way of
looking for directly applied lambdas and
turning them into let's we're gonna find
our let bound lambdas and turn those
into light Rex we like let Rex there
they're pure and fun to deal with we're
gonna remove our anonymous lambdas and
we're gonna convert assignments and
that's going to get rid of set bang for
us so by the time we're done with that
everything will be either an immutable
variable or a data structure that has
some way to mutate it then we're gonna
uncover free variables convert closures
we need to do this in order to sort of
drop this stuff in to see where we don't
have closures available to us well okay
I know that there are now if sort of
lambdas in in at least the newest C
standard but we're not going to use them
and then we're gonna optimize known
calls which is basically a way of saying
we're going to make the function call
rather than pulling it out of the
closure we're going to just call it
directly
now we'll lift the lambdas get rid of
nested things nested expressions will
separate things into contacts I'm going
to all that detail expose the allocation
primitives is going to basically start
to convert some of our stuff into
something that looks closer to see we're
gonna entry introduced set bang we're
gonna get rid of let we're gonna flatten
those so that they don't have we never
have a set bang that's on the other side
of a set bang and then we're going to
push our ifs in which we I think we need
to do for C just to get all of the
predicates in the same place we're gonna
specify a constant representation this
is part of why we have the 61 bit
integers and we're gonna expand
primitives and finally generate C which
it's a lot of stuff so first let's start
by looking at the second language in our
in our compiler so there are 23
languages total l source the the only
admittedly the only named language and
then a whole bunch of unnamed languages
that have been conveniently enumerated
as l1 through LT 2 yeah sometimes it's
hard to come up with meaningful names
for these things so the basic idea here
is that we're making a very small change
we're going to extend our our list of
primitives to add void and we're going
to get rid of our one-armed ifs here and
so that's going to be the technique and
we're gonna look at one pass here in
detail so this is the very first pass
it's not too much code to write actually
it's just this kind of one-line clause
and some of the context to wrap around
it so when we define a new pass we're
going to get a new function named remove
one-armed if this is our name and then
we have a signature associated with it
and the signature tells us what our
input language is what our argument list
is so this one accepts one argument and
it's an argument of the else source type
and then we're going to have an output
language and we're going to output the
one thing the language thing and scheme
has multiple return values so we have a
way of returning multiple things but
we're not going to return anything else
here so we can indicate that by just
having these empty bracket and
deeper ends here and then we're going to
have a transformer and the transformer
here is just this piece the framework
figures out what transformer it should
call automatically and the transformer
we we can name we tend to name it the
same as the non-terminal that we're
processing but you can choose any name
you like
we just have sort of done that as a
standard and then we indicate what the
input non-terminal is what its argument
count is what the output non-terminal is
and any extra values that we're on a
return and then within the body of our
transformer we're going to match some
Clause and take a look to see what it is
so we've got an if here the one armed if
that we're trying to match the little
commas here these are schemes version of
unquote so the tilde that's used in
closure this was the scheme equivalent
of and then our square bracket and
things here this is actually to indicate
what's called a cat a morphism the the
idea behind the cat a morphism is is
really fancy category theory stuff I I
think of it as I recur on something
that's smaller than the thing that I had
before which I think is more or less the
definition so what this is basically
going to generate for us is a call to
expert so it's going to generate the
value of e0 by calling exper on the
thing that it found and making that
available in the body so we really don't
have to do too much fancy the really the
work that we're doing here is to add
this void so that we have a two-armed if
instead of one-armed if so here the
quasi quote even for those of you
familiar with scheme is maybe going to
be a little bit misleading quasi quote
does not do what you expect it to do
here because it's not building a list
it's actually building a record for this
particular type we made use of the fact
that we have the flexibility of the
macro system to override what quasi
quote means in this context which is
nice because it means that we can sort
of take our old match based compilers
and we can just kind of translate them
pretty easily but it's a little
confusing for people when they first see
this stuff
and then of course we have our quotes
again again this is our unquote and our
void and here we are actually building a
record for the primitive call or for the
rather for the the call here and the
primitive is just the quoted symbol void
which we don't have to do the unquote
and quote around but I think enclosure
you do have to do the unquote and cord
around to get that piece working so
pretty simple actually
but this it really isn't all this past
needs to do because there are many many
other forms in this language that need
to be recurred through and so this is
one of the great things about the Nano
pass that actually is going to generate
for us all these other clauses that we
don't need to worry about and if it
finds a closet it can't figure out how
to build it will either well okay let's
see does it ever complain at compile
time I don't think it ever complains a
compile time although it probably could
in some situations but what it does do
because I got sick of trying to debug
this while we were working on the Shay
scheme compiler is it puts an error
message in there that remembers the
source location of where things may have
gone wrong and reports back hey
something went wrong at this source
location which is kind of nice when
you're trying to debug things especially
if you spend about eighteen months
working on a compiler and it turns out
you run into these things more
frequently than you would like because
you forget to write some closet you
needed to write okay so let's talk about
the representation I said I would say
why we had 16-bit signed integers 61 bit
signed integers so the whole reason
behind this is because schema objects
are going to be word aligned we're gonna
kind of play a little bit of a game here
and put all of represent all of our
schema objects with just a one a word
sized 64-bit pointer because their word
aligned it means that the bottom three
bits are always going to be 0 so hating
to waste anything that we could use
we're going to use those bottom three
bits in order to tag the types of our
pointers
so these bottom three bits are going to
give us a tag for pairs vectors boxes
closures and actually for fixed nums
which is why we have our 61 bit signed
integers we're actually going to use raw
pointers to represent them where the tag
on them is just going to be 0 it turns
out that works out well for the math and
we can identify them fairly easily so
what about representing closures because
I said you know we don't have closures
in C and there's a different number of
different ways we could have decided to
do this but I decided to sort of follow
the model that I'm most familiar with
partially because I was you know running
a little bit on trying to get these all
put together so we're gonna use what's
called a flat closure representation
with a flat closure there is one slot
for the code pointer and one slot for
each of the free variables that's needed
so just to give you an idea of what that
looks like let's imagine we have these
nested lambdas here and we want to
figure out what the closure looks like
for the innermost lambda so we do a free
variable analysis and we figure out that
x and y are free variables in the
innermost lambda because they aren't
arguments they actually come from the
outer lambdas here so when we create a
closure for the innermost lambda we need
to have one code slot and two data slots
one for the X and 1 for the Y and that's
how we're gonna represent things
internally so what about C I mean how
are we going to represent all of this in
C and one one approach that we could
have taken is to represent our closures
by building new data structures that
represented each closure we could
represent our pairs and boxes and things
like that as data structures but you
know I I don't like to do that kind of
stuff I admittedly some of this is
because I'm used to generating assembly
and I kind of like to play with the low
low low level representations so we're
just not going to tell see what we're
doing at all because you know what C
really doesn't care
C you see is happy to do whatever you
want with a pointer and that's what
we're gonna do so maybe not the safest C
code
we're gonna have to trust our compiler
is gonna generate the right stuff so
instead what we're gonna do is we're
gonna just play with the memory directly
when we need space will allocate some
space when we represent a fixnum
that'll just be in a pointer so so with
all that said let's take a look at this
and me adjust my screen here this works
that's so much better if the displays
are married all right so yeah copyright
you know I put that in there mostly just
so that I can put a like an MIT
copyright on these things MIT style or
BSD style copyright so this is all this
stuff this is what's out there on the
the github actually these are all the
random things were we're exporting the
important thing from our export list is
we've built this as a little library and
we have the main entry function my tiny
compile which is going to compile things
for us using GCC as the backend and
actually reread the value we're actually
going to do everything from inside
schemes so that we don't have to
actually like touch C that would be
nasty and then we can trace our passes
and see what it's actually doing so I
took like 10 minutes and looked up the
Boehm garbage collector to see if I
could get a garbage collector running
but and I sort of ran out of time to
test it so you can actually turn this on
and in theory it should generate code
that will use the bomb collector but in
practice may not okay so we have a
representation for our data types and so
let's fix and um tag is just 0 we have
our pair tag as 1 you know 2 for our box
tag 3 for our vector tag 4 for our
closure tag we have more tags that we
could use but we have a representation
for our true and our false values a
little tag for boolean's just to make
boolean question mark a little simpler
and a record for our fixnum shift here
so that we know that we need to shift
the thing 3 bits up when we want to make
a change to it or 3 bits down
after we've done operations like
multiply and divide and our word size
just so that we know that we've got
eight bytes here in each of our words
and then we've got some stuff here for
taking care of like unique variables and
our list of primitives which should all
be cleaned up I might to do here which
didn't actually get done ooh and my
misspelling if should sad all right and
then we have a number of language
definitions so you can kind of look
through these I actually included a
potentially out-of-date comment with the
the full language in here but most of
these languages are generated this way
and they can actually be regenerated by
loading the library and loading the
nanopatch framework and then just saying
language arrow s expression and it will
give you the full the full language
definition and then we have all of our
passes so the first pass the parson
renamed pass yeah it's a little long
which is why I didn't end up talking
about it we're doing something that's a
little bit macro expanding here and that
we're defining this initial environment
and this is really all I wanted to show
from this so because we're in scheme our
keywords can be overwritten and we need
to have an environment as we read in the
code to know which thing we're actually
referring to so we we want to make sure
that if if some1 binds a variable called
quote we don't then see all of the calls
to quote as quotes so we use an initial
environment and then as we rebind new
things we just extend the environment
and that's the idea there so since I'm
running a little short on time here
let's actually take a look at this
example code here so I intentionally
shrank my history so that I don't have a
few things in here so I cheated a little
bit so we are going to import this and
you know it is a little bit slow to
import there's a couple thousand lines
of code that's actually in the in our
compiler itself plus there's all the
nano pass code and then the nano pass
code generates a heck of a lot of codes
so we tend to get a little bit slow down
there but let's let's do our first tiny
little program
originally I was just going to test this
for two programs and make sure that
those two programs worked the program
five and factorial so let's test the
program five okay so that worked that
was good it compiled five through all 27
passes it wrote a C file to the file
system it told the C compiler to compile
it it ran the program the program output
was written to the file system and then
we use ASCII Murray to read that back in
that all that's what happened there
thanks thanks okay so so we have our
other fat our other program factorial
and we're gonna run factorial of ten
because this is a compiler there's no
reason for us to limit ourselves to five
it's also reasonably fast so that's
that's our answer there and I know it
might seem like hey how do I know that
you're actually doing anything here so
we're gonna turn on our trace passes and
we'll run the same program again okay
that actually went by too fast this is
the stuff this is the stuff that it
generated okay all right we're somewhere
around the start here so you can see you
know we start we start running our our
initial pass here parson rename and then
we run our remove one-armed if and you
know some of these passes aren't going
to do anything really they're just going
to recur through the code and generate
the exact same thing that came in
because none of those pieces are
actually there we don't need to do
anything with those things
but there are certain parts that are
going to do transforms and as we get
through this whole thing we're
eventually going to get to some C code
the C code is also entirely generated
from inside scheme so if you go and look
at the code there's a bunch of printf
that printf printf s-- in order to do
this stuff this was less fun to write by
the way this is this is the downside of
not having not using the data structures
that c provides is that you end up doing
things like casting to a long a
reference of a pointer that you cast to
a long to do the math on the pointer
okay so have an idea of what's going on
here now and let's go back to the slides
for a second okay so we have a little
compiler what else can we do right I
mean it does a little thing and it runs
at least two programs I actually did
test it on some other programs and I
fixed my vector representation for those
people who I was talking to and I had
had a broken vector representation but
one of the things we could do is add a
different back end I mean you know C is
fine target for us but we could also
target you know JavaScript or closure or
the JVM or net whatever we want really
LLVM I've really been wanting to play
with LLVM but I haven't had a chance to
yet so that would be a fun one we could
also add more primitives and data types
you know there's a lot of data types
that I that I think are really neat to
enclosure that I would love to add to a
schema implementation so that I can use
them in a schema implementation of
course I should probably also you know
use some closure we could also add more
optimizations and of course this is my
favorite thing to do because part of the
reason why I love compilers is I love
fast and these are to make things fast
and we could add more runtime factors
like GC which may or may not work but we
could also add things like foreign
function calls and things like that
another thing is we could port it to
closure
I would love to port it to closure sadly
I don't I don't know closure yet but I
it's on my list of things to do and we
could do a couple of things here we
could port compiler using just core
match sort of the internal
representation I suspect this would be
faster than our match this I think would
be the easier task the other pieces we
could actually port the framework to use
closure macros and to use a more closure
like syntax and to feel generally more
closure II I think this is going to be a
bit harder harder partially because
right now the entire thing is written
using these gigantic syntax case macros
which is part of the reason why I know
that we can do arbitrary computation
lists in text case because believe me I
do arbitrary computation
and but but you know there's nothing
missing for us doing this it's just the
the work of getting it done and figuring
out how all the pieces fit together and
with that I'd like to say thanks I have
a ton of links here the compiler the
framework my email if if that's the one
to remember if you get lost on
everything else because I I can respond
with everything else the twitter which i
suppose is also useful because i can
also respond on that one my web page
where i will post this stuff and then
this stuff runs on che scheme
unfortunately the scheme compilers they
are not all so close together I think it
should run on Icarus and Vicari although
I have not yet tested it on those
platforms but it should be supported on
those and I think I have just like a
minute for questions and I can't see
very well so if someone has a question
yeah thanks
yeah so I haven't thought about it in
that quite that way I do sit next to
will bird so we have actually talked
about some of the ideas somewhat
somewhat in the context of actually like
writing a type checker that you write
with a pass like this that is actually
written in a relational style and many
of the passes are written in a
relational style in fact that if that
you saw could have been done as a
relational thing right it's just a term
rewriting at that point and like any
term rewriting it could be done
relationally so yeah yeah yeah so we
produce a control flow graph so passes
actually don't have to produce an AST
they can produce things of different
types and what we used to do was we we
sort of produced an AST that had the
information about the control flow graph
embedded in it it turns out that's not
necessarily the best way to write your
register allocator so what we did
instead was have it generate the graph
for us and then the graph gets passed
through a couple of graph oriented
passes and then it gets turned back into
an AST when we're done with that process
so that you know this the idea behind
this framework is to write these little
passes because we can't write these
little passes but we can't to always
write these little passes so in
particular like the che source optimizer
doesn't use this style of these tiny
passes because the things that it do
that it does in order to to get the
performance that it gets it combines
several different optimizations at the
same time that are mutually beneficial
and so it's actually quite a big pass
even though you know it's using the nano
pass framework to build it so you're
never limited this is more to enable you
to write more in this style so and I
think I'm I'm past out of time so I'll
leave the rest of questions for after
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>