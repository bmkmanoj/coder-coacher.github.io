<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Nada Amin / William Byrd - From Greek to Clojure! | Coder Coacher - Coaching Coders</title><meta content="Nada Amin / William Byrd - From Greek to Clojure! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Nada Amin / William Byrd - From Greek to Clojure!</b></h2><h5 class="post__date">2014-01-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7kPMFkNm2dw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I was just saying this is like the
fourth or
that I've given and this is the first
time we're actually gonna show some
closure codes which is why not as we
were inspired by David Mullins
presentation Atlanta Jam where he showed
how much he was inspired by academic
papers and we thought it would be
interesting to for this audience to to
demystify how you read an academic paper
and and get something out of it
so the just and there you go what oh no
no no well I mean it's hard even for
academics to read this stuff right yeah
we were we picked a paper yesterday
which we're gonna show you today in
which first look that the rules are like
oh we can't show this because we don't
understand any of it right so that's
what we're gonna show you but we're
going to start from very basic things so
in in papers syntax are usually as shown
in this abstract way well you just say
okay a piano number is either the zero
busy or a successor of another number
and it's a recursive definition yeah so
when you see a definition like this you
can think a couple different ways when
you're going to implement this enclosure
one you could implement this using like
pattern matching with core match but
we're gonna do core logic for this for
this particular example and for all our
example all our examples were using the
core match or core logic they're both so
that's diving right in I tried to put
the slides here anyways
okay variations okay so who here is
familiar with core logic okay so that's
that's good okay good children
so we're going to define a relation to
just capture the constraint of what it
is to be a piano number so let's call it
piano and no piano so usually okay okay
I'm just gonna call it nacho then I
prefer so let's do that fine
so we have two cases here so let's have
a condi one for each case the first one
is easy we just say n Z and the second
one we have to capture this other end
which is smaller here so I'm gonna do
fresh and minus one and unify this like
this and this works but I also want to
add the constraint that n minus 1 is
itself
another piano number yeah so if you're
not familiar with core logic condi just
expresses a disjunction and fresh
introduces a new variable logic variable
and can sequence other expressions so
now if I evaluate this run expression I
get I get this as a result and the list
is not empty so it means something was
successful and this underscore zero is
an unbound logic variable which is the
this Q here which we haven't used in the
in the in the expression at all so this
just says that Z is a piano number and
we can also try a different one and that
also works ok how about something is not
a number
so clearly one is not a number fairly
and we can also generate numbers so we
can ask for the 10 10 10 piano numbers
and it gives us a list here okay we're
not gonna do a run star no alright so
that was piano numbers and now now that
we have this inductive definition for
numbers we can also write inductive
definitions for relations on numbers
yeah so this notation is showing
inference rules we have two inference
rules and these will pop up over and
over again they come up in all sorts of
computer science ii and programming
language papers
the first inference rule you can kind of
imagine it having one of these
horizontal lines except there's nothing
above it some and sometimes it's written
that way so the way to read this
horizontal line is what is below is the
conclusion and what is above is the
premise or premises there might be more
and another way to think of it is if you
need to show if you need to show
something that has this shape you can
read you can reduce it to just showing
something that has this in order to show
this it's it's sufficient to just show
this okay so for the top one where we
have a rule which we're calling plus D
that's saying that zero plus any integer
gives us back the original integer and
we don't have to prove anything else for
that the whole that just always holds
and for the second case we're saying
that the successor of some number so 1
plus n 1 plus n 2 is the same as a
successor of n 3 provided that N 1 plus
N 1 plus n 2 equals n 3 so this is a
basically a recursive definition and
eventually if we apply it enough times
we'll get that to the base case which is
plus C so the very simple set of rules
and there are two ways to look at this
the first is as a relation so it's a
three place relation here where this is
the first the first
position second position and third
position
or in this case it's also a function
where you can think of it's a function
of two arguments that return the third
and in this case we can treat it as a
function because we have if we look at
the first argument we do have a an
inductive definition on the first
argument so we're gonna first show you
this using poor match and write it as a
function it'll take two numbers and then
return the third number okay okay so
therefore the first I think I was just
we all remember the definition right I
can just
okay so let's define plus as as a
function using core match so it takes n
1 and n 2 and we're just matching on the
first yes and if the first is Z then we
just return and two and two and if the
first is the sequence with an S and n
minus 1 then what we do is that we say
ok we're going to return a successor of
plus n minus 1 and n 2 oops
yeah ok that's fine so now we can try it
out
and that's okay you try harder what okay
hey we're headed one in one okay so now
we can do it in a core logic hit they'll
clap for that wait until we add two and
three
yeah I don't know no no don't do it
wait wait until we're doing for logic
hold on so let's do a plus or this time
yeah and how many arguments does this
take three okay it's a three place
relation so again a conte and so in the
first case we just say n1 is z and then
n 2 is n 3 that was the the axiom and in
the second case we say okay we say n1 is
a successor and then we say ok the
result is also going to be a successor
and then we need to do the recursive
constraint
okay so that's that and now we can call
it on let's just should we call this
just run it because I don't want to type
so much okay so for a core logic program
if you don't feel like typing in any of
the input you just feed it fresh
variables it yeah but I told you what it
supposed to be okay well we can well
okay let's do let's just do let's run it
forward okay yeah nice to do that let's
run it forward so you have that and we
can also run it backwards let's try this
you have that again okay no read for
real like put in more variables okay
that's what variables everywhere yeah
yeah so I don't know if that's very
interesting because it's just it's just
saying that it's really showing how this
was about as interesting as piano gets
right yeah
so the point of this isn't that this is
like high-powered programming the point
of this is that we're trying to come up
with the simplest possible example of
reading these inference rules and this
is about it so the the point is whenever
you see rules like this to have a line
there all of this form metaphorically
and you can use normally either
something like or match or core logic to
to implement them so you might see lots
of other Greek letters here and we're
gonna get to some more complicated
examples in a second but the idea is
still the same so okay it's really
straightforward so our second example is
motivated because in functional
programming related papers it shows a
shows up a lot it's a lambda calculus
and so here's how you would have the
syntax you either have a variable an
abstraction or an application yeah and
now we can jump straight to some
inference rules for for typing so it's
really it's really the same process as
the the other one so that's enough you
learn we have our same friendly line
right it means it's easy
let's look at at application first so if
you're if you have a 1 and E 2 and
you're applying even as a UN has to be a
function and e2 has to have a type that
matches the parameter type of the
function and then you can apply it and
you get this result type C yeah so you
just think of it maybe II won a vetas
evaluates to a function that takes this
add one right it takes takes a number
and adds one to it right so okay oh come
on that makes it too easy okay so well
yeah well it's finding these other
symbols fine
these things this is like a hangman
thing that's gamma this is the type
environment or typing context and this
is just like an environment in an
interpreter or something like that it
maps variables to instead of values like
you would have an interpreter Maps
variables two types so you might have a
variable X that in the type environment
is bound to the type int or the type
bool arrow int or something like that
and this rule here is is almost looks
like it's repeating the same thing it's
saying well X has type the variable X
has type T if X has type T and gamma
yeah so they're saying if you treat the
type environment as a set of bindings
we're just this is just a map right and
that back that's how we're gonna
implement as a map and closure saying
that X is bound to T in gamma right well
then we're just doing a lookup this is
just saying a lookup for the variable
case if you want to know what the type
of X is and look it up in the map that's
all it is this is just how logicians
write this right I mean they couldn't
just say we're gonna look it up in a map
and here we're putting
you would never get tenure doing that
you know it's true
so here you put something in the map so
we're putting we're seeing excess type
t1 but what's strange is that t1 is
coming from it's kind of related related
here in here but we're not really we
don't see it in this lambda so we were
making up net1 such that this will hold
yeah so this is kind of weird right
we're deferring our decision of what the
type of t1 is until later normally what
happens is there'll be an application
that matches this lambda and from that
application you'll be able to tell from
the argument e to what the type is
flowing in and now tell you the rest of
the types you don't always have that but
we'll be able to use logic variables to
represent this delayed decision so if
you think of this as a function where
this is which takes gamma and this term
it looks kind of strange because you
have to conjure up this t1 so that's why
if you look at it as a relation then you
don't really think what is input what is
output
you're just constraining things so that
this rule holds yeah and then the only
other symbol we haven't talked about is
this this turnstile thing and that's
basically saying that we can infer some
value and then the colon is just this
convention to say the thing after this
is the type so that's it those are all
the symbols it's the comma so this old
oh yeah ok yeah this is this is
extension we're extending a map with a
binding between X and and t1 a BS
abstraction yeah so so ok good question
we normally we give names to all the
rules which is handy when referring to
them so it abs is abstraction which is
lambda bar is variable and then APIs
application and you can think of
procedure application and in this case
there's one rule per syntax shape yeah
in our syntax we had we had three cases
so here we have three cases as well it's
usually it can be more complicated of
course but so shall we try to do this in
yeah enclosure okay so first we need to
do this environment thing and I guess
we're gonna use core logic so we have to
define oh okay let's just jump to core
logic well the reason why we use core
logic is because it's kind of
complicated to conjure up this yeah this
this is actually the sort of problem
core logic is really good at so well
we'll do that so yeah so in for the
couple we've seen this one before yes so
so here we're just gonna represent the
typing environment gamma as basically
like an association list right yeah so
so our environment lookup is a three
place relationship we want to look up X
in the typing environment in for gamma
and get back tight but since we're
implementing this as a relation instead
of a function you can't really say that
we're looking up xnm to get type you
know we could go backwards we could say
here's the type give me an environment
where X has that type that sort of thing
so there's no notion of input and output
once we're in a relational world and and
you can see that's reflected in these
rules there's no notion of input and
output there's above the line the below
the line but you can read them either
way
top down or bottom up so yeah so this
one is
so this one is a bit this this console
thing is really di oh okay I never used
console but anyway cons so it was like
cons you know we're going to wait what
what is it I don't know what are these
black things and closure with is that
like a list or something I guess
okay so we're binding X the type of X G
of X in the environment invert to get a
new extended environment in right yeah
so it's like the relational version of
cons right y NT Y yeah and then in the
second clause here the reason not I
wrote this dis equality constraint this
not equal thing is because in a condi
it's it's a mathematical disjunction or
logical disjunction what it means is you
try both of the clauses all the time so
it's not like a standard Condor we're an
if we're if the first succeeds you don't
go to the second clause you always try
both clauses so the reason we have this
this koala constraint is to say if X
isn't the first thing in the Association
lists then then we're gonna recur okay
all right so we can look something up
okay and the reason we we had this this
equality is if I have this I really only
want the first answer because the second
X is shadowed in the environment you
cannot access it anymore
yeah so that's what gives us like proper
electricals okay so we can finally get
to the typing rules now that we have
this so
and et again I can take one for each
case so if we have I'm gonna use this
symbol to to constrain it to be a symbol
and if that's the case I can just look
it up in the environment and whatever
the environment returns is the result
this would be equivalent to just looking
it up in the map and then for the the
other case so for the other case now I
have to match on this xeb I'll call it
so I I decide I'm going to use exactly
closures syntax for the for the
abstraction
so let's see so this is EB so EB is the
body expression mm-hmm so this is like
lambda X Yi so then we do a console
well elkins is kind of the the the dual
of it just puts it right there so okay
thanks is that is that like a closure
thing yeah and actually think so what do
we need to do okay first we have this
this lambda abstraction and then if we
look at the rule this is if you look at
the rule we first have to evaluate so
that's just right what the rule says it
says so it's for it well for one thing
we're gonna get an arrow type right so
don't get the type 2 t1 arrow t2 okay so
we can put this already so we say the
result is going to be an arrow g1 g2 and
then we can say okay and the environment
we say that X has type t1 yeah so here
we're extending the environment right
yeah yeah so we're extending or original
gamma with a binding between X and T 1
and in that extended type environment
we're going to try to infer that the
expression e the body of the lambda has
type t2 so does this match to rule it
looks like it does right I mean yeah
evey okay so we have this and now the
last case is if you have an application
you want you to can you is it possible
yeah thank you okay
so in the application case we're gonna
have to make sure that we recur on both
a 1 and a 2 in terms of our inference
and notice we're not we're doing it in
the original gamma the original type
environment we don't have to extend that
map at all and furthermore II 1 had
better be an arrow type because
otherwise it's not a function so we
can't apply it if it's an arrow type for
the type of the argument coming into the
function had better matched the type of
the formal parameter to the function
I think you oh yeah ok so you're doing
him fix there okay
okay good yeah okay that works
so now let's run it on the empty
environment let's try to get the type of
this okay let's hope the environment
environment is read this as anything
goes so that thing okay this is like a
basically a for all type yeah so this is
just constraining that the input has to
be the same as the output type which is
because we have the identity function
that makes sense so now we can just run
a few a few more examples like let's
just make it let's just run it by itself
so
okay mmm so yeah so it's inferring
things and doing the okay so okay what'd
you do
I'm just asking for oh you're asking for
any to type so why don't you give it a
tight okay okay this is really cool we
promised we weren't going to talk about
but we're going to say something about
so what we're about to do I think Dan
pointed this out in a previous talk we
gave one says we're going to give a type
to the inference ER and say give us a
program that has that type so this is
this is called type in habitation or
type habitation and here I guess we're
getting 10 different programs in the
lambda calculus that have that
particular type of a acre goes to a and
the this is important because this is
really design called the curry Howard
isomorphism where you can basically look
at the programs that you're generating
as proofs in logic so this is the basis
of a number of theorem provers and
things like that okay let's go back to
inference rules so actually can go back
one two so the point of this is not the
show that we can we can do the inference
for simply typed lambda calculus because
that's not terribly difficult but but
the point is to show that once again
when you see a horizontal bar that
should mean something to you okay I mean
that basically we're talking about
relations and furthermore if you look at
any paper that has typing rules they
will look probably very similar to this
but maybe with some extensions like
we'll see later on
okay so so if you kind of keep these
rules in mind you'll see that most
papers are kind of extending these or
modifying them a little bit and then you
have at least a starting point and a
chance to understand what's going on
with the with their new system so
another another type of relation that
that occurs often is reduction here
we're starting with the term
we're just taking a step and computing a
little bit of it and so the route to
computers saying if you have a lambda
and the value here then you do this the
substitution step or you say an e you
replace the variable X with the value V
and this is the only computation step
that goes on in and in the lambda
calculus the other steps are really just
so that you know how you can you can
take a step when you have a an
expression that is more complex than
that yeah so so this beta rule this
expression here where you have a lambda
expression to directly apply to to a
value that's that's called a read X and
these rules down here to try to figure
out where in a compound expression we
might find the read X so we can reduce
it and now we just want to show that so
this is a kind of rewriting rewriting
style of rules where you go from one one
term to another but here the target type
is the same then we just wanted to show
another example where the target is
different I'll actually can't go back to
that one yeah so so we're not gonna
implement these rules in this case but
once again you have your warm fuzzy with
the horizontal line what shouldn't be so
fuzzy in your heart is that beta step of
that substitution turns out that's
actually really tricky to get right and
there are special rules for that there's
a mathematical convention often given to
try to avoid having to specify all the
rules for the substitute of the capture
avoiding substitution where I'll
basically say oh yeah we assume your
variables her name such that just you
know you don't really have to worry
about it right but it's kind of on you
to make sure that happens so that's
actually the tricky part but the the
inference rules themselves are very
straightforward okay so the idea here is
that we're going to to change you don't
even need to understand CPS here we're
just going to show you the rule and they
will kind of make sense it's probably
better if you don't understand so let's
just let's just go ahead well do we have
these at home expressions which are
either variable or simple abstractions
or this should be a stupid and complex
expressions which are this application
and then these are the rules and it it's
it's kind of like a rewriting system and
and the only so it's it's what is that
well yeah
YK thing so you have so this this T
relation takes two inputs it takes X and
a syntactic continuation and so if you
have a variable it just calls the
syntactic continuation on the variable
which has been passed through this and
we write rule so there's two there are
two relations here that are mutually
inductive there is M like this and
relation and this T relation okay and
you're gonna live code this well we have
six minutes okay yeah no no no the
promise he was gonna it like live code
this cold yeah yeah I think I think it's
okay just explain how you do it you just
use match and here there is like one
case for each each of the syntactic
structure so this is left as an exercise
and finally another thing we want to
show is this evaluation which is really
just a different way of specific we saw
we saw a reduction which was a way of
showing the computation at every step
and so this is called small step
operational semantics and another thing
is this big step operational semantics
which uses an environment that's like
the typing environment but here it's a
runtime environment which match just
variables and values and in this context
because we want to have lexical scope
our values are actually closures yeah so
this row thing is the normal environment
that map's variables to values instead
of the gamma that map's variables to
types and the down arrow is basically a
revaluation relation and otherwise you
can see we have a environment extension
like we had before and then we have the
recursive calls except we just have
these data structures closures we could
work we could represent as lists or
sequences or whatever and the
application rule is actually quite
subtle because here we're using the
environment from the closure definition
when we're doing the evaluating the body
and that's that's what gives you lexical
scoping as opposed to dynamic scoping so
just by changing this row here from Row
one to row you would get dynamic scoping
but we these rules unlike the the
reduction rules that require the beta
step was the capture avoiding
substitution these rules you really can
just type in to core logic and it works
just fine and in fact if you add lists
and quote rules then you get an
interpreter runs backwards and can
generate coins okay okay so no right
switch gears to the paper yeah okay so
now we're actually gonna show you like a
real paper so actually in the paper the
rules we just showed you about this
operational semantics appears here and
it's more complicated but the basic rule
looks the same so for the this is the
the better rule and again you see this
down arrow and we're using they're using
a slightly different
tax for how the extent the environment
but this is the room we just saw yeah so
this is once again extending the map
basically but just to take a step back
this paper has a lot of rules and
usually that's not how you would read it
you would not start by looking at the
rules so you the title is logical types
for untyped languages and that's the the
paper at the foundation of core typed
now if you're Dan you actually start by
looking at the rules and if you're Oleg
you start by looking at the latex but
but it takes a while to get that point I
mean after at some point you can
actually look at just the rules and the
boxes and you're like hey why they put
that hat there right we don't recommend
starting out them I would start by
looking at the examples of what what
this is trying to achieve so the idea
here is that you have a function where
the the parameter type is either a
string or a number and this type checks
because you can add 1 to X when you're
in the in the branch where the the
number predicate the number this number
function returns true so in this branch
you know that X is actually a number and
furthermore you know that in the S
branch it is definitely not a number but
you know more you know that it's a
string so you can use string length
which is yeah like counting the length
of the string and so if you look at how
do you achieve this they use a typing
judgment that is extended but the basic
part of the judgment looks exactly like
what we showed you for typing you have a
gamma you have an expression E and the
result is this tau to just use a Greek
letter Y we use this capital T but
that's the type but the key insight is
that by looking at it here you can see
okay what is this extra stuff you're
doing and it turns out that what they do
and the text explains that rather
clearly is that they they actually
extend this so that they when when when
this evaluates to it to a true like
value they this
position here will hold and when it's
evaluates to a fuzz value this
proposition here will hold the negative
one so they have a way to track for for
each expression which propositions hold
if this expression is is it true like
value or a fast like ready and I asked
nada what is this oh thing and her
response was well we don't need to to to
understand everything that's at the same
time like it's ready it's ready kind of
you you you you pat yourself on the back
when you understand one thing and then
you take a coffee and then you
understand that another so yeah that
felt that was good advice yeah
okay so we're running short on time so I
think what we want to end by giving some
strategies on how you actually end up
reading these papers personally I always
go to the examples first and then I look
at the syntax of what this is the that
this what that they're modeling exactly
so here you see that in their type
system they actually have unions and
they have these lambdas that are
extended with these like propositions so
you can actually know when you when you
have a function
what kind of propositions you can infer
once this function is a is it bad so I
look at the the syntax I look at the
examples and the motivation what about
you well first thing is I guess going a
step back whenever I'm trying to learn
about some new area of computer science
the first thing I try to do is look and
find good papers to start with right
because you don't necessarily want to
start with the most dense technical
paper in the world and there are two
really good sources of information so
one our survey papers so for example
Jack Cohen had a great survey paper on
constraint logic programming or
introduction to Christmas constraint
logic program is very very readable and
you know it looks look for sign I've got
an intro paper or or a survey paper the
other thing that's really good to read
are actually dissertations if you can
find papers by a graduate student and
you don't understand them at all
hopefully they graduated by time you
read that paper and you can
their dissertation because their
dissertation unlike the papers that are
length constrain the dissertations are
usually much more self-contained and
also much gentler because like Richard
Feynman had a saying that you should
write your dissertation for yourself
when you're just starting in your
studies where you were smart but
ignorant right so if you good
dissertation is written that way so
dissertations are actually much easier
to read normally than a short paper so
so that's another good thing to look
when I actually find a paper I like what
I do is I look at the intro I look at
the abstract and then I immediately look
at the bibliography to see what the
references are and I do this with all
the papers that read in certain area and
often what I'll find is after I read a
few papers I'll see the same papers
coming up over and over again in the
bibliographies that's usually a hint
that those are important papers that I
can do it like a paper trail later and
then afterwards kind of like nada I I go
for the examples and then from that
start looking at the rules okay so this
concludes our talk thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>