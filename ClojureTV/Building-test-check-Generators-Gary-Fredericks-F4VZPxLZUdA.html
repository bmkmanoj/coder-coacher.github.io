<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building test check Generators - Gary Fredericks | Coder Coacher - Coaching Coders</title><meta content="Building test check Generators - Gary Fredericks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building test check Generators - Gary Fredericks</b></h2><h5 class="post__date">2017-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F4VZPxLZUdA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so I'm gonna be talking about
building test check generators some
quick metadata my name is Gary
Frederick's I live in Chicago I use
closure at CRW and I spend some of my
time working on improving tests check so
I'm gonna try to put this in the context
of the broader closure ecosystem test
check was created four years ago by Reed
Draper it is a closure library for
property based testing somewhat like the
the original quick check in Haskell and
that means that it lets you write
properties that describe things that
should be true about your functions for
any input and then test those properties
on randomly generated input so if you're
doing that then probably you're spending
a moderate amount of your time
describing the inputs your functions
also known as building generators
alternately closure spec was announced
eighteen months ago and one of its major
features is integration with test check
which means that when you have specs
especially basic specs it can create the
generators for you and then test your
functions automatically but because a
spec can be an arbitrary function this
means that users will have to eventually
supply their own generators when things
are complex enough so one way or another
people are building generators and much
like functional programming it can be a
little bewildering to beginners so I'm
going to try to address that with this
talk so the the roadmap here is I will
start off talking about generators in
general so we'll look at what's
available and why it is the way it is
then we'll look at one big example of
building a substantial generator and
then finally I'll talk about fine-tuning
things okay so to start off with let me
identify what what namespaces I'm
talking about so we have the two
libraries I mentioned earlier such check
enclosure spec test check on the right
has some namespaces for for running
tests and integrating with other
frameworks that sort of thing but it has
a nice little partitioned or quarantines
namespace for the generators
on the bottom-right spec also has some
as a namespace for respects in another
namespace for testing things and it has
its own generators namespace and this is
mostly just a proxy to enable dynamic
loading of tests check
so what whichever side you're using
you're probably going to be encountering
the generators namespace on the bottom
right and that's where this talk is
gonna be focused so it should be useful
to people coming from either direction
and for the most part I'm not going to
talk about this distinction anymore so
we're just gonna be in the bottom right
so looks at let's look at what comes out
of the box with tests check these come
in basically two categories that are the
basic data generators these are all I
think not not too weird we've got our
traditional scalars like boolean's and
numbers and uu IDs etc there are
functions that that take arguments and
return a generator so the the vector
function online for return it takes a a
generator for elements and returns a
generator for vectors so the the sample
output on line 15 is a vector of
integers there's a function called
elements on line 7 that takes a
collection of values and it will give
you a generator that just picks randomly
from that collection so you can see on
line 18 we just picked one random color
there's also a tuple generator so that
you can generate collections that are
heterogeneous so if you pass in say two
different generators it will generate
you a pair where the first thing comes
from the first generator the second from
the second and then the the whole
expression here is a call to the hashmap
function on line two and you pass it a
you know key value pairs with keys and
generators for values and it will
generate you a map with the same keys
taking the the values from the
corresponding generators so I think all
of this is is not too intimidating
hopefully pretty intuitive but the other
category of generators are what I call
the Combinator's and these at first
glance are pretty weird and declarative
and smell like monads and so I think
it's a little bit like when you first
encounter functional programming so I
want
try to justify why it is this way so
we'll have a little more appreciation so
if you think about how you might try to
design a generator without knowing
anything about the problem just the
first thought it might be a function
takes no arguments and returns a random
value you can write this using a one of
the random functions inside of closure
core so we call the random function on
line three we get a random number and we
generate the this assertion about a
favorite number so we now have a
favorite number assertion generator and
we can call it by just calling a
function with zero arguments and it
returns one of the values we wanted to
generate so this is good but test check
one of the features it has is it likes
to start a test on very small inputs and
slowly grow the size of the inputs so it
needs some way to tell the generator
what size it wants so the way test check
does this is with what we call the size
parameter it's a sort of an abstract
idea of size it's it's implemented as
just a number from 0 to 200 or so and
the generator gets to interpret it
however it wants so in this case we
could just take the size as an argument
and then use it to determine how big of
a number we use in our favorite number
assertion so we can pass the size to the
randint function that'll sort of bound
how a big of a number we get and so now
we have a generator that we have to pass
a size to when we call it and then a
little return of value but another
feature of test check is that it when it
finds a failure it wants to be able to
incremental e shrink the value in order
to find a simpler version of that
failure and you might think that it
could do this all on its own and it's
not part of the generator but on line 7
we have this string and if this was
failing our tests and we wanted to
shrink it it's not really obvious
without knowing anything about the
generator what a valid way to shrink it
is for a you know an arbitrary string
you might be able to just take out
characters or reduce one of the
characters to some other character and
most of those things are just not valid
on this string the only valid way to
shrink this this string is to shrink
that number on the right hand side of it
but only the generator knows that and so
the way touch check is implemented is
that the the the generator needs to
return not only a value but also
a description of all the different ways
that you could shrink it from that point
and the subsequent points and so this is
implemented as a lazy tree that I
haven't even tried to code on here
because it'd be kind of a headache but
you could imagine doing it if if you're
good at this sort of thing by writing a
recursive function and lazy sequences
and all that so now we have a function
that takes a size and returns two
different things but wait there's more
when you run tests you especially random
tests you want to be able to do it
deterministically and because of the way
tests check is implemented it's useful
to have an immutable random number
generator so we have to pass that in as
well so we now have two arguments and
two return values and this is maybe like
bordering on the verge of do ability if
you need to like write your own
generator but this is just generating
like one thing what if you needed to
generate that collection or some other
heterogeneous thing and like now you
need to combine all these different
inputs and merge and split and in all
sorts of headachy stuff so the the
reason that that such check has these
these really abstract Combinator's is
because it supports all these different
features it supports growth it supports
shrinking and it supports determinism so
a one thing I want to mention real quick
is that there's also these these dev
tools in the generators namespace these
will show up in later slides sample you
can pass a generator and get some some
small samples from it and the generate
function is very similar but it just
gives you one thing instead of many but
I realized when I was thinking about
this that I've said already that for a
beginner test check has a similarity to
functional programming where it's it's a
little intimidating things are weird in
a way that like don't seem like they
need to be so weird but with practice
they get the little easier and and you
can appreciate them a bit more in
particular some similarities are the the
universality in functional programming
you can express anything using a
functional program and similarly with
these generator Combinator's you can
generate anything even though it's not
obvious at first that that's possible
and it takes practice before you can
sort of think about how to how to use
that way it's also tempting to
circumvent them just like with
functional programming especially in a
dynamic language you can use trapdoors
and you have a mutation or whatever it
is that you need and sometimes that's
justifiable and especially with with
more users coming from spec there seems
to be different use cases for using
generators that really tempt people to
use these impurities and I'm not gonna
say you're a bad person if you do it but
I think you should at least know that
you're undermining the different
features of test check so if those
features aren't important to you you can
do whatever you want but this tech this
talk is going to be focused on not
circumventing those features like how to
build generators and and keep those
features so so now I'm going to go
through the the different Combinator's
and a little more detail so that when we
have our big example they'll will be a
bit more familiar so the first one is
the the tuple generator this was also on
the the basic tenor data generators
slide because I think it can it can work
both ways but the the signature is you
pass in a variable number of different
generators and it will give you a
generator of tuples where it takes one
thing from each generator so this is a
way of generating several things at the
same time another generator with a very
similar signature the 1up generator
takes a collection of generators and
then returns a generator that just picks
from one of them randomly so sometimes
you get a triangle sometimes a circle
etc the frequency generator is very
similar but gives you a bit more control
over the distribution so you can pass in
a weight to associate with each
generator and that will determine how
often it picks from each one next is
such that this takes a generator and a
function so if you have a generator of
triangles and then a function that takes
a triangle and returns true or false
this is essentially a way of filtering
it will give you a generator that only
generates things that pass that
predicate and I'll talk about that a bit
more because it's a bit tricky but for
now we're gonna move on the F map
generator this one is super useful also
takes a generator in a function this
time the the function takes the thing
generated as an argument
and return something else and they get
combined together and you get a
generator that returned that generates
whatever the function returns so this is
a way of essentially adding some
post-processing to a generator if you
have all the the information you need
but it's not in the shape you want you
can do these arbitrary transformations
so this is very useful bind looks very
similar at a glance except the arguments
have been swapped and so I'm going to
put them side-by-side the only real
difference aside from the confusing
arguments which is that the function in
bind needs to return a generator rather
than a value so it seems like it may not
be like a very meaningful difference but
it's actually a big leap in complexity
and power so I'm going to dig into that
a little bit because I think it's worth
understanding so let's imagine that you
wanted to generate a non-empty
collection and a random element from
that collection so you could start by
doing the easy part let's generate a
non-empty collection so we can do that
on line six and seven by just using the
the built in generators and then we're
going to pass it to F map and so now we
have a function that takes one of those
collections we just generated and we
want to maybe figure out how to pick a
random element and and return that so
one way to do this is to cheat you can
call the random function and close your
core with your collection and make a
little tuple with with two pieces and
return it and if you run this generator
it will work or at least it looks like
it works and it certainly does work fine
for generating things but you're missing
the some of the the three features from
earlier so let's try something else
we could use the elements generator that
we saw in the data slide so on line
seven we'll take our collection and pass
it to the elements function and that
gives us a generator that'll pick a
random thing which is what we need to do
and we can pass that to F map on line
six and take the that random element
that was generated and wrap the two of
them up in a vector which we could do
lexically from the context and so this
expresses all of the the logic we need
but when we run the generator down at
the bottom we get a generator and not a
value and this makes sense because the
width
with F map your functions expected to
return a value and what we actually
returned on line six was this F map
generator so anytime that you're tempted
or you need to return a generator from
your F map function that essentially
tells you you need to be using bind
instead that's exactly what bind is for
so this slide is just like the last side
except the arguments have been switched
and we are calling bind instead of F map
now and this actually works but it's a
little bit hard to read so fortunately
we have a macro in the generators
namespace called let this is based on
the closure core let accept now paired
up with names we have generators and so
the names refer to the values generated
from the generators and not the
generators themselves so in line - we
have our empty our non empty collection
generator and we give the give a name to
the collections being generated and then
we can take that collection and pass it
into the elements generator on line line
four and give a name to the random
element X and then wrap those up in a
pair and so this does the exact same
thing as the previous slide but it's
hopefully a bit more readable another
example real quick if you want to
generate a 2d matrix the the easy thing
of just using two nested calls to a
vector is not quite going to work
because then the inter vectors will have
just random lengths that don't match
each other so an easy way to do this is
again with bind but using the let macro
on line 8 we we generate a small
non-negative integer for the width and
then use that to assemble our generator
of vectors so now we can fix the the
inner vectors to have a fixed width in
the outlaw match so this wraps up the
first section I talked about the the
different generators we have basic data
generators and the abstract combinators
the abstractness is it's difficult but
it's in service of something that I
think is valuable and in like functional
programming it gets more familiar with
practice so our next section this is
going to be the the big example so this
example is inspired by Benjamin Pierce's
keynote from two years ago
where he talked about testing a drop box
like system I'm not gonna worry about
the mechanics of how you test something
like that I'm just gonna think about
what things might you want to generate
if you were doing something of that sort
so let's say we want to generate a
nested directory of files and some
changes to that directory so if you're
going to do this you'll probably want to
generate file names and test check has a
string generator built-in and you might
have the opinion that a file name
probably shouldn't have slashes in it so
how can we generate file names without
slashes we can take that string
generator and pass it to such that and
have a predicate that checks whether
there are any slashes in it or not and
if you try this out it will work you
pass it to sample you get some some nice
file names that don't have slashes in
them but if you sample it a little
harder than you'll eventually run into
this this exception that I assume a lot
of people have seen that such that could
not find a string that didn't have a
slash in it after tense tries and this
happens because once you're generating
large and large enough strings they're
highly likely to have slashes or at
least they've got a decent chance and if
you do that over and over and over again
you'll eventually just bye-bye bad luck
run into a ton of them in a row that all
has slashes so such that is really only
appropriate if you or Jan if your
predicate gets more likely to pass as
you look at larger and larger examples
and that the opposite is happening here
this comes up a lot for spec users
because of the the and spec because the
only only way to generate something from
an and spec is to generate something
from the first spec and then check you
pass it to such that and check that the
other specs pass but fortunately most
uses of such that can be replaced with a
clever use of F map so the example in
this case is you can just generate a
string that might have a slash and then
use F map to pull out all the slashes so
your generator is going to be doing a
little bit of extra work and throwing
things away but that's ok so if we pass
this to sample we get more nice file
names that don't have slashes and this
one will actually never throw the such
that error we also might want to
generate file contents in this case byte
arrays and test check has a byte
generator built-in so we can just use it
we a Lea sit on line one two gen file
contents and then we can pass that to
sample and see lots of nice random by
Therese we might also want to generate
metadata and just just to make this
interesting let's say that that when we
generate the permissions on a file or
directory that we want it to be in the
octal format so there's not any sort of
obvious built-in way to generate octal
strings in in test check but you could
just generate the the underlying number
that's represented by an octal string
which is a number from zero up to the
largest three-digit octal number so
whatever that is if the reader will
figure it out but we can pass that to
the large integer generator to get a
number in that range and then use F map
to format it as an octal string and
fortunately the the format function
built sin to closure knows how to
generate octal strings in one line and
so we get a generator that works pretty
well
another part of metadata is time stamps
there's nothing built-in to test check
that deals with time because time is
pretty contextual but it's not too hard
to get a minimal thing going yourself
you can generate an integer that you
interpret as a UNIX epoch value and just
pass use F map to pass that into a
constructor of whatever type you're
interested in generating so if we do
this we get a whole bunch of time stamps
that are all several milliseconds off of
midnight 1970 it's just a little weird
and I'm gonna come back to that later on
but for now this is definitely generate
some timestamps so we can wrap these up
in a metadata generator add on some user
IDs and group IDs for fun and we'll get
this generator that generates a map with
with five entries and that's pretty good
next we want to be able to generate an
actual like recursive structure that
represents the directory the file names
the directory names all that sort of
stuff
so so test check has a recursive helper
built in and I'm not going to spend too
much time on this because it's it's a
little subtle but you can when you use
it on line 11 you need to go two things
one is a generator for the leaves
of your tree structure and in this case
the leaves are the byte arrays so we'll
use our existing gen file contents
function for that and you also need to
give it a function that can take a
generator for child nodes and generate
the appropriate structure at that point
so where we'll use this function at the
top that takes an argument on line two
for the the content under that thing and
then returns a generator which is a map
from from file names to a little to
entry map that has the metadata and
whatever content gets generated by this
generator that was passed in so if we
run that on a modest-sized we get this
very large output it the top-level
structure is this is a map that has some
directory names in it like Eklund and
Shu underscore which are good directory
names and they have their own metadata
and they also have content which is yet
another nested directory in this case on
line eight we have a file named right
parenthesis it has its own its own
metadata and it has the contents from
the byte array generator on line 13 so
let's stash that away for future use
finally the our top-level goal was to
generate a directory and changes to that
directory so how would we go about doing
that
well we could separate this out we
already have a directory of changes or
I'm sorry we have a generator of
directories and we could make a function
that takes the directory and returns a
generator changes and then combine those
somehow so let's start from the
top-level on line 5 how would we write
this function assuming we have the
function above it
well the generating first the directory
and then the changes sounds like a
two-stage thing which is exactly what
bind does so we're gonna start by
calling bind and passing in our
directory generator on line 6 and then
we'll have a function that takes the
directory and it needs to call the gen
changes so we do that on line 11 and we
pass that into F map and we wrap things
up in our map and we get back into this
not very readable code situation and but
just like before Jenna applies
we can rewrite it so the top is the same
as the bottom here on line 10 we take
our directory generator get the
directory pass that into Gen changes now
we have changes and we can wrap them up
into our final product so that just
leaves this gen changes function that we
haven't written yet for simplicity I'm
just going to talk about generating one
kind of change because there's lots of
ways to change a nested directory of
things and I don't have a lot of time so
let's just talk about a change where you
append some bytes to a particular file
if we have a generator that can generate
one of those then we can pass that to
Gen vector and get a vector of changes
so how might we generate in a pension
which I promise is a real word well we
can do this in four steps we can take
our directory and get all the file paths
then pick one of those randomly then
generate some random bytes to append to
that file and then wrap them up and
return them
so the first step the file paths we can
write a function that just takes a
directory and does a little recursive
walk that I'm not going to get into
because this is some regular data
processing code but assuming it works we
can pass that directory that we saved
from earlier into this function on line
10 and get a sequence of file names
where the slashes have been added in
between the the directory names and the
file names so if we have that we can
wrap this up in into our gen file a
pension function we call that function
on line 3 to get all the file paths and
we pick one at random on line 8 by using
the elements generator we also generate
some random bytes on line 9 and we
combine both of these things with the
the tuple generator so we want to
generate them in parallel and then we we
use F map to pass them into a function
that will wrap them up in a map for us
on lines 5 through 7
so we can use our the directory we saved
earlier we can pass it to this function
on line 12 and then generate something
from the from that generator and we'll
get a random file path and some random
bytes so back to the top we have the gen
changes at the top that we wrote earlier
that will generate a vector of file
pensions and we have our very top level
directory with changes that calls the
directory func generator and the changes
generator and combines them together and
then we can actually try this with a
very modest size of three so that it
fits on the slide and we'll get back a
very small directory that has just one
file which has the empty file name and
contains zero bytes and we've generated
also one change to that same file of
adding zero bytes to it so that is the
giant example I was going through I
don't think that you can get comfortable
with this stuff after watching five
minutes of slides just like with
functional programming but hopefully
I've convinced you that these sorts of
things are possible and as you practice
them they get they get easier so the
last section fine tuning generators so
let's first talk about what you might
want to fine tune in a generator I think
these basically in two categories so
it's the distribution and growth and
then there's the shrinking so I'm going
to focus mainly on the first one so
distribution and growth is a little
tricky to talk about because of the size
parameter so this this diagram here
shows the a sampling of values from the
large integer generator at different
sizes so you can see near the bottom
when we start out with size zero the
values are clustered around zero as the
size increments they start getting
farther and farther away but even up at
nine they're still somewhat clustered
around zero they just reach farther to
the edges this is a heuristic that a lot
of the tests check generators have but
what this demonstrates is that you
essentially have a distribution for
every size and even though they look
kind of similar they just like scaled
versions of each other
don't have to be that way and this is
only for generating a single scalar once
you're generating something more complex
even even harder to think about what the
distribution is we should talk about
what size means exactly now so the
meaning is essentially determined by how
test the test runner and test check uses
it when you run tests it will it will
start the first trial by generating a
value of size zero and then the next
trial it uses one and then two and all
the way up to 199 then it cycles back to
zero and starts counting up again you
can control what the maximum size is and
but that just changes the length of the
cycle so it'll still go up to that max
size and then back to zero and I
preferred not changing that and just
letting it do this and writing
generators with the assumption that 200
is supposed to mean the largest thing
you might want to generate on any given
day and since there's ways to control
sizing within the generators this should
be sufficient before we get into that
the the way size is used here has a few
gotchas that I want to highlight one is
that if you are running less than 200
trials in your test then you might not
be testing with as large of values as
you thought you were another is the the
sample function when you call sample you
are getting values that are sized from 0
to 9 so if they look small it's cuz
they're supposed to be and that's not
necessarily what's being tested most of
the time I mean the generate function
uses the default size of 30 okay so now
that we have this this little more
precise way of thinking about the size
of a generator a common dissatisfaction
you might have is that you and your
generator disagree about what big means
so if you're generating vectors of
strings for example you might call a
generator with size 10 and see this
output and think that this is pretty
good this is about as big as you want
for whatever sensitive domain you're
using but that when you call it with
size 200 this is just unreasonable and
you would never want to test this and
maybe your test would never return
whatever the your particular issue is so
fortunately there's a scale function in
the generators namespace this lets you
pass in a generator and then a function
that will transform the size that the
generator uses so you can take this
generator that has really big stuff at
size 200 but stuff that you like it's
size 10 and just divide the size by 20
and then you'll get another generator
that it's size 200 has the stuff you
like and below that it's even smaller
and obviously this function can do
whatever you want it doesn't have to
just be division or multiplication or
something like that so you can do
fancier things as well this is a good
time to mention that there's an open
issue in test check about how
collections are sized
such check does it kind of naively in in
a way that results in very large data if
you are composing if you have nested
collections that you're generating and I
think spec has kind of increased the the
occurrence of this problem because it
makes it so easy to generate big things
so this is something that that needs to
be worked on I hope that it will be
fixed in some way before the next
release but for now it's just you need
to pay more attention to sizing so
another category of things that you
might have opinions about with respect
to your generator is that the stuff it
generates is too weird or it's not weird
enough for there were some of they're
very into this so one example is our our
file contents generator from earlier
where we were just generating random
bytes if you're testing a file syncing
service then you might suspect there
might be special handling around text
files and so you want to make sure that
you're testing text files but a random
byte generator once it's generating big
things is highly unlikely to generate
any valid text files so this brings up
the question like how weird should the
generator be I think there's a trade-off
here like one of the value propositions
of test check is that by testing lots of
really weird things it's gonna find bugs
that you weren't even thinking about and
so by like focusing the generators on
just generating happy little things that
that fit the the tests you have in mind
you're sort of losing out on that but
it's also important to test things that
you know that your domain is sensitive
to and some generators might just either
have zero probability of getting there
or just a very low probability so I
think there's a balance here and
our tools for balancing them one of them
is the one of generator so in this case
we can make a generator that half the
time generates random bytes half the
time generates utf-8 bytes assuming we
can write a generator that does that you
can combine them together with one of
and get the best of both worlds further
you might notice that the generator only
generates small files so the bytes
generator just uses the size parameter
as the cap and so by default you're only
going to be testing on files that are up
to 200 bytes and file syncing service
might well have bugs that only manifest
with larger files but you don't want to
use larger files all the time because
your tests will be slow so there's
another another tactic we can do here
the frequency generator will let you do
things that you want to cover but not
too often you can do them not too often
so we can generate bytes or utf-8 bytes
90% of the time and then 10% of the time
will generate big files but only if the
size is greater than 100 so I'm not
going to go over that in detail but it's
definitely something you can do another
example of distribution issues is the
date/time generator the generator that
we looked at earlier so one of the
issues here is just part of the sample
function when we call sample we're only
getting things size to 0 to 9 and so for
this generator they're all clustered
around 1970 but for larger values
they're gonna be all over the place
some of them will be 6 or 8 digit ears
which is an interesting problem but even
so they're they're not really that you
know we're just generating a number the
number doesn't know anything about the
different fields in our date/time so all
the semantics are kind of lost so
there's different different downsides to
that and a solution is to actually
generate the different fields that are
part of the date/time so this generator
has the seven different fields for the
different parts and if we write a
function that can take those seven
values and actually construct an
instance of the class that we want here
we have some some handling to do for
when the day is too large for the month
but you should do something dumb like
replace it with 28 which which works and
then you combine those two things
together with F map and we now have a
generator that's it's not centered on
1970 because I just added 2017 to a
small integer here but also you can see
that even for small values the fields
are kind of varying in a more natural
way and this also extends to shrinking
when the underlying generator is
actually matching the semantics of what
you're generating a connection it can
shrink the different fields
independently in a way that wouldn't
work if you're just generating an
integer because it would just be
shrinking the integer and the the
different fields would be changing in
sort of random ways so the last section
is shrinking I just talked about
shrinking with respect to these it's a
date times and what happens when you you
model the domain a little more closely
a couple other random things the UUID
generator that's built in turns
shrinking off completely there's a no
shrink function that you can pass a
generator to to get something that just
doesn't shrink this is useful for you
you IDs in particular because it means
that users can generate you you IDs and
assume that they are different because
it also uses a uniform distribution so
it's as random as it is in real life and
then when you're shrinking they don't
all shrink to zero and start colliding
with each other and it would also take a
lot of effort shrinking time to do that
shrinking and hopefully your program
doesn't have bugs that only manifest
with certain uu IDs if they do you can
even write your own ok the last example
is how bind relates to shrinking so I've
talked about bind as being a generator
that works in phases you generate one
thing you call the user function then
you generate another thing this this
matrix example that we saw earlier works
that way first we generate the width and
then we have to call the user function
to get this vector generator and then we
generate the actual vectors bind is very
difficult to shrink and for in an
inherent way because you can you can
shrink either the earlier generator or
the later generator and shrinking the
later generator is kind of easy but if
you shrink the earlier generator you now
have changed the thing that was passed
into the user function so you have to
call that user function again get a
brand new generator return and
the only thing you can do with it is
just generate a completely new random
thing from it and that means that in the
case of the matrix when we're trying to
shrink our matrix we can remove rows
from the bottom really easily we can
remove rows from the top etc but to
actually reduce the width means that we
generate a totally new matrix with that
width so you can see things where in the
matrix example you'll shrink to
something that has these sort of trivial
shrunken degenerate columns that you
didn't need and this can manifest in
other sort of situations as well I don't
think there's a an awesome solution to
this that I know of if you know of one
please tell me but this is just
something to be aware of when you're
using bind custom shrinking in general
is something that tests check doesn't
really support I'm not sure if there's a
good way to do this if there is then
they could certainly be added but I also
don't think that this is very severe
this is kind of a graceful degradation
in the worst case if things don't shrink
the way you want you at least have a
failing case that you can do something
with even if it's if it's not as small
as you'd like so summarizing this
section things can get too big or small
we have functions for scaling we have
functions for modifying the distribution
you can model your domain a little more
directly and get some benefits both for
generation and in for shrinking but
shrinking in general is is kind of
tricky okay so this is basically my last
slide covered a whole bunch of stuff
really fast I apologize for the things I
glossed over or said too quickly but
we've we've covered different kinds of
generators there's the data generators
then there's these abstract declarative
things and building generative
generators it can be difficult because
of this abstractness but it supports
some valuable features like growth and
shrinking and just like functional
programming with with practice it gets
more familiar so that's all I have
and again the couple of minutes if
anybody has any questions in back
so the question was about base cases
like zero or an empty string or 1970 I
think this this chart here sort of also
gets at the question so a lot of the
generators do have this sort of simplest
case that they'll generate if you give
them a small size I'll just start with
that and they will also sort of center
around that like even this large integer
generator when you get up to size 200
it's gonna be generating the full range
of 64-bit integers but it's still gonna
generate the zero and single-digit
numbers pretty often and that that's a
heuristic you can obviously write your
own generators that don't do that if you
don't like it the assumption is that
lots of edge cases center around these
simpler values and this also means that
even when you're generating a big
structure a lot of the leaves will have
these simple values so it's not just
that like you'll you're only get bugs
when you're generating when you're
testing tiny things you'll you'll be
testing edge cases even on larger
structures so I think that's that's part
of the justification for that one more
question Eric
so the question is about customs
shrinkage with an example from John
Hughes where he he shrinks certain
operations to a pause mm-hmm yeah that
does sound pretty custom the for just
the pause I was going to mention that
the like the frequency generator will
shrink to earlier things and so
sometimes if you know how a generator
shrinks you can set things up so that it
shrinks a little more favorably but the
especially when you're generating like
sequences of events and there's some
state that ties them together it's
really really hard I think there might
be some custom techniques but like I
said like test check doesn't have an API
for for supporting these things if you
want to do stuff at the low level and
learn how test checks implemented you
can certainly do whatever you want just
like in closure but like I said I don't
know of a good API for letting people do
really general stuff like that so I
think I'm out of time I'm happy to take
any questions for the rest of the
conference
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>