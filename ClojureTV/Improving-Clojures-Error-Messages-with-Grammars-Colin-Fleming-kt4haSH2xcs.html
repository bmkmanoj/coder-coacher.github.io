<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Improving Clojure's Error Messages with Grammars - Colin Fleming | Coder Coacher - Coaching Coders</title><meta content="Improving Clojure's Error Messages with Grammars - Colin Fleming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Improving Clojure's Error Messages with Grammars - Colin Fleming</b></h2><h5 class="post__date">2015-11-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kt4haSH2xcs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so before I get started on the main talk
I wanted to talk about something that
I've noticed something that surprised me
and what a lot of people have been
sending me this picture recently since I
started working on cursive and in fact
so today's your day folks you can
actually give me some money for cursive
today I open it up for pre-sale today
thank you it's very exciting so it's
just a pre-sale the full release will be
in about two weeks and there's a 20%
discount till then you can pick it up
and something else to say about that is
that cursive does actually work with the
community edition of IntelliJ so so
that's free it's open source you don't
need to buy IntelliJ to use cursive and
cursive will also be free for open
source and non-commercial personal works
and things like student work personal
hacking things like that and I just
wanted to say thanks to everyone for all
the support while I've been developing
cursive it's great cursive is the most
fun I've had at work in a long long time
and and that's a large part because of
the great feedback I get from everyone
and the great support ever and gives me
so thanks very much alright but we're
here today to talk about error messages
which are totally different ballgame
so these for a lot of people are really
like the pointy end of their experience
for closure there it's one of the
regular complaints that comes up for a
lot of time particularly new users to
Clojure that the error messages are but
incomprehensible they're hard to figure
out what's actually going on so I was
doing a bit of research whilst preparing
for the talk and I got the the details
from the 2014 state of closure which is
a survey of the of the closure ecosystem
and there were two freeform questions at
the end that I was interested in one was
named one language feature you'd like to
see added and so you can get all the
data from there and if you look at it
and you look for error or stacktrace
better communication of errors better
compiler error messages better compiler
error reporting there a mr. just bit
error messages and so on is it this is a
very very common thing there's a lot of
people saying that they want that they
want bit error messages in closure
similarly what do you think is the most
glaring weakness or problem error
debugging error handling error messages
error messages
mr. Cerra messages this is a big problem
for quite a lot of people for new users
but also for very experienced users as
well I think and so it's definitely
something that I that I think it's good
it would be good to try to improve if we
can so I wanted particularly today to
talk about macros and the error messages
that come from them so just a brief
summary of what macros are for those who
haven't used it very much so macros are
essentially a compiler plugin it allows
you as a closure developer to extend the
language that you're using to write your
programs they're just normal closure
functions this is something that often
gets lost I think when people are
talking about how macros work a macro is
just a function basically and it's a
function that's invoked by the compiler
at compile time so while the compiler is
going through and doing its thing it's
reading your your program if it finds
form that is a macro invocation what it
will do is it will call the function and
it will pass it the macro invocation
form and then the macro will work out
what that form does and it will return
another form to the compiler which is
what the compiler will will use instead
and so what this is used you'll see this
referred to and like the scheme
literature for example as language
towers so Clojure the language is
actually a very very small language that
only has I can't remember like 15 or 20
actual built-in forms and a lot of what
we think of as the cloture language
exactly macros in the standard library
and so you can think of a macro as a
compiler really from from one language
to another slightly different language
one is Clojure with a particular macro
form and then after the macro has done
its thing it's a slightly more reduced
version of Clojure that no longer needs
that macro form because it's been
expanded out and to enter code that
doesn't need it anymore
so the problem with macros there's there
are a couple of problems with macros as
long as well as many benefits obviously
but what I really wanted to look at
today was how macros are actually paused
so this is a macro that we're all pretty
familiar with at least familiar with
using there's different and so I had to
try and trim this a little bit to get it
on the slide but
the important but it's there so you can
see that basically different is just
defined as a function and it receives
the form which is the macro form of the
diff and that it's a that is expanding
in verses your local variables and and
then the various parameters are
essentially destructuring the macro form
in two parameters that the macro will
use to expand out to create the
expansion and you can see this little
bit of error checking there we like to
see that so if named as a simple if not
a symbol then we'll throw an arrow
saying those dark a definite must be a
symbol but the important that I wanted
to look at is in the the lit block there
where you can see how the macros being
passed and it's a very kind of manual
process so essentially the macro
receives the the form as a seat of
closure forms and it will just pick them
out one by one of a look at the first
thing is that's what I'm looking for
us--not if it is it'll store it
somewhere and and it's a very it's a
very manual process quite a laborious
process it's very very tedious to write
this code I've written a lot of micro
parsing code in my time while I've been
working on cursive it's very it's not
fun code to write and it's very
difficult to achieve reusability form
with this code so if you look at the
implementation of diff macro for example
diff macro has almost exactly the same
shape as different and in fact the
parsing code is very very similar but
it's not quite the same it's not quite
an exact copy paste but it's there's
very little reusability between those
two functions but most importantly it's
very very brittle this code so the code
tends to make very very strong
assumptions about what it's given and
the code basically assumes it's given a
valid different form and it will pick it
apart with those assumptions and if the
input doesn't actually conform to what
it's expecting then you'll get some
really really crazy errors you'll get
errors about can't cast character to I
see something like that and critically
the error message will actually come
from the compiler code so the error
message is often almost completely
useless to the user in terms of actually
trying to figure out where
and the users code things actually went
wrong so here's an example again of a
macro that were all quite familiar with
and a macro that doesn't actually check
its arguments very well so we can see in
the first example their illegal argument
exception parameter direct declaration
I've one should be a victor and so this
is an error that someone might make if
they were coming from scheme or common
list where they use round parentheses
much more frequently than then enclosure
where we tend to use square brackets of
victors for our OGG forms and the zero
is going to be quite confusing for
someone from their background you'll be
like argh one there's an argument why
does it need to be a victor so what's
actually happened there is they're
different and it's going through its
parsing and it's reached the arg1 arg2
list and different actually comes in two
flavors so it has a single arity form
where you say differen myath in and then
you give it a victim of parameters or
you can have a multi arity form where
you give it a series of lists and the
first element of each of those lists is
a victor which are actually the
parameters for that arity and so what's
actually heaven is closures actually
seen that it's a list it's assumed it's
a multi arity form which is not what the
user intended in this case and it's
given an error message relating to that
and again note that the error message
itself comes from core dot clj that's
closure core line six five six seven and
if you look at the whole stack trace of
that it's it's almost totally useless to
the to the user and trying to figure out
what's actually going on and so there
are a couple of other examples here the
second example there again it thinks
it's parsing a multi arity victor which
looks pretty plausible in this case
because that's what the first thing is
but when it's got to the to the second
element there which is the victor a B
it's just assumed that since there's
parsing a multi Rd form it's going to be
given a list and it hasn't checked
that'll actually is a list and so now
it's thinks that a is going to be the
parameter and it's not a victor so it's
complaining about that different foo a
don't know how to create I seek from
Clojure Lang symbol I mean who knows
what it's thinking right
bad dog string again don't know how to
create icicle enclosure name symbol the
only way to figure out why these
messages are coming out is to look at
the implementation of the macro and to
see what's going on and again these are
not very these are not useful error
messages for for the user different it's
name it goes a hidden defines a VAR who
knows what it has in it and and then the
last one that's just a misplaced man now
you might be thinking I used different
quite a lot and I'm sure the error
message is a bitter than this and in
fact you're right because there was this
fantastic JIRA enclosure one 5cl j15
seven need bit error report when a
missing parameter list from if they're
no different
it sounds like exactly what you want so
the description is somehow I just forgot
to define parameters my zero argument
function and it took me a long time to
notice it mostly because I've been
working with a lot of macros but
especially because I didn't get an error
that said you must provide a list of
parameter names but instead don't know
how to create I seek from symbol and
this is an experienced user this bug was
filed by a embrose bonus agent who wrote
core.typed so while these errors are
particularly difficult for newcomers to
Clojure experienced programmers have
problems with these as well but this is
a great JIRA so here's what the error
messages look like afterwards and the
first one the Aramis is actually almost
exactly the same but critically the
error now shows where in the user's code
the problem is so you can click on that
link if you use inside our recursive or
something or you can just go and look it
up in the file and it will tell you
where the problem actually is and it's
much much easier to figure out what's
going on and there are much better error
messages for these other cases invalid
signature AV should be a list parameter
a should be a victor it doesn't accept
just different it's name first argument
must be a symbol and so on so the error
messages are much much better after
after this jerome but i wanted to
comment a few things about this JIRA
firstly as priority was minor I'll just
leave that there without further comment
it took three years for this Jared to be
fixed from the time it was filed to the
time it was came out and there was it
wasn't like it was just sitting there
languishing there was actually there's
quite a lot of activity on the Giro and
this time so these are all the people
who are involved in fixing
you probably recognize most or all of
them they're the people who are
implementing cloture who are working on
cloture they're implementing significant
cloture libraries and they're spending
quite a lot of time on this juror there
there's a lot of discussion and effect
so they didn't just have a single
comment each they're actually a whole
bunch of comments and a lot of us was a
sort of back and forth a lot of it was
discussion of regression impact about
fixing these things so pathological
cases that used to be accepted by the
compiler and they're now and now throw
errors which you do you need to be
discussing that stuff while you're
actually doing this because you need to
assist the regression impact and some of
these comments were also just the
workflow of the juror so okay now it's
screened now as weighted and so on but
it took a lot of time to go through and
to figure all to figure out how these
changes should work what the changes
should be and after all that work we fix
three cases in one macro and different
isn't actually even a very complicated
macro it's quite as a relatively simple
one like the NS form I mean that thing's
huge and I mean there's there's an awful
lot of unhappy paths through the NS
macro while you're parsing it so but
these things are getting bitter so if
you look at the release notes for
different closure versions there's
actually a separate section always in
the release notes for improvements to
the error messages so Clojure 1.8 there
are four improvements there closure 1.7
they were - closure 1.6 there were six
of them but again when you look at these
fixes they're very very specific so
similar to the diff and they and they
fix very very specific cases that have
cropped up and presumably each of these
requires a reasonable amount of work to
get it through and better and whatnot
and there's plenty more where these came
from right so there's currently 39
jurors open just with the tag error
messages so we're going to be fixing
these things for a long time I think and
I think we probably need a better
approach I think well I think everyone
agrees it's that that you know that
jurors fantastic it's it was a great
result there are misses are much much
better as
as a result of it and hopefully it's not
too controversial to say that I think
the ROI on the amount of investment they
went into it as maybe not as great as we
might hope so
Kosovo I spoke a bit about this at the
college last year about how cursive
works basically cursive unlike most
other closure editors doesn't use the
ripple for its editor functionality so
most closure editors they will actually
the sort of continuously talking to the
ripple while you're editing to provide
the editor functionality that you want
so things like navigation that will go
out to the ripple and it will introspect
the VAR that you're trying to jump to to
to get the metadata off it to see where
it needs to go
similarly with documentation why not
cursive doesn't actually do that so
cursive actually works by analyzing and
the unexpanded source so it quite
deliberately doesn't chooses not to use
the ripple and it also deliberately
chooses not to expand macros for for
various reasons that I won't go into now
so this means that needs to understand
what macros mean and it really means
that it needs to parse the macros in
much the same way as the actual makers
themselves doing so when I first started
out writing cursive and I started
implementing support for a lot of these
macros the core built-in macros I passed
them all by hand so I had very similar
code to what the macros themselves have
I wrote macro parsing code for nearly
all the core macros all the core macros
that cursive supports which is most of
them these days and in really
complicated cases like the NS macro I
mean there's an awful lot of edge cases
in the in its macro because it's a
combination of a whole bunch of
different macros or functions all
bundled together and there was no way I
could capture all the edge cases by
writing code myself so so I just
basically copied it copy the code from
closure core into the cursive code base
I modified the cursive ast elements so
that they mimicked as closely as
possible the elements from closure core
and they're they're basically helped
with the porting of that code from the
original closure core code to do
something similar with the curse of AST
but it was really no fun right it was
not
it was difficult work it was quite
tedious too and it was very very hard to
get it right so in a compiler
particularly when you're starting out
you can you can kind of punt on error
messages a little bit you can say well
you know I'm just going to assume that
you're giving me that input and if
you're not I'll just do something a bit
crazy with it so and Clojure is a
compiler even though it doesn't seem
like it sometimes while you're in the
ripple you're working interactively
there's no interpretation if it happens
with closure so it receives the form it
will basically parse and compile a
top-level form at a time and then it
will execute it so in an editor the the
ast is continually broken while the user
is working on it so so it's like the
normal stage right you can't assume that
that the input you're going to be given
as good and and so the macro parsing
problem is much worse so what I found
was I was getting similar error messages
to the sorts of things that we saw
earlier from standard macro expansions
users were getting those all the time
while they were editing code in cursive
because they're the ASE is broken while
you're working on it right while you you
know you're writing out your inner storm
where you're different it's missing
parts that it needs that you haven't
filled in yet and so the micro pausing
problem is much much worse because it's
continuous and the user sees it all the
time but it is still the same problem
and I think that the fixes that the
sorts of fixes that I ended up with
using and cursive could also be used in
the compiler and I think they would make
the compiler error messages much better
so I thought quite a lot about how to
actually fix this
I was eventually tipped over the edge
when I was implementing core type
support which has very very large
complex macros there's a lot of optional
parts to them writing the code to pass
them as really is really quite difficult
so so in the end I figured while I'm
parsing things I should just write a
parser and that was what I did so the
initial implementation was fairly simple
paths I used the semantics of parsing
expression grammars which I'll talk
about in a little bit it took like the
initial version literally took me an
afternoon it was 200 lines of code and
it just saved my life
I
I can't describe how much better it made
my life this change so parsing
expression grammars there are simple
recognition based formalism so to
describe a top-down puzzle with
backtracking so the fact this
recognition based means that basically
they were designed to be used in parsers
and so essentially you give it a bunch
of rules and it will try and pass
something if it can't it will then
backtrack and try another alternative so
in theory the backtracking can lead to
exponential time with the parsing and
practice there doesn't actually happen
very much even complex grammars only ten
for machine oriented languages pigs
aren't very well suited to natural
language but because the backtracking is
quite limited I'll show you in a moment
how that works the backtracking only
goes back to quite fixed points and
practice it's actually quite it's quite
easy to handle and you can also use
memorization with ease that's called a
packrat parser where essentially it will
use memorization for the intermediate
results and then you get guaranteed
linear time while you're parsing at the
expense of memory so again in the worst
case and a pathological case the memory
use can be exponential but they get in
practice they're basically never happens
for for computer oriented machine
oriented languages and one other
interesting feature of these of these
grammars is that there's no ambiguity
and there's never ambiguity has never
introduced because it uses what's called
an ordered choice operator so these are
the basic operators and a pig if you've
used any sort of grammar before VNAF or
anything like that or even if you've
used regular expressions it's pretty
similar basically so you can group
expressions you can have you can have
optional elements you can have zero or
more the negative look ahead what they
will do is from your current point it
will try and pass ahead and if it
succeeds in parsing then the possible
fails so that's sort of a way of saying
I'm not looking at this particular
expression and then the order choice
operator is the main thing that kind of
distinguishes pigs from a lot of other
grammar things and so basically it will
try and parse the first expression if
that succeeds then you're done that's
your result if it doesn't succeed then
you try the second
our third alternative you go through the
alternatives and that's how you avoid
the ambiguity basically so the
essentially the burden is on the
programmer to ensure that your grammar
is not ambiguous so you need to ensure
basically that none of your earlier
cases will leave a shadow you later ones
but not having ambiguity is actually a
really nice feature in a parser and
again you can sequence them which is
just when you pass the first expression
then the second one so this is the
initial version of how the code actually
turned out in cursive so on the left
there you can see an example of what the
grammar actually looks like so at the
bottom there is the pattern for
different so these patterns assume that
they they implicitly receive a list
because olmec reforms are lists and
closure so a difference starts with a
symbol which is a different itself and
then it has another symbol which is the
name symbol so you can see there it says
symbol as name symbol that's actually
just a simple capturing mechanism so the
way these parsers work is you'll give it
a form you'll try and pass it if the
person's successful that will return you
back a data structure with all the
elements that you picked out of the form
as you were passing it and so the two
basic ways to do that you can see
there's symbol as name symbols so that
will just take the symbol and I'll put
it in the map using the key name symbol
or further up you can see an into
declaration and that assumes that
there's going to be multiple of these
things so it will create a victor and
just put them and so you get a series of
these things back so the grammars
reasonably straightforward I mean
different as a symbol which is the
difference then we'll forward by the
name symbol then you have an optional
doc string you have an optional per ml
then you have some arrow tees so the one
thing that might need a bit of
explanation is the item so again because
you're receiving a data structure back
you can use item to create nested maps
within their data structure so item just
basically creates a new map for some
sort of sub element of what you're
passing and then the the sub passes to
item the things that it captures will go
into that second map and in and so on so
you can see in the arrow tees there
there's an alternate there between the
the singularity forum and the multi
arity forum but hopefully it's
reasonably simple to understand what's
actually going on there and there's an
example of a part on the right there so
there's a simple function different esta
fin with a with a doc string uses a
little bit of destructuring there and
you can see the data structure that the
parser will return at the bottom and so
it's picked the various pieces out as
its passing through so it gives you the
name symbol it gives you the doc string
you get victor of your arrow tees and
then you get some information about the
arrow tees you get the UGG list so
they're the parameters that's actually
two elements it's a victor and a symbol
so let's use cursive actually does arity
checking so so the parameters element
there will tell you what the arity of
the function is how many things you need
to pass that the targets are slightly
different that is all the local
variables that are declared by this
function and that's actually slightly
different here because we're using these
structuring so there are actually three
local variables even though the because
we're restructuring them even though the
function actually only has era t2 and
and this change was massive I mean I
can't describe how much that's improved
my life and improve the lives of all the
cursive users as well because they were
used to getting these sort of random
crazy exceptions while they were editing
their source code and all of a sudden
everything became much more robust
basically the these puzzles were still
quite simple they would essentially just
just fail if the input didn't match the
grammar but that's okay it's better than
some exception right so what would
basically happen is that it would be
quite obvious because cursive wouldn't
be able to resolve symbols inside the
macro form but it still it still didn't
actually show you where the arrows were
but even so the the grammars are much
more readable I think then the
equivalent hand parsing code the hand
parsing code especially when you look at
some of the larger macros is extremely
extremely complicated and it's very
they're quite difficult to maintain as
well if you suddenly want to change a
little bit about how how the macros
passed in the middle of the form that
code is quite difficult to maintain so
in in contrast to someone who's writing
new macros for cursive I actually have
to write parsers for existing macro
forms
so I basically tend to look at the
documentation and see what the
documentation system accra looks like I
look like look at a bunch of examples
and see what the maker actually looks
like and then I make the grammar based
on those and these grammars are much
much easier to develop based on a bunch
of examples and some documentation then
writing the code by hand
they're much faster to write so even for
a complicated form like something like
the core typed macros they have a lot of
optional parts there they're quite
complicated I I can sit down now with a
little bit of experience and like half
an hour an hour I can come up with a
grammar for a very complicated form and
I can be reasonably confident that it's
actually correct that they're easy and
there's a lot of reuse you get there as
well because if we look at the the
grammar here again you can see that the
parameters think so these are just
functions here basically so you can
compose them or you can reuse them
however you like
and so parameters is actually called
twice there but that parameters little
chunk of grammar is actually reused
anytime that you need to pass a list of
parameters for something that they're
under the hood is going to be destructed
down to anything form right so that's
different and a bunch of other things as
well but you don't just get a lot of
reuse in the grammars I found which
actually surprised me so the fact that
you're separating the parsing and
separating the parsing out from the
processing and those data structures
really form a data API between the the
the parsing process and whatever you're
actually doing with the results of the
parsing in my case i'm doing i'm
creating indices and whatnot but code
generation would be basically the same
thing and that data api actually allows
them a surprising amount of code reuse
so for example diff and and if in
semantically are actually pretty similar
because diff and really do sugars down
to just diff in an if in that takes a it
basically takes it creates an anonymous
function and sticks it in a bar that's
basically what different does and so the
fact that if i can create the pauses
such that they create the same data
structure from a different and FN even
though the syntax is different and then
i can just use the same back in code for
both and this was actually really useful
in core.typed as well because
core type has like an old-style syntax
and a new-style syntax ember has changed
a while back so I just need a different
parser for the two different syntaxes
but as long as they produce the same
intermediate data structure then the
backend code or the the processing code
is still that is the same so I was
extremely pleased with myself I thought
I had invented the best thing since
sliced bread and so I send it off to
Ambrose who was working on core type and
he was suitably impressed as I send it
off to Colin Jones who at the time was
writing the book on cloture macros and
he said oh that looks like illuminated
macros I was like wow and it turns out
the two years ago at the cons Chasseur
and Jonathan Clegg it gave basically
this exact talk talking about how we
should be using grammars to pass our
macros because it's great right and and
their work was based on a paper called
fortifying macros and this is paper
right into record and actually at the
college last year after I had spoken to
after I'd spoken about cursive and how
past a lot of macros are speaking to
Wilbert afterwards he said I you should
check out the syntax pass thing that
they did and I didn't listen to them
because I'm a moron obviously and that
turns out to be what fortifying macros
talks about and so five years ago they
had a great solution to this problem
and so the listeners always look at the
scheme thing folks to see what they're
up to because they do a lot of really
cool stuff so but I also wanted I also
wanted better error handling so when the
forum wasn't correct I wanted to be able
to help the user to figure out what was
going on
so top-down pass is usually a good
support for this because essentially you
part you start at the top and you pass
down recursively through different forms
so when you reach something that you
don't understand you have quite a lot of
context to know it to explain to the
user what you are trying to do what you
thought was going on and you can use
that to provide pretty good error
messages pigs make that a bit more
complicated because they backtrack so
what that means is that for any given
Pig paz'
if it can't match the input that's not
necessarily a catastrophic failure it
doesn't necessarily mean the input is
bad what it means is you have to
backtrack to your previous alternation
and try another option
so this sort of dual failure mode of
pigs actually complicates their handling
a little bit what you will tend to get
so if you imagine what a pig for
something like JSON would look like I
simplified JSON so the top level you
would say a JSON object is maybe it's a
string or a number or in JSON object or
a list and then a JSON object would be
some curly braces followed by one JSON
object which is the key of the JSON
object which is the value and so on so a
pig if you give it a big JSON document
and there's an error halfway through it
or pass through it but then when it
reaches the failure a naive
implementation will just backtrack
through the various alternates and then
it will basically say at the beginning
of your document I tried to pass a JSON
document and I couldn't which is not
very useful I would say I couldn't match
either a JSON object or a string or a
list or a number it's not any of those
things and it doesn't really help so the
usual heuristic here is while you're
parsing you keep track of how far you
got with each of your alternates and
then you assume that the farthest point
you got to is where the error actually
is and so when one of your positives
fails you basically at the point it
fails you maintain how far through the
input you were and and you record a
bunch of contexts and then you can use
that later to give pretty good error
messages so here is a slightly modified
form of the grammar which just to help
the error messages so pretty much the
only thing that's been added there is
has these and these called forms here
and that's just used to provide a human
readable error message so I'm going to
show you a demo now I followed a strict
TDD philosophy while I was developing
this demo which is talking and
development I I thought it would be an
excellent idea to propose to talk about
something that I'd done quite a bit of
research on but hadn't actually
implemented that turns out to be a
terrible idea don't do that um I got
extremely busy with other things so I
didn't actually have as much time to
work on this sort of liked and input so
the main thing is that this is not
actually in the public cursor version
yet this is still just a proof of
concept
but as you'll see it actually works
pretty well so here I have my goose
ripple I'll just load that namespace and
switch into it
so here are these these macro forms that
we saw before and this is Clojure 1.7
actually that's a little bit small
unfortunately so you can see these are
the the bidder error messages produced
by their more recent forms of more
recent versions of Clojure and again
that's a bit smaller sorry but so is
there a misuse here and there are some
other cases down here as well so here
are some other things that I've
basically picked off the mailing list
while I was looking for four different
options for different so while I was
preparing for this talk I went through
the mailing list I looked for people who
are complaining about error messages to
see what the sorts of things were that
were bothering them so here's an example
here that that would be quite a common
case for a new user to Clojure when
you're using the NS form it's quite
difficult sometimes to work out when
you're in the ripple you have to quote
things and then when you put it your
interest form you don't have to quote it
anymore and so here if the if the user
actually forgets about this and they put
it in they get the zero message here
class not found quote dot open
parentheses and l-dog could work or
something
no class name I've ever seen has a
parentheses in it but it's so it gets
this this crazy error message that for a
new user which is this is quite a common
mistake or an easy mistake to make at
least and their error message is not and
optically useful so the user might go
through and try and fix it and then they
would try this here for exact and the
compiler accepts that perfectly well
then you go to the tester namespace and
you say and it's not there and so what's
up with that and again that this is a
very confusing case for a user because
they think they fix their problem the
closure compiler said it was okay but in
fact when it loaded in it didn't do
anything
so the way this works is that the import
form here if you if you want to import
this class you why they have to do it
like this so you're essentially
importing the the package and then the
class separately and you can use that to
import multiple classes for a single
package all we need to do it like that
and just import a single class but for
someone who doesn't who isn't very
familiar with closures getting started
or even just an experienced user who
makes a mistake and it's quite a subtle
error and that it can be quite confusing
to know what's going on and there are
various other cases down here so here is
what this looks like inclusive now
so I can now mark these errors right in
here and and this actually shows you
exactly where the error occurs so again
because I'm parsing through the forms I
know where it failed I know which form
it failed on I can actually show the
error right on the on the place and the
Euro message is actually pretty good
like when you look at it unexpected
simple ugh one expected parameter vector
that's actually almost exactly the error
message that was handwritten from the
closure compiler but these error
messages are automatically generated the
only thing that's required to get these
error messages is just to annotate the
grammar with some friendly names for the
particular things that it's looking for
so parameter vector is just a friendly
name otherwise it would just say victor
because it only knows the type of what
you're looking for and again these cases
here the the error messages I think are
at least as good as the handwritten ones
and sometimes they're better so that's
saying here expected that it's a doc
string and attribute map a parameter
vector so again the parser knows all the
possible things that might actually be
present there and it can show you these
cases and it caches so it catches all
these all these cases and and
importantly I didn't really have to do
anything to actually do this I'm already
passing the forms I know what what the
shape of the forms is I really didn't
have to do any work the only work had to
do for this demo was actually implement
showing the errors that well I don't put
the error handling which Odin had
previously and then just showed the
errors and the editor but now for any
new grammar that I develop I'll get
these errors automatically for free and
it shows the things here unexpected
quoted form expected sequential form or
a symbol again in the NS form I haven't
actually gone through and given up the
friendly name so I can make the error
message a bit better and the same thing
here they expect that symbol at the end
so there are some other things here that
are some other cases that are caches the
documentation for Innes is that
references in the NS form have to be one
of zero or more prefer Clojure require
use and port load whatever that's
actually a total lyle except pretty much
anything you give it you can put Nouvel
in there if you want it'll do that as
well quite happily and cursive marks
there is an error it's I guess it's a
little bit arguable as to whether that's
actually an error or not given that
closure X except it is actually valid
I'm gonna leave it as an arrow because I
don't think you should be doing that so
there are some other cases here that it
catches previously closure for example
when you say quote one two three it will
just return your one but you've actually
passed it multiple things to quote there
which is an expect same with via some
other cases that I found on the mailing
lists here someone had left their full
stop outside there don't comment so this
is this is much much nicer basically
it's much easier for the user and again
these are updated dynamically as you're
editing so it's very easy to see what's
going on right but I know there's at
least someone out there thinking I know
but IDs suck and cursive sucks and this
looks nice but I don't want to use it so
but it's okay random internet hater
person I've got your back so just to
show that it's nothing up my sleeves
this is just a standard line rule so I
can do install the goodness here right
and I'll just do function that always
returns teen right that's always useful
so different works just like it always
did previously but now I get these same
error messages that I got on the cursive
editor here so none of this is
specifically cursive right I developed
this because I wanted me to error
messages in cursive
but you can use this for normal clergy
code so this could be used just to
create if you didn't want the cost of
validating all your built-in forms while
direct and running and production
there's really there's no runtime cost
of these right there's a load time cost
so it's only while your code is being
passed and and the macros are being
expended that there's any cost at all to
this once the macro has actually been
expanded and compiled there's no runtime
cost at all to these error messages and
I think these make a big difference and
so again we can do some some bad things
here to the in this form and it will
work so all those cases you saw in the
editor will work fine here and I think
there's quite a lot of scope here for so
this basic what the way this works is
essentially monkey pictures different
and in is it uses altered by route on
the macro and what so what it will do is
it will pass the form that it's given
and assuming the powers returns no error
messages and it will just call the
original so it's a reasonably low impact
form right so who's making a con so just
a little bit of inspiration before I
finished there's a fantastic blog post
here I recommend people read it I've got
a huge gig crush on Evans of lucky who
makes Elm he's a very thoughtful guy I
think he he writes a lot of stuff that's
about Elm but I think a lot of it is
about programming in general and about
implementation of programming languages
in general and I think I think we could
learn quite a lot from him even if we're
not using Elm so he talks there about
how he sat down to think about error
messages and just by really focusing on
what the user experience of the error
messages as he got some really dramatic
improvements and he had some examples
there and there's blog post there's a
little bit of C on the projector sorry
but so on the left is the code and on
the right hand side is the error message
from the bad code so it actually shows
your exact line of code as it appears in
your source code so this isn't some
pretty printed thing from the ast that
the compiler has it actually has the
actual source code
in there and it shows you exactly where
the error happened it gives you some
sort of friendly hints it has a database
of errors and it tries to figure out
based on the error message you got what
it thinks you were trying to do and it
shows you some ideas there and it uses a
little bit of color and layout to make
these errors these errors friendlier so
the element takes error message handling
very seriously they actually have an
error message catalog which is a github
repo where people can upload snippets of
things that they've got crazy errors for
so they can analyze them and try and
figure it out I think this is a
fantastic idea it also produces JSON
errors for tool consumption and things
like that there's an open question as to
whether it actually helps adoption a few
people have said to me well ok that's
all very nice but no one actually uses
them and tons of people use closure so
maybe this is next year problem right I
which I would answer that's kind of a
depressing argument and they just like
saying you know we're we're sort of
mediocre enough that no one complains
but you know I think it's something we
should be trying to improve for a hit
so I'm not actually sure whether it
helps adoption or not but it kind of
feels like it should and it feels like
something that would be nice to do for
our users thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>