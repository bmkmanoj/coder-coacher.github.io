<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Poetry of Programming - Attila Egri-Nagy | Coder Coacher - Coaching Coders</title><meta content="Poetry of Programming - Attila Egri-Nagy - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Poetry of Programming - Attila Egri-Nagy</b></h2><h5 class="post__date">2017-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XRjPnuPv6xo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay thanks for coming and I'm going to
introduce myself properly but let's just
mention first that was the topic here
this talk is about designing and
deploying a full semester closure course
so I will talk about how to teach and
how not to teach closure to beginners
and in more general the cognitive
difficulties of problem solving and also
my personal mission of trying to
understand why I like this language so I
will introduce myself and I of course
will give a background story how this
happened and I will talk about the
design of the course then of course
running the course and probably what's
most useful for you and we talk about
general problem-solving and and coding
in size and talk about the future of the
course as one so Who am I well I'm a
software engineer disguised as a
mathematician and I work in applied
computational abstract algebra well
don't bother looking it up I made this
up completely but that's the best
description of what I'm doing and I also
teach traditional math classes but
probably more interesting here my
language history I started with
Commodore 64 I did assembly in manually
just putting the numbers in and then of
course at university Pascal and C then
as a software engineer I work with Java
then I left industry and I did economic
research using the gap system which is
really great if you do group theory and
it's sort of hybrid functional
object-oriented and then I use closure
for recomputing these results as for
just gathering evidence ok this is the
place where I come from it's Okita
International University it's a very
small liberal arts college in northern
Japan but with a specialty that all
courses are taught in English this will
be quite crucial
I'm saying and we also offer programming
course courses c-sharp and enclosure and
you might ask how come well what's the
rationale for teaching programming well
you know there's a hype around this and
somebody should teach everyone coding
including kids which is I like the idea
I just don't like kids hunting over
laptops so it's let's say it's a
slightly controversial issue but what we
can agree your bar is that every
University students regardless of the
major should have at least one good
programming course because it's just
part of universal knowledge in
particular at AI we are working on a new
major called digital studies which you
might think of as liberal arts sort of
getting a digital upgrade well that was
the you know the official rationale how
did it really happen well I landed in a
new job and I realized that there were
expectations for deploying new courses
and of course if you are an academic
this is well this is an extremely great
opportunity because you can design your
course and you can teach what you like
so first I did you know just a discrete
mathematics course about basically how
explaining how computers work and that's
I like that part of mathematics and then
I realized that okay
the expectation is still on so I needed
to do more courses or of course I had to
come up with a new tactic it's like okay
let's suggest something which is crazy
enough that it might get rejected so I
get more research time or I get a course
which is research itself so this is how
this poetry of programming came about
okay right at this point you might loss
in poetry and well of course in a
limited sense if you think in terms of a
haiku it's a very short poem focusing on
on a feeling or a situation but it's a
very expressive use of
but that's exactly what III plenty and
to teach expressing an idea how to do
something or describing a problem with a
very short but very expressive piece of
text but of course the question was that
would the students come okay you can see
I tried my best in marketing the course
and actually they did come so sixteen
registered and fourteen finished the
course and the gender ratio is three to
eleven you might guess which way it is
but it's it's not zero to something so
that was was great okay well I had to
design the course and at first you know
you want to do it in the easy way
thinking that oh there are very good
beginner books I just walk into the
classroom and start teaching those but
then you realize that these two very
great books they are not for the
complete beginners they target software
developers who want to learn closure so
my audience is just different so I had
to think about this problem how to teach
beginners and I realized that I had to
do three things I had to find a shared
background knowledge in order to to
ground metaphors and and of course I had
to produce some very focused material
minimize demand and and one concept at a
time in particular for for our students
the shared background knowledge is
actually high school algebra and well in
Japan you get quite good high school
algebra background so real valued
functions and even some bit of calculus
ease is known and it's very important
than all the students there they already
learned one foreign language mostly
Japanese and they are learning in in
English regarding the reduced material
of course I cannot teach any tooling no
idea no image
just a wrapper and of course the same
argument it's like no Java interrupts
because that's that's another language
so that leaves the functional core of
closure and um well I started thinking
that okay that's what I want to teach
but how exactly and and in what order so
I figured that well I have to do it one
step at a time that means that I want to
introduce a new concept when all the
parts are already known so for example
you might think that what function
definition that's where we start right
that's the easiest thing but if you
think about it it's not quite because
it's already has many things of course
well you have to know about lists and
function calls but you have to explain
what def does and you need vectors for
the for the argument so it is not as
fundamental as it seems and well the
alternative is to ask for postponing or
understanding you can say that Y okay
you need to write this but you don't
need to worry about it now just you
remember HelloWorld in Java so my
question was that which path in this
dependency graph of closure functions
and concept maximizes speed and and
phone and it's it's it's not an easier
not a simple question because some of
these students they you know they
probably just have this one course
exposure to programming so you want to
maximize the fun okay
so running the course well I found my
starting point and it might be a bit
peculiar its function composition the
reason is because I teach it I teach it
in college algebra and I taught it many
times and I said that okay when you do
function composition basically you are
already doing programming okay just you
know trying to improve them the stance
of mathematics saying the policies
useful knowledge so one of the obvious
next step is just to do it and the
argument goes that well if you have to
if you have to learn this stuff anyway
why not using it all you need to do is
just
to move the panties a bit and you get
exactly the function composition okay
starting with simple functions the
identity is the most important simple
function and of course just doing a bit
of arithmetic and then the game is on
it's like so what can you do with a
limited set of functions okay you want
to start something a set of very small
set of functions well you know I had to
sit down and think about how to put
these together so well this is sort of
the coin style game so what's the value
if you compose incremented decrement or
of course that's a no identity for four
numbers but here's another little puzzle
it's what happens when you compose
compose with itself it's like you have
to think about does it make sense when
you have composed without any argument
and of course it does make sense because
that's the identity function because it
has to compose nicely and you have to
give a nice default values for for
composition so basically composing when
composes just compose so this would be
negative one but the point is that this
forced me to revisit this function so I
had to think about I had to look at them
again and here's the the question in in
red for everyone so when do we stop
learning okay we start learning the
language and we admit that we are
beginners but once you get comfortable
with it oh yeah you know I can code in
this language well I mean we just stop
right we don't look anymore
and unless there is a problem and so
it's useful that you know what to look
at the van on stuff again and again and
you discover interesting things and
actually this turned into the way of how
to to do the assessment actually
students asked for this or I was a bit
late with that because well okay we are
having fun but there is an expectation
that well there has to be a grade at the
end
and it's not just administration but
students themselves and what how do you
do paper based exam right in a
programming language and actually you
can do right let's say this reading
exercise I did a lot so here is a
one-liner what's the value and it's
coming round of him and of course I
didn't require them to write down the
exception it was enough to say just an
error and what regarding exception I
told them that well when you get an
exception well you just think about the
problem more and start again because
it's probably easier it's forced for
small problems you don't need to figure
out what happened in the error and some
student said okay this was a really
great way for learning the language okay
and also function definitions are not
urgent because many data structures they
behave like functions well you can have
this silly exercise you can compose
vectors with bitmaps but as actually
it's not that silly because if you look
at it while there is a more sensible one
you can map the digits to the English
birds and it it's again just a function
another non-issue immutability is not an
issue right I can do this little piece
of code and if you're not not surprised
that four does not appear in vector V
then just no worries we can move one and
and it's you know I've went through from
Commodore 64 assembly to closure but
they don't have to go through the same
path okay that's an enormous opportunity
and it's a nice experiment to see new
generations of programmers starting with
immutability straight okay I was very
happy to have the conceptual cognitive
metaphors coming in in today a closure
community so I can refer to them because
that's what we do in teaching we need to
find the right metaphors for example for
binding value
it's it's like creating long long-term
memories or attaching meaning to words
and both in towers immutability and of
course they got the department we
defined functions and there's just the
usual algebraic abstractions you do a
couple of calculations you identify the
moving part and so you put and put a
hole into the expression for that part
that's your ex and you can do this
abstraction then you give it a name and
you use it everywhere and and this
seemed easy and it worked well and at
this point my my vanity kicked in it's
like okay what did I do in the last 20
years if if students can go and eat this
fast right so but I mean this is how
people Lorentz think this way but it was
not that easy because the next corner
you hit a roadblock and and you realize
that well we establish the shared a
background knowledge and that's
mathematical functions but then we lived
it well that's new for them so when I
just told them to write a function that
somehow makes these strings and numbers
and they were like okay what happened
here so it's it's actually the same
problem as in as in mathematics then we
sort of stop and then we have to work
with objects that are not familiar okay
so I thought what I had to put a bit
more effort on on bridging this abstract
realm and everyday experience so well
since the reducers talk we know that
it's opposed all the way down anyway now
I introduced a bit more fruit and the
key point here is that the concrete
example is like separating the oranges
from the fruits and the abstract example
of the same idea we use filtering a
collection is just next to each other
and of course closures
syntax is quite nice it's almost late
reads like English text and well
visualization is always helpful
what makes future great well because we
have these two three and four values and
it's very flexible we can filter by said
so what I've created this diagram T to
emphasize that we can treat almost
everything yes true okay map that we
just repeat the same operation for all
elements of a collection peel of the
oranges and and this was a general
advice I had to give the students all
the time that well all you have to do is
just to figure out how you deal with it
in single element because collection
processing is automated and it's strange
enough even students with no previous
programming background they sort of try
to do it's like okay I understand map
but I still have to go through the
collection somehow okay so it's it's an
interesting fact and yep
I mean you should try this game maybe
not now but I think this game can teach
functional programming in a very
entertaining way and then yeah I
introduced reduce as well and well again
the concrete the fruit salad next the
biggest collection abstract and the
concrete example together but I I need
to talk about which is a bit more we
have nice metaphors available you know
that the child is on the on the beach
and collecting pebbles in a pocket or
just looking for the most beautiful
pebble but what I found is that the most
useful thing is the reductions function
I so I can't built-in debugger for reuse
and it shows you exactly what is
happening
in the reduction process okay so well
this is the point where I had to
actually reconsider my way of thinking
as a programmer naturally we play this
game of reimplemented functions that
that we use just to understand how they
work and and I started with the
recursive implementation then later or
introduced the one which we use and the
question is which one is nicer which one
is better and of course in in what sense
is it better and well in terms of
cognitive load while the reduced one is
lot easier because for the recursive one
you have to imagine this hanging cons
calls and on the stack right and if you
don't have the background knowledge of
this stack then it's like well you don't
even know what to imagine exactly so
what I found that I was blinding by
recursion that's why sort of academic
upbringing you know self reference is
the thing when when it starts becoming
interesting and of course well it's a
cinema experience as well so it's like
recursion is great
but I have to think next time I will do
reduce first talking about the schedule
so here is what I did in 15 weeks it's
like two classes per week so that totals
in 37.5 hours and so this is the weekly
schedule of it as you can see I did
creole to graphics at the 14th week okay
I did not introduce mutable functions I
didn't even introduce print line because
you don't need it sand in the rapids
it's already printed and as you can see
I did recursion first and
we use later which I will do the other
way around
next time so a few words about the class
format well most of the time it's like I
I did a little bit of live coding
it's instead of lecturing using my
Raspberry Pi in the Emacs and insider
and the good thing about live coding is
that well of course you don't just want
to go straight to the solutions you sort
of want to dramatize it so first you do
a couple of force attempts but if the
problem gets just a little bit more
complicated and it's it's very easy you
know just map get on the wrong level in
the recursive call and you get something
completely different and it's not acted
anymore it's it's it's real and I'm
wondering whether the students realize
it then it it actually happened in the
class that I I didn't really know at
this point how to fix the problem but
okay that's life coding and two third of
the class is its problem solving so they
actually solve these little mathematical
puzzles or the talked about and I did
what I call patrolling just walking
around and looking for screens with the
most read text on it and the great thing
that happened in student help each other
okay so one student finished stood up
and and went and had other students I
mean that's really great so an example
problem as the Collatz conjecture it's a
very nice puzzle you have dysfunction
defined and it's still an open question
in mathematics but it this conjecture
that no matter what X you put into this
function and you keep iterating it
eventually you get back to you to one so
the question was what number between 1
and 1000 produces the longest sequence
and but it's an easy exercise to define
the function itself then what you need
to know a bit of collection processing
and and lazy evaluation and so you can
find the
the sequence length of then and then
it's basically again just collection
processing you have to to find the
longest one and this one actually the
solution came out quite nice because it
happens then the long longer synchronous
178 and what which one is the number
that produces that well that's 871 and
students were happy I was like okay
that's a very nice exercise how did you
design it and it was just completely a
random choice okay but what I wanted to
talk about here that most concepts are I
try to introduce this called
transformation so that means that we
already have a solution but I show that
all okay if you write it like this then
it's while noise or simpler or better in
in a way so for example in in this
particular case or introduce max key and
it's just one line instead of two
except that apply seems to be a pain
point for for some reasons even I mean
you know I thought I used very nice
metaphors it's like well this container
and data structure is just packaging and
you cannot eat the apple if it's in a in
a package but it it's especially
confusing
well addition is a very nice case so
it's apply introduced seems to be doing
the same thing and I also vaguely
remembered and I had a slight problems
in to apply but I don't remember what
was exactly when I learned closure so I
am I still don't have a clear answer
that why apply seems to be a difficult
one okay so here's an example of a
complicated solution because often they
come up with a very complicated solution
and it it's like you think that it's
it's a lot more difficult to do it that
way ok so here's one as from the very
beginning you have to write a function
that multiplies the number by 10 and in
the solution by the student was this and
I had to look at it is like okay
what happened here exactly so then I
realized that okay I see what happened
so I told the student that it can be
simplified this way well as student was
like really checked in the rep oh yes
but then I don't understand okay so I
mean this is the type of problem you get
and I had to think hard that okay so
what what is saying in in this
particular case and and of course what's
happening here that maybe there was a
half solution without the definition of
just using the lambda function then it
it got put together so what happens all
the time
that you have some half solution or some
dead end and the students keep it and
that changes the problem and then when
they finally put together it has whole
history of problem solving so yeah at
this point I I had to think about
problem solving again and here is the
book and here everyone knows this book
because five years ago which told you to
buy it
immediately after his talk ok so I can
rely on this fact then this book is is
well known and and luckily it is it is a
book about heuristics in Mathematica
thematical problem solving and most
ideas translate quite easily especially
for this scenario when I use a
functional programming language to solve
little sort of mathematical puzzles so
well yeah in the process of of the
semester I I produce this document I
will give the link later and I even try
to reproduce the typography of the old
book but of course the current the
actual advices are especially suited for
for this new functional programming ok
so just to remind you what are the steps
of problem solving first you have to
understand well that's a no-brainer
and it's
you can't really write code if you don't
want if you don't know what you want to
solve but making a planet that's
slightly different for in this situation
I I told the students many times that
you just you just play in the repple
then I realize that actually it's
probably not clear what do I mean by
playing in the redbone okay so I then I
clarify that Oh
once you identify the problem you know
the type of your input and you know the
type of your output and if you don't
know how to start well I'll just just
try a few functions you remember about
dealing with this type of data and then
you know it's just mobilizing in
information about mobilizing knowledge
okay and well once you know what to do
you just carry out the plan and there's
a loop of writing testing and it's most
important looking back because that's an
instinct you know the correct answer
appears on the screen and the students
is oh okay
solved we can move on and it's it's like
that's where learning start when you
have the solution now you can look at it
how you did that and you can think about
it it more okay but this was one of the
failure points it's like playing in the
in the rapport and I had to think about
it and listen to other professionals
holiday use it and it seems that okay so
once you have the repple and the editor
the beginners workflow is is different
compared to the professional one the the
beginner you know they try to figure out
the solution in the rapper and then oh
there's something useful they copy it to
the editor just to keep it why the
professional you know as you know where
you are heading
you just want to check whether your
candidate solution for a particular
problem it's good or not so here's what
happened first we just started with the
rapper I mean this was a choice by
students probably noise colors and of
course the available documentation and
we used it happily
for a couple of weeks then I realized
that the students started copying the
solutions into well you know a word
processor which is probably the worst
thing that could happen to a piece of
code because it's very bad okay so but
luckily just slightly before then
rappeling came up with a closure support
and I thought that okay this is great
this is this is what we need here
because what they can see save their
solutions and they can send it to me and
they can bring it as a homework
assignment and it looked good except
that what I saw that the students
immediately gave up the rap oh okay they
went to the editor and I had to tell
them many times then look I mean you
can't do it we can't do it it's like
just writing the code and figuring out
the solution without checking the pieces
it's very difficult so I always said
that well try it in the report write in
the wrapper and one thing is that
probably it was due to the interface a
little bit is that they just have a
single bottom for evaluating everything
okay so it's not like that you put
pieces there and well that caused a bit
of trouble as well and well that's
probably due to a reason that rappeling
support many language is not just
closure okay a few words about the
documentation well you know the inline
documentation is great but it's it's
probably geared towards professionals
and students use closure dogs quite a
lot and it's very useful but simple and
advanced examples there they are just
totally makes in no particular order and
that caused a bit of a problem
and while the weird characters go and it
came out while it was posted on and
closer at all and the students cheered
it's like wow that's totally awesome
unfortunately we have to deal with the
stackoverflow effect and so that means
that the students just searches it finds
the solution and copies it there and
that's okay I mean if we do this all the
time but in the learning setup this is
really not what we want because at least
two solutions but not understanding okay
so it's like typical case student shows
well here's the solution and it's like
okay oh you are using these threading
macros and of course I haven't mentioned
threading macros yeah and there's no
understanding but okay another thing
which is it's still after solving the
problem you want to go back and think
about your solution because we don't
just most of the time we don't just have
a single solution we have several
different solutions so it's better to
think of it as a as a solution space
rather than just a single path and this
was actually a solution for the absolute
value problem and I was glad to see two
different solutions of course if you
think about it these two solutions are
not different because while they do
exactly the same thing it's well of
course it depends how you define being a
different solution okay I need to talk
about what to do in the in the future
and well the course will be offered next
winter and the next spring semester so
it's an ongoing story and on I'm
thinking a lot how to improve the course
well one thing is that well I have to go
from reactive to proactive in a sense
that well when I started this I was
convinced then the functional core of
closure is the ultimate beginner
language okay but that was just my
thinking
you know I could have gotten wrong but
after the the one core so I can say that
well yeah this is this is really great
for beginners and they can get very far
in problem-solving with very little but
of course now I know the pain point and
I can do it more proactively addressing
those and what I normally do in order
other classes that I I have a summit in
the of the course it's not I'm saying
that okay we are heading there and in
algebra that's Euler's equation because
it's just so crazy looking and in
calculus it's the fundamental theorem of
calculus which is again surprising just
integration is inverse derivation and I
think in closer settings that would be
the meta-circular evaluator and that's
probably it's very nice in the liberals
environment as well because it's sort of
a metalinguistic abstraction so I will
aim in an altitude regarding tooling now
I think that I will are the trying I
scored and and poor infer so I didn't
say anything about managing pain
parentheses in in the previous course
and of course eventually it becomes a
problem so now I think that I will try
to address that up front okay so the
summary the question is what is
achievable in in in one semester and all
I can say that map filter and reduce and
the persistent data structures that that
and and that's that's a whole lot so you
can do many things with that and and
also here are the suggestions and that's
not just for for students and teachers
but it's basically for for everyone the
learning process basically never
finishes right so it's a good idea to
maintain a beginner mindset you can
always have a fresh look
the function you use all the time and
probably the best way to do that is that
if you could expose yourself to beginner
thinking by teaching them you should
consider yourself very lucky because
that helps you a lot and again a
metacognition is thinking about your
coding the way you coded of course
improves your coding and and then the
last idea think of a solution space not
just a single solution these scales it's
not just for little mathematical
problems it scares through the big
system you need to consider alternatives
for that ok and for my personal mission
well I mean oh I still don't know why I
like closure that much but I can say
that the love of closure cannot be
destroyed by the construction by trying
to look at the pieces and and breaking
it up into little ones and it's still
like the language and here's the link
for the course material it's of course
being developed and you can if you are
interested only the how to code it part
the heuristics part that's there as well
and thank you very much
I mean oh well I'm happy to take
questions
yeah sure out of 40 no I had three and
one one came immediately and said that
oh yeah I'm doing my working in Scala
and and things like oak what this is
great except that this will be slightly
different and then came the second time
and said that why are we learning this
primitive language and okay it's like
what do you mean by primitive well that
doesn't even have a for loop okay and
it's like at that point you know what
thinking the dependency graph before the
at least comprehension went in the very
end I didn't want to argue about then
and so yeah it's more difficult and
unfortunately well I I found it a bit
sort of sad to see young young people
it's already having very rigid thinking
I like the persistent data structures
I'm not like hashmap and and has certain
how it's used so I don't know scheme
that much but I think I would have a bit
of problem giving that up
yeah a liberal arts college and non non
computer science
I would change a little averages double
check their math background because they
might not have you know functional
functional composition but it wouldn't
change a lot oh sure yeah I mean that's
when I wanted to go from reactive to
proactive now I know it's a pain point I
think about it are they trying to find
the best example so yeah
I before you mean a foreclosure yeah
yeah I'm sure that's what's the starting
point initially I thought the assessment
would be that the students just come
into the class and it's just okay let's
see how far you get in foreclosure but
again a foreclosure and also has
problems that relies on the other
background knowledge so I couldn't do
them but yeah so that was inspiration
um sure as it's done by the university
so I mean the actual numbers are
probably not telling that much but it's
it's more the feedback then what needs
to be done it's like was it fast or was
it slow and you know I still get on the
in the end of the course that is like
why not learning something more useful
like Python okay then it's like okay
maybe I have to rethink how hard would I
was in delivering the message why why
this is cool
I'm using the foreign language yeah I
leaned on that metaphor lon
as for example when I defined death
that's basically sort of light I mean
whenever you want to understand a piece
of coal it's basically it's like reading
a text you want to figure out what's the
meaning of each symbol right and so
that's what I said it's like when you
learn a foreign language you need to
know what the actual meaning of the word
is and and what's the grammatical
structure carries meaning and actually I
do the same it with mathematics on I'm
telling them that well if you learned a
foreign language then you already did a
lot harder task than learning
mathematics because while I'm
mathematics and programming languages
they are designed to have a single
meaning and that's they have to be well
defined and you don't have that in a
natural language and the students like
all they say that Burnett is it's still
difficult so that's the argument yeah I
lose use that a lot as a metaphor well
thank you very much again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>