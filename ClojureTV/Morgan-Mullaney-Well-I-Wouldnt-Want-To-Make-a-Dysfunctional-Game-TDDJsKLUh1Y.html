<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Morgan Mullaney - Well I Wouldn't Want To Make a *Dys*functional Game | Coder Coacher - Coaching Coders</title><meta content="Morgan Mullaney - Well I Wouldn't Want To Make a *Dys*functional Game - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Morgan Mullaney - Well I Wouldn't Want To Make a *Dys*functional Game</b></h2><h5 class="post__date">2015-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TDDJsKLUh1Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the title of my talk is well I wouldn't
want to make a dysfunctional game that's
supposed to be at Alex you know you sort
of expect mark down every word but when
I submitted it to the program actually
you know they they just they just copy
the plain text so I thought I'd roll
with it it kind of looks neat you know
okay so I wouldn't want to make a
dysfunctional game this is going to be
an anthropological exploration of Lisp
and game development so we're going to
ask questions like what kinds of games
have people made in lisp what can we
learn from their experiences how do you
know if someone used lists for a game
don't worry she'll tell you so some of
you might have seen this book before
bye-bye Conrad Barsky the land of lisp
it's a it's a book about how to program
Lisp is sort of fun fundamentally the
idea but it does does that by exploring
writing little toy games there's dopey
know more about that in incomplete and
non comprehensive list of games that use
Lisp ok so there was abuse in 1996 so
you might have played this one thing
that is notable for in gaming circles is
that pioneered the idea of using the
keyboard to control movement and the
mouse to control looking at the same
time what we care about though is a
little bit more technical this game had
the engine written in C++ but the the UI
and game logic we're all in this Lisp
scripting language that they wrote you
can see a little sample of that here at
hopefully that's big enough for you to
see so the way that this is structured
is okay so we're looking at the the HP
up these are this def care macro here
defines a character in the game and
register the set of callbacks to it and
then so when
the the player interacts with that
character in the game world then the
callbacks get called in this case we're
talking about these little hearts right
here these are the the health power-ups
right and so here is your callback it
gets called the the HP up there you test
that it's it's touching and that you can
give the player health and then you know
there you have it the all of the
entities in the game are defined using
the system and and they each have
callback functions that are associated
with them that are written in this
littlest violet so that's sort of need
um I bet some of you have probably heard
of this game crash bandicoot in 1996 and
jack and dexter in 2001 and all of the
sequels of those of course and a neat
thing about these is that first of all
they were written entirely in lists or
were almost entirely um but also the
flavor of lifts that they used was again
totally totally custom totally made
explicitly for this purpose crash
bandicoot series used game oriented
object list and the jak and daxter
series used its predecessor or rather
its successor game oriented assembly
list or a goal so let's take a look at
what that a game oriented assembly Lisp
looks like here you see a little snippet
this is hey again it's a call back
old-fashioned games use lots of
callbacks look at look at this though
they have typed function arguments you
see this right here SP system particle
SP Veck these are all types and then you
see this typical sort of Common Lisp let
binding look at all of these parentheses
aren't we lucky we live in closure land
where you get to use vectors for this
and here's another interesting thing
down here is this art 'let and what that
does is let you write code in assembly
this is where the name comes from game
oriented assembly Lisp you get to write
stuff directly in assembly
when you need that sort of optimization
and this construct here allows you to
guarantee that the values get stored
into a register and then you bind a
symbol to it that you can call call that
you can use from list code so you get
sort of the high-level sort of abstract
view that Lisp gives you and you also
have this very gritty low level control
over over what's going on so this was
this was really neat uh they sort of
invest in this because the the team that
built these games came out of MIT and
they were all very sort of you know
happy happy to use Lisp happy to do
experimental things and it turned out to
work very well for them and pretty much
all of the games that came out of
naughty dog studios used ghoul or goal
until they got bought die sonne and and
Sony put a stop to it as these sort of
big companies do so another game another
game to look at is vendetta online which
again was sort of a sort of a popular
one some of you might have heard of this
in vendetta the the game engine was
written in C++ like the the client code
is all C++ but the server-side npc AI
system was written in common lisp so
here's just a picture of some spaceships
flying around these are what the NPC is
often look like they're these little bug
look and spaceships and one of the
interesting things that they do is that
was encoded in this NPC a our system is
they travel around and swarms through
this through this universe here sorry
you can't see my finger and inside each
of these little dots you have this
little star chart and you can see these
little asteroid belts in there and the
the bugs like to hop around between
those asteroids and a big part of the
game sort of hunting them down trying to
trying to kill them trying to get access
to the asteroids and so this is a you
know huge like MMO game and
so there are thousands and thousands and
thousands of NPC spawns in any given
time and they're all overseen by this
this this big Common Lisp system that
they wrote and that gave you a lot of
really cool things you could connect a
read full on the live AI system and
actually so so I used to play this game
this one has a soft spot in my heart and
sometimes one of the one of the
developers would get online and they'd
just be connected into a ripple on the
server and instead of using the normal
NPC behavior they would they would like
script events they would like play play
Game Master sort of and spawn in pcs and
have them do various things like pick
targets for them that sort of stuff it
was it was really neat I sort of
everyone against the devs kind of a
dogfight environment that you get into
you that way you could easily add new
bots behavior they're all just callbacks
you know callback hell but the the the
sort of cool thing about this is they
have this huge system but all the time
they want they're wanting to add new
NPCs new behavior for those new missions
that you interact with and adding this
new stuff was all very easy just to sort
of pile on top unfortunately the system
became unmaintained ball it just got
huge sort of the original specification
of what deliverator was supposed to do
just kept growing and growing and
growing and it became very brittle and
was breaking all the time and consuming
a tremendous amount of developer
resources just to keep it running so
they re-routed an ER laying recognizing
rightfully so that they had actually
kind of reinvented the actor model of
concurrency so it was a good fit
actually there was there was actually a
big fuss on the forums about this
because there were a number of Lisp
nerds that played this game and they
said they were rewriting an erlang there
were actually a couple of people who
threatened to leave the game
I was not one of them I promise ok so
there's also a chroma shift it's a
little game damn game right it's tiny uh
it was built enclosure script that use
the entity component system architecture
and one of the cool things about this is
it demonstrates how rapidly you can
write write a cute little sort of run
around platformer game and the entity
component system architecture is sort of
something that a lot of modern games use
and sort the same people that worked on
this ended up actually building light
table the editor and they were they're
actually very inspired by the sort of
entity component system architecture and
they have some of you may have seen the
talk about that I don't remember what
they call it but the sort of
architecture inspired by entity
component system adapted for sort of a
user interface more than a than an
actual game okay and then here's one of
my favorites this is this is to Zhang is
how you pronounce that this is written
by David O'Toole who's a huge fan of
Common Lisp again um and he actually
wrote his own game engine thing called
zelfs the to Zhang and a number of his
other games are implemented in so you
know here's here's what the gameplay
looks like it is these very simplistic
graphics it's really quite beautiful I
can't I can't play the sound for you I
don't have any sound connected to this
but the the soundtrack is really really
great and crunchy and you're just this
little robot it runs around and you have
this block and you have to throw it at
these these rectangles of color to
collect color that you can then use to
shoot through the force fields and
disable them you can see see how that's
working so is this this great little
like puzzle roguelike game um zelfs
itself is really neat is it a language
that's mighty it's a library its kind of
actually all of those um it's described
as Emacs for games what it gives you
is right some would argue that emacs for
games is actually just Emacs however I
haven't seen graphics this pretty in an
emacs list before and what self gives
you is the ability to have a ripple that
that actually runs inside of your game
that you don't have to necessarily
connect to sort of you can display your
code alongside of the game can you get a
sort of similar thing to this in my
table actually um and you can sort of
modify components of the game on the fly
as your as you sort of iteratively
developing it it's a it's a really neat
system it's all common lisp and it's
it's I don't know that anyone uses it
other than the author I've sort of poked
her hand with a little bit that's not
necessarily to say that it's it's not
usable but it's it's perhaps a little
bit arcane um so a big problem with with
making games is that a lot of times you
want to draw graphics they're sort of
the majority of things that you think of
as computer games have graphics
associated with them in fact sometimes
you call them video games and there are
a number of philosophies about this you
can get really down to the metal use
OpenGL there are some thought leaders
that highly recommend this approach and
in fact one of them wrote a blog post
about it one called penumbra there's the
sdl abstraction the simple direct media
layer which is a little bit higher level
that gives you things like sound along
with your video and their bindings to
that both in enclosure and common lisp
these are still super procedural and
you're mutating state all over the place
it's pretty gross um too bad this is
what you get for interfacing with real
hardware but you can hang a pretty
picture in front of it and and maybe
what that would look like is something
like this
um what you want to do is is just
abstract those away hide them hide them
in in some dark corner of your game and
never interact with them directly so if
this was true anthropological piece we
wouldn't really be very judgmental about
it but um I like being judgmental
actually so I I feel like this the sort
of exploration of the history of game
development list has taught me a few
things lisps are really easy to write a
very common thing to do a very common
theme across all of these is actually
just making your own language make your
own dialect of lisp to write the game in
that's sort of tailored to exactly what
you need goole does this goal does this
zelfs is sort of another sort of step in
that direction it might be more feasible
if you're a big game development company
however David O'Toole's just one person
he did it you know you can you can too
um use an entity component system it's
it's very elegant you can sort of
iterate on things very quickly you can
get a working product very quickly and
it's it's very easy to sort of modify
things and iterate on that embed a
triple everyone does this it's amazing
if you have a live repple inside of your
game and can modify things on the fly it
that just reduces the turnaround time
between noticing something that you want
to be different and actually making it
so and of course you know this from sort
of developing software that is not games
right but this holds so true in games
where you want to do things like wine on
the job just right so that the the
player has to jump at exactly the right
time in order to get on the platform but
you want to make sure that the platform
is close enough that they can get to it
or or to dodge a spike trap or whatever
and having a rebel plugged into your
game so that you can just modify that on
the fly and and try it over and over and
over again until you get the feel
exactly right is just invaluable I can't
really describe how much that helps in
game development versus you know the old
model of write C++ compile it wait for a
while come back
run run your game see what changed so
that's all I've got does anyone have any
questions good I answer them all okay
it's hard to say because people don't
usually talk about it until it's out
it's so proprietary you know however
there's there's a few answers to that
question so um David O'Toole's games are
all open source so you sort of know what
he's working on right and he has a much
grander game written in self that is
sort of a one of these like 4x space
exploration games and you'll be sort of
flying around a little spaceship and
going to planets and collecting
resources and fighting aliens and that
sort of thing and you know there's
there's there's a thousand different
sort of little indie game developers if
like how many how many people in this
room have toyed with writing a game in
any sort of Lisp dialect yeah there you
go so so what's happening you know and
if you sort of limit your search to big
fancy triple-a studios then you won't
find much because they tend to be very
very reactionary and very sort of locked
down about the technologies that they're
willing to use but if you look in the
the sort of indie game development
community it's really flourishing any
other questions
we've all heard that one yeah totally um
well a few things so first of all with
modern computers performance doesn't
matter that's that's true in the rest of
the world right and that's that's
totally true in games to you except it
does sort of matter right but it but
what matters is getting your algorithms
right making sure that you don't have
any pathological loops that that are
just running in like grossly exponential
time or something like that but the
other thing is that there are libraries
to interface with the the parts of the
code that need to be the most performant
the the graphics layer the the rendering
and stuff like that and it really is
okay for that not to be written in list
while most of the game still is in fact
if you use an off-the-shelf library like
list builder sdl for for common lisp or
if you use a play closure for closure
you really don't have to think about
that at all and you still get all the
performance benefits of using C++ or
Java respectively
tune in next year all right thanks
everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>