<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Becoming Omniscient with Sayid - Bill Piel | Coder Coacher - Coaching Coders</title><meta content="Becoming Omniscient with Sayid - Bill Piel - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Becoming Omniscient with Sayid - Bill Piel</b></h2><h5 class="post__date">2016-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ipDhvd1NsmE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon I'm here to tell you
about Sayid debugging and profiling tool
that I wrote for closure
all right bit about myself my name is
Bill Peele
I'm born I was born raised and I'm
living in the Philadelphia area I've
been programming for a while
professionally for the last 15 years or
so doing closure for about for now I'm
working in the analytics division of
Magento via a very recent acquisition of
my previous employer
RJ metrics and my face looks like that
before I tell you anything else about
Syed I want to emphasize the hugeness of
the impact that it's had on my life it's
probably less than say like having kids
but more than getting a pet like a dog
or fish or something like that because I
write closure almost every day and every
one of those days I am using Sayid
so it's become an indispensable tool for
me for the better yeah all right so what
was the problem why did I feel the need
for Sayid well I do love closure a lot
like a lot I think its interactive
development style does a lot to ease the
debugging process but I was still left
unsatisfied by some things especially I
think a very prevalent debugging
practice that I like to call code
sprinkling
many times after an intense bug hunt I
would step back and look at my code and
see what I had done to it it was
disturbing the reprint lines and deaths
all over the place sometimes like little
wacky things stuck into threading macro
expressions try to figure out what's
going on in there
I felt like I was doing something wrong
and if you are not doing something like
this and you do like what you're doing
drop me a line because I want to know
what people are doing out there to solve
this kind of thing another tool that you
might be using is a step through
debugger Snyder has one I think cursive
has one and maybe that's the gold
standard of debugging not for me at
least there's something different that I
wanted all right so it was about a year
ago that I decided it was time for
action and I started writing the first
lines of code of what eventually became
Sayid now here's my big pitch Sayid can
largely replace these other tools and
techniques that I've described
I hardly ever sprinkle anymore and I
hope to sprinkle even less in the future
all right so when I got started I had
some questions that I wanted to ask
myself like what am I trying to do and
has it been done before and does it have
a name I did some research and there
were some relevant terms things like
reverse debugger historical debugger
even time-traveling debugger but my
favorite of course was a mission
debugger omniscient debugging is
debugging with full knowledge of what's
going on in your code like all the
function calls all the arguments all the
return values all that stuff that is
what I wanted and like has it been done
before of course everything's been done
before but it didn't seem like it was
being done very often so I turned to
Google to see what was going on out
there so here's a chart
showing three different search terms
than the Google Start frequency first in
blue is the omniscient debugger which
had a little bit activity in 2004 and
it's just been dropping off since then
today I think it's like me and three
other people that look for it
next I've intellitrace which seems like
it was the most recent kind of major
product offering in this area it was a
feature that Microsoft included in
Visual Studio 2010 and can you see you
can see there was a spike of activity
back then but interests they're also
kind of dropped off quickly and searches
for rich Hickey are about to help pace
it right around now so go rich but
despite the apparent lack of popularity
of omniscient debugging I decided to
press on and see if I was crazy or just
severely misguided there was one tool I
wanted to mention that I discovered
along the way is a closure tools trace
by Stewart Sierra closure tools trace is
pretty cool it captures execution
activity at the omniscient level and
then prints it out kind of like a log so
like the core technical like idea was
there but I saw a lot more potential
anyway the first first lines of code
that I wrote for Sayid were completely
inspired by closure tools trace so
thanks Stewart
alright so that's the background I have
developed a highly contrived example
application for demonstration purposes
it's pretty simple it relies on some
libraries like composure and liberator
to expose simple HTTP API and I'm going
to use it to demonstrate like two
different contexts that you can use cite
through one is executing your code
through a test and the other is
executing it through an HTTP request and
I'll be using Carl for that the book
closure for the brave and true used
a hotdog vending machine as an example
in one of its chapters I like that model
a lot because vending machines are just
complex enough that they're interesting
and most people know how a vending
machine is supposed to work but I wanted
to be a little bit original so I went
with a taco vending machine so that's
the example application we'll be looking
at all right so it was very concerned
that I was going to get up here and
forget what I was trying to do so I put
together this demo checklist for us all
right
we are gonna look at all these things
we're gonna look at how to get set up to
use Syene briefly tracing a namespace
with Sayid we'll execute a test we'll
view and query the resulting trace tree
that we've captured we're gonna look at
the magical although a little bit buggy
inner trace feature then we're gonna do
bug we're probably going to fix a bug I
think I'll switch over to using curl and
yeah then we'll look at Syed's pretty
print buffer feature do a little bit
more debugging and finally we'll track
down some slow code using Syed's
profiler alright it's harder to type in
front of hundreds of people all right so
if you use line you're probably familiar
with profiles clj or you might be this
is a this is mine it's pretty light
doesn't have a lot going on the
important thing is I have two plugins
one is cider and ripple which Sayid
relies upon and the other is Sayid
itself the plugin is doing two things
first
it's injecting a dependency on the Sayid
library itself which is critical and
second it's injecting the N rubber
middleware which is necessary if you're
using the Emacs integration which is
what I'm going to be demonstrating
although technically you can use site
completely just from the from the repple
which means you wouldn't need the
middle where in that case all right so
here's our test this is the initial
state of our taco vending machine
we've got tacos we've got ten tacos
loaded in here
they cost eighty five cents each and we
can go down here all right
go down here and here is our test we
take our test vending machine and we're
gonna insert a series of coins
we got quarter dime nickel and penny
totaling to 41 cents then we press the
taco button now and you insert 41 cents
and press the taco button and tacos cost
85 cents you should not expect a taco
but let's see what happens but before I
run the test I don't want to forget the
thing that I always forget to do when
I'm doing practicing this which is to
use Syed's to trace the namespaces so
here yeah you can see the bottom right
using like a wild card and we're just
tracing all of the name spaces in our
contrived example application all right
so when when I trace these namespaces
Sayid pops up a nice little buffer for
us which details all the namespaces that
have been traced as well as the number
of function VARs in each one that have
been traced and you can even like drill
in and see like okay here's all the
functions and that namespace and just
feel pretty good about the situation all
right so we got the traces in place
let's run this test Oh test failed
that's too bad I wonder what happened
might be a bug yep didn't see that
coming there's a bug in this code but
yeah what's the bug oh we got back a
taco which we didn't want and also we
got some change to quarters a nickel so
yeah that's a bug but that's okay
because we have a great debugger
at our disposal all right so did Sayid
do anything for us at this point yes
here we go i what is this thing I'll
tell you this is everything that Syed
captured this is the trace tree as
visualized by Syed I'm gonna zoom out or
quick just show you that uh it's big
it's not that big it's big enough
go big all right and each node in this
trace tree represents a call to a
function and we're looking at a summary
view so each note is just showing the
name of the function but in fact we do
have more details so I can drill into
just the call to press button and see
here press button was called with two
arguments there machine and button and
you've got the values that were passed
in nicely pretty printed out for us and
finally also the return value you can
see the return value here has the 2/4
and the nickel the taco which agrees
with the bad test results we got before
all right so oh yeah the colors and
indenting right that's how Syed
represents kind of like the hierarchy of
the tree so press button for example
made a call to valid selection valid
selection called get selection and you
can see how like that's nested I so now
we're gonna do let's try to debug we
made those calls to insert coin that
doesn't look especially interesting but
when we hit press button all sorts of
things happen so we're gonna drill into
that Sayid has gives you some capability
to query the trace tree and I'll give
you a little bit more detail on that
later but suffice to say we're gonna
look at the details for press button and
all the function calls that occurred
below that there we go so yeah there's
press button which we just saw makes a
call to valid selection which makes a
call to get selection now I'm going to
soon a little bit of programmers
intuition and notice that
this doesn't seem right when we call cow
coin value passing into four coins which
we said we're worth 41 cents but it's
returning a dollar 40 that seems like
pretty suspicious so we use Sayid to
just jump to that function and there's
the definition the cow coin value cool
all right now check out this feature so
I use a feature where it kind of
attempts to encapsulate like a given
instance of a call to a function and the
way that works is hit a button takes us
back over here and I'll show you what
it's done it took the arguments that
were being passed in the cow coin value
stuck them in VARs in a small in a var
in a var in a special namespace like so
if we evaluate coins one there's the
coins that we'd passed in and you can
eval the whole expression and see a
dollar forty so this can be pretty
useful when you've narrowed it down to
the point where you're looking at a
specific function and you want it kind
of like iterated on iterate on it and
get the behavior right or something
along those lines yep dollar forty all
right right next I was gonna show you
the inner trace feature which sometimes
breaks but shouldn't because this has
been very carefully prepared so the
inner trace feature works kind of like
the normal trace feature except instead
of being at the function level it's at
the expression level so it's looking at
all the values that are being passed
into the expression and as well as the
final value of what the expression
itself evaluates to and we'll turn that
on and again we get the the free spot
for popping up and we can see like here
there's that the cow coin value function
that's now does the special inner trace
on it I'm going to clear our log
and we will run the test again I we
still get failure which we expected but
now should be something different there
we go so it queried for all the calls to
that function and now I can look at just
the one instance here now we're looking
at the what was going on in calc point
value except now it's at the expression
level so we've got the threading macro
returning a dollar 40 next we're
applying plus also returns a dollar 40
and then we finally get into a little
bit more detail something interesting
when we make that call to keep coin
values coins and looking through here we
see the value of quarter dime nickel
penny penny is one as in like one dollar
not one cent so that's looking like it
could be a bug again Sayid will just
jump us to that line of code and if we
look at coin values here which is
conveniently defined right above the
function yep there's penny it's one
let's change that to a cent okay we did
that now we can revolve or t1 cents so
that's a pretty good sign that we fix
something we can go back to the test
test passed all right we debug
I've never gotten applause for debugging
before so I really appreciate that my
boss never does that
all right cool all right so what uh
let's let's review what did we do yeah
we looked at how to get things set up
quickly we traced we executed reviewed
and queried the trace tree inter trace
work that was good
and then we found a bug as promised all
right so let's switch over to curling
our application I'm going to what am I
gonna do I'm gonna clear the log trace
log start fresh
oh I know I got to clear that inner
trace as well I don't want to mess that
up okay cleared everything out retrace
all the namespaces cool all right so
here's our request we are hitting the
we're hitting the taco endpoint we're
inserting four quarters and again
pressing the taco button four quarters
is a dollar so now we should get that
taco but we didn't know acceptable
resource available so that's some kind
of crazy HTTP API thing right so this
time what site you captured was a much
less it got us to as far as like our
Liberator resource we can drill into
that and there is a ring request which
is nice and we can see we did get a four
or six no acceptable resource available
but this actually does not give us a lot
to go on and you might wonder what are
our options at this point well I'll tell
you because we have them Syed allows you
to trace like any namespaces that are
available not just ones that are yours
like you know that you have the code to
so what we can do
is we can't race in the liberator and
there's the there's our trace buffer
again and we got some Liberator
namespaces in there great we're all set
up
run Karl again same response but this
time mm all right
it's a linear map real quick
look how much bigger it is liberator
does a lot that's crazy
and we don't want to have to step
through all that if we don't need to and
we don't need to that's great
Sayid has a feature called views which
lets you like configure or customize
which data is coming back when do you
view a trace so if there's certain like
a certain piece of code or library that
you're working with on a regular basis
it might benefit you to set up a view I
happen to have set up one for Liberator
for us there we go and now I can turn
that on and what are we seeing now all
right now we're just seeing calls to
liberators to side function which is
what we want and you can see it's just
showing us the name of the decision and
the return value which is four sixes all
the way down so we can step through here
and see like how far down the decision
tree did we get now we got this far last
decision last decision that we made was
language available so that's where
things went wrong so now we've got some
kind of clue we can go to or liberate a
resource and see what was our
configuration well we set up languages
and turns out the only available
language is Spanish and if you look at
our current request
huh we only accept English so this is a
spanish-speaking taco vending machine
and we're trying to speak English do it
maybe that's the bug Dada taco muy bien
this is going okay all right what else
are we gonna do oh yeah pretty print
buffer let's do that so the pretty print
I'm going to run this again for fun oh
this is where I always screw up don't do
it one more time there's um there's a
awesome thing that I do sometimes where
I accidentally try to dump all the
details from the trace and it's too much
and locks up the VM for a while and then
I stand here and I'm embarrassed but uh
I'm not gonna do that today okay so
let's go in here again so this is that
same call to the Liberator resource and
we're passing in this very large ring
request it's big enough that Sayid has
truncated it for us
because it doesn't want to you know
doesn't want to overwhelm us and when
that happens if you want to get more
detail on what was captured you can go
into the pretty print buffer hit a
button so now we're just looking at that
ring request and see it's not getting
truncate anymore
and this is useful because there's some
things like there you can navigate
through it in kind of like a sane way if
you want using like navigation keys you
can go like through the levels and
siblings and whatnot parent-child that
whole thing but my favorite feature is
that say
you were in a big structure like this
which happens to me a lot enclosure and
you find some value and you want to know
where in the structure is that value
exactly so I've located this third
quarter which I'm interested in and hit
a button and now at the bottom you see
body insert coins - that is the path
that you could pass to like get in for
example to find that third quarter that
we were looking for so that's helped me
out a lot of times last one okay so
we're pretty prayer and we debugged
profiling let's do that so okay the
profiler is not integrated with Emacs so
we're gonna be using the ruble for that
but that's okay what am i doing so I'm
calling profile analyze the workspace
which is the trace tree and then I'm
gonna zoom out you might not be able to
read this but they should get a feel for
it
so here's a table these are all the
function calls that were in our trace
tree and it's sorted by a metric that
I'm calling net time some net time some
is the metric that I think you actually
want to look at when you're doing
profiling and what it is is like the net
time sum for a function is all the time
that was spent in a function - the time
that was spent in calls to other
functions that were called so I think
that gives you like the best kind of
indication of where time is actually
getting spent when you execute your code
and for example here by far the biggest
net time sum is coming from a function
called slowpoke
so that's suspicious already
and it's a zoom in okay so we look at
slowpoke here yeah it's just calling
thread sleep 50 which is not efficient
now just as example try to explain what
I was talking about with net time some
there's another function called
questionable all it does is call
slowpoke so you could imagine that a
profiler might say like okay we're
spending a lot of time in questionable
but that's not actually interesting to
us because all the time being spent in
questionable is actually being spent in
slowpoke
so Sayid marked slowpoke as the slowpoke
in questionable it says that's fine
alright where are we yes all right may
it through the checklist success okay so
I showed you how we can query the trace
tree before and I wanted to give just
like a little bit more detail on that
let's pretend that this unrealistically
balanced tree is our trace tree
Sayid actually has a really powerful
interface for querying this although
only a subset of it has been integrated
into Emacs so far it's a good subset so
that's fine two things that you can do
are query for all the calls to a
function or a specific instance of a
call to a function so for example here
I've highlighted let's say this is an
instance that we're interested in you
can also modify the query to do things
like show me that instance plus all of
its ancestors or that instance and all
of its descendants or both you can
further modify it and get and limit the
number of generations that you're
looking at so here's that instance of a
call and its immediate ancestors and
descendants as I said you can also get
all the calls to a function so let's
pretend that's what this is and those
same modifiers are available to you so
you can do this kind of thing
which is useful sometimes when you're
debugging a lot of what makes closure
special got leveraged in the making of
site this is a long list I'm going to go
through it in some more detail
immutability and structural sharing do a
lot to improve the memory usage
efficiency of Sayyid in another language
that relied heavily on mutable objects
it would be necessary to clone
everything as it got captured so that
you could be sure it hadn't changed when
you later went to view or query for it
that would be costly but with closures
immutable values you can capture them be
pretty sure they're not changing on you
now I'm going to attempt to explain my
very simple understanding of structural
sharing and why I believe it benefits
Syed here we've got two trees the yellow
one on the left or the only one on the
right yellow one on the right and the
blue one on the left are the same except
the yellow one has one additional
element added to it now these are
supposed to represent like values that
Syed is captured so like persistent data
structure there's like a vector and the
yellow ones got one additional element
and as I understand it you might
represent the memory usage of these two
something like this where the green
nodes represent reused nose or like
shared memory now you can imagine if
Syed
when Syed captures a larger data
structure as it passes through like a
series of functions that there'd be many
more green nodes and those savings would
really add up all right
when cyi
traces a function it finds that
functions bar it takes the original
function wraps it up and then changes
the route binding in order to replace
that original function now the original
function gets stuck on the metadata of
the bar which makes it very easy for Sai
to like trace and untraced any given
functions bar this is my tricky slide
when um when a traced function gets
called Sayid looks at a dynamically
scoped VAR for an atom to write trace
data to now this map up here in the top
left represents like a simplified
version of that trace data we've traced
and executed a function called func 1 we
captured its name it gets children Adam
and this children Adam will have trace
data written to it whenever func one
makes calls to other traced functions so
we capture the arguments going into func
1 func 1 then makes a call to func - and
this is when we start writing to func
one's children Adam func - gets its own
children Adam we capture its args we
capture its return value func 1 then
makes a call to func 3 that same process
plays out finally funk 1 completes and
we capture its return value so this is
how Sayid goes about building a its
trace tree I'm going to talk a little
bit just briefly about the inner trace
feature as I said it's like a little bit
buggy and it's it's just kind of nuts
but I'll mention it the the key thing
that the key feature of closure that the
inner trace feature leverages is the
ability to eval source code on the fly
and the reason it does that is here's a
ridiculously simple function right so
even something as simple as this when
inner trace gets its hands on it it
turns it into this now so yeah no wonder
it's buggy right like this is crazy
don't worry about the details but it
suffice to say it generates this source
code and evaluates it and replaces the
original function and this is what goes
about tracing every single like the call
to every individual expression all right
Sayid has some limitations and problems
there's a real there's a reason why it's
still an alpha
probably the biggest problem is the
bigness problem which is because Syed
allows you to capture so much
information you have to be very careful
you have to give some thought to what
you're tracing which namespaces and once
you have those traces in place you have
to think about what you're executing
during that time because you can
definitely capture enough to just blow
up your JVM don't use this in production
and even if you do manage to capture all
this information it might be difficult
it might be slow or impossible to view
the resulting trace or query it so fair
warning other limitations dynamic the
state of dynamic VARs and mutable x'
that get referenced by a function those
don't get captured at the time multi
methods like technically they work this
supports a little bit messy and yeah
finally as I mentioned inner trace is a
not especially reliable it breaks a lot
especially if if your function has a
recur in it that's right out all right
so what does the future hold
I'm not done with Syed even though I use
it every day it is definitely alpha and
it's really great that Syed has
benefited me so much but it would be
even better if it helped anybody else
besides just me so with that in mind
Syed is open source under the Apache 2
license I've got it up on github PRS and
issues are welcome of course I'm very
interested in getting more editor
integrations especially then all my
co-workers use vim and they use this as
an excuse to not use Syed and I want to
take that excuse away from them
now I'm an Emacs guy I don't know
anything about about BIM so I'm not
gonna write this plug-in myself but if
somebody else is interested in doing it
I would provide whatever kind of support
or documentation would be helpful to you
personally I've got a few things in my
roadmap this the Emacs package is not on
melba yet I should do that it's just
like on my own personal repo it's kind
of ridiculous I want to fix inner
tracing so it doesn't blow up so much
and oh and a faster Emacs I want to
speed up the Emacs integration when as I
said when you're trace is pretty big
getting all that information over to
Emacs can sometimes be prohibitively
slow i time out every day and i want to
see if there's a way to improve that
alright so that is the end I hope that
I've convinced anybody to try this thing
out and I hope you enjoy the rest of the
conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>