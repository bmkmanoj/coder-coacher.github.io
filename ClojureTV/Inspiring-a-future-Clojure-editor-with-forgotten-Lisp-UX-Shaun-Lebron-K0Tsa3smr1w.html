<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Inspiring a future Clojure editor with forgotten Lisp UX - Shaun Lebron | Coder Coacher - Coaching Coders</title><meta content="Inspiring a future Clojure editor with forgotten Lisp UX - Shaun Lebron - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Inspiring a future Clojure editor with forgotten Lisp UX - Shaun Lebron</b></h2><h5 class="post__date">2017-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/K0Tsa3smr1w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello my name is Sean I'm from Houston
and I'm here to try to inspire you about
what a future closure editor might look
like by looking to the past particularly
I want to look through the lens of the
perception problem of parentheses I know
that Ridge said in his previous talk
that this is just a problem with
programmers I'm I sort of agree with
them but as somebody who comes from a
design from a background of game design
I feel like if there are experiences
that can get people past that problem
then it won't be a problem anymore and
people will start understanding the
value proposition of closure and lisps
in general so I'm going to first talk
about what that perception problem is
then I'm going to talk about the history
of what people have tried to do to solve
this problem and then at the last half
of the talk I'm just going to jump into
a demo and show you guys what what tools
that I've developed to try to to try to
fix this problem this is a four
dimensional tesseract it's conceptually
simple but it's visually jarring right
like how so what kind of experiences can
we use to sort of learn this complicated
thing and sort of get over our fear of
that there these are scenes from games
and movies these different things that
have gotten me over sort of my fear of
the fourth dimension you have these
things that are aesthetics you have good
explanations but then you also have
these interactions that you can just
jump into to learn about what these
things are so it's these types of
experiences that I'm after so this is
this is how I see lists code and I think
how a lot of newcomers view it it's it's
this complicated thing that appears to
be jarring even though it's conceptually
simple so what what can we do about this
so we know we know that this year is the
10th anniversary of closure but this is
also the 50th anniversary of the very
first Lisp structure editor
there's a lot of history in here but I
want to give you sort of an animated
tour of my favorite parts of it
that that I think have really
interesting innovations around sort of
solving this problem that I'm that I
want to show you I've made little
animated versions of these different
editors and I made them to be
interactive they're not interactive here
but I would like to publish this soon
so I'll you can check this link and sort
of follow that so in 1967 there was this
thing called the BB list editor these
three different views are the command
the focus in the context you cannot
actually see the context when you're
editing obviously because this is a
thing that you're looking at through a
teletype printer you would type in a
command and it would show you one
expression at a time so this is how you
were able to focus into this really long
expressions in these single line
environments so once you're at an
expression you could just type in a
number to drill down into a child and
then press P to print it out and all the
commands were sort of based on these on
this principle of just typing in the
numbers to target the arguments here you
can just kind of explore it by clicking
on the child instead of typing the
numbers that's just a visual aid out of
Finland this guy named Tim Naoko
actually tried to take this idea and to
extend it onto a display to sort of what
would this look like on a line based
editor so rather than displaying a
expression on a single line he would
display each of the child expressions on
their own line and then from there you
could actually move the arrow keys up
and down to select a child instead of
having the type of the numbers and an
Ida benefit is you could actually modify
the expressions on a line
so again you're not seeing the context
in this editor but you can actually
press P to pretty print to move between
these different views like the list
based view and then the pretty printed
view
um so in 1980 zmax this was I suppose
one of the versions of Emacs from that
time it was the first one to actually
highlight the matching parens next to a
cursor it's a staple feature of all Lisp
editors today but to me it was a way to
apply that concept of focus that we saw
in the previous two and in an
environment that didn't allow you to see
one expression at a time so there their
approach to showing the focus is just by
highlighting the parentheses which is
what we all take for granted today
another innovation that they created
that we're all familiar with as well
was to apply structure editing commands
to the text editor so what you're
looking at right now is the first
structure based editing commands for a
text editor this one is obscure this is
1984 I was going through a mailing list
and somebody was raving about how cool
this was and not many people knew about
it and the it there are no surviving
images or ways to run this thing so I
reconstructed it based on what I was
reading from these manuals and what it
was is it's I love to describe it as a
fisheye view of your code so on the left
is what you would see it allows you to
see the focus and the context around
that focus but the context would be
compressed in such a way that things
that were further away would be sort of
compressed in your periphery so you
would always have these breadcrumbs of
where you are in the function by just
using the first token in each of the
ancestor lists at the bottom you can
type in commands and even insert text
that way
so now we go to the legendary research
center of Xerox PARC and the first guys
who made the BBN Lisp editor that I
showed you first in 1967 they went to
Palo Alto and they started building out
the system called inter Lisp and Inter
Lisp was the first one to have sort of
this visual clickable structure editor
well it was interesting about this is
that you cannot you cannot actually edit
in line but you can click to select
these expressions and the current
expression will be solid lined the
previous expression would be dotted
lined and those who represent the two
arguments in the in any kind of
operation you can do so for example if I
wanted to insert an expression from this
function and paste it into another
expression I would click one of them
click the other and then press after so
there were these click based commands to
manipulate your code it's something cool
at the bottom in the Edit buffer you
could actually put in an expression and
then it would immediately become
clickable after you press enter so that
you can insert expressions that way
and the last editor I want to talk about
is the first one that I found because I
found it referenced and a part at it
read me so this was the one that sort of
inspired the thing that everybody uses
today this structure editor
sort of looks like a regular text editor
and it borrows a lot of the same ideas
but it deprecated the previous display
editor it uses this really interesting
mouse language to constrain what you can
do but it made hotkey commands less
necessary because it was because it
added a mouse language that allowed you
to select sequences of things in a way
that made it safe to copy and paste
these are details that you can read
about in my research that I'll link you
to
this next one is not an editor but it's
like an interesting idea that I found in
a 2001 paper
I immediately scoffed at it but like it
just eventually started growing on me
I unless we like to put parentheses at
the end of a function but and see like
languages people just like that vertical
alignment so you just put it under the
open paren so you can vertically align
those his proposal is to just put them
on the same line so this they said that
they align with the open parens without
wasting the lines so you're probably
wondering like this wouldn't work and
that's because in closure if you're
using different types of parens you kind
of notice that these things are actually
being reversed so it would work in a
lisp that only has one type of open
print but it doesn't work here because
it actually has to reverse the order of
the prints but it's an interesting
compromise between the vertical
alignment and saving lines and this is
an example they used in his paper
that covers the history of the editors
that I wanted to talk about I want to
talk about what people are doing today
is what we consider the practical
approaches John McCarthy mentioned in
his history list paper from 1979 that
the accidental creation of the
interpreter tended to freeze the form of
the language and kind of made these
mistakes sort of unfixable so he thought
that the cond expression had too much
nesting and I think what he meant was
these things yes these pears these
condition results tend to be can be
logically grouped but they don't really
need to be there because you can just
include it unwrapped and this is what
closure does it sort of reduces the
nesting of parentheses there just by not
wrapping these logical groups together
varying the types of parentheses are
also a good way to reduce how
overwhelming their racket does this by
simply using square brackets so to me
when I think of a callable form I think
of parentheses so if I see something in
parentheses that isn't actually callable
that confuses me
and I feel like a lot of all lists
programs are written this way so there's
some things that are not visually
apparent you kind of have to look at the
context of what it is it's a racket does
this and like before there is still like
this unnecessary depth of parenthesis so
close you're kind of uses of square
brackets but it doesn't make it that
nested so I think this is what people
talk about when they say closure has is
a lisp that has been given a facelift so
it's a good good job rich and people
have found different ways to decorate
these parentheses today obviously you
can highlight the matching paren so you
can see where your foot pointing focus
is since people stop seeing parentheses
over time some like to just dim them and
coloring this is this is a popular one
Lisp works is an IDE that does this by
default just by color coding you can
immediately match and the structure
becomes apparent
and finally filling it kind of makes
sense to color it in some people do this
I saw some old Emacs editors plugins
that do this
and a Hawking I suppose part it is kind
of the first to create this language of
slurping and barfing things smart
friends is something that works outside
of Lisp as well all of these things has
like it have an interesting language
around sort of motion of these
parentheses and how to move them around
so inferring a there are some businesses
where we're starting to infer the
parentheses and old less predators you
could type an incomplete statement and
press ENTER and it would close all this
stuff for you inter lisp had this super
paren it was a square bracket that you
could use to close all the previous open
parens let's see dr. racket allows you
to type an incorrect unmatching and then
it would just automatically say oh you
meant to put this one in so then it'll
like put that in for you and indentation
this is mostly been a like this is
obvious everybody knows that these
prints can be inferred by indentation so
the usual approach is to just throw away
the syntax and try to use one that is
just wide space based but in 2013
somebody tried to do this by pressing
tab to sort of restructure your program
based on indentation so you indent a
line and then the parentheses would move
around but a few years after that I
tried to create a most complete solution
that I'll tell you about so that's the
history and what we do today and I want
to talk about sort of that can what
people are doing to try to to try to
research new solutions and then after
that I'll tell you about what I'm doing
and I categorized these two main
research directions as we're just going
to try to change the notation or we're
going to leave the medium of the text
editor and to try to create something
new completely new
you can barely read this because there
are so many attempts to try to fix the
language of the syntax of Lisp by just
removing parentheses it's been tried
since 1964 you can see here it's so many
this has been a visited so many times
right what I will point to is the
deepest look into this problem that I've
read and that is sweet expressions read
David a wheelers spec on this and you
will learn everything you need to know
about it there were some disagreements
on what like what the syntax should do
to should we cover all cases or should
we just keep the syntax simple so if
you're looking for something that's just
simpler and may not cover a lot of cases
in the perfect way so look at wisp if
you're interested in that and this is
just quickly what they look like without
the parentheses you notice they just
introduce some new syntax
so now we go to changing the medium so
this is something called ISO morph that
is a structural editor it's probably the
most recent one and this is they treat
syntax as font so you can actually
change the syntax and I chose Lisp here
just so you could see what that will
look like in a night just just to show
you that this is nothing new
like they Microsoft tried this with
their visual studio suite back in 1995
and it looked really nice but it was
just cancelled so where do I want to go
in terms of these research directions
I'm interested in the problem of
building the perfect experience to get
people over the problem of parentheses
and just throughout through looking at
this how all these different approaches
have been taken I'm interested in
staying inside of the notation and I'm
interested in staying inside the medium
of the text editor like what can we do
if we just stay inside these things that
everybody is already used to and using
so I want to this is my constraint I
want to stay in these two things so to
me if if I can derive common principles
from all these things that have been
tried and maybe maybe this can give us a
good direction I think we obviously need
to simplify writing be it through
commands or whatever people need a way
to manipulate these parentheses in a way
that's both powerful and natural I think
obviously when people if people want
that vertical alignment in their code
and some way to make make their
structure much more apparent then let's
make that a principle like let's make
structure a parent and the last
principle is elision for focus people
need a way to focus in on what they want
to look at without being overwhelmed by
things in the periphery closure did this
in a very conservative way by just
removing certain types of parentheses
and giving you a visual indication
of the type of something just by the
type of the paren and going to even the
more radical ideas of like fisheye
parentheses but we're really we can just
little this down to two basic problem
two basic principles we want to make
things easier to write but we also want
to make things easier to read so I wrote
something called par and fur it's hard
to pronounce because it's not a word but
but it stands for a parentheses
inference and we're trying to this only
solves half the problem but it's an
important part of the problem where we
should be able to write this stuff much
more easily the other half of the
problem is something I've been thinking
about for a few years like how do we fix
reading while staying inside of our
notation and our medium just real quick
part fur is based on a mathematical core
that allowed me to sort of simplify
things and to to make sure things would
work I established what's called a line
invariant but just so you know that this
is there's a lot of impure parts at the
edges but in the middle is math
and just like visually explain what that
math means to me it's essentially when
you change the parentheses the
indentation should be moved in kind and
likewise if you move the indentation the
parentheses will be moved in kind as
well
so yeah experience is important so let's
just jump into it and see what that
looks like
this is the code that I wrote for all
those visualizations but we can just
jump in you'll notice that these are
just normal expressions small functions
I'm just gonna do some fake things here
and it's it's this is the latest version
of hard for right now so let me let me
just move this let block down and sort
of put at the top level I can just hit
backspace and completely separate it
from that function if I wanted to
comment out this form I'll just use the
ignore form right so I can type I'm
sorry can everyone see this yeah black
on white this could take some time
I hope that's okay
so commenting out this form let's try
that so in the ignore form things are
sort of shifting the way you would
expect because the the parentheses the
indentation is changing so the shape of
your expression should be preserved I'm
not learning any hotkeys to do this so
maybe I want to put that let block back
into that function oh I see I got that
wrong so I can just keep going and now
I'm inside of that form let's see what
else I can do let's say I wanted to use
like I don't know
let FN that can be a problem some
problems happen sometimes
so you just correct the indentation
indentation is something that is very
apparent to us so if it looks wrong you
can just fix it are there any questions
like this is Adam is there anybody here
is Adam yeah any Emacs users mostly them
ok cursive
sorry netcode yeah yeah so hard for
exists for all these editors right now
sublime and sublime sublime uses no
tab space it works for any operation
because all it does is it enforces this
line invariant so no matter what you do
the the result will be the same I was
just deleting there's no hotkeys that
I'm pressing I'm sorry so one part of
this is that the the file has to be
properly formatted in order for this
invariant to work so when you open up
something that's incorrectly formatted
you don't want the structure to be
changed so it's asking you is it okay
for me to like adjust the indentation
like if you're working on a team that
may not be okay so it will ask you first
and if you say no then it'll just turn
off power and further allow you to use
it normally this is a feature of Adam
Adam pardon for did that answer your
question
so part fur exists as a mode for editors
that you can enable with a hotkey but
that was that's it cursive yeah has that
as a mode so yeah so there's like an
indent mode and a paren mode and I'm
trying to like sort of get rid of that
language and just use something so what
you've seen here is something called
smart mode so I didn't tell you about it
because it's you the user shouldn't have
to care about like these details so like
the smart mode is yes it's something
that exists and you can know the name of
it but it it should just work right
yeah
yeah
yeah that's hard to summarize but no
it's a good question so you're saying
I'm sorry could you like routine yeah
yep
yeah
yeah I see what you're saying okay so he
was asking that because parn four will
shift around your expressions in a
certain way as you're typing for example
the lines below it would be shifting
around I believe the question was does
that change the way you see your code
and the way you treat formatting to me
like that this is how I've always kind
of seen the code to sort of have this
relationship between indentation and
structure so because I guess because it
follows my own expectations for what
code should look like and maybe I'll use
this question to sort of address a
broader problem there are many different
types of sort of formatting styles and
Lisp some like sell me for example like
let me just show you here so I'm going
to the next line I'm just going to type
something and notice that paren is just
like being moved automatically so
indentation implies nesting say again
I can try to get creative and do this
yeah we can do this is that better so
the reason why i dim them is because you
don't I mean well it is it is a visual
signal that this stuff is being inferred
for you so that was the purpose of that
design but some people you may not like
that that's actually an a feature that I
could have just changed actually in the
Preferences I just didn't think to do
that they look act actually invisible oh
okay sorry okay
back to the original thing yes there are
different formatting styles but let's
see so there's two space indentation but
some people will want to indent it to
the to the to the first art on the first
line right like notice it's still
respecting that it's not some kind of
aggressive thing that will change the
indentation on you depending on like the
indentation length it's only bound to
these indentation thresholds and this is
something I'm going to cover in the in
the next slide once we're done with this
demo but in terms of like how this
affects the way I see structure in my
program like I don't know it's hard to
answer because I guess I've been using
this for so long that this is just how I
see my code anyway any other questions
before I go back to the slide how am i
doing on time
I don't know it's it's preference for
example I don't use prettier the
JavaScript winter on some of my projects
because it's well it's a human thing to
want to lay out your code in a way and I
don't want this to be in conflict with
it I think winters are great for teams
but that's that's not what I want
partner to be I don't want it to be
restricting I want I still want this to
be a low friction environment as much as
possible to allow this inference I'm
sorry say again I would say that the the
best one is the first one that was made
by Chris it's Adam Horne fur and in
addition to that like the new smart mode
only exists for for Adam right now just
because it's still being in use in
development so Adam is like sort of the
premier environment right now and and
then once we've proven out these ideas
then we poured it to different editors
and another thing like there there are
tab stops that are actually structural
in nature so I can hit tab to go to that
next one because I can infer that
structure and you can move back move
back there etc so pardon fur provides
the information for editors to do this
since indentation is a big part of part
four I wanted that the tab stops to help
you there okay if they're no more no
more questions I'll go to the slides
so we saw how it worked but what I want
to do is to sort of visually explain
what's actually going on so what is
incorrect indentation like what does
that mean well if you try to draw a box
around any kind of expression no matter
how like deep into an action it's in and
you cannot find a way to make that left
edge straight you always have to like
sort of cut a corner around it then
that's that's incorrect what what part
first seems to be incorrect and it seems
to be compatible with everybody's sort
of formatting conventions there are some
small exceptions so there are two ways
to fix these crooked rectangles right
you can just straighten it out or you
can detach the offending part which is
the bottom so this is sort of the two
different modes that you're talking
about earlier and I want to call out
somebody who really helped me on this
problem his name is Ryan dilatory he
sort of maybe this part isn't so
important for you to know in order to
use it but this new smart mode sort of
takes those different principles
allowing you to detach from things that
were on the top and to keep things below
straight so this was this was like a
really important realization that solved
the problem that nobody could solve for
a couple years including myself and on
the left is just a general principle if
this thing is really annoying
if the straightening is kind of getting
in your way because maybe you pasted an
expression in the wrong place and the
indentation is all wrong and you try to
like correct the indentation it's moving
everything below like in a way that's
annoying you that the way to to back out
of that is to just select the expression
and then everything is then everything
is sort of isolated from that lining you
can correct the indentation that way so
again there are like trade offs in the
system but I'm trying to to balance them
out in a way that doesn't introduce
hotkeys
so that's part for this the the other
half of the problem that I'm actively
looking at is is something I want to
call locusts
the stands for Lisp focus which
represents the principle of trying to
help you read this thing while staying
inside of text the syntax and the text
medium I was advised not to show it
because it's a little bit too early but
what I what I do want to tell you is
that it is based on these two principles
that you can sort of visualize here
indentation guides is something that all
editors will show you so it's something
that we can sort of use and par infer to
help you give to give you that vertical
alignment without introducing anything
crazy in code folding is something that
all editors do as well so maybe we can
use that to sort of hide the parentheses
in a way if you don't really need to see
them in that moment and these
parentheses are just the ones that are
being that are being inferred the ones
that you that were dimmed at you didn't
even see and perhaps you really didn't
need to see them but the idea is like we
should not remove them so if you're
copying and pasting this text to
somebody or you're working within a team
they should still be there but the view
can kind of fold them away like we fold
other things that we don't want to see
at the moment so that concludes the
second sabbatical that I've taken to
sort of research this idea if you'd like
to to support the future development of
parn fir and Lukas I've opened a patreon
account here thank you very much for
your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>