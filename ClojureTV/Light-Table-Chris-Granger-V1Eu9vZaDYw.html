<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Light Table - Chris Granger | Coder Coacher - Coaching Coders</title><meta content="Light Table - Chris Granger - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/ClojureTV/">ClojureTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Light Table - Chris Granger</b></h2><h5 class="post__date">2013-01-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V1Eu9vZaDYw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm going to be kind of honest I it
was a little mean to put me first see
I'm from sunny San Francisco
cornea which looks a little like this
right now because out on the west coast
it's currently 6:00 in the morning and I
am NOT a morning person as a matter of
fact all of my clocks look a little
something like this I didn't even know
there was a 6:00 in the morning
and I'm telling you this to give you
fair warning upfront I get a little
sarcastic when I'm tired and so while
many of you probably think you know what
I'm going to talk about today I think
you might actually be a little surprised
my first thought was well this is a
conference I could introduce a new
product right conferences are great
places to do exactly that but this isn't
really that kind of conference this is
the closure cons and the cons is about
sort of deep technical knowledge right
this is about us talking about the
things we use to do work and that is a
very serious thing and so my thought was
if we're going to be serious let's start
with little color-changing men this past
weekend my girlfriend my co-founder and
I set out to save the universe if you
will by building a game in a 48-hour
coding competition and what we came up
with was called chroma shift and it
looked a little something like this
sorry it's a little hard to see but
you're this little tiny guy who changes
color and when you change color you turn
things in the world on and off and so
it's kind of neat about this game is
that it's actually a multiplayer game
where you're both racing to some goal
and as you change colors you actually
affect the other player's world now I
mentioned this was for a coding
competition and that competition is
called the node knockout the rules on
the node knockout are relatively simple
you have 48 hours all digital assets
have to be created in that 48 hours all
the arcs if you have sound all the music
all of that stuff must be created in
that 48 hours past that you basically
have free reign you can build anything
you want so long as it's built on top of
this newfangled
javascript platform everyone's talking
about called node J s and so we entered
this JavaScript competition but there's
nothing in the rules that said you have
to actually write it in JavaScript just
that it needs to run in JavaScript and
so we decided to cheat a little bit and
we use closure script to do all of this
and you may have heard the adage before
bringing a knife to a gunfight well we
decided to bring something with a little
bit more kick to it for those of you who
don't know closure script is a version
of closure that compiles down to
JavaScript and so what that means is we
bring the wonders of macros and
persistent data structures and same
semantics to the otherwise scary and
unpredictable place that is JavaScript
and so we built a game with closure
script
now how many people here show of hands
have actually built a game before
something more than pong because that
can be done in a hundred lines later
when a lot of hands just went down Oh
for those of you who haven't before I
highly recommend you build a game it
turns out that building games requires a
very different way of thinking about
software and it sort of stretches your
mind a little bit on top of that it
actually serves as a fantastic way to
sort of test the edges of performance of
a language and a platform right because
games have to be fast
and when I say fast I mean really really
fast as a matter of fact all of your
logic all of your physics all of your
rendering has to get done in less than
16 milliseconds in order for you to
maintain 60 frames per second that is
not a lot of time as a matter of fact if
you try to iterate over about I think a
thousand to ten thousand items in a siik
you'll hit this by default so here we
are we have this disclosure script or we
have this competition we want to build a
game enclosure script and so the
question comes down to how do you build
a game that feels closure right you
don't want to write something that looks
just like JavaScript you want something
that feels closure
that is still blazingly fast well there
are a few different schools of thought
when it comes to game design sort of
additional one is that you have these
really deep object hierarchies right
because games are traditionally built in
C++ and so oop is the is the way of the
land but it turns out those get really
hairy and they're they're scary things
in the long run because you want to make
some new sort of enemy class and you
have n different base classes for your
enemy and it turns out you end up
overriding everything all the time and
it just ends up being a mess really
really fast it's also not a very closure
II way to build something but there is
another way of going about building a
game engine that I do think fits closure
really really well and that is called a
component entity system engine I think
the easiest way instead of trying to
give you a high-level overview of what
this is is actually the easiest way to
understand is to go through each thing
individually industry enough we're going
to start in the middle because it's by
far the simplest entities are just IDs
right so everything in the game gets
some ID literally a number an integer
right instead of having sort of these
monolithic game objects that you think
about like let's say you wanted to
represent a player you think about all
the things that go into a player well
you would have x position Y position the
angle of rotation his health his walk
speed and other different attributes
that you would have to represent you end
up with these giant objects the notion
here is that instead the only thing you
pass around is this ID and what you want
to do is decompose all of that state
into little tiny reusable pieces sounds
very closure rewrite those little tiny
reusable pieces of state are called
components and what's nice about this is
the the the strategy here is that they
can be reused and so they need to be
single purpose
little tiny bits of state an example of
this would be position and so here's a
little code from the game right we want
to create a component for position it's
going to have an X an x-coordinate a
y-coordinate
a is an angle of rotation wasn't really
important for our game but useful
nonetheless and so we have this little
tiny bit of state representing position
and we would have little tiny bits of
state representing all the other
different things we want in the game
walking and jumping and all these
abilities that you might have as a
player by sort of decomposing this
monolithic object it makes it really
really easy for us to create new things
so let's say for example in our game we
wanted two bad guys one that was really
really fast and walked around and
another one that was slow but jumped
every three seconds well if you were
doing some crazy object-oriented thing
you would probably have to you know
extract some base class that represents
the basic methods that this guy would
have and then override some of them so
that he jumps but in a component entity
system since components when you think
about it an entire entity is nothing
more than a group of these components
all you would have to do is something
like this right so if we wanted a fast
guy we would give him some set of
components in this case he has a
position and he has this Walker
component that gives us speed right and
20 units is apparently really fast and
then you have a jump guy who has you
know similar components but done
slightly differently he has a position
he's a walker and he is a jumper and
he'll jump every three seconds so all
there is to creating something new right
it's an ability to compose these
together very cleanly
well underlying this system is nothing
more when you think about it is nothing
more than some basic data structure that
allows you to map entity IDs to these
groups of components that's all you
really need to keep track of all of this
stuff and that's very very easy to
represent inside of closure all you need
to do is have a map from entity ID to a
vector or a map of these different
little component Maps
if you will so this gives us all the
data we need for our game but we haven't
actually talked about how the game does
anything right this is just sort of what
the game is to do that
we need our last piece and that is the
system it is the logic now unlike in an
object-oriented system where every
single class would be responsible for
you know handling its tick events right
because in a game loop you're constantly
looping over every single thing in the
game what we want here is nice little
bite-sized functions that work over
those components right those components
are kind of like tags for us they let us
know what entities inside of the game
need to react to different things and so
I think the best way to look at a system
is to just be very practical and look at
a real system so we need a component
here and a game isn't very fun if you
don't actually render something to the
screen and so our component is
renderable and as you can see all it
does is it takes a function that you
would use to render and so what our
system needs to do is it needs to go and
look at all of the entities that are
renderable go through each one of them
get the renderable component from it and
call that function right sounds really
straightforward sounds like a simple
function and it is this is what it would
look like you have some renderer which
is just a regular old closure function
and you you know do seek over the
renderable x' so that you you have each
nd entity that's renderable as just
takes an entity and turns it into the
component that is represented by that
type in this case renderable and you
would call that function with the entity
itself so there you have it that's all
it would take to make something
renderable so let's say you add some new
thing to the game and you want it to be
visible on screen all you'd have to do
is add this component right if you add n
you know 20 different things to the game
and you only want half of them to be
renderable you just don't give them the
component that's all there is to it
there's no overriding there's no sort of
crazy class nonsense going on there and
then inside of the game or rather inside
of the game loop what you end up doing
is you just call this renderer function
every single frame right and this all a
function is just saying give me all
entities that are renderable that's all
it takes
make a renderable system so that's great
we now have a way of sort of organizing
our thoughts in our and our code into
something that deals closure e right we
have this component entity system engine
hopefully it's kind of started to set in
a little bit why this might be a good
idea for closure I can't remember
exactly who said this I'm pretty sure it
was at the last cons but this is about
turning the entire game into data right
this is data all the things and when you
think about it that's a great place for
closure to be all we have is some giant
data structure that represents the
entire game at runtime and then we have
these nice little bite-sized functions
that work over that structure data
functions this is the bread and butter
of closure right and what we get as a
result of this kind of like I was saying
is that we get composition and really
really neat in interesting ways it's
trivial for us to change the game even
at runtime and so here's a little
excerpt I guess of the code from the
game itself which is on my github if you
want to go look at it from from an
actual level inside of the game right so
we had some background here it's
renderable it's on the backing layer
because there's this the visual layer
system so you don't cover the player up
when you're rendering things there's a
camera which isn't something that gets
rendered inside of the game but you
wanted to have a position right because
you want it to follow the player around
the the game world and then you have a
player itself which again instead of
some monolithic objects in and of itself
is a bunch of these components all
strung together things like yes he's
renderable but he also has he responds
to keyboard input he has a color
he's animated and standing right by
default and so on and so forth now I
mentioned in composition here this is a
multiplayer game and what's really neat
about how that played out for us is that
in order to implement the other guy all
we had to do was take this little the
set of things and remove some of them
right because fundamentally that other
player needs to respond to the world
much the same way that
the the normal player does but he's not
going to respond to keyboard input and
he might have a couple of other things
involved in there he might respond to
sinking right over over the network and
so supporting multiplayer was relatively
trivial in that regard so great
component entity system engine so this
is a way we're going to build the game
enclosure script or this is the way we
built our game enclosure script but
there's another aspect to this as well
and that is remember it doesn't just
need to be closure II it also needs to
be really fast and when it comes to
closure or closure script closure script
in our case there are a few problems
with this approach that make this kind
of difficult the first is that
components change a lot every single
frame you're going to be you know
changing state inside of the game right
you're going to be getting new positions
you might have new velocity vectors and
so on and so forth
there are so many little because there
are so many little components you're
recreating these all the time the second
thing is that you need to iterate over
these entities because of the way we've
sort of decoupled it hundreds of times
in a single frame right and like I said
you need to do all of this in 16
milliseconds and the sort of the problem
you run into with closure scripts
specifically is seeks can't go that fast
there's just too much overhead with
calling first and all the all of the
functions that go involved with that you
can't iterate over them that quickly the
second thing is persistent collections
are not necessarily too slow to write to
although they are sort of on the edge
here for this but more importantly
they're a GC nightmare in this case
because you're creating thousands of
objects every 16 milliseconds it doesn't
take very long for the JavaScript
garbage collector to freak out go
through some GC pause and you basically
ruined your game fortunately for us
being on top of closer script this isn't
that big of a deal um because we have
access to all of JavaScript and
JavaScript arrays and JavaScript objects
are pretty darn fast they are really
really fast
action
more than fast enough for us to hit our
16 milliseconds but closure script is
closure right it's built on top of the
abstractions we have come to know and
love inside of closure and so it's not
really designed to work over JavaScript
arrays and objects it's if you start
writing this code it ends up looking
pretty nasty it doesn't look like
closure anymore but it is closure and so
we have the benefit of macros they can
come to our rescue here and make this
code look exactly like closure even
though we are working with these arrays
and objects and so sort of to give you
an example of this I'll show you an
example a real system from from the game
itself using this right so when you
change color we need to turn all of the
all the similarly colored things on or
off right so there's this flip active
system and it takes color and and sort
of whether or not it's active and then
what it does is it goes through this
dolf's macro is for do fast right it's
just do seek over a raise nothing fancy
here at all there's a let's see macro
since you're constantly pulling
components out of these entities right I
wrote this little macro that just makes
that really clean for you instead of
constantly writing let you know some
entity as blah over and over again and
then we have exclamation point in
question mark those are just simple
aliases for a set and a get array set
and a rake yet since JavaScript objects
are weird that's all it takes and this
still looks like closure right this
looks like code you would have written
it looks like the example I gave before
more or less so that's awesome
using JavaScript arrays using JavaScript
objects with this component entity
system we've got a game that is not only
fast but is built on the founding
principles of data and Composition
that's exactly where we want to be now
the entire code base for this in that 48
hours ended up being about 2,300 lines
which for closure script is a lot but I
should say
that 500 easily five hundred to a
thousand of those lines are just the
definitions of the game and are sort of
the game levels themselves right and so
when you start thinking about that and
you separate out some of the like the
physics stuff that you would never
rewrite you're probably talking about
having written this entire multiplayer
game for the node knockout and about
seven hundred lines of code I'd call
that pretty good that being said it
wasn't all fun and games while we were
doing it we definitely ran into some
things and even though I've worked with
with closure script a lot I still don't
know what to do with this right you get
these crazy error messages that make
literally no sense whatsoever that are
almost impossible to figure out because
honestly because for whatever reason
sometimes the closure compiler not the G
closure the Google closure compiler will
like take all of your links scuse me
take all of your lines of code and put
it onto one line for awhile there take
like ten lines of code and put it onto a
single line and so you'll have like 20
dot calls in that single line you have
no idea which one of them is not
available to you at that point in time
and it doesn't give you any help for
trying to figure it out that being said
it obviously wasn't that much of a
hindrance we were after all able to
build a game in 48 hours and so that
that speaks really well to not only the
ability for closure scripts to be
performant but also for it to work well
in sort of a pressure situation that you
know not many people have worked with
before so I've been telling you about
this game and many of you may be
wondering well what in the world is he
doing up on stage talking about a game
and not light table uh well there
there's you know we build the game with
light table and we learned a lot doing
that we found out some of the brokenness
is and some of the things we need to fix
in order for this to work a little bit
better but that's not really what ties
this together I have a confession to
make and that is that I haven't really
been doing much closure lately I've kind
of taken to another language and and
actually to make to make Kevin lineup
proud I'll show you a graph as you can
see I'm basically doing almost no
closure now it might come as a shock to
you that I'm instead doing closure
script but what's interesting is I'm
doing all closure script basically and
that means for lighttable to the latest
release of light table is entirely built
with closure script the only bits of
closure that exists are in the lining
and plugin that you use to connect to
projects that's it and the way we manage
to do this is by using a really neat
project that embeds nodejs into chromium
directly and this project is called node
WebKit it's really cool it's R it's
written by these guys out of the Intel
open source Center it's really young it
still got a lot to work on and obviously
we had some issues with it when we
released with the Linux and so on and so
forth but it's a very good way of sort
of essentially giving yourself a
platform to build closure script client
apps on top of and so here I am doing
tons and tons of closure script very
little closure but this isn't the only
thing that links the game to light table
itself it's not just that we built the
game in light table it's not just that
it's all closure script now it turns out
that this sort of component entity
system thing is a pretty good idea not
just for games this actually served as
the inspiration for how all of light
table is now built but light table isn't
a game and so there isn't a loop right
there are events it's just like you
would expect any client application to
be it's an invented sort of system and
so while this component engine works
really well for games it needs to take a
slightly different form when you start
working in a world without that loop and
the way this sort of got implemented
inside of light table is fairly simple
it is a behavior object system as I'm
calling it and again we'll just kind of
go through these and get a sense for
what that
I mean an object is sort of the first
bit here and unlike in a game where
you're going to have lots of these
composable bits of state objects inside
of light table aren't really going to be
very composable in the state sense right
not every object has position and so on
and so forth that doesn really make
sense instead state is just a map right
it's just a map with things like you can
imagine the map for an editor for
instance might be the path to the file
that represents if it is a file sort of
what language it sits in what language
mode it's in and so on and so forth
now everything inside of light table is
an object everything from the background
to the it's kinda hard to see
unfortunately from the background to the
tabs to the editors to the results
windows the command bar everything is an
object what's interesting about that
that means you can easily add and remove
the entirety of light table if you
wanted to fairly trivially and sort of
the way this this plays itself out in
code remember these are just little maps
of state more or less but there's some
special things we need to do so there's
this function that you use to write them
and so this is what an actual object
inside of a light table looks like so
this object is the console that's the
little thing that prints out all your
results for you and it just has some
metadata on top of it so this triggers
thing is just saying there are going to
be events that can be called on this
thing in this case there aren't any but
if there were you would want to document
them here just so you have a good sense
for yourself there's this set of
behaviors and remember these are just
these are just Maps these are just state
and so behaviors are what are going to
give it some some life we'll talk about
that in just a second and the last thing
is all objects have an init function
they can choose to do nothing when
they're initialized and that's fine but
if they do do something whatever they
return is try to be considered their UI
right and so in this case with our
console we just return the console UI so
we have these objects these maps and
these get put into a nice big data
structure for us but we also need a way
for these
these objects to do something and that's
where behaviors come in and a good way
to think about behaviors has just sort
of named event handlers they're kind of
a way of composing reactions to things
and so I think the easiest way to
understand that is just a look at one
and it looks pretty much like what you
would expect you have some behavior and
it give it some name so when you click
something we're going to remove it so we
call it on click remove and there's
remember I said triggers are the sort of
events that get raised on an object and
so the trigger in this case that we're
concerned with is click right so when we
click on something or rather when the
object raises click earlier click is
raised on the object we will have the
following reaction and that reaction is
to call this REM exclamation point
function so this is again just like that
component system this is about turning
everything into data even when something
happens or whether something happens as
an event right if you think about how
events would get would get built or how
event systems work sort of traditionally
you give something an object you say ok
add this event handler to this list of
this nameless list of event handlers and
you're kind of lost at that point if you
wanted to introspect that object and see
oh what things are going to happen when
I click on it you can't really write you
could get a list that says all there are
three functions that are going to get
called but that's it whereas in this
case we've dated it right we can know
exactly what is going to get called when
something happens and so here's how this
plays out in a real object so this is
the notifier object the little thing
that shows up in the bottom right hand
side of light table when there's a new
version or when you're connecting or
whatever the case may be and so we have
we've documented a set of triggers for
it right so the things that might get
called on this object are no - phone
clicks notification click and
notification timeout so if you click on
one we want to know about it and if it
times out we want to know about it and
then we have these behaviors that we're
saying it has well when when when we
create this object go ahead and add the
behavior
move on timeout and that's going to
listen for that notification timeout
trigger right and it's going to have
remove on click now let's say for
instance you didn't like this behavior
whatsoever you wanted to change the way
notifications worked inside of a light
table all it would take is removing
those behaviors that's it
you'd remove them add new ones yeah you
don't have to add anything right if you
don't like you don't like that they
timeout just remove that behavior or add
some new one that gives it a totally
different way of working
we have composition here again this is
about being able to compose these events
in sort of unique and interesting ways
and it can happen at runtime which is
really really powerful and so an example
of this sort of being able to compose
these these these behaviors together is
let's say we wanted to make every single
editor inside of the light table an
instant evaluation environment basically
you want to make every single editor and
insta ripple all it would take is adding
these three behaviors to it so sonar
result is the thing that does the magic
we'll figure out what the values are and
put them in their place every time it
changes every time the editor changes
you want to eval that's pretty
straightforward and you want to be able
to toggle the live eval on and off those
three things are enough to essentially
give every single editor inside of a
light table the ability to be an
instable and so what we have is just one
big data structure all of light table is
in this single map that represents every
single object and what we get as a
result of this is we get introspection
for free this is a little tool that I
have built where I can click on any
object inside of the light table and
then see everything I know about it
right I can see all of the behaviors it
has in this case it's an editor and so I
can see things like well it's not it has
no rap on its going to be destroyed when
it gets closed it's trying to track
whether or not it's active it has the
ability to save because it's file
oriented you can eval it's going to save
when
it's eval and so on and so forth if I
wanted to change this I don't even have
to go to the code I could click on one
of these hit an X button or you know hit
some button that removes the that
removes that behavior and then go look
at a list of all the behaviors that I
have available to me and add it there
you go now I've changed the
functionality of this editor entirely
and so this is the system that underlies
lighttable
it is the behavior object system and
like I said it draws a lot of
inspiration from that component way of
building games we get runtime modify
ability and infinite customization to
things that are really really hard to
get right but fortunately games have
sort of solved this problem for us
already and so that's how light table
works now I always like to leave a fair
amount of time for questions but I have
one more thing that I want to talk and
since we started early I should have
quite a bit of time for questions but I
want to sort of end on one more thing
and that is since I'm doing a lot of
closure script and I'm fairly certain
that light table is probably the biggest
closure script application out there I
have I wanted to sort of end on my five
wishes for the project itself I my five
wishes for closure scripts sort of span
a bunch of different things the first
one is that we need better error
messages and I know why we don't have
them it's because this is a really
really hard problem to solve given the
way it works but we have to fix them if
we expect more people to be able to do
this I literally spend hundreds of hours
doing closure script and I still get
tripped up on errors right if that's
happening to me if you're new to it
that's going to make things kind of
difficult now that being said for the
most part you only run into this every
once in a while but when you do run into
it it's very hard to get around and so
this is something I think we really have
to sort of focus on the second one is
that I would really really like to see
the compiler working on node.js now I'm
not talking about eval here or any of
that stuff just the compiler I want to
be able to take closure script code and
turn it into JavaScript without ever
being able to spin up
JVM and interestingly enough when I talk
to people about closer script one of the
biggest complaints I hear for whatever
reason is that they don't want to take
that Java requirement they just won't do
it right I write in JavaScript why in
the world am i spinning up the JVM to do
that I means by far the biggest
criticism I hear but on top of that in
terms of light table it would be amazing
to be able to modify light table itself
without ever spinning up the JVM right
I would love not to have to have that
dependency and that would make a big
difference I don't even think this is
actually that bad we'd have to come up
with some interesting things to do with
the the closure the Google closure
compiler but I think even there there's
some clever things we can do the third
thing is I would really like to see the
closure script analyzer being able to
work over closure it may not have the
same level of information that the
closure analyzer has but the closure
script analyzer has a far better
interface as it exists now and there's
only superficial things keeping this
from really happening I don't think
there's a lot of work here the the main
one is that the namespaces have some
different things inside of them right so
like the the closure script analyzer
doesn't know about importing Java things
and the closure analyzer doesn't know
about requiring macros and so there's a
little bit of magic we would have to do
there but this would mean that our tools
could sort of rely on a single source of
analysis and do really great things over
top of that and I think that would be
immensely valuable the fourth one is a
bit more of a community thing and this
goes for both closure and closure script
and just completely in general we need
screencasts we as a community for
whatever reason we're starting to work
on the documentation there's some great
sort of efforts happening there on
working on closure Docs and and so on
and so forth but we still don't actually
ever show people things we only ever
tell them and and this is a big thing
that when I introduce someone to closure
for whatever reason I think this this
comes from like the way rails became
popular and so on and so forth people go
well where's the screencast like well we
don't really have very many of those oh
okay well tell me when you get
screencasts and maybe I'll look at them
so this is something that we as a
community
it doesn't matter if you're building
something stupid and trivial and just
for fun like video recording is still
probably actually useful for somebody
and it's not really that hard to do so I
would really like to see us sort of
build or rather do more screencasts and
the last one falls on me a bit and that
is we really need better tools for
foreclosure scripts there are still too
many things you have to know too many
things for someone who's never used
closure before to get up and running
with closure script right it's gotten
tons better line clj as build is awesome
and that has worked out really well but
that works really well for those of us
who already have lining installed who
are already closure people and so one of
the things I really kind of want to work
on with with with lighttable itself is
that you know we need better tools for
closure script and and what those might
look like so those are my five wishes
you know we need better errors to help
people so they're not banging their
heads against the wall the whole time
having the compiler on node is just
useful to drop that jvm dependency which
is a big blocker for a lot of people
using the c ljs analyzer for closure is
just goodness because we have one source
of analysis and that's very valuable
doing more screencasts again that's more
of a community thing and I really really
hope you guys do it me myself included
right we need to start doing screencasts
for for lighttable as well and the fifth
one is better tools and again that's
kind of on me but there's lots of
interesting sort of efforts being made
in this tool space for closure you know
there's a lot of work going on on n
repple Hugo has been working on like R
it's the the debugger for for closure
and Emacs so there's some good good
things happening here and so I since
they put me first I want to end on one
last thing and that is I sincerely hope
you realize how magical this community
really is and I'm not saying that I
Ronnie I'm meaning genuinely mean it
like the things and the people you will
meet or rather the things you will hear
about and the people you will meet at
this conference it's just amazing and
ridiculous some of the things that are
going on in this community like we're
testing the waters in so many different
directions
from logic programming to new tools to
new databases right there's so much
going on in this community and I
genuinely believe that we are kind of in
a transitional period in our industry
that a lot of the things that we decide
sort of in the next couple of years are
going to make a big difference for the
next decade of programming and I truly
believe that some of the people who are
going to make that difference are in
this room right now and with that I want
to welcome you to the Khans 2012 thank
so it looks like we have about 10
minutes left so I can take questions for
about 10 minutes or if there are none I
will happily go sit down and go to sleep
yes so the question is for the video if
there is a video um is with with the
initial release of light table with that
0.1 release of light table we were
trying out some interesting things with
like this table mode that had this
function very function oriented thing
and and he was asking with this new one
you seem to have reverted back to more
of the traditional editor style with
files and so on and so forth to that I
will say it's because we wanted to
release something that had a bit more
polish that worked in a more general
case but that is not to say that we
aren't bringing all of that back right
we we essentially rewrote the entire
thing and one of the things we really
wanted to focus on was that we need to
be working in light table all the time
ourselves and in order to do that really
early on we needed the simplest possible
way to do that and that was with files
right those tabs that are in the top of
the on the top of light table those can
contain anything they're not file
oriented they're not editor oriented
they can be anything right when you
think about it tabs are nothing more
than a way of sort of byte sizing a
context it's like oh the ability to
switch between contexts relatively
trivially in light tables taste those
contexts right now are only a file-based
editor and the insta repple what that
ultimately intends to be is things like
that what we were calling codex is those
function oriented sort of documents if
you will those are all going to come
back but one of the things we kind of
learned watching people use use that
thing as we wouldn't be hadn't figured
it out yet right we had something that
worked but it only sort of work we need
sort of better navigation better ways of
finding those functions and so on and so
forth and so it wasn't worth us spending
all that time trying to get that into
this release we thought it would be
better off let's just release the file
stuff that we have and let people use
that and that's been really beneficial
to a lot of people I think purely
because until we really figure that out
until we nail that sort of experience
with the functions it's hard to use
other question yeah yeah so the question
is have I thought about how we envision
extending and plugging into lighttable
this entire object or this behavior
object system is exactly that right the
point is not only I guess one of the
advantages you have is something like
Emacs right is that you can basically
turn it into anything you want and there
are two things we set out to do with
light take one connector to your project
that's something pretty much everyone
here understands the other one is that
we need an infinitely customizable
interface that still does graphics right
like Emacs can do text and that's
wonderful and great and vim can do text
and that's wonderful and great but we
need to be able to like when we ask a
question about performance let's see a
graph right like we want that ability
and so this behavior object system is a
way of not only customizing the objects
that are already in lighttable which
there will be a lot of right there's
going to be all sorts of useful these
primitives if you will but on top of
that you have the exact same system at
your disposal that all of light table is
built in and I was only half joking when
I said you could remove everything
inside a light table right one of the
things I sort of realizes that I
accidentally stumbled on a way of
building a closure script platform right
you now have you could take a light
table build your entire application live
inside of it right and then just ship it
as essentially a plugin that removes all
the all the light table parts and
there's your application and actually
think that's a really strong and
powerful thing to do based on how our
development work with light table itself
has been going I mean so from that
standpoint there's there's still a lot
to figure out like how are we going to
do the packaging and extensions and and
all that but you know there's a lot of
good sort of precedents there for what
has worked and what hasn't right for
example texts make kind of screwed up
and not having a central repository for
these to begin with
that's something will not make the
mistake right but in terms of the actual
mechanism itself everything that we can
do you can do oh I see okay so so he's
basically saying since since we're
exposing the entirety of light table to
you isn't that a problem for
compatibility over time my answer is yes
it would be right
fortunately in general though the state
like when you think about state in this
case there's very little of it for one
right like editors don't actually carry
around that much state aside from
obviously the text and stuff inside of
them but in terms of things outside of
that there's not that much there and so
the probability of that changing is
relatively low on top of that all the
functionality all the scary things are
still wrapped up in these behaviors you
can just remove right so even if even if
large things happen to light table
itself there's a good chance that it
actually won't be that impactful in
general and on top of that let's say
like a key changes for example inside of
that map in that case you could do some
shimming if you will and create a fairly
simplistic compatibility layer that
wouldn't be hard
that being said anything that's this
open is naturally going to have issues
if you rely on low-level things like
there's nothing you can do about that
yeah so so this question was with the
the big data structure do we try to keep
it fully serializable I've gone back and
forth on that one so I'm going to answer
your last question first do I think it's
valuable that that could be serializable
my answer to that would be absolutely I
think that would be valuable because
within which you could essentially do is
package that up and ship it right if you
ship it to some other version of light
table or some other instance of light
table and tada you're in the exact same
place you were before I don't know that
that that dream is certainly something I
want to see happen whether or not the
entire data structure needs to be
serializable to do that I don't think so
a view of it needs to be you need to be
able to recreate the things that for
whatever reason can't be serialized and
it turns out that those are relatively
few and straightforward and they're
things that you wouldn't want to
serialize anyways in the light table
case so far and so the ability to not
only just like share it to someone else
but even like to sync it across
multiples like for pair programming for
example is definitely something I want
to see and so our goal is to keep it as
serializable as possible such that when
we do that work it's not that hard to do
so so I talked to David Nolan who I hope
is here somewhere
a little bit about this so
his question was what does it take to
make the closure script compiler work
inside of JavaScript essentially so
there are a couple of different aspects
of this just turning closure script into
JavaScript is relatively straight
forward the things that we need to
happen there is you need a you need
macro expansion which is something
that's not written in closure right now
you would need a full line numbering
push back reader and all and that as
well I think those were the main two
things that needed to happen if I
remember correctly someone else might
know better than I do and then there's
this problem with if you want to then
subsequently get the output you would
actually get if you were using the
compiler you have to run it through the
Google closure compiler and that
requires Java right now so so I said
there's probably some trickery we could
do there well you could easily set up
there actually already is a service
where you could just send code and get
the result back right so you could do it
that way but in your case if you're just
doing something like a ripple right you
want to make hai meraa be completely
yeah just right you can make right and I
think that was actually the point of hai
meraa focus can probably talk more about
it right was this idea that you could
just like send code to it and get
results back so yeah so I don't think
there's a lot of work to do there well I
say a lot I don't know how much is
involved in trying to do all of that but
it doesn't seem at least on the surface
level to be to too much work all right
guys I'm out of time I'm more than happy
I'll be here the entire conference in
your more than more than welcome to come
and talk to me thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>