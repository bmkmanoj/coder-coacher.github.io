<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Understanding Structures in C Programming | Edureka | Coder Coacher - Coaching Coders</title><meta content="Understanding Structures in C Programming | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Understanding Structures in C Programming | Edureka</b></h2><h5 class="post__date">2014-09-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/l_usJK7b6OI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so as we have spoken earlier we need a
way to represent complex data types in C
so let's say we talk about a single
point in three-dimensional space it has
an int X int Y and n Z so we need a way
to represent all the three of them
together as a single block all three put
together represents a point in space so
we need to have a data type let us say
point which says a single point consists
of an XY and z axis similarly let's have
another example that you can see on a
screen is a coordinate system any
address on earth is represented by a
latitude and a longitude a latitude is a
floating-point number followed by a
character it says whether it's not south
east or west
similarly the longitude also the
floating-point number followed by the
direction so now all these four put
together tells you the coordinates of a
particular point on earth so if you are
good so if you're going to write a
program and see which is going to store
the coordinates of a particular location
then it's simpler to have a single block
called coordinates instead of having
four different variables to do that we
can define all the four variables within
a single structure so in C a structure
is a collection of multiple variables of
different types they can be the same
type too but the whole idea is you're
trying to store everything as a
structure so most of the time they're
all of different types the structures
are used to basically create
user-defined data types like you can see
here we want a new data type called
coordinate so we created a structure
called struct chord then within that we
have said that the coordinate consists
of a latitude or float longitude a
character which is large to underscore
direction and another character
longitude underscore Direction so what
you see here is a syntax for defining a
structure in C you have the keyword
struct followed by the name of the
structure that you want to give curly
braces then you can have all the
variables that belong to the particular
structure and finally close the curly
braces and
semicolon so now we have defined a
user-defined data type called struct
cord
now we shall go ahead and see how we're
going to use this structure how do we
access members how do we copy data to it
and so on so like I said we have now
declared a user-defined data type and
it's called struct cord so before we can
start using it we have to first declare
a variable of that type to declare a
variable of any type is simple so in
this case you say struct cord and then
see one so now we have variable c1 which
is of the type struct cord so c1 itself
consists of four individual variables so
we then see when you have a float
latitude you have a character latitude
underscore Direction you have a float
longitude and you have a cash longitude
underscore direction to initialize the
structure c1 you say c1 equal two curly
braces and values for all the four
members which are part of the structure
so 27 point one seven becomes the
latitude the letter n is the latitude
underscore Direction 78 point zero four
is a longitude and the letter E is
longitude underscore Direction okay so
now that we have initialized the
variable two how do we access each
individual member in the structure to
access the members of the structure we
use the dot operator so you say variable
name dot member name so in this case a
variable name is c1 the member name is
latitude so as a c1 dot latitude equal
to twenty seven point one seven well if
I want to print the latitude on the
screen I can just say printf percentage
dc1 dot latitude but latitude is float
so you'll say percentage F similarly you
say printf % 8c C 1 dot Latin is good
direction simple so you say variable
name dot member name also just if we can
have basic variables within a structure
you can have other structures also
within structures these are called
nested structures so let's say I have
another structure in my program I can
make that structure part or
when you structure that I'm going to
declare - we shall see how we're going
to do that and finally now that we
declared a new data type every data type
has a size we know that integers are
generally four bytes a character is one
byte so what is the size of a structure
the size of a structure is basically the
sum of all of its members but the size
of the structure is not simply the sum
it may sometimes be greater than the sum
of all of its members and the next slide
we shall see why before that we're going
to take another simple example of using
structures and write a program for the
same so let's take another real-life
example when we want to represent a
person a person consists of a first name
and a last name it's just not a name
alone right so you're talking about the
name of a person it can be first name
last name or first name middle name last
name so for this example we're going to
assume that a person has a first name
and a last name so how do we represent
that in --see so first let's just
include stdio.h
now we are going to define a new data
type called named struct name now the
name itself consists of two parts the
first name and the last name so you're
going to say care first name size 52 up
to 50 characters cat last name 50
finally close this so that's a structure
generally you define structures outside
of any function because the data type
and you can use the data type anywhere
but once you've defined the function you
can have variables of that once you
define the structure you can have
variables of the structure within any
function and that variable becomes local
to that function so let's have int main
now I want to store the name of a
student so let's declare a variable of
the type name so I say struct name
student so now we want the user to enter
his or her name and we're going to store
it in the variable student don't f enter
your first name
the first name is a character array or
like we say it's a string you can of
course use scanf to accept strings in
the user but a better way to accept
strings is use the Geddes function as
scanf if percentage s has some issues
you cannot accept strings with spaces in
it get it is a simpler one so you say
get us and now we want to accept the
first name we say student dot F name
next you on the last name def enter your
last name
darris student dot L name
now finally before we exit the program
we want to see if you've stored the name
correctly made a mistake here so let's
print both the values so printf now
remember that to print a structure see
does not understand what type is that
structure so you can access only each
member or the structure so in C if you
want to print a structure you cannot
print it as it is you can only print
every member individually just the way
we had to accept the first name
separately and store it in first name
except the last name then store it and
last name similarly when I'm printing it
I can print just one member at a time I
cannot just say printf some special
keyword and give just the structure name
as student so if I have to print the
first name of the last name of the
student I have to say printf first name
percentage s student dot F name
similarly printf last name percentage s
student dot last name
finally system pause Etan zero let's try
and run this program
compile the new error the warnings run
enter your first name I'm going to say
hello enter your last name I'm going to
say world first name hello last name
world so of course for the example we do
not require a structure we could have
just had to be different variables
called cat fname and kal-el name and
stored it but once we've made it into a
structure it's very easy for us to
understand when we look at the variable
student we know we're going to store the
name of a student and the name of a
student comes of two parts which is a
first name and a last name so now your
program becomes a lot more structured
and is very easy to represent complex
data like this
so now we're going to talk about
structure padding due to which the size
of a particular structure can be more
than just the sum of its members now we
shall see why one of the main issues is
many processors expect the memory
allocated for a particular variable to
be byte aligned what I mean by byte
aligned is that lets say a variable
takes up four bytes like an integer then
the processor expects that variable to
sit at a four byte boundary so which
means it variable can sit at the byte
number five thousand four or five
thousand eight or five thousand twelve
and so on it cannot be assign the
address five thousand three or five
thousand two because that's not for byte
aligned but a character which is one
byte can sit anywhere in memory
similarly or double which may be eight
bytes would have to be eight byte
aligned so now let's see how this
property is going to affect the size of
a structure so let's say this my memory
and I want to store care CH because a
character takes are just one bite I can
store it anywhere in memory so I can
store CH at the address five thousand
one now let's say I want end num integer
takes of four bytes so I need four bytes
in memory the starting address for this
4 bytes has to be 4 byte aligned so this
has to be either five thousand four five
thousand eight or a multiple of four so
now what happens when we apply the same
rule to a structure when the individual
variables are no problems integer takes
of four bytes
it doesn't matter where memory is going
to sit I need the address whenever I
want it but can sit anywhere in memory
and it's going to assign four bytes to
it now let's try to put these two fields
within a structure so if I say
strucked dummy so I will structure dummy
and I have two variables while the type
cash and other of the type int so now
when I say struct dummy d1 what happens
I'm going to firstly raise this so when
we declare a structure the space for the
structure and space for all the members
within a structure allocated one after
the other so normally what you would
land up doing is in D 1 you start B 1
here let's say our character is one byte
an integer is 4 bytes so we need 5 bytes
so alligator 5 bytes so d1 dot CH is the
first byte and then D 1 dot num is the
next 4 bytes so d1 starts here CH or
Cassy H is the first member that's
stored here then num or int num is the
second member that is stored here but
simple right so we have three members
the third member here fourth member and
so on but now let's say if d1 dot CH was
it address 5,000 CH is a type gas it can
sit anywhere in memory that's okay
which would mean d1 dot numbered started
address 5,000 one but num being an
integer it cannot start it at this five
thousand one like I said earlier it has
to be four byte aligned that means after
five thousand the next byte it can sit
at is five thousand four
so this is five thousand for this is
five thousand won this five thousand two
is five thousand three is five thousand
four so you have five thousand four here
so your d 1.9 has to start at five
thousand four and then it lock by four
bytes after this point so you have five
thousand five six seven so dividend
number is going to occupy these four
bytes and even if CH is occupying this
byte so what happens to these three
bytes these three bytes are wasted and
the compiler uses these three bytes to
pad the structure so that all the other
members are byte aligned so this call
structure padding so now the size of the
structure is not 4 plus 1 5 but it's 4
plus 1 plus 3 that's 8 bytes so silo the
entire structure is 8 bytes knowing such
information is useful to us because once
we know about structure padding it's
easy for us to redesign or rewrite the
structure so that we use up less space
now instead of writing it like this if
you written the structure as strut dummy
in turn um
and then gasps eh
so firstly look at space for the integer
num so it can start anywhere in memory
right now it will align into four bytes
of course
so it'll allocate space for the integer
num which is four bytes and then you'll
write allocate space for cash CH for a
character which is one byte it doesn't
matter we can start it anywhere this
will be CH this will be numb so these
four bytes and this is one bytes totally
eight bytes but then in this case two
instead of five bytes the structure is
going to take up eight bytes this is
because after the gasps CH the last
three bytes are also going to be used up
this because the entire structure or the
end of the structure is also padded
based on the size of the largest member
the size of the largest member here is
four bytes which is for num so the end
of the structure also has to be four
byte aligned so now once we have a
character we still have to assign three
more bytes to make it four by the lined
so it's going to pad three more bites
making the entire structure eight bytes
so in this case which is two variables
no matter how we interchange the order
the size is going to occupy will remain
the same but in a lot of other cases
once we are aware of structure padding
we can rearrange the members to minimize
the effect of structure padding
first thing to do to minimize effective
structure padding is to arrange the
members in descending order so let's say
I have int num
and then float F let's say what happens
this is four bytes then this is eight
bytes you're going to use a four bytes
for padding then this is four bytes we
don't have to bother about padding so
we've taken up 4 4 8 16 20 and the end
of the structure has all should also be
eight by the line because largest member
of eight bytes so you're going to have
again are the four bytes of padding so
let's say we had stored the members in
the opposite order or a different order
so ice first or double double X then I
have a float F and int now
now let's see what happens double X
takes up eight bytes in the float F 4
bytes no batting required because in a
four byte boundary in num four bytes
again it's in a four byte boundary total
12 16 totally 16 bytes so no padding
required at the end of the structure
either here the total was 4 4 8 16 20 24
we've saved about 8 bytes by JISC
rearranging the members let us just
write a program to see if you are right
about this say hash include steady i/o
dot H we have struct
dummy I'm going to have in num X float F
and main
I just print the size of structure so
printf size % HD size of struct dummy
finally system pause return 0 let's
compile and run this program
no errors or warnings run as we had
guessed it storing 4 bytes /n here now
let's have another structure struck
dummy one here we're going to rearrange
we're going to have double X and num
float F and let's print both the values
first we pin for dummy and then we say
size of shocked dummy 1
there you go 24 and 16 so in this
example 2 you can see structor me you
have a cash CH we'll take a one-bite
then you have an integer so between
these two you're going to have three
bites of padding and then finally you
have a double temp now piling the quiet
here because this already taken up 8
bytes is going to be at a 8 byte
boundary so you're going to take up 8
plus 4 12 12 plus 4 16 so it's going to
take up 16 bytes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>