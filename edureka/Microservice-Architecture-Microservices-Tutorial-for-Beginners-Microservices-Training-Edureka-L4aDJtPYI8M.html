<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Microservice Architecture | Microservices Tutorial for Beginners | Microservices Training | Edureka | Coder Coacher - Coaching Coders</title><meta content="Microservice Architecture | Microservices Tutorial for Beginners | Microservices Training | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Microservice Architecture | Microservices Tutorial for Beginners | Microservices Training | Edureka</b></h2><h5 class="post__date">2018-02-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/L4aDJtPYI8M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey guys this is a high pyramid Eureka
and today we will be learning about
microservice architecture so before I
start with the session let's take a look
at today's agenda initially we will
start talking about the previous system
that was the monolithic architecture
followed by its challenges then we'll
jump on to the functionalities of
micro-services and the best practices to
design them after going through all the
lancets we will go through a real-life
use case of uber and understand them
better
so let's get started with the session
what do you think monolithic
architecture was well I could say that
it was like a big container where all
the software components of an
application were tightly packed together
have you got any idea how the
applications on this framework worked
how they looked like how they performed
how they communicated with each other
and so on let's look at the
client-server model shown here what do
you see as a user as a user when you
open a web UI you just see your website
but behind the scenes the server-side
application has different features which
have to be handled together feature such
as handling HTTP requests retrieving and
updating the data from database and
executing a domain-specific logic were
put on a single framework so if any one
feature of the server-side applications
had not worked and the complete system
would go down also if only any one
feature had to be updated then the
complete system had to be built again
now let's understand more about
monolithic architecture by using a
shopping cart application for reference
as a user when you open a shopping cart
application what all do you see you see
different features for handling wish
list new labels new brands in the
markets customer services and so on but
if the developers of this framework had
decided to build this application on the
single framework then all the features
were put together on a single database
this not only created problem for
scalability but also for fault tolerance
and agility let's understand these
challenges
one by one specifically the first
challenge that we are going to talk
about is agility let us consider an
asset management industry here different
clients come with different investments
who have to be offered different
services so if any new services had to
be given to any new clients or any new
changes had to be made do you think one
of the thing I could accommodate these
changes well I would say it definitely
could but yes there's a problem here the
problem is here it could accommodate the
changes but are the cost of reduced
agility why do you think this happened
this happened because even if a small
component in an application had to be
changed the entire application had to be
repackage together let's look at the
second challenge consider yourself as a
developer now so if you had bet any
application you would obviously want it
to scale as per the future trends but if
you had built this application on a
monolithic architecture how do you think
you could keep up with the scalability
well let's take an example our shopping
cart application is built on a
monolithic framework now consider three
customers come out to the application
just to accommodate these three new
customers three instances of the same
application have to be created also
apart from the three new instances of
the application resources also get
wasted for the services which need not
have to be scaled let us now look into
the third challenge which is fault
tolerance consider your shopping cart
application for reference suppose even
if one feature of the application
doesn't work then the entire system goes
down this not only creates a problem for
the users but also creates a problem for
the developers as they have to rebuild
it again so to avoid these challenges
developers of these applications decided
to shift from monolithic architecture to
micro-services now many questions may
come onto your mind such as what were
the advantages of new architecture how
could the developers benefit from the
new architecture what were the new
challenges that were faced with this
architecture and so on let's discuss
each of them one by one
let's start with what were microservices
microservices are basically an
architecture where in a monolithic
application is decomposed into small and
micro applications which were packaged
and deployed independently consider your
shopping cart application for reference
again imagine now the developers of this
application have shifted its framework
from a manila tick to a micro service
architecture so this is how the
architecture looks like now even now as
a user when you open a shopping cart
application you just see features put on
together on a single website now there
are separate themes handling different
features that means there's a team of
developer handling deal of the day a
team of developers handing new labels a
team of developer handling customer
services and so on all themes now right
cause for their features only making it
easy to deploy individual features again
and again whenever it is required how do
you think these individual supriya
deployable units communicate with each
other
well these separate individual
deployable units communicate with each
other through a well-defined interface
of rest or message bus by now you must
have understood what were the
functionalities of micro services and
how they communicated with each other
let's learn more about micro services by
looking at different components of its
architecture well the architecture
starts with different clients from
different devices trying to perform
different management capabilities such
as build surge notification and so on
then each and every functionality is
segregated into separate micro services
handling their own data for example
macro service a could take care of
search operation micro service B could
take care of build operation micro
service C could take care of
notification feature and so on all these
individual micro services have their own
load balancing and execution
environments to perform different
functionalities and capture their own
data these individual micro services
then communicated within themselves
through the rest or message pass to
perform different operational
capabilities such as automation and
monitoring also the
Qwest of clients were passed on to the
internal architecture through an API
gateway let's summarize the difference
between both the architectures before
moving forward to the features of micro
services and the use case so in short
monolithic architecture had a single
framework for all the features on a
single database whereas microservice
architecture had different micro
services for each and every feature
handling their own database now what
features may the developers ship from a
monolithic architecture to micro
services let's have a look at them the
applications built using Microsoft's
architecture were easily built altered
and scaled they focused on a single
capability all the components could be
easily replaced the teams work
independently they allow frequent
releases of these software applications
with treated as products there were no
standardized patterns and most
importantly all the features were
quickly developed let's look into more
of micro services and their
implementation by using a real life use
case of uber what do you know about uber
well uber technologies is a global tax a
technology company headquarter in San
Francisco United States operating in 633
cities worldwide like many of the
startups who were also started its
journey with a monolithic architecture
for a single city let's have a look at
this architecture initially they had a
REST API with which the passenger and
the driver were connected this means
that the mobile API was connected to the
REST API which was then connected to the
monolithic architecture as a back-end
server also for people accessing two web
UI
they were also connected to the same
server coming forward there were three
more adapters which we use to perform
different functionalities such as
notifications sending mails or messages
billing payment acceptor finally a my
sequel database to capture all their
data so if you observe here all the
features such as passenger management
billing notification features trip
management driver management were
composed in a single framework this
means that having one code base seemed
cleaned at that time and solved Uber's
core business problems which included
connecting drivers with riders buildings
and payments but as uber started
expanding worldwide into many more
cities it continuously faced the problem
of scalability and continuous
integration so developers could not
continuously pill test deploy and
release the software frequently as and
when uber started expanding city wise
throughout the world also adding new
features and fixing bugs in a single
repository became extremely difficult
for the developers so to avoid such
challenges Hoover decided to follow the
lead of hyper growth companies like
Amazon Netflix SoundCloud and Twitter
and broke down its monolithic framework
into multiple code bases to form a micro
service architecture so this is how the
new architecture looks like what your
thing is the new change in the
architecture well we could clearly see
the introduction of API gateway which
connected all the drivers with the
passengers also from the API gateway
all the internal points were connected
such as
Basinger management trip management and
driver management and so on so basically
anybody who connects to the api gateway
gets automatically connected to all the
micro services another change that we
observe in this architecture is the
introduction of individual separate
deployable units here this means that we
can deploy this unit or this unit or any
other unit without disturbing the others
let me explain you this point with an
example consider yourself as one of the
developers of uber so now if you want to
change anything in the building micro
services then you just have to deploy
only building micro services and do not
have to disturb the others also this
kind of architecture helped uber to
scale its services individually let me
explain you with an example as we all
know the number of people searching for
cabs are comparatively more than the
number of people actually booking a cab
and making payments so the number of
processes working on the passenger
management micro service are more than
the number of processes working on the
payments also it was observed that even
if any one feature was done no other
micro service would get affected
therefore developers of uber need not
build their applications again again
even if one micro service goes down now
that you've seen a real-life use cases
uber can you think of any best practices
to design micro services well let's have
a look at them initially separate the
data store for each micro service then
keep the code at similar level of
maturity now after this separately built
each micro service according to its
respective features and then deploy into
containers lastly create the servers as
stateless for communication now let me
just give you a quick summary of what
all we discussed we started with the
understanding of what was monolithic
architecture and its challenges then we
went through the micro service
architecture and understood the
differences between both the
architectures after understanding the
architectures we focused on the features
of micro services and discuss the best
sister designed them then we compared
Hoover's previous framework to the
present one and understood what made
them change their architecture thank you
for watching this video and have a great
day I hope you have enjoyed listening to
this video please be kind enough to like
it and you can comment any of your
doubts and queries and we will reply
them at the earliest do look out for
more videos in our playlist and
subscribe to any Rekha channel to learn
more happy learning</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>