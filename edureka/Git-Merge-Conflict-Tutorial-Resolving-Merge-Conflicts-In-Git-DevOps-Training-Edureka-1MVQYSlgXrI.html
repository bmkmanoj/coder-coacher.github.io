<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Git Merge Conflict Tutorial | Resolving Merge Conflicts In Git | DevOps Training | Edureka | Coder Coacher - Coaching Coders</title><meta content="Git Merge Conflict Tutorial | Resolving Merge Conflicts In Git | DevOps Training | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Git Merge Conflict Tutorial | Resolving Merge Conflicts In Git | DevOps Training | Edureka</b></h2><h5 class="post__date">2017-08-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1MVQYSlgXrI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone this is Rashmi from Eddie
Rica and I'm very excited to take up my
first live session here on YouTube so
thank you all for joining this session
on git and in this session we'll majorly
focus on the different workflows on git
and how to handle merge conflicts when
they arise so this is the agenda for
today so we'll take a brief introduction
to get will see all the Kidd commands
that we use the different get workflows
that different dev teams follow and how
to handle merge conflicts in each of the
workflows so this is the short agenda
for today now let us take a brief look
at what is good and what does it
actually do so git is a version control
software that is mainly used in software
development to help your map to help to
manage your code better and how exactly
does it manage your code better it helps
by keeping versions of your code so
let's say that you have got your source
code file and in time you'll keep making
changes to it maybe like adding new
features or doing bug fixes and
sometimes you would want to go back to
the previous versions because the newly
added features might not be working out
the way you want to or because of any
other reasons and kit will help you to
rollback because it has been keeping
snapshots every time you change
something and these snapshots are known
as version 1 so let's say that this is
your initial code you made some other
changes in the initial code that will
keep a version for that and similarly as
time passes by it will keep different
versions and whenever you want to go
back to any of the working versions you
can do that with the help of git so this
is how git helps in code management so
now let us take a look at the get basic
commands so if you want to create
repositories let's say you want to
create your local repository you just
have to initialize that using git init
or if there is an existing repository
you can use git clone if you want to
make changes in your file you can use
different commands you can use git
status to see whether a file is there in
your index or not you can use git add in
order to add a file on your index
and you can finally use get comment in
order to commit those changes that you
have made for sinking in repositories so
you know that and get we deal with two
repositories the central and a local so
you have to inform your local repository
that butches our central repository that
basically lies on a remote machine so
for that we add origin we add the link
of the central repository using this
command git remote add origin and then
if you want to pull all the files that
are in the existing central repository
use a get pull and then finally if you
want to reflect your changes into the
central repository you can use git push
for parallel development we have got get
branch it allows you to branch off from
your main branch and you can work on
different features on a completely
isolated branch using git branch and
then you can finally also merge all
those changes in your production
deployable branch which is usually the
master branch using git merge and then
we can also use git rebase now this is a
special kind of merge so it's basically
does the same thing as get merged only
the Komet workflow or the commit working
tree looks a little bit different so
you'll know about that because we'll be
using rebase in today's session so now
let us take a look at the get workflows
so basically the git workflows can be
categorized into broadly three kinds so
there is the centralized workflow where
there is one central repository and only
one working branch which is the master
branch then there is the feature branch
workflow where you have dedicated
branches for each feature and then
you've got get flow so we'll take a look
at all of this and how to solve
conflicts in each of this workflows so
now let us talk about the centralized
workflow so the centralized workflow
uses a central repository to serve as a
single point of entry for all changes to
the project and there is only one
default development branch and it is
called in master and all changes are
committed into this branch so this
workflow does not require any branches
besides the master so what the
developers do they start by cloning the
central repository into their local
repository and in their lo own local
copies of the project they will edit the
files commit
Changez but you should know that these
comments are stored locally they are
completely isolated from the central
repository and if the developers want
the changes in the central repository
they'll have to get push it so now let's
say that we have got three people we
have got Bob Alice and Jake and they are
working on a project X so now let's say
that Bob here makes the changes and the
project commits said and then pushes it
into the central repository so his
changes will be published into the
repository with his recent comments and
now let's say that alice is also working
on the same thing and she wants to
publish her changes in the central
repository but since Bob and Alice
changed the same file in the same line
there will be a conflict so let me show
you how exactly does it happen and how
to solve it
so here I have created repositories for
Bob and Alice so they are just in my
system at different folders so since I
have to show you the scenario I have to
pretend to be two persons at one time so
what I'll do I'll just click get bash
here now I'm using git for Windows so
you just don't have to do anything you
just click get bash here and we'll open
up the git bash shell and the same thing
I'm gonna do for Alice over here
so let me just adjust the screens so
that you can see what I'm doing in both
of this get bash shells
so hope that you can see the screen over
here so this is Bob's local repository
shell that we're using and this is for
Alice so the first thing that you need
to do you need to initialize your
repository so for that you have to use
git init and I'll do the same thing for
Alice it's done and now what I'm going
to do I have already set up my central
repository on github so I'll just add
the origin using git remote add origin
so I'll do that for Bob I lives this
command git remote origin and now you
need to provide the link of your central
repository that is on github so I'll
just go to my github so you can find the
link over here so you just just copy it
paste it and I'll do the same thing
again for Alice
all right so now there are files that
are existing in my central repository
already so I want to pull those files so
for that I'll just use this command get
full origin master so it has pulled all
those files I'll do the same thing for
Alice again so now if you see their
repository so this is Bob surprise the
traders pulled all the files from my
central repository and this is the dot
get hidden folder this gets created when
you initialize a repository specifically
when we type git init all right so now
let us assume that bob has made some
changes so let's say that's fine over
here so i'm just taking very simple
example so basically there will be code
here just so that you can just
understand the concepts of conflict I'm
just using simple text files so let's
say that Bob has made some change like
this saved it and now bob wants to
commit this changes so first bob will
check to get status to see sorry so git
status will show you whether a file has
been added to the index or not so if it
is in red it means that it has not been
added to the index so for that we'll
have to add this file so we'll use the
command get add and the name of our file
so now if you check its status
so you can see that it is green now so
it means that it has been added to the
index that is there in the staging area
and it is ready to be committed so now
we'll use git commit in order to commit
this and also remember that we have to
commit using a message
so for I'll just pass this Bob changing
and urea set is committed now Bob wants
to push it to the central repository so
I'll use git push origin master
and it's done so if you go to your
central repository now so let me refresh
this page so you can see Bob's commit
over here so that means that this file
has been changed in the central
repository so now let us go to Alice's
local repository and let's say that
Alice does not know that bob has already
made changes in the central repository
and she is doing her work in her own
local repository and she has changed the
file something like this so we'll close
it now Alice will also do the same thing
she will add the file and then she will
commit the file to pass this flag M so
let me just keep it simple I'll just
write Alice over here and now she would
want to push it the same way that bob
has done get push origin master and
since it's a centralized workflow there
is only the master branch so you can see
that there is an error that is has been
rejected the updates were rejected
because the remote contains work that
you do not have locally so it means that
something was changed in the central
repository which Alice's local
repository doesn't contain and now it is
centralized workflow and I don't want to
mess around with my master branch
because my master branch is supposed to
always be and a master branch is always
supposed to keep the production
deployable code so instead of just
pulling it directly I'll use rebase so
what Phoebe's will do is that it will
always have the initial commits that
will come from the central repository it
will just add up my commits on top of
that workflow or my working tree that
shows all my commits so I'll show how it
works so for that
I'll not just pull it directly I'll use
a different command
get full prepays parisian master so it
is showing that there is a conflict in
the content and it is an ED Eureka dot
txt and even this message doesn't appear
and you're confused where the conflict
is you can do one thing let me first
clear the screen you can use git status
to see where the conflicting file is so
you can see that ad Eureka dot txt so in
order to solve this conflict I'll use
git merge two so you can see it has
opened up three files so this is the
file that Bob has changed this is what
was the original file and this is what
Alice have changed right so Alice can
take a look and this is the head where
her initial commit right now points to
so she can decide whether to keep the
changes or not and let's say that Alice
wants to edit it she wants to solve the
conflict and let's say that she decides
that she wants to keep both the two
lines let's remove all that
save that file you can save an exit
so even exit save an exit
all right so now you can continue
rebasing so for that you can use this
command okay let me clear my screen so
that you can see what I'm typing so you
can use this command git rebase continue
so it has applied my last comment that I
was trying to push it on to my central
repository and now the merge conflict is
solved and I should be an or let's say
Alice should be successfully be able to
push it to the central repository so
let's try it
and the conflict is solved and it is
successfully pushed on to the central
repository so let me just show it to you
so here is Alice's comment so this is
how you deal with conflicts when you are
using a centralized workflow so I hope
that this is clear so now let us talk
about the feature branch workflow so if
your team is comfortable with the
centralized workflow but they want to
streamline its collaboration efforts and
it is definitely worth exploring the
benefits of the feature branch workflow
so what happens here is that you
dedicate an isolated branch to each
feature and because of this it is
possible to initiate in-depth
discussions around the new additions
before you try to integrate them into
the official project so the core idea
behind this feature branch workflow is
that all feature development should take
place in a dedicated branch instead of
the master branch and this encapsulation
actually makes it easier for multiple
developers to work on a particular
feature without disturbing the main
codebase because again I'm telling you
the master branch should always contain
production deployable code so it also
means that the master branch will never
contain broken code and this is going to
be a huge advantage when you're dealing
with continuous integration environments
so again let us consider the scenario so
this is the feature branch workflow so
they're all working on the features so
let's say that Jake here is working on
feature B and Alice and Bob are again
working on feature a so again first bob
makes a new branch and he pushes that
new branch where he has added some
features and it was pushed and he has
pushed it into the central repository
and then again Alice wants to push it
again the same things that she might
have some changes that she might have
done in the central repository so then
there is an advantage of using the pull
request so pull request are a way to
initiate discussions around the brunt so
they give other developers the
opportunity to sign off on a feature
branch before it's get integrated into
the official product so let me just show
you an example of this again so open up
this repositories again so this is Bob's
repository so let's say that Bob wants
to know branch off and work on his new
feature so he just can use this command
over here get branch and let's say his
feature is called feature one so now
let's check out the feature one so now
bob is in the feature one branch so
let's say he wants to add something
all right so just save and exit and now
again Bob wants to add this file all
right you come at this file
come it done it's clear for you and now
you would want to push this branch on to
the central repository so for that he'll
just use the same command git push
origin and the name of his branch and
this will actually create a different
branch in a central repository with the
same name and it will serve as a remote
tracking branch
and it is done so if you go to the
central repository and I can see that
less than a minute ago there was a new
branch here which is called the feature
1 so if you go check out this branch and
github you can see it has got this file
along with the other files because it
was actually branched off from the
master with the latest commit where it
contained all the files right so now if
Bob wants Alice to know that he has made
some changes because now they're working
in a featured Branch workflows so he
will file a pull request so how to do
that and get help you just have to go
here just click this button new pull
request the base should be master branch
and compare the feature 1 and then you
can add some comments over here so you
can just create and just let's say that
please check it out so if you want
reviews on your branch whether you have
done or develop the feature in the
correct way or not you can actually add
reviewers here and you can you can
actually also assign someone here so now
since my github only have me as a
collaborator I don't have anyone else so
so you can add other people who are
actually contributing on to this central
repository and then finally you can
click this button oops
right there seems to be some internet
issues with github alright but the good
part is that I'm actually done with that
you don't have to do anything after you
have created that pull request so what
will happen after that is that whoever
you add as a reviewer so they will
either get a mail of how you set it up
so they'll get a mail and then you can
also comment and they'll be back and
forth discussion about what to change or
not and finally you have to merge it
when it has been set up when you're all
the when the entire time so sorry when
your entire team is satisfied on the
feature that you have worked on so
someone will finally merge it onto the
master branch so this was all about the
feature branch so pull requests come in
handy when to cat when you want to carry
your discussions with your entire team
so now let us talk about git flow so git
flow workflow defines a strict branching
model that is designed around the
project release so this is somewhat more
complicated than feature branch workflow
but this provides a robust framework for
managing larger projects so this is what
the entire branching model kind of looks
like so you don't have to worry even
though it looks very complex this
workflow does not add any new concepts
or commands beyond what's required for
the feature branch workflow instead the
difference is that it assigns very
specific roles to different branches and
defines how and when they should
interact so in addition to feature
branches it uses individual branches for
preparing maintaining and recording
releases and of course you also get to
leverage all the benefits of feature
branch workflow the pull requests the
isolated experience experiments that you
do on your feature branches and more
efficient collaboration so how does it
work so the git flow workflow uses a
central repository as a communication
for all developers just like all of the
workflows and the developers again work
locally and push branches on to the
central repository so the only
difference is the bronze structure of
the project so instead of a single
master branch so this workflow uses two
branches to record the history of the
project so the master branch here
actually stores the official release
history and then develop branch that
serves as an integration branch for
features and it is very convenient to
tag all the commits in the master branch
as different versions so here you have
tagged it as version 1.0 1.0 point one
then one point 1.0 something like this
so whatever naming scheme that you are
comfortable with
so you have got feature branches so
there are two feature branches mostly so
one is for that one is there which
majorly focused on the coming release
and the other needs to be worked on for
a coming release or a feature release so
when a feature is complete it gets back
its get it gets merged back to the
develop branch and feature browser
should never interact directly with the
master so feature branches combined with
develop browse for all intent and
purposes to the feature branch workflow
but the git workflow does not just stop
there so once developers acquired enough
features for a release or let's say a
release date is coming up so what do you
do you for the release branch off to
develop and creating this branch start
the next release cycle so no new
features can be added at this point so
you can only do bug fixes and hard fixes
and patching up things and once it is
ready to ship the release gets merged on
to the master and tagged with the
version number so this is how git flow
works so obviously you'll also find
merge conflicts here but it is very
easier to fix because it is more in a
structured way and when you have a lot
of people working on a particular
application especially larger
applications you can use git flow for
that and in most of the companies people
use git flow so all you have to do you
have to create feature branches you have
to create
well a branch and you have to follow the
get flow so just flow with the game flow
and so here are the different workflows
I hope that I you have understood
something you have learned something new
and I have shown you in a very bare
minimum with just so that it can get the
concepts so all right if you have any
questions you can leave it on the
comment section below and I'm very glad
to announce that a de Rica has finally
launched their DevOps engineer master
program and Eddie Rica has tailor-made
this particular course for you to become
a DevOps expert so it includes each and
everything that you need to learn
starting from the basic to advanced
covering every concept that you need to
know so here here is everything that you
will learn so these are some must-have
things that you should go through in
order to become a DevOps expert so
you'll be learning Linux fundamentals
Python DevOps darker AWS Splunk and here
are some free electives that you can
choose so you can choose either a
self-paced course on Jenkins puppet chef
ansible and even kit so you can check
out our course landing page at ability
rikako and you can just type in DevOps
masters program and you can check out
all the things you have got everything
mentioned here and the earliest batch
that starts the orientation class starts
from 21st August so make sure that you
attend that so thank you so much for
attending this session I hope that you
liked it and I'll see you next time till
then happy learning</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>