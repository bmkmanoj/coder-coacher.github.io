<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Understanding Lucene Querying | Lucene Query Tutorial For Beginners | Edureka | Coder Coacher - Coaching Coders</title><meta content="Understanding Lucene Querying | Lucene Query Tutorial For Beginners | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Understanding Lucene Querying | Lucene Query Tutorial For Beginners | Edureka</b></h2><h5 class="post__date">2015-02-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6NnfwlhNNgQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">topic we are going to cover is
completely on the query so here we will
be covering various query types so the
first few things which we'll be covering
like the boolean wildcard will give us a
lot of understanding of what exactly
happens and how do we query different
documents with different variations are
the different flavors okay so let's get
into the details of it okay so the first
thing is a term query what we have seen
it so far so in all these examples we
have used something called term query in
our search so that was the reason it
exactly looks for the term and it
exactly returns the term if it matches
okay so that was the reason why you
would not you were not finding the
partial strings or embedded strings
that's the first reason so you have to
provide or specify what kind of query
type you are expecting the results to
return okay so if you use term query
which is the most basic way of searching
or default way of searching in Lucene
will return only exact matching
documents from the terms what you have
provided okay so there won't be any
partial things there won't be phrases
there won't be wildcards are anything in
the default term query search okay so
the term query all you need to do is
just save which is the field you wanted
to search and on that field what is the
term you are looking for as simple as
that okay now is it clear why you are
not finding the embedded or partial
results
if we have to go ahead and do the
embedded or partial results we have to
do very different query and also you may
have to change some of the analyzing
terms as well okay
the tokenizer also may be changed if you
have to use it
partial or embedded things okay so say
for example if you really wanted to do
the embedded search so in those cases we
may have to use the Engram tokenizer
where every token is again split into an
N number of characters so M gram is the
weight age say for example if you have
let's take it you rec example back okay
let's say you are you have a token
called ed Eureka and you wanted to
search embedded strings like say you are
e okay so in those cases you may have to
use a Engram tokenizer where you need to
specify what is the value of n so if you
say the well value of n is 3 okay so
each token will be split into
combination of three grams okay
say for example edu will be one token
okay D u R will be one token you are he
will be one token re K will be one token
ek a will be one token that is how the
Engram token will be split and then you
can search the embedded key embedded
words from the actual tokens what you
had it in the index and the engrams need
not be stored in the document but it can
be stored as the index so this is a
little bit more advanced topic which we
will be covering it in the solar not in
the Lucent since loosing we only wanted
to cover the basics and the topics which
is very important for us to understand
so we are covering engrams will cover it
in the SONA okay so next Eid
steak what is term range query so
everything remains same the only
difference is that we are asking for
particular range which matches the terms
in the lexical order so lexical order is
so any byte character in the lexical
order if it falls into that term range
it should return all the term ranges
okay and also if you notice there is
something called inclusion or exclusion
so when you provide two range of terms
say term could be of any length if I say
between a and s you return all the
documents so it would written all the
documents between and those a and s can
be either includes inclusive or
exclusive and you can provide that
including a or just exclude a and
provide after a kind of a thing okay so
all those things are possible possible
in the term range query and we will see
a couple of examples which will make it
easier for us to follow understand okay
fine
so term range queries are not intended
for numeric range say if you wanted to
query numeric range like say dates or
integers or anything which is has to
deal with numerix so you have to use it
numeric range query or term range query
okay so everything else they main same
so you might have noticed in all the
three examples there is only one thing
which is changing any guesses English
what is that on the code box
just only one thing which is getting
changed what is it yeah the query type
right so here we are saying term here we
are saying term range query here we are
saying numeric range query here we are
saying prefix query okay
so except that everything remains same
the queering aspect of it okay so the
prefix query is so now we will come to
your example you said I wanted to search
for edu and show me the edu results for
matching Eddie Ricker thing so using
prefix query you can search for partial
results okay but the condition is prefix
so only prefixed characters will be
searched not embedded embedded is
completely different and you have to use
a Engram tokenizer for that but prefix
is if you know the starting characters
you can search for those starting
characters using the prefix query okay
fine so now the wild-card is little bit
different so the supported wide
wildcards are the star or asterisk and
the question mark so the asterisk
represents it can be zero or more
characters and the question mark
designates it has to be only single
character replacement okay
say for example if I know there are some
characters in between which I am NOT
very sure you can put asterisk or star
and symbol and if you are very sure
there is only one character which I am
looking for say for example I wanted to
get all three the three character
words which are index between SEBI
question mark and t so it will riddle
say back bu T but all those kind of
things
okay so phrase query so so far whatever
we have dealt with were all term queries
when I said term it is single word it is
a single term okay it reads that entire
term as just one word so you cannot
write multiple words or you cannot
search multiple words in that particular
approach say for example if I really
wanted to try a couple of words as what
I am typing it in Google kind of a
search engine so in those cases you may
have to use something called phrase
query okay so the phrase query lets you
search for multiple words at a time and
also allows you to set a slope so the
slope is nothing but so what is the
acceptable distance between each word
from the tokens okay
say for example if you say the slope of
three between say you are searching for
french fries as a phrase query French
might be somewhere in the document price
may be somewhere in the document okay so
the distance between French and fries if
you specify not more than three if a
word is say French okay in French there
are people who like fries a lot if that
is the sentence okay and you if you had
said the slop is only three would it
find the document french fries would it
match exactly no because you have set
the slop the relative threshold is only
three and there are more than three
words in between french and fries
if
make it maybe more than 10 yes of course
it will match French fries and it would
pretend the documents okay so that is
the purpose of the phrase query so again
if you notice there is only slight
variation so you have to add all the
terms as a phrase and then pass it to
the phrase query and set the slop that's
the way of to doing the phrase query
fine so now we have seen term query
range numeric range term range phrase so
what if if I wanted to search on
multiple fields based on and our kind of
conditions right say for example I have
four to five fields in a document and I
wanted to search on those multiple
fields let's say I wanted to say if it
matches on field one it may or may not
match on field 2 those kind of and or
condition so those kind of queries are
done using boolean queries so using the
boolean query API you can say what is
required and what is not required okay
must designates and it says that term
has to appear for the document to match
at any cost
okay should occur not should say it is
optional if you are looking for that
parameter it is like optionally may
occur it may not occur just ignore it
okay if it occurs well and good if you
even it doesn't occur it's not an issue
not is basically must not is that you
only return if it does not match your
word in that document it is the other
way around so these are the three
aspects which you can use in the boolean
query and retrieve records from
searching in multiple fields
is that clear finally so all the leucine
we have seen different API is using ApS
we can just go and write code sometimes
it may be really really painful to
always go in right ApS or change in P X
so leucine also provides a alternate way
of query which is like using the query
parcel and instead of writing the EPS we
can use a query parser and the query
syntax to retrieve the data what we are
looking for
so just by writing one query parcel we
can pass him the entire query syntax and
get the results back what we are looking
for so earlier we were using the API so
now instead of using the API we are
using the query parser and writing the
query syntax something similar to SQL if
you notice name is the field and I am
looking for Eddie Ricker in the name or
name can also contain brain for signal
so either one of them if it matches
return me the document okay so this is
how the boo boolean query is done using
the query parser
okay we'll see different variations of
query parser
getting into the lab so let's see some
of the basic query syntax terminologies
okay so as I mentioned fields are the
field names has to be mentioned using or
a separator colon and thereafter you can
specify the content okay the terms are
specified without any string quotes if
you wanted to specify phrases then you
have to specify double quotes okay and
you can use boolean operators and or and
you can provide any number of fields
using the boolean operator okay so
similarly wildcard you can say the field
name :
what the text you are aware of and you
can provide a wildcard
okay so there is a restriction on the
wild-card so the wildcards cannot be
used at the beginning okay wildcards is
only after at least one single character
okay you cannot prefix a wildcard in the
beginning so similarly a range search is
used basically field name : square
bracket the value starting value to the
ending value square bracket so that is
how we use the range searches
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>