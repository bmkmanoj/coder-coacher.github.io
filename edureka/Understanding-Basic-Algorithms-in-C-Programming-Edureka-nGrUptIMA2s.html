<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Understanding Basic Algorithms in C Programming | Edureka | Coder Coacher - Coaching Coders</title><meta content="Understanding Basic Algorithms in C Programming | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Understanding Basic Algorithms in C Programming | Edureka</b></h2><h5 class="post__date">2014-08-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nGrUptIMA2s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi in this chapter we're going to go
through some of the popular search and
sort algorithms so in this chapter we
will first talk about algorithms and
then you're going to talk about the
linear search and binary search those
are the two search algorithms that we
have in this chapter and finally we're
going to talk about three different sort
algorithms namely the selection sort
bubble sort and the quicksort so we all
know what an algorithm is an algorithm
is a set of steps which accepts some set
of values as input and produces a set of
values is output now for a given problem
it's not necessarily that we're going to
have just one algorithm you can have
multiple algorithms to solve the same
problem and the algorithm you would
generally pick is the one that executes
the fastest so you say a particular
algorithm is a good algorithm or a good
solution when that algorithm is better
than the others in a door occupying less
space or is faster in execution time we
shall first take a look at the linear
search algorithm a search algorithm is
one where given a set of numbers the
algorithm has to search for a particular
number so you'll be given array with a
lot of numbers and a key element that
you want to search for and the algorithm
has to search for that element or that
number and return its position so there
are multiple ways of implementing a
search algorithm we shall first talk
about the linear search the linear
search is a simplest algorithm for
searching that's because it's very
similar to how you would search for a
number given a set of numbers let's see
how the linear search algorithm works so
let's see our array has about five
elements or five numbers so I'm going to
have 2546 10 5 14 and I want to search
for the number 5 so how do we go about
doing it manually if you're asked to
search for the number 5 of course
they're just fine numbers can easily see
this is where five is so it's in the
position number 0 1 2 3 position number
3 that's because it's right in front of
your eyes but lets you add 100 numbers
how do you go about searching you start
with the first number you see this 5 no
is this 5 no is this 5 no is this 5 yes
and you will stop here that is how the
linear search works to when you have to
write a program for it you start in the
first number keep verifying if this is
the number you're searching for no go to
the next one
no no finally you found it and then you
return this position that is 0 1 2 3
you'll return the position 3 let's say
you're searching for the number 50 then
we start searching 25 no 46 no 10 no 5
no 14 no we've reached the end of the
list and we haven't found it so it is
return minus 1 which means we couldn't
find the element simple right so if we
take a look at the algorithm - so the
same thing for each element in the array
check if the element is equal to the key
researching for if it's equal then
return the location of the element now
let's write a program to do the same we
first start with our hash include
now the function let's call it linear
search this function has to return a
number to us so it's going to turn
integer the number can be either minus 1
if we did not find the key or it would
be the position of the number the other
input is the first input is the atom so
int a or let's just say in star a then
the key element we searching for into
key and like I said in any given area we
don't know the size of the array so
instead of taking the size here we can
accept the starting index is start
searching from and the last index to
stop searching so let's say end I'm in
drama int IMAX so we're going to start
searching from I'm in go up to IMAX
which means let's say we have 10
elements in the array and we want to
search through the entire array
iemon will be 0 and IMAX will be 9 so
it's from 0 to 9
okay so how do we go about doing the
linear search we need a for loop we need
to go through an every element so int i
4i starts from i'm in i stops at I max
keep incrementing I what do you do in
the for loop you check if a
I is equal to equal to key key is the
element researching form so right now we
are the ith element we checking if a fi
is equal to equal to ki if that's the
case we just return I I freak out of a
for loop means we do not find the key so
we can just say return -1 that's our
linear search function now let's write
the main
we first need to declare the array but
in this case we're not going to use a
static array we're not going to assume
that the user is going to enter ten
numbers of five numbers none of that
we're going to ask the user first as to
how many numbers he wants to enter and
then he's going to enter the numbers so
which is going to have a empty pointer
first star a Arash
so you can this equal to null it's not
pointing to anything we then ask the
user printf how many numbers
scanf HD ampersand num so we need a none
and none to accepted numb from the user
now we need to allocate space for num
integers - ARR is equal to int star my
log num into size of int so we've
allocated space now we can start
accepting the numbers from the user save
printf enter the numbers
for I equals zero I less than none i
plus plus
scanf % HD comma ampersand a or 5 so as
you can see here ARR is a pointer to you
using it like an array because like its
it earlier other chapters arrays and
pointers can be used in a similar way so
when I use ARR of index the calculation
is similar to saying ARR plus I so you
can just say ARR of I 2 so we have
accepted all the numbers from the user
in the for loop now we have to search
for a particular element so let's as a
user to enter which key to search form
so printf enter the search key
scanf % HD let's call the variable key
so we knew in turkey and finally now we
call linear search to search for that so
linear search we have to pass the idea
of the pointer then the key then we need
to start searching from zero to numb but
it's not zero to numb it will be numb
minus one that's because if we have numb
as ten the index is actually from zero
to nine so you always pass one less and
finally linear search will return a the
minus one or the location so let's have
it as LOC equals this so we need another
variable
if LOC is equal to equal to -1 printf
key not found
else if it's any other number in deaf
key found at position percentage D
LOC +1 this is because let's say the
number you're searching for is the first
number the function linear search will
return zero to us because as a 0th index
but to the user it's always nice to show
it as one because as the first number if
its second show it as two so we always
incremented by one
finally system pause returns zero let's
now compile our program we have an arrow
it says I undeclared so you're using I
here we are not declared I let's compile
it again no errors or warnings let's run
it
- how many numbers let's say five
numbers enter the numbers so I'm going
to say 25 10:46
105 enter the search key let's say I
want to search for the number 100 100 is
the position 1 2 3 4 the fourth position
and we have a problem
so as you saw the program quit abruptly
that's because we had a segmentation
fault that is when such things happen
when you're trying to access a wrong
memory location so this is to get a
program you can see over here we doing
scanf and we're not passing the address
of key passing key itself so whatever
value we entered for key was being
stored at a wrong address which does not
even belong to us let's compile and run
this again how many numbers five into
the numbers 4625 5110 searching for the
number 100 key found at position 4 let's
try again and search for something that
doesn't exist
fine umbers 1 2 3 4 5 let's search for 6
key not fat now let's see if there's a
way to make this algorithm faster this
is the array the example that we'd
spoken Oleum as you can see the number
the not in sorted order and if I'm
searching for a particular number I have
to search every element there is no way
I know where the number could be so I
have to start searching from here go one
by one till I find it but can I make a
search algorithm faster if the numbers
already sorted so let's say I had the
numbers like 10 15 1800 250 so the
number is sorted in ascending order
in this case if I'm searching for the
number 250 what is the linear search to
we'll start here no no no no yes this is
going to go through the loop 1 2 3 4 5 5
times the 100 numbers and the number
we're searching for is in the 67th
position then it's going to iterate
through the loop 67 times can we reduce
this number do we really need to go
through the loop 67 times let's look at
a new algorithm which works on sorted
is this is called binary search it takes
advantage of the fact that the ADEA is
already sorted so once we have a sorted
array we don't have to actually go
through every element starting from the
first one let's see how binary search
works so let's take a few numbers and
it's going to be sorted so let's say 5
10 20 40 500 115 so we have a proper
sorted list and let's say I'm searching
for the number 100 if you're the linear
search what we would have done is start
from here no no no no yes so it's 1 2 3
4 5 you have gone through the for loop 5
times to be found the key we are
searching for what binary search
algorithm says is that split your list
in half find the middle element first so
how many elements do we have 1 2 3 4 5 6
so 6 by 2 is 3 so you go to the third
element this is the number of searching
form no but now we know that the array
is sorted so you can check if the number
you're searching for is greater than
this number or not if it's greater we
know the number will be only over here
if it's less than this number then the
number will be somewhere here so it's
handle greater than 20 yes that means we
know the number is somewhere in this
half of the Attic the next we need to
only search this stretch so we need to
only search this half so now we assume
this is a sub array again we repeat the
same binary search algorithm we have 3
elements or is 3 by 2 1.5 which means
let's say it's 1 because in integers you
can round it off first element we're
going to search here this is the one
we're looking for
no now the number you're searching for
the greater than 45 yes that means going
to be in this half
now again we take these two two by two
is one so search is a first element this
is the number you're looking for yes and
we found it so how many times did we
have to actually do the search or how
many times do you have to go through a
loop we first checked against 20 that's
one then we checked against 45 it's two
then we checked against 100 and we found
it that's three times so already for
five numbers instead of going through
the loop five times we went through it
three times so if you have 100 or
thousand numbers the average case where
a binary search is much faster than the
linear search so let's just look at the
algorithm the algorithm is similar pick
the middle index I made of the array if
the element that I made is equal to the
key we're searching for then we return
that index if the key is less than the
element at the middle then repeat the
process for the sub array from I mean
till the middle element that I made
minus one if the key is greater then we
repeat the process for the sub array I
made plus one tool I max let's go ahead
and write a program for this now so
let's start with our hash include'
next a binary search is going to be
similar to the linear search as far as
the function declaration goes so int
call it binary search it needs an array
as input to that needs the key we
searching for then you need the I MN and
the I max the starting index and the
ending index
okay so what do we need to do in the
binary search we first need to calculate
the middle index so let's have int i mid
I melt is equal to I'm n plus I max
divided by two once you've calculated
the I mid we need to check if that is a
key element the researching form a of I
mid is equal to equal to KI if that's
the case we return
IMed if that's not true then we need to
check F key is greater than a of I mid
key is greater than a of I'm int then
what do we need to do if T is greater
that means we need to search in the
right half so we research from I'm 8
plus 1 to IMAX so which me I'm in
becomes I'm 8 plus 1 so we say I'm in is
equal to I meant plus 1 because we
always searching for I'm in to IMAX
so we first start from 0 to let us say
10 0 to 9 that is and we found that the
middle element is smaller than key
Sookie has to exist in the right half so
I'm in becomes I'm 8 plus 1 we again
search from I'm in to IMAX we should
keep repeating this loop we'll see how
finally else you don't need an F over
here because key is not equal to a of I
made or it's not greater than that mean
it is less than so we can say else IMAX
equal to I mid minus 1
again we turn the loop from we run the
loop from I'm in to IMAX so now we need
to repeat this thing in a loop how many
times we don't know how many times right
but we know one thing that at every
point either Ayman gets incremented or
IMAX gets decremented at me at some
point I'm in an IMAX will be the same or
IMAX will be less than Ayman so this
loop stops when I'm in is greater than
IMAX so it means we need to keep
repeating this while I'm in is less than
equal to IMAX so we know the I'm in has
to be smaller than IMAX or equal to IMAX
if I mean is equal to IMAX means we have
one element in the array or one area to
search for but once I'm in is greater
than IMAX there's nothing to search for
so this entire thing is repeated in the
loop
and finally if we are the loop we do not
find the number so we say return minus
one so now what we need to do is write
the main the main is going to be exactly
same as a linear search main so I'm just
going to copy paste it here paste it the
main from linear search all we need to
change is instead of calling linear
search we're going to call binary search
the argument that we paths are exactly
the same now let's try and run this
program let's compile it
no matter the warnings run enter number
of numbers let's say 5 enter the numbers
now remember for binary search to work
the numbers have to be in sorted order
and in this case it has to be in
ascending order so let's give the
numbers at 10 15 16 30 50 now let's say
I want to search for the number 10 key
final position 1 which is correct so our
program works and from theory we know
that the average case for the binary
search is better than the average case
for the linear search now we have seen
two important search algorithms let's
look at a few sort algorithms sorting
algorithms are simple the purpose of the
sorting algorithm is to sort a given set
of numbers so we shall first look at
something called the selection sort the
selection sort is very similar to how we
as humans might try to sort numbers
let's see how that works so let's say I
was given a set of numbers I'm just
going to take random numbers
if someone were to ask me to sort this
how would I go about doing it if I were
sorted in ascending order
I would pick ten is a small list so I
would put ten separately then I would
see 15 as the next then I see 45 then I
see 50 and then I see hundred and it's
sorted so every given time I pick the
smallest number and store it separately
so that me I selected the smallest
number and then copied it this is why
it's called selection sort because any
given time you select the smallest or
the largest depending upon what they
doing ascending or descending and then
store it separately but in the selection
sort algorithm instead of storing it
separately we will store it within the
same array because if you have to copy
separately we need a new added instead
of doing that we store it within the
same array how do we do that
it's simple so when I go through this
list I see ten is the smallest all I
need to do is ten being the smaller it
has to go into the beginning of the
array so I swap ten and forty five so
you get 10 over here 15 stays here 150
forty five so now I'm sure this is ten
the position for ten so I don't care
about this next I search from here
onwards I search for the smallest number
starting from here I know 15 the
smallest number so I leave this as it is
next I start searching from here so it's
very smallest number fortify the
smallest we swap 45 and the first number
in this list that's 100 so you get 45 50
100 next you start from here in the
right position and you're done and
that's your sorted list
so let's see how do we write a program
to do the same as you can see the
algorithm here - it's simple find the
smallest element on the list swap the
element with the first element on the
list repeat the same for the rest of the
elements so as usual we start with hash
include stdio.h
now we're going to write the selection
sort the selection sort algorithm does
not have to return anything to us so
it's going to be avoid let's say select
in sort it's going to accept the array
and again we have to say from where to
wait from where to start sorting so int
I'm in and the ending of the array int I
max okay so the first thing we need to
do is have a loop to go through every
element the logic is simple at any given
time we start the loop from here we see
which is the best number you'll fit in
this position we found the ten fits in
this position we put it here next we go
to this position we see which is the
best numbers will fit here you know 15
next we go here what is the best number
I'll sit here we realize 45 and so on so
we need to have a for loop starting from
the first position till the last
position at every given time we need to
find what is the smallest number left on
the list and copy it to that position so
we have four I equal to I men I is less
than equal to I max I plus plus so I is
keeping track of the positions so I in
the beginning starts from I'm in which
in our case mostly will be zero so I is
equal to zero so now we need to see who
will fit into the 0th position for that
we need to find the smallest number in
the entire array so let's have a
function called small this sum is going
to call a function smallest a comma I
comma I max
so this function smallest takes the
added a and find the smallest number
starting from index I until I max so in
the beginning index I is zero so we'll
search for the smallest number from zero
to I max next time I will be one will
search from index 1 to I max because
position 0 we already found the smallest
number now we need to find the smallest
number between index 1 and the maximum
index then next will be from index 2 to
the maximum and so on so the function
smallest will return the smallest number
to us in this case we need the index of
the smallest number so we can swap it
with the current position so we say I
small we need another integer so once we
have this we need to swap it so we say
swap
if you remember in one of the previous
chapters we had written a swap function
where we had to pass the address of the
two variables which you want to swap so
we can do the same here or simpler way
is we already have a pointer we pass the
whole array and we pass the index of the
two areas that we want to swap let's we
want to swap I with I small and just to
make it more efficient we want to swap
only I and I smaller not the same so we
can just say if I is not equal to I
small then we do the swap
and finally we end the for loop so the
hold for loop goes from I'm into IMAX
and for every point we check which is
the smallest number starting from that
point and we swap it now we need to
write the two functions which is
smallest and swap let's start with
smallest smallest has to return the
smallest index to us so int smallest
takes the array takes the starting index
and the ending index
so let's end small equal to
I'm in
we are for I equals I'm in plus one
because you already have put the
smallest index at I'm in crazy I am in
plus one Chile we are supposed to put a
of I'm in plus 1 I is less than equal to
I max I plus plus if small is greater
than a of I then small is equal to a or
Phi
so if you can see this program is very
similar to find the largest number
program we had written previously in one
of the chapters but in this case we
don't want to return the smallest number
we want to return the index where the
smallest number is in the added so
instead of storing the number itself in
the variable small we're going to store
only the index we can return the
variable small which will be the index
so here the check would be for a of
small is greater than a of I then small
is equal to just I and finally once we
done with the whole follow you can just
say return small
we have forgotten to declare I so we can
say in Thai that's our function smallest
the other thing left is the function
swap it does not have to return anything
so void swap takes the array it takes
the two index is to swap so let's say
int index 1 comma int index 2 let's have
int temp temp equal to a Arash of index
1 ARR of index 1 is equal to AR AR of
index to of index 2 is equal to temp and
we swap the two positions so we're done
with the swap to what's left we just
need a main which is going to copy the
main from the previous programs because
we have to again take in numbers the
only difference is we don't have to ask
the user for a key
we have edges except numbers from the
user and then finally sort it so let's
just copy paste from the previous
program so we're done with this let's
paste our main all these things remain
the same how many numbers enter all the
numbers we don't need a key because
we're sorting the numbers you're not
searching finally our sort normal return
I think we just need to call selection
SOT and we pass three arguments that is
a starting index ending index and the
array itself and finally just to check
if we've sorted it we need to print the
entire adding so we will have a for loop
again so printf the sorted array
for I equals zero I less than none i
plus plus printf percentage t /n we have
ARR of I and that's it let's save this
program let's compile this program and
we have an error error says conflicting
types for swap this because we have the
function definition swap here but we
haven't declared the function but if you
remember we also haven't declared a lot
of other functions is because if you're
using the function after the definition
it's fine but if you using the function
before it's been defined then it's a
problem so here we're using the function
small list and swap with being defined
later
that means the compiler will not know
what the parameters for the function are
like so we need to declare it so let's
have the declarations into smallest
takes an int star int + int devoid swap
in stash int int let's try compiling the
program now no errors or warnings can
run it how many numbers you're going to
say 5 and enter the numbers let's enter
it in reverse orders 5 4 3 2 1
this will be the worst case the sorted
list is 1 2 3 4 5 there you go let's try
again with something else five numbers
is going to enter 45 120 67 120 45 67
100 then we have the sorted list so this
was one of the simplest sorting
algorithms because very similar to how
we as humans might try to sort numbers
when it's given to us let's look at the
next sorting algorithm in this slide
we're going to talk about quicksort when
an average quicksort is faster than
previous sorting algorithms the worst
case in general is kind of similar to
the other sorting algorithms but on an
average case quicksort is supposed to be
faster let's take a look at how
quicksort works
the idea behind quicksort is simple
you're given a set of numbers so let's
say 2010 45 30 the idea behind quicksort
is to divide this entire array into two
halves such that all the numbers in the
right half are greater than all the
numbers in the left half by doing so if
we sort the right half separately in the
left half separately and you join the
two halves you don't have to do anything
much after that as soon as you join them
you still get a sorted at it so you want
to divide this array in such a way such
that all the numbers in the right half
are greater than all the numbers in the
left half
so how do we do that in case of a
quicksort what we do is
a number called the pivot number it can
be any number in the atom so in our
algorithm you generally pick the first
number simpler we just take the first
number as them pivot let's call it P now
they're going to perform the
partitioning around the pivot number
that is we need to find all the numbers
less than 20 and move it to the left and
all the numbers greater than 20 will be
moved to its right simple right so we're
going to have two counters you're going
to have I starting from here and J
starting from here so all the numbers
less than equal to 20 should stay on the
left hand side so we will not do
anything but any number greater than 20
should move to the right side so I will
keep moving till we find a number which
is greater than 20 because 10 is less
than 20 we don't need to do anything
about it it's already on the left hand
side but as soon as we find something
which is greater than 20 it needs to be
move to the right side so we keep moving
I till we find the number greater than
20 this is not greater than 20 this is
greater than 20 size stops there
similarly all the numbers in the right
side have to be greater than 20 so
anything less than 20 will have to be
moved to the left side J is less than 20
no so we move J to one step 5 is less
than 20 yes so now what we do is we swap
these two positions so 5 goes here and
40 goes here so what you get is 20 10 5
40 30 this is our pivot this is I this
is J once you've done this swap we again
continue the process J needs to keep
moving till we find the number that is
less than 20 so J will stop here
similarly I needs to keep moving till it
finds a number greater than 20 so I is
going to stop here now I is greater than
J so we shall not swap these two wheels
stop the process now all we need to do
is swap J and uh pivot B this is because
as soon as we do this all the numbers to
the left of a pivot 20 will be less than
20 and all
numbers to the right are greater than 20
as you can see here 40 and 30 greater
than 25 and 10 are less than 20 so all
we need to do is insert 20 here but
because I raised instead of inserting
we're going to swap so you're going to
have 5 10 20 40 30 so this was our pivot
so as you can see all the numbers to the
right of the pivot are greater than 20
and all the numbers to the left of the
pivot are less than 20 now that we're
done with this we can repeat the exact
same process for the sub arrays on the
right and the sub arrays on the left so
second recursive call fill entire array
we picked a random pivot number and then
divided it such as all the numbers to
the right are greater than it and all
the numbers to the left I greater than
now that'll be done with that division
we again continue the process for all
the numbers to its light and all the
numbers to its left so when you repeat
this process automatically both the
halves get sorted this side is anyway
sorted this side also what will happen
is you repeat the process you start with
pivot over here you started I over here
and J over here you keep moving
I till you find a number which is
greater than the pivot 40 this is
greater than pivot no but is the end of
the iris you can't move it anymore you
keep moving J till you find a number
which is less than 40 which is here now
again I is not less than J the power
same so you don't do anything all you do
is swap the pivot n J so you'll swap
these two she'll get 30 here 40 here
automatically sorted this sub array this
sub array will also get sorted or in
this case already sorted and you have 20
here and you have the entire sorted
array
let us now see how we can write a
program to do the same as usual we
should start with Ashe include stdio.h
now the first thing you're going to
write is the partition algorithm the
partitioning is supposed to take gasps
is that all the numbers in the right
hand side are greater than all these
numbers on the left-hand side so let's
have function go partition which will
take the array and it would take the min
and the max
so for doing the partitioning like we
saw in the diagram we need to first pick
a pivot so we shall have int pivot as I
mentioned we're going to pick the first
number as a pivot itself so pivot would
be equal to a of
iemon we then need our counters inj so
we going to say i equal to i'm n plus 1
starts from the next number and J is
equal to I max into play I NJ so you've
gotten all our counters in place now
what we need to do is move I until we
find a number which is greater than the
pivot so while a of I is less than pivot
instead of checking against pivot pivot
is just going to have the index and so
we shall check a off pivot this is
required because we need to swap the
pivot also later so we need to know the
position so a of I is less than or equal
to a of pivot we do I plus plus so as
long as a of I is less than or equal to
a of pivot we just keep incrementing I
as soon as we find a number which is
greater than the pivot we stop so is
pointing to that also we will make sure
that I does not go across the boundary
so we'll just say and I is less than I
max this is to just make sure we do not
go beyond the boundary of the array
similarly we need to keep decrementing J
so while a of J is greater than a of
pivot we do J minus minus so J stop as
soon as I find the number which is less
than the pivot so now we have both I and
J what we need to do is if I is less
than J we need to swap the two numbers
if I is less than J this a swap a comma
I comma J
now if I is not less than J what do we
need to do that means get done finding
the pride position for the pivot so all
the numbers to the right hand side are
greater and all the numbers to the left
hand side are smaller all we need to do
is swap the pivot with the jth position
so you say swap a comma pivot comma J
and we're finally going to return the
position of the pivot which is the jth
position so now that you've done the
swap the pivot number has gone to the
position J C which is returning the
position where the pivot has moved which
is return J so the partitioning has
happened on both sides of the pivot on
the right hand side of J all the numbers
are greater than the pivot on the left
hand side of J all the numbers are
smaller than the pivot
so the function partition is basically
going to partition the array and return
the index where the partition has
happened so we're turning J so this
simple now if I is less than J we swap
but the algorithm doesn't end there we
need to continue again again we need to
move I forward and J backward and this
needs to go on till I becomes greater
than J so all we need to do is have the
entire thing in a loop while one
so all this scroll into the loop
so this is an infinite loop it doesn't
matter to us because we need to keep
repeating I and J as long as I and J are
this is an infinite loop it doesn't
matter to us because we need to keep
incrementing I and decrementing J until
I is greater than J so once I is greater
than J we swap J with the pivot and then
return from the function so we won't
actually get stuck in this infinite loop
because you're going to return out of
the function over here so we have our
partition function now we're going to
actually write the quicksort function we
have a void quicksort and star a comma
int I'm in comma int I max we need to
actually solve the algorithm only if I -
less than I max so if I'm n is less than
I max what do we do we first have to
partition it through say partition a
comma I'm in comma I max another
function partition will return the index
cross which it is partitioned so let's
say J equal to partition so now we know
all the numbers to the right hand side
of J are greater than J and all the
numbers to the left hand side of J are
smaller than J but that does not mean
the numbers to the right half in the
left half are sorted we just know
they're greater or smaller but they
haven't been sorted yet so we need to
sort those two using the same method so
we're going to call quicksort again
quicksort a comma
now we need to sort the left-hand side
separately which is I'm in comma J minus
1 because J is in the right position we
don't need to worry about whether J the
element is it is in the right position
in the array
so we sought left-hand side of Jay and
the right-hand side quicksort a comma J
plus 1 comma IMAX so this one sucks all
the elements from beginning until J and
this one sorts all the elements from
after J until the end of the array now
we're done with the quicksort algorithm
- let's copy and paste the swap and the
main these two don't change we just can
declare it then let's try and compile
this program we have an error the
undefined reference to bubble sort
oh yes we forgot to change the main we
need to call quicksort now let's compile
it again
let's run the program enter five number
let's say five numbers I'm going to
enter them in reverse order and it works
let's try again
how many numbers five again I'm just
going to enter them in the sorted all
itself and it works again now let's try
some random set of numbers five numbers
I'm just going to say 1250 32 115-112 13
32 50 and as a last try we can just try
some numbers which repeat themselves so
we say ten twenty ten thirty ten and
that's sorted too
so this is our quicksort algorithm let's
just take a quick walk through it's
simple all you're doing here is making
sure I mean is less than I max because
like I said for every recursive function
we need to have an ending point in this
case as soon as I mine as soon as I'm in
becomes greater than I max we will quit
the recursive function until then if I
am in a less than I max we first find
the partition so what partition actually
does is fix a random pivot number in
this scale it takes the first element as
a pivot number and then it partitions it
in such a way so that all the numbers to
the right side of the pivot are greater
than the pivot and all the numbers to
the left hand side of the pivot are less
than the pivot so that's what this
entire while loop does I will explain in
the diagram we keep incrementing I
degree menteng J and in swap i NJ and
finally we swap the pivot ng so your
partition make sure that once we return
J all the elements to the right hand
side of J are greater than the element
of J and all the elements to the left
hand side of J are lesser than or
smaller than the element at J so we
complete the partitioning and we
returned the index by the pivot element
is now once we know that J has been
partitioned correctly that means the
element IJ is in the right position so
once you sort the entire array whatever
element was a J it does not have to
change its position because we found the
right spot for that particular number
all we need to do is sort the left hand
side of this and the right hand side of
it separately so now we say quicksort
again for the left hand side that's I'm
into J minus 1 and for the right hand
side there's J plus 1 to I max so that
is our quicksort algorithm so finally in
this chapter you've learnt the various
search and sort algorithms and you also
learn the advantages or disadvantages of
using these algorithms
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>