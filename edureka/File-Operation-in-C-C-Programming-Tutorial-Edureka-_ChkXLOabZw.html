<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>File Operation in C | C Programming Tutorial | Edureka | Coder Coacher - Coaching Coders</title><meta content="File Operation in C | C Programming Tutorial | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>File Operation in C | C Programming Tutorial | Edureka</b></h2><h5 class="post__date">2014-08-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_ChkXLOabZw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi in this chapter we're going to talk
about the various operations we can
perform with files all this while all
the programs we wrote the data was
stored in memory so once a program
finished all our data was lost but let's
say you want to store the data
permanently like you take a student
database the student joins you could
have got added to your linked list but
once your day is over
you want to copy all the data into a
file you don't want to lose the data
permanently let's say your system
crashes or something like that the new
mages lose all the data right so you
need to permanently store it somewhere
on your hard disk so in this chapter
we're going to talk about the various
operations that we can perform with
files so when you work with files there
are three basic operations you need to
perform first you need to open the file
then you can perform any kind of
activity or operation you want that is
read or write etc and then finally once
you're done you need to close the file
now to keep track of what you've done
with the file let's say the last byte
that you wrote to the file or the last
location the file that was written to or
the last location the five from where
you read etc you need some kind of a
data type which keep the step tracking
for you so this spatial data type is
called file it's all in capitals it's a
special structure that has already been
defined in stdio.h so how do we make use
of this data type
let's see firstly you need to open the
file so to open a file you use the
function f open the function f open
takes the name of the file as a first
parameter and the second parameter is
the mode the mode can be our W or a our
says you're going to open it in read
mode so you can only read from the file
W says you can write to the file and a
says you're opening the file in append
mode that is writing to the end of the
file so once you open the file the
function f open with it or no handle or
a pointer to you that handle or pointer
is the type file start also the file
name that you pass over here can be an
absolute path name or the relative path
name let's the file is in the same
folder as where your program is sitting
then you can just pass the filename as
it is but let's say if it's in some of
the folder then you may have to pass the
absolute pathname which is starting from
C colon slash ABC slash so on and let's
say the finally specify does not exist
or for some reason F open is unable to
open the file in that case F open return
our null to you so if I pull so if F
open returns null you know there was
some problem opening the file and
finally let's say you want to create a
new file you can still use F open to do
the same call F open with the mode of W
and if the file does not exist it will
create the file and open the file and
keep it ready for writing so that's F
open so we've done the first task that
is opening a file now the next thing you
generally do is either read some data
from the file or write some data to the
file there are multiple functions that
are available to help you do that in
this slide we're going to talk about the
gate C and the put C we get C simple it
gets a single character from the file so
you need to pass the file pointer which
was returned to you by F open F open
return or file pointer you pass a file
pointer to get C it will get a single
character so if you keep calling get C
multiple times the first time it will
get the first character the second time
it will get the second character and so
on and finally the character that gets C
reads from the file is returned to you
similarly put C is used to write a
character to the file so the characters
see over here is written to the file
which is pointed to by the file pointer
FB so get C n put C a simple gets you
will read one character at a time and
put C will put one character into the
file now where in the file it needs to
write to is already being kept track off
by FB within FB it knows the last
position at read from so when you call
get C and read the first character the
next time we call get C it knows it has
to read the second character and then it
has to read the third character so on
similarly put C also keeps track of
where to write to the file the first
time when you write it rise to the
starting on the file second time you
call put C will write on the second
bite the third time you call will right
at the third position and so on so this
file pointer FP keeps track of where
you'd last written or where your last
read from the file and finally the last
operation once you're done with all the
reads and writes is to close the file
you have a function called F close you
just pass the file pointer and sure
close the file for you playing around
with files or file operations are pretty
simple
so let's now write a program which is
going to read a given file and go and
print all the content of the file on
your screen let's see how we're going to
do that so the first thing as usual we
need a hash include in the file
operations all the functions are part of
stdio.h we are int main ok first thing
we need to do is open the file and F
open return a file pointer so we need to
store the file pointer in a variable so
we need to declare a file pointer let's
call it SP now you can say FB equals F
open we need to give the file name and
the mode they both are strings the mode
in this case is going to be read mode
because we just want to read from the
file and we're going to write it to the
screen so we can open it in read mode if
you open a file in write mode will just
say W so this is going to open it in
read mode now let's say the file I wanna
open is test dot txt so as the name of
the file given that so f open will open
the file test or detection read mode and
return the file pointer which will be
stored in FB now what do I need to do I
need to read the file and print it to
the screen so simplest thing I can do is
read one character at a time and keep
printing that one character to the
screen so to read a character you have
get C and I just pass the file pointer
he will return the character to me so I
need to store the character so I see CH
so I need out - CH
now once I have the character as you
need to print it on the screen so I'd
say printf % HC CH
so now we've printed the first character
from the file on the screen we need to
keep repeating this to print everything
till the end of the file so how we do
that is let's have a do-while loop so
how do we know when to stop reading from
the file
when you reach the end of the file gets
e will return a macro called a or F so
if CH is equal to EOF which stands for
end of file then we stop reading we say
well CH is not equal to EOF so as long
as not equal to EOF you can keep getting
a character and printing it on the
screen finally we just print one more
flag slash n before we call system pause
return 0 so that's a program it's as
simple as that we getting a character
and we printing it on the screen there
is one thing that we forgotten to do
that is close the file so once we've
done with all the read operations we
just need to close it so we say F close
FB and we're done let's save this and
compile this program and see if there
are any errors compiled and we have an
error that's because we forgotten
semicolon off the do-while loop let's
compile it again no errors or warnings
so now before we run this program we
need to create this file called test or
text and write something into it let's
do that
okay so let's say hello world write
multiple lines how are you
some random letters and be good to go
let's save this now let's run our
program there you go you got hello world
you got how are you you got the jumble
random letters and finally press any key
to continue so then not a small mistake
in our program that we haven't taken
care of which is F open can return null
if the file did not exist so let's say
test or text should not exist this so
I'm going to create it for us because
we're opening it in read mode which case
will return null and if FB is null if
you try to say get c null it can cause
problems so we need to take care of that
so every time you open you to check
whether it is able to open the file if
SP is equal to equal to null then you
just print unable to open file
system pause return
now we already have test or take so
let's try and open test1 dot txt and see
if our printf comes
compile no errors or warnings rerun they
unable to open the file we have test dot
txt it works magic there you go
now we're going to make a small
modification to this program
instead of using printf I'm going to
call put see we have seen on this slide
that put see puts a character to the
file so you can put the character here
to see CH is a character and now where
you want to put it we want to put it to
the screen this screen has a special
file handle which is called STD out
standard out so if you want to bring
something to the screen you can always
print it to STD out STD out is your file
pointer for the screen printf by default
prints it to STD out
similarly can be used to to put
the to put it to the screen so we're
going to remove printf now we have put C
CH - STD out let's see if this works the
same no errors or warnings there you go
we have the exact same output so now you
know the special file handle for your
screen is STD out so you don't have to
open STD out separately or you don't
have to open a file for your screen you
just start writing something to STD out
it will come to your screen
so we had said earlier that can be
used to put a character to a file and
here we are putting it to STD out which
is behaving like a file now instead of
STD out let's say it given another file
pointer say FB - and let's call this FB
one we're just going to change
everything in the program so we have FB
1 ok so if I said put C 2 FB 2 that
means what is the character I read from
FB 1 will be copied or written to FB 2
then automatically this program will
work like a file copy program so I read
something from test or text and I can
open another file let's say FB 2 is
equal to F open I say destination dot
txt and we can open this in write mode
so I'm not going to create the file dest
dot txt because I'm opening in write
mode if it does not exist
f open will created itself if there is
an arrow
and we'll just say just take this bring
the arrow finally close this so now I
have opened test or text in read mode
I have opened dest dot text in write
mode so I'm reading from FB one which
stressed our text I get a character CH
and I put the character CH into FB 2
which is desktop text so now what should
happen is at the end of the program
there should be a file called dest dot
txt in my folder and if I open that file
in notepad I should see the contents to
be exactly the same as test dot txt so
similar to how you do a copying write
you copy a file from one folder to
another it copies the contents of the
file that's exactly what we're doing
here let's see if this works let's
compile it we have an arrow ok that's
because we haven't declared FB - so we
need FB - it's compiled still have an
arrow
if that is because if p2 is supposed to
be a pointer we miss that out now let's
compile it no errors or warnings let's
run the program it did not show anything
on HDD out because we're not printing
anything to the screen now let's open
our folder and see if we have a file
called desk dot txt so in notepad let me
go to open then I have a desktop text
let's open this and then the contents
are exactly the same as test dot txt let
me open test dot txt to there this test
or text in the desktop
text contents are exactly the same
except for one small problem which is in
the end we have this one some special
character here I wonder why that's
coming let's look at our program and
this is because we have a do-while loop
so what will happen is when it reads the
end of file character so getsy will
return end of file and it's not supposed
to put the end of file character it's
just supposed to indicate to us that we
finished reading but we still printing
some character to s p2 which is wrong so
we are not supposed to use a do-while
loop in this case so we're going to say
while CH is not equal to EOF
you're going to keep doing this now
there's a shorter way of writing the
same we can just see CH equal to get see
FB 1 is not equal to EOF so within the
while loop itself we first call get see
as I add to CH check if is not equal to
EOF is not equal to EOF we say put C now
let's try that again
now this time I'm going to copy it to
test1 dot txt let's compile it no errors
or warnings run it we're done let's open
a notepad the desktop text let's open
test1 dot txt and there you go you don't
have that vo special character the end
it ends with this which is exactly the
same as test dot txt there you go
so many of these small bugs that we
created me writing programs can be
easily rectified when you know your
program really well as to what it is
doing so when you see a special
character they I automatically knew that
I'm writing an extra character and I
could've written an extra character only
because the while loop the while loop is
doing one character extra so simple if
you know your program really well you
can debug your problems very easily so
we have now seen how to write a program
to copy the contents of one file to
another</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>