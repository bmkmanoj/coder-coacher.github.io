<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Design Patterns : The Ultimate Blueprint for Software | Edureka | Coder Coacher - Coaching Coders</title><meta content="Design Patterns : The Ultimate Blueprint for Software | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Design Patterns : The Ultimate Blueprint for Software | Edureka</b></h2><h5 class="post__date">2015-03-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Otz5vFBfzyc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I am an enterprise architect with about
11 years of experience in the intro
voice enterprise wide application
development a span majority of my time
in building maintaining evolving and at
times replacing java ee based
applications but at heart I'm a designer
of software systems and more complex
system is merrier it is for me sharing
knowledge and experience to do is going
to accept as my passion and it helps me
grow it tells me grow because it
reinforces my knowledge but most
importantly it exposes me to bite my
writer brains like you who will probably
share their experiences their troubles
and pain points with me and therefore
this course the design patterns is our
opportunity to collaborate interact gain
knowledge and today we are going to see
and feel how the training course is
going to be like before we start a quick
note if there are questions queries you
may want to put them in a chat window
and the time permit I'll be able to
answer them at the end of our webinar
with that let us begin at the end of
this session we should be able to
understand and appreciate the need of
design patterns we should be able to
build some flexible design using select
design patterns we will look at the uml
diagrams what they are why what would
use them
we will look at the abstract factory
pattern dobbs of a pattern and the
mediator pattern so let us understand
what a pattern is when you are seeing my
screen you will see there are some
diagrams in the sequence and some of us
might have played with these kind of
questions and trying to figure out what
is the next number or diagram or an
alphabet this is a very general problem
statement in the in the worlds of
aptitude tests and this is how and
therefore ability to figure out the
pattern is is a crucial one now the the
pattern that we have on the screen here
is a solution one of the characteristics
of the pattern or that are that they are
easy to recognize right and we see them
all the time we just need to observe and
you will see the patterns and the real
life everywhere you look at it and thats
makes them very powerful because their
observable easily observable the other
people can also appreciate it and deduce
certain logic based on it moreover
patterns come in handy because they are
answers to some recurring problems and
because the problem is recurring its
best-known solution that is pattern is
also recurring so you will see the
yellow highlighted numbers are or
diagrams are the are the next in the
sequence because we were trying to
identify a pattern since all of us here
are some sort of software developers the
next question would be other patterns in
the software development there are
problems in the development can be
figured out
some recurring solution to these these
problems and the obvious answer is yes
and it not only just plain simple yes it
is oh definitely yes and we should
consider using those patterns because
they are recurring solution they are
very well understood by the industry and
industry has also analyzed them for
their weak points and the strong point
where should we use them on the context
of the problem and the constraints that
is what can we do or not do with those
patterns here comes our our pioneers in
the space of design patterns on the card
Gang of Four and they were one of the
first ones to catalog the design
patterns now note this these gang of
four guys did not invent the patterns
they just analyzed the existing systems
and draw commonality and catalog them
that is listed them as the design
patterns and it was a groundbreaking
book the one that they wrote because it
changed the way we think about short
threads and we then started saying okay
so if we know the problem statement and
there if there is a match we can very
well pick up a design pattern from the
catalog and and solve the problem and we
don't have to bang her head or to figure
out how do I solve it and also meet all
the constraints and make it maintainable
so before I move on to the next slide
note their faces how's my house how
happy they seem to be so importance of
the design patterns well one of the most
important part in design patterns is
industry experts understand them and so
can you are in my peers and it brings up
a common language for people to talk to
each other when they are talking about
software development
they also are based on in recent time
something called object-oriented
programming paradigm which is the most
popular mythology of developing the
software but it also comes with a a
downside a downside is that many
programmers and sometimes even designer
falsely assume that design patterns and
object-oriented paradigms are one and
the same but they are not in general
patterns and then design patterns and
nothing to do with a specific kind of
programming paradigm in this case
object-oriented because object-oriented
is more prevalent therefore the design
patterns for object-oriented world are
more prevalent most importantly these
design patterns are tried and proven
solutions to programming problems the
problems that require and if we choose
to implement a particular design pattern
to solve a particular problem it
guarantees us that the next person was
going to maintain the code under
standard because they will be able to
understand the design pattern and we
also know the weaknesses and strengths
of those design patterns so should the
context change we will be really looking
at the design pattern and say whether it
is still ok to use or should we switch
it toward or swap it out in favor of
another design pattern today we are
going to look at a use case on a problem
statement or we are going to say that
let's there let there be some sort of
factory a factory which which consumes
the raw material and produces the
finished good that factory could be a
cement factory or a pickle factory or a
cheese factory even a chocolate factory
if you like the factory is going to get
some material some raw material there
would be some automated machines that
keep
of the speed the temperature the
ingredients and all and the data
captured we use the data is captured
using sensors various sensors employed
in this automated system and these
sensors are going to send their input to
the master control system the master
control system will look at those sensor
values and operate on the data that
operate on the data decide what action
to take and then action is related to
something called actuators which may
change the temperature may change the
mixture proportion these machines
operate in coordination if one of the
part fields the operation is kind of
cannot be completed so there needs to be
communication between these entities in
your factory for example temperature
sensor talking to the master controller
and master controller talking to maybe a
furnace an electric furnace to either
lower the temperature or increase the
temperature a real-world scenario
question will be how can we build this
automated system so we will continue
with this use case and requirements we
are saying that let there be different
entities that are monitoring data
generated by the sensors each entity can
take its own decision on data as well as
inform to other for example a
temperature sensor may display it to a
human operator as well as send that data
to the master controller and there is a
master management control room where the
commands for two different entities are
generated which is soldiers which is
solely responsible for the good and safe
operations
and the data is from the entities is
also sent back to the master management
control room where it is processed and
actions can be taken in some cases even
the audit logs can be generated with
that moving on here is the general
depiction of how the solution would look
like there could be packaging entities
the master management control the
catalyst control and the chemical
control entity and you see these blue
diamond they are actuators so all these
bubbles are gonna operate on actuators
and there's yellow rectangles or sensors
who are gonna send data to these bubbles
if you look at it the master management
control is a central entity which is
responsible for the operation of this
factory where are the three other
entities which are separate domains some
handling chemical composition catalysts
and packaging but it is the master
management controller system which
orchestrates various operations in this
so this is going to be a general
depiction or we will then come to how a
non object-oriented world can program it
they will probably go by procedural
system and they will put all the
functionality pertaining to management
control into something called the main
function and the main function may have
certain other helping procedures or
child procedures or subroutines which
allow me into segments it works well it
may solve your problem but it may be
hard to maintain what happens for
example the catalyst composition
needs to change you'll have to figure
out the exact procedure where it needs
to change go update that procedure we
compile your code test it out and then
deploy it into a production system now
the the challenge here of the procedural
system is that it thinks like human
brain you know I walk up the stairs if I
need to go to let's say a third floor I
know that I have to walk up to the pace
of the staircase or at the elevator area
and do a next step maybe start climbing
up or requesting the elevator based on
what we choose to do and so on and so
forth essentially a procedural language
is more like one looking it from a
single point of view in this case if a
human needs to go to third floor human
will start thinking what he needs to do
and not what environment what needs to
happen in the environment that he is
living in such procedures would be good
if you are building a very small
application may be something that
accepts the data in the single form in a
web UI but this cannot scale when we are
talking about complex enterprise wide
applications especially those
applications who are to be which are to
be maintained for let's say five to
seven years in fact what ends up
happening if you write procedural
programming there is you write a lot of
spaghetti code and therefore in general
one would want to move into the
object-oriented paradigm where each
entity is represented by an object or
set of object and that allows you to
maintain the program in the long run
here comes the object-oriented world's
kind of introduction with any technology
it's not going to solve all your
problems just by using it one has to be
a little more intelligent as to find out
how to to use it
there is an old saying which goes like
the one who has a hammer thinks that
every problem or everything is an L we
will be doing good if we remember that
we don't own a hammer and if we hold an
own hammer but every problem is a knell
you don't have to use the same old stuff
to solve any new problem then what
problem should we be solving by having
that hammer or in this case having some
known solutions that's where need of
understanding design pattern comes in so
talking let's talk a little bit about
object oriented on the slide an
object-oriented program or may take a
master control master manager management
control unit in a one object and
subsequently different entities are
different objects and you one would want
them to talk to each other to achieve
certain use kiss so as rightly noted
there um once we have identified the
objects the only remaining part is to
find out how they will talk to each
other communicate to each other a to do
achieve a same common goal in this case
the use case that we talked about when
we look at it we definitely know that
there is something missing and what is
what is it missing well how about a
change required because there is a new
research coming in or how about I want
to scale up my apple application in this
case for example I want to increase the
unit production per day of my factory in
the software world that will mean how
can i make my application run faster and
most importantly which is the life of
any software it has to evolve because
the business needs change and sometimes
we add functions or features to the
existing
existing software let's say in case of a
cement factory I want to change my
packaging from a 50kg back to maybe a
10kg bag or and I also want to let say
change the material of the sack in which
my cement gets packaged in so in the in
the life of a software it is important
to understand initially that a code
needs to be maintainable if I may share
with you some statistics it is very
likely that a software application will
spend eighty percent of its life time in
the maintenance mode where you know you
are just making sure that the software
survives in the production perhaps we
spend about ten to twelve percent of the
time designing a system and only maybe
eight percent time to write the code and
test the code and therefore while
building any system one has to also
consider what does it take to maintain
it and that is where if you know the
design patterns and if you apply them
correctly the answers will come
naturally every design pattern will have
as I said its own strengths and weakness
and what matters in the maintenance mode
of a software is how do we cope up with
the weakness of any system so as I said
the design patterns are our kind of
cataloged right and if you know the
design pattern and if you know how to
use it you would be a better software
developer but there is a difference
between knowing what a pattern is and
knowing how and when to use it if I may
draw your attention to a difference
between a knowledge and wisdom in
knowledge will say oh there is a design
pattern catalog where in there are
patterns 6 Y Z and it is to be applied
in certain cases
but it is a wisdom which will tell you
when exactly to use it when it when you
should not be using it and generally
that comes with experience and I'm here
with you to share that experience and
some sort of wisdom there is an old
saying if I may quote it here knowledge
is like knowing that tomato is a fruit
but wisdom is knowing that it is not to
be put into a fruit salad so if you look
at a design pattern catalog and you find
out oh well there is an abstract factory
but if you don't know when and how to
use it that knowledge is not really not
really useful isn't it you'll probably
be creating more mess than you started
with and that's where we come in we want
to share with you the experience that we
have in industry and knowing for example
an abstract factory what is it and how
to use it and what is the consequence of
using it in the maintenance mode so with
that I am moving to the next slide we
are saying that we will model this
manufacturer entity or with some design
patterns for example if you don't do it
with design pattern it will work but
then in future when you want to extend
the functionality or make it more
maintainable or scalable it will be a
hard task to take up sim the so when I
also have to understand um okay most of
the time we think about building a new
software have you thought about when the
software dice well I can tell you that a
software dies meaning the software is
taken out of production when it is no
longer economical to maintain it the
code has become something called a
spaghetti code the original developers
who developed it are no longer with that
organization and they the new developers
did not perhaps got the entire
or did get the Katie but did not get
their facts together and it is cost
prohibitive to add feature to that
software in such cases the architects
and the business stakeholders will want
to think about building a brand new
system and if the brand new system is
not developed well the cycle repeats
very soon the software will age it is
not beneficial to maintain or it is a
cost prohibitive to maintain that system
and production and then architects and
business stakeholders or holders will
come and say oh they want to build a new
system so using the right solution in
this is right design patterns extends
the life of the system and that's where
it is important for us to know the
design patterns and know how to use it
not only for the fresh or greenfield
projects but also for the projects under
maintenance design patterns are
generally a common language between the
development organizations for example if
you are building an abstract factory fly
apart and somewhere in the comments you
will say that well this is a standard
abstract factory pattern and let's say
three years four years down the line
somebody wants to come in and men in the
maintenance mode in handset or are kind
of make some changes because of maybe a
business in are you changing the person
will read abstract factory pattern he'll
easily be able to correlate the related
classes to those entities in the
abstract factory or any other pattern
for that matter right that makes it very
maintenance of a large enterprise scale
applications moderately easy to maintain
now they are because design patterns of
proven solution you also know the
consequences should there be a mint in
the maintenance mode should there be a
added requirement
to a scenario which makes that design
pattern not so lucrative one will have
an option of swapping out that design
pattern in in favor of some other design
pattern which makes motions and that's
where it's very important to understand
how to use design patterns moving on we
will talk about something called a
unified modeling language it is a
decrement diagrammatical representation
of how the solution will look like a in
most of the time it is an
object-oriented solution that will look
like and if I have to go to another
saying it says a picture is worth more
than thousand words same is in UML it is
worth more than maybe a one-kilo lines
of code and why it is important because
not only the programmers but also
architects and the system engineers and
the business stakeholders can understand
and appreciate the design expressed in
the UML another benefit of your melon is
it is programming language independent
you can have in UML and use tools to
let's say forward engineer your UML
design into a Java code or a dotnet code
or in any other programming language
that the tool supports talking about UML
um it is set of predefined diagrams and
set of notations that one would use to
show various aspects of the objects or
classes the rod set of diagrams shown on
the picture or the categorization of
them essentially they are structural and
behavioral diagrams a structure has
something to do with a static
representation of the class or a package
or component sometimes it also shows how
your component is deployed in the
production system
a behavioral diagram will talk about how
the runtime behavior of the program is
in that sense one would draw an activity
diagram which is which is in part
similar to a flow diagram telling how
program will execute a use case diagram
telling how the program will be used a
system will use a state diagram that
talks about a state of a particular
entity so on and so forth now remember
that not all these diagrams are useful
in a given context for example if you
are not going to do any real time system
development you may not even worry about
a timing diagram it may not add value to
your design but there will be places
where you would want to use let us say
sequence diagram showing how the
sequence of call flows happen in a
particular I use case realization for
our discussions we are not going to do
do a lot of UML kind of designs or
notations so if you have not looked at
in depth UML do not worry we will just
be drawing some block diagrams and and
using very minor minor features of the
UML will not be going into advanced UML
so nobody is if you have not looked at
the UML there are tools to draw these
diagrams the free ones are or go um el
dia um let star UML they are free
open-source with simple user interface
allows you to create some diagrams so
quite quickly and there are enterprise
level modeling's of applications like an
enterprise architect by microsoft there
is also an enterprise architect by IBM
there is a magic draw by pneumatic
cooperation an IBM has always been
leading with rational rose and likes of
tools with tools edge now most of the
commercial software will allow you to do
a forward range engineering as well as
you
engineering a forward engineering will
allow you to convert a particular design
into code and a reverse engineering will
allow you to import your code into UML
it will read the code and generate the
human diagrams for you and what is
interesting is almost all these tools
freeverse as well as the paid ones come
up with a set of design patent
applications so you can put in the you
can come come into the tool and say oh
draw me a abstract factory and it will
draw you an abstract five free and you
will end up changing only the class
names again tools make life easier but
what needs to happen is the user must
understand how to use a tool and then
how to use a design pattern that the
tool is going to draw draw for you with
that let's talk about that track factor
in our problem space we are looking at
maybe building a cement factory or a
cheese factory now do not confuse these
these cheese factory with abstract
factory because the names are the same
what happens in abstract factory is it
generates the factory classes for a one
of a kind of objects for example if you
are going to build a cement factory an
abstract factory will give you an
actuator factory as well as the sensor
factory or that is applicable only to
cement factory and not let us say it is
factory because the actuators and
sensors and the world of cement factory
will be drastically different than those
for let's say a cheese factory or a
pickle factory if you like pickle so
abstract factory allows you to generate
the butt
the category of classes in this case an
actuator for cement factory will always
be generating the the flow sensors are
you know the weighing sensors are for
cement factory whereas the the pickle
factory will have a different kind of
sensors or or and or actuators so
depending on which factory we are
building the client will ask abstract
factory to get you the get you the
specific factory for that problem
sentence let's say a cement factory and
then client will start using those to
generate the actuators and sensors now
an abstract factory always works with an
abstract representation of the real
object in this case it can be an
interface or an abstract class and the
factories generate the concrete classes
for those in this case for example an
abstract actuator is known to the client
but client does not know what is a
furnace actuator and how to construct it
that will be constructed by the actual
actuator factory same is the case with
let us say a flow actuator or a
temperature sensor or flow sensor so
that's an abstract factory again or if
you want to relate it to a real time
real life example in a software world
consider abstract factory as your theme
in let's say windows okay so when you
apply a theme you just choose a
different theme factory and that theme
factory will give you the actual
instance of Windows the start bars the
buttons and the background color and all
those stuff stuff when as a user you
change your theme the client underneath
is going to change the factory
implementation specific to that chosen
theme and you all of a sudden you will
see your buttons and bars and everything
is changed because the
client is going to use a different
factory to render those in the Java
world you will see a awt or swing
toolkits being using the similar
abstract factory implementation what is
the beauty of abstract factor
implementation well you can plug in
another set of factories to the
implementation and your client does not
know what's happening under under the
hood in the droid factory all the client
will ask abstract factory is to get a
factory of a particular kind and that
factory of a particular kind will give
that real instances of the object so
thus we avoid something called ripple
effect let's talk about a little bit
about a ripple effect a ripple effect is
in need of changing one or more objects
because one object changed in this case
we have contained the ripple effect
let's say we build another factory for a
different theme the client does not have
to change therefore the changes are only
constrained within the abstract factory
and nowhere else so abstract factory are
good if you want to change the behavior
of a set of classes and it allows you a
plug-and-play kind of behavior if you
design it right the client does not need
to change and thus you can add more
behaviors on the fly of when you need
them the next page we are going to talk
about a yet another pattern called an
observer patterns as the name suggests
an observer pattern will allow you to
observe a particular subject or a class
a class under observation is generally
named a subject so what ends up
happening is your observer will
subscribe to the subject and when there
is a and when we say subscribe to a
subject right it subscribes to a state
change or in that subject and what ends
up happening
is the subject will notify back to the
observer when the when the state that
observer was interested in changes so if
you look at the next diagram on the page
it shows you some UML diagram and you
don't have to worry about the UML
diagram if you don't know it it will
show you a subject and observer a lie in
between subject and observations of
Association the observer will attach
itself to the subject or somebody will
log or somebody else will attach the
observer to the subject that could be
your master program an observer can be
detached an observer when attached gets
notified when a state of a subject
changes and then observer updates itself
or updates does some sort of a update
operation and keeps listening for any of
your future subject changes or subject
state changes in the lower half of a
diagram you will see that there is a
packaging a concrete subject and a
chemical control called and concrete
observer and when the packaging's state
changes it will call it will notify the
chemical controller with an object state
with a new object objects state and the
chemical control will kind of update
itself with that new state and that all
that operation it may tell about the
change in the packaging to master
control with that let's move on and talk
something about a mediator pattern now
we talked about observer on one would
relate these observers to the sensors
like an observer will be attached to a
sensor and when the sensors value
example a temperature changes it will
tell it to the observer and then
observer will tell it to the two
probably the master controller but then
the mode number of observers you have
and the sensors you have the
communication paths between these
observers and the and the master
controller becomes complex right there
are let's say ten different observers
all of them telling their their values
are talking to the master controller or
in some even more complex scenarios the
observers talking to each other which
will then be a computational value and
the complexity will grow exponentially
for example then objects talking to each
other will mean 90 independent paths in
which they can talk to each other such
code becomes quite complicated to
maintain and very prone to bugs and
defects to be introduced and therefore
in general has a good practice we avoid
multiple communication channels between
multiple objects or entities interacting
because there will be so many parts of
communication the testing becomes hard
in fact it becomes real hard and
therefore we will look at a pattern
called a mediator pattern where we limit
how much objects can talk to each other
and it is achieved by something called a
mediator interface each each object
which is in this case we call them
colleagues in our cases they could be
observers and each observer who wants to
communicate with another or entity will
not talk to that entity directly but go
through a mediator right it's like a
person standing in a hallway and
everybody everybody in the room in their
own room talking to that person in the
alway communicating the message the
person goes to the next room and
delivers it to a concerned person so
let's say if you have tamed 10 rooms and
there are 10 people lost it one person
sitting in the each room instead of a
one-person going to nine other doors you
talk to this person in the hallway and
that person goes to whoever the message
was for so thereby if you have n objects
in in earlier case we are saying 10
objects talking to each other will mean
90 independent parts here we are saying
10 objects all of them will talk to a
mediator and listen from radiator all of
a sudden are independent communication
paths become 2310 for each 10 paths for
the observers talking to mediator and 10
parts for paths for mediator talking to
10 different objects that reduces
complexity The Observer that we were
talking about the object in the mediator
pattern is called Kelly because he is
colleague to the mediator and colleague
may have different concrete instances of
all the all the all those people who are
or objects were trying to talk a
mediator is an interface so colleagues
know about the mediator interface but
the actual or concrete object or class
may be different and because it is
interface or driven the controllers or
the colleagues do not know about do not
not need to know about what the concrete
mediator is if we draw the parallel to
the the man standing in the in the in
the corridor in the hallway the person
sitting in the room only needs to know
how to talk to that out that person
maybe he's we can only speak in English
so you'll only talk in English but you
didn't don't need to know the name of
that person odd in what shift that
person is going to work and all that
stuff the person is still there you
just need to know that he can talk in
English and he knows how to communicate
a message to other colleague and that's
all so in the in the UML depiction
diagram there is an association between
a mediator and Kelly and a mediator is
extended or subclassed into a concrete
mediator and the colleagues may have one
or more concrete instances of a concrete
classes of the myth colleagues with that
um we have these three patterns that
will help us solve the cement factory or
a become factory or a cheese factory
problem much easier the mediator will
talk to the central controller the
colleagues will be all sensors the
observers will be rather the colleagues
will be all the observers and the
sensors will be observed by the observer
and you have this abstract factory
pattern which allows you to generate a
specific category of sensors or
actuators and there are more design
patterns to to solve the majority of the
problems in the software designs and why
there are so many design patterns
because there are so many problems and
because those problems can be solved
successfully by managing the constraints
and optimizing the benefits and it is an
ever-growing scenario note that the
design patterns are never ever invented
they are discovered that discovered
through practice and then are documented
however in recent times in an
object-oriented while there have not
been new new patterns introduced because
the field is quite mature now and there
for me as object oriented program would
always ask if there is a problem is
there a solution readymade that
employ and speed of my development and
also make the software cost effective
and in the in the training that we are
going to attend that will that will be
our focus how can we make you efficient
how can we make you a smarter software
developer and designer and design
patterns knowing them and knowing them
well knowing how to use them goes long
way in making one a good software
developer the the design pattern because
we will be using a common terminology
are also easier to communicate for
example in a mediator pattern if you say
curly people will understand what a
kelly here or in an observer pattern if
you knows if you say subject people will
no subject is something that is being
observed for the state change more and
more the software field is maturing it
is no more an art but it is a skill a
skill that one can learn and a skill
that will make you a better programmer
and knowing design patterns is an
important skill in that that that
spectrum it allows you to talk to maybe
your seniors your architects your
colleagues in a common nomenclature and
it allows them also to get a field that
you understand and know what you're
talking about and you're not talking
something that you know does not sound
good or um sounds foolish if I may use
that word if you say for example an
abstract factory in a concrete factory
it is better you know what you mean and
it is also easy of architects and the
sequel to understand oh you're saying
abstract 5 free that means okay I know
this this problem will be solved or not
solved like based on whether you applied
it correctly or not with that let me get
you a feel of how the course curriculum
is going to look like we'll have eight
modules and in the first module we will
talk about the introduction to design
pattern we'll talk about I an
object-oriented of object-oriented
principles called solid principles or
will probably be spending most of our
first modules time talking about the
solid principles we will then look at
different classes of patterns or we will
be implementing probably a dao and the
factory pattern that and then we will
move on to in the module to the
creational patterns then module one you
would have seen that there are four kind
of design patterns creational structural
behavioral and concurrency we will
devote our next four modules talking
various patterns in those arm in those
category more most importantly we will
be talking about factories and builders
and when to use factory and when to use
builder we'll be talking about a very
common pattern called single-tenant will
be talking about prototype and object
pools which allows us some sort of
cashing in module three structural
design part and we will be covering some
interesting patterns like adapter and a
bridge and a decorator and we'll try to
identify when to use an adapter and when
to use a decorator or will not look at
the front controller and proxy and so on
and so forth in the module four when we
talk about the behavioral pattern we
will look at something called chain of
responsibility command a mediator and
Observer that we looked at will do a
deep dive there we will look at template
method and few more Parliament few more
patterns there in the module five a
concurrency design pattern a critical
one or in a multi-threaded environment
and with the
the advancement in the multi-core CPUs
that one gets important to understand
how to design well for concurrent
programs we will be looking at monitor
objects active objects thread pools
leader followers and so on and so forth
in module six we will be looking at
anti-patterns a pattern not used well
results in an anti-pattern we'll be
looking at those in the design and the
chakra development and very briefly in
the management of a software development
many of us must be using a putting time
in maintaining existing project and
therefore it comes handy if you know how
to refactor and refactor well so in
module 7 will be spending time
understanding various refactoring
techniques organizing data how to
simplify certain programming
constructions in module 8 we will do a
quick project we will implement some of
the patterns that we use and we will do
some sort of a prospection and how did
we do in those earlier seven eight
modules you'll probably be taking the
question that may be pending by then on
let maybe project or recent modules and
that how that's how we will conclude our
live sessions in addition to live
sessions there are other other very
important tools that you can use help
that you can use all the classes will be
recorded and will be available in the
learning management system lms for your
offline viewing sometimes you want to
revise certain concept or you want to
refresh and reinforce your understanding
a class recording will come handy in
that that case we work 24 by 7 anytime
you have questions technical
difficulties you can always call up log
catch ask questions we we believe in
reinforcing the knowledge just there and
there therefore you will have modeled
wise quizzes which will test how much
did you how much did you grasp and if if
you did not there's an opportunity to
ask question there and there itself and
we will try and reinforce the
understanding we will do some project
work and that will allow us to get our
hands dirty as they call it and get the
feel of how to apply design patterns and
we learn from each other a particular
design pattern may be used in a
different context that we may not have
thought of and we will come to know
about it doing a project work is
important step in the curriculum because
writing it is is going to imbibe imbibe
the knowledge on your brains we will
have a verifiable certificate now that
is important although your skills after
this course will speak for themselves
because now you will be able to
implement better solutions there would
be people let's say in your management
or when you are looking out for a job
the people who will not be able to
appreciate the skills you have because
they don't have that skill right you
talk about abstract factory to an HR the
HR person will not know it and that's
where a verifiable certificate comes
handy you can always say that well look
I have done this course and you can
always go to aid you Rica and verify
that I have done it and with that I can
conclude my webinar I hope this was a
joyful experience to you and you have
learned at least three patterns or
learnt about three patterns and it makes
you feel bad
most importantly it it makes you feel
you're more skillful than an hour back
and I look forward to you in the
upcoming training sessions well we will
do a deep dive and try under standing it
from a practical aspect as well as a
theoretical aspect i will share you the
knowledge that we have gained the wisdom
that we have experiences the pitfalls
how something that we thought will work
did not work and also of soft so I I'm
hoping to see you there with that I take
your leave thank you for your time and
opportunity or to listen to me again
this was jaikumar and i'm happy to have
you thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>