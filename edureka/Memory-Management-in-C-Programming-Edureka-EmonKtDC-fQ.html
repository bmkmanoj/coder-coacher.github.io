<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Memory Management in C Programming | Edureka | Coder Coacher - Coaching Coders</title><meta content="Memory Management in C Programming | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Memory Management in C Programming | Edureka</b></h2><h5 class="post__date">2014-09-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EmonKtDC-fQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">you
similarly to handle your memory we have
some memory management functions we
already we have already used malloc we
know how to use my lock you see my lock
give a size it allocates so many number
of bytes in memory and returns the
starting address you also have something
called realloc let's say we allocated
space first and we ask for about 20
bytes later we realize we want another 8
bytes you can call realloc to the
allocate space so you can say the a lock
firstly we have done my lock for 20 will
return a pointer now to realloc you need
to pass that pointer to save a
reallocating space for that particular
address so we passed the address of the
malloc space and then we passed the new
size so now I can say 28 so reallocate
28 bytes and whatever was in the first
20 bytes previously will automatically
be copied to the new location
Andreea lock will finally return
starting address of the new location but
please remember realloc does not have to
always allocate space at a new location
it could just try and expand the current
location itself and it's also not
necessary size has to be greater than
the previous size if size is smaller it
will free up that extra space so realloc
is used to actually reallocate memory
and finally you also something called
gallic you remember the things like
malloc andrea log do not initialize your
memory so whatever memory is being
allocated to you is uninitialized it'll
have some junk value in it same with
realloc when realloc when we set for 28
bytes the extra 8 bytes as being
allocated will be uninitialized the
first 20 bytes will of course be similar
to what the old memory contained with
the new 8 bytes or the extra 8 bytes
that has been allocated will be
uninitialized so you also have a call so
you have a function called Kellogg
Kellogg initializes your memory to 0 so
what are the memory Kellogg allocates it
will initialize that memory to 0 and the
way you called Kellogg is slightly
different from the
where you called malach if you see Milan
just took one parameter but Garlock has
to this because let's say we on allocate
space for an array of 10 integers how
would we call malloc you say malloc 10
into sizeof int sizeof int would be 4 so
it would do 10 into 4 and reallocate 40
bytes in case of calloc you don't have
to do 10 into sizeof int first use past
size n which is how many objects of the
array you want we want 10 objects so we
pass them and second parameter is the
size of each object which is size of int
so instead of a surf eying the total
number of bytes that we require we
specify the number of objects and the
size of each objects and the size of
each object and it will automatically
calculate the size internally and return
a pointer to the starting address so
kalloch returns pointer to memory of an
array of n objects of this specified
size</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>