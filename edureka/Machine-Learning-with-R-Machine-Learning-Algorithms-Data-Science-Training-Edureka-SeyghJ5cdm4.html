<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Machine Learning with R | Machine Learning Algorithms | Data Science Training | Edureka | Coder Coacher - Coaching Coders</title><meta content="Machine Learning with R | Machine Learning Algorithms | Data Science Training | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Machine Learning with R | Machine Learning Algorithms | Data Science Training | Edureka</b></h2><h5 class="post__date">2018-04-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SeyghJ5cdm4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey guys this is Bernie from arica and
the session is all about machine
learning with our we'll start off by
understanding what exactly is machine
learning and then he'll head on to look
at some applications of machine learning
following which and look at the
different languages to implement machine
learning algorithms and understand what
makes our so popular for the going ahead
we'll understand the different types of
machine learning algorithms and finally
we'll be working on a very interesting
case study to implement all that we've
learned so let's get started let's
understand the concept of machine
learning this example over here so what
do you see in the slide what is this
exactly it's a fish isn't it and how
about this again a fish and this well
this is a fish - now how do you know all
of these are fish well as a kid you
might have come across a picture of a
fish and you would have been told by
your kindergarten teacher I have pains
that this is a fish and your brain
learned that anything which looks like
that is a fish and that is how our brain
functions but what about a machine the
same image is fed to a machine
how will the machine identify it to be a
fish so this is where machine learning
comes in we keep on feeding images of a
fish to a computer with the labeled fish
until the machine learns all of the
features associated with the fish and
once the machine learns all of the
features associated with the fish we
will feed it new data to determine how
much it has not in other words
raw data or the training data is given
to the machine so that it learns all the
features associated with the training
data and once the learning is done
the machine is given new data or the
test data to determine how well it has
learned and that is the underlying
concept of machine learning now let
we've understood what exactly is machine
learning let's go ahead and look at some
applications of machine learning the
aviation industry uses machine learning
for tasks such as finding optimal air
routes predicting flight delay and
dynamic pricing and all of these are
quite serious optimization problems
which can be solved by machine learning
marketing organizations are in
with machine learning according to
Twitter 75% of marketing enterprises use
machine learning to enhance customer
satisfaction and also to improve sales
of new products and services healthcare
industry uses machine learning for drug
discovery and disease prediction robotic
surgery is also an application of
machine learning The Da Vinci robot is a
device which helps doctors to perform
surgeries with fine detail machine
learning has wide applications in
financial industry as well such as
building economic models and finding out
fraudulent transactions Google's
much-hyped self-driving car and the
automated drones used in military are
also applications of machine learning so
those were the applications of machine
learning now let's move ahead and look
at the different languages which can be
used to implement machine learning
algorithms are and Python are the most
widely used languages to implement
machine learning and that is because
they provide wide variety of packages
for the purpose of data science machine
learning and visualization MATLAB is
another language which is used for image
recognition and machine learning of a
good old Java also provides machine
learning libraries such as mallet and
deep learning 4G let's understand why
our for machine learning our is a Turing
complete language Dallas it can perform
any computation witchetty ring machine
can and thus we can perform tasks such
as statistical analysis predictive
modeling and also implement machine
learning algorithms are also provides
both object-oriented and functional
programming paradigms and the best thing
about RS is a free open source software
and hence there are no licensing
restrictions at all it's time to look at
the steps involved in building a machine
learning algorithm we'll start off by
ingesting the data from various sources
and once the ingestion is done the data
needs to be cleaned so that simple
insights can be found from it after
cleaning and understanding the structure
of the data we'll divide the entire data
set into train and test sets and we'll
the algorithm on top of the train set
once the algorithm learns all the
features of the train set we'll check
for the models accuracy with the test
set and finally with a value
the result by using various parameters
such as confusion matrix and root mean
square error we'll be implementing both
the confusion matrix and root mean
square arrow in a case later on so those
were the steps involved in building a
machine learning algorithm now we'll
have a look at the different types of
machine learning algorithms broadly
speaking we have supervised unsupervised
and reinforcement machine learning
algorithms so let's start with the first
one let's understand what exactly is
supervised learning a super is learning
algorithm learns from a known data set
with labels notice it needs a training
data set to learn all the features and
once it learns these features it is
given the test set to check for its
accuracy let's take this example there
is a student who is about to appear for
a test and before he appears for the
test
she needs to train herself well so that
she can perform well in the test and
this is the concept behind supervised
learning so examples of suppose learning
or classification and regression she
let's start with classification
classification determines to which set
of categories as a new observation
belong so in this example if the
observation is given the label man then
it is rightly classified but if it has
given the label woman then the
classification is wrong similarly for
the second observation if it is given
the label woman it is rightly classified
else the classification is wrong an
example of classification is decision
tree is a tree like structure where all
the internal nodes represent a test
condition on an attribute and all the
leaf nodes are the categories into which
the data is divided now we'll go ahead
and implement the classification
algorithm on top of the car purchase
data set so let's head on to our studio
this is our studio guys so we'll use the
read dot CSV function to load the car
purchase DITA set the read dot CSV
function is used to load a CSV file will
say view of car purchase and this loads
of the car purchase data side so this
has the columns gender age estimated
salary and purchased now this denotes
the gender of the person
this tells the age of the position this
tells the estimated salary of the
position and this column tells if the
person has purchased the car or not now
we can remove this column because this
column does not serve any purpose and to
do that we'll be using to deploy a
package the deploy a package is used for
data manipulation so the deploy a
package provides a function called
select so what we're doing over here is
from the car purchase dataset we are
selecting all of the columns except the
first column and storing it back to the
cop which is data set let's have a
glance at the modified car purchase data
set so view of the our purchase and we
see that the first column has been
deleted now it's time to split the
entire dataset into two parts and to do
that we'll be using the CA tools package
will load the CA tools package with the
help of the library function the CA
tools package has been loaded
now the CA tools package provides us
with the function sample dot split and
this function takes two parameters first
is the column which is about to be split
and next parameter is a split ratio so
what we are doing over here is we are
taking the purchased column from the car
coach's dataset and we are dividing it
into the split ratio of 6535 that is 65%
observations of this column will have
the true label and the rest of the 35%
observations will have the false label
and will store the result back into
split values object now after doing this
will select the 65% observations which
have the true label and store them into
the training set similarly we'll take
the rest of the 35% observations which
have the false label and store them into
the test set so we have our training and
testing sets ready after doing this we
can finally build our our part model on
top of the training set so we'd have to
load the our part package and we can do
that to the help of the library function
part stands for recursive partitioning
the Arpad package also provides us with
the our part function and this function
takes in two parameters over here the
first parameter is a formula and we see
that we have given the purchased column
on the left side of the tilde symbol
letters the purchased column would be a
dependent variable and all of the
columns except the purchased column
would be our independent variables or in
other words we're trying to determine
whether the person has purchased the car
or not with respect to the estimated
salary column each column and the gender
column of the car purchase dataset and
we'll store this result in mod class
object
so we built the model on top of the
train set now it's time to predict the
values on top of the test set and we can
do that by using the predict function so
over here the predict function takes in
three parameters first is the model
build next is the test set and next is a
type of prediction and since this is a
classification algorithm will say type
is equal to class and we'll store the
predicted results in the result class
object so we have build the model on top
of the training set and we've predicted
the results on top of the test set now
it's time to build the confusion matrix
using the table function let's
understand this confusion matrix
properly these are the 90 observations
from the test set where the person has
not bought the car and these are the 50
observations from the test set where the
person has actually bought the car that
us out of this 90 observations ap have
been correctly classified and again are
these 50 observations 39 have been
correctly classified and to find out the
accuracy we'll divide the left agonal
with all of the observations so that'll
be 80 plus 39 divided by 80 plus 39 plus
11 plus 10 and thus the accuracy of this
model is 85% should have done us we
build the classification model on top of
the car pushes data set and we found out
the accuracy of the model is 85% now
let's head back and understand what
exactly is regression regression is a
supervised learning algorithm which
helps in determining how does one
variable influence another variable so
over here we're trying to determine how
does living area of the house affect the
price of the house or in other words
over here price would be the dependent
variable and living area would be our
independent variable there a variety of
regression techniques such as linear
regression logistic regression and
Poisson regression and for the purpose
of this key study we'll be implementing
the linear regression model and we'll be
implementing this model on the Diamonds
dataset so let's head back to our studio
now the Diamonds data set is part of the
ggplot2 package so let's load this
ggplot2 package let's have a glance of
the Diamonds data set so we'll
view of diamonds and this is the data
set let's understand this data set
so we see that this is a data frame
which has 50 3940 rows and 10 variables
and over here price depicts the price of
the diamond and US dollars carat is a
column which tells us the weight of the
diamond cut as the quality of the cut
color is a diamond color then clarity is
a measurement of how here the diamond
does x y and z tell us the length width
and depth of the diamond and millimeters
now it's time to again split the entire
dataset into training and testing sets
and to do that you'd have to lose the CA
tools package again now we'll use the
sample dot split function from the CA
tools package and this time we'll take
the price column and we'll split this
price column in the 6535 a she o and
will store the result and split values
after doing this using the subset
function we will select the for 65%
observations for all of those who are
split value stag is true and store them
in trainwreck object similarly we'll
select the rest of the 35% observations
where the split values tag is false and
store them in test rec object and thus
we have our training and testing sets
ready and now that we have a training
and testing sets ready it's time to
build the linear model on top of the
training set to build the linear model
we'll be using the linear regression
function and this linear regression
function takes in two parameters over
here the first parameter is a formula
and the next parameter is a training set
and over here in this formula we have
given the price to be the dependent
variable and all of the columns to be
the independent variables that us we're
trying to determine the price of the
diamond with respect to all of the
columns with data set and we'll store
the result in mod regress object so we
build the model on top of the training
set now it's time to predict the result
on top of the test set so we'll use the
predict function which takes in two
parameters over here first is the model
which we build and next is a test set
and we'll store the predicted values in
result rigorous object so we build the
model and then we have also predicted
the results now it's time to bind the
actual values with the predictor
values so these are the actual price
values from the test set and these are
the predicted values and we'll combine
these two and store it in the final data
object but this is actually a matrix so
we will have to convert this into a data
frame using the a store data frame
function now let's have a glance at this
final data object view of final data
this gives us two columns which are
actual and predicted this tells us the
actual diamond prices and these are the
predicted diamond prices now we'll go
ahead and find out the error
introduction and that can be found out
by subtracting the predicted values from
the actual values so we'll go ahead and
subtract the predicted values from the
actual values and store it in error
object we have done this now we'll also
bind the error object back to the
original final data object and store it
in final data
now the final data object has three
columns which are actual prices of the
diamond predicted prices of the diamond
and the error in prediction but what if
we wanted to find out the aggregate
error in prediction so we have something
known as root mean square error so as
the name stands you would have to take
the square of the error then we would
have to take the mean then we would have
to take the square root and this gives
us the root mean square error it needs
to be understood that the lower the
value of root mean square error the
better the model we've implemented the
linear regression model and we found out
that the root mean square error of this
built model is thousand twenty now let's
head back and understand what exactly is
unsupervised learning a nun supposed
earning algorithm draw inferences from
DITA which does not have labels so let's
take this example over here there are
students who do not require any external
training and they can learn by
themselves and this is the concept of
unsupervised learning an example of
unsupervised learning is clustering
there are many clustering techniques
such as k-means clustering hierarchical
clustering fuzzy c means and so on the
concept of clustering is simple there is
high indra cluster similarity and blue
inter cluster similarity now we'll go
ahead and implement the k-means
clustering algorithm on top of the iris
dataset let's have a glance at the iris
dataset view of iris
so this is our iris dataset which
comprises of these five columns now
before we build the k-means clustering
algorithm on top of this we would have
to remove the fifth column because the
key means can be applied only on top of
the numerical values so we'll be
selecting the first four columns from
this data set and we'll store it in a
risky object let's have a glance at this
view of iris K now we see that the fifth
column has been deleted and we just have
the first four columns now again before
we apply the key means you would also
have to convert this data frame into a
matrix so we'll use the as dot matrix
function and convert this data frame
into a matrix and store the result back
into the iris K object now after doing
this it's finally time to use the K mean
function to divide our data set into
clusters so we'll use the k-means
function and this takes in two
parameters first is the data set and
next is the number of clusters it is
divided into so we are taking this data
set and dividing this entire data set
into three clusters will store the
result in iris cluster let's have a look
at this iris cluster object so you see
that are these 150 observations all of
these have been divided into three
clusters so now we'll bind the
clustering vector with the original data
set to have a better analysis let's have
a glance at this clustered data object
so you have binded the clustering vector
object with the original data set now if
we have a closer look at this data set
you will understand that the first 50
observations of this data set or all of
the setosa species of the iris flower
have been grouped into the third cluster
and the rest of the hundred observations
thatis virginica and OC color have been
grouped in cluster number one and
cluster number two so what we basically
done as if implemented the k-means
algorithm on top of this is k data set
and we've grouped all of the sadducees
species into the third cluster and the
rest of the hundred observations into
cluster number one and cluster number
two so this was k-means clustering on
top of the iris dataset now let's head
back and understand whereas
reinforcement learning reinforcement
learning is a type of machine learning
algorithm with the machine or agent in
an environment learns ideal behavior in
order to maximize its performance and
simple reward feedback is required for
the agent to learn its behavior and this
is known as reinforcement signal let's
take pac-man for example as long as
pac-man keeps eating food it earns
points but when it crashes against a
monster it loses its life and this is
how Batman learns that it needs to eat
more food and avoid monsters so as to
improve its performance and these are
some real-world applications of
reinforcement learning Google
self-driving car the manufacturing
robots used in the industry and the
autonomous flying helicopters used in
the military now that we've understood
were exactly L suppose learning and
suppose learning and reinforcement
learning it's finally time to head on to
a final machine learning case study
since its release way back in 1995
Pokemon has taken the world by storm
Pokemon is a popular adventure game
developed by Game Freak and produced by
Nintendo and this game is popular across
the globe and enjoys a long streak of 21
years which still continues the gamer or
the participant is expected to choose a
starter Pokemon and catch all of the
pokemons available in that region and
the participant has to train his or her
Pokemon by
with other pokemons to level them up so
that they can compete with gym leaders
to become the champion of champions and
for the purpose of this case study you
are a pokemon trainer who is on his
journey to catch all the 721 pokemons so
we'll be working on this Pokemon data
set and that's part of your first task
you have to select one grass pokemon 1/5
Pokemon and one water pokemon to fight
in the Johto league so let's go ahead
with a first task let's load the Pokemon
data side with the help of the read dot
CSV function
let's have a glance at this dataset so
this is a dataset these are all the
names of the Pokemon type one tells us
the primary type of the Pokemon type 2
tells us the secondary type of the
Pokemon this is the total of all the B
stats this is health points attack
defense special attack special defense
the speed of the Pokemon and this column
tells us to each generation does the
Pokemon belong to this column tells us
as the Pokemon is legendary or not this
gives the color and this column tells us
if the Pokemon has gender or not this
column tells us if the Pokemon has a
gender then what is the probability of
the Pokemon being male this column tells
us if the Pokemon has mega evolution on
earth these two columns are for height
and weight of the Pokemon this gives the
cash rate of the Pokemon and this is the
body style of the Pokemon now if we've
understood this Pokemon dataset now
let's go ahead and also remove the first
column of this data set because again
this does not serve any purpose these
are just row numbers so let's go ahead
and remove the first column will require
the deployer package for that so let's
load the deploy a package and we are
removing the first column now if you
look at the data set again we see that
the first column has been deleted now
we'll go ahead and rename the columns so
the type 1 so we can rename this to be
primary type and we can rename this
column to be secondary type and this
could be renamed to health points this
to be special attack and this to be
special defense we'll be using the call
names function to rename all of these
columns
so the call names function takes in the
name of the data set and over here we
give the column number not us we are
changing the name of the column number
to two primary type similarly we are
changing the name of third column to be
secondary type we'll also change the
name of fifth eighth and the ninth
column two health points special attack
and special difference now if we look at
the data set we see that all the changes
have taken place so we have changed the
names of these columns now let's
understand the structure of this pokemon
data set
we'll be using the STR function to
understand the structure and this gives
us the structure of the data set so we
see that this is a data frame which
consists of 721 observations of twenty
variables or in other words there are
721 pokemons in total now there are some
variables which are of logical type such
as s legendry is a column which is of
class logical similarly has gender is a
column which is of logical and again has
mega evolution is a column which is of
logical type now we'll go ahead and
change the class of these three columns
to factor because when we have to build
the machine learning algorithms on top
of these you would require the class of
this to be a factor and not logical type
and we can change the class of this to
be factored using the as dot factor
function will say AZ dot factor of
Pokemon dollar as legendary and we'll
change the class of this column to
factor similarly we will change the
class of hash mega evolution to a factor
again we'll change the class of has
gender column to a factor now let's go
ahead and look at the different primary
types of the Pokemon we'll be using the
table function to do that so there are
in total 18 Pokemon types which could be
bug dark dragon electric and so on now
it's time to head on with a forest ask
the list select our grass water in fire
pokemon and for the purpose of the
contest we would require a grass pokemon
which is also poisonous and which has
the maximum speed so let's go ahead and
do that the deploy a package gives us
the filter function so what we are
basically doing
yes from the Pokemon dataset we are
filtering out all the grass pokemons
that us from the Pokemon dataset we are
filtering out those observations where
the primary type is grass and will store
the result in grass pokemon object let's
have a glance at this
view of grass pokemon and we see that
there are 66 class pokemons in total and
out of the 66 class pokemons we need to
select all of those grass pokemons who
secondary type is poison so let's go
ahead and select all of those grass
pokemons which are also poisonous so
from this grass pokemon dataset
I am filtering out those pokemons which
are also poisonous and I'll store the
result in grass poison Pokemon view of
grass poison Pokemon now I see that
there are 14 pokemons in total whose
primary type is grass and whose
secondary type is poison now out of this
14 pokemons I need to select that one
Pokemon which has the maximum speed so
let me get the range of speed for all of
these pokemons I see that there is one
particular Pokemon with the minimum
speed value of 15 and there is another
Pokemon which has the maximum speed
value of 90 and this will be my final
Pokemon so let me go ahead and select
that one particular Pokemon which has a
speed value of 90 so from the grass
poison Pokemon dataset
I am filtering out that one particular
Pokemon which has the speed value 90 and
I am storing it in my grass pokemon
object view of my grass pokemon so this
tells me that rosy red is my final grass
pokemon which has the speed value of 90
so I successfully selected my grass
pokemon now it's time to select the
water pokemon so we'll do the same thing
from the Pokemon data set I am filtering
out all those pokemons whose primary
type is water and storing it into the
water Pokemon object view of water
Pokemon and I see that there are 105
water pokemons in total now out of this
105 water pokemons
I need to sell it those water pokemon
switch are also psychic because for the
contest I need a water pokemon which is
psychic and has the maximum defense
value so let me go ahead and filter out
all the psychic water pokemons so what I
will do is from the water Pokemon data
set I will filter out all
those pokemons who secondary type is
psychic and store it in water psychic
pokÃ©mon
let me have a glance at this so I see
that there are four water psychic
pokemons and all of this for water
psychic pokemons I need to select that
one particular Pokemon which would have
the maximum defense let me find out the
range of defense for these four pokemons
that is one pokemon with the minimum
defense value of 65 and there is another
Pokemon with the maximum defence value
of 110 now let me go ahead and select
this one pokemon which has the maximum
defense value so from the water psychic
pokÃ©mon dataset
I am filtering out that one particular
Pokemon which has a defense value of 110
and I'm storing it and my water pokemon
object view of my water Pokemon and I
see that Slowbro is my final water
pokemon with a defense value of hundred
and ten so I've selected my grass
pokemon I have selected my water pokemon
now it's time to select the fire pokemon
so let's go ahead and do that so again
I'll do the same thing from the entire
Pokemon dataset
I am filtering out all those pokemons
whose primary type is fire and I am
storing it in the fire Pokemon object
let me have a glance of this view of
fire pokemon and I see that there are 47
fire pokemons in total now for the
contest I would require a fire pokemon
secondary type is fighting and which has
the maximum attack value so from this
fire pokemon data set I'll filter out
all those pokemons with secondary type
is fighting so let me go ahead and do
that so what I'm doing over here is from
the fire pokemon data set I am filtering
out all those pokemons who secondary
type is fighting and storing it in
firefighting Pokemon object view of fire
fighting pokÃ©mon and there are six fire
fighting pokemons in total out of this
six fire fighting pokemons I need to
select that one particular Pokemon which
has the maximum attack value and to do
that let me find out the range of attack
for this six pokemons so there is one
pokemon with the minimum attack value of
78 and there is another pokemon with the
maximum attack value of 123 now I would
have to select that Pokemon which has
the maximum attack value of
23 so from the firefighting Pokemon
dataset
I am filtering out that one particular
Pokemon which has the attack value of
123 and I'll store it in my fire Pokemon
object view of my fire pokemon and M
boar will be my final fire pokemon with
the attack value of 123 so I've finally
selected the grass water and the fire
pokemons now let me bind all of these
three pokemons into a single data set by
using the our bind function so I'll use
the R bind function and give these three
parameters which are my fire Pokemon my
grass pokemon and my water pokemon and
store the result in my pokemons so these
are my three pokemons for the fight in
the judo league so successfully
completed the first task and I've also
won the jutsu League now it's time for
the second task and the second task is
to understand what are the factors
influencing a pokÃ©mon's attack and I can
do that by implementing the linear
regression algorithm on top of the
Pokemon data set so let me implement the
linear regression algorithm on top of
the pokemons data set and understand
what are the factors influencing the
pokemons attack so to do that I would
have to split the entire dataset into
training and testing sets so I'll use a
sample dot split function to divide the
entire data set into trained inter sets
and this time the attack column from the
Pokemon data set I will be splitting
this into the 6535 issue I will store
the result in split index now with the
help of the subset function I'll select
those 65% of the observations where the
tag of split index is true and store it
and train one object similarly again
I'll select the rest of the 35%
observations where the split index tag
is false and store it in test one object
so now I have the training and testing
sets ready now I can finally build the
linear regression model on top of the
train set I can build a linear
regression model with the help of the LM
function so over here
the LM function again takes in two
parameters first parameter is a formula
next parameter is the training set and
in this formula I have given attacked to
be on the left side of the tilde symbol
and defense to be on the right side of
the tilde symbol status attack is my
dependent variable and defense is my
independent variable or in other words I
am trying to determine how does the
defence of a pokemon influence the
attack of the pokemon now build the
model on top of the training set now let
me predict the result on top of the
testing set so I will use the predict
function which takes in two parameters
over here first is the model belt next
is a test set and I will store the
predicted values in the result rigorous
object now I'll go ahead and combine the
actual values and the predicted values
with the help of the see bind function
and store the result in final data
object and again since this is actually
a matrix I'll use the AZ dot data frame
function to convert this into a data
frame and store this in final data view
of final data now I see that this data
set has two columns actual and predicted
so this is the actual attack values and
this is the predicted attack values now
let me find out the error in prediction
and to find out the error in prediction
I would have to subtract the predicted
column from the actual column so I am
subtracting the predicted values from
the actual values and storing the result
in error object
now I'll bind the error back to the
original final data set and store it
back to the final data object
so now this is the actual attack value
this is the predicted attack value and
this is the error in prediction now let
me go ahead and find out the aggregate
error in prediction I can do that by
implementing the root mean square error
for this model so I will take the square
of this then I will take the mean of
this then I'll implement the square root
for this and this finally gives me the
root mean square error for the model
which I've just built and the root mean
square error value for this is 24 now
let me go ahead and build another linear
regression model on top of this data set
but this time I am trying to determine
how would defense speed and health
points combined influence the attack of
the Pokemon Terrace this time attack is
a dependent variable but this time
defense speed and health points are the
independent variables and as to the
result in more rigorous to build the
model on top of the training set and now
I'll use the predict function to predict
the values on top of the test set
I'll store the predicted results in
result rigorous to I built the model
I've predicted the results now let me
bind the actual values with the
predicted values and store it in final
data too and again since that is
actually a matrix let me convert that to
a data frame using the a store data
frame function and I'll store it in
final data to let me have a glance at
this view of final data - and this is
the new data set which comprises of the
actual attack values and this is the
predicted attack values now I'll find
out the error in prediction by
subtracting the predicted values from
the actual values so these are the
predicted attack values and these are
the actual attack values and I'm
subtracting that and storing it in error
- now I will bind this error to object
back to the final data to object using
the C bind function let me have a glance
at this view of final data - so now this
data set has three columns actual attack
values predicted attack values and the
error in prediction let me go ahead and
find out the aggregate error in
prediction with the help of the root
mean square error so I will take the
square
I will take the mean then I'll finally
implement the square root and store it
in our MSE - so this tells me that the
rmse value for this is 21 so let me
compare our MSE 1 and our MSE to our MSE
one are MSE - so now I see that the RMA
C 2 value is less than the RMA C 1 value
or in other words the second model is
much better than the first linear
regression model and thus we are done
with a second task so we're done with
the second task now it's time to head on
to the third task and we have to see the
entire world by selecting all the
legendary pokemons or in other words you
would have to implement the
classification algorithm on top of the
Pokemon data set to find out if the
Pokemon is legendary or not so let's
implement the classification algorithm
to find out if the Pokemon is legendary
or not again
we would have to load the CA tools
package so this time the sample dot
split function would take the is
legendary column and we are splitting
the is legendary column into two parts
so this column over here will be split
into two parts were 65% observations
will have the true tag and the rest of
the 35% observations will have the false
tag and the result is stored in split
values after doing this with the help of
a subset function I'll select those
observations where the split values tag
is true and store them into the training
data similarly again I'll use a subset
function now I'll select all of the sub
survey shion's
where the split values tag is false and
store them in the test data and thus I
have divided the entire dataset into
training and testing set
let me have a glance at the number of
frozen training in the testing data so
there are 469 rose in the training data
and 252 rows in the testing data now
it's time to build the our part model on
top of the training set so library of
our part this would load the our part
package now again the our part package
provides the our part function so over
here the formula s is legendary tilde
dot let us as legendary will be our
dependent variable and all other
would be our independent variables or in
other words we are trying to find out of
the pokemon is legendary or not with
respect to all of the columns of the
dataset and we'll store this result in
mod 1 so we build the model on top of
the training set now let me predict the
values on top of the test set so this
time the predict function takes in three
parameters forces the model build next
is the test data and next is a type of
prediction which is equal to class and
I'll store the result in result one so
have built the model I have predicted
the results and now it's time to check
for the accuracy of the model now this
gives me a confusion matrix I can also
use the confusion matrix function from
the carrot package so this confusion
matrix function directly gives from the
confusion matrix and also gives me the
accuracy of the model build so I see
that the accuracy of this model is 98%
now I'll build another classification
model on top of this data set but this
time I'll take attack defense and speed
to be the independent variables and s
legendary to be the dependent variable
that as I'm taking only three columns
this time as the independent variables
and I'll store the result in mod to
object so I built the model on top of
the training set now it's time to
predict the values on top of the test
set so this time the predict function
takes these three parameters the model
built which is more to the test data set
and type is equal to class which tells
me that this is a classification
algorithm I'll store it in result to
object so I build the model have made
the predictions now it's time to build
the confusion matrix so again I'll take
the help of the carrot package to build
the confusion matrix so this builds up
the confusion matrix and I see that the
accuracy of the second model is 94% so
when I compare the first model with the
second model I see that the first model
is much better than the second model so
now how successfully completed all of
the three tasks so a first task was to
select a firewater
and grass pokemon to fight in the jutsu
League we've done that and a second task
was to understand how would a pokemons
defense influence its attack and we did
that by implementing the regression
algorithm and finally if also
implemented the classification algorithm
to find out at the Pokemon is legendary
or not and this brings us to the end of
this video so we started off by
understanding what exactly is machine
learning
after which we looked at some
applications of machine learning and
then look at the different types of
machine learning algorithms and finally
we went ahead with the final machine
learning case study and worked on the
Pokemon dataset so hoping that you liked
the video thank you I hope you have
enjoyed listening to this video please
be kind enough to like it and you can
comment any of your doubts and queries
and we will reply them at the earliest
do look out for more videos in our
playlist and subscribe to any Rekha
channel to learn more happy learning</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>