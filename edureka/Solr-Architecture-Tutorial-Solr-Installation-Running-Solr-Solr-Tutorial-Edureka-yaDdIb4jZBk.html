<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Solr Architecture Tutorial | Solr Installation | Running Solr | Solr Tutorial | Edureka | Coder Coacher - Coaching Coders</title><meta content="Solr Architecture Tutorial | Solr Installation | Running Solr | Solr Tutorial | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Solr Architecture Tutorial | Solr Installation | Running Solr | Solr Tutorial | Edureka</b></h2><h5 class="post__date">2015-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yaDdIb4jZBk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's briefly talk about the solar
architecture so these these are some of
these components what now you would come
across when we are trying to understand
soul up so it's very important that we
same we spend some time in understanding
this architecture and we understand
these things in detail because when we
move forward most of these things I'll
be referring to these components so the
more in detail we understand it's really
good for us okay so the first one if you
look on the topmost left corner there is
a section called breakfast handlers
okay so a request handler is nothing but
a plugin which can be defined to accept
any requests coming to the solar server
say for example it is in simple terms it
is like you are defining a servlet for
different needs it's just a URL ok so if
you need different aspects or features
of solar the first the first thing you
may be dealing is with the request
handlers so you have to define request
handlers for different type of
interactions it's like the entry point
so once you define the entry points you
can create all the sub components under
those request handlers and you can let
anyone interact with those like 'christ
handless so it is just like a URL where
you are defining a servlet relative
context path for each request to Matt to
that particular type if someone is
accessing select so the select request
handler will respond if someone is
calling say forward slash select this
electric post handler will response
respond if someone is calling for slash
had been that like this hand level
respond
and if someone is calling for slash
spell that one would respond so you can
configure your own request handlers by
choosing what components you wanted to
use in that request handler and
remaining that particular behavior of
the component will take care of it okay
so all these things is done by XML so
you can chain lot of components in the
request handler and you can service the
requests based on the behavior you want
it to handle in that request handler
okay so either you can pick and choose
the existing search components like say
for example I wanted to have a request
handler which only does faceting so I
can have a ford slash physic and choose
the facet component or I can choose
faceting and highlighting and say H
pheasant URL so all those things you can
do it or you can build your own custom
search component and you can also
configure those things so it is all
based on what is that we need ok so
there are a bunch of request Hamlet's so
I have only mentioned three on the
topmost left corner but in fact there
are many more okay so all the
configurations of the request handlers
and all is handled and done using the
XML configurations so these are all the
search components which you can pick and
choose and once you pick and choose
these components that request handler
behaves the way how you have configured
so
I'll just give not give the complaint
Rick the sadness but at some point of
time we will see most of the required
stems what solar s'posed will be
building with them from use case to use
case so the next one what you see is
their response writers so the response
writers is nothing but once the request
has been processed you also have to tell
solar in what format you want the
response back either an XML or JSON or
binary or some other format so if you
tell the response Magnus take care of
providing you the response in that
particular format okay
so on the right side so in fact as I was
mentioning there there are few more
response formats apart from what you see
there
XML binary and Jason there is CSV
response handler PHP Python Ruby in fact
a little bit of XSLT as well so these
response writers is responsible for
providing you the response in that
particular format where you want it to
handle in that way okay so there are
some update handless so the request
handlers are used primarily to read the
data back from the index response
writers is basically used for providing
the request in a particular format
responding to a request in a particular
response format when it comes to update
harmless
they are basically to update the indexes
more of a write operation so the first
two sections is more or more or less
related to reads the last section on the
top layer is used for updating or
creating indexes
so you would have lot of a bit handless
apart from XML CSV binary you would also
have a data in boat handler which can
directly interact with the database
periodically and detect the changes and
import the data that is also possible so
there are some update handlers like
Jason and XSLT so the most commonly used
are either XML or JSON or in some cases
CSV as well okay so fine so now let's
understand a little bit on the search
components so we have seen their request
handlers so the search components enable
the rest search or the request handlers
so most of the time request handlers
only does search or support these search
on the index so it does support the
behavior of the search or request
handler by chaining the search
components so you can also change the
search components it is not that you
should only use one search component you
can choose okay and some of these
components are as mentioned you can
choose all of these components and you
can provide that feature power
functionality so we'll briefly talk
about some of these components so the
spell check component is used to check
the spellings based on dictionaries and
you have to provide that dictionary to
solar okay so so there are some standard
dictionaries you can use those standard
dictionaries and recommend did you mean
this okay
or you also can use the index itself as
a dictionary right you know all your
indexes
correctly spelled so you can use your
index itself as a dictionary to correct
and tell if someone is looking for a
Samsung phone and someone doesn't know
the spelling of it and type something
wrong so you can use your index itself
as a dictionary to to correct the
Spelling's and make write
recommendations okay so there are a lot
of advantage of doing that okay so apart
from that there are a lot of other
components like query elevation
component is basically used to elevate
the results based on some the end
conditions or criterion decisions which
we'll discuss that and there are some
stats component term component where you
can return all the statistics and all
that stuff okay so we will explore when
we go to that aspect of it so the
distributed search what it does is in
the new architecture it handles the
search components okay
when a file or when an index becomes too
large and if it is executing for a long
time so this component which is the core
of the solar cloud it splits the file or
the index into multiple places and it
places in two different machines so this
component is basically used to split the
indexes identifies where there is a free
space and places that into that machine
and when there is a request handler
coming in for a specific requests a
query component so it is handl to the
distributed search so the distributed
search knows where the content is and
splits it into that particular machine
request and
gets their response back and again it is
collated back and gives it back to the
request handler and then a response
writer takes it back and applies the
format okay so basically you can
directly use distributed search by the
HTTP web service by providing a simple
param parameter configuration and by
saying we're in one you wanted to read
or you can leave it to the distributed
search for Westwood taken care okay got
it happen okay here is it so the schema
and configuration blocks what you see is
basically everything is in schema so
there is a big component called schema
not XML which defines the solar database
instance so when it
a question so distributed search keeps
their server swear index stored in its
memory it's sometimes yes it can keep it
in memory or sometimes it can write it
back to a search control files most of
the time it is responsible for splitting
the index and breaking the index and
giving it back to those machines where
you can store those indexes okay
since the location of that particular
range remembering it in memory is much
more efficient so potentially yes or if
it is required could also persist into a
file system okay so you will we will
come across these two components called
schema and config so the entire
definition of a database schema or say
for example a up for anything related to
one application you can have multiple
instances or multiple databases running
in solar so for example you can have
four to five databases running in the
same server physical machine for four to
five different applications so every
application schema has to define its
fields columns what is being stored what
is being indexed what is the field type
all the definition of the that
particular schema which is very closer
or synonym to your traditional RDBMS
--is where we call it as one user
related to one application holds all the
tables or objects or the PL sequel
packages related to one application we
call it as schema so something similar
we define for one application we run
multiple schemas in solar
and it is all defined in the schema dot
XML you can have multiple instances
running or multiple schemas running in
solar and every schema or every instance
should have schema dot
we'll explore this in detail apart from
that there is another global solar
config dot XML defines the functionality
of the entire solar or entire course so
I was referring to you can run multiple
schemas right so sometimes it is also
called it as core so you can have
multiple cores running in one solver
somewhere ok so solar config is the
global configuration file which you will
use it for all the course or all the
instances running in solar server ok
fine so when we come to guys so far is
it clear can I get yes no any confusions
any clarifications okay fine fine so
when it comes to update handlers okay so
there are components which we can use
based on our needs like the logging
aspect or the signature aspect so we'll
see some of these things while we are
doing it so before we move further so
let's understand a little bit on the
update handler so what happens is
similar to the request Handler you may
have to also configure update handler
like say for slash update and then you
could give whatever the format it is
like say XML CSV or whatever other
format so once we have configured an
update request handler similar to the
search request Handler so the update
handler uses some of the components
which is configured for the update
handler like say for example I could use
the similar components like search
components there are a lot of components
say like I am adding a logging component
the first thing is the moment it comes
for update I'm adding a logging so that
it just adds and the next one I am
saying if there are any duplicates in
the fields or in the data in the field
data I am just removing that duplicate
data that could be one component I am
adding and then I'm adding the index
component so after this steps is done it
will index okay
or even before preparing the document I
could also use the request extractors
like data import handler sorry the PDF
or the rich document handler like a
solar cell or Apache digger and then
pass on to the update processors so all
these things is possible there are some
other aspect which I have mentioned the
data import handler on this component
where if you configure this component to
a update handler it will directly
retrieve all the information from the
databases and gives it to the update
components or processors now I am NOT
writing anything went head-on I am just
explaining the same things so you are
not missing anything ok so I am
explaining I'm explaining all the boxes
how the flow happens and this is the
high level architecture so if we
understand this as close as possible it
will be easier because this will be the
terminology what will be coming across
the course ok so once we have all the
content extracted from so the first
point is your request will hit the
update Handler and based on what
configurations or components you have
done it will go through the update
processors and then it would index the
content when it starts indexing the
content so it will use the same Apache
lousine layer like index writer and all
that stuff and it will write the content
to the index ok
so apart from there there could be some
common components like analyzers and all
that stuff which can be used across a
the requests portion or the update
portion so similarly the request flow
also happens the same way so you will
get a request heading to any of the
request component handler and based on
what you have configured on the chain it
will apply those components and then if
required it will it will so this is
basically gÃ¶ran Earth has a question so
this is basically the high level
architecture
Loreena we will get into the details of
each and every component so if I explain
this in more detail we will not get into
at this part at this point of time the
idea is to understand the architecture
and will explore all of those things
when we go there okay others will be
getting confused so now is it clear guys
we have two sections one is the request
Handler and its components and then it
uses the underneath Lusine library and
updates the index similarly you have the
update handler entry point uses all the
components and uses the underneath
indexing framework Lusine and updates
the index
this is the high-level architecture
component act architecture you okay so
for now don't worry about the components
all we need to do is to understand the
high-level architecture okay we will
understand what is this more like this
is what is the statistics debug
comprehend does what is faceting does
all that stuff will go and configure
each and every component that's what we
gonna do in the next few sessions we are
not going to do anything else every
component will pick will pick a use case
we'll see how to use that okay fine I I
take that as no and I hope it's pretty
clear right okay fine so let's explore
some of these things so the first thing
is we'll see the first glimpse of solar
okay how does it look okay so those who
haven't installed Java I would recommend
install the latest 1.7 Oracle JDK not
JRE JDK sometimes we would require some
of the libraries from the JDK so better
install the Oracle Java JDK and go to
the Apache Solr site ok and download the
4.10 version ok so this is the latest
version I'm not sure what is the latest
version since we have developed Aldi ok
so it's more or less for dot 10.3 so I
think we have more or less the similar
version so let me just check it out
so I guess we are using 4.1 4.1 so it's
better we take the same version of what
we are practicing okay it should not be
a huge difference because we haven't
tested it in the new version there are
prone to errors when there is a new
release immediately which happens okay
so it's better that we take the same
ones which we are working so you can
always download the earlier versions and
make sure we work with the four dot 10.1
and once you extract the contents into
the solar so at later point of the time
we may have to set the solar home so
what we do is just copy this if you are
in linux systems you have to export this
solar home and the folder the solar
folder path and carrot to be environment
variable over to your dot bash RC or
your profile environment if you are
running it in Windows you can also go
ahead go and add it to Windows and we're
on mental variables okay it's it's just
an optional step it is not that it is
required but it is an optional step
which will be helpful if we are running
multiple solar goes on different
containers rather than what we are
practicing it in in the labs okay so
once we download you will see the basic
solar folder extracted so I'll briefly
talk about what we can expect in this
folder so what's what's that you gotta
see in this folder is basically list of
folders and some
files once you extract and enter it into
solar folder this is what all you need
you don't need any other thing like a
server Tomcat at least for now because
solar bundles the basic version of its
downloadable with a jetty a minute jetty
server which is more than sufficient for
our lab exercises ok so you don't have
to download a Tomcat start the Tomcat or
copy the power file and do all that
stuff
for all our lab purposes this is more
than sufficient
ok so let's quickly explore what we have
got so the most important folder is what
you will notice in the example so this
is what we will be mostly focusing and
working with this folder ok so the solar
if you see this folder where we will be
dealing with all our cores or all our
instances so this is what I was telling
this is one schema this is one schema
this is one schema and this is another
schema or we call it as core as well
this is the another important folder
which will be working on ok
so apart from that for now we will only
look into the this folder where you will
have all of these things ok and if you
wanted to know where you can find your
web app content this is the solar web
content ok but actually you can find the
solar dirt war in deep web apps this is
required when you are deploying this in
a different container kind of a thing
otherwise you don't require the start
dot jar is configured to understand all
these aspects and run it in an embedded
jetty server if you are stuck with
something you can always go to
logs folder it will give you the and
their list of lock what's happening in
the server okay and apart from that you
would also have the docks the complete
docks of all the components or the
primary components and at times we may
also require some examples okay say if
you see there are some examples which
we'll be exploring it okay example docks
they have got some example docks where
we may have to use this example docks to
import the content instead of e
preparing for the content index the
content and search the content okay so
there are some libraries like all the
merit jetty server libraries and the
servlet api s-- and there is a very
important folder called extension folder
say if you are adding any custom based
jar file which you have to access it in
sola this is the folder where you have
to refer and this is the folder where
you have to keep all those jar files say
for example i am using a data import
handler from my sequel table so i need
to keep the JDBC connector library in
this folder so that when I configure the
data import handler it loads the JDBC
driver and reads the content using this
JDBC driver
otherwise it won't know how to connect
to a particular database so if you are
using Oracle you need to place Oracle if
you using say some other database you
need to place those libraries or
anything else for that matter
if you are referring a class file or if
you are referring something which is not
present in the standard solar server
you have to add those library files yeah
okay fine so for now we will just keep
our context till here and we will go and
understand this more in detail as and
when we are working so the most
important file what you have to remember
is this start dot jar file which we will
be using it extensively throughout our
exercises and throughout our course okay
so how do I start a solar server after I
download is pretty simple go to the
examples folder type Java - or - jar and
start not jar file which will start the
embedded jetty server with solar
instance running in it okay and when you
wanted to shut down all you need to do
is just press control C or exit from
that particular terminal or session and
the default port would be eight nine
eight three four slash Sola so let's try
this out so I already have Java so
that's how I was able to run all my
things but I in fact I think I have one
not eight should be fine
you can also try with the latest Java
version so there is no constrain that
you have to use one not seven so feel
free to try it out with the updated ones
as well it should be fine I'm guessing
so so let me go to solar folder
okay so this is the folder so this is
what I call it as solar home in the
solar fold of - 4.1 0.1 and then inside
that good ol example and type Java -
char start dot char so it should start
the server so it's just starting the
server okay so it has started the server
and now we can go ahead and access the
server so let's say okay I forgot to
know what is this just keeps on coming
I need to see something wrong with it
this is a virus or something I'm not
sure it just hurts movie time okay
so our solar is started so now I can go
ahead and query do see if you notice one
of these things what I mentioned here is
now in my server there are four cores or
four instances running so that's what I
have shown it to you in my solar this
thing so I have got four cores which is
coming in my solar ok so apart from that
everything went fine
so if I just wanted to check if the
server started up properly so you could
see there are some requests handless
okay already configured and it is
throwing me an error saying there are
multiple request handlers registered to
the same name so it should be fine but
it is giving me as in warping okay so we
could just check it out so what we can
do this if you just quickly walk through
some of the admin components so this is
the admin UI where you can access most
of the key components or key things okay
so let's understand what happened
exactly when I did Java - or - jar with
start down jar file so behind the scenes
the particular jar file had launched a
jetty the container listening on port 80
9 k3 okay so from solar point of view
actually it is nothing but the jetty is
running this solar dot war on top of the
jail JVM or on top of the
Java Virtual Machine fine
so every solar server has a solar
directory home you when it runs in the
web container which is identified as
solar dot home so this is the Java
system property which it loads and tries
to identify the location of where your
solar server is located so if it is
running in the embedded server it is
local and relative so you can always
trust that it is running it is running
from the related context and as I
mentioned you can have multiple course
say collection one collection to all
those things with different
configuration file and different index
data under the solar home so the first
thing what I would recommend is when we
are learning solar don't worry about
trying it out with the print inner or
JBoss or any other server for learning
purpose just stick to whatever the
embedded jetty server is more than
sufficient it fulfills all the means
later point of time in the project
development or not yes we will use
Tomcat access solar do all that stuff
but not now okay for now let's keep it
let's keep our focus 2d embedded jetty
server how do you shut down just if you
are in Windows terminal session just say
control C it would shut down the server
and you can restart it back by same way
okay so you can play started back using
the same approach fine so now we have
seen how to start solar server we
understood the basics of the solar
server are the web container and the
folder structures so I'm not going
through this one more time if required I
can just show you this is the same thing
what we have so you would notice it has
got all the documents and this is the
actual solar distribution jar files this
is not related to anything to jetty or
XML so this is the actual solar
distribution jar files which Solar
itself uses say for example there is a
analysis extra solar cell clustering
chorded I'm out handler this is all
related to solar features okay and there
are some so large a client features as
well so these are all related to the
solar features which you can find it in
the distribution document so in the
contract folder as you could see there
are lot of other folders like the
clustering aspects and all that stuff
you will find the related libraries
required to those particular more you
see extraction and all that stuff so
mostly this is all to do with the
directories which is holding all the jar
files and all that stuff we have seen
the example folder structure what it
contains primarily we should be only
worried about the solar where you will
find all the required
in schools running so apart from that
the license files are none we are not we
should not be that worried or we should
not be worried about it just take a
small look at the system requirements so
you can try using some of the JVM
parameters which will cover it using or
starting the even embedded jetty servers
you can pass in some command line
parameters how you wanted your solar
embedded server to react or behave okay
so we have just tried our exercise of
trying out so let's see what I really
meant with lab one just to confirm yeah
I think the lab one is for us to go
ahead and start the server acts as the
server and explore the content so let's
do it
fine so we have all these things so on
the dashboard you might notice all the
server when started okay what is the
version
what is the loosing implementation
version what is the JVM I am running and
what kind of processor this JVM is
running on and you could also see what
is my physical memory right and what is
my swap space and how much it is
allocated to JVM okay
currently I have allocated say I think
to 50 MB out of which 120 and 121 MB is
what being used right so in the locking
I could see all the
errors or warnings what has been loading
okay or I could go to the level and
select or choose the package and change
the log level itself for a particular
component at runtime so I could just say
go to a particular component okay
say let me just see you request
happiness
so request handlers I need everything to
be handled okay let's see now when I go
to request handlers all the today say
yeah everything is logged
now let's say if I go to another window
okay so let's see the login it is still
taking its own time to load okay Norris
so you can change the log levels and if
you see the log files you should get all
the errors and everything what is
happening in the log files so the core
administrative the core administration
what you would notice is you can add a
new core and say this is my core as I
mentioned for every new code you should
have a data directory and this is what I
meant schema and config so you should
have one schema and one solar conflict
defined and once you do that you can
create your own collection okay so you
can also do some of the things like
there could be at times when you wanted
to reload the index or reload some of
the
configurations to particular instance
oil cool you can definitely do that so
we will go through this rainy anything
just in case if you wanted to rename the
collection maim and all that stuff and
just in case there are some Auto tools
where you wanted to optimize the index
if there are too many local say segments
created which is not yet merged and all
that stuff you can optimize it just by
click of a button
it will try to optimize the indexes
which are pending to merge and all that
stuff ok so it can be done at various
course okay and you'd see the instance
directory data directory and all this
stuff and you could see what is the
maximum content footprint it has got on
all this stuff ok
so apart from that there there are a lot
of Java properties which you can see
what is the current Jo properties it has
got or you can override some of these
things while starting the server if you
want okay so this one is just like your
standard thread dump of your gem so you
should not be worried too much just in
case if you are stuck with something so
you don't know you
you filed a query and it is stuck so in
those kind of cases you might require to
just take a thread down look of the JVM
you
okay so once you this is more of generic
to the server once you see see across
all these things so there are four cores
which are running in this server so
let's choose one of these cores and see
you can have options of or view okay you
could do analysis on a particular field
this is a very very useful feature which
will cover it in detail and we'll see
what what kind of analysis we can
provide when we do the analysis part of
it okay very useful feature for
debugging okay and the data import
handler if we define it will create the
data imports from your traditional RDBMS
system and documents is nothing but you
can query the document or update the
document sorry update the document with
a update request handler you can
directly type the XML copy paste the XML
or the Jason I said there are multiple
update handlers there could be CSV there
could be doc of Jason there could be XML
from the solar command raw thing or file
upload or whatever option so we could
also see all the configuration files and
all that stuff and I think this is just
a very basic thing so now you could see
all the plugins or start components what
this particular instance is using say
for example I am using all the
highlighter the query parser in the
query parses these are all the query
parses what I can potentially use a lot
of other lot of useful query parses and
update handlers if you see I have got
one update handler and when you go to
very this is how you will use this
section to query the documents you will
get all the documents and we can specify
which query parser what is what should
be the response format all that stuff
will keep using all these things if you
notice see the format changes this was
what I was telling as a response object
based on the type it would change and
you can play around with some of these
things based on say if I want from only
one to two records so I would only get
two records so everything is possible so
you could do all that stuff the
application will cover it later so you
can also browse this schema and see what
on all the fields has been included it
would tell you exactly the definition of
what we are doing with that particular
feed okay and it would tell you what
kind of analyzer we are using with that
feeling and all that stuff okay so
that's a brief overview of what we have
been supposed to do in the lab
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>