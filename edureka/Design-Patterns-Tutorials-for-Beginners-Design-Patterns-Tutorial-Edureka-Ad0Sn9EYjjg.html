<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Design Patterns Tutorials for Beginners | Design Patterns Tutorial | Edureka | Coder Coacher - Coaching Coders</title><meta content="Design Patterns Tutorials for Beginners | Design Patterns Tutorial | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Design Patterns Tutorials for Beginners | Design Patterns Tutorial | Edureka</b></h2><h5 class="post__date">2015-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ad0Sn9EYjjg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the design patterns is our opportunity
to collaborate interact gain knowledge
and today we are going to see and feel
how the training course is going to be
like with that let's begin at the end of
this session we should be able to
understand and appreciate the need of
design patterns we should be able to
build some flexible design using select
design patterns we will look at the UML
diagrams what they are why wouldn't God
use them we will look at the abstract
factory pattern gobs of a pattern and
the mediator pattern so let's understand
what a pattern is when you are seeing my
screen you will see there are some
diagrams in a sequence and some of us
might have played with these kind of
questions and trying to figure out what
is the next number or diagram or an
alphabet this is a very general problem
statement in the in the worlds of
aptitude tests and this is how and
therefore ability to figure out the
pattern is is a crucial one now the the
pattern that we have on the screen here
is a solution one of the characteristics
of the pattern are that are that they
are easy to recognize right and we see
them all the time
we just need to observe and you will see
the patterns and the real-life
everywhere you look at it and that makes
them very powerful because they're
observable easily observable the other
people can also appreciate it and deduce
logic maze on it moreover patterns come
in handy because they are answers to
some recurring problems and because the
problem is recurring its best-known
solution that is pattern is also
recurring so you will see the yellow
highlighted numbers are or diagrams are
the the next in the sequence because we
were trying to identify a pattern since
all of us here are some sort of software
developers the next question would be
other patterns in the software
development there are problems in the
development can we figure out some
recurring solution to these these
problems and the obvious answer is yes
and it's not only just plain simple yes
it is oh definitely yes and we should
consider using those patterns because
they are recurring solution they are
very well understood by the industry and
industry has also analyzed them for
their weak points and the strong point
where should be used them on the context
of the problem and the constraints that
is what can we do or not do with those
patterns here comes our our pioneers in
the space of design patterns the called
Gang of Four and they were one of the
first ones to catalog the design
patterns now note this these Gang of
Four guys did not invent the patterns
they just analyzed the existing systems
and draw commonality and catalogued them
that is listed them as the design
patterns and it was a groundbreaking
book the one that they wrote because it
changed the way we think about strong
threads and we then started saying ok so
if we know the problem statement and
there if there is a match we can very
well pick up a design pattern from the
catalog and
and so on the problem and we don't have
to bang our head or to figure out how do
I solve it and also meet all the
constraints and make it maintainable so
before I move on to the next slide
note their faces house my house house
how happy they seemed to be so
importance of the design patterns well
one of the most important part in design
patterns is industry experts understand
them and so can you are in my peers and
it brings up a common language for
people to talk to each other when they
are talking about software development
they also are based on in recent time
something called object-oriented
programming paradigm which is the most
popular mythology of developing the
software but it also comes with a
downside a downside is that many
programmers and sometimes even designer
falsely assume that design patterns and
object-oriented paradigms are one and
the same but they are not in general
patterns and then design patterns are
nothing to do with a specific kind of
programming paradigm in this case object
oriented because object-oriented is more
prevalent therefore the design patterns
for object-oriented world are more
prevalent most importantly these design
patterns are tried and proven solutions
to programming problems the problems
that recur and if we choose to implement
a particular design pattern to solve a
particular problem it guarantees us that
the next person who's going to maintain
the code understands it because they
will be able to understand the design
pattern and we also know the weaknesses
and strengths of those design patterns
so should the context change we will be
really looking at the design pattern and
say whether it is still
okay to use or should we switch it
toward or swap it out in favor of
another design pattern today we are
going to look at a use case a problem
statement we are gonna say that let's
let there be some sort of factory a
factory which which consumes the raw
material and produces the finished good
that factory could be a cement factory
or a pickle factory or a cheese factory
even a chocolate factory if you like the
factory is going to get some material
some raw material there would be some
automated machines that keep track of
the speed the temperature the
ingredients and all and the data
captured we use the data is captured
using sensors various sensors employed
in this automated system and these
sensors are going to send their input to
the master control system the master
control system will look at those sensor
values and operate on the data that
operate on the data decide what action
to take and then action is relate to
something called actuators which may
change the temperature or may change the
mixture proportion these machines
operate in coordination if one of the
part fails the the operation is kind of
cannot be completed so there needs to be
communication between these entities in
your factory for example a temperature
sensor talking to the master controller
and master controller talking to maybe a
furnace an electric furnace to either
lower the temperature or increase the
temperature a real-world scenario the
question will be how can we build this
automated system
so we'll continue with this use case and
requirement we are saying that let there
be different entities that are
monitoring data generated by the sensors
each entity can take its own decision on
data as well as inform to other for
example a temperature sensor may display
it to a human operator as well as send
that data to the master controller and
there is a master management control
room where the commands for two
different entities are generated which
is Soltis which is solely responsible
for the good then safe operations and
the data is from the entities is also
sent back to the master management
control room where it is processed and
actions can be taken in some cases even
the audit logs can be generated with
that moving on here is the general
depiction of how the solution would look
like there could be packaging entities
the master management control the
catalyst control and the chemical
control entity and you see these blue
diamond
they are actuators so all these bubbles
are gonna operate on actuators and
there's yellow rectangles are our
sensors who are gonna send data to these
bubbles if you look at it the master
management control is a central entity
which is responsible for the operation
of this factory where are the three
other entities which are separate
domains some handling chemical
composition catalysts and packaging but
it is the master management controller
system which orchestrates various
operations in this
so this is going to be a general
depiction we will then come to how a non
object-oriented world can program it
they will probably go by procedural
system and they will put all the
functionality pertaining to management
control into something called a main
function and the main function may have
certain other helping procedures or
child procedures subroutines which allow
me into segments it works well it may
solve your problem but it may be hard to
maintain what happens for example the
catalyst composition
needs to change you'll have to figure
out the exact procedure where it needs
to change go update that procedure we
compile your code test it out and then
deploy it into a production system now
the challenge here of the procedural
system is that it thinks like human
brain you know I walk up the stairs if I
need to go to let's say a third floor I
know that I have to walk up to the base
of the staircase or at the elevator area
and do a next step maybe start climbing
up or requesting the elevator based on
what we choose to do and so on and so
forth essentially a procedural language
is more like one looking it from a
single point of view in this case if a
human needs to go to the third floor
human will start thinking what he needs
to do and not what environment what
needs to happen in the environment that
he is living in such procedures would be
good if you are building a very small
application may be something that
accepts the data in the single form in a
web UI but this cannot scale when we are
talking about complex enterprise wide
applications especially those
applications who are to be which are to
be maintained
for let's say five to seven years in
fact what ends up happening if you write
procedural programming there is you
write a lot of spaghetti code and
therefore in general one would want to
move into the object-oriented paradigm
where each entity is represented by an
object or set of object and that allows
you to maintain the program in the long
run here comes the object-oriented
world's kind of introduction with any
technology it's not going to solve all
your problems just by using it one has
to be a little more intelligent as to
find out how to use it there is an old
saying which goes like the one who has a
hammer thinks that every problem or
everything is an L we will be doing good
if we remember that we don't own a
hammer and if we hold an own hammer not
every problem is a nail you don't have
to use the same old stuff to solve any
new problem then what problem should we
be solving by having that hammer or in
this case having some known solutions
that's where need of understanding
design pattern comes in so talking let's
talk a little bit about object oriented
on the slide an object oriented program
may take a master control master or
manager management control unit in a one
object and subsequently different
entities are different objects and you
one would want them to talk to each
other to achieve certain use kiss so as
rightly noted there um once we have
identified the objects the only
remaining part is to find out how they
will talk to each other communicate to
each other yeah to to achieve a same
common goal in this case the use case
that we talked about
when we look at it we definitely know
that there is something missing
and what is what is it missing well how
about a change required because there is
a new research coming in or how about I
want to scale up my IP application in
this case for example I want to increase
the unit production all day of my
factory in a software world that will
mean how can I make my application run
faster and most importantly which is the
life of any software it has to evolve
because the business needs change and
sometimes we add functions or features
to the existing existing software let's
say in case of a cement factory I want
to change my packaging from a 50 kg bag
to maybe a 10 kg bag or and
I also want to let's say change the
material of the sack in which my cement
gets packaged in so in the in the life
of a software it is important to
understand initially that a code needs
to be maintainable if I may share with
you some statistics it is very likely
that a software application will spend
80% of its life time in the maintenance
mode where you know you're just making
sure that the software survives in the
production perhaps we spend about 10 to
12 percent of the time designing a
system and only maybe 8% time to write
the code and test the code and therefore
while building any system one has to
also consider what does it take to
maintain it and that is where if you
know the design patterns and if you
apply them correctly the answers will
come naturally every design pattern will
have
as I said its own strength and weakness
and what matters in the maintenance mode
office oft where is how do we cope up
with the weakness of any system so as I
said the design patterns are are kind of
catalogued right and if you know the
design pattern and if you know how to
use it you would be a better software
developer but there is a difference
between knowing what a pattern is and
knowing how and when to use it if I may
draw your attention to a difference
between a knowledge and a wisdom in
knowledge we'll say oh there is a design
pattern catalog wherein there are
patterns XYZ and it is to be applied in
certain cases but it is a wisdom which
will tell you when exactly to use it
when it when you should not be using it
and generally that comes with experience
and I'm here with you to share that
experience and some sort of wisdom there
is an old saying if I may quote it here
knowledge is like knowing that tomato is
a fruit but wisdom is knowing that it is
not to be put into a fruit salad so if
you look at a design pattern catalog and
you find out oh well there is an
abstract Factory
but if you don't know when and how to
use it that knowledge is not really not
really useful isn't it you'll probably
be creating more mess than you started
with and that's where we come in we want
to share with you the experience that we
have in industry and knowing for example
in abstract Factory what is it and how
to use it and what is the consequence of
using it in the maintenance mode so with
that I am moving to the next slide we
are saying that we will model this
manufacturer entity
with some design patterns for example if
you don't do it with design pattern it
will work but then in future when you
want to extend the functionality or make
it more maintainable or scalable it will
be a hard task to take up sim the so
when I also have to understand okay most
of the time we think about building a
new software have we thought about when
the software dies well I can tell you
that a software dies meaning the
software is taken out of production when
it is no longer economical to maintain
it the code has become something called
a spaghetti code the original developers
who developed it are no longer with that
organization and they the new developers
did not perhaps got the entire Katie or
did get the Katie but did not get their
facts together and it is cost
prohibitive to add feature to that
software in such cases the architects
and the business stakeholders will want
to think about building a brand new
system and if that brand new system is
not developed well the cycle repeats
very soon the software will age it it is
not beneficial to maintain or it is a
cost prohibitive to maintain that system
in production and then architects and
business stakeholders or holders will
come and say oh they want to build a new
system so using the right solution in
this is right design patterns extends
the life of the system and that's where
it is important for us to know the
design patterns and know how to use it
not only for the fresh or greenfield
projects but also for the projects under
maintenance design patterns are
generally a common language between the
development organizations for example if
you are building an abstract factory
pattern somewhere in the comments you
will say that well this is a standard
abstract factory pattern and let's say
three years four years down the line
somebody won't
to come in and men in the maintenance
mode in Hanson are our kind of make some
changes because of maybe a business in
are you changing the person will read a
track factory part and he easily be able
to correlate the related classes to
those entities in the track factory or
any other pattern for that matter that
makes it very maintenance of a large
enterprise scale applications moderately
easy to maintain now they are because
design patterns are proven solution you
also know the consequences should there
be a mint in the maintenance mode should
there be a added requirement to a
scenario which makes that design pattern
not so lucrative one will have an option
of swapping out that design pattern in
favor of some other design pattern which
makes motions and that's where it's very
important to understand how to use
design patterns moving on we will talk
about something called a unified
modeling language it is a decrement
diagrammatical representation of how the
solution will look like a in most of the
time it is an object-oriented solution
that will look like and if I have to
quote another saying it says a picture
is worth more than thousand words same
is in UML it is worth more than maybe a
1 kilo lines of code and why it is
important because not only the
programmers but also architects and the
system engineers and the business
stakeholders can understand and
appreciate the design expressed in the
UML another benefit of UML is it is
programming language independent you can
have a UML and
use tools to let's say forward engineer
your UML design into a Java code or a
dotnet code or in any other programming
language that the tool supports talking
about UML um it is set of predefined
diagrams and set of notations that one
would use to show various aspects of the
objects or classes there are set of
diagrams are shown on the picture or the
categorization of them essentially they
are structural and behavioral diagrams a
structure has something to do with the
static representation of the class or a
package or component sometimes it also
shows how your component is deployed in
the production system a behavioral
diagram will talk about how the runtime
behavior of the program is in that sense
one would draw an activity diagram which
is which is in part similar to a flow
diagram telling how program will execute
a use case diagram telling how the
program will be used a system will be
used a state diagram that talks about a
state of a particular entity so on and
so forth now remember that not all these
diagrams are useful in a given context
for example if you are not gonna do any
real-time system development you may not
even worry about a timing diagram it may
not add value to your design but there
will be places where you would want to
use let us say a sequence diagram
showing how the sequence of call flows
happen in a particular I use case
realization for all these questions we
are not gonna do do a lot of UML kind of
designs or notations so if you have not
looked at in-depth UML do not worry we
will just be drawing some block diagrams
and and using very minor minor features
of the UML will not be going into
advanced UML so nobody is if you have
not looked at the you
there are tools to draw these diagrams
the free ones are or go UML dia um let
Star UML they are free open-source with
simple user interface allows you to
create some diagrams so quite quickly
and there are enterprise level modeling
software applications like an Enterprise
Architect by Microsoft
there is also an Enterprise Architect by
IBM there's a magic draw by pneumatic
corporation an IBM has always been
leading with rational rows and likes of
tools with tools such now most of the
commercial software's will allow you to
do a forward wrench engineering as well
as reverse engineering a forward
engineering will allow you to convert a
particular design into code and a
reverse engineering will allow you to
import your code into UML it will read
the code and generate the human diagrams
for you
and what is interesting is almost all
these tools free words as well as the
paid ones come up with a set of design
pattern applications so you can put in
the you can come come into the tool and
say Oh
draw me a abstract Factory and it will
draw you an abstract Factory and you
will end up changing only the class
names again tools make life easier but
what needs to happen is the user must
understand how to use a tool and then
how to use a design pattern that the
tool is going to draw draw for you with
that let's talk about that track factor
in our problem space we are looking at
maybe building a cement factory or a
cheese factory now do not confuse these
these cheese factory with abstract
factory because the names are the same
what happens in abstract Factory is it
generates the factory classes for a
one-of-a-kind of objects for example if
you are going to build a cement factory
an abstract Factory will give you an
actuator factory as well as the sensor
factory that is applicable only to
cement factory and not let's say it is
factory because the actuators and
sensors and the world of cement factory
will be drastically different than those
for let's say a cheese factory or a
pickle factory if you like a pickle so
abstract factory allows you to generate
the particular category of classes in
this case an actuator for cement factory
will always be generating the the flow
sensors are you know the weighing
sensors for cement factory whereas the
the pickle factory will have a different
kind of sensors or and/or actuators so
depending on which factory we are
building the client will ask abstract
factory to get you the get you the
specific factory for that problem
sentence let's say a cement factory and
then client will start using those to
generate the actuators and sensors now
an abstract factory always works with an
abstract representation of the real
object in this case it can be an
interface or an abstract class and the
factories generate the concrete classes
for those in this case for example an
abstract actuator is known to the client
but client does not know what is a
furnace actuator and how to construct it
that will be constructed by the actual
actuator factory same is the case with
let us say a flow actuator or a
temperature sensor or a flow sensor
so that's an abstract factory again or
if you want to relate it to a real time
real-life example in a software world
consider abstract Factory as your theme
in let's say Windows ok so when you
apply a theme you just choose a
different theme Factory and that theme
factory will give you the actual
instance of Windows the start bars the
buttons and the background color and all
those tough stuff when as a user you
change your theme the client underneath
is going to change the factory
implementation specific to that chosen
theme and you all of a sudden you will
see your buttons and bars and everything
is changed because the Dijkstra client
is going to use a different factory to
render those in the Java world you will
see a AWT or a swing toolkit being using
the similar abstract factory
implementation what is the beauty of
abstract factor implementation well you
can plug in another set of factories to
the implementation and your client does
not know what's happening under under
the hood in that traffic factory all the
client will ask abstract factory is to
get a factory of a particular kind and
that factory of a particular kind will
give that real instances of the object
so thus we avoid something called ripple
effect let's talk about a little bit
about a ripple effect a ripple effect is
in need of changing one or more objects
because one object changed in this case
we have contained the ripple effect
let's say we build another factory for a
different theme the client does not have
to change therefore the changes are only
constrained within the abstract factory
and nowhere else so abstract factory
good if you want to change the behavior
of a set of classes and it allows you a
plug-and-play kind of behavior if you
design
right the client does not need to change
and thus you can add more behaviors on
the fly when you need them the next page
we're going to talk about a yet another
pattern called an observer patterns as
the name suggests an observer pattern
will allow you to observe a particular
subject or a class a class under
observation is generally named a subject
so what ends up happening is your
observer will subscribe to the subject
and when there is a and when we say
subscribe to a subject right it
subscribes to a state change or in that
subject and what ends up happening is
the subject will notify back to the
observer when the when the state that
observer was interested in changes so if
you look at the next diagram on the page
it shows you some UML diagram and you
don't have to worry about the UML
diagram if you don't know it it will
show you a subject and observer a in
line between subject and observing of
Association the observer will attach
itself to the subject or somebody will
log or somebody else will attach the
observer to the subject that could be
your master program an observer can be
detached an observer when attached gets
notified when a state of a subject
changes and then observer updates itself
or update does some sort of a update
operation and keeps listening for any of
your future subject changes or subject
state changes in the lower half of a
diagram you will see that there is a
packaging a concrete subject and a
chemical control called and concrete
observer and
and the packaging's state changes it
will call it will notify the chemical
controller with an object state with a
new object objects state and the
chemical control will kind of update
itself with that new state and that uh
that operation it may tell about the
change in the packaging to master
control with that let's move on and talk
something about a mediator pattern now
we talked about observer one would
relate these observers to the sensors
like an observer will be attached to a
sensor and when the sensors value for
example a temperature changes it will
tell it to the observer and then
observer will tell it to the two
probably the master controller but then
the mode number of observers you have
and sensors you have the communication
paths between these observers and the
and the master controller becomes
complex right there are let's say ten
different observers all of them telling
there's their values or talking to the
master controller or in some even more
complex scenarios the observer is
talking to each other
which will then be a computational value
and the complexity will grow
exponentially
for example then objects talking to each
other will mean 90 independent paths in
which they can talk to each other such
code becomes quite complicated to
maintain and very prone to bugs and
defects to be introduced and therefore
in general as a good practice we avoid
multiple communication channels between
multiple objects or entities interacting
because there will be so many paths of
negation the testing becomes hard in
fact it becomes real hard and therefore
we will look at a pattern called a
mediator pattern where we limit how much
objects can talk to each other
and it is achieved by something called a
mediator interface each each object
which is in this case we call them
colleagues in our cases they could be
observers and each observer who wants to
communicate with another entity will not
talk to that entity directly but go
through a mediator right it's like a
person standing in a hallway and
everybody everybody in the room in their
own room talking to that person in the
hallway communicating the message the
person goes to the next room and
delivers it to a concerned person so
let's say if you have gained 10 rooms
and there are 10 people lost it one
person sitting in the each room instead
of a one person going to nine other
doors you talk to this person in the
hallway and that person goes to whoever
the message was for so thereby if you
have 10 objects in in earlier case we
are saying 10 objects talking to each
other will mean 90 independent parts
here we are saying 10 objects all of
them will talk to a mediator and listen
from mediator all of a sudden our
independent communication paths become
twenty ten for each ten paths for the
observer was talking to mediator and ten
parts for paths for mediator talking to
ten different objects that reduces
complexity the observer that we were
talking about the object in the mediator
pattern is cortically because he is
colleague to the mediator and colleague
may have different concrete instances of
all the
on the all those people who are our
objects were trying to talk a mediator
is an interface so colleagues know about
the mediator interface but the actual
concrete object or class may be
different and because it is interface
driven the controllers or the colleagues
do not know about do not not need to
know about what the concrete mediator is
if we draw the parallel to the the man
standing in the in the in the corridor
in the hallway the person sitting in the
room only needs to know how to talk how
to talk to that out that person maybe
he's he can only speak in English so
you'll only talk in English but you
didn't don't need to know the name of
that person or in what shift that person
is going to work and all that stuff the
person is still there you just need to
know that he can talk in English and he
knows how to communicate a message to
other colleague and that's all so in the
in the UML depiction diagram there is an
association between a mediator and a
colleague and a mediator is extended or
subclassed
into a concrete mediator and the
colleagues may have one or more concrete
instances of a concrete classes of the
colleagues with that we have these three
patterns that will help us solve the
cement factory or a pickle factory or a
cheese factory problem much easier the
mediator will talk to the central
controller the colleagues will be all
sensors the observers will be rather the
colleagues will be all the observers and
the sensors will be observed by the
observer and you have this abstract
factory pattern which allows you to
generate a specific category of sensors
or actuators
and there are more design patterns to to
solve the majority of the problems in
the software designs and why there are
so many design patterns because there
are so many problems and because those
problems can be solved successfully by
managing the constraints and optimizing
the benefit and it is an ever growing
scenario
note that the design patterns are never
ever invented they are discovered that
discovered through practice and then are
documented however in recent times in an
object-oriented while there have not
been new new patterns introduced because
the field is quite mature now and
therefore we as object-oriented program
or should always ask if there is a
problem is there a solution ready-made
that I can employ and speed up my
development and also make the software
cost effective and in the innocence in
the training that we are going to attend
that will that will be our focus how can
we make you efficient how can we make
you a smarter software developer and
designer and design patterns knowing
them and knowing them well knowing how
to use them
goes a long way in making one a good
software developer though the design
pattern because we will be using a
common terminology are also easier to
communicate for example in a mediator
pattern if you say Kali people will
understand what a curly here or in an
observer pattern if you nose if you say
subject people will know subject is
something that is being observed for the
state change more and more the software
field is maturing it is no more an art
but it is a skill or skill that one can
learn
and a skill that will make you a better
programmer and knowing design patterns
is an important skill in that that that
spectrum it allows you to talk to maybe
your seniors your architects your
colleagues in a common nomenclature and
it allows them also to get a feel that
you understand and know what you're
talking about and you're not talking
something that you know does not sound
good or sound foolish if I may use that
word
if you say for example an abstract
Factory and a concrete factory it is
better you know what you mean and it is
also easier for architects and the
stakeholders to understand oh you are
saying abstract Factory that means okay
I know this this problem will be solved
or not solved like based on whether you
applied it correctly or not
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>