<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Understanding Design patterns | Why Design Patterns | Design patterns Tutorial for Beginners | Coder Coacher - Coaching Coders</title><meta content="Understanding Design patterns | Why Design Patterns | Design patterns Tutorial for Beginners - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Understanding Design patterns | Why Design Patterns | Design patterns Tutorial for Beginners</b></h2><h5 class="post__date">2015-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bj96UI_F0QI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the design patterns is our opportunity
to collaborate interact gain knowledge
and today we are going to see and feel
how the training course is going to be
like with that let's begin at the end of
this session we should be able to
understand and appreciate the need of
design patterns we should be able to
build some flexible design using the
Select design patterns so let us
understand what a pattern is when you
are seeing my screen you will see there
are some diagrams in a sequence and some
of us might have played with these kind
of questions and trying to figure out
what is the next number or diagram or an
alphabet this is a very general problem
statement in the in the worlds of
aptitude tests and this is how and
therefore ability to figure out the
pattern is is a crucial one now that the
pattern that we have on the screen here
is a solution one of the characteristics
of the pattern or that are that they are
easy to recognize right and we see them
all the time
we just need to observe and you will see
the patterns and the real-life
everywhere you look at it and that's
makes them very powerful because they're
observable easily observable the other
people can also appreciate it and deduce
certain logic based on it
moreover patterns come in handy because
they are answers to some recurring
problems and because the problem is
recurring its best-known solution that
is part and is also recurring
so you will see the yellow highlighted
numbers are or diagrams are the the next
in the sequence because we were trying
to identify a pattern since all of us
here are some sort of software
developers the next question would be
are there patterns in the software
development there are problems in the
development can we figure out some
recurring solution to these these
problems and the obvious answer is yes
and it's not only just plain simple yes
it is
or definitely yes and we should consider
using those patterns because they are
recurring solution they are very well
understood by the industry and industry
has also analyzed them for their weak
points and the strong point there should
be used them or the context of the
problem and the constraints that is what
can we do or not do with those patterns
here comes our our pioneers in the space
of design patterns they called Gang of
Four and they were one of the first ones
to catalog the design patterns now note
this these gang of four guys did not
invent the patterns they just analyzed
the existing systems and draw
commonality and catalogued them that is
listed them as the design patterns and
it was a groundbreaking book the one
that they wrote because it changed the
way we think about short threads and we
then started saying ok so if we know the
problem statement and there if there is
a match we can very well pick up a
design pattern from the catalog and
and so on the problem and we don't have
to bang our head or to figure out how do
I solve it and also meet all the
constraints and make it maintainable so
before I move on to the next slide
note their faces house my house house
how happy they seemed to be so
importance of the design patterns well
one of the most important part in design
patterns is industry experts understand
them and so can you are in my peers and
it brings up a common language for
people to talk to each other when they
are talking about software development
they also are based on in recent time
something called object-oriented
programming paradigm which is the most
popular mythology of developing the
software but it also comes with a
downside a downside is that many
programmers and sometimes even designer
falsely assume that design patterns and
object-oriented paradigms are one and
the same but they are not in general
patterns and then design patterns and
nothing to do with a specific kind of
programming paradigm in this case object
oriented because object oriented is more
prevalent therefore the design patterns
for object oriented world are more
prevalent most importantly these design
patterns are tried and proven solutions
to programming problems the problems
that require and if we choose to
implement a particular design pattern to
solve a particular problem it guarantees
us that the next person who's going to
maintain the code understands it because
they will be able to understand the
design pattern and we also know the
weaknesses and strengths of those design
patterns so should the context change we
will be really looking at the design
pattern and say whether it is still
okay to use or should we switch it
toward or swap it out in favor of
another design pattern today we are
going to look at a use case a problem
statement we are gonna say that let's
let there be some sort of factory a
factory which which consumes the raw
material and produces the finished good
that factory could be a cement factory
or a pickle factory or a cheese factory
even a chocolate factory if you like the
factory is going to get some material
some raw material there would be some
automated machines that keep track of
the speed the temperature the
ingredients and all and the data
captured we use the data is captured
using sensors various sensors employed
in this automated system and these
sensors are going to send their input to
the master control system the master
control system will look at those sensor
values and operate on the data the
operate on the data decide what action
to take and then action is relayed to
something called actuators which may
change the temperature or may change the
mixture proportion these machines
operate in coordination if one of the
part fails the the operation is kind of
cannot be completed so there needs to be
communication between these entities in
your factory for example a temperature
sensor talking to the master controller
and master controller talking to maybe a
furnace an electric furnace to either
lower the temperature or increase the
temperature a real-world scenario the
question will be how can we build this
automated system
so we'll continue with this use case and
requirement we are saying that let there
be different entities that are
monitoring data generated by the sensors
each entity can take its own decision on
data as well as inform to other for
example a temperature sensor may display
it to a human operator as well as send
that data to the master controller and
there is a master management control
room where the commands for two
different entities are generated which
is Soltis which is solely responsible
for the good and safe operations and the
data is from the entities is also sent
back to the master management control
room where it is processed and actions
can be taken in some cases even the
audit logs can be generated with that
moving on here is the general depiction
of how the solution would look like
there could be packaging entities the
master management control the catalyst
control and the chemical control entity
and you see these blue diamond
they are actuators so all these bubbles
are gonna operate on actuators and those
yellow rectangles are our sensors who
are gonna send data to these bubbles if
you look at it the master management
control is a central entity which is
responsible for the operation of this
Factory where are the three other
entities which are separate domains some
handling chemical composition catalysts
and packaging
but it is the master management
controller system which orchestrates
various operations in this so this is
going to be a general depiction we will
then come to how a non object-oriented
world can program it they will probably
go by procedural system and they will
put all the functionality pertaining to
management control into something called
the main function and the main function
may have certain other helping
procedures or child procedures
subroutines which allow main to segment
it works well it may solve your problem
but it may be hard to maintain what
happens for example the catalyst
composition needs to change you'll have
to figure out the exact procedure where
it needs to change go update that
procedure we compile your code test it
out and then deploy it into a production
system now the challenge here of the
procedural system is that it thinks like
human brain you know I walk up the
stairs if I need to go to let's say a
third floor I know that I have to walk
up to the base of the staircase or at
the elevator area and do a next step
maybe start climbing up or requesting
the elevator based on what we choose to
do and so on and so forth essentially a
procedural language is more like one
looking it from a single point of view
in this case if a human needs to go to
the third floor human will start
thinking what he needs to do and not
what environment what needs to happen in
the environment that he is living in
such procedures would be good if you are
building a very small application may be
something that accepts the data in the
single form in a web UI but this cannot
scale when we are talking about
complex enterprise wide applications
especially those applications who are to
be which are to be maintained for let's
say five to seven years in fact what
ends up happening if you write
procedural programming there is you
write a lot of spaghetti code and
therefore in general one would want to
move into the object-oriented paradigm
where each entity is represented by an
object or set of object and that allows
you to maintain the program in the long
run here comes the object-oriented
world's kind of introduction with any
technology it's not gonna solve all your
problems
just by using it one has to be a little
more intelligent as to find out how to
to use it there is an old saying which
goes like the one who has a hammer
thinks that every problem or everything
is an L we will be doing good if we
remember that we don't own a hammer and
if we own an own a hammer not every
problem is a then you don't have to use
the same old stuff to solve any new
problem then what problem should we be
solving by having that hammer or in this
case having some known solutions that's
where need of understanding design
pattern comes in so talking let's talk a
little bit about object oriented on the
slide an object oriented program may
take a master control master manager
management control unit in a one object
and subsequently different entities are
different objects and you one would want
them to talk to each other to achieve
certain use kiss so as rightly noted
there um once we have identified the
objects the only remaining part is to
find out how they will talk to each
other communicate to each other a to to
achieve a same common goal in this case
the use case
we talked about when we look at it we
definitely know that there is something
missing and what is what is it missing
well how about a change required because
there is a new research coming in or how
about I want to scale up my IP
application in this case for example I
want to increase the unit production per
day of my factory in a software world
that will mean how can I make my
application run faster and most
importantly which is the life of any
software it has to evolve because the
business needs change and sometimes we
add functions or features to the
existing existing software let's say in
case of a cement factory I want to
change my packaging from a 50 kg bag to
maybe a 10 kg bag or and I also want to
let's say change the material of the
sack in which my cement gets packaged in
so in the in the life of a software it
is important to understand initially
that a code needs to be maintainable if
I may share with you some statistics it
is very likely that a software
application will spend 80% of its life
time in the maintenance mode where you
know you are just making sure that the
software survives in the production
perhaps we spend about 10 to 12 percent
of the time designing a system and only
maybe 8 percent time to write the code
and test the code and therefore while
building any system one has to also
consider what does it take to maintain
it and that is where if you know the
design patterns and if you apply them
correctly the answers will come
naturally a pre-designed pattern will
as I said its own strength and weakness
and what matters in the maintenance mode
of a software is how do we cope up with
the weakness of any system so as I said
the design patterns are are kind of
catalogued right and if you know the
design pattern and if you know how to
use it you would be a better software
developer but there is a difference
between knowing what a pattern is and
knowing how and when to use it if I may
draw your attention to a difference
between a knowledge and a wisdom in
knowledge will say oh there is a design
pattern catalog wherein there are
patterns X Y Z and it is to be applied
in certain cases but it is a wisdom
which will tell you when exactly to use
it when it when you should not be using
it and generally that comes with
experience and I'm here with you to
share that experience and some sort of
wisdom there is an old saying if I may
quote it here knowledge is like knowing
that tomato is a fruit but wisdom is
knowing that it is not to be put into a
fruit salad so if you look at a design
pattern catalog and you find out oh well
there is an abstract Factory
but if you don't know when and how to
use it that knowledge is not really not
really useful isn't it
you'll probably be creating more mess
than you started with and that's where
we come in we want to share with you the
experience that we have in industry and
knowing for example in abstract Factory
what is it and how to use it and what is
the consequence of using it in the
maintenance mode so with that I am
moving to the next slide we are saying
that we will model this manufacturer
entity
with some design patterns for example if
you don't do it with design pattern it
will work but then in future when you
want to extend the functionality or make
it more maintainable or scalable it will
be a hard task to take up sim the so one
I also have to understand okay most of
the time you think about building a new
software have you thought about when the
software dies well I can tell you that a
software dies meaning the software is
taken out of production when it is no
longer economical to maintain it the
code has become something called a
spaghetti code the original developers
who developed it are no longer with that
organization and they the new developers
did not perhaps got the entire Katie or
did get the Katie but did not get their
sacks together and it is cost
prohibitive to add feature to that
software in such cases the architects
and the business stakeholders will want
to think about building a brand new
system and if the brand new system is
not developed well the cycle repeats
very soon the software we age it it is
not beneficial to maintain or it is a
cost prohibitive to maintain that system
and production and then architects and
business stakeholder holders will come
and say oh they want to build a new
system so using the right solution in
this is right design patterns extends
the life of the system and that's where
it is important for us to know the
design patterns and know how to use it
not only for the fresh or greenfield
projects but also for the projects under
maintenance design patterns are
generally a common language between the
development organizations for example if
you are building an abstract factory
pattern somewhere in the comments you
will say that well this is a standard
abstract factory pattern and let's say
three years four years down the line
somebody won't
to come in and men in the maintenance
mode enhance it or are kind of make some
changes because of maybe a business in
are you changing the person will read a
track factory part and he'll easily be
able to correlate the related classes to
those entities in the abstract factory
or any other pattern for that matter
that makes it very maintenance of a
large enterprise scale applications
moderately easy to maintain now they are
because design patterns are proven
solution you also know the consequences
should there be a mint in the
maintenance mode should there be a added
requirement to a scenario which makes
that design pattern not so lucrative one
will have an option of swapping out that
design pattern in in favour of some
other design pattern which makes motions
and that's where it's very important to
understand how to use design patterns
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>