<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Framework Tutorial - 2 | Spring Framework Tutorial for Beginners | Spring Bean | Edureka | Coder Coacher - Coaching Coders</title><meta content="Spring Framework Tutorial - 2 | Spring Framework Tutorial for Beginners | Spring Bean | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Framework Tutorial - 2 | Spring Framework Tutorial for Beginners | Spring Bean | Edureka</b></h2><h5 class="post__date">2015-02-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9O_EQ6A88ac" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">module 2 spring configuration at the end
of this module we will be able to
understand spring concept of Auto wiring
differentiate between the different
types of auto wiring with examples
signify being inheritance and spring
expression language we call it as spell
explore most commonly used annotations
in spring application and atomic
discovery of beans so all these concepts
we will be able to understand by end of
this session now the team has started
working on Spring Framework one day two
teammates meet in cafeteria and then one
of them says that hey Lina I am writing
this spring application in which I have
class a that requests an instance of
Class B to do its work so what's the
problem if I make a has a relationship
between Class A and B I'm worried about
tight coupling is there any other way
yes you can use Springs Auto wedding
feature it will automatically where
Class B instance to Class A so the
problem stated by one of them is
I am searching for a suitable example
here
yeah this is what has a relationship so
here I am saying that so assume that it
is a property Here I am saying that I am
explicitly writing about the dependency
here so that is the problem he says that
okay uh I am going with has a
relationship in my XML so can it be done
automatically is it possible that is the
question
spring can automatically resolve
dependencies using auto wiring spring
offers Auto wearing feature that helps
cut down the amount of XML configuration
that it developers have to write so that
is what I had shown you right that line
will not be there
once we implement Auto wiring spring
offers following types of auto wiring so
we can Auto wear by using name by using
type and by using constructor okay we
will see one by one Auto wearing by name
spring container looks at the beans on
which auto wear art attribute is set to
by name in the XML configuration file
based on the name of a property a bean
because that same name will be injected
into this property if it exists okay so
what does it mean we will understand
about these students in the next slide
because it has the XML configuration
file with other relevant information
don't worry at this moment
see I have a hostel class and our
student the class so here I have a
reference of hostel so usually we know
that we need to write a beam for hostel
and we need to write a beam for student
and we need to refer are in what we call
we have to refer the hostel beam for
this hostel that we know by using ref
from a trip
dude but if you see here if you see here
I supplied value for name I supplied
value for ID but I ignored hostel
completely free I do not see the
property with respect to the hostel at
all for the beam for the class student
fee here I had written for only two
properties and the hostel two properties
because if you see hostel I have two
properties four of those I set the
values student it has three properties
but I have set the values for name and
ID but I completely ignored faster
why if you come here it says auto why by
name Auto while by name if you see id is
hostel here property is hostel here so
it is going with the property name it is
going with the property name if it finds
any beam which is the same property name
then it will cover it that's it three I
no need to write that dependency for
student beam at all just because of auto
I equal to by name so everything else
remains same see nothing changed for our
test class next I don't want to write
this line that's it
that is my requirement it should be auto
while it should automatically inject the
specific value for this property based
on either by name or by ID or sorry by
name or by type or by constructor
argument okay
this injection has to happen
automatically we thought writing this
mapping information so that is my
ultimate goal that is when as
it goal so I want to remove this line
and I want to write something like this
auto wire auto wire by using by using
either name or type so when I say name
it means search for it will search for a
beam with the ID equal to this name
equal to this name what is that I have a
beam with I did this so then I can
remove this got it then I can remove
this so this is the whole funda behind
that example that means I am just
decreasing the amount of effort that has
to be put by the developer in writing
the XML it should automatically wire
with the dependent beams so that is the
ultimate goal of this session okay next
go to the slide
yeah so here we understood we have two
classes student and hostel and we
understood application context or
texture may look something like this
where we are writing auto wire okay and
that this remains same okay now we will
see an example on the same
module two we have student and hostel
see are these many tabs are open right
these many files are open right so I
don't I want to close all of them in one
shot so the shortcut for a Clips little
shortcut is ctrl shift W see all the
open files were closed ctrl shift
W student glass looks something like
this
which has a reference to hostel and with
the okay B here we are talking about
constructor injection no problem I'll
comment without ok next
you
yeah how it looks now with three
properties and setter and getter methods
that's it
okay and go to hostel it remains same go
to bean stew dot XML so for River in
beans beans dot XML which corresponds to
module 1 and module 2 we are going with
beans to dot XML this is just for
readability pumps that's it nothing more
than that ok so what I will do I will
comment this piece of code and I will
see here enable this piece of code to
explain Auto where by name so let me
enable this
see now here hosta for the class hostel
am writing a beam with the ID hostel and
with two properties hostel name and city
and the values that I passed her hostel
name and City are Hyderabad famous
Austin and heroin and fur beam for the
class student I am passing only to
attribute to properties for name and ID
it has the third property faster but I
am NOT passing any value or I am NOT
mapping any beam for that property
why because I explicitly said that I
explicitly said that was was go with
hostel see in student the property name
is what hostel so in that case search
with a beam hose I des hostel and a map
with it that can be done automatically
by this so does this XML file has any
bin with ID hostel yes it has then it
should work then it should work
that means the mapping part is extracted
away from XML and it is made automatic
by this go to test so this is same again
so here I am going with beans to dot XML
this is the only change I am trying to
get a bean with ID student as it written
student and take casting it so now I got
a student instance on which I am a
firing to string just to get the
information of it okay so forget about
this for some time okay now run this
program
see here student name is prom one and I
des param one two three four five and
hostel details from where these were
injected these were injected because of
auto wire by name auto wire by name so
we are going to the next level we are
going to the next level
any question on this
okay so as there are no questions
which is X crystal-clear Thank You G
next now Auto vary by type Auto wearing
by type not by name so type refers to
the class type for example if it is
employee type is employee if it is book
it is book so like that
now it should not depend on the property
name rather than the property of type so
here in this example the type refers to
hostel this hostel so this property is
this is property name and this is
property type now it has to wait based
on the type available it has to work
based on the type available so in this
case in this case how it behaves by type
specifies Auto wearing by property type
not by name spring container reads the
XML configuration file and then for the
beans on which auto where attribute is
set to by type it finds and the inject
that would be according to type match so
what we are trying to convey from these
two lines is see here see now this is
capital H we made it intentionally to
tell you guys that it is not the
property man we are referring because
the property name is small H there okay
so now this on based on the name it will
not work so that we ensure by giving
capital H here next
but how still it is able to work because
I said auto whereby type so the property
hostel is of type hostel what am i
selling the property house
is of type hostile so it will find for
our being host type is faster so
fortunately it phone a being host class
is of type hostile that's it it will
inject it it will inject it how if you
see it remains theme it remains same
okay next sorry
yeah till this point only here go two
beams two dot XML and instead of by name
we should have by type
I am commenting this piece of code and
let me uncomment this piece of code okay
see here see the ID I give five star
hostel five-star hostel okay and by type
I said but if you go to student class
how to go to student the class from XML
just click on that class name and f3 it
will take you there so now I am in the
student class the property name is
hostel okay come back but I do not have
a respective property not even
respective bean with the same property
name because it is five-star hostel but
still it will work why because I am Auto
wearing by type so what is the type it
is looking for I've been with the type
hostel yes it phone then it will match
it it will match it see I save it go to
test and execute it see your client
program
will not rain because we are doing it it
configuration level any questions on
this got the difference between by name
and the PI type name refers to property
name type refers to property type that's
okay so as there are
no questions let me go to the next slide
Auto wearing bike instructor this is
third way to achieve the same if a beam
is set to auto while bike instructor in
configuration file then spring container
tries to match I on the wire its
constructor argument with exactly one of
the beans hose type matches with the
type of constructor or Q mentor so again
this is by type but it constructor level
by Ted but it constructor level so for
that what I will be doing is and just to
modify this let me enable this and let
me disable all my set
now I want to go with constructor
injection you can help your setter
methods also but I just wanted to
differentiate between constructor and
setter injection now I have a
constructor with name ID and a hostile
that's it no changes made to hostile
come back to beans now we will be
commenting this out let us uncomment
this piece of code now see if you see
here again five star hotel so a five
star hostel and the field hostel and I
am giving passing the values were only
hostel and city because then it does not
contain anything else and for being of
type student instead of property I am
using constructor arc because I am using
constructor injection here and I am
ignoring the third type that is for
hostel so again the IDE is file star hot
hostel but how it will work because of
constructor Auto wearing my constructor
but it will go with a game by type again
by type
it a constructor injection level okay so
let me save this and go to tests execute
it
nothing change right so again the
program is working as expected
so let me repeat this again three things
I will repeat we have by IB then by type
and constructor three things by ID sorry
by name by type and the constructor by
name is most bothered about the property
name by type is most brother a board
setter injection less property type
constructor most bothers about
constructor injection less by type
that's it yeah so again this is homework
for all of you guys loading multiple
beam configuration files generally in it
spring based in a spring spring based
application we have multiple big
configuration files if a good practice
to define your beams in different XML
file rather than defining all means in
one XML file one question that comes to
mind is how we will load multiple beam
configuration files so we will write a
parent that is meant dot XML and we will
import all the other XML files by using
an import tag as shown here and
importing a resource so that refers to
the path to the respective XML file so
as I have these many XML files and these
are the paths so I am referring to all
those examples in one main dot XML file
and I will supply this one way dot XML
file to the application
context so this is one way of achieving
that and the other way is if you see
here if you see here it takes an array
also it takes an array also so this is
also one of the way to go for it
got it so either we can load multiple
configuration files in this way or in
the other way suggested so I am giving
this also as homework to all of you I am
skipping it intentionally as there is
nothing rocket science in this example
next beam definition inheritance beam
definition inheritance a child beam
definition inherits configuration data
from a parent definition so it is
nothing but you the inheritance that you
know that's it inheritance that you know
parent rail relationship so you can
acquire the properties of parent that's
it so the change definition can
overwrite some values or add others as
beaded what does it mean child can have
its own properties and it acquires the
values assigned to the properties for
the parent but again it is up to tell
whether whether to go with the values of
the parent are give some speciality
values to the parent properties so that
is what this overlaid some values refers
to using parent a child beam definition
can save a lot of typing that developers
have to do otherwise so what does it
mean you no need to redefine those
properties in parent and the child
rather if you define it in parent it
will be acquired by the child if you
establish
boss this is my parent a relationship
with China okay so how we will do that
see here this example I was not
convinced so I have another example this
is very very basic example and it is not
a carry any value so I am NOT going with
this so parent-child relationship I have
booked as a parent and the e-book
electronic book as the child okay it
could it could be a paper book or it
could be a ebook so I have an e-book
electronic book it is a child which
extends parent that is our book okay so
what book contains book contains these
many properties these many properties so
whether it is an electronic book or
paper book name of the book author of
the book number of pages and the cost
would be same okay that is where this is
the parent and the property specific to
evoke are five in MB size in MB okay so
I have setter methods for all these four
properties along with the to string and
the I have setter methods for this
property along with two string tax it
now I could see parent and the child
relationship some meaningful parent and
child relationship in this example
okay then how then how this looks so I
am deleting this then how this looks
book Godot
module 2 dot book and I give values
through all the four properties of the
parent book okay by default by the
theory of inheritance all these are
available to ebook all these are
available to a book okay so in that case
in that case go to bills to dot XML so
all these values whether you write it or
not will be available to ebook will be
available to eBook okay so ebook now I
am saying pain as book parent as book
then I had defined only size in MB for
ebook okay then when when I create an
instance of ebook that means what I will
do is I will check for this ID in my
tester dot Java C here C ebook okay
under it is written it will written an
instance of a book then if you say book
dot to string it will written what
everything all the file properties see
eBook size in MV is 25.2 and what book
contains book contains all this
information why because I established
some pain in child relationship in beans
the parent-child relationship in beans
okay understood
there are no need to be inheritance
relationship established also for
example
yeah this is coming because of
inheritance relations okay fine got this
point any questions on this inheritance
what is parent and all
yeah which is this yes it is very if you
feel it is hard just go with this
example it is very easy see here for it
has only one class father and it has
father and now the other bean there is
no class a different for it
see there is no class defined for it but
you still you are treating it as a
parent as a parent and it has a father
that means it is referring to this that
means first name and last them both are
available to this child appeal but again
you are overriding the value of first
name by shame so that is what this red
box rebel okay so next topic yeah coding
to interfaces when using spring for
dependency injection it's a good
practice to use interfaces for reference
referencing dependencies so what it
means so for example in our earlier
example assume I have a student class
and I have two kinds of hostels one is
5-star hostel and the second one is
priest or hostel but both the hostels
are implementing an interface called
hostel so here do not right either
5-star hostel or priest or hostel rather
right hostel because it is a reference
which which can accommodate either it is
a three-star hostel or a five-star
hostel that is what the meaning of this
is read go with the interfaces rather
than the implementations because the
implementation may vary but if you refer
it with the interface that is super
interface then it can accommodate any of
its in
meditations that is what the meaning of
the slide next animation based container
configuration so far whatever we had
seen that is XML based configuration XML
based configuration now we would be
seeing how to configure everything using
annotations using annotations so here
comes the again chicken problem we will
ask whether this is good or that is good
is it XML configuration is good or
annotation configuration is good both
have their own advantages as well as
disadvantages ok we will understand that
stuff better when we develop more when
we develop more annotation based
container configuration so now we will
be adding this XML namespace with
respect to the context in order to your
annotations work the container has to
know the context related to all your
annotations so this line was missing in
other XML if you see bins two dot XML do
we have that context see XML namespace I
have it for only beings not fur not for
context so that we need to add that we
need to add I had added the XML
namespace context this okay that is the
only change with respect to talk
container but how to add it let me
create a new
xml configuration of beam configuration
XML for second application of dummy next
see here you can select the required
namespaces from here so I want beans so
it will ask you which so we had chosen
for dot 1.4 for our beam
total jars right so I am going with this
and we have something called context
here so I will use the same 4.1 finish
see you can see the context added you
can see the context added got it so this
is how you will create that we will add
the context information to our XML file
any questions on adding this context to
our XML file okay our next what is this
life context : annotation
- config it tells that boss I'll be
using annotation based configuration so
I will see container I request you to
please consider those configurations so
that is that is said by this life so I
would be using annotation driven
configuration also along with my XML
based configuration so I request you to
consider those along with the XML
configuration that is said by this
context call an annotation - confit if
you
means to add this line though you write
your annotations but they will not work
because your ioc engine is not aware of
those until unless you write this line
okay so it should be the first line of
your configuration file after beans okay
first annotation we will check for each
enter rate value or notation so either
it value annotation defined in jsr 3:13
so jsr yesterday also I give some hint
on jsr 250 and 330 right so these are
three 30 days R stands for Java
specification request and that that is
three that the in which used to inject
string values into members of a beam
usually we use a great value annotation
to provide default value to beans
properties for example by default it has
to take John joy for name and the
one-one-one for ID so whether I set each
in the beam definition or not so for
example if you see student 1 did I write
these two properties no but still if you
create an object for this bean ID it
will have john lloyd under 1 1 1 as the
result why because a great value
specifies that these are the default
values for the associated properties
default values for the Associated
properties but when you overrate or
explicitly write them what does it means
you are overriding the default value you
are overriding the default value if you
come here I had created an object for us
student 1 and student 2 and when you
type will see the IDS you could see the
difference got it okay
going next er see here student with
annotations so for ID I am taking this
as the default value per name I'm taking
this as default well and if you go to
beans with context added see here the
context is added and you can see this
student 1 without any property defined
student 2 with one property defined and
how it behaves if you go to test
annotation beans you could see I had
created two objects student 1 and
student little from being ideal student
1 I on student 2 it should populate with
the two default values it should
populate with one default value and one
overridden value okay if you run this
you will come to know see this is a
default value this is default value and
this is default value this give the
overridden value so how these are these
are working because we set the container
that please consider all my annotations
while you prepare your engine so where
is that where is that line of code this
context : on annotation - conflict this
will ensure that container will be aware
of all your annotations got it
next next enter a required this is the
second annotation that we are going to
learn today this annotation simply
indicates that the affected bean
property must be populated at
configuration time through an explicitly
explicit property value in a bean
definition or through Auto way the
method could be either Auto wearing or
explicitly you set the property but it
should have the value supplied with that
property
other way the initialization will know
happen when when we add at the right
required it is something like mandatory
film it is something like mandatory
field because though you are stood in
the class hands to properties but when
you ignore okay not this though your
student property has two properties but
for the first student one when you
ignore both the properties still it
accepted why there was no mandatory
condition is there on the values to be
said for these properties that is when
there is no exception but but see now I
have int value and I have a setter
method for that and I am adding a
required annotation on it and the go-to
beans with context added dot external
and see how my required annotation looks
like how it looks like see I am setting
the value attribute but if you ignore it
what happens now I am NOT
playing any value I am not supplying any
value for my required annotation class
attribute is value I am NOT giving any
value but but here I said the Spector
method as required that means I am
saying that the property value is
required but you did not say what
happens go to test annotation means and
see no being initialization phase beam
initialization exception while property
value is required for beam required
annotations which you did not sit that
is what the meaning of it so how I can
rectify it by my own go to beads with
context added and just uncomment this
what I mean by that pass the value for
the property value then I am passing 123
if you go back to your program that is
the sanitation based for this now you
will find it's working why because when
it qualified itself as required and when
you pass the information there is no
problem at all right so that is why it
is working so now did you understand
what is required and how it will
influence the bead initialization any
questions on that
yeah BJ's clear I hope everything is
clear on this otherwise let me know I
will explain again yeah
yet the problem with these kind of
courses like this is a kind of crash
course I'd you're learning entire spring
in our eighteen two three a very poor at
mathematics but still at by 24 so you
are trying to learn total spring with so
many admins topics in 24 hours but
usually people take two and half months
into one and of other so that is a time
period people dedicate for Spring
Framework with all these concepts so
this is at end of crash course so so
many concepts we are covering in a deal
so it will be confusing until you try it
by your own the best part from this
course if you have a week time to
practice the to decision but if you do
not practice from module 3 and 4 I will
increase my speed much more so you need
to be very clear about all the concepts
that we covered so far
ok next
yeah Auto wide now the annotation is
auto where we have seen Auto - why'd for
beam definition right now we will do it
using annotations you can also apply the
annotation to methods with arbitrary
name and or multiple or events you can
apply a great auto head to constructors
and fields also by default auto wiring
fails
whenever 0 candidate beams are available
that means you are saying Auto right but
the respective it is not available then
it will the default behavior is to treat
annotated method
constructors in the fields as indicating
required dependencies this behavior can
be changed as demonstrated below edit
order weight of liquid equal to phones
because auto reading by type may lead to
multiple candidates see multiple
candidates that means we have seen file
star and 3 star example rate so how can
we get rid of that problem we will see
it is often necessary to have more
control over the selection process more
control over the selection process one
way to accomplish this is bitter springs
in the rate qualifier annotation so when
I am trying to auto where if by type
what happens it might there might be a
possibility of more than one type can be
qualified for it we had seen that
exception right so then I can say that
though it has more than one beam
associated with the same type but I am
looking for this that we will explicitly
say use a great auto void to have spring
Auto while the any property of the beam
using a great auto wide sorry you can
get
of the property element that works in
the configuration file here that we know
we had seen that also in the XML
declaration but now we will be seeing it
using at the rate annotation that is
iterate Auto wide how we will see now as
expected you can apply the a great auto
word annotation to traditional setter
method see here I am writing at the rate
auto wide so it will check for what when
spring sees either it or to where it
will try to perform by type annotation
by type Auto wearing on the method so
the default behavior is on by type then
how you will how you will restrict it to
two one there are two bins qualified for
just then you can restrict it using
either a to qualify by this name so by
default it is a by type and now you are
minimizing the scope of by type by
iterate qualifier how we will see with
an example see this is how we can write
or to avoid annotation then it will be
what away automatically wide body type
class a it contains a method plus B it
contains a property of F a so I said
Auto why e next so everything else
remains same if you come here see this
configuration file a I configured a and
I configured be but though B has a I am
not saying our Auto - void with Y type
here instead in C in Java itself
I said Auto ID then it will understand
from the configuration file it will
check for that type a and it will wire
that here in this setter method that's
it the
is again what we achieved using Auto -
config equal to by type you're achieving
the same by using annotations by using
and rotations so that what I am NOT
writing here because I had written an
annotation for the same yeah if you see
here yes I have a student yeah I'm
talking about qualifier also let me
cover that also then we'll come back to
this example usually we create more than
one beam of the same type one of the
problem that is quite common in that
case is using a thread at a wild
annotation to I repeat because by
default its behavior is to wire based on
by type so what if the configuration
file contains more than one beam
qualified for the same type then we can
use either the rate qualifier annotation
along with Auto wide annotation to
remove the confusion by specifying which
exact B to be wide which exact the beam
to be wired how we can see it here
hostel name city name ID and the now I
am writing Auto wait Auto word
annotation on property level itself okay
I am adding the qualifier as hostile to
okay why because if you see here I have
two hostile beings on his hostel one and
hostile to and when it is Auto well it
will wear whether on the type but I have
two beans so among these two qualifying
hostile to for me qualify hostile to
Fermi that is what this qualifier talk
support that is what
disqualifier docks a word got it so when
you come back here so we have the same
example and if you go to being with
context added you can see that I have
hostile one is of type hostile hostile
to is of type hostile and when you go to
student we have hostile of type posture
okay when you say Auto weld it will
search by type that means by hostile but
unfortunately it has either has to it
has two IDs with the same type with the
same type in that case I am saying that
boss boss
qualify with this beam being with this
ID though it result in n number of beams
with the same type but I am looking at
this that is what we can pass by using
annotation called a tree right qualifier
it great qualifier so see how it works
okay see it is working as expected it is
working as expected in the sea here it
is going with second provide hostel why
if you go back to your Dean definition
it is evident that we are going with
second row bed hostel got it so this is
the funda of annotations this is the
wonder of annotations any questions yeah
very important question from any and he
says Alan is using a great auto wild
annotation in his class and definition
but when he run the application Auto
wearing feature is not working what
might be the problem so you should
answer for this I actually answer for
this question now you should answer for
this what is missing why internet Auto
read annotation is not working Auto
wearing feature itself is not working
what could be the problem
okay it's very simple most probably alan
forgot to include context collar
annotation - convey in the xml file so i
already spoke about it right so this is
the way container knows that you had
followed annotation based configuration
also otherwise it should not it will not
be knowing about it
so that is the reason it might not work
okay next spring also supports injection
using the jsr 250 enter a tree source
annotation on fields or beam property
set their methods so this is another way
of doing the same every resource takes a
name attribute and the by default spring
interprets that value as the beam name
to be injected okay
in other words it follows by name
semantics as demonstrated in this
example what does it mean see here now I
am qualifying it as deep so now it is it
will work on by name principle so
injection by name so if you go to this
no example on this yeah it is very clear
right so the injection will happen based
on the beam ID host name is rich that is
that is the only thing that we need to
understand from this example next Edgar
it post construct and iterate pre
destroy so the init method attribute
specified a method that is to be called
on the beam immediately upon
instantiation
similarly destroy method specifies a
method that is called just before our
being
is removed from the container so you
must be able to map this with your
initialization being disposable being a
little method destroy method right yes
you are correct this is as same as that
so instead of writing all that stuff you
can just annotate the respective methods
with respective annotations when you
annotate our method with poster
construct with this you are in each
method then when you annotate our method
with the pre destroy it is your destroy
method that's it so the same flavor of
your declarative approach in the form of
annotations you could see that in
practice it is very simple so we can
control the lifecycle of a beam by using
annotation also yeah we had seen two
variations of it and is anita method
kind of initialization beam and the
destroy method and disposable this is
the third way of doing the same okay
next
but one thing needs to be understand
here is this post construct and the pre
destroy does not belong to spring
framework rather they belongs to rather
they belongs to a Java EE specification
so fervent reason for the trees err we
need to add bean class equal to10 Spring
Framework context or annotation not
common annotation bean post processor
either you need to add this are you need
to add our favorite line this whether
you need to add this are this in order
to work reconstruct and pose to destroy
methods that is the only thing that we
need to understand that is the only
difference also but as we know when we
are using annotations definitely we will
be adding this line right so you don't
need to even think of it this is just
for your note
next I do not have a working example of
the same thing so I request you to
prepare at your end if you encounter any
problem let me know automatically
discovering beams automatically
discovering beans the context components
can element does everything that context
: annotation - con Victor's plus it also
configures spring to automatically
discover beans and declare them for you
declare them for you what does it mean
what this means is that most of the
beans in your spring application can be
declared and void without using beam
that means now we are going to get rid
of bean tag itself to configure spring
for auto discovery use context :
component - scan instead of context :
annotation - config both what are we
moving towards by default context :
components can looks for classes that
are annotated with one of a handful of
special stereotyped annotations a data
component in the rate controller in the
red repository in the red service this
is all all the flavors are of type a
great component only but controller we
use it to indicate that the glass
identifies a spring MVC controller so
when we talk about MVC we will come back
to controller repose to the answer with
again okay this is just an introduction
that's it component is a general type
and all these are of the three
as of as the top component repository in
persistence layer service at the
business logic layer so but all the
three are of fiber component usually we
declare all the beams in XML beam
configuration file so that spring the
container can detect and register our
bins what does it mean we are defining
our beam definitions in XML file that is
what the meaning of this line but spring
is able to auto scan you no need to
write any beam definition also detect
and instantiate your beans from defined
package project project package it seems
the amount of XML configuration
developers have to chew so no bean
configuration at all directly it will
detect and instantiate beans for you
from the annotations how just you need
to place a greater component before the
class that's it this qualifies this
hello as a beam by default spring will
lower case the first character of the
component here component name is hello
right
so being ID would be small h-e-l-l-o
that's it so you can retrieve this
component using hello context :
components can base package so this is
required because we're to scan for the
annotated components so that information
we need to pass using base - package
both you you need to auto detect the
beans under this package the next
question comes into our mid what if
there are multiple packages which
contains auto detection has to be done
then comma separated by using the
packages code package 1 comma coded
package 2 comma coder package like that
you need to specify here you need to
specify
here then how our context rewrote XML
looks see it's very simple and similar
and notice that we haven't see this is
our context of file do we have beam
definition associated with it no but
still how it is working that you should
tell them you should tell me because a
great component annotation is added for
hello under we we have added components
can also we have added components can
also ok let us write this example to
understand it better go back to your
code I have created auto detect the
beans not XML where I have added the
context and I have added this line and I
am requesting the container to scan this
package to detect whether I whether I
have created any components so that it
will detect the beans and it will create
them for us then when you go back to
hello dot Java I have created hello
class with say hello method and it has a
component added to it then go to test
Auto detect annotations dot Java is this
is same but the only thing differs is
here I am going with Auto detector beans
Auto detector beans that's it when you
say context not get bean with a small
hello see it will give you the hello
reference on which you are firing say
hello but if you go to auto detect means
do you have any bean definition no but
how it still it is working because we
are doing the automaticall scan for the
beans which are different in this
package that is known by the annotation
called add the red component so when I
run this what happens it will print
HelloWorld it will print
hello world that's it so no need to even
define your beans in your XML more
advanced alright
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>