<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Exploring Query Parser | Solr Search Engine Tutorial | Solr Tutorial | Edureka | Coder Coacher - Coaching Coders</title><meta content="Exploring Query Parser | Solr Search Engine Tutorial | Solr Tutorial | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Exploring Query Parser | Solr Search Engine Tutorial | Solr Tutorial | Edureka</b></h2><h5 class="post__date">2015-05-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/K6qOd2CSf0w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we have the default implementation of
standard query parcel so however if you
want to change it you could use the
param dev type and you could define the
different query parser for your query so
again I think we spoke about that the
standard query parser is the
implementation of which query parcel so
this max query parser is the query
parser which works under the hood of
standard query parcel so it was in fact
the first query parser which was evolved
and then guys decided that we need draw
more simpler you know query parser so
this is something which was designed to
process simple phrases without complex
and taxes so they were trying to
implement something very very simple
however this this became little complex
by additional parameters which were
available so we would see what all
parameters are available with this max
query parcel once we jump onto the lab
sessions okay so this again is going to
search for the terms across all the
fields which are available on the basis
of different weighing or boost
methodology or factors which we apply on
various fields based on the significance
of each field so the significance of
each field is basically decided by if we
have applied any boost factor on any of
the fields so this is these are the
various sub parameters which come handy
with this max query parser so in general
the dispatch query parsers interface is
more like that of a Google so it's a
very you know standard thing so you can
happily enter the terms and it is going
to you know operate on those queries so
the similarity makes this max the most
appropriate query parser for most
consumer applications and it takes
accepts fee simple syntax and it really
fails so you will not really you know
get any chance wherein this is going to
give you some exception or error okay
so I pulled out few documents from the
web before moving on to this one so
there are a few parameters which are
available I'm not sure because that was
not covered on these slides so before
covering that the only lab exercises I
just thought probably we should discuss
these in the class so we have these
parameters which are available with me
this max query parser okay so we have a
simple Q is the you know raw input
string or the query which sure you would
be giving then we have Q dot alt which
is which act more like a alternate query
I think not sure if you discussed that
yesterday but though we could have two
queries on when we use the different or
the custom query parser
so if I trade I'll say that I'm trying
to look for a document using say this
max query parser I could also use the
alternate query say I'm looking for say
this one I'm looking for this query okay
and what if I say that I am trying to
look for say def type equals to this max
so we get three documents only okay what
if I say that I'm looking for
say Samson I get okay
only one not appropriate use case maybe
the Apple has got one as well okay we're
gonna look for then let me look for
tests okay we have only two documents
here so let's suggest via query which
might give me the more more results let
me look for electronics okay I get 14
results this this looks better so what
if I say that def type is this max I'm
looking for these results using this
query
parser however I am trying to say that Q
dot alternate alternate query again Q
dot alternate is going to use the
standard query parser so this is again
another variation in which you could use
two different query parsers in one query
so I'm trying to say my results would be
first of all would be generated on the
basis of the first you know query parser
which is this max and then I'm going to
say look for another query alternate
query which is going to use these
standard query parson and I say my other
query is anything which gives me motor
service let me look for what can I look
for okay let me look for mmm maybe Apple
I think had one document only okay oh oh
maybe samsung also had only one document
so this is not going to really change
the results in this case so what else
can we look for okay let me try saying
this one I do not specify anything in
the query say I do not specify anything
and I remove this def type as well just
to try something okay so do you think
this will work without the query any
ideas any guesses is it going to work
without the query no yes it would not
work but what if I say that I have this
oops I did something wrong I think
let me remove this one
I think I have done something wrong okay
I was not specifying the question mark
so why do you think guys this one has
worked I mean I did not specify anything
what happens which one you have any
questions or confusions oh okay well you
suggesting any question mark - okay okay
okay all right all right so yes so what
I was trying to tell you was that I'm
using the dismiss query parcel and even
if I'm not specifying the query your
parameter still this is going to work
the the reason is that it is going to
use the alternate query so that this is
another way another variation in which
this could be worked through okay let's
go back let me close this one down this
one so this is again the way in which
this alternator query parameter could be
used then we have the query fields in
which if we want to define any
particular you know a field on which we
want to send the query to this is mmm by
default it is going to have the default
value of 1 this is minimum match okay so
you need to kind of play around with
these options a bit this is going to be
the phrase field so again you could see
that the phrase field is the basically
it would boost the score of the document
and guess both of the terms because
anyway the phrase would be found by more
than one terms so if all of this is
found it would the document but
automatically would be boosted then we
have the phrase lock I think the rest of
the things are pretty much clear I think
tiebreaker is one of the things most of
us wanted to know so it is for the
documents which have this similar say
score so tiebreaker is going to be like
a factor which is going to decide so
which is going to decide that which
document would come first basically so
you would specify the tiebreaker tile as
the maybe some fraction maybe point one
or point two or something of that sort
then we have the boost query so you
could define a boost query as well moose
query is something like a filter query
so you would have to specify that maybe
along with all the queries I'm trying to
say likely they're dumb johner
underscore s equals two fantasy so if
you are going to put some additional
query to boost up the results so along
with all of this result set if my
journal is of the book is fantasy then
put those results up okay then we have
the boost functions here so again we are
going to explore more about this when we
talk about function queries and the
booster query parser because ultimately
this boost function is used as a
back-end by the boost query parser
okay do we have any questions for this
one anything No
okay let me just move on to either
Smacks now EDA smacks is again pretty
much like this max only but it is going
to women have some more features a kind
of improved version of this max query
parser so basically if we can quickly
look into what all parameters we have
okay these are few examples of this max
I think so I just wanted to explore
through the parameters because they're
not there on these slides so there are
many parameters so these all have the
explanations along with them and few of
the experiment queries as well I'm not
sure how many people have really been
following or loose it works for solar
this is kind of pretty cool so along
with all the parameters which were
available with it is max query parser we
have
the parameters like boost I think we
just spoke about that then we have the
lowercase operator so in this if
lowercase and aurora's given it should
be treated like and or or so these are
for the people who generally forget that
so PS is again the freest Locke which we
have additionally we have phrase field
one two and three here which basically
affects the boosting of the document
then we have these talks word parameter
here as well then we have the user
filter say if user wants to put
additional filter on the results so
these are a few of the type of queries
which could give you different type of
results here I'm not sure if we have any
examples on our labs okay I think we
have I saw something like this max
function queries I think I saw this Mac
somewhere no okay let us try a few
examples from what has been given here
so what this going to what this is
trying to do is that it is going to look
for the iPod or video and the depth is
this max let us try first of all this
example without using any query parser
here then only we are going to see any
difference so let's see I say
oh I'm supposed to specify the core okay
and I say some pretty printing WT cross
to chase Sun and indent equals to true
so we found five documents let us not
try using this one okay so we again got
five documents only okay so let us try
something more complex which affects the
results let us take okay this seems good
enough so what I'm trying to do is I'm
going to define the EDA Smacks
the query is hello the phrase query is
going to be from the text field and the
query field is also D text field and I'm
boosting the results on the basis of
popularity okay let's see this one
and I need to specify the course again
okay so I'm trying to look for hello
here and I found two documents I think
me one Vitry added yesterday so
desperately looking for this term here
in the text field okay so what if I
removed this thing and I try to look for
these are certain scoops okay it is
again giving me the same results I need
something else some better examples
maybe guys suggest me some example where
and I couldn't maybe post on the basis
of says no boosting we do not need I'm
saying query field category let me try
this case again the same one let me try
doing Apple only fun no let me say test
this gave me two results okay maybe
electronics okay and let me try putting
up test now okay did you guys see any
difference we were looking for this um
this query wherein we are looking for
wrong the query was electronics and
we're trying to formally phrase query on
the basis of the text fields and the
query field is the category field okay
and when we when we removed this EDA
Smacks definition the query partial
definition we got 14 results but when we
used the EDA smash it got me only 12
results
right let me just try removing this once
again please notice do you see that 14
results okay this is because the way in
which the query is first that is what I
basically wanted to showcase that the
difference would be how the query is
basically been parsed so there is a
difference so I mean that is that that
is what should make you understand that
what exactly is the value of additional
firm these query parsers are to your
complete implementation so basically
this trying basically the query partials
are used to refine your query it is
trying to kind of beautify or I would
say what does the right word to use it
is kind of refining the results so these
parameters basically act as a filter so
they're trying to say act as a maybe
kind of checkers so I think filter was
the right word so if you you know send
our normal generic query you will get
different results but if you use any of
the query parsers the implementation
would vary and that is why you would get
different results so that totally is
dependent on the kind of use case you
are serving so if you have any kind of
use case where you want exact matches
for each of the query parameters
probably this is the right one to be
used okay so there are various other
examples here which could be used we
could also overwrite the default value
of minimum matches to two or maybe three
we could also say use the query field as
features and I'm trying to use the boost
factor along with the the query feature
query fields so over here I'm trying to
look for the video and definition is a
dispatch the query parcel I'm looking
for query field as
features the value and the features is
boosted to the factor of 20 neat text
field is boosted by say point 3 and then
I'm saying that my boost query is if the
documents fall under the category of
electronics say I am also on boosting
this by the factor of five okay
so you give certain feels more
importance and so the results are more
specific correct because thank you so
much for putting that up so maybe that
is the kind of way I wanted to put this
through so yes there are some fields
which kind of gainy precedence over the
rest of the fields and that is why the
results and the number of results every
kind of results vary so again we have a
limited result set over here to be used
in the class so maybe when you're using
that on the production you know indexed
or maybe the results would vary as and
to a great extent ok again to be more
more specific on the result set like a
kind of being more strict on the query
parameters you would want to use either
Smacks
otherwise you have rest of the features
are there on this max query parser as
well however if you still want to use
say booster query and boost function
maybe this is the right one to go for it
additionally offers you few parameters
here I just I think discuss those so if
you have more number of say phrase
filters so you would probably want to
use one of these so these are based on
the War shingles I mean don't get
confused with he were shingle it is a
kind of maybe a a Graham which was
formed by the Engram filter so basically
this would act only on the Graham's
which are formed by your Engram or edge
and Graham filter so if you're trying to
use that on your field
this is going to be more relevant so
again that is totally dependent on the
kind of for use case you have so it
gives you few more flexibility and few
more features to be added to dis max so
that is another reason you would want to
use EDA's max or if you want to use this
max right so if you if you need the less
strictness on the kind of results to be
retrieved from the data store maybe you
can go for this max or if you want kind
of more stringent query and the results
therein which are kind of pretty much
what the user has been looking for no
hanky-panky probably you should go for
either smacks so that's kind of an
additional extended this max okay
because so rest of the features remains
the same so there are a few features
which kind of vary okay so there are a
few other examples which are there along
with the features okay I think this is
the same one which we saw on that
website okay so then we have the
function queries so the function query
is basically okay the function queries
lets you say do some evaluation at the
time of query like was i I just gave you
an example where and I would like to add
or say maybe few metrics which are
already available like was take an
example I am trying to look for a
product and there is a price field and
there is a tax field and say I have say
delivery charges maybe and what I'm
trying to do here is that I'm trying to
sort the product price on the when I'm
trying to look for the some product and
I'm trying to ID all of these prices so
I'm trying to evaluate that which
product would be lesser would cost
lesser or less on my pocket so I'm
trying to say sum up these values the
price of product the taxes which are
then and the delivery charges so
on the basis of these three themes I'm
trying to find out that which price
which product would cost me less okay so
these are a few of the available
functions which are there so do you guys
understand what what could be the use
case wherein we might require the
function query parser
okay Kiran has another question where do
we usually write this results two flat
files or to the database Oh
Kiran basically you do not write the
results I mean I'm not sure what kind of
implementation you have basically in the
general implementation you would I mean
render the user results only UI itself
because that is what the user has been
looking for and what if okay you say
that this is all web-based but what if I
don't want web interface yeah this is
JSON format that is correct but this can
always be parsed as per your requirement
so you can always parse the results
maybe you could always want turn that I
want the results in the XML format and I
could use the dormady sax parser and I
could create my own custom schema and
saying that under this you know ties get
me the results and that that's how it
okay what you could not here
Kiran is I mean is this a problem with
everyone are you guys not able to hear
me okay kidding now yeah okay I guess
rest of us can hear me probably some
issue with Kiran Kiran Zinj so what I
was saying is that you could use your
custom you know write a type likewise
I'm using JSON in the kind of examples
I'm using what I could do is I could
write the responses in the XML format
and I could define my own custom schema
saying that my results set
would be I mean if let me just give you
a quick example of that oh it's my query
admin I think this is the one okay so we
have results here I have one document
found what if I change my result display
in the format of XML so in the general
you know implementations you would see
that I could define my own schema that
my result says if I have the response
and if I say that I found something then
process the B's or tags further I say
that I do not want D ID to be shown on
the you know front end I just want the
name to be shown and probably I would
like to display the categories so these
are the tags I'm going to parse using
one of the parsers so maybe the Dom
parser or the sax parser and I would
process the results for the web UI do
you understand what I'm trying to convey
Karen okay
is there a writer for DB so are you
trying to say that you're trying to
store the results in the database okay
so yes you can do that I mean you could
store the xml's as well in the DB yeah
and then you could process the way you
would want them to you could process
them in CSV probably just to be on the
safe reg so probably I would want to see
the CSV is kind of more convenient for
me to import an export from the DB point
of view so I get something like this for
a DV and I could send them to the
database field maybe okay
so again there are few parameters which
are pretty specific to the query so
likewise we've spoken about that default
query field and the default operator has
been deprecated we saw that in the solar
config
right we all remember that right
so if he spoke about the default query
field this is the default query sure if
we had to default
I think parser know and we look for
deprecated in fact this is working oh
okay I was looking into the wrong XML
altogether so we will have spoken about
that the default search field the
default query field and the default
operator has been deprecated so you
could specify an or or whatever you want
to so you could maybe leverage the users
of the local parameters in the query and
you could specify whichever default
field you want to search on or any
operator any specific operator which is
pretty in sync with the the the
particular query you are sending to the
server okay so this is something like a
local parameter provides a way to add
metadata to certain arguments such as
the query strings so if you if you're
going to specify something like this
like exclamation and Q dot off it
becomes the query operator for that
particular fields and you could use that
in the query so I I think I used few
examples here not sure if that one okay
not this one I think we can get rid of
this one oh no not this one as well oh
this one
okay this is another example of function
ready okay so this is the one I was
talking about so likewise I say that I
have been looking for I've been looking
for from the say this this is my phrase
solar-energy Arica and the default
operand between these two phrases is and
I I want a solo and I want every réka
in the default field is text here okay
and the field name I'm looking for is
name and score so I have used firm and
operator and I'm searching on the
default field say I could take some
other field as well as a default field
because by default this is anyway text
so let me try you're making some more
thing here okay let me try or as the
default operand and let's say name and I
say name is either Samsung or it's Apple
okay so when you look for this type of
query it is pretty straightforward
though but it is trying to create the
query parameters which are very very
special specific to this query so you
could do that you can do that okay so
this is going to look for this is going
to consider the name fields or I mean
this local query parameters are
basically used for the more complex
queries basically so this might be a
very simple one to say but this is again
something which we could use to you know
make the complex queries a little easier
okay so I think you got the point
what I'm trying to convey here so there
are other parts as well there are
approximately
the more query parsers which are
available in solar ok so these are again
few of the types we have block join
query parser boost query parser
collapsing query parcel I have few Wake
few of the examples from these query
parses as well so we're going to cover
them quickly so that we can jump on the
session six in a presentation so again
let me quickly show you one example and
explain this to you theoretically okay
so you can explore this a bit on your
own if you still find them little kind
of tricky your drum stuff probably we
can discuss that in class okay so I'll
just go through them quickly so block
join query is again a type of query in
which we are going to be creating a kind
of join between the child documents and
the parent documents so I'm not sure if
we have really taken any example of the
nested documents so every document in a
solar could also point to another
document so there was another scenario
which we could have so again this is
very very specific to some use case in
which we have the parent document and we
have the child document as one of the
say a field maybe we could specify that
child and then we could give the
document idea of some other document
Narron okay this is kind of not very
hard to understand though so the child
query parcel basically takes the query
and it matches with the parent document
and then it is going to return the child
documents the children documents
basically and the pairing document is
going to do the reverse that is it is
going to take the query which is which
it is going to match with the child
documents of the parent document and
then it is going to return the parent
documents okay I hope I did not confuse
you guys so this is a little different
from the inner and outer joins we have
in the database basically so we have
child query partials any parent query
parcels here then we have the boost
query parcel here so I have I think I
discussed that the booster query parcel
is basic
using leaders max you know query parcel
at the back end so it it is extending
the queue parcel plugin and it creates
the boosted query from the input value
so the main value is the query to be
boosted the main value as and now which
was the value which we give after the
curly braces this is the main query so
it is the query which is supposed to be
boosted and the parameter B is the
function query to be used as the boost
so this is going to define D basically
the factor by which this parameter is
supposed to be boosted on which
parameter likewise I'm saying that look
for the term foo and I'm going to kind
of boost this document on the basis of
log to the popularity matrix this is
again another variation of it and
looking for the same field but my boost
factor kind of has changed so the query
to be boosted may be of any type could
be of any type I have I think few
examples for that so this is again
another type of boosts query I had so
you could use this from maybe the solar
admin so okay so I'm looking for a star
dot star and I say my boost query okay
let me change this one to Eddie right
now and I say that my format is JSON so
I'm looking for the term iPod and I'm
boosting it on the basis of the
popularity metrics so I'm generating the
boos factor by log of popularity matrix
okay
so this is one of the documents I have
which has the in which has the
occurrence of iPod let me try this on
some other
okay this is surprising oops I did not
find anything here I found something on
the collection run okay let me try using
that as the main query as well so this
is going to basically look for the term
iPod in the default field okay so this
time it found four documents so this is
basically this tells you tells your
query parser to use ebo a booster query
parcel and we define DB as the boost
factor basically and this is the default
term which I'm looking for okay
so every occurrence of iPod in the
document the boost is applied on it
and the documents are boosted on the
basis of this term I'm looking for let's
see if I can boost the documents which
have electronics as one of thee I found
four documents with that query let's see
how much how many documents do I found
find this time okay I have 15 documents
now so electronics was the main query
and this was the boost factor which I
used okay so I think you got the idea
behind the boost query so we're
basically using the booster query parcel
if you are if you have to look for any
you know the operation we're in I'm
supposed to boost on the basis of some
term some specific term the collapsing
query parser is more like
maybe living think of an example where
we're trying to say the retractable list
maybe so it is kind of the approach when
the number of distinct groups in the
result set is high so if we have more
number of categories maybe this is the
kind of right term query parser to be
used so this part of collapses the
result set into a single document for
the group before it forwards the result
set to the rest of the search component
so this is something pretty similar to
reface sitting in highlighting we would
be discussing in a little while so I'm
not sure if I took any example of this
one okay I think I did not let me see if
we have anything in here okay so we had
example of the local parameter in the
query as well so we have certain
examples here where we are trying to
define the name and we're trying to give
it a phrase we can also specify the
particular query parser if you are
trying to use this is again the example
where in okay
oh I think this is basically letting you
know about how to experiment with the
child and parent documents I think I'll
leave up these two to be tried the
offline you guys can try it I think
which is pretty much okay right you guys
anyway practice the lab sessions at home
do you guys do that is it fine if I
leave these examples for you to try
online I mean offline I'm sorry is it
fine so we can quickly cover a few more
young okay alright so okay so let me
move ahead and see if we have any more
examples for this give me two don't have
them so I think so collapsing query
parser could be treated something like
like we have the okay so I think face
the thing is one of the examples which
is coming to my mind in which you have
grouping done and each group has got
furthermore sub-query subcategories
therein so we'll we'll see more about
this once we traverse towards the face
of thing then we have the complex phrase
query parser here which provides support
for the wildcards so what you could do
is that you could play around with the
wild cards and the boolean operators
inside the phrase query and this would
basically use the loo scenes complex
phrase query parser so under the cover
this query parser makes use of span
group so it is basically going to use
the spans so span near or span all which
is again the pretty much implementation
of the Lucene complex phrase query
parser so I'll take a quick example of
this one as well so I'm not sure because
these are not there on
the lab excises I guess so maybe I can
provide you with this document where any
you could try a few of these um offline
as well let me ask the support guys to
upload this document as well let me kind
of like format them nicely like we have
rest of the documents here so this is a
complex place query and I'm saying that
in order to be true I'm looking for the
a P P style and it should have the word
a P P star an iPod with the slop of the
very proximity of one so I'm trying to
add more kind of complexity to it I'm
also adding the proximity search so I'm
using the wild-card and the proximity
here and let's see what happens now so
it should look for okay it's not there
oh maybe I should be looking into get
your rekha real surprised how is the
code changing every time nevermind okay
so here we go again so let's see what do
we get now okay you don't get anything
here okay let's see if we get something
on the collection one for this I think
we deleted the data for collection two
only we did not play around with the
data for any record current collection
one okay
I just tried these examples before ok
let's try with and fit a query no ok
let's try not an idiot Rekha
I should have Hoshi noted down the core
I have tried these examples on might
have made my work easier ok not the one
no let me try modifying this a bit ok do
I have any more examples for this No
okay let me try modifying this one say
I'm looking for this so if I include
this in the double quotes it is going to
look this as a phrase basically so I got
something here so let's see what was it
problem I'm looking for a PP an iPod
with the slop of with a slope of 1 ok if
you get something okay I got something
now so I am looking for a PP and iPod ok
I think
there must be some encoding issue I
think the it's supposed to work
okay I'm looking for Apple iPod ah guys
could you could you see any problem I
mean you guys seen any problem in here I
mean I do not see any problem for some
reason can you guys suggest me why this
might not be working because I mean I
tried this before the class today so
okay let me try using the query queue
okay no results now as well let me look
for this in text no okay let me not make
it pretty complex then okay this was
supposed to be working anywhere no okay
I forgot the okay a PP star is working
if I have to look for this okay what
could be the problem
okay I tried that with the father filter
query as well someone this doesn't seems
to be working
let us try some other term maybe Oh
let us try with the give me a thumb guys
a quick one
oh maybe or Belle Starr oh okay this
became the prefix wedding let us not use
it here just taking it as the different
query type altogether
let me try using VL star and let me
remove this as well let us try the
simple wildcard queries here okay
okay Pelican is coming now let's see if
I can use bell Stars and mobile pass a
phrase let us not specify any slop okay
this one seems to be working as well and
what if I specify the slop may be said
to I think with one it should work by
default it is okay there must be some
syntax problem in the other example okay
- as well it is able to find okay okay
with three as well it is able to find so
I think this is more of I think I should
give you a better example with for the
complex phrase query so this is
basically to add more complexity to the
you know two terms which a person might
be looking for so here are a few
examples let me give you a better one
when I send the document for uploading
in the lab exercises so let me see if I
can find a better example I mean I felt
the afterlife poor iPod was supposed to
be working so I'm not sure what is
really gone wrong in that one so then we
have the field query parser on which
which is which arts more like if we're
trying to send a query on a particular
field okay so it is going to create a
field query from the input value and it
applies the text analysis and construct
the phrase query if appropriate so it is
going to see if you are sending in two
you know terms it is automatically going
to convert it into a
raise query by itself so this is one of
the examples which I have taken I think
these documents were there on the core
collection one I think let me close
these downs this is kind of adding to
the confusion okay I think we are pretty
much done with these I think this is
also done this is also done okay so
let's see if we can get hold of this guy
okay so I'm looking for I'm defining a
field and the field is basically
constructed on the author field of the
schema and the value I'm trying to look
for is we had the books data we entered
yesterday I think if you guys remember
so Rick Ryder Nestle basically it should
be taken in answer the phrase query so
it is going to construct it by itself so
this is going to simply convert this
entire thing into the phrase query on
the basis of the value which has been
provided so if you give it two strings
it is probably going to form a
permutation combination of the phrase
query or can be used as a term as well
so right now it is fetching the
documents which had the occurrence of
authoress Rick Crichton so this is
another example of the text of the field
query parser so I think we do not have
any such thing into the in the lab
exercises we currently have so then we
have the function query parser so please
do not confuse yourself with function
query parser and function query so
function query is basically the query is
basically the functions you are applying
at the time of querying the next or okay
there are a few functions which could be
used every time of querying the data
store or the index store and there are a
few you know functions which could be
used at the time of basically
when you're trying to construct say I'm
defining a function which could be which
basically I'm defining to be used online
query so this is one way to use the
function on the solar query so we saw
one of the examples here so I've tried
adding this okay let me try copying this
so I'm trying to apply the this function
on the price of the price of the books
or the article I was speaking about so
okay so we found around 41 documents
here so what we did was that we are
trying to define two values here in that
I am trying to add up
okay the value one is max of price and
weight so we would have price and weight
for each document so I'm trying to
replace the value one on in this
function with the price and weight okay
and the second one would be may be the
deciding factor so I've kept it as five
so I'm trying to add up these and I'm
trying to create the kind of a matrix
with which my document would be matched
okay
so this is another variation of using
the functions here so every time you are
going to use a different query parcel
with the within the query you're going
to have something or the other in this
manner so with the exclamation symbol
whatever you're going to provide here
would be considered as the query parcel
you're using for that particular query
so likewise if you see I could always
say that I'm trying to use with the
exclamation mark I could always say that
I'm trying to use this match here and I
could just go about giving it the
parameters of the this max query parcel
Oh
so I would be sharing this up for
further analysis you guys could um try
this at your end okay so I found that
there were no examples related to these
concepts in fact I think they were not
covered in the previous sessions which
were conducted so I thought probably I
should pick out few examples to be taken
up in the class just for the fair
understanding so then we have the
function range query in which we're
trying to apply the function and we're
trying to provide a range with it so it
is also going to be an extension of few
parts of plugin and it creates the range
over a function so I'm trying to create
the F range which is function range and
I'm trying to provide it the lower end
as the 1000 and the upper end as 50,000
and I'm going to specify my field okay
this could be another function say it
could be used as a function as well
likewise I saw that term I could use it
as sum of wait in price or I could
provide it as a simple field so likewise
I've used this on the the price field
here in the document okay I think we're
good enough with this one so let's try
this one I'm sure this is collection one
okay so I'm trying to okay this is the
filter query star not star and I say so
what I'm trying to do is I'm trying to
create the range of the price okay from
2200 I found three documents iam and if
I said that the price range was probably
to include a zero as well I would have
got more documents here okay so you
could try various variations with the
such queries you could apply the
functions on
the instead of a field you could specify
the you could specify the function here
so this is another variation you could
do or if you wanted to say I do not want
to consider zero because it is going to
get me all the documents even if they do
not have any price so let me see if I
can get hold of something like this from
one hundred to two thousand let's see if
I can get something like this okay so I
get something here I got eight documents
here which have the price range from 100
till 2000 so 350 399 are all greater
than 100 185 so because I have not
sorted the results so you would not get
any results a result here in which the
price would be less than 100 here okay
so are we getting the idea of using the
this thing the function query I mean I'm
sorry the function range query did we
get the idea why would we use it okay
well if range work with ABCD to XYZ you
mean lexically creating the F ranges it
should yum it should so where did we try
that example okay here so let us try
creating B that's nice interesting
question in fact so let's say if we have
say Apple and Apple range would be say a
Samsung and I say my field would be name
right something like this which will is
that correct
is that what we wanted to try yeah okay
so in this case it should use the
lexical ordering o
it did use something not sure what it
test is there something is there Belgian
is there I think it does did we say that
we are trying to order them in a
different way
no okay we do not have anything to
specify the ordering here so it is
containing everything from Apple to
Samsung so we have Apple here we have
something here we have the Corsair here
so anything which ranged between the
Apple and Samsung it got me everything
right okay so if it could not be you
know um evaluated by any numbers it
would use the different technique for
characters then we have the join query
parcel which allows to normalize the
relationship between the document with
the join operation likewise uh I could
have given you the more complex examples
but third root excuse me I've tried
getting the simpler ones here so this is
a different concept in which we're
trying to join now the information
basically okay so this is little
different from the our DBMS joins which
we have so as we see here this is going
to find all the products containing the
word iPod the search query and it is
going to join them against the
manufacturer Docs manufacturer ID to the
main idea of the document and return the
list of manufacturers so all the
manufacturers which return the ID of all
the manufacturers which match with the
query iPod okay so in the similar way we
have find all the manufacturer dogs
named Belkin the
the company name here is welcome and
then it is what it is trying to do is it
is trying to join them against the
product documents and filter the list of
only the products which are priced less
than $12 so this is the main query and
then it is the say the filter query so
I'm not sure what example I have I've
taken here so I am just term trying a
simpler one maybe you could drive few
more offline and let me know how this
comes out to be so I'm going to use a
simpler one here will remove this one
and I think I have few other things here
so it extends the Lucine query parcel
but returns a max code from the clause
so the ones which have the max Col are
going to be basically will take the
precedence so it does this by wrapping
all these should clause in the
disjunction max query and it is going to
evaluate them with the Atty query any
master prohibited clauses are passed
through as is so it is not really going
to consider any any any filtering
basically so numeric range falls through
the query Q parcel behavior let me just
quickly take an example maybe that might
explain okay I have say here what I'm
trying to do is I'm trying to evaluate
the max code I'm trying to use the same
query parser and I'm trying to say that
I am trying to look for the term
electronics and the product or maybe say
the because the default field is text so
I'm trying to look for first of all
Electronics is going to make a data set
and then the other query like Samsung or
Apple is going to run on that query set
and it is going to give me the results
let me see if I could get this one
running for you guys
so this
the walls around the implementation of
the score feature we have here so let me
first of all see if we have if you can
see the difference so right I'm trying
to pull out everything which has which
comes under the Electronics category
okay so I have 15 documents so what if I
say that I'm trying to put up the
additional say condition here saying
that along with this along with looking
for electronics also look for Samsung or
Apple should be there so only fetch the
documents which have electronics Samsung
or Apple so it should get me it should
not get me the Belkin ones at this time
so it is only going to get me the
Samsung and Apple okay I think we saw
here so from 15 it returned only three
documents right guys so it basically is
generating the Mac score so
implementation of the score field which
is already there
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>