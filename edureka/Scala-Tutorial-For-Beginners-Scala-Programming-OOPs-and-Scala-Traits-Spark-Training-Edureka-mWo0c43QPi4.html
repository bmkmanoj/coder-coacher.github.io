<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scala Tutorial For Beginners | Scala Programming | OOPs and Scala Traits | Spark Training | Edureka | Coder Coacher - Coaching Coders</title><meta content="Scala Tutorial For Beginners | Scala Programming | OOPs and Scala Traits | Spark Training | Edureka - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/edureka/">edureka!</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scala Tutorial For Beginners | Scala Programming | OOPs and Scala Traits | Spark Training | Edureka</b></h2><h5 class="post__date">2017-01-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mWo0c43QPi4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and now we are going to go to the next
module which is going to be our
object-oriented programs and function
programming okay now tell me how many of
you know object-oriented programming and
the concepts of object-oriented
programming
how many of you know it okay I see some
people know it some people don't know it
so what I'll do is I'll just quickly
tell you a couple of things about
object-oriented programs so this is
actually a very short in a presentation
where I quickly tell you about
object-oriented programming concepts so
the four pillars you know of
object-oriented programming are
encapsulation abstraction inheritance
and polymorphism okay so just remember
these are the four pillars of
object-oriented programming an
encapsulation means you know in real
word we don't have the jiggler details
to everyone okay so now what we tell
others you know about ourselves depends
on various cycles so say for example you
know I don't mind telling my name and
age to to you but if you ask me my
salary and other personal details I may
not be able to tell you so that's
encapsulation we're in a based on need
and based on the use cases we actually
reveal information it's not always
public for everyone okay so that's
encapsulation and any other mineral
abstraction abstraction you know in
programming is basically any entity in
your program which has a very clear
defined response beauty so that means if
you look at a model like email or an
employee or a department savings account
in your program these are nothing but
abstractions so that you know they have
a very clear defined well defined
responsibility okay inheritance
basically means that you know where you
know when you when you actually surplus
from parent classes so you inherit in
just like our inheritance biological
inheritance we inherit a lot of
properties from the base classes so say
for example here you know we have a
shape class which has the name area and
location in space and from the shape you
know when we create when we recreate in
child objects like square rectangle
circle the kids ellipse or triangles we
automatically inherit the properties of
shape like area name and location in
space yes that's inner and volume or
please let me know is context driven
behavior so here one favorite example of
mine is if you look at this blackberry
phone here you have a disconnect button
now is this connect button here you know
it has
the behavior is the only context
treatment because the thing is that when
you're inside a call you can click on
the disconnect button to disconnect the
call if you are ap or if you're not
inside a call and if you keep that
button pressed for more than three
seconds then it shuts down the phone and
it also acts as as as a button to boot
the phone and similarly if you are in
the middle of something in a phone call
comes you can you can click on that
button disconnect button to you know
forward that call to your voicemail or
somewhere else so as you can see that
the disconnect button you know based on
the state of the phone you know have
different uses so that's basically what
I call polymorphism that means you know
it is purely context driven behavior so
that in based on the state of the object
the behavior is designed okay so so
these are you know the four pillars of
object-oriented programming okay so so
how many of you knew this the way I
explained okay good so that's a quick
revision here and now what you're going
to do is I'm just quickly going to tell
you in about the various features you
know of object-oriented programs and and
I'm going to spend a lot of time on
functional programming okay so that's
one area and I want to spend a lot of
time on because functional programming
is something which actually you will
need a lot in your in your smart program
looking so so now what we're going to do
is we are going to stop using the shell
and we have to start using the ID so you
can use this in a caller ID which is
available in your in virtual machine or
you can download it and play it around
yourself okay so you can do any of that
so I'm going to use the Eclipse ID which
is already available inside the virtual
machines I go to the cubes folder and
click on eclipse the CHC so this is not
a start of this particular exe and
whatever you install the examples I'm
using here these are there in my github
so I suggest that in AU you keep all all
the source code which I'm using here we
will be doing my github but let me show
you my github so you can save the link
here say if you go to my positives if
you go to Scala Deb
so this way you will find all my scholar
programs okay so you can keep my github
link your lot of useful stuff is there
okay so let's write you know a simple
program in our using class concepts and
just a minute let my Eclipse start okay
this this idea is a little bit old so
what I'll do is you know what if you are
using the new idea interface has changed
little good but not drastically so I
think it's fine so can you all see my
screen can you all see my an ID okay so
what I want to do now I'm going to
create a you know default a class so I'm
going to create okay it's a pretty old
ID really so I'm going to create a news
color file color class and I'm going to
name it as you know my class okay
so we'll name it as my class so here I
have a class called my class okay and
here you know I'm going to define a
method called test method and so here
what I'm going to do is you say test
message okay so this is my simple class
I have now what we're going to do is
you're going to build this class as I go
along now what we do is I'm going to
create an object don't worry about an
object is now okay because we still
haven't I still haven't taught you what
an object is but literally I'll tell you
you know tomorrow I'm going to teach you
what an object is
okay but for now you know just think
this object is given and this is more
like and inside an object in I have a
main method okay so we all know that you
know we need a main method in the
program because the main method without
a main method your program JVM needs to
issue an entry point within so to start
the program so that's why you know you
need the main function
so here's the signature of the main
function you write the main it's just
like the Java or the C++ main definition
you have an array of arguments
command-line arguments and in return
type is void and here what I do is you
know I create a new class okay say m and
I say in a new n I see you know my class
okay and then what I do is I call m dot
test okay so I prepare my syntax what
I'm doing here so I create an instance
of the class opee
so I'm creating an instance of the class
and by using the operator and then I'm
calling test is this clear to all of you
this particular syntax and then what I
do is in I run run into the Scala
application and here you see the test
message okay so this is a message a hat
now the thing is if I want to make this
you know this is a constructor which we
are seeing here this is called a
constructor and now what I want is I I
basically want that you notice to have
arguments okay so the class should have
particular states now how do I you know
put states in the class okay so that
means you know our test class is going
to have a name and age and any any kind
of stuff you know I want to put in the
class
so how do I go about doing this so what
I do is in order to define a constructor
for the class and the way you define a
constructor in Scala is you define it
along the class name so what I do is if
I define a name called string and I
define the age so we know two variables
that define okay so here what I do is
when I make them as well so that means
the name and the age in it becomes
immutable okay so you cannot change the
name and it okay it's a screen
refreshing now so you know I declare a
class can you see the screen refresh now
okay so what I do is in I in order to
declare a constructor what I have to do
is you know after the my class
definition after write this piece of
code so now what I do here is you know I
print here I declare two variables name
and age so this becomes the class
variables okay so so my class now has in
a two variables name and age and these
are you know these are public okay so
and since I haven't mentioned anything
here so basically it's public by default
and now what I'm going to do is you know
I'm going to just print the name and the
age so so I'm just going to print the
name and the age and here find a
constructor I'm going to pass the name
and age okay so I'm passing the name
here test and the age is 18 and that's
what I'm passing here and you can see
test 18 here all of you deuce piece of
code so this is by default public you
know if you want to make this in a
private so that means you know so now
what happens is let me give you a quick
demo the thing is that you know you can
you can do things like this okay so you
can actually do m dot name you can print
and you do m dot H okay so so now what
you can do is you know you since I told
you that these are public variables you
can access them from outside the class
okay so you can actually print m dot
name and in ham dot age you can do you
can you can do it from outside because
these are public variables now out if I
make them private okay so you can make
them private so that means you know they
are no more accessible from inside the
class okay so if you make them private
then you're going to get an error here
saying that you know this these things
are not accessible from outside so here
you know if you if you delete them and
now if you run them so it only prints
from internal inside the class okay so
this is all remember that this is how
you know you you create private or
public variables and this is what
encapsulation is all about okay so this
how you encapsulate this stuff okay so
now what I'm going to do is now I'm
going to add so this is called a primary
construct and just remember that into
this constructor which I've defined here
after the class name okay so this is
called the primary constructor P so
remember the name it's called a-- in a
primary constructor okay there's also a
concept called auxilary constructed okay
so now what we're going to do is we're
going to define and auxilary constructed
so Julie constructors are basically any
constructors other than the one which is
defined here other than the primary
constructor to be absolutely and the
auxiliary constructor you define like
this okay so it starts with the keyword
this and you can you know just give any
you can just give any in evaluate okay
so what I'm going to do is I'm going to
define a non-phonetic constructor say
for example I'm going to find observing
auxilary constructor where either the
name I can override but the age will be
you know constant so here what I do is I
bought the name and the age I hard-coded
200 okay so this basically what happens
is there's an auxiliary constructor
which means it only takes the name as
and the and the ages in a hard-coded 200
and internally in the observing
constructor I'm calling the primary
constructor okay this this is basically
the primary constructor right because if
you look at this you know it has got the
name and an age which is nothing but it
maps to this okay so this name and age
you know match - so the name and age
here whatever I'm writing here basically
maps to this constructor here okay so I
define an auxilary construct to this
with you know and I just give the name
here and then for the age 200 so inside
the auxilary constructor I'm calling the
primary constructor which basically maps
to this font here clear all of you and
then what I do is you know I'll just
tell you how to use the primary you know
how to use the constructor now so what
you can do is you can you can declare
another variable you know well m1 and
you can say new my class and you can
just give the name here say test one
but you don't give the age okay and now
what I do is I call em one dot test okay
so then you will see that in a test one
and hundred is printed and if I call
this so you will see that in a test one
and hundred is imprinted okay
so that's typically how you declare a
class how you declare constructors this
is called the primary constructor this
value together auxilary constructor and
this is how you declare maybe methods
inside the class so this test is a
method inside the class and you create
instances of the class like this and yes
is it like this
don't worry about this object here and
tell you later or the subject is okay so
this is all clear to all of you this is
how you declare cuts it's pretty simple
okay venkat is asking me in Java the
constructor has the same name as the
class name yes you are writing greater
so the constructor has the same name as
the class name but here it's given with
this today okay Shailaja is asking when
we would when would we need to use those
very constructors see the thing is that
you know if you have it's just like the
concept of overloaded constructors in
Java okay so if you want to construct in
more than one way so this is a so here
is one way of constructing in a way you
give the name in the age if you want to
construct in another way where you just
want to give the name anyone to inner
default bah to something else so in that
case you know you you just call the
primary constructor and hard-code by H
200 okay so it just no over the
constructor
yeah if you run this coordinate is how
it looks so age 18 and clear all of you
it's actually pretty simple you know
there is not much complication okay just
one more thing I want to tell you is you
know whatever course okay which you
write inside the class is executed when
the class is instantiated so when a
class is instantiated
whatever code you write inside the class
you know gates this is a different from
C C++ and Java
okay so just mind it so this whatever
code you write except the method
definitions okay except the method
definitions whatever methods you've
defined here X
method definitions whatever cordierite
inside the class gets executed so
there's a very unique feature so say for
example you know if I inside the class
if I just give a println and just say
you know some message you will see that
you know two times I instantiated the
class myclass
so you will see that two times some
message icon so that means every time
the class is instantiated whatever code
is there inside the class gets executed
other than the method so it is a very
important thing and the times ask you in
interviews as well so just remember that
okay and if I run this you will see that
you know some method gets called some
message you know gets printed two times
so that means the first time when I
created this object M so we see all the
code inside the class got executed so
some message was franker then again you
know when I created an instance of m1
again that time some messages print okay
so other than the method definitions
everything gets executed
okay so just remember this piece so when
you execute a particular class hmm what
happens is in everything is all the code
inside the class gets executed and
except the methods whatever code you
write you know gets executed so that's a
unique feature of the scholar classes
unlike Java or C++ so here I wrote a
message in a some message a print so two
times you know the class gets created
one when I'm creating M and 101 so and
and reading m1 so in both the instances
when the glass got created this message
was printed because I told you that all
the code inside the class except the
method definitions get executed so if
you run this code obviously you can see
that you know some message comes twice
zero okay so so that's about you know
classes and now I'm going to talk about
you know something called Singleton's
and companion objects so and that's
where you know I want to even show you
the use of object you know what I wrote
there okay so now we are going to talk
about so this is what classes are okay
so now the thing is now let's learn
something called objects okay so now the
thing is let's get rid of all these
things
and learn objects okay so let me just
clean this up now the thing is object is
you know we we all know something called
static okay so if you have come from a
Java or C++ or C background there's a
keyword called static so static
basically means that you know that you
know when we saw that in a year when I
was using the my class I had to create
an instance of that class of if I
created an instance of the class using
the new operator and then I started
using the class now there are some
entities where you don't need to create
the instance either you can directly you
know call college on the class name so
that means you know so so those becomes
you know static entities where you
actually don't need to create an
instance and so in C++ or Java you do
that you do that with the static keyword
in color you do that with with a keyword
call object okay so is this concept of
static clear to all ofyou can I can I
have a quick poll static means that you
know when you want to access the object
you don't need an instance you can
directly access the object using the
class name if you scare the concept of
static okay so now what I do is you know
I have a static I declare an object a
static n the way you do static in Scala
is by with this keyword called
object okay so you so I create an object
for my object and inside that you know I
keep a method called test method say I
do some print okay I say print Oh Oliver
so this message now what I do is you
know I have another object inside which
I have the main method so what I can do
is you know I can either write the main
method you know inside my you know my
object itself or I can write it
separately it really doesn't matter and
here what you have to do is you know
previously we saw that you know for
classes if I had to access methods you
know or attributes of the class then I
had to you know create an instance but
for objects you know you don't need to
create instances episo-- you can
directly call in my object and my object
you can call the test method so you can
just do this okay so that's the
UDF so you can just do this
and you'll see the test message counts
okay so that you know how that's how you
use objects okay
clear all of you what what objects are
here so you're right so memory is going
to be indirectly and it's going to be
directly allocated when the object is
created okay and these are called
Singleton's opening so these are called
Singleton's in scala and they are very
useful in scala okay so the singletons
so here you can see you know under the
screen so singleton Gina can be used in
Scala these are called Singleton's okay
so so you know when you only require one
instance you know in the whole gabion so
that's when you can go for such
instances such as coordinating a service
okay so for example in a suppose you
have a printer service and you want to
use the printer service across the
network now we all know that you know
printers are shared resources so it's
obviously not everyone printer which you
know all of us you know would be using
in such a scenario so obviously it makes
sense you know to give the printer
service as a singleton so that you know
all the clients can connect to the
singleton service and request a print ok
so they could be shared across you know
for efficiency purposes and you know
they can have mutable when it's an
immutable instance when you create an
immutable instance so you basically have
utility function and constitution inside
it so say for example imagist if I want
to convert this to a print service so I
can I can do something like you know
object you know my print service and a
now I can have methods like connect you
know and I can client name as string
knowledge and return a boolean saying
whether the connection was successful or
not okay and I can say you know test
message client and and then I can see
true okay so and then you know
this is one thing like that and then you
can have in another thing like print so
stop talking a method you can have okay
clearly love you so
so this is how you can use the singleton
option so this method basically has you
know it's an immutable class that means
it doesn't have any state and inner you
have utility functions like an egg print
etc okay okay Vemula is asking that can
you have the code you know my object or
just test or my print service dot
connect in outside in with my desk class
yeah why not you know you can access it
from anywhere
as long as this class is accessible open
it soon so if it's in a different
package you have to imported it you can
write it from anywhere okay so nobody
stops you from that okay so now what I'm
going to do now is now I'm going to do
another new topic called companion
object talking so companion objects are
another very interesting use case so let
me go to companion objects so let's
let's understand the scenario okay so so
now you know we first saw that you know
we created a class you know this class
had attributes okay and this class had
in a method so so like attributes like
you know name and age I added and then
methods like test and print message
etcetera then I created an object so
where I show case that in a way if you
want to have static methods that means
if you want to have methods which are
not related to any instance which are
not related to any States how to go
about that
now let's combine the two now what if I
want you know an object or I want an I
want a class on an object where some
class methods will be static and I'm
sure you must have used that in Java as
well in Java we see that you know there
is a class or maybe in C++ also where in
the in the class there are some methods
which are instance methods and there are
some methods you know which are static
methods right you must have seen it in
Java or C++ where some methods are
instance methods that means you have to
create an instance with new and then
call the methods and again some method
the setting methods that means you don't
need an instance you know you can
directly in a column on on the class
name right so it's quite possible that
in a song will be instance methods
and you know some will be stateless
object methods so have we come across
such scenarios you know I'm sure you've
used them somewhere oh you're with me
can I have a yes/no aking some response
from all of you I'm sure you know yes
you've you've used that so now the
question is how do you do this in Scala
you know in Java obviously in C++ you
know you can add the static keyword you
know and you can achieve that but in you
know in Scala how do you do that in
scholar to do that you know you have to
do something called companion object so
peaceful so companion objects basically
means that where you know static methods
or the non instance related metrics are
in the objects and the instance methods
are in the class okay so let's
understand it with an example so here
what I do is you know I can I can write
a class call in my class okay and I can
have a test def test and unit now what I
have to do is in companion class the
only rule is that you know the name of
the class and the object should be the
same so I should also have another
object called my class okay which you
know will which will have a method like
print message for example
and it can
it brings something okay so and the best
part you know about you know companion
object is that you know the classes have
full access to the companion objects
members so actually you can call in a my
class dot you can call print message
okay so this is absolutely valid so this
my class you know you can you can call
the print message this vertical APA is
directly accessible here okay so they
are inaccessible to each other and if
you want to use them so you can write
another object called main in a way we
just had the main function and then what
you can do is you can create a Val M
equals to new my class and then you can
call m dot o test okay so if you run
this code so basically two streams the
test message okay clear all of you on
the semantics now let me give you a
practical example in a way where we can
use such things of companion objects
okay so companion objects are pretty
useful you know when you want to have
you know some static methods and some
non static method so here say for
example you know I want to write a
method call I want to you know create a
utility class where it will keep the
number of where it will keep a track of
the number of instances which it creates
okay so say for example I I create a
test class and I have a test in object
now what I want to do
my requirement is that and I want to
give track of how many in how many
instances my test is getting created so
what I can do is in a liking and I can
keep in I can keep a variable called
instance count and I can initialize it
to zero okay and then what I can do is
and I can have a method called print'
instance count which basically prints
you know this okay so this will just
bring the instance count and what I do
here is can I just delete this method I
told you that you know whatever code I
write inside the class you know that
gets executed when I instantiate a class
so here what I do is you know I test out
instance count so so I just increment
the count okay so every time I call the
test count so every time I create a new
instance of this the instance count is
going to be incremented by one okay and
then finally what I do is in I print the
number of instances so here let's do
something in a let's create ten new
instances so I write a for loop and for
I
so I can say I create ten instances okay
so and I so basically I create you know
ten instances of the new desk class and
now what I do is you know I just you
know call test dot string didn't count
okay so because every time a new
instance is getting created the end of
the count increases okay so now what I
do is you know I keep on increasing the
count and finally after three to ten
instances because I'm running the loop
from one to ten I just called test dot
bring count and it should print ten to
me okay so so let's see what it prints
in exactly prints ten right so so that
means ten was ten instances was created
I care about this code in what I'm doing
here it's pretty simple you know so it
basically you know I've created it in a
method to keep track of how many
instances of a class gets created and
that is done to companion object you can
just have a look at the code and and try
to understand what I'm doing here and if
you have any questions you can ask me
it's a scare to all of you it's very
important because you know I I want all
of you to understand this kind of coding
because when I go to spar and I don't
want to waste a lot of time you know
explaining things which I've already
done so just make sure you are clear
with this I all clear my friends from
Accenture I all clear and Carl
Kevin profile uh Nana I all care okay
just one more thing you know I see a lot
of people from from Accenture so is it a
corporate sponsor training or are you
doing it on your own
how's it I understand that you are a
yellow from Philippines right so you're
doing it on your own okay so you're
doing it on your own right or is it
corporate sponsored okay good so I I
think you're in Manila right that's
where the eight offices are in some
other city or Philippines okay good
no because I haven't you know i I've
never interacted with you know students
from Philippines so it's it's a pleasure
all of you so to interact with you
because I have taught you know many
people from across the world with the
first time I'm interacting with somebody
from Philippines I mean I have
interacted with Filipinos from the US
and Europe but not from Philippines
itself so welcome aboard
okay so I hope you are you're okay with
my accent and you can understand what
I'm saying in case you have any
difficulties please let me know I can
slow down and change my pace so tell me
now are you all okay with this native
all understand this code for any any
doubts any trouble you have in
understanding this is the time you
should ask me Praveen Rao srivasa in the
Jeep Harini benkard rimmel rimmel ah
sorry
hopefully all fine okay now I'm gonna
she's asking me that in a wise instance
count you know defined in the object
test object obviously because you know
you need you know you need a shared
variable you know you need only one copy
of the variable which will keep track of
how many instants get created right if
you if you're declared this instance
count inside the test class then every
time you know the class gets created
they know this would be initialized to
zero this is not what we want we want
this to have one copy in the memory and
every time a new class gets created we
just increment that copy right so that's
a reason why you have this here okay so
so that's about so that's about company
objects there couple of rules about
companion objects which I want all of
you to be aware of and you already know
about the rules but I just want to harp
on them the first rule is that you know
the companion object and the class has
to the class file and the companion
object has to be in the same fight okay
in the class and the companion object
has to be in the same source file okay
so has a dunny okay you cannot have it
in two different sources
it has to be in the same source file and
you know the class and the companion
object can access each other's inner
private members so there is fuller in
accessibility so just remember these two
points is a very very important and if
you see here just a minute so they are
already in the same class and the same
class file and this is where I've
defined and they are access to each
other's member variables okay
now let's do another interesting thing
you know when when I was doing no I I
think you know I let me start case class
tomorrow because I want to spend some
more time on case classes because that's
what is used in scholar a lot in spark
we use case classes a lot now what we
are going to do is I'm going to show you
some companion objects in action so if
you go to the scholar dogs in every
class you know how the companion objects
so if you look at this on the left side
and if you look at and just teaching you
how to read the scholar dogs if you look
at a particular class say for example
adding on the left side you will see a
see here okay the C basically means the
class methods and the all basically
means the object methods okay so so
every class you know comes has an object
which basically doesn't need an instance
so if you click on array you know if you
click on Mary you come to the added here
and you see the see here so if you pick
on the C it will take you to the oh okay
so these are the array methods where you
don't need to have any instance okay so
these are non instance methods or static
methods or object methods whatever you
would like to call them and every class
in has this so if you are going click on
the oh it takes you to the C so these
are the class matters where you need to
create an instance and use them so
remember that you know the all means
object methods and C means the class
methods okay so that's how you do it so
similarly if you go for map you know if
you if you look at the map
so this also has in its a trade so we
are going to do trade tomorrow but it
also has some object methods I like
these
okay so okay I think we still have time
you know let's finish up the case
classes and let's to case classes in let
me show you how these classes are
important so now you know I was telling
you that suppose you are reading a
database table okay so you have a
database table I'll tell you you know
how typically we use this in spark so
for example say you have a spark process
here as far as you're running and the
job is reading from a database table and
so here you have a table look it's a
database table which has rows okay so
you're really an employee table which
has an employee ID my name employee
address and these are you know the table
data so you're reading each and every
row okay now what you can do is you can
read the rows and you can keep that in a
case class okay so what are they what is
the advantage of a case class let's
learn this now okay so I'm going to
create a case class now I'll again go to
others create new just a minute this VM
is little bit of singly flow so so have
created in my case class okay and now
let's do something and let me get rid of
this so let's create something called
test okay so the way you define a case
class is in are you just write case
class okay and then you basically you
know give the name say my case class and
you define in other variables you want
okay so so for example you know we are
reading this you know we are reading a
particular database table which has an
employee ID employee name and an
employee may be address or something
like that so so I can define a case
class in like this
so so I can define you know employee ID
so I can give it as a string then I have
EMP name string and EMP address okay so
that's all your case class is ready ok
now let's see how we can use this ok so
I can create an object and inside that I
can create a min so what I do it every
time I read from the table I can
actually you know create an instance of
this so you can see my case class and
you can get the variables here employee
ID 100 and addresses in somewhere ok so
I've created a new instance of my case
class so let's call this m1 okay and
let's create another instance m2 and
let's make this 200 so let's make this
one let's make this test two let's make
this one let's work this - ok now the
biggest advantage in off case classes is
that the first thing is that you know it
gives you automatically gives you a lot
of stuff free stuff ok which you don't
have to pay for the first thing it gives
you an equals method it gives you copy
method okay so you can actually call you
know you can say in a println it gives
you an equals method so you can check m1
equals m2 okay so when you actually do
this equality internally there are
equals method is called for the object
now automatically the compiler generates
a equals method for all case classes so
if you do if you write instructions like
this and if you execute the code so
basically it's going to say false
obviously because m1 is in a not equal
to m2 then the other beauty is that you
know they basically give you a copy
function also you know you can you can
actually do a copying you know from one
object to another
and that also comes you know for free so
this automatic is given by you know the
compiler okay so just remember that you
know it automatically also gives you a
copy function you know where you can
have your own stuff okay so you can
write instructions like just a minute
this
so you can call you know entry I can
declare another instance call dial entry
and equals I can same onewhat copy okay
so I am on that copy means that you know
a copy of m1 will be assigned to entry
and now if I give say in m1 equals
equals to M 3 it's going to print true
so now if I bring this you see that it
prints true here okay so these are in a
couple of utility methods which
automatically good so just remember that
when I generally is class you basically
get a lot of things for free you get an
equals method you get a copy method you
get a hash code method and you get a two
string method in all these things you
get for free
okay so similarly why you get a two
string method is because you know if you
just want to print printer than m1 if
you just do print of m1 you
automatically see that all the
attributes are printed my case class
hundred hundred test one and somewhere
one so automatically the to string is
also implemented okay so this is the end
of the beauty of gate classes and they
are very very useful just remember that
they are in a very useful for data
transfer object such as details okay
data transfer objects so they are very
useful for any transfers so this is the
cost is a concept of case classes and we
are going to see more of case classes
when we do spark because there I use the
case classes a lot okay so you're going
to see that more often okay here should
have outside asking me that what is the
hash code here escort is basically you
know it's a hash code function generated
by energy VM and these are very useful
you know to generate a unique object IDs
so these are useful for you know when
you try to put these objects in hash
tables or when you want to get a unique
ID for the object this is where the hash
code function comes useful and you okay
but I didn't understand universe what
your question is you are saying that
what is the hash code here in the block
in this block of code okay
okay there is a hash code here in ask
what is the function and if you just
want you can even print the hash code
here okay
so you can print the hash code which you
just print even the unique ID of the
object okay so so it's just a method in
which the function has so this is the
hash code you know it the print some
arbitrary value okay there are some more
questions let me quickly take these
questions because we are out of time now
there's one question from silages she's
asking that can you instantiate a modern
m3 as bad then copy and change one
attribute of m3 yeah you can do that you
can do the Jolly will do that okay so so
what she'll is I is asking me that you
know can I make this as you know bare
okay I can make this as a bear and then
I can do m1 dot you know then I can say
M PI D equals 200 okay so can I do
things like that okay
that's what you asking right ravager no
so L is that the thing is that you know
you you cannot do this because you have
to just look at the way you are defining
the my case class you know my case class
the way you've written all these things
okay
these are by default Val okay so so just
remember that you know when you write
them my case class you declare DM by DM
name these are all by default in mutable
looking so you cannot do this you cannot
you cannot write m1 but even if you
declare this as bad you know you won't
be able to do this you that means that
you can change the reference but you
cannot change the individual values okay
so you cannot just do this clear but
having said that you know you when you
do a copy you can actually change the
value so so say for example when you are
copying you can change the employee ID
to 200 that you can that you can jolly
well do so that means n1 instead of
being hundred will be equal to 200 so
these things you can you can Jolly will
do but in this case when you're doing
there monocles n3 obviously it will be
false
because now it's employee IDs 200 okay
just remember they say when you declare
a gift class all the attributes bells
okay so next question from R all these
case classes used to dump our DBMS table
data and run transformations absolutely
so that's what we do we know we dub the
table data and do transformations okay
yeah see the thing is well whatever is
required for SPARC you know that's what
I am teaching so it's not that I'm
teaching in something which you don't
need so whatever I am saying that these
things are by default will be useful
useful spark okay good okay
Erwin is asking me that you know can we
do just Val three equals to M one
instead of M hundred copy yes of course
you know you can you can jolly well do
that so you know if you if you do
something like this this is absolutely
fine Erin but internally what happens is
you know it is going to call the copy
function okay so so this will be
implicitly called even if you don't
mention it
okay but I strongly recommend that you
know you can do this okay just for
teaching I was saying you can do this in
production and you can use the copy
function in case you want to in override
some individual elements so if you don't
override individual elements while
you're copying then you can just jolly
well keep this okay okay good so so
that's about in our case classes for
today and so tomorrow we are going to
continue with traits and inheritance and
then directly go to functional
programming because I want to spend more
time on functional programming because
that's something in which you're going
to use a lot in your career okay so I
don't want you know to get stuck with
deleting ZIP codes in SPARC we this is
where we use a lot of functional
programming concepts and that's where in
a your knowledge is going to be tested
okay so today we are going to see how
inheritance is achieved in you know in
Scala so here even let me explain to you
the example and then I'll show you what
I'm doing in the code so here what I do
is you know we we all know there are we
all have seen you know files in the in
the fire
system so here is a in a hierarchy where
I'm planning to in a modern affine
system so here I have you know something
called a file now this is a novel fine
you know it can be a text file can be a
Java code side can be your qualifying
anything some pie and then basically you
have a specialized type of file called a
compressed file okay so then you have
something called compressed right a
compressed file is a you know it's a
specialized fine because it's just
normal file which is being compressed
okay and the compression can be another
technique or any other technique so this
compressed file is a subtype you know of
so I can say that it's a subtype of file
okay because it has all the
functionalities of the file in addition
to that tonight has its schedule ecology
in a compressed format so what I've done
is you know I have a half I icon at a
untracked file okay and this is abstract
in this class you know there's an
abstract class so that means you know
you cannot you cannot instantiate this
particular class so what I do is you
know to model I have something called an
abstract class and abstract Phi ok so
there's just for modeling convenience
where I put in a B and I'll declare all
the types of files in extends room yes
right right now here basically just
modeling convenience I had this my track
file and there you know obviously I have
to allege track functions open insane
and why these are abstract functions
without implementation because I won't
be you know the derived classes to
actually implement the functionality so
that's why I might have kept them on
track so that you know direct classes a
charge classes can droid the
functionality side as and when they want
so that's my extract file now you know
what I have is and I have I'm basically
modeling this my file you know basically
modeling this file here and if you want
to extend the file if you want to
surplus in the from a particular class
you use the queue would extend
so I'm extending from my abstract crying
and I'm just writing in implementations
for open and safe which are abstract
methods in the base class so here I
write override so what ideally means
that I'm overriding you know this method
there in the base class and then I say
in a def open and just I put this simple
print LM similarly overrides if I put a
simple println thing that my file
pacsafe method called okay so till here
is it clear to everyone what I'm doing
here it's ok good so now that it's clear
now you know let us a nerd let us design
the icon press right now the my compass
file in obviously we know that even when
it comes to opening and saving the only
extra thing which you have to do is
basically compress and uncompress okay
so when you're actually saving the file
all you have to do is basically just
compress it first and then after that
you know the saving part it's just the
same as what you're doing in the mine
fine okay basically just see realizes
the file to disk so that's why you know
maybe overwrite save function what I do
is I provide the logic for I implement
the logic for the compression logic and
after that all I do is I call super dot
save with the violence when this meeting
is called the base class and that is a
my file save method to serialize the
file to the disk
okay okay Ganesh is asking that do we
have to declare all methods in the child
class yes you have to declare all
methods in the child class provided you
know the methods are abstracting the in
the better class so here the methods are
abstract in the parent class so that's
why in the child class you know you have
to provide implementations for in a both
open and safe okay so you have to
provide implementations and the thing is
that you know it's recommended in there
is there is no you know like what should
I say a compiler
you know it it amended because you see
that you know I have this open method
here which is purely abstract but I
haven't implemented that in my file
so obviously the compiler Flags an error
saying that you know the class my files
in a sense it's not implementing the
open method so either make it abstract
or you know just implement the method
here Ganesh so that's why you have to
make it have to implement unlimited okay
and then you have this mark of my
compass file which extends to my file
okay and here what I do is in I just in
implement these so you know the save
method we're basically just before
saving I see your life be fine okay so I
do the compression logic everything and
after the compression is done basically
I just round to call to the superclass
which is the my file class where all the
saving logic is okay so I hope this one
is clear to all of you it's pretty
straightforward so that's obviously you
do inheritance and let us see how we
test it okay so so here's my test
program so what I'm doing is you know
I've declared in a variable F which is
of times my abstract file and then I
give the in a variable new file a new my
idea and so we think this is runtime
polymorphism because I am assigning you
know a child class reference to a you
know to a base class so that's more of
an time polymorphism and then I call the
you know by5 methods open and save then
what I do is in I reassign F to my
compressed file and then I call open and
say okay and if you execute this program
so if you execute this program you see
just a minute so if you execute the
program you will see that in a visible
execution sequence then when I'm first
time when I'm testing my file the my
files open method is called then the my
fine segment is called and when I'm
testing the combine compressed file so
when I'm following the open method so
this is open with and I have an ordered
in the class so we better keep calls the
my file dot open method and when I'm
following the same method when I'm
calling the mypie in shape method it's
really implementing the compression
logic and then working the call into the
my file set method ok so I hope with
this see me you are clear with the whole
concept of the concept of inheritance
now you up here with this any doubts you
have so I have showcased you know you
can write abstract classes or you can
define abstract methods and the rule is
that if you have an ad-hoc method and
every class is extending from that you
have to override this particular method
you have to go and implementation if you
don't for an implementation then it
doesn't make the class abstract or you
know you you will have a compiler error
do you have any questions is it clear to
all of you
okay she'll Ajay is asking that can we
have a class without abstract class I
didn't understand what you mean the
world can we have a class without an
abstract class can we reframe your
rephrase your question Shailaja you were
to say it and we have a class without
the extra keyword is that what do you
mean or can you just rephrase the
question please
okay so file Ajay is asking me that you
know can I have a class can I have this
hierarchy without that tricky word yes
you can have it you know you can just
get rid of this extra keyword but it
doesn't make sense if you don't have
this extra keyword then you can directly
get rid of this class by itself okay
and if you weren't open and save here
and let my crop the compressed file in
extender so it is just immortal
inconvenience because I have kept an
abstraction
so that at least you know how you know a
file should look so that's more like an
attraction I've created okay okay so
Praveen is asking me is there any
difference between a Java and Scala in
terms of inheritance in terms of
inheritance the Java and the scale
inheritance is exactly the same there is
no difference okay okay viola is asking
that how come in my compressed file the
open method was not over didn't see the
open method you know I did not overwrite
okay if you want you can overwrite it
the thing is that you know I haven't
overwritten my compressed file the open
method just to showcase that you know
when we call the open method into my
compressed file the call actually goes
to the open method of the base class
because since there is an implementation
here so obviously the runtime
environment is me we look for the
implementation in the parent class just
to showcase that you know I I did not
implement it so if you don't implement
automatically you know the JVM looks for
implementations in the super classes
Caravela
okay so vanilla is asking that so why
have wise assess where and why not Val
know I've deliberately kept ffs there
because you know here again I'm
resigning reassigning F to my compressed
file okay so you can do this as well you
can make this valve F and then you can
declare a new variable in a battle f1
equal to new compress right so I just
want to wanted to reuse this reference
so that's why am i tempted is that okay
clear Allah okay venkata is asking that
sure do we have to use override keyword
yes it's about practice you not reused
overnight keyword if you it's better to
use all right keyword because it
basically you know tells the compiler
that you're overwriting exactly the open
method so so then what it does is you
know it basically checks for you know it
basically checks where the signature is
the same otherwise in a you can it's
quite possible that you can override
sorry you can overload this method with
some other parameter and there can be
mistakes
inadvertent mistakes you know that right
because across the hierarchy you can
have all loaded methods but overridden
method should have the same signature
so just to ensure that it is compliant
to the same signature as the superclass
we write the overloaded override keyword
here okay you have entered okay now he's
asking me that you know you are the
thing here you are giving an abstract
type here so see it's not necessary okay
it's you can I just wanted to show you
our time polymorphism that's why I gave
it an abstract type you can put a my
five-year-old so no big deal okay so it
does salute you fine you can do that
okay what else
nebula is asking that if I make it Val
can you reassign can you assign
different object reference no you can't
vimla if I make it well you won't be
able to do this so if I make this Val so
then obviously we got a compile error
here because you cannot do a resign mint
too bad
so here again you know you have to
create a new variable by f1 or something
like that okay
so you do something like this okay
clear Imbler okay so that's about
inheritance in action server clear all
your doubts any any more questions you
have I hope you understood you know why
overwrite is it's important okay and let
me show you one more examples there and
if you don't put overwrite what kind of
problems you can have so say for example
you have a class a simple class in a
base class okay and here you have a
method F say test okay and it takes a
parameter say be integer okay
and it basically does nothing okay so
this is the method you have now you plus
you write the okay let's make it parent
now
let's make this class giant okay and
here you ride f-test
in a pea float say for example you write
this okay so this is a independent
method you have a test method which
takes the parameter integer and here you
have a def test method which takes a
parameter float okay so that's only
difference in the signature rest of the
return type and the name of the function
everything is same can it tell me this
is overriding or overloading what is
this what is this example this is
overloading or overriding took a very
good finish
very good row file a very good praveen
yet see all of your right prashant in
row so it's basically overloading okay
so because you are you know providing
the same method name with a different
parameter list so it's basically
overloading okay but maybe you know you
wanted actually to override so the thing
is that you know by mistake you did this
but basically what you wanted was you
know you wanted to actually override
this parent method rather than overload
so in that case you know it's always
better to write override because the
moment you write over right so what the
compiler does is it's going to check for
a function name test in the base classes
okay and in the base classes if it finds
a function name and then it's going to
check signatures so obviously the
signature doesn't match because this is
an integer here and here it's a float so
that's why so okay so sorry I have
forgot to write that so that's why you
know obviously the compiler will flag an
error I didn't say that you know you're
trying to override what the signatures
don't match so users override keyword
you know just to strictly ensure that
the signatures match okay
yes sorry about this I forgot to write
the extents parent so that's why some of
you could not answer overloading or
overriding sorry about that so okay
so it is clear now why you should write
and the moment you write over it
obviously you're going to get a compiler
error so you just need to write into
here so it will then the combined your
degree you know compile the code clear
out of you I just remember this okay
and Prashant is asking me yes in Scala
do abstract classes achieve
hundred-percent instruction absolutely
okay so strategies you can achieve any
person instruction to abstract classes
okay okay are always asking me what are
the major differences and similarities
between Java and Scala see I cannot
answer this question Rob because it's a
big maybe at the end of the course we'll
try to answer it work now if I second
answering this I think the whole lecture
you know we'll be talking about this
which may not be very relevant for
things but maybe at the end of the
course we can talk about this okay good
so so this is about it
now let me you know introduce in
something called traits
okay so traits are in a very similar
they are very similar to interfaces in
Java okay so in basically but how it
differs you know from create interfaces
in Java is I didn't win traits
basically you can keep in a state
variables okay so you can keep state
variables okay so you can keep state
variables okay and also you can car you
can have you know methods with
implementations
the two key differences okay so it is
similar to interfaces in Java but it's
exactly not the same as streets not as
same as interfaces in Java because in
traits you can have state variables and
you can have methods with
implementations which is not possible in
interfaces in Java in case you cannot
have straight moving words here now let
us understand that you know in Java
you have this abstract and versus in I
interfaces similarly in Scala you have
so abstract versus traits okay not only
a situation I'm going to tell you when
should you use abstract classes and when
should you use strict supey so abstract
classes basically you know you use it
you know when you want an abstraction in
another common in a hierarchy so say for
example in our abstraction in the common
hierarchy I mean that say for example
you know in the files we saw that in a
you you have the you know you can have
normal files you know then compressed in
an N encrypted and embarrass types of
stuff okay so you can have all all sorts
of files so if you have a kind of
hierarchy then you can you can define an
abstraction to an abstract class
similarly now if you if you have say for
example it accounts so accounts can have
in various types of a consignee you can
have a savings account you can have in a
current business account you can have a
you know trading account that you
stopped trading account the very sense
of accounts you can have in the bank so
here again you know you can come up with
a sort of abstraction you know across so
because there's a common hierarchy and
in a decade there will be lot of common
functionalities so all these
functionalities you can put in the
abstract class which can ease you can
make the base and from there you can
drive all the classes clear when you
should use abstraction when you should
use abstract classes this is clear to
all of you I want a yes-no from all of
you that these are very fundamental
stuff you know I want all of you to get
absolutely
balint so remember you know when to use
abstract classes and when to use
interfaces and this principles are the
same across Java across scholar in
across C++ any any object-oriented
programming language is that when you
have a common hierarchy and you want to
give a common functionalities you know
in so then you can abstract it out in a
in a common base class and and give that
as a as a root base class and derived
classes from it now when we come to
knowledge even when we should use traits
or interfaces in Java when you basically
you know want to provide you know
specifications okay so what do I mean by
provide specifications so say for
example you know you are in on designing
a remote control okay so you are
designing a remote a TV remote okay so
we all know what a TV remote is so
obviously in TV remotes you know you
have a red button you have a blue button
you have a green button you know you
have a in a volume you know plus minus
button and you know you have a channel
you know plus minus button so all this
stuff okay now the thing is what you
what your strategy is that you want to
give another specification and you want
in a specific you know implementers to
implement the you know that will have
their own implementation so say for
example in a few the sonic TV remote you
know maybe the red in a will you know do
will you know will if we show the date
okay maybe you know the maybe the LG you
know TV will the red will you know show
males okay so like that you know you can
draw your own functionality but at least
a specification that you know the red
button should be there a blue button
should be there like that you know
should be provided by you know the TV
remote plan so typically in Java you
know will will write in our interface in
a vehicle to st. of his remote
so we are going to have something
you know public boy it on red then we're
going to have a method like on green on
blue something like the entity and this
concept is exactly similar to traits so
in Scala you know we are going to have a
trait and instead of this we are going
to write public you know and then say on
red and I'm going to say unit I like
that you know I can I can keep on
defining methods okay so so that's again
interface and another interface example
can be that you want to in a design
would give you shortly but to the little
of you okay realizing that is I think I
kind of think it creates interfaces
provides multiple inheritance yeah
that's a that's a very actually named
explanation a lot of people say that you
know three interfaces or creates I can
do multiple inheritance but actually
that's more of on the implementation
side you know it's not a conceptual site
the conceptual thing is mainly if you
want to you know provide specification
so if you are providing any sort of
specifications functionality then you
know traitor's interfaces are gonna be
the way to go
and obviously know it from the
implementation side you can say that you
know that I want to implement multiple
interface but that's a very what should
I say amateur answer because if you're
really doing that is only related to
simpler to Java or scholar where
multiple inheritance is not supported
but if you look at languages like Python
if you look at languages like C++ where
multiple inheritance is supported there
obviously this your argument won't make
sense so a general design approach is
what I have told you okay ok vimla okay
Ganesh is asking me his red green blue
all these are state variables no these
are functions are functionalities these
are not States oh so ed you know the PV
I'm sure you you know you've seen a red
button blue button green button on on
the TV remote I don't know which part of
the world you are but honestly I think
all the remote pieces you know have
discovered buttons and which can have
various functionalities
okay clear all of you went to use this
went to go for abstract classes and went
to okay sorry Ganesha okay I got Ganesh
is confusion what Ganesh is saying is
that is that on red a method and is this
red green blue no I mean these are
buttons okay these buttons these are
button names okay so these are not
States it's physically a red button a
blue button that's what I meant okay
Ganesh so obviously when you press the
red button this method gets called like
that
so this TV remote doesn't have a state
doesn't does not have state variables so
it just has a bunch of methods which
provide the specification okay like in
the save you have a doubt just ask okay
so because obviously I'm talking and
writing so things can be missed out it's
absolutely fine okay good so it looks
like all of you appear so now let's in
and see one example of what I've done is
you know I have designed a trade here so
and the trader is basically what I've
designed is a speedometer okay
and here the Phaedo meter what I'm doing
the speedometer is you know I have kept
a state variable so speedometer is what
you see you know where it shows the
speed off of the vehicle so it's a
general-purpose speedometer so you can
put that specification on a cycle on a
on a bycicle
on motorbike in cars anywhere you can
put it where you know it's a moving
object so I've taught kept a state
variable in a protected so why I've kept
it protected because only in a classes
which inherit you know which inherit
from this straight will have access to
the speed variable so this is a speed
variable of type float which basically
stores the state okay which shows the
speed of the may of the value of the
moving object and there are three simple
functions okay these are the interface
functions or trade functions which
doesn't have an implementation but if
you want you can have implementations
nobody stops you so it basically shows
the speed
and then in accelerate and decelerate
okay so this is the trait I have which
are designed and now I'm putting this
trait in a you know - mode
okay Ganesh is asking me that can be
having irritants and traits of course
you have you can have inheritance in
traits so you can have a super trade
from there you can drag a child trait
you can just like classes you can do
that okay so now what I've done is in
I've designed to dashboard and this
dashboard you know basically has a
constructor has a primary constructor
which takes the float as an argument and
this is extending another speedometer so
basically it's providing the
certification for the speedometer crate
and here basically I I just show them I
provide implementations so I I say show
speed and accelerate this Lorraine so I
brought implementations okay and in the
death speedometer I this is how I test
it so so here what I do is I declare the
speedometer variable of time dashboard
and I give the variable of five that is
initial speed is 5 and then I say
initial speed is in a speedometer one
not show speed method I call and then I
accelerate and then I discrete so just a
simple example to show how you can use
traits geography with this example it's
pretty straight forward a simple example
easy to understand
I get all clear with this once you clear
I can show you some more complex
examples but can I have a quick check
from all of you whether you clear with
this not okay good so now what we are
going to do is we are going to see some
more in a little bit of a complex
application now the speed here okay the
speed is of type float okay it's a type
float now now
what if I if I want the generate speed
in the sense that in I don't want to
hard-code the the data type of you know
float office so it's what if I what if I
don't want you know don't want to
hard-code another data type of speed so
I want to make keep it user define so
that you know you can have a speed as
float or you can have a speed as integer
or double anything which the user can
use it and specify in that case you know
I go for something called generate page
okay so I design a generic speedometer
and the way you design generic types
it's not there in the course but I'm
just teaching you so that you remember
this it's not there in your material so
just pay attention to what I'm teaching
here so what I do is an I declare a
generic type and to declare generic
types in the you have to write like this
when you declare the class name after
the class name you know you just give in
square brackets you you write T so T is
the convention okay so you can write XYZ
anything even right but usually for type
screen the convention is T okay there's
not a keyboard or something so you can
write XY 0 also absolutely fine so T
means a generic type okay so yeah it
means you know you can you can pass any
yes gonna show right you can pass any so
if you just want to stick it to numeric
types and you'll be sleep and do a sub
classing but I'm not getting into that
complication here so it's a type any and
then basically I just keep the types T
that means this is a general type I'm
using okay this is the syntax Q at all
of you know what I do is and now I
design a generic dashboard and again run
a generation in a generating the generic
dashboard you will be using T here so
you have to write you know T which is a
generic type and it takes the speed of
type T okay yes you're right regular
that this condition can we use for
return types as well okay so you can use
it for return types as well so you have
you know you write the bios PT and it
extends again the generic speedometer
and here you provide the implementation
so it's just a same implementation as
above so the float is basically replaced
with tea okay
and the way you use it is very simple
the thing is that when you are declaring
the generic - but you have to just
mention in square brackets the data type
so here basically double I want into the
speed to be a sub so that's why I
mention double here in the braces in
brackets and then I end up create a new
journey - Bo 25.1 and the rest of the
stuff so if I execute this you will see
that initially I had use float and now I
have used double okay so you learn two
things today you also learned how to
handle generic types and also use that
about traits and similarly know traits
canned and you can subclass traits so
suppose there is a super crate so you
can write create speedometer extends in
X Y Z so you it's just applicable as
classes okay so you can just use it the
same way no big deal it's the principle
of inheritance a place to create as well
clear all of you yes you're right vanish
in Ooty combine steering run no T
doesn't compile organized is asking T
does it T compiled during runtime no T
is not compiled during in a not
substituted a grand time during
compilation only you know the types of T
are result because I have already
written double here and given the values
so every compilation T is result to
double so wherever T of course they are
substituted with double okay
so it's not a runtime resolution its
generates our result at compile time
okay good so
we have any more questions for me
anything you would like to ask clear
okay good so that brings us to the end
of tricks I hope you enjoyed listening
to this video please be kind enough to
like it and you can comment any of your
doubts and queries and we will reply to
them at the earliest to look out for
more videos in our playlist and
subscribe to our Ed Rica channel to
learn more happy learning</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>