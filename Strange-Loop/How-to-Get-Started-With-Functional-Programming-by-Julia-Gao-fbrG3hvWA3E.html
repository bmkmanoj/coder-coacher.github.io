<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;How to Get Started With Functional Programming&quot; by Julia Gao | Coder Coacher - Coaching Coders</title><meta content="&quot;How to Get Started With Functional Programming&quot; by Julia Gao - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;How to Get Started With Functional Programming&quot; by Julia Gao</b></h2><h5 class="post__date">2016-09-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fbrG3hvWA3E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">uh how's everybody doing good alright
cool so I'm going to talk about how to
make fun and development more functional
today just a little bit introduction
that's my name julia gal and i'm a
software developer at OC tanner i do use
javascript i work every day and I do
like math and science but do I like
JavaScript and maybe it's really easy to
use but we'll talk about that later cool
alright so in the next 30 minutes or so
I'm going to talk about functional
programming concepts and maybe I'll
mention some types and then there are
some other languages for front-end just
in case you want to try something else
other than JavaScript so we'll be
talking about that as well okay what the
functional so so the three concepts I'm
going to go over our immutable data
structures and pure functions and
composable functions so basically
immutable data is just not letting you
change variables after you first assign
them a value right so you can't touch
this but now you may think doesn't every
variable get changed somewhere somehow
and since we learned object-oriented
programming at the very beginning and I
i'm pretty sure tons of us are still
mutating data on a daily basis in our
coding life and so we're pretty much
used to changing stuff right and and i
think we may think mutation is good
because then we're able to actually
compute anything
but it's mutable data good or are they
just easy so some of the things we may
lose for using a changeable data is that
we don't have any control over our
arguments or parameters and we have no
control on our outputs because since
everything can be changed if we do
change things outside of our function or
outputs may be different again which
yeah so any changes on the same
variables can and probably will produce
bugs and it's not thread-safe anymore
because we can change everything so this
threat may think this variable is this
value whereas the threat is actually
changing it so they don't so they're not
consistent anymore and we lose the
reference sharing because we can't share
your references because things can get
changed all right so basically it's so
easy to lose control when we change
variables cool so since we want to avoid
changing things as much as we can when
they create new variables when we do
change it right but that actually
requires us to copy tons of things if
the language doesn't actually have
immutable objects and we all know that
copy things can be really really slow it
just depends on the size of the data
we're copying as well as how many times
we will be copying them so it can lead
to really really slow data but actually
a lot of functional programming
languages such as a closure closure
script or hasko Pierce Crip or earling
have built-in immeuble data structure
which uses which uses persistent data
structures
and it looked something like this so on
the left-hand side we have the original
data which contains one through seven
right and then we want to add eight on
26 node instead of copying every single
thing we're really just sharing the
reference of the things that are not
being changed and then making a new copy
of all the parent node of six that are
being changed so after you insert note 8
only six and then three is the parent of
six and then one is the parent of three
and six get copied over instead of every
single thing okay so now you say it's
not necessarily inefficient but what
other benefits will you get so when you
have more than one threat operations you
don't actually need to lock them anymore
because they can be changed so no matter
what you do on the other thread the data
won't get changed so you can safely do
your own computation on this thread
which prevents deadlocking and then
since you can actually share references
copying anything can simply mean creates
a new reference which is constant time
so it's actually more efficient same
thing as a comparison so sometimes we
want to do deep comparison on the value
we're actually just comparing references
and not being able to change any data
keep the data consistent which provides
a peace of mind in our mind right so
what about loops what about four loops
while loops or do our loops
maybe we should try to reduce the time
so we actually use loops and use
recursion instead because loops a lot of
times encourage mutation so let's say we
have this factorial function by passing
a number hopefully it's a number and
then we okay so then we have the result
of equal to 1 and then we have this for
loop of going through one to this number
and every single time we're mutating the
result two times the number and then
we're returning the result so and so in
this case we tend to mutate the things
that we were we tend to mutate the
things within the for loop but if
instead we use recursion like this and
then recursion tends to have similar
patterns whenever you want to use it so
so normally you would write the base
cases and in this case if n is zero you
simply return one and then you write the
the otherwise recurs case so so so if n
is not zero we're simply recursing the
function and then passing it and minus
one and then in this function no
variable will get changed not even n
because when you call the recursive
function and it's different every single
time
okay so the second concept is pure
functions and pure functions actually
just means same input and then same
output every single time it doesn't
matter any outside changes and we may
not notice it but we're actually using
pure functions all the time because
we're using math all the time and math
computations are actually just pure
functions like we expect mass to have
the same result every time 10 is divided
by 2 we always get 5 right it can be 100
or something so some of the benefits of
having pure functions or you will get
the results that you want it every
single time and then it's really easy to
refactor because so if you have pure
functions in your code base and it is
very very hard to get surprising results
you then know exactly what those methods
are for which makes moving things around
and then still maintaining their same
results very easy so if most of the
functions in your code base are pure
functions then you will have a better
organized code base and some of us may
have experienced the pain of bringing
new people on board and I'm sure one of
the main reasons can be due to the time
they actually need to understand our
code base by so but if your code base is
really well organized whenever you have
new members join your teams you can
easily understand where everything is
and then start contributing so
JavaScript actually has pure functions
and they have a lot of building pure
functions and functions such as a split
slice to lowercase uppercase math
functions and cetera they're all pure so
so I think if javascript can do it you
can do it as well okay it's just a
simple example all right let's say you
have an array of programs somewhere and
that's not supposed to be changed so you
may either do comments or whatever to
let other people know that they're not
supposed to be changed and then in this
program trigger you pass in one program
and then you're checking like the
program name or whatever and then
whether the list of programs contains
that one program and if we simply return
true or false we're not changing the
past in program or changing the list of
programs but if we try to mutate the
list of programs then other places i use
that list of programs may get surprising
surprising outputs ok so the third
concept is composable functions so what
is composable functions it's a circle
and we're getting warmer it's F circle G
whatever that means and then if we all
remember math it actually just means we
are giving function G some variable X
and then get some result and then we're
simply passing that result into this F
function right so since there are a lot
of native JavaScript functions that are
pure and composable their results will
be the same every single time we do this
so let's say we have a string of bar
food equals bar whoever did this and
then we do upper case and a split and
uncle cat we will get this result every
single time because all three functions
are pure and we're now actually mutating
foo so in this example we're changing
things a little bit so this is a known
not pure function so we have this X
because the sentence can be changed and
then in this
and then if you look at three lines
above the last line or two lines above
the last line we call it the first time
so we have X at the upper case and then
we're checking if the string has changed
in it and then we will find the index of
it right and now we're calling this
mutation function for some reason and in
the mutation function we're checking if
the X has that string or not if it is
we're changing the X to the oops so
we're so we're passing sentence in
mutation and X does have that sentence
so when we call the same functions again
exit to uppercase that index of will get
a very different result so if instead
we're making the mutation function a lot
of pure and then we're calling a new
creation so in this case we're having
the same variable X and then we're
checking X contains a string or not and
then we're simply returning oops instead
of changing X so we will get the same
result when we check X the upper case
that index of change well the result
will always be the same index okay so
now you know when are we going to use
this kind of function so hopefully this
is a more practical example okay so in
this case we're passing in some group
into the get details right and then we
want to check whether the group has idea
or not and then if it doesn't we create
a random one two three ID but then we're
really changing the group object for
group that exact ID and then assigning
the ID or 123 to it and then when we
call the URL we get callbacks that has
details and then we want to pass in the
detail things into this other function
and then we're assigning groups again to
the result of this function so we're
changing group again and then after that
we're simply returning detail
us and groups in a list but at this
point group is being changed so many
times Oh actually group is also being
changed in the other function in the
processor so we're checking images and
then do something else and now we're
changing the group that images ecosys
new images so group is being changed and
then group can be declared somewhere
else and if some other functions also
use the same group then their results
may not stay the same when we call this
function but if instead we assign a new
variable whenever we try to mutate right
so we're still checking the same thing
we're checking if group ID is there and
now we're creating the new variable ID
and into the same request and then
getting callbacks and stuff and then
instead of assigning group to the result
of this image processor we're creating a
new variable and then returning the
variable and the detail and in the image
processor function instead of changing
group we're using object design which
creates a new object and copy everything
inside of a group and then only adding
the images element inside of the object
so we're not really changing it we're
simply returning a new object in this
case so then we know exactly what this
function does and and and if later we
want to reflect your things it won't
impact things outside of this function
cool so now we're going to talk about
types wrong types but yeah
and every expression has types and even
if we use like C sharp or Java our code
actually cares about types a lot so
let's say you have a c-sharp call like
this you're trying to do concert that
right line but you're really passing a
string times a number which doesn't
really match you may get an error like
this and that's really saying oh those
types are wrong you can't do that and
even Java scripts actually cares about
types a little bit so we all know
JavaScript can core some types so let's
say we have a string type of an integer
it will actually treat as an integer so
it can compute things when it comes to
math but if we do something like a
string of high and then we time set to
10 will get not a number right and not a
number is really just a nicer way of
telling us all those two are not the
same type but we do have to pay a price
for having the nice things and that's
when we do defensive programming so we
have to check the type of the parameter
or whatever before we can do anything
else and just in case our defensive
programming isn't enough we create unit
tests specifically to check types so so
in this case we check whether we can
pass in a strain we can pass in a zero
and negative a negative number or really
large number and then some other random
types we check whether our program
prevents that from happening or not but
if the language has types and it's
compiler has a type checker then you
then your unit test can focus on testing
the logic of the function rather than
checking both types and the logic and so
the test for
the bar example can really be reduced to
I don't know three tests rather than six
so I grabbed this chapter exercises from
the Haskell book and so I don't want you
to pay too much about the details of
each function but I would like you to
pay attention to the types of each
function so it's a little bit all over
the place but i'll just tell you the
steps of walking through the types so
the first one that would be called it's
called wort number it's at the very
bottom that takes an int and then and
then the result should give you a string
and then we're number if you look into
it it will call this other function
called digital to work but before we do
that we have to call this other function
that cause a digits of from integer to a
string so we call that or sorry so
digits is this is actually converting or
not converting but transforming the
types of an integer to a list of integer
so we do that and then we but inside of
digits we also use Cal which we know for
sure will take two parameters that is a
type of integer and a list of integers
and then we return another list of
integers and then inside the account
we're using combine which also takes two
parameters that can be really confusing
right but if you follow the types your
program will make sure that this all run
and you can't pass in like string two
digits or account or something like that
so types kind of help you format your
functions better and then helps you
organize your code okay so I got
frustrated with JIRA one day so I
tweeted this I say cheers like
JavaScript it's really easy and simple
to use but that's also the probe the
counts of it I do like JavaScript
because it's very flexible and very easy
to use but since it's so easy to use we
also have a lot of cons and ensure we we
have a way to get around those things
like sometimes in order for other people
to know certain things cannot be changed
we may add the word const onto the
variable so like a group underscore
const or something so that other people
know okay this variable shouldn't be
changed that helps a little bit but that
doesn't really prevent anything so if
somebody accidentally changed them
nothing will stop them from doing that
so what are some of the alternatives do
we have when it comes to front-end
development first one it's called
immutable J's so it uses the same
persistent data structure that we talked
about earlier so this is a regular
JavaScript map and then we first set the
map 21 and high and I later we add 2 and
x to it and then the size of the map and
the content of the map changed but if we
create an immutable map we have to
initiate a value first because the first
map can be changed after that so we give
it one and high and then later we want
to set again with 2 and x we have to
create a new variable to contain the new
value because the original map doesn't
really change so then later once you
check the size of it it will make a
remain one and then the new map will be
too so this is like an easier way of
adding that but we can just and we can
just import the library and then start
using it but if you want to dive in just
a tiny bit more and use some of the
source you some of the real functional
programming languages here are a few of
them
so there's closure script it is written
in closure which has the Lisp syntax but
don't let that stop you so you may see
something like that so say we define a
vector 1 2 3 and a later we want to add
4 into it so we will get the result that
we wanna which is 1234 but the original
vector 1 2 3 wouldn't get changed and
then let's say we have an increment
function that takes a person and
increment the age of that person instead
of changing the given person object a
sauce is a shortcut for associate and so
so when we do use a salesperson and then
change the age of that person to +1 it
will return a new map rather than
changing the given person and then
there's Pierce grip it is written in
Haskell and it also has a haskell syntax
and so we have this app function and its
really simple so it's just a so it takes
in two integers and then return another
integer so it guarantees type and won't
mess that up and then the second one is
the same function as a code escape
function which is increment the age of
that person so let's say we have an
object a person that has name age and
something else and then we are passing
this person in and then getting a person
object back but instead we're getting a
new person object back that has
everything else in the in the P and then
we're returning with the new age so
we're not changing the given variable
again we're just returning a new person
kind of like when we age we are a new
person my age okay say you want to try
some of these but how do you choose
which one to learn first so Haskell is
purely functional language it is typed
and an ampere script if you want to try
P R script but don't want to convert
every single line to peer script yet you
can simply write a component in pure
script and then it will compile to
JavaScript and then you can simply
renders that with the rest of your
JavaScript code so and then there's
closure closure is not typed but it does
have other benefits of a functional
programming language and I think closure
is really easy to integrate since it
runs on JVM and then you can just
radical I you can just write a component
enclosure and then simply add the jar
file into your Java program a job
project and then there's also F sharp it
is typed and since it's produced by
Microsoft I heard a lot of good things
when you try to convert your C sharp app
to F sharp and I know we may not be
comfortable using some of them right now
but we're really just need to get used
to but we really just need to get used
to the syntax and the functional way of
thinking it when it comes to
constructing our code and then you will
see all the perks of using that okay so
the conclusion is immutable data
structure is actually more efficient and
then when you do use functional
programming concepts you produce a more
reliable code and then it makes us think
about code before we actually start
writing code and that's all I have and
all those slides are on that link and
there's another talk about Pierce cope
after lunch so check that out if you
want to and that's how I have thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>