<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Bootstrapping the Web with Scala Native&quot; by Richard Whaling | Coder Coacher - Coaching Coders</title><meta content="&quot;Bootstrapping the Web with Scala Native&quot; by Richard Whaling - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>&quot;Bootstrapping the Web with Scala Native&quot; by Richard Whaling</b></h2><h5 class="post__date">2017-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-52HXQKwk5E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">who here's tried to do something with
Scala native download it compile a
program okay cool cool cool and anyone
here ever write C for school or for a
living
cool oh nice okay I got the right crowd
for this some of this might be a little
systems 101 for y'all but I will see
where this ends up so yeah thanks for
come to the talk there's a talk about
Scala native right but it's not just to
talk about Scala native it's a talk
about systems programming in the most
traditional sense it's also talk about
server programming and server
programming as the quintessential hard
thing to do in systems programming right
the reason there's like one book on UNIX
systems programming is in two more books
on writing a decent server but it's also
a talk just about working with emerging
technology in general I mean here we are
we're at strange loop beyond Scala
there's all kinds of awesome emerging
languages out there and when you're
working with new technology you don't
have the kind of giant stable platform
we all take for granted and absolutely I
hope this talk contributes just some
some knowledge about how to basically
come up with improvised solutions
provisional solutions to do useful work
with really new tools it's also about
like is your OS a platform what can you
expect from your OS and like what can
you expect from your language where's
the boundary between those in the more
hand-wavy later sections um concretely
the the talk is going to be a really
quick introduction to scala native
probably too quick but then we're gonna
actually like see some let's see a lot
of code is gonna be a code heavy talk
I'm gonna go over like basic like
serversocket programming and then we're
gonna come up with Minimum Viable web
server and then we're gonna start making
it faster when add some multiplexing
both multiplex protocols with a proxy
and then real direct multiplex IO and
then we're not gonna conclude we're just
sort of gonna pause trail off and think
some warm fuzzy thoughts all right so
that's the plan
about me I'm a consultant at span Tree
Technology Group a fabulous boutique
consulting firm in the West Loop of
Chicago I work with Kafka akka and spark
pretty regularly I've been contributing
a bit to the
- no doubt three releases of Scala
native but I'm by no means like a core
dev team member or anything like that I
also work a lot with like kubernetes
meso silastic search stuff like that and
yeah I've a lot of this contents also
available in blog formats pantry no
slash blog go check it out
also I'm on Twitter and at Richard
whaling I just tweeted out links to the
slides and to the github repo with all
the code some of this stuff's a little
bleeding-edge and might not even be
merged in yet but I'll continue pushing
stuff up and basically as I blog about
it over the coming weeks so that being
said let's get started
so what's Scala native its first of all
it's it's Scala it's not like a fork or
a variant or a separate implementation
it's a it's a plug-in for the Scala
compiler and SBT in particular it's a
it's an LLVM backed a ot compiler so
basically what that gives you is the
ability to take a Scala program and
compile it all the way down to compact
like maybe five ten megabyte like chunk
of executable bytecode like a C compiler
or go or uh scan which is awesome
it's especially awesome for command-line
tools people have things like Scala
format and there's even some demos of
Scala C itself running in Scala native
which is really cool the downside is you
don't have a JVM right and if you don't
have a JVM doing things with Scala's
actually pretty hard just because the
original plan of Scala right was to
bootstrap and all the things the JVM
already gave you and most pure Scala
programs transiently depend on Java
classes under the hood to do pretty
pretty simple things the way Scala
native gets around that is it includes
like alternative implementations of some
of the JDK classes but there's
definitely not like a virtual machine
under the hood
instead everything's basically re
implemented in terms of like C systems
calls and in particular the really neat
stuff Scala native provides is a set of
types and annotations for really really
cool like C Interop like tricks and it
really encompasses like the full range
of like weird idiomatic C programmer
stuff that we all know and love so like
you can do things like this
so you declare C struct types basically
like like tuples right so we'll declare
a vector type like it's a three
dimensional vector of three doubles and
then we just have this stack a lock
function that'll just allocate one on
the stack and give us back a pointer to
it right so pointer is is asterisk right
I actually I've written C for a long
time and like once I saw this it's like
it's hard to go back it actually just
makes more sense the kind of weird thing
is because it's tuples you don't have
names for your fields yet that's coming
too no doubt for is my current
understanding so you do have to keep
track of which field is which but it's
crazy fast and it actually compiles down
to real structs with all the goodies
same thing goes for arrays arrays of
structs void pointers it's it's awesome
the the other really cool thing is
binding to see functions either the
standard library or external libraries
you just declare one of these externa
you name your your function you give it
the right type signature and the value
is just X turn and not a compile time
but a link time Scala native will look
it up and create the the suitable like
dynamic linking stubs for all the magic
to happen and then congratulations you
have malloc and free and now you can
have you can have all the horrors of
segmentation faults and your Scala
native programs when no but what this
also means is like you could also do
something like write a write a custom
memory allocator and Scala which starts
to get really exciting I will also say
Scala native has an excellent garbage
collector and if you're running pure
Scala code you don't have to worry about
memory allocation or stuff like that
it's only when you go down into the C
Interop and you're slinging pointers
around that you have to deal with that
but that's also where the really fun
powerful stuff is so you're gonna see me
do a fair amount of it today what it
does include is it does include
implementations of hundreds of JDK
classes in in in terms of these like
basic C libraries unfortunately that's
actually like a drop of an ocean the JDK
is enormous there's pretty good but not
entirely complete ANSI C bindings same
for
six the like UNIX standard circa 1983 or
whatever but the the cool thing is
because it's so straightforward to bring
in and just add your additional ones you
can it's easier to write your own than
to use the the standard once in many
cases so what can you do with this what
can't you took with this obviously you
can't do anything that's depending on
like deep JVM capabilities anything
that's using like nettie for example
like akka HTTP is probably not going to
be possible in the near future on the
other hand if you want to do something
that you have a sea library for um and
maybe you don't have a good Java binding
then you're gonna have an awesome time
and that's where I think this gets
really exciting so yeah let's move into
the the actual like substance of a talk
like what's a server yryr server is hard
to write I'm gonna argue that a typical
server like granted that's broad
generalization does like four things it
listens on an open port it accepts
incoming connections on that port
it reads requests and it writes
responses
the reason it's hard is because it has
to do all of these things at the same
time and that it has to do it with
system calls that were traditionally
have having blocking semantics that's
big big asterisk right which we'll get
to in the the second half of the talk
but the the system calls that actually
allow you to do this right because your
I mean the great inside of Haskell is
your programs don't do I owe that best
your programs can ask your runtime to do
IO for you right the the system calls
that allow a program to ask an operating
system to start doing stuff on the
network or here it's really just about
eight of them but the the really tricky
ones are bind and listen
so you initialize a socket with socket
you call bind to assign it to a given
port an address which is pretty
straightforward listen is really
interesting though when you call listen
that's what tells your operating system
hey this is a server socket if you get
inbound TCP connections on this port an
address it's gonna start accepting the
three-step TCP handshake sending acts
and establishing connections but the
thing is your operating system is doing
that for you in the background totally
separate from your pro
what happens is it establishes the is it
establishes these connections and puts
them in a backlog and of course this
backlog has a fixed size then when your
program calls accept accept is that the
thing that establishes connections all
accept does is it pulls those
connections off of the internal backlog
right and there's a lot of Scala people
in the room so I bet a lot of people
know about back pressure and knows hey
if you have like a finite queue and
stuff coming into it the worst thing
that can happen is your queue fills up
and that's when your server will stop
will start refusing requests entirely
the really critical sort of metric I
would say four four servers in general
is can it keep up with incoming
connections as fast as as it needs to
before it starts dropping things on the
floor once you've established this
connection you know then there's more
specialized system calls like receive
and receive message but you can also
just read and write to it like a file
good old-fashioned UNIX everything as a
file magic the one like additional
asterisk is that there's these three io
control set socket op and file control
system calls and these are like pure
evil doing this and like a portable and
backwards compatible way is why this is
hard and I'm not going into it at all
but just to be aware that this is a
something that I'm totally punting on
for this talk so the the way these all
fit together is like this so you've got
a server and a client the server sets up
the socket by calling socket by and
listen and then accept and then the
client right is called socket and
connect to establish the connection and
then you just go into a loop of read and
write calls and then you're done right
it's relatively straightforward
typically the the examples of this are
in like an CC textbooks or whatever this
is what it looks like in scala native
isn't that relatively reasonable
thumbs-up thumbs-down
no is that any better okay cool
so after remember to shrink this back
down afterwards so it turns out the
hardest part of this is actually
allocating the structure at a whole to
addresses the
Berkeley sockets API predates @cc and
void pointers by like a year so instead
there's all of these unsafe casts
between a couple of different socket
variant types because you could have
internet sockets UNIX sockets all these
weird like ATS like things that don't
exist anymore so there's a lot of things
that seem pretty foreign to us
but basically we just we we use malloc
unlike and I'm like and see you actually
cast malloc a lot because you are in
Scala and you are just slinging void
pointers around with total Cavalier
capabilities and then once we've
allocated the socket we just say hey
this is an Internet socket so it's gonna
be one of the IP protocols TCP or UDP we
set up the port and then we set it to
any address which is the same as binding
to 0 and I 0 2 0 0 once we have that set
up then we just call socket to get a new
file descriptor we're gonna say Internet
Sokka and sock stream to say we want a
TCP socket and not a UDP socket and then
we call bind we pass in that server
address we cast down to a more generic
form of socket address that doesn't
necessarily have the the Internet socket
formats and then we give it the the size
of the address object - once we do that
we just call listen we give it the size
of the the backlog and the one other
kind of weird thing is we also have to
pre allocate a struct to hold the
address of clients as they come in this
is the client address thing that's
relatively similar and once we've done
that we can just go into like a while
loop and start calling except which
gives us another file descriptor right
what's weird is that the server like
socket and the actual connection are
both file descriptors but they're
actually pretty different server sockets
you can really just accept on you can't
it's not meaningful to read or write
from them the connections are the things
that are more like a bi-directional pipe
and and you can actually use like a file
so once you have this connection down
here then you can just pass it in to
another method to actually handle it
let's see if that code is readable yeah
it looks ok so the idea is once you're
in there it's actually pretty straight
forward like we'll just Malecha buffer
so we can actually read stuff but other
than that this is at least syntactically
this is relatively idiomatic Scala there
aren't any crazy types granted while
true loops and like returning is not
idiomatic Scala at all but I ported this
from a c textbook be gentle to me
so pretty straightforward but the the
catch is what with this approach right
what's gonna happen when we have a new
connection coming in like our main while
loop is gonna block most of the time and
read inside of this loop but what
happens if more accepts come in right
they'll just go back into the backlog
and we could be stuck in that inner
while loop basically until the client
decides to stop sending us stuff so this
is sort of the the fundamental question
is how do you do two things at once how
do you get a program to block in two
places at once and the way you do that
is with my single favorite UNIX system
call fork for clones a process in place
it doesn't create a new process it
creates an exact copy of the process
that they that you that called it it's
it's sort of magical like one process
calls two processes return at the same
place but with different values I like
to call it a reverse Thunderdome but I'm
Ching there's a pretty formal
parent-child relationship between the
two the parent is responsible for
supervising the children and cleaning
them up if they are cleaned up they
become zombie processes they will clog
up your process table they can take your
kernel down and like of your hosts not
just a container so like be careful if
you're doing this zombies will will will
overwhelm your containers be careful
hashtag no zombies so right with fork
I'm going to zoom this back out
basically what fork allows us to do is
immediately after calling except we can
fork and then our parent can go back and
block and except again and then the
child that comes out of the fork can go
into the readwrite loop and that's like
the textbook like systems 101 way to get
a working like concurrent UNIX server
running I can't go superfast or
line-by-line here but the idea is you
call fork right and returns a process I
of what the new process is but the trick
is it only returns that to the parent
the child just gets zero so by switching
on the process ID you can know whether
you're in the parent and then you can
return immediately or if you're in the
child and you can do stuff so pretty
straightforward so right winning except
not what are the downsides of this
approach the testing testing systems
programs are hard everything is like
dealing with hardware and backwards
compatibility and vendors and those
wonderful things testing concurrent code
is also hard as I think everyone in the
room knows testing concurrent systems
code is probably the hardest thing
they're one of the hardest things there
is to test I won't be that sweeping
beyond just like correctness there's
robustness making code that really works
the way you'd want it to in a production
situation people don't just sit down and
write perfect like server code this is
something that has to be hardened by
running it in production over years and
it's not something to be taken lightly
portability is viciously difficult just
because of the number of like backwards
compatible hacks and quirks a lot
especially things that they either got
coded into the POSIX standard or were
coded in and then implemented
differently by different vendors BSD
versus Linux vs. sometimes UNIX it gets
terrifying and then trying to do that
while implementing your application
logic in the same code will really wear
on your sanity so there's there's any
number of good reasons not to do this in
your own code or at least not to
maintain it as part of the same package
that actually contains your your
application right so it's like what are
the techniques we can use to sort of
divide this problem of writing a server
into parts so that we can either find or
improvise some kind of like useful and
effective like server socket Handler and
then have all of our application code
live somewhere else and presumably we'll
be doing that with Scala native right
the great like UNIX hackers have been
doing this for multiple generations and
the I think my favorite like expression
of the philosophy was you know write
programs that do one thing do it well
that work together and everything
handles text stream
that's Peter say Lissa's statement right
and in particular I'm going to go
further and say that HTTP is a solved
problem engine X is out there right
there's great things like envoy like
proxies and like there's plenty of good
tools for doing HTTP well so the
question is what's the simplest way to
get a stable HTTP server for a Scala
native app and like let's figure out how
it performs and that being said let's
get started um I'm gonna hand wave over
this section I sort of walked through
exact which is like what shells used to
exact new processes I don't think I
quite have time for it but it's like
what you'd use to implement I net D the
thing that's really important is when
you're after you fork when you exact to
create a new process you can you can do
lots of cool tricks with a file
descriptor so you can make a single like
connected socket look like both the
standard input and the standard output
of a new program for example which is
one of the like all-time grade like
everything is a file hacks and unless
you just sort of read write print
whatever without having your like in our
program having to know there's a any
socket or like network involved but I
can't go super deep into that the the
trouble is that's enough to give you
like a bare bi-directional stream a
connected TCP socket and a lot of the
early internet services didn't need any
more than that like FTP and like our
login SSH stuff like that
HTTP needs more it has a request
response protocol like sort of at the l5
ish layer it has these like resources
and other important metadata like
methods and parameters and the RFC for
it is like 300 pages long and parsing it
isn't easy when people write efficient
HTTP parsers they tend to get used by a
lot of people for a long time and it's
also not to be underestimated what we
need then for our Scala native Jam is we
need some generic way to handle
concurrent HTTP connections we need to
route them to various like programs that
implement our logic and then the
simplest request response protocol for
handlers that we can get and drum roll
it's Apache
and CGI so oh there's those went out of
order so Apache is the direct descendant
of the NCSA httpd from urbana-champaign
it's pre a pre for based web server not
quite the same as the fork except model
but I'd love to talk about the
differences afterwards may or may not be
upon a patchy web server they deny it
now but it totally is the cool thing
about CGI right is you can write CGI
handlers and bash in Perl and awk or in
C right it's the most generic like
interface you could possibly ask for all
you need is environment variables
standard input standard output
you don't need an operating system for
that all you need is like like the the
facilities of ANSI C and for for people
here who are interested in emerging
languages that's really powerful right
because those are like pretty much what
you can get from version o dot 1 of any
language out there and it gets it gets a
bad rap because people wrote a lot of
terrible software in CGI back in the 90s
but it's actually possible to write
pretty good software and CGI also if you
like sort of squint at it and turn your
head to the right a little bit it almost
like resembles server lessness or like
finagle or like everything's a function
of streams onto streams there's actually
a lot of cool things going on there if I
could spend more time in the hand-wavy
sections of the talk so this is a this
is a program that implements a entirely
useful Scala native CGI bin handler
that's all it takes and I've got one
running so BAM that's you don't have to
applaud for that would save it for the
end
so actually building that I have a whole
other blog post about this and again I'm
gonna have to go kind of fast building
like small Scala native docker images is
interesting because you need like Scala
Java SBT to build them even if the
resulting in binary is like five Meg's
or something like that so I'm using
multistage docker builds here so this is
where I'm saying hey from Scala native
base build as build and then like the
second half of the build same file I'll
start over but then I can copy
from the build stage and because it's um
it's dynamically linked right not
statically linked I have to copy in the
exact dynamic libraries it links to
which is a little fiddly but it works
and then I can just like add Apache and
run it I just pretty cool and I already
demo didn't spoil that but that was like
a degenerate like it's not really a CGI
like thing if I were to write like to my
design like like a like a little web
program or something like that I would
want somebody looks kind of like this
sorta has that like flask Sinatra hey
let's just do it let's just like make
this as simple as possible right this
sort of hey everything is a method of
request onto response it has a method
and a pattern matcher maybe we can use
Scala pattern matching to pick apart the
URL path segments stuff like that and
implementing this takes like maybe like
6070 lines of code like let's say we
have a router trait right it takes a
bunch of handlers and the handlers are
all basically just functions of request
onto response with a method and a path
maybe request just lets you get at the
method the path right which is the the
path info and CGI is the segment of the
URL that comes after the name of the
program that's executing so you can
absolutely have like web 2.0 style like
rest URLs you don't have to have
question mark line noise you can totally
get like clean URL design and in CGI and
then let's just say the response is a
body a status code as a matters right
then to implement this really the only
thing we need is standard Lib github I
wrap it because I would rather present
this to the like end users of the
application as a string like a scala
string with all the nice methods it gets
rather than a c string which is just an
array of bytes right so I and I've got
some null safety and stuff like that and
then you know so if I have this path
info with a URL I can just split it on
slashes and do some filtering if I have
the query strings I you know those are
the question mark x equals y you know a
equals B etc I just sort of do typical
Scala
kind of messy for comprehensions to
split them and group them like this
right and once I have all that then
actually running it is pretty
straightforward so this is like the
implementation of the router trade
I just parsed the request I walk through
all my handlers and just try to find the
longest match based on the this prefix
of the the path info and then I run the
handler to get the response and then I
print out all the headers with this
beautiful colon whitespace separated
form and then I print out their response
and that's it and so this runs again to
save time I'm not gonna live demo this
part but this can get a like a mean
response time of 40 milliseconds under
light load the 99th percentile response
goes over a second at 150 users and then
like the mean response plateaus around
500 milliseconds of 300 users can handle
a max of about 400 requests per second I
think we all saw the keynotes so I don't
have to go too deep into the intricacies
of like longtail optimization and stuff
like this which saves me at least like
three minutes so by comparison like a
Python CGI app like just doing hello
world that takes a hundred and 36
milliseconds to just return a basic
hello world response and it does because
you're starting a new process over for
every single request and with Python
that's loading a relatively large
interpreter and running your code and
maybe like compiling it right so
basically what you get with scala native
because it's pretty compiled because
it's like a five Meg binary you're
getting about three times faster
response under light load and you're
handling about twice as much load before
things get sort of dicey that being said
in absolute terms these aren't actually
the the best numbers right like like a
trivial nodejs Express app can get a
median response back in about seven
milliseconds and and the 99th percentile
stays under one second up to 2000 users
the error rate gets up to about 15%
around 500 users which is a little
higher than I was expecting to be honest
but the peak throughputs around 2,000
requests per second so I guess the rest
of the talk and I have like 15 minutes
which is great is how can we do better
than Apache and CGI
how can we sort of close that gap with
with no to get not like a perfect web
framework cuz honestly like most
programs don't bottleneck at your middle
tier web framework they're gonna
bottleneck somewhere else like I'm just
aiming for adequacy and like to get to
where we can do something useful right
and without spending years of our lives
or like you know just like like like
slogging away at writing socket code
right and there there's actually two
ways we can do this that are pretty
pragmatic and are like weekend project
like sort of sort of level undertakings
one is multiplex protocols so that
involves bringing in a proxy server in
front of our application and using a
protocol that's a little easier to
handle than HTTP to deal with that and
then the other is by doing multiplex
Taiyo directly much like node does so
that being said let's do it
so multiplex protocols are a technique
for combining more than one stream on to
one stream I'll have a diagram in the
next slide you can do that in analog
right there's all kinds of ways to do
this but with with digital data
typically what that means is you're you
have something that intercepts multiple
upstream connections and then it breaks
them into blocks like frames and each
frame is basically tagged with an
identifier and because you have these
frames of a known size and they all have
identifiers it's pretty easy to
reassemble them put them back together
and it means that when like if I have an
application that's consuming this I can
just consume a single socket like
connection right I have all these
requests coming in and they all have
tagged with IDs I can send back
responses that also have identifier tags
and again the proxy will know how to
route them back upstream to wherever
they need to go the two things people
have heard of that do this is fast CGI
back from 1996 because people realize
classic CGI was a problem pretty quick
the other is HTTP HTTP too which is like
new and is surprisingly similar than too
fast CGI you know way I think is kind of
fascinating that said fast CGI is a lot
easier to implement so that's what I
went with here so basically what it
looks like is this right you have a
bunch of HTTP clients
they're all speaking HTTP to a web
server and then the web server is
speaking fast CGI back and forth to a
fast CGI application yeah so pretty
straightforward so what makes it
different and better than regular CGI
one is that the application is
persistent it sits on this connection
and keeps it open and processes as much
as I can and since sends it all back
you're not taking the hit of starting a
new process up for every request 40
milliseconds to start a new process adds
up if you're doing thousands of them you
get persistent connections you don't
have to do any TCP handshakes over and
over again and you can just keep a pipe
open between your server and your your
application and again because the
requests are multiplex you can handle
more of them at the same time like if
you have like non-blocking logic you can
return them out of order and cool stuff
like that so it's actually really nice
for like async protocols and also the
framing and the the explicit like size
tags on every like chunk of data turns
out to be really nice for handling
things efficiently you don't have to
scan through like plain text looking for
new lines and colons like everything is
nice and clean the one catches we do
need a socket but like stay with me
there's also some like kind of Hall of
Shame hacks to avoid writing socket code
if you really don't what but the trick
is you might not need concurrency if you
can like it's fast CGI does not
guarantee you only have one socket but
if you can convince your servers to play
nice together and get it onto one socket
you can just do blocking i/o on a single
socket and multiplex all the things and
that turns out to be pretty darn fast
so like at a high level the the the
protocols like this you read exactly
eight bytes because that's the header
you get the type of the request the
request ID the length and there's
padding also because it likes to pad
things out to eight byte intervals and
then basically you keep pulling those
those frames in until you get a standard
end frame of length zero and that's what
signals hey this is the end of the
request it's time to start writing a
response and then you just do it and
write it back out and basically the same
format a byte headers variable size
so like in Scala native the way you
parse the header looks kind of like this
lots of fun bit shifty operators the one
thing that's unfortunate because we are
backwards compatible with Scala we get
to inherit Java's signed bite boo so
because of that I have to do a bitwise
and of all my bytes with o xff to make
them unsigned basically Scala native has
an unsigned byte and I should probably
point this to it but this is as close
you get to a like a bare-metal void
pointer and we're stuck with this sign
for now what's cool is that even though
it's a pointer byte it actually you can
treat it basically like an array and
again this is unsafe pointer arithmetic
right this is not something you
necessarily should be doing but when
you're trying to write like
high-performance net code being able to
inspect the contents of things without
doing copies anywhere actually pays off
and can make an enormous differences so
we read out the version we read out the
the record type we've got two bytes for
the request ID right so we read them out
separately and then we add them together
we have the the most significant byte we
shift at eight bits over to the left
which is the same as multiplying it by
two to the eighth and then add it to the
the least significant byte same thing
for the length and for the padding right
and that's our record header and then
once we have that we know how to
actually read it because we know how
many bytes to read the the thing that
gets interesting is inside of the the
like content frames you can also get
cool stuff like variable length encoding
zuv key value pairs and what's
interesting is the length indicator
itself has a variable length so into
this case you'll do things like if the
top bit of of the name length offset is
1 ernõ is 0 it's a one byte length if
it's one every it's actually a four it's
a four byte length so if it's if it's if
it's not zero then we take everything
but the top bit of the first byte and
all the other bytes and bitch of them I
love this stuff it's kind of scary if
you don't do this every day but what's
really cool is once you get it right
it's like 100 percent right and it just
works and that's my favorite kind of
code to write ok this is
shameful but so everyone uses netcat
right for connecting to things netcat
can listen on sockets to people don't
know this the ability to listen on a
socket and pipe it to a program is
typically locked behind a compiler flag
called
- D gaping security hole and it's called
that for a really good reason and it's
probably not enabled even if it's not
enabled you know you can still hack it
together by using another named pipe as
like a relay to get the data back where
it needs to be but I'm sort of ashamed
of this so I'm not going to dwell on it
and there's better ways to do this but
yeah so you can take this it turns out
nginx I thought it would be great at
handling this engine X does not in the
free distribution like to constrain to
exactly one fast cgi connection it has
excellent fast CGI support but if you
want to put a cap on the number of
connections that's an engine X plus and
I do not have an engine X plus
subscription instead I just wrote like a
80 line proxy and golang because go has
a great fast CGI support too and this
was good this got a mean response in
four milliseconds which is somewhat
faster than that node Express thing I
wrote a second ago the error rates a
little lower at 500 users the backlog
starts overflowing a little sooner it
doesn't quite a peak at the same level
of load and it Peaks around 1,500
requests per second so it's a little
better under light load but doesn't
quite hold up under heavy load as well
as nodes basically but that being said
this is this is pretty cool right
blocking i/o on a multiplex socket turns
out to be pretty competitive with with
modern frameworks and I'm I was somewhat
surprised by this I mean this should be
promising to anyone who's working with
like emerging tools and platforms and
technologies that being said I think we
can still do better so multiplexed IO
right is the big asterisk I have around
blocking system calls traditionally this
was select and pull and then there's
some OS specific async i/o options
eople KQ and the windows io completion
ports which I really don't know anything
about so even bigger asterisk there what
they all provide is the way to pull the
state of mini sockets at once
it doesn't magically make
reading happen in the background it just
lets you know exactly which things you
need to deal with at one time and the
idea is because it just has a set of
sockets it can deal with we can pull
both you're listening sockets that
you're gonna call except on and well as
well as your connection sockets which
you're going to call read and write on
at the same time and it allows you to
fully dispatch all of that logic and the
way you would want it so it's it's weird
though it would be nice if it were
really logical but everything is always
specific there's all kinds of vendor
quirks and writing a cross-platform
multiplex i/o is very very very very
hard
it requires use of the the evil tree
Ohio control set sock it up and whatever
and it's not especially portable in
theory it goes about like this I've only
got four minutes I'm gonna go a little
fast now basically you establish your
your set with just the listener socket
and then you keep pulling and every time
your listener socket is ready you'll
just call except to pull something off
of it and then if connection socket is
ready you'll read from it and write from
it in practice that's really hard to do
but we don't have to do it here's the
cool thing
libuv the nodejs event loop is a sea
library that anyone can equate to not
just node it's got excellent
cross-platform support great for single
threads or single processes which is
great because Scala native doesn't have
threads yet it'll run on e-poll in the
backend it has a sort of famous callback
api kind of like nodejs but also a lot
more restricted not at least restricted
cuz it's in c so you have to manage
memory and malloc a nand freeing across
asynchronous callbacks is a little scary
let's be real here also they're their
icon is a unicorn Velociraptor I love it
so like I said I can't go file have to
go fast here but the Scala native is
great at just binding like an external
library and linking to it at linked UV
pretty cool and doing this in your own
program right this doesn't require like
access to the library or recompiling
anything you can just build this into
your program so the cool thing is I
think it handles function pointers
really elegantly especially compared to
like see like if you ask me to sit down
and write the signature of a C program
that takes a function pointer as an
argument I swear
I could work on it for days and not get
it right and this is so much more
readable honestly and again I have to go
fast but the basic idea is you just set
up your loop you call your pipe you
create a pipe handle we're gonna use a
UNIX socket here just for just for for
speed we call listen on it and then we
tell it hey every time you listen caulk
this connect callback and this connect
callback says hey every time you get a
connection in will initialize a new pipe
and then we'll just call accept on it
and then once we've accepted it we can
say hey every time there's something to
read allocate memory with this callback
and then call the read callback so all
the the meet this is all like boiler
plate all the meat of it is in the read
callback which just looks like this and
I'm happy to talk about this after but I
think I have to keep moving but
basically you're just parsing out all of
those you're just looping and parsing
over fast cgi headers and then deciding
when to respond how does it run let's
find out so I've been using Gatling for
this and yeah how's that that's is that
somewhat better
okay so gatlings Scala based load
testing tool uses akka HTTP under the
hood really good at hitting things about
as hard as you can this isn't that hard
this is 500 users and 25,000 requests
with a one-second ramp time so we'll see
how it goes BAM so that cleared 4166
requests per second mean response time
of 80 that's kind of weird
56 milliseconds on the median and a nice
low error rate of one that's way under
1% so cool right for I've seen that down
at four milliseconds I think there's
some Network weirdness here but if you
crank that up to a thousand users the
meaner spots goes up maybe to like 140
milliseconds the error rates are about
half
of nodes and you don't get any timeouts
to the extent that it does start
dropping connections it drops them very
fast which is exactly what you want in
this kind of case tah-dah
so yeah I was I was sort of surprised
that this worked so well and yeah it's
exciting so this is the part of the talk
where I trail off which is great because
I'm at exactly 40 minutes but yeah this
make just working on this for a couple
months made me think a lot about well
what do our languages need to give us do
we need a giant like Java development
kit to get things done and like granted
there's going to be some hard things
like try bringing in an XML parser to
something like this but I think those
are also surmountable probably it makes
you think hard about whether HTTP is
something that belongs in your app it
belongs in your infrastructure in
particular like if you're running in a
modern managed cluster like kubernetes
or something where you have any number
of multiple layers of like internal and
external proxies going maybe HTTP is a
performance task we're paying and maybe
we don't need it anymore
especially now that docker makes it easy
to like bundle engine X in with as an
application server for local development
and yeah I feel like things are changing
I feel like there's so many exciting and
new things happening with this and I
hope I've given you some idea of how
Scala native is is a part of it and
that's the top thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>