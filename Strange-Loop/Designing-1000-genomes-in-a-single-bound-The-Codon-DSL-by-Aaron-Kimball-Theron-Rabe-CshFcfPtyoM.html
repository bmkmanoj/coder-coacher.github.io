<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Designing 1000 genomes in a single bound: The Codon DSL&quot; by Aaron Kimball, Theron Rabe | Coder Coacher - Coaching Coders</title><meta content="&quot;Designing 1000 genomes in a single bound: The Codon DSL&quot; by Aaron Kimball, Theron Rabe - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Designing 1000 genomes in a single bound: The Codon DSL&quot; by Aaron Kimball, Theron Rabe</b></h2><h5 class="post__date">2017-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CshFcfPtyoM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody my name is Aaron
Kimball and I'm fair and Raby and today
we are going to talk to you about code
on a system that we built at Zamora gin
in order to help our scientific staff
design experiments involving large
collections of genetic engineering
experiments this talk is divided into
five parts first we're going to talk
about what it is that we do at zymogen
and then I'm going to give you a brief
biology lesson this is going to help
explain some of the key terminology that
we need in order to understand the rest
of this talk and the motivation for some
of the specific challenges that we face
then we're going to talk specifically
about how the problem of microbiology
experimentation affects us in software
engineering at zymogen it's like what
solution we delivered and then evaluate
it to understand how well it did and
what we could do better in a future
version so let's start with what it is
that we exactly do ads I merge in it
design region is in the industrial
fermentation industry we make microbes
that make chemicals if you saw the
previous talk on biomaterials you might
have seen some aspects of this shown at
industrial fermentation is a technology
that allows micro organisms like yeast
or bacteria to ferment sugar into a wide
variety of chemicals for any number of
purposes some medicines like penicillin
are industrially fermented agricultural
products like fertilizers pesticides
animal nutrition products or chemicals
that apply more towards the industrial
sector like bioplastic microbes can also
be used in more exotic contexts for
example that some microbes can break
down plastic so there can be these
cycles where microbes manufacture
plastic out of sugar and then break it
down on the other side for waste
management purposes of course if you
want this to happen that means that you
have to induce a microbe to actually
produce the chemical you want and this
is a very complicated problem because
the way that you control a microbe or
any organism it's through its DNA and
DNA is a very large search space if you
think about what's considered a hard
problem in a iron machine-learning such
as playing games like chess or go these
involve computing on the order of
10 to the 100 to 10 to the 300 possible
moves that that need to be evaluated or
pruned against in biology we have so
many orders of magnitude more of free
space to work with if you think about a
genome at just the gene level where it's
large blocks of DNA that you are
manipulating you have between 10 to the
five thousand and ten to the twenty five
thousand different opportunities at play
depending on the complexity of the
organism and then if you look at the DNA
at the base pair level the individual
AGC T's in the string we're talking four
to the three million to four to the
three billion possible changes that can
be performed so this is a problem that
requires that we focus very effectively
if we're going to actually find needles
in this haystack that are going to make
changes that help the organism do the
things that we want to do as I'm region
we have two pieces of technology that
help us perform this search more
effectively than other organizations
that have come before first we
exclusively use robot automation to
manufacture and test genomes within
microbes a lot of organizations create
microbes or create genetic changes by
hand using pipettes and this allows a
human scientist to test on the order of
say a dozen theories per month we can
perform 100 to 1,000 engineering
experiments per cycle and we can start
cycles very frequently so this allows us
to have broader coverage of the search
space we also use what we call an a
theoretic approach we are less concerned
with the particular mechanism of action
by which a given genetic change actually
causes the change in the phenotype for
the trait and we're more concerned with
the fact that it simply works and so we
run a search algorithm effectively by
scanning the genome finding areas where
there seems to be a mechanistic link and
then we optimize in that area to get the
best possible linkage outcome for the
goal of our experiment and so by using
machine learning and these kinds of
tools to guide our experimentation
process this allows for the design of
hundreds or thousands of different
genomes at a time which we can then plug
into our
experimentation system or our factory so
now let's go one level deeper and
understand just a little bit about the
biology that motivates how these kinds
of experiments work and for anybody in
the audience who actually knows biology
I apologize I'm a computer scientist and
this is a very high level overview that
is just intended to introduce the key
terms in a simple way so I mentioned
that design region performs industrial
fermentation experiments industrial
fermentation works very similarly to the
fermentation that you all know and love
that makes beer and wine you take a
large vessel fill it with water add some
yeast or a different microorganism add
some sugar for fuel and then wait a
while in beer fermentation the yeast
will consume the sugar and emit alcohol
as well as perhaps other trace compounds
that add to a unique flavor profile and
in industrial fermentation it's
producing a chemical that maybe isn't
alcohol and we can produce as I said
earlier hundreds of different chemicals
depending on the particular metabolism
of the microorganism in question one key
difference between beer fermentation and
industrial fermentation is the scale at
which this operates if you're making a
homebrew situation you are perhaps
working in five to fifty gallons of beer
at a time and an industrial brewer might
produce a vat of 5,000 gallons at a time
industrial fermentation of chemicals
operates at the hundred thousand gallon
scale or above so we are talking about
absolutely massive fermenters and at
that point the economics of what you're
making are very important a lot of these
chemicals are pure commodities which
means that they're sold with relatively
low margins so there are some economic
factors about the microbe that have to
be true beyond simply making some
quantity of the chemical you care about
first you have to convert a high
percentage of the sugar into the target
chemical and produce as little waste
chemicals or other chemicals as possible
because that's wasted input and you're
going to have to spend more effort
separating those chemicals out the other
side the microbe also needs to have a
healthy appetite you want it to digest
sugar hungrily
and with continuous throughput as
opposed to sort of nibbling at the
feedstock and finally we would like the
microbe to survive in a high
concentration of the output
dear fermentation switches off between
five and ten percent because the
microbes effectively poisoned themselves
with the alcohol they can't tolerate a
high alcohol environment so the more of
your output chemical concentration that
your microbe can tolerate the longer you
can let a fermentation process run
before you have to flush out the tank
and sort of refill it and start all over
again which takes time so successful
industrial fermentation projects require
convincing the microbe to make the
chemical you care about and then
successively optimizing these phenotypes
or traits until it reaches the economic
performance levels that you need and so
this involves a process that we call
microbial engineering and microbial
engineering we have many successive
rounds of directed evolution we start
with some best current microbe and then
we manufacture a collection of child
microbes that each have one or more
small genetic changes in various
locations that we hope will cause a
change in the phenotypes of interest and
there's a number of different techniques
that we can use to manufacture these
kinds of changes first we could meant we
could mutate a single base pair this is
called a single nucleotide polymorphism
or a snip and changing a single a to a t
or a single G to a C can sometimes have
outsized effects on the actual observed
behavior of the organism we could also
perform more radical changes by changing
larger sections of the genome such as
some of the regulatory machinery of the
genome that is not the genes we can swap
in and out different sections there and
we could also remove a gene entirely
doing so is called creating a knockout
organism and so this can be used to shut
off a behavior that we don't want like
manufacturing some other chemical as a
waste product and finally we can insert
one or more genes at a time this can
involve a very large insert of you know
five or ten thousand bases at a time or
more and this will perform a more
radical change by basically installing a
feature in a microbe so frequently this
last technique is the one you use first
you sort of install the genes that
manufacture the chemical you want and
then successive rounds of evolution work
on controlling the rest of the genome to
improve
it's performance all of this is done in
a three-step manufacturing process first
we build short snippets of DNA that are
going to perform the change then we
build the micro by introducing that DNA
into the microbe and letting the change
happen and then we want to test for my
curb we want to actually see if this
does what we think it will do so here's
a very high-level simplified version of
how we perform these three steps the
first step is building the DNA so for
this example let's think about creating
a snip where we change the G above that
arrow into a see below that arrow which
is highlighted in red so we're going to
create a bunch of DNA parts the first of
these parts is the actual change
cassette that we want to insert which in
this case is just the letter C then we
need to create what are called homology
arms homology arms are regions that are
to the left and to the right of the
insert that match exactly the DNA of the
underlying organism the homology arms in
a real experiment would be between
twenty-five and a hundred bases long and
it's actually a software optimization
problem to find optimal length homology
arms that meet criteria for certain
process conditions that are encountered
when performing the change then we
concatenate these homology arms and the
insertion together along with another
piece of DNA that is not particularly
ver this insertion payload into the cell
and the rest of it is looped on to the
backbone on both sides this is
single-stranded DNA not the double helix
that you think about perhaps in sort of
a classic biology textbook picture and
this circular DNA this a single strand a
piece of DNA is going to turn into a
circle and loop at both ends where
there's no well-defined start or end
point and this is an item that we call a
plasmid the key takeaway is that in
addition to creating the particular
piece of DNA we want to insert we also
create other pieces of DNA in this
process that are necessary to perform
the mechanistic action of the insertion
and these are particular to the
experiment so then in the second step
building them
microbe we insert the plasmid into the
cell so at the bottom of the screen we
could see a cell within blue our main
DNA genome floating around in there and
our plasmid is also floating around in
there and I've helpfully aligned for
illustrative purposes that the homology
regions of the plasmid are directly on
top of the same regions within the cells
own genome as the cell begins to
replicate a protein is going to move
along the DNA strand to produce another
copy of this DNA but because the
homology regions of our insertion
matched the DNA exactly it's possible
for this protein to sort of skip on to
our plasmid this is something called
crossover and so then when we finished
replicating the genome the replicated
genome might have traveled along that
plasmid path and now we have our new
change in place of the original DNA that
was in that location the G has changed
into a C in the second cell we can then
cultivate a colony of these cells and
move them into the test process and the
test process we perform industrial
fermentation by either taking at
small-scale something called a plate
which is about a index card sized piece
of plastic with 96 small wells in it
that can be filled with liquid or we can
work in a larger bioreactor which is the
vessel shown on the right bio reactors
are anywhere from a leader to five
gallons and they offer a more precise
test but they are slower and more
expensive to run and they take up more
bench space so you can't run as many
distinct microbe variants in bio
reactors and the basic process is the
same in either we put sugar and water
into the cell a lot into the well along
with the cells and then after a
predefined period of time we measure the
concentration of the output chemical and
compare it to our benchmark strain to
see if we've beaten the benchmark and
then whichever is the best cell from
here we then take and bring into the
next round of genetic engineering so
given this context that Erin described
of a factory scale wet lab which we call
simply the factory and in a theoretic
approach to using it we like to think of
our experiments as these
search spaces of DNA designs our factory
then can directed li explore those
search spaces looking for certain
optimized phenotypes as it goes in a
high-throughput parallel fashion
this however leaves us with a bit of a
shortcoming in the existing tools for
designing DNA most of these existing
tools really focus on building single
designs at a time search spaces of size
one if you will this problem kind of it
reinforces the idea that a scientist
will be making a single hypothesis at a
time and then testing it with that one
change then going back and trying again
so we have a need to overcome this and
design very large search spaces in very
little time and space so this talk will
now kind of shift to how we solved this
problem that problem more concisely put
is how do we direct the factory to
perform the work necessary to carry out
some abstract experiment design well in
claiming that we can do this there are
kind of three implications that go along
with that we can break this problem into
saying well for one there must be some
way that we can take this very abstract
notion of an experiment and put it into
some data type this is a claim in itself
because our experiments are potentially
very complex they potentially vary quite
a bit from one experiment to the next
and any given experiment it might change
a lot in the future we don't necessarily
know what the logic behind some next
experiment might be - there's a language
that scientists used to describe their
experiments to one another there must be
some way to take that language and turn
it into that data type that represents
the experiment formally and third given
this data type and a means of turning
experiments into that type there must be
some way that we can direct the factory
to explore any search space of that type
so for this problem in three parts we
have a solution in three parts made up
of a core data model a tool we call code
on and a tool we call helix they come
together under a common approach of
thinking of this microbiology jargon
that scientists use to communicate to
each other as if it is a programming
language and that programming language
is target platform is our Factory
so in much the same way that the
programming languages you're accustomed
to turn your abstract ideas for
computations into instructions for a CPU
we can do the same thing by turning
these microbiology terms into
instructions for the factory so for part
one of those three problems we have a
collection of core data models that look
very similar to an abstract syntax tree
from a programming language to turn that
microbiology speak into that data model
we have a tool called a codon which is a
domain-specific language that parses and
partially evaluates that language in to
that data model
and third is helix which is a tool that
in much the same way a programming
language evaluates its ast s takes our
experiments and evaluates them into
instructions for our factory looking at
our DNA data model so this is what is
ultimately the output of our codon tool
we have two primary types we're looking
at the first and simpler of which is a
DNA component which represents simply a
DNA sequence and some information about
that sequence our second is what we call
a DNA specification which represents a
search space over those DNA components
something good to understand about DNA
itself is that we actually for the most
part don't have any clue about what most
of it means given any sequence of a C's
T's and G's here there might be a long
sequence of base pairs that we don't
know anything about until we get to just
that little bit that we think all right
we have a pretty good idea of what this
does so for those regions we label them
with annotations so an example here in
green we might say well this region of
the DNA is what we call a promoter it
basically controls the thing that comes
after it like a volume knob and in blue
we have a gene since these are generally
pretty sparse between each other we
often represent them as a solid line
with colored boxes strung along it to
just kind of show hey these are the
parts we know the rest of it don't worry
so much about each of these annotations
has a type to kind of tell us this is
what it's what we think it does it has a
name and perhaps some other static
properties around it as well so a DNA
component then is this idea of a single
sequence of DNA along with all of the
annotations we have for that sequence we
have our DNA components compatible with
kind of the common formats for storing
DNA GenBank and s ball for example and
DNA specifications then are the search
spaces over those DNA components they
model these search spaces like I said
earlier in much the same way that an
abstract syntax tree is modeled in your
programming language we start with sets
of DNA components small search spaces
and we connect them into bigger search
spaces as nested trees of functions some
examples might be concatenate which much
like a string concatenation takes two
sequences of DNA and sticks them
together they can hold other static
properties much like the DNA components
as well to give you a more kind of
end-to-end view of this data model we
can start with a DNA component here it
has a couple annotations that we find
interesting that DNA component might be
combined with a few other DNA compose
into a set of DNA components which is in
itself a very small search space of
course if we asked our scientists to
actually list every DNA sequence in a
search space we would be turning our
scientists into data entry so what we
want to do is represent these very large
sets as functions over smaller sets and
that's how we use a DNA specification so
this DNA specification has two small
sets and it connects them by
concatenation saying we have a large
search space that is made up of all the
concatenations of these two smaller
search spaces actually creating a DNA
specification data structure by hand
would be a complicated challenge for
programmers to do there's a lot of
tedium involved in setting all the
different properties as well as
constructing all of the nested
structures within these objects so we
want a convenient mechanism to allow
people to encode these DNA
specifications and that's where the
codon language comes in codon is a
domain-specific language we implemented
in Scala for parsing and partially
evaluating biologists lingo into DNA
specifications it is a procedural syntax
so more complicated search spaces or
more complicated expressions are built
up hierarchically out of simpler search
space expressions that came before it
the function library in codon is
tailored to the language that biologists
use and it has a wide range of
abstraction at the one extreme you can
use code on to describe creating a knock
out or performing other annotation level
changes to the underlying DNA in the
sets and at the other end we can treat
DNA like a string sequence and perform
snip changes and other manipulations of
the DNA directly so this allows for a
great degree of flexibility in the kinds
of experiments that can be described
with the language a key goal between
codon and the next tool helix that comes
after it is separating the what to do of
an experiment from the how to do it so
encode on scientists describe the target
DNA sequences they want to manufacture
and the next tool
then calculates what does the factory
need in terms of DNA parts to actually
perform that manufacturing operation to
give a motivating example of how codon
works let's talk about a kind of change
called promoter swapping a sterile
unmentioned a promoter is kind of a
volume knob that changes the expression
level of the gene that follows it
so a weaker or a stronger promoter can
have a weaker or stronger phenotype
response from a particular gene so here
on our DNA sequence we've got two genes
of interest yfg one and two your
favorite gene here is what that stands
for
and there are promoters ahead of each of
these genes and something else called a
terminator that follows it so in our
experiment suppose we had a library of 3
promoters of known calibrated strength
we might want to try each of these
promoters in front of these collection
of genes of interest so here we can run
a compound X expression where first
within a host strain we locate the genes
that match the expression Y FG star with
their name and we also have a promoter
library held in the variable promoters
and we can run the replace promoter
function on the located genes with these
promoters which will give us a
combinatorial set of all possible
combinations of these promoters and
genes the X in brackets next to the word
replace promoter means that we should be
doing this in a cross product format so
for each promoter and for each gene
generate an output there's also a dot
product mode where the sets have to be
the same size and they evaluate pairwise
so here we can see in our example
outputs four of six possible outputs are
shown and each of P 1 through P 3 prime
are ahead of yfg 1 in the first three
versions where Y fgq is held constant
and then in the fourth example p1 Prime
starts moving in front of yfg 2 and the
original promoter is left in front of Y
FG 1 so now we have in a linear way
expressed a cut a quadratic size search
space which is a more compact
representation and more flexible so
downstream from this codon tool we need
a tool that takes in those DNA
specifications and make sense of what to
do with them we call this tool helix and
in much the same way some programming
language might evaluate its ast we use
term rewriting as in abstract semantics
framework for evaluating in a sense
these DNA specifications to create the
both the entire search space we need as
well as evaluating under some different
contexts which I'll explain in a moment
just a quick review on term rewriting
it's it's pretty intuitive you probably
use it all the time without really
thinking about it you learned it in
algebra class with maybe an expression
like x equals 1 times 2 plus 3 times 4
we can search for terms within that
greater term and rewrite them in a sim
as simpler term so for instance if we
look at 1 times 2 well we can change
that into just 2 as we progressively go
through this term rewriting it
eventually we end up with x equals 14
which is equivalent to the original
expression but much simpler to work with
the way your programming language might
model this is much like DNA
specifications as a tree of functions
with the operands as the leaves so for
our expression here we end up with a
tree that looks like this and to perform
that rewrite we can traverse down this
tree looking for at the bottom we have 1
&amp;amp; 2 as op the first operands we might
Traverse to those can't be rewritten
they're very simple but the node above
them that multiplication can easily be
written as 2 doing the same thing on the
right side we have 2 plus 12 and
eventually 14 so we can look at our DNA
specifications under much the same light
we have a nested tree of functions in
this case two concatenations at the
leaves we have not just simple operands
but sets of DNA components as we
Traverse down this tree we reach the
nested concatenation which we can
rewrite as this larger search space and
again at the top level we now have a
fully reified search space despite no
scientist ever having to
actually list all those out it's a
little bit more complicated than that
though
so as Aaron described earlier
concatenated DNA isn't as simple as just
saying well these are the sequences
let's stick them together we need these
home homology arms so in this sense
there's another context of evaluation
and this is what we gain from viewing
this as an abstract term rewriting
system is we can implement these new
context reusing most of our code so we
might Traverse down the tree as usual
but under this green context we're not
simply applying that concatenation
function we need to apply a function of
that function basically that spits out
the homology arms that we need for that
particular operation to actually take
place in the factory so here we can omit
the homology arms perform our usual
rewrite as in the evaluation step come
back up to the top do the same thing and
in the end we're left with both a fully
reified search space and under any
number of other contexts for example
homology arm calculation we can have the
full set of all of those evaluated
contacts so at this point we've kind of
shown you from beginning to end a high
overview of how this whole system works
and we kind of like to shift the talk
now to maybe what we could have done
better in lessons we learned along the
way so how does this how does this tool
work first codon is an effective tool
for our scientists they use it every day
to create new collections of experiments
to run and I haven't actually tallied up
how many strains have been designed
through this tool but it's certainly
well above the tens of thousands so
while it is a tool that achieves its
direct objective it's not without its
own problems and we've learned a number
of lessons which are not just particular
to codon but we think are hopefully
helpful advice to help you from falling
into some of the same mistakes the
unfortunate conclusion for the language
buffs and the audience who came to see
this talk is that creating our own DSL
may have been overkill the core feature
that is really
portant of code on is the library of
functions that operate in terms of
biologists understand and creating our
own syntax around that was intended to
solve other problems but again created
more problems of its own and perhaps a
library was more effective so what
exactly are these problems that we
encountered the first one of these is a
problem of code trust search spaces are
complicated and we can't predict what
search spaces scientists will dream up
in the future so we need a sort of
general purpose mechanism for them to
express them thus code but we don't
actually want scientists to paste Python
code into our limbs and then call it
with eval because that would be crazy
so our system needs to safely handle
user specified code somehow so this is
one of the main motivations for the
sandboxed code on runtime we've got our
own syntax that we can then completely
control the sort of VM where that code
gets executed our VM also has other
language features that make it safe for
example strict static typing strong
normalizations there's no unbounded
while loops as well as transactionality
so if the code on script has an error in
it we don't commit half of a search
space into our limbs instead the
scientists simply gets the error message
and nothing gets committed or if it runs
successfully a whole search space is
created at once our language also did
not allow user-defined functions which
is its own sort of half pro and half con
but the main lesson here is that if you
take a step back we're sort of solving
two problems with with one solution we
have a problem of how do we do the work
how do we empower the scientists to
create these search spaces and then
there's another problem of how does this
solution stay safe in the context of a
shared user environment and there are
good tools for accomplishing each of
these distinct tasks separately for
example in the safety front we could
have invested more effort into DevOps up
front and offered users either sandbox
virtual machines that are personal or
docker environments or some other
isolated context and then within there
you know allowed them to use a different
programming language there are a few
tools out there that will actually
successfully solve both of these
problems Google's App Engine is sort of
it's a specific example where this did
have
but they effectively rewrote the Python
runtime entirely in order to facilitate
this which is a larger undertaking than
we can do so the main lesson for this is
take a step back and think about not
just what your total problem is but how
to decompose it in two parts and then
try to develop tools only to solve the
most narrow problems associated with
your use case the next problem we ran
into is what we've called the simplified
interface problem this comes up because
DNA specifications are kind of complex
and we have downstream systems from them
that really don't need to care about
that complexity so we thought a nice way
to kind of simplify the DNA
specification at that code boundary is
to make it pretend to be a lazily
generated list that can generate each
element of its entire search space as
desired so in a local scope a private
scope DNA specifications are treated as
these trees of functions like I
explained but to the public scope it
looks like it's just a list that like I
said is just kind of created on demand
this brought some problems with it
though so at the time this was this
solution was decided on all of the
functions we were supporting were
functions like concatenate we're given
two input sets any combination of
elements from those sets could one by
one be iteratively performed but
eventually not all functions fit that
type so kind of the lesson we learned
here is if your business logic is so
complex unpredictable and varied from in
our case one experiment to the next that
functions themselves have become a
citizen of your data model be really
careful about limiting the types of
functions that can be there because any
limitations you claim over the types of
those functions are likely to be
implicitly or even accidentally encoded
into the downstream systems so in our
case
we turn to us a tree a rich structure
into a flat list
we lost structural information thus
limiting the types of our functions and
we would have been better off just not
losing that structural information at a
code boundary another problem that came
with creating a scripting language is a
learning curve problem some users really
don't want to learn a new scripting
language our scientific staff ranges in
by in software expertise from people who
really dive in and do a lot of work in
Python and are in other languages and
then other scientists who tend to shy
much more away from that and prefer to
use GUI tools for example so even though
we've created a perfectly useful user
guide that all of them read very
thoroughly there were still some
challenges getting adoption in certain
corners so we created what we called the
codon cookbook which was a wiki page
with short template scripts that would
accomplish the dozen most common genetic
engineering tasks and set up experiments
like they want for it for these kinds of
tasks and these cookbook scripts have
had some variables at the top that you
could sort of switch in and out some
parameters to accomplish what you wanted
even this however wasn't necessarily
user-friendly enough for certain use
cases especially once experiments got
even a little bit more complicated than
what the cookbook could accomplish and
so we wound up adding retooling
functions that could parse in CSVs
into a code on script and then process
it to generate the search space however
you can imagine that the CSV functions
and the manipulations and data that you
could perform in our new language we're
not necessarily as rich as those you
could perform in a more general-purpose
language and so the lesson that we took
away from this is that it gets really
clumsy to provide retooling within your
own system empowering users to do
retooling sort of outside the scope of
the system you develop makes this much
easier for example existing programming
languages allow you to combine sort of
arbitrarily many libraries to accomplish
your solution so if your dsl needs its
own utility libraries perhaps reconsider
the approach that you're taking dual to
this learning curve problem is what we
call the super user problem so on one
end of the spectrum we have users who
don't
really haven't taken the time to really
dive into the depths of what to learn
but on the other end we have users who
have learned it so well that they can
help out the other users so in this case
we had one super user who wrote a single
code on script that was a generalization
of every possible code on script it
takes CSV inputs of course but nobody
wants to write out CSVs full of data so
they wrote Python functions for
generating those CSV inputs this leaves
us overall with a comically long
mechanism of machines that begins in
Python outputs a CSV file which goes
into a codon template script which
together go into the code on runtime
producing a DNA specification that then
is evaluated in helix which by the way
is implemented in Python we've
effectively built a Rube Goldberg
machine the solution we suppose might be
best at this point is to actually retire
codon in favor of a Python library some
lessons from this that I think are
pretty valuable are if you create a
language users will learn to abuse it as
quickly as they learn to use it and
that's not a bad thing in itself that is
something that rather than trying to
avoid you should just accept and prepare
for we learned that great parts don't
necessarily combine into great machines
every step of that that comical Rube
Goldberg machine itself seems really
good but when you chain it end-to-end it
doesn't quite make sense as a unified
system so overall if you're thinking of
approaching your problem as a
domain-specific language it might be a
good idea to first implement it as a
library in some subset of a well-known
general-purpose language work out all
the kinks over time and eventually if
you still need a custom syntax over it
just add a thin layer of syntax rather
than giving it its whole own run
as a language from the get-go so for
conclusions from this whole talk
we built code on its a DSL for
specifying and designing new organisms
overall this idea of treating
microbiology as if it is a formal
language actually appears quite
tractable and rather effective from the
level of abstract syntax tree down to
our Factory however just because we're
using abstract syntax trees as our data
model doesn't necessarily imply that we
should treat the syntax itself and the
way it's that syntax is turned into our
data model as if that itself is a
language so overall we've learned a lot
of lessons from this code on project and
hopefully this has been a chance for us
to share those out with you whatever
link for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>