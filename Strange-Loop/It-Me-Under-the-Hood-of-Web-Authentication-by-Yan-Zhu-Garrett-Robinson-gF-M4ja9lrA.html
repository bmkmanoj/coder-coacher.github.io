<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;&quot;It Me&quot;: Under the Hood of Web Authentication&quot; by Yan Zhu, Garrett Robinson | Coder Coacher - Coaching Coders</title><meta content="&quot;&quot;It Me&quot;: Under the Hood of Web Authentication&quot; by Yan Zhu, Garrett Robinson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;&quot;It Me&quot;: Under the Hood of Web Authentication&quot; by Yan Zhu, Garrett Robinson</b></h2><h5 class="post__date">2017-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gF-M4ja9lrA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey everyone so my name is Yan and this
is Garrett today we are going to be
talking about web authentication you
might think why box dedication seems
like a perfectly solved problem because
most likely when you have to
authenticate users to your web app you
just download some library and plug it
in and you're good to go
however today we're gonna look deeper
into some of those libraries and see
some potential bugs and problems that
might not be obvious at first glance the
first one we'll take a quick look at is
a node so how many people here use node
most hands right so I picked this
because we use it a lot where I work and
I've never specifically used passport
but people tell me it's one of the most
common node off libraries as you can see
about 36 thousand downloads a day it's
open source the way it works is it has
these authentication strategies right
not everyone uses username plus password
a lot of people want to use OAuth but
username and password is what we'll
focus on today because it's easy to
understand and it's still commonly used
so that's provided and a separate module
by passport local and the color of this
must provide their own password password
verification callback however passport
local gives you an example of what a
passed a password verification functions
should look like and it's pretty short
and simple so it's just checking if the
password in the database is the same as
the password that the user gave you
sounds good not really
okay there's something wrong here why
are you comparing plaintext password
passwords right something you probably
learned a long time ago is that your
server should never be storing user
passwords in plain text because then if
your database gets compromised somehow
all of your past all of your accounts
are hacked easily
so instead what you should do is store
these passwords as a salted hash and
that's that's widely known but a less a
more subtle problem with the function we
just saw is that it's not a timing safe
string comparison and we'll go into what
that means a little bit later so that
was kind of a toy example but this
happens in real life a lot to people get
hacked even where the when there are
large companies like Adobe so in 2013
some people may remember this there were
about 38 million active Adobe accounts
that were compromised and the entire
database of passwords was posted online
and anyone could just download it this
was only the third largest password
breach that year and okay so how got the
password database but the passwords must
be salted and hashed right right now
they were encrypted how is about as good
as salting in hashing well so encryption
is not the same as hashing most
importantly encryption is an invertible
function so if you have the secret key
and you have the ciphertext you can
invert the encryption function that's
what we usually call decryption and get
back to the plaintext by hashing is a
one-way function there's no information
you can get that easily allows you to
get from the hash output back to the
input so if you're given all the hashed
output output the only way you can find
the input is by brute forcing insulting
a hash is this technique to prevent
statistical analysis so that if a bunch
of users have the same password they
don't have the same output in your
database because many users share many
users use the same easy common common
easy to guess passwords but Adobe did
encryption so you actually can do this
kind of frequency analysis and if you
just look at the leaked database which
anyone could download and you sort it by
frequency you see that a single password
string encrypted password which is eq7
etc etc had
about two million users using it so 2
million people were using the same
password you know what would it be
any guesses yeah I want to guess
password but it turns out the password
limit requirement was six so it was one
three three four five six and yeah so so
one point two five percent of users use
this password we already have some good
guess as to what it could be but the
reason I know is one two three four five
six is because the leak contained
password hints available to you in plain
text so Adobe didn't think that you know
they didn't think that users would just
put their password in a password hint so
they're like well we'll encrypt the
password but why would we crypt the
hints there couldn't be anything in
there but it feels like this is
literally just a sample I sort of left
so graphically but this is like the
average password hint our password is
online the password is this some
people's were like this is the same
password I use on Gmail
I use on all my accounts so basically if
you got this it's easy to pivot that
into attacking people's email accounts
and so forth oh xkc how to had a great
commentary about this which is you're
given these hints you're given these
like opaque strings you have to solve
for the WoW what these strings are based
on the hints so this is the greatest
crossword puzzle in the history of the
world pretty much and you know for users
it was a garbage fire you know a lot of
their passwords could have just been
trivially exposed and if you could
somehow get the single encryption key to
to do that Adobe used and you could
decrypt all 150 million passwords
alright but let's assume your users
logged in yeah wrong let's assume that
you are storing passwords securely and
your users logged in as you guys are
probably aware HTTP is a stateless
protocol and so we need some way to
remember that we logged that person in
who they are what their deal is
etc so this is a quick overview it's
probably review for you a lot of you
guys but so typically as a developer you
have some kind of a session abstraction
provided to you by your web framework
and this is usually like a key value
store like a dictionary and you put
arbitrary data into it and then the
framework handles the rest of what I'm
about to talk about so there's two broad
common kinds of web sessions there are
these stateless sessions in which all
the session data is sent to the client
so in Python land which is what I'm
familiar with the flask micro framework
does this by default and if you guys are
more to Java Script and you're using JWT
is JSON web tokens which are apparently
all the rage that's basically the exact
same thing but with some more structure
and some more vulnerabilities there's
also server-side sessions which are you
know very very common where you store
all the data on the server and that
avoids the size limitations of cookies
and then you just send the client a
little session identifier so for example
this is what Django does by default
once so yeah once you have this session
data you included in a response and you
want it to be persisted on the client
the classic way to do this is cookies
that's what they were designed to do and
cookies aren't the greatest you might be
familiar with their bizarre behavior
that intersects with the same origin
policy in a web browser but also doesn't
and has a lot of weird caveats and
exceptions but over time we've kind of
evolved features to add to cookies that
do make them pretty reasonable for
managing sessions so for example there's
this HTTP only flag and what that means
is that javascript in a webpage is not
able to access or modify a cookie via
the document cookie you know access ur
in JavaScript and that's actually a
really good thing because it means that
cross-site scripting attacks can't steal
your session cookies and then reuse them
elsewhere it's also a secure flag which
prevents the browser from sending
cookies over an insecure connection IIE
a non TLS HTTP connection which is also
a really good thing more recently people
are kind of fed up with cookies and want
to use something that's more flexible
and more ergonomic for a developer so
you're using your local storage in your
browser and that's got some benefits it
avoids some of the weirdness of cookies
but it also kind of is a backpedal in
some ways you're vulnerable to XSS you
can use content security policy which is
a access control framework for the
browser that I helped work on at Mozilla
that'll definitely help you and I
recommend that you consider doing that
but there are some trade-offs there they
both have their pluses and minuses that
there's no real clear winner here
great so once you know how you're going
to store it you send that to the client
and then the client persists it and will
send it back to you and subsequent
requests and that's how you maintain
this state over time so one problem with
the sessions is that you might store
data in there that the user has an
interest in modifying maybe you know
Alice has an account on your site she
has some credits and she wants to do
stuff but she thinks she deserves you
know more of a balance to start with
right so if you could just arbitrarily
modify the session data which you could
and like a totally naive implementation
then
all kinds of weird stuff could happen
there's a lot of ways you can try to
avoid this but the really common pattern
is to use message authentication codes
or Macs not laptops cryptographic
instructions but so the basic idea of a
Mac is that you have a message and
that's in this case the serialized
session data and you've got a secret key
K you feed them both into the Mac
algorithm and it outputs this thing
called the Mac tag which is the little
green guy right there
and the Mac algorithm is designed so
that it's difficult cryptographically
difficult to generate a valid mac tag if
you don't know the key K so you transmit
your message plus the tag through the
untrusted environment which is the Dark
Void in between these two brightly
colored pastel squares and then when the
receiver gets the message and the mac
tag they just recompute the mac with the
secret key that they know and compare
the recomputed tag with the received tag
if they match integrity is good to go
you're safe otherwise shenanigans are
afoot this is interesting in the web
context because the sender and the
receiver are actually the same entity
right it's the webserver it sends it
from itself to itself through a round
trip with the client which is maybe a
little confusing to people so one common
gotcha this affects flask which is the
example I'm giving here but it's also a
problem with JW T's is that sessions are
signed but they're not encrypted and
that isn't always a problem you know
it's just like a random session ID it
doesn't really matter if somebody can
read it but in some cases you might
store information in this session that
your users should not be able to read
this is kind of a toy example where you
have a guess the number web F because we
need those and you know basically what
you do is you generate like I know
between 1 and 10 you store it in the
session that's the correct answer
you return to the user and then when
they submit their guests you just
compare what was in the form they
submitted to what was in the session but
because the session was persisted on
their machine and it's not encrypted
they could just look at it and get the
right answer every single time this
actually is a problem that you will see
in various applications I've audited
several applications that do more
complicated things but with the same
basic kind of MIS
conception about how the underlying
abstraction works and it can be a pretty
serious problem Oh another gotcha
appears when you start comparing these
Mac tags that is when you're trying to
verify that the Mac is the expected
value on the server the obvious way is
to use equal equal on two strings as a
string comparison but there's kind of a
subtle problem here which is that this
equal equal function terminates as soon
as there is a prefix mismatch between
the two strings for instance if Mac
starts with a and correct Mac starts
with B then the function says oh these
don't match well obviously the entire
string isn't going to match so we're
just gonna stop here but if they have a
longer prefix in common then the
function will run for a longer time so
the time it takes to run this varies
depending on how similar a and B are so
I'll share these slides later then I
wrote a little demo of this anode so the
reason this can become a problem is when
an attacker can measure the timing they
shouldn't learn any information about
what the secret input is and this is a
pretty common pretty common problem that
people have in their code I actually saw
it in an early version of let's encrypt
which a lot of people use so I did a
little demo which I'm not gonna run live
but basically it it does this password
equal equal expected password function
and at times it and it times it against
every possible expected sorry every
password password every possible
password guess of length 3 and that's
alphabetical so the actual password is
foo and we compare a a a a ba etc and
then we measure the time it takes for
that comparison to finish and indeed
even on this toy very simple piece of
code you can see there's some timing
variation when there's no prefix when
there's no prefix mismatch the when
there's no prefix match it finishes
faster in about 91 nanosecond and all
the way on your right where there's a
full match on the string food
it's about 115 nanoseconds so yeah so
there are clear timing variations and
you can see this even in a language like
JavaScript and you might ask so it's
this kind of timing difference of you
know several nanoseconds measurable over
the network there's a 2007 study that
found that there you can get about 15
100 microsecond accuracy across the
internet and about as good as a hundred
nanoseconds over a local network so
that's about this almost the same order
of magnitude as what I just showed so
there's good evidence these attacks are
practical in some situations just to go
over this how can i attack or abuse this
timing difference if they're trying to
commute force a Mac they let's say the
Mac is in hex encoded so first they can
try 0 0 0 0 then they can try 1 as the
first character then a 2 all the way up
to F so they measured a mark
verification time for each of these
strings and they say well the one that
took the longest probably had a prefix
match so that's probably the correct
first character and so they set that as
the first character then they go on and
repeat this for the second character and
over and over again until they have the
full string and they've brute force the
entire secret so one way to solve this
problem in your code is to do a constant
time comparison this is a common way
I've seen it done and python and node
and other languages basically you loop
through these strings that you're
comparing that's the for loop with the
car code out and you XOR to the two
characters and if they match then there
is 0 if they don't match their 1 and
then you append that to a mismatch
result so basically only if all of them
match is the entire result 0 so that's a
pretty easy way to do that and so in
node someone pointed out 2015 or 2016
that they weren't doing timings safe
equality chucks so no it actually
recently added this API crypto timing
safe equal so you can just plug it in to
your code and I did that on my boy code
from earlier and as you can see my code
is slower about by about an order of
magnitude but things are not running in
a way that you know reveals my secret or
at least not obviously so so constant
time comparison the security researcher
Brad hill has this quote where he says
it's good for native code but in
high-level languages there are some
problems so he found that source code
which looks like it's constant time
doesn't always run that way because the
compiler and runtime optimizers don't
recognize timing as a program semantics
so in other words there's no guarantee
that this supposedly constant time
function will be constant so how do you
solve that well a simple way is to blind
the timing channel so instead of
comparing these two strings directly
apply of pseudo-random functions to the
two strings and then compare the outputs
so by definition the outputs are
uncorrelated to the inputs they're just
random functions of it and so now when
someone tries to measure the timing
they're measuring a timing of a random
string not the timing of the inputs and
so they can't recover that easily so a
common pseudo-random function is each
Mac and you can get that from the node
crypto API easily so basically here I
just H max both of my inputs and compare
those instead and that runs even slower
I like the like the use of an H Mac to
verify an h-back it's kind of like the
yo dog of like refer graphics for
collections I heard you like verifying H
max so I put in H anyway so okay let's
say that you've got these first two
really critical components down you're
storing passwords securely and you're
managing sessions securely you're
checking your H back to the cons time
comparison no timing attacks that's
pretty good there's a lot more that you
could do wrong but this is like a survey
of like some very common things that
people do wrong so unfortunately even if
you as a developer do everything right
here you've audit your libraries you
make sure your own code is secure your
users might still end up being hacked
mostly because users as we saw earlier
are really bad at choosing passwords
they choose weak passwords and they
reuse them across multiple sites all the
time a lot of you guys are technically
savvy so you probably use a password
manager can I get a show hands people
who use password managers Wow Wow
oh my goodness that's almost the entire
room amazing you guys are awesome
but so the actual percentage of people
who use password managers out of the
entire population is very very small I
think you ought to have never run it
later it's it's quite small so password
managers themselves are not a great
solution for the majority of people at
least not yet and they also create their
own trade-offs for security I mean what
if your password manager is compromised
like what if Tavis or MIDI just like
takes an interest in it as happens some
sometimes so what else can we do you
know to protect users even when we know
that there are fallible humans who will
make poor decisions
so multi-factor authentication is the
really common way to solve this this is
probably review for you guys but just a
quick one the idea is to create this
concept of an authentication factor so
there's knowledge factors something you
know like a password possession factors
that's like something you have like a
key or a you Baqi or a phone and
something you are like your fingerprint
for touch ID or your entire face I guess
is the new thing but on the web we don't
really see these in here insane yet
mostly we see a combination of password
and possession factor and there's a huge
variety of designs and trade-offs and
constraints and designing effective
two-factor possession factors so let's
take a look at some common examples can
I get all have hands for people who do
this this kind of you send a code to
your phone when you log into web pages
not as many but a lot of people cool
okay yeah so this is a really common
technique for two-factor authentication
in this case the possession factor is
your your phone your cell phone when you
log into an account like for example I'm
logging into Google after they checked
your password they'll just generate a
one-time password a shortcode send you a
text and then you're supposed to type it
in and that proves that you have your
phone
this is actually like a really common
technique mostly because it's really low
friction like as a user you don't need
to get a new device or install any apps
like you just receive texts and it was
kind of like a lesser appreciated reason
why this is really nice and that it's it
helps you manage the lifecycle of this
two-factor device like a lot of people
lose their phones and they don't have
backups or they migrate their phone and
don't back up all their data but you can
still receive texts on your phone number
which doesn't tend to change that often
so there are some benefits to this but
in general it's really bad there we go
so you guys might remember in August of
last year or June of last year the
activist DeRay McKesson Twitter account
was hacked even though he was using
two-factor authentication the attackers
were able to call up Verizon say that
they were DeRay and asked to port his
number to a SIM card that they
controlled at which point they began to
receive all of his texts including his
one-time passwords more recently we've
been seeing these attacks that exploit
the ss7 routing protocol which is used
to interconnect telecoms and also
handles SMS around the world
so thieves stole money from German banks
in May using this type of exploit and
just last week a security firm
demonstrated a proof of concept where
you can drain someone's coinbase Bitcoin
wallet with the same type of attack so
maybe you have like a really important
online account like you people read it a
lot don't know why what they do and you
want to make sure that people can't like
take it over log into it and do weird
stuff so is there something better than
these SMS one-time passwords well
there's the next step up is kind of
these H macro time-based one-time
passwords you've probably seen these
like little hardware tokens or maybe you
have an app on your phone like Aussie or
Google Authenticator and these are very
simple basically you pre share a
symmetric key a shared secret with the
server and your device so when you're
scanning that QR code at the beginning
that's communicating a random secret key
to your device and then it combines the
secret key and a moving factor so in the
case of HTTP that just
simple counter one two three etc and
with totp you just take the current time
and modulo it and get another simple
counter they're actually almost the same
algorithm but this is really nice mostly
because there's no SMS there's no
transport layer the code is generated on
your device and you type it in so it
avoids a lot of the problems of SMS
one-time passwords and if you have the
option to switch to this it might not be
a bad idea
quick aside it's great if you have the
option to switch to this so you can have
a more secure solution for logging in
than SMS one-time passwords but it's
really important that the software
provider honors that so for Twitter for
example you'd think that after the Dre
hack they would have implemented like
some more secure options than SMS
one-time passwords and if you go to the
settings which I did recently there's an
option that says set up a code generator
app which sounded really promising so I
did and then I logged out and I logged
in again and this is what I got this is
a page that's saying hey we texted you a
one-time password and I was like what so
they do this for usability right like
people complain that the SMS OTPs don't
work when you have no cellular service
like you're on an airplane and that's
true but there's also a really important
security trade-off that this
implementation which always sends you an
SMS no matter what in every context just
doesn't you know fails to achieve so if
anyone here works at Twitter maybe maybe
take a look at this and and in in
general takeaway for everybody is you
know I think it's um
is really good to think about like what
the trade-offs are with these systems
there and there are complicated but when
you can it's really good to give your
users the option to protect themselves
you know I don't think SMS or GPS are
the end of the world they have some
useful side effects useful benefits but
it's good to get people options to step
it up if they feel like they might be at
risk or under threat yeah you may also
but in both these cases you're still
talking about a one-time password type
of a two-factor scheme and these are
always vulnerable to other attacks the
most common one is phishing so
this is a phishing page it looks like a
Google change your password page
although if you it's kind of fuzzy but
in the top left corner you could see
it's actually at login dot logins -
verified comm which I'm pretty sure is
not a Google registered domain name and
so if you were to get taken to the site
you're tricked you would put in your
current password and then after you hit
change password they'll be like hold on
I'm gonna need a two-factor code and so
you get out your phone or open your app
it doesn't matter because it's just a
one-time password the attackers receive
it and then turn around and
man-in-the-middle the login in real time
they get into your account and then
that's that's the end of the story
this actually these are from an account
that was used by the Iranian government
or an attack by the Iranian government
against activists in 2015 which is where
it got my attention the first time so
the good news is that there's been some
really promising developments in this
regard in the past couple of years
anybody here heard of you to f4 security
keys and use them yeah okay okay Oh
interesting a lot of more heard less use
okay yeah that's maybe I can convince
you so this is a really cool standard it
was developed initially internally at
Google and then they created this
industry group called Fido and now it's
being actually kind of reworked an open
group or the w3c in this web
authentication spec so this is a meant
to be like a comprehensive two-factor
design that tries to solve a lot of
these problems at once here's how it
works
so there's kind of like three components
of u2f so already weights a little more
complex than it was before but on the
right you have the relying party and u2f
speak that's the website you're logging
into so Google com
you have the clients which is your
browser and then you have a u2f device
and that's some kind of a secure element
that stores secret data on your behalf
that could be a dedicated hardware token
it could be your phone there's a lot of
options but you'd have to have that role
in the system so at a very high level
it's just a challenge in response
protocol the relying party says I want
to make sure you're really you and then
you prove that you have you know access
to this physical thing so I'll send you
a challenge the client the browser will
relay the challenge to the device which
will sign it with a private
keye an asymmetric private key and then
return the signature of the challenge
back to the relying party who has a copy
of the public key and they just verify
it so if you guys have ever used SSH
with public keys it's very very similar
at a high level to that protocol
challenge and response based on
asymmetric cryptography and signatures
but this actually adds a lot more onto
that very simple idea so the next step
is that the relying party this generates
that challenge and then it sends it to
the client and then the client kind of
extends that with some additional
information the first and the most
important is that it adds the origin of
the request so in that fishing example
that would be log and verify comm or
whatever and so when the user created
this public/private key pair and
associated with their real Google
Account that was Google comm and the u2f
device actually keys it maps these
private keys using the origin so in this
case that earlier attack is totally
foiled there's just no way that the
device will return a valid signature for
the wrong domain and then if you look at
this back they kind of keep layering
these interesting kind of optional ideas
there's too many to talk about here but
one that's kind of cool is that
there's an optional thing called TLS
channel ID which allows you to create a
unique identifier for a TLS connection
between yourself and a server and you
can actually kind of include those in
these assertions these challenges as
well and that means that even if you
have an attacker who is able to obtain a
valid TLS certificate they still won't
be able to man the middle of your
authentication process because it won't
be able to spoof the channel ID yeah the
really cool thing is that while it's
it's a fairly complex protocol the user
experience is still really simple so
they're trying to innovate on both
security and the usability so you have
to have a dedicated thing which is a
little bit of a higher bar than the SMS
one-time passwords but other than that
it's just name and password do a user
action as they're called on the device
it's tapping a button or responding to a
prompt on your phone and then you're
good to go
cool so this has been kind of in the
works for a while and as we heard from
the audience earlier people have been
hearing about it but not people have
been using it and
the reason why is because there's a big
trade-off with u2f which is that in
order for it to work you need buy-in
from three separate constituencies right
like you need these u2f devices to exist
and be readily available and hopefully
cheap you need clients like web browsers
to support the protocol and you need the
relying parties of the websites to add
support for you to F as an option for
authentication so the cool thing is that
today u2f devices are cheap they're
usually about $20 or less and they're
available for Manning a growing variety
of manufacturers Brad Hill that same guy
we mentioned earlier has a really really
great github repository where he's
collecting reviews of these devices so
if you're interested in purchasing one I
would go there first because a lot of
smart security folks are really tearing
these things apart and like trying to
find which are the best the main
problems that remain in this regard are
iOS support for Android there are you
know for example like you can buy a you
Baqi that has Near Field Communication
support and so you can just tap that on
your phone if you have Android and that
totally works to fulfill the u2f
protocol but Apple doesn't make NFC
available to third-party applications so
that's not an option on iOS right now
there are some people working on some
different ideas but that's still a work
in progress in addition there are some
kind of experimental new ideas like
github has this recent thing called soft
u2f it's a software token so when you to
F was designed initially a lot of people
were really into this idea of like
hardware hardware hardware like keep the
key in the hardware it'll be totally
safe from every possible attacker and
from malware but for a lot of people
like that isn't really there their
concern that isn't the kind of adversary
they're worried about they can still
realize a lot of the benefits of u2f by
running it in software and so soft you
have stores the keys and you're like Mac
OS keychain but is really really usable
and easy to set up so that's kind of a
cool thing take a look at its new
projects work in progress as for the
clients chrome has had support for a
long time because it was developed
in-house at Google but also news just
last week Firefox nightly landed native
support for you to F finally
which is great and so that'll hopefully
make it to the stable release in about
six weeks and when it does I think about
80% of web browsers worldwide will have
support for you to F which is pretty
great
finally websites there's been kind of a
parade of like big websites rolling out
uqf as the good word spreads and you can
see a full list at this dongle off info
very humorously named web site but a
great web site awesome awesome work and
it's supported by a lot of big sites
like Google Facebook github etc and I
would just say that if you are working
on your own authentication and you're
protecting sensitive user data maybe
consider adding it as an option to your
own site so finally I wanted to talk
about some password lists login systems
because whoa these things Garret talks
about are really nice they're kind of
all addressing very fundamental
weaknesses and password systems it's no
surprise that passwords are kind of
unusable for the average people there's
all these problems like people forget
them or lose them they pick weak
passwords they pick weak passwords and
then they reuse them on 20 different
accounts and password databases are easy
- well they get hacked a lot let's just
say that and only about 5% well unlike
this room which is not a representative
sample only about 5% of of Americans use
a password manager as their primary way
to save passwords most people in this
survey said they just memorize them or
wrote them down or something or just use
the same one on all sites so we can make
some observations which is that Garrett
talked about all these ways you could do
two factors such as SMS and a related
method is the verify log and push
notification that you may have seen on
Google or Facebook where Google says oh
you're trying to log in on your computer
we're gonna send you a verified
notification to your Gmail app on your
phone and you tap that to log in so
that's another form of 2fa and both of
these are much
more convenient for most people than
remembering and typing and passwords and
also given multiple ways of
authenticating users don't usually pick
two factors right they only start up one
of them so some people have been
thinking like why don't we just use what
we've traditionally used as the second
factor as the primary way for people to
log in what does that look like
so actually in 2015
yahoo mail tried this they had a system
called account key where each time you
sign in you receive a push notification
on your mobile phone in the Yahoo app
for you to approve and then once you do
that you'll be signed in immediately so
in the user flow like the password input
box was just gone completely this kind
of makes sense for Yahoo because they've
had a number of password breaches in the
past and this and you know their users
don't always pick the best passwords etc
so and they all don't usually set up two
factors so in their case like you could
strongly argue that the second factor
push verification is stronger than a
primary factor which is passwords so if
people are only gonna pick one factor
pick the stronger one and just offer
that to them that's their way to sign-in
so look like this you put in your user
name on yahoo mail it sends you an
account key and it just says are you
trying to sign in tap yes and you're
done so it's just proof of
authentication by possession instead of
passwords so there's a service called
auth0 that does this but they own for
mobile they only offer as well they
offer SMS and email but they don't offer
push notifications so if you're using
something like this just keep in mind
SMS is easy to hack like Garrett said
earlier I wouldn't recommend using SMS
is the only authentication factor
there's another thing that's kind of
weird about password login systems that
you may have noticed which is that
they're about only as secure as your
email account because if someone doesn't
have your password but they do have
access to your email they can go to a
slot comm and say I forgot my password
send me a reset link and they get the
reset link change your password and they
can log-in forever
and see all your strange loot messages
and so slack actually kind of took this
idea and turned it into a first class
login option which you've probably seen
it's called magic links so if you go to
the this is from the slack web
desktop app and it says it has the
sign-in box and then it has two options
forgot password or is there password too
long to type email me a link amazingly
these are pretty much the same thing if
you click either of these links it sends
you an email the email contains a link
with a long one time use token you click
that the token gets used and you login
by proving you control your email
account and that's a pretty nice user
flow especially if passwords are hard to
type on your phone but keep so a point
here to make is is email secure in
transit so on four websites people are
off well most people are familiar with
HTTPS right like you see the lock icon
you see HTTP colon slash slash that
means they're safe to enter your
password on your banking site or
whatever but emails a bit different it
uses a protocol called start TLS which
under the hood is similar to TLS except
it's opportunistic well what do I mean
by that so the way that mail server is
usually negotiated encryption is like
this the first server is like what's up
second server says I support encryption
the first server says well I also
support encryption so let's have an
encrypted conversation so then they
start encrypting and everything's great
the problem is up until the encryption
happens like all of these messages are
in plain text
so no attacker can do this service one
says what's up server two says I support
encryption but then a man-in-the-middle
attack err pretending to be server one
says actually I don't support encryption
and you know in a secure system the
conversation would just stop at this
point like server two would say I'm not
willing to send my passwords unsecure
that's really bad let's just shut it
down but people really expect their
email to be delivered right like there's
this expectation of reliability when you
send your
email to your boss that it'll get there
so for this reason most email providers
have made the trade-off that they will
send the email anyway even if encryption
is not negotiated so in most cases
server 2 will just say ok yeah here's my
password anyway whatever and that's not
great but the good news is um you know
some start TLS support has been going up
so you know originally some service
didn't even support this opportunistic
encryption and around 2014-2015 that
started rising pretty dramatically but
it's not perfect yet so for instance
yesterday I booked the flight and got a
got this little red icon in Gmail which
means the message was not securely
encrypted so NSA can now like have my
booking code and do whatever they want
so that's that's it yeah so I hope we've
given you some interesting things to
think about when you're looking at
password systems and authentication I
will take questions I think after</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>