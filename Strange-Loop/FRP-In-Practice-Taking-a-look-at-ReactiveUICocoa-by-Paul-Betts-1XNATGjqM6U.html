<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;FRP In Practice: Taking a look at Reactive[UI/Cocoa]&quot; by Paul Betts | Coder Coacher - Coaching Coders</title><meta content="&quot;FRP In Practice: Taking a look at Reactive[UI/Cocoa]&quot; by Paul Betts - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;FRP In Practice: Taking a look at Reactive[UI/Cocoa]&quot; by Paul Betts</b></h2><h5 class="post__date">2014-09-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1XNATGjqM6U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the end of strange loop and
I'm here to talk to you about a subject
that's a little more practical and a
little less brain melty since you've had
two days of turning your brain into like
molten silicon with the end of
terminator so and I'm really excited to
speak here it's strangely if only
because I don't have to spend the first
like two thirds of my talk explaining
what functional reactive programming is
that's really great it's like trying to
teach somebody calculus and explain why
it's cool at the same time like it's not
so easy so yeah so I was super excited
to see a lot of talks on the subject on
the schedule especially I really liked
Evans talk about Elm that was really
great it was a really great overview how
many people saw that talk was really
cool he's a great prisoner I loved his
talks so a lot of people presenting
about function reactive programming or
presenting on theory or talking about
web frameworks and a github in the
desktop group I get we've been doing a
lot of things around Native programming
so desktop apps mobile apps anything
that the ends and app or dot exe or dot
IPA or apk that's what we do and we've
been using this approach for a really
long time and we're really excited about
it and so I'd like to share that with
you all so why why should we think about
this technology when I can I can write
an event handler I can an on click it'll
be great
I can save off some boolean why should
we bother so we can no longer write
synchronous software bad news I think
Bob Dylan said that but I think Abraham
Lincoln said that about him saying that
yeah so I'm going to talk about kind of
the history of two desktop applications
one for Mac and one for Windows and the
libraries that we built around them a
lot of what I've been saying what
I'll say today applies to mobile
applications as well so you know desktop
and mobile Mobile is just desktop where
you don't have as much memory and random
bad things happen to you so all the cool
things that I'm in talking about works
in both places that's very cool
so around 2002 github.com decided to
write a first a Mac application and then
a Windows application and these
applications were really designed back
in 2000 to get was not the paragon of
usability that it is today and so we
wanted to write these applications to
make it so the people who just wanted to
get their work done and make commits and
you know create branches and push things
up to get up calm the website could do
so because they really couldn't they
couldn't use they couldn't use git so
they couldn't use github I know it was
we thought that was a bummer so both of
these applications started off as kind
of best practices imperative
applications they were written kind of
the style of what you were supposed to
do at the time using using imperative
code and through the development of it
we hired a bunch of people we're really
excited about functional programming and
so now these applications both of them
are driven almost completely by signals
by by the kind of the concepts of
functional reactive programming
everything UI events are signals
shelling out to get is a signal where
every line is an item in the signal
every network call is a signal every API
call doukas the background is also a
signal that only returns one item it's
kind of a it's a really different way to
write user interface applications than a
lot of other people were doing in the
past and and we're really excited to
share this with people and so these
libraries we we kind of took out a lot
of these pieces and built
into two libraries that are kind of
complimentary one written in objective-c
and one in c-sharp and so I'll get into
that but the impetus for all of this was
library written by Microsoft written by
Eric Meyer called the reactive
extensions and this was written
originally for c-sharp was actually
written for the sequel server group
which was really strange if you think
about how they're trying to manage like
stream computing like these huge stock
worker kind of environments where they
have all this data coming in they want
to process at real time that's what they
came up with and Evan mentioned this in
his talk this rx fits into the async
data flow model of functional reactive
programming so it's it compromises on
the principles to fit into a world that
is mostly imperative so when we write
Windows applications when you're at Mac
applications we still live in this world
of mutable state Coco really likes
objects that save state and you poke and
set and get in set properties and and
run methods on them we live in that
world but we can bridge a lot of it away
and that's really cool so because we
live in very mutable languages we have
to make a lot of compromises
what ends up working out so reactive
extensions kind of gives you these
primitives for creating observables
which so an rx they call them
observables and in it's the same as a
signal in reactive cocoa and some of the
other in elm they call them signals the
semantics kind of vary between platforms
so we can create signals if you haven't
heard of signals that are kind of like
events right event as if n as a signal
we can create this signal we can
transform it you can lift operators to
it
things like filters and maps and reduces
in this talk I use c-sharp syntax
because all the things that I'm saying
also apply to the Objective C version
but I find that c-sharp syntax is kind
of if you didn't know either language
then like you might be able to figure
that one out easier
I also write c-sharp every day and think
it's better so and so we have
transforming observables which is really
cool we can take simple events and then
transform them into more interesting
events you can take dumb signals and
then make them cool signals that we're
more interested in in our application
and the third thing that provides and
it's really important and it it's a very
practical compromise is the notion of
context so normally a functional
reactive programming doesn't care about
what context is running in right it's
just in order in other words in a
practical sense what thread it's running
in but unfortunately user interface
toolkits really do
and so scheduling is an abstraction that
lets us defer the result of them anytime
we defer any computation we're gonna use
this object called a scheduler because
we've wrapped that we can do some
interesting things and I'll show show
that later the important thing is that
scheduling is the way to move from
background threads to the UI thread and
the UI threads to the background thread
so reactive extensions doesn't know
anything about user interfaces it
doesn't know anything about any kind of
like domain
it's very domain agnostic it's just a
way to create events a way to transform
those events and a way to schedule those
events it has no knowledge of any kind
of platform so around like early mid to
2010 I started to write a few it's kind
of almost just helper classes around
tying this very agnostic framework to a
very different UI toolkits so trying to
make it so you don't have to think as
much about moving between threads and it
will just kind of handle it for you and
so originally we'll start on Windows and
now it works on every major desktop and
mobile platform so it works on Android
it works on iOS it works on Linux and
Windows and Mac so that's really cool so
reactive cocoa is the same thing
objective-c plus your favorite UI
toolkit whose name literally ends in kit
so app kit UI kit then we're good
someone around 2012 I kind of introduced
these ideas to the Mac team it github
and they were really excited about it
and they're like we got to write this in
objective-c and so reactive UI and
reactive cocoa are kind of these two
like sister libraries they they're
intentionally we like both of us we but
we all work together to make sure that
kind of all the concepts are really
consistent even though the names are a
lot different they're really like the
underlying concepts behind them are all
the same so that's really cool so there
was originally written for app kit and
objective-c because we're desktop
developers most people using reactive
cocoa or writing UI kit applications and
the new version is in development it's
being rewritten in Swift which is really
cool because Swift has types and types
are great so reactive cocoa has really
taken off and it's really exciting to
see and so so much so that they kind of
throw every year at WWDC is held in San
Francisco and we throw it like a mini
conference one day thing they call RAC
DC so reactive cocoa is always
cocoa libraries always have a prefix
right and so the prefix reactive Coco's
RAC and so it's often abbreviated that
way so RAC DC if you ever had if you're
interested in reactive cocoa and you
happen to be in town for WTC I highly
recommend stopping in for the event
that's very cool so it's people were
really excited about it it's really cool
so reactio i does a lot of a lot of
different things it does a lot of things
like pave over platform differences and
a lot of little kind of things to just
practice solve practical problems but it
also does some things that are really
specific to functional reactive
programming or takes a lot of the ideas
from it and one of the most these are
kind of for interesting things that it
provides it provides a way to take
properties of objects and turn them into
observables or turn them into signals
keep switching words signals events ups
are rules they're kind of related that's
the same thing
taking properties and turning them into
signals where every time the property
changes you get a new item it's really
powerful it's really powerful and
actually every domain not just user
interface programming because if you can
take an object and then watch when it
changes and do stuff based on it and
construct how a new object looks based
on a previous objects changes that's
really powerful it's actually powerful
in all all kind of programming that's
really cool so we have a method called
that called win any which lets you do
that it's called win any because you can
watch multiple properties where you can
watch for example you can say like food
bar dot Baz tell me what bass changes
and so it'll even watch the intermediate
objects so food changes then you know
bar changed because the properties of
the change stuff so we have a way to
take properties and change them into
observables or signals I just need to
say signals all the time signals is what
the literature called it so we need a
way to take signals and turn them into
properties so if we look at like for
example like a color picker dialog right
look at a Photoshop or MS pane or
whatever you usually have three three
properties red green and blue and their
user input properties people type them
in but then you have this fourth
property color alright and so color
isn't like a property that you should be
setting it's really a derived value of
red green and blue and so we have a
method in reactive UI to make sure that
you're not setting these
explicitly we you construct this
property based on other inputs and as
those other puts change we were
rendering so that's really important
observables properties properties of
residuals reactor voi has a thing called
a command in in reactive cocoa I think
it's called action based on like the
target action framework and it's this
abstraction to model this really common
pattern of we're going to invoke
something from the UI we're going to run
it in the background and then we're
gonna bring back the data back to the UI
thread and to do things like only allow
this to run once or like not
concurrently or to disable the attached
UI element when it's running
so the like canonical examples like the
search button right you get search we
have to run something in the background
we pull back the data and then the
button is enabled again and the fourth
thing is observable lists so lists who
we can watch when items are added items
are removed we can say things like for
every object run a method on it and
whether that object was inserted on
creation when it was you know added
after the fact the list gets cleared and
then new set of items get added you need
to do everything on that one meter will
list whose changes can be observed so I
tried in my examples to take really
practical examples because I'm talking
about a like a case study kind of thing
and so I'm taking I'm copy pacing these
right out of get them for Windows so
sometimes they're not very pretty and so
these aren't these aren't like ideal
beautiful examples but this one was easy
to understand so you want to take the
full sha-1 value of a commit and we want
to make the short version so get github
never just displays unless you hover
over in them the full Shah displays a
nice shortened one and we're going to
say whenever whenever that
Changez select it into the short version
and then stuff into this other property
called short show and we can describe
how these so we're describing how these
properties are related and we can
describe in the really interesting ways
we we don't have to we're not limited to
simple like filters selects we can say
like these two properties are related by
a Google search or these properties are
related by this complex series of events
that have to come be combined and put
together
so this is a canned example so we can
create commands that run asynchronous
actions this is uses C sharps
async/await
which is kind of cheating but you can
combine these two together async/await
and and observos we're going to take
that result in the stuff and do property
if anything bad happens we're going to
take the exception object to throw bolt
and then turn that into a stream that we
can type to the UI as well and commands
also do the very practical thing of
marshaling marshaling objects between
threads which unfortunately have to
think about
so observable collections are in my
opinion the weakest part of reactive UI
but I'll show them anyway because they
have a lot of potential I think and the
interesting thing about observable
collections is you can create derived
collections you click just like I can
take objects and select and wear them I
can take collections and then filter
them into new ones and as the original
updates the new and updates too and this
is really practical because if you have
like a like a list of model objects you
really want to select that into
something you can display in a big UI so
you want to you take a list of model
objects and you want to map them into a
list of view tiles right like tiles in a
list box so this has a lot of potential
but it actually has a lot of bugs too
unfortunately and the cool thing is that
the inputs to these this here is doing
filtering and sorting as well as mapping
and the cool thing is that the filter
and sort predicate can also be signals
and those signals can update and we
shuffle up the derived collection based
on that too so it has a lot of potential
to really simplify a lot of common UI
scenarios but you end up getting into a
lot of practical problems like
allocating too much memory you're like
you're always creating these new objects
that can be quite costly and if you're
putting them in a list box then that's
very important or we'll see you later
because this is definitely an area of a
lot of potential for future versions so
since we learned all about Elm today I
wanted to just like point out a few
things of how they're related both of
them both elm and RAC and reactive UI
effectively use behaviors so behavior is
like a time a time varied value it's the
thing that always has a current value
when you call win any the for as soon as
you call that method you get the initial
value of the property and so that means
you have you don't have to worry about
the the start state if you had like a an
event representing the change but you
want to set up your UI the initial view
of it
you have to wait for everything to
change once and so
this kind of solves us through through
behaviors so elm does a lot of really
cool stuff that rx does none of like you
have to think about scheduling and
ordering you have to think about like
putting things on other threats because
the language helps you you do this then
they can do a lot of cool things that as
a library you kind of have to compromise
with elm disallows signals of signals
our ex left he used them but then again
let's use them because I can't guarantee
a native of the nice things at Elm does
so I will really want to talk about how
this has worked practically as a team
like how how we built these kind of
production size products using this
application so some great things high
five yeah so some great things and this
was actually the hardest part of the
talk because I don't have like an
alternate me which decided not to use
any of these things and wrote my program
imperative Lee and then found out all
the bad things that happen to me yeah I
haven't written like I just don't want
to write imperative programs anymore so
I try to avoid it so I'm not smart
enough to write stateful asynchronous
applications anymore it's too hard it's
too hard in large applications it's it's
really too hard these days in small
applications because so many things are
asynchronous as rich Hickey says it is
easy but not simple UI state has a ton
of intermediate values UI user
interfaces as a concept is essentially
state like if I have a desk and I leave
a hammer in the middle and I could walk
away and come back I expect the hammer
to be there that state all UI
applications are state and we're trying
to model it in such a way so we don't
have to look at it as much and so making
sure that all these intermediate values
that show up in our application like you
know is enabled or you know checkbox
checked is this intermediate value that
is tied to some piece of model code
making sure that these intermediate
values are all up-to-date is really hard
it's a cash intermediate values are cash
and cash and validation is hard
especially when this the way that we got
into this invalid state is
non-deterministic based on timing based
on race conditions so we need something
and I think this is a really good
solution so our X and reactive you are a
consistent model of asynchrony so if you
look at even like on the web and
JavaScript you look at the you know the
Dom we have callbacks
we have Dom events we have XML HTTP
requests we have a lot of different ways
to say the same thing when we have an
event and it's coming back to us so
every UI toolkit also has eleventy
billion different ways to model
asynchronous things we have promises we
have events callbacks dotnet has like at
least four that they recommended at some
point and then burned down and then
recommended a different way and then
burn it down and so one of the cool
things that rx lets you do is take a lot
of these code and write really dumb
wrappers around them so that you don't
see you can see it in a very consistent
way all using observer rules are signals
signals and you don't have to think
about and you can combine them all
together you can combine things like you
know when when it's five seconds in or
this network request calls comes back
even though in the network request was a
callback and the timer was an event and
they don't agree but we can make them
agree which is cool modeling
asynchronous code in tests is actually
possible so take signals are really easy
to mock and fake out or like create
dummy versions of and we'll see a little
bit like a little bit of that later but
being able to create dummy versions of
timelines is really powerful
so it's a powerful model of asynchrony
being able to compose operations in this
really flexible way is really powerful
and it's powerful because it lets me
take the distance between the speck in
my head of how a feature should work or
like how a piece of UI should act and
map it to code in a way that's really
readable it's really cool because I can
write this in a really succinct way so I
want to be able to take like the button
should be enabled when these four fields
have values that are all strings they're
all numbers rather and be able to map
that to a single line in my application
and normally you can't do that you have
to like take a bunch of callback
somewhere I'm together being able to
write essentially take the lines of the
spec and then write them as lines of
code or blocks of code is really
powerful without having to spew it
everywhere and then different callbacks
to like fiddle with each other's stayed
accidentally and make a big mess so this
is one of the examples I really like
this feature is called the undo flash so
every time you do anything and get up
for Windows you get this pop-up and it
lets you undo it which is really
important in my opinion a lot of people
who are nervous about get they're like
what did i do what I did I hit a button
and now my no my's code is broken so
being always happy to be able to go back
as cool and the interesting about this
rule is that the way that it is
dismissed so it pops up as soon as you
do something and so the logic is
actually a little bit more complicated
and than you think you think it's just
oh yeah it hangs around for a while then
goes away so what it does is it
guarantees what I wanted I wanted to say
hang around for at least five seconds if
any that the user does anything else
that's a hint that they don't want to
undo send it away but we don't want to
like make it go away immediately because
that means as soon as they like if they
move the mouse like a second like it'll
just go pop up pop down that sucks so we
want to hang around for at least five
seconds and then if they do any
thing like move the mouse click you know
type something send it away they they
must not have wanted it or if they wait
a really long time also dismiss it
trying to set this up in the parrot of
code wouldn't be succinct you wouldn't
know what they were trying to do when
you read it again and so we can express
in in a single block of code a really
complicated intent like that I don't
know how to do that in any other
framework so we can say like you know
when this original timer fires and
either when either of these two fire
then executes the command we fake
hitting the OK button
there's an invisible button that
actually means cancel this is practical
code this is not this is not theoretical
I copy pasted this we are practical
individuals above all else so Evan
talked about time travel debugging we
have something that's not as cool but
still really useful called time travel
testing so remember that this thing that
I described is scheduler which lets us
jump to other threads anytime an action
is deferred it's run through this object
called a scheduler so you can create a
scheduler that doesn't actually do
anything it just records what you would
have done so just puts it in a list it's
like oh yeah they what they wanted to in
ten seconds we run this thing and so you
just keep recording whatever they wanted
to do and then at some point you say
like scheduler that's advanced to ten
minutes in and so now you've just got a
list and you've got some things in order
and so you run down the list until you
get to 10 minutes in as fast as possible
executing it like full-speed even though
you're simulating this thing that was
supposed to take a lot of time and so
that way you can write tests that are
deterministic run full speed but
simulate time passing which is really
cool like
I had this really good example that was
a Pomodoro timer like these you know you
know time and you wait 20 minutes and
then you wait 10 minutes and then 10 min
break and then you go back to work and
even if you try to set the delays so you
write a bunch of test suite to it you
set all the time so like really low like
1 millisecond to milliseconds of
real-time times like a hundred tests you
still end up with a test suite that is
unusable slow and so this is really cool
a lot of stock traders use this feature
of reactive extensions because what you
can do is you can take canned historical
data stock trading data run all of it
through as if you're running through as
if you sat there you know in real time
and watch this data come in and then you
catch up with the present day and so now
you're watching real time as if you were
doing that the entire time and your code
base is one path you don't have to
create like the historical path where
you run through a file and then you get
the present day and then you come jump
to the completely other code base where
you run through real time just cool so
here's an example of how we test the
relative time so get up always displays
times for commits is like five minutes
ago or like if you're in New Zealand
sometimes it says like two minutes from
now like somehow I don't know time is
weird in other countries or time zones
it's hard so we do the same thing we
override we say all right we made a
commit does it say just now because we
just made this commit fast forward five
minutes what does it say now fast
forward five more minutes does it say
like five minutes ago
does it not so it's cool
this is what every developer who gets
really good at reactive UI and RAC says
they're like I don't know I can't write
these like I don't want to like it
doesn't it doesn't work and that's kind
of a sign that I'm onto a good thing so
here are some things that aren't so good
so in a group of developers when you're
writing a production application most
developers aren't familiar with these
concepts even if they're really good
developers and so one thing we have to
do a github is that every new developer
to our application kind of has to take
the RX class and so you'll find that
we'll kind of like people will fall back
to their old habits and because they
know that it'll get stuff done and it
will but in the end you'll end up kind
of like getting a little bit of Croft
and like it may be a little bit more
crops in like so you'll be really
careful and and like kind of it takes
some time for new developers to
understand this model or really kind of
latch on to it and so if you're now and
if you're in a large group then this can
be definitely something to think about
like a trade-off UI frameworks care
about threads it really only just cares
about one thread and whether you're on
it or not so Windows will just blow up
on you whenever you try to touch it from
the wrong thread cocoa does even more
insidious things that just like you call
a method nothing happens it didn't work
I don't know like sorry computers
they're the worst
reactive UI actually try to solve this
problem and make it really easy and kind
of hide this from developers but it
turns out that making it easy also made
it really slow because these schedules
where we defer something and say like
put this on the UI thread would end up
stacking and so you end up with this
convoy problem with like I I made a
change which scheduled the UI thread
that was a little bit of latency but now
I did it again and now I did it again
now you have it like 20 times and now
that's a lot of latency in your
application
feels really slow so we had to tear out
all of these features and make it very
manual which is a bummer but you make
fast applications so it made it possible
for large applications to exist space
and time leaks it turns out that giving
developers the tools to make long chains
of events is cruise control for memory
leaks so because this makes it easy to
tie a bunch of objects together
you've now tied their lifetime together
through event leaks just like in
JavaScript event leaks I spend a lot of
time and get up four windows in memory
profilers digging around trying to find
event leaks because it's really easy to
leak a small object and you're like oh
that doesn't really matter but then you
look up the chain and eventually it's
like a giant bitmap and here I go
because everything is tied to the view
view objects are really heavy and
eventually at some point you'll get to a
view object worried that you leaked and
now you've you caused a lot of problems
it's not a lot of fun to trace down this
and the tooling for it is not ideal so
it's a lot of looking at this kind of
diagram you're using rocks and sticks
basically but this isn't so it's
something to keep in mind when you start
it we didn't know and get a per Windows
there was a specific kind of framework
related memory leak that we didn't know
about and so we're like why are we
leaking all this memory like I don't and
we figured out that it was like a WPF
bug and we're like so the framework will
sometimes conspire against you to leak
memory
so one thing that's really isn't a super
big disadvantage but it's something that
you have to really throw out all the
nice things you have is a virtualizing
list and so virtualizing list show up
and every mobile platform in cocoa it's
called a UI tableview controller or UI
collection view controller and Android
it's a ListView or like a recycler view
and WPF and sort of you know
virtualizing ListView these lists that
actually hold a certain amount like a
trash stack of views that are recycled
and so as you scroll it doesn't have all
the views in memory because if you have
a look a list of a thousand items you
don't want to have a thousand cells
because you don't have the memory to do
it so you might have like 20 cells and
as you scroll you create new ones or
reuse old ones that creating new ones
you are essentially doing a lot of work
in a draw loop and you have to be really
it's really performance sensitive and we
found that the methods to create
observables or signals or and set them
up was too expensive to do inside for
for really complicated user interfaces
so people would scroll and they'd see
like this like grind as it is it this is
an uncommon problem like scrolling in
iOS and Android is very difficult to get
really good you just basically have to
do less stuff so it's just hard and so
you can definitely run into that a
problem
GC pauses on Android are a super bummer
Rx laws are really small objects the
call stacks in in these in Rx and RAC
can get pretty ridiculous so this is an
example there's an iOS application so
the top of the button the bug is
actually really simple like it's just
like right there like line three
it's actually like a like a runtime like
a GC bug where we just didn't marshal
the object or I jumped into nowhere so
that's part of the call stack let me
keep going
so we haven't got there yet
we're still looking through and the
problem is that at least with c-sharp
a lot of the names have been stripped
because they use anonymous classes and
so you don't know the operators you're
actually going through and so like it if
you take that cause that can grep out
the word system not reactive and that
actually is a pretty readable call sack
but you end up with these like crazy
long it's like let's keep going let's
keep going
and there we go we're at main three
pages later so that can be intimidating
to new developers this is using yeah
samurai OS so this is they took a
c-sharp application they pre compile
everything ahead of time because Apple
doesn't Lodge it and they this is
actually a native call stack but they do
a trick where they make all the native
function names to be like c-sharp
function names so when you get the
native stack like you crack it out of
the console dot log you see something
that you can kind of interpret as a it
was pretty clever like this so a lot of
these problems if we had good tools and
like we could like hack into kind of the
internals of it and since a lot of this
is open source we can we can make a lot
of these things way better and so we're
at get up trying to think just like
barely starting to think about like how
can we make this how can we make this
better for developers because when we
make it better we make it more
approachable I want everyone to be able
to great UI applications in the style
but right now like they fall into the
pit of of this somewhere and so that's
not great so tooling can help us out one
thing that's really important if you do
decide to write this in your application
logging and tracing is really useful
logging signals in particular will help
you debug a lot of what's going on
signals are really cool because they're
natively what's called a dual point log
so it's a span it's a certain amount of
time
and if you can visualize that you get a
lot of cool things and so yeah
logging signals in an area obviously
that's important so this is a tool that
I use in WPF it's basically the best
part of Visual Studio this is called the
concurrency visualizer and what it does
is it lets you they log everything using
like the essentially the Windows version
of dtrace called etw which is impossible
to use unless you're inside Microsoft
but they made this tool that I can at
least see kind of what's going on so
this is there's a view of a bunch of
threads and each color code is a kind of
thing you're doing and you can see a
little bit of in the corner and I have a
great screenshot and so the important
thing is to look at the main thread and
you basically want the entire thing to
be brown because the brown means
processing UI messages it has brown that
means it's responding to user input if
it's any other color this is actually a
really bad trace like this application
sucks because you can see like at four
seconds in that they start grabbing
locks everywhere
red is synchronization and if you click
on any of those you can see how long it
was you can see the thread that
unblocked you and it'll like kind of
point like would be like this ran from
here and it was waiting on this and like
it's a really cool tool and if I could
jam my own data into it if I could have
signals in that view it'd be really
useful and it make debugging
applications really easy especially even
ones that are really asynchronous and
have all kinds of things going on in
different threads and so there's a
really cool tool that I want to like
rebuild but integrated into rx I have a
lot of plans but not enough time I need
more hands basically it type faster
reactive cocoa has DTrace integration
you can view this trace and instruments
instruments is not extensible in in many
any super interesting way so this is
this is the best you can get out of it
it's kind of a bummer I'll be really
cool because they have all these
visualizations and if you could Jam
arbitrary data into it that'd be awesome
so like steal the ideas of instruments
but make it so that applications can
write their own their own stuff it works
for both iOS and App Ken trap grabbing
grabbing these traces so nobody's ever
seen this before one of the developers
on the desktop team and the Markus Olson
is working on a tool to visualize
signals so this is super cool and I'm
really excited about this this is gonna
be amazing I want to bring it every on
every platform he did this by like
abusing the dotnet runtime to be able to
hack methods and like replace like hook
them basically and so we can see like
this timer and the timer dot select
timer it out where and you can't see the
lines but there's lines connecting these
there's like it's a graph like an
acyclic graph and at the bottom we can
see that somebody's sony's watching it
and we can see how many instances are
live of each of each thing and if it's
red that means it ended in an error
right like throw immediately answer so
I'm almost out of time but this little
last slide and so tools like this will
make it so that this is really useable
and cool or like we had like it kind of
some ideas around overviews like be able
to see all the errors that were thrown
and then kind of debugging like and what
point in that graph did it happen stuff
like that so having these kind of tools
will turn that certain will turn the
ideas of functional reactive programming
how bring them to everyone in a way that
is approachable so I think tooling is a
big part of that and so cool so that's
all I got
thank you so much for your time
questions comments concerns
rants Tomatoes thrown
how much time do you think it takes for
someone
sure so the question was how how long
does it take to kind of move from an
imperative mindset to a functional
mindset I think it's a progress you can
definitely one of the cool things is you
can kind of like apply this piecemeal to
your application you don't have to
completely buy into it or completely not
and so you can kind of try it out on
maybe like a single view and then see
how that works and and it's there's
definitely a learning curve it's
unfortunate you know take some time to
really like map your brain a different
way than you're used to but yeah I think
that typically get up you know get up
hires really good developers we're
really fortunate to be able to hire
really smart people it takes them about
a good like six months to really like
turn their brain around
now it'd be really cool we don't record
it ever like it's always just like get
some developers in a room we're gonna
wait board some stuff let's go
like about the thing with that I think
one more question we're out of time
I totally agree but like yeah like if we
can buy some pitchforks will storm
Cupertino like I live right nearby like
we just roll in and be like guys I'm
sick of pointers aren't great I don't
want to but yeah so I mean racking and
reactive you I definitely compromise
it's living within a system that is
definitely not designed for it and so
yeah so having having a a really
beautiful functional UI toolkit would be
really cool
a little bird has told me that like
apples thinking about this they notice
react with cocoa and they notice that
it's kind of this different thing that
it's really useful and I think that
they're at least a lot of their
engineers are kind of taking these ideas
to heart but maybe in a perhaps more
like you know when you're out of you I
took it for every person in the world
then you have to think of it and it
really like you give them the pieces and
people can build what they want right it
has to be really like approachable and
so I think that's definitely compromise
that they they have to make okay yep all
right thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>