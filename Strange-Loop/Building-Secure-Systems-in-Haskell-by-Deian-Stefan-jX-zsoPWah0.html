<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Building Secure Systems in Haskell&quot; by Deian Stefan | Coder Coacher - Coaching Coders</title><meta content="&quot;Building Secure Systems in Haskell&quot; by Deian Stefan - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Building Secure Systems in Haskell&quot; by Deian Stefan</b></h2><h5 class="post__date">2016-09-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jX-zsoPWah0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everybody I'm dan I'm an assistant
professor at UC San Diego I just started
last week actually and prior to that and
kind of to work that want to talk to you
about is I was it was a Stanford
basically building secure systems in
particular take your web frameworks and
unlike you know every other Stanford
grad student I also have a startup
that's commercializing kind of this
stuff that we've been building there
okay so to get started I want to kind of
look back at an early bug that Facebook
had in inter application so Facebook
missed single security check and our
Android application and this person
happens to have found it this particular
vulnerability allowed kind of any user
to send a delete request to their HTTP
application and basically delete
anybody's album right and anybody's
photo album now this is actually just
two of the iceburg over the last a year
and a half I've been talking to
companies about web application security
and the stories actually way worse right
like I've heard stories where say an
intern was building a particular feature
and accidentally exposed you know the
whole password of every user for say 24
hours now this didn't make the news but
in reality like the story I think is way
worse than we kind of hear about in the
news and this is not because these
companies don't know what they're doing
that's really because of the way we're
building applications and systems in
general all right so what's what's the
actual problem well when we look at it
there are three things happening the
first one is that we are building these
systems that inherently handle sensitive
information right so they're handling
our medical data are now like IOT is
handling or our you know thermostat and
it's telling you whether or not you're
into house political data banking and so
forth and all these applications and
systems are built using programming
models that actually don't know about
the sensitivity of this data right they
don't know that this particular
information which happens to be
associate number is actually sensitive
right and when developers write these
applications they use these programming
models and naturally as we all write
software they introduce bugs right now
all these three things independently are
not really a problem right but when
combined what we huge we typically have
a pretty big privacy risk now to give
you an actual example I want to go
through
a blogging application this blogging
application is actually based on a real
production blog app I removed kind of
hopefully old names from here but this
is a real application and application
basically at its core handles two things
the first one is blog post and the
second one is say the users that are
writing these particular blog posts now
this is what the data model looks like
so on one hand we have blog posts and
there's of course some sets of
information that information is the boss
blackfoot post itself right so if i
currently working on a blog post and
it's still a draft maybe it should not
actually be publicly readable and we
have the user model which contains all
some sensitive information and
particularly contains say the password
hashes and email addresses so we might
want to make sure that you know nobody
can read password hashes and only say
the people like you're collaborating
with or only when you actually declare
that an email should be public can it be
read by somebody else okay so this is
some sensitive information and the
simples kind of data model I could come
up with let's look at a particular
feature that we can implement for this
application and see how this particular
web app it did the thing I want to look
at is just simply reading a post so
we're gonna read a blog post which takes
an ID and returns that post data and
author information all right so this is
what the source code looked like at that
initial kind of stage of the application
right so there's this read function you
guys actually see the sorcerer okay so
what this rida a function was basically
doing is given some HTTP requests it was
calling their the read function with
this particular ID which itself talked
to a database by calling to find one
function the database basically fetched
a couple of rows from the two different
tables the first one would be say from
the post model would be the actual table
that represents the post information the
second one would be Deardon their author
information right so we want to include
say the email addresses of Bob and
Claire when we reply back with the post
now what was happening this was
primarily client-side application it was
returning a JSON object and this JSON
object happened to also include password
hashes so this particular web app was
leaking user passwords they didn't
actually know about this but they found
out if
password a leaking problem and the way
they did it is by tweaking the read
function and adding a few lines of code
these lines of code basically look
through a data model object and emit the
field named password and anything else
that might be sensitive now this is like
one particular a place where we're
fetching these protocol objects but
you're doing this in eight different
places right so they had to go in about
eight different places to add this
particular check that would emit the
password from user objects okay so this
is what the code looked like basically
six months after you fixed this
particular bug now this particular piece
of code still has a vulnerability and a
vulnerability said it's leaking drafts
right so because again we're just
fetching information when we fetch
information we're not actually checking
to see whether or not a particular thing
that we're fetching is a draft or
whether it has been published so if
you're an anonymous user you can just
request this particular post ID and you
get back the draft okay so they also
notice this and they also fixed it in
the same way you fix the previous bug by
sprinkling a bunch of checks to about
eight different places right so what if
we want to do something slightly more
interesting right so this is a really
simple blogging application they don't
even have actually support for
collaborators but suppose they added
support for collaborators and one thing
you might want to have is that users
collaborate on posts can see and edit to
post but if you're not clara buying on a
post you can't see it right again the
way you do it is just sprinkling more
checks and this will give an idea of
like what this would actually look like
in their codebase well here's a
particular route that handles the
updating of user profiles now the code
itself is huge and there's like so many
annotations it's actually super hard to
follow and all the red arrows are -
security critical checks right so if
you've missed any of these now you have
a full ability in your web application
and unfortunately the way we're tackling
this problem of fixing probabilities is
by just finding it fixing these bugs and
just patching ramifications and
hopefully teaching our developers that
you know they should be adding the right
checks and right places and you know
using libraries they trust and so on and
so forth but of course this is actually
not working
all right like I think it's almost like
a daily occurrence that we have somebody
like getting owned and actually like our
consumer data being leaked so no it's
actually just this we actually have to
change how we build software we
fundamentally have to change this in the
way we're gonna do this is by minimizing
our transit competing base right so if
you look at your system today
you're basically trusting most of the
code that you're actually running all
right this is on the left-hand side and
the reason for is if do you have any bug
well that bug could potentially be able
to ability to bright so that's
inherently we have to trust this code
and we want to move to a world where you
don't actually have to trust most code
right I'd like to get to a point where
we only have to trust say like one
particular file and then we can import
all these libraries and we could have
our developers like write these
application features and not have to
trust that code to be secure right so if
we have a bug and that part of the
application it doesn't actually matter
that might just be a UI bug but it's not
a security vulnerability now this is of
course the thing that kind of the
security community has been trying to do
forever and the question is can we
actually do this I want to convince you
just talk that we can at least for web
applications and hopefully like I can
like shed some insight into how we can
potentially tackle this for other kinds
of systems the way we're going to do
that for web applications by leveraging
the way people actually structure web
applications right so if you look at a
web app well most of the functionality
is actually revolving around persistent
data right so in our particular blog
example well this application rules our
blog post and user user profiles right
so conceptually the thing that we care
about are these particular blog posts in
particular two drafts and these user
profiles right so all we need to
actually do is make sure that these
posts enemies user profiles aren't
leaked or corrupted by incorrect users
and the other thing that makes web
applications kind of special is that
developers already have a security
policy in mind
you kind of already know when you're
building this application whose should
be accessing any particular piece of
information right like we know for
example that anybody can read a post
that's been published we can like write
this policy in English in an English
sentence and we know for example that
Alice is a lot to read her draft but
nobody else is until it's actually
public or pub
and finally we know that nobody should
be allowed to actually password hashes
and really like when you look at
security like knowing two policies
really have to challenge the only other
thing like once we have the policies
knowing how to actually enforce this
particular policy this is what our Hales
framework does our hails framework is
just a Haskell web framework and it's
designed around two principles one is to
specify policy in a self-contained
concise manner and do so in a way that's
separate from your application logic
right so you should be specifying your
security policy away from your nasty UI
code and not have to sprinkle checks
throughout your codebase to ensure that
this particular policy was actually
enforced we don't want to depend on
developers adding the right checks in
the right places we just want you to
specify the policy once and have it be
enforced on everything right so we want
to cuz ice policy and we want to make
sure again that this policy is always
enforced right like you can't write a
piece of code that gets to bypass this
particular policy what that means that
if we can afford this policy and
everything and we got a policy right
then you don't need to actually trust
any particular piece of code right so
our application like TCB the amount of
code that we need to trust to be correct
really just comes down to the policy
specification code okay so how do we
actually like what does Hale's
really look like and how do we actually
build applications well the first thing
that we've done is extended to MVC model
with security policies right
so today most applications are
structured in kind of the MVC model even
though it's a little bit ugly I'm gonna
pretend that this is what they actually
do so in the model you would typically
define say your your data interface
right so you define your schema and how
you actually store data on on disk and
you define say a renderer that would say
take this data and give you back an HTML
page or JSON object and so forth so this
is commonly called a view and finally
you have the controllers that tie
everything in right so the controllers
take user requests they talk to the
model they didn't talk to the view and
give you back a fully rendered HTML page
now in practice this model is actually
kind of ugly because you're sprinkling
security checks throughout the
controller and sometimes even view code
so what we're trying to do is make this
model slightly cleaner and actually have
security of first-class citizenship the
way we're going to do this is by
I mean the policy with the data model
right so again I like the thing that we
care about is protecting your data so
when you're actually specifying it like
schema for your database well this is
when you should be specifying a
particular policy and how this data
should be accessed right so when you're
saying this is a blog blog object and
has this particular field so well you
should also say who's allowed to read
and write this particular blog and
finally we're gonna enforce this policy
everywhere to make sure that whenever
you you do read something this policy is
enforced okay but how do we actually
specify policy a policies are just
Haskell functions from say rows two
labels and our actual implementation
we're using Mongo so it's not actually a
row it's more document but I think the
row concept is slightly simpler to think
about so what are these labels
well these labels are just a concise way
of saying who's allowed to read and
write this particular piece of
information
it's just basically a conjunction of
these junctions of principles right so
Alice or Bob Alice and Bob and so forth
let's take a concrete example of how you
would specify a policy for our blogpost
object well this would be again a
function from the post object itself and
then we want to have the readers and
writers
well who's about to read a post well
this informations contain end to post
itself right so if the post has been
published then anybody can read this if
the post hasn't been published
well then let's look at who the authors
are and use those authors in our read
field right so like only the authors
that are actually collaborating on this
poster are allowed to read this
particular post but who's a lot to write
this particular post well we want to
make sure that only the author so what
do we do we just look up this formation
into post itself right so just get the
authors and this will tell you who's
lots of read to write this particular
post now this is a function right so
like you can actually use it and this is
not what the thing that has actually
accentuated but when we read something
from the database on the right-hand side
for example when we read say the first
first row this row is a blog post
written by Alice and it has not yet been
made public right so it's it's still a
draft and now when we apply this policy
to this particular row what do we get
well we get that the readers are Alice
and the writers are Alice for the second
row which is a post problem Clara
collaborating on this
has been made public so when we actually
instantiate the policy when we read from
the database for example who would get
that the readers won't include everybody
so it's a public posts and writers are
only Bob or Claire right so you get a
very simple way of specifying policy and
in a similar way we can do it say for
the different fields on a particular
user profile so let's look at a policy
for user passwords what does this look
like well again it's just a function
from the object itself so from users to
a set of readers and writers are labeled
so who's allowed to read a password well
we're saying nobody and who's allowed to
actually write the password well the
particular user so I should be able to
change my password and maybe I should
allow root to change my password as well
so the writers are and this particular
bro Alice or root okay now the question
comes down to okay we have these labels
and we have these labels when they come
out of the database where do we actually
enforce these restrictions on who's a
lots of read and write well it's not
enough to just enforce these
restrictions at the model boundary right
this is a pretty common thinking that
like when you read something from the
database this is when you should perform
the checks and nowhere else well this is
not enough and the reason it's not
enough is because say the code that's
rendering the particular post might
actually be able to leak it if you don't
enforce these restrictions everywhere so
that's the thing that we have to do we
have to enforce these label restrictions
on all code once it leaves the database
right so like once your render actually
leaks your particular draft I to not be
able to actually leak once a reason it
should not be able to leak it to an
arbitrary host right the policy dead
comes with the particular post from the
database should be enforced even once
you have access to this particular data
but this means is that we don't have to
actually trust the renderer code right
like we know that the policy ensures
that it can't leak it so you can write
this particular matter or however you
want right it's not part of our TCB okay
so now we know where the more enforcing
these policies and what these policies
look like how do we actually do it
enforcement
well her system is built around this
technique called information flow
control have any of you heard of this
term before all right
so very few the idea is actually super
simple so the idea behind dynamic
information flow control in this
particular context is that whenever data
leaves say your data model it's
explicitly labeled right so we applied a
policy and now we have basically an
object that also has an Associated label
that says whose odd to read and write
this data now this particular label
always follows data throughout the
system and finally the mechanisms
underlying runtime system enforces that
these label restrictions are actually
obeyed by whenever you're about to
perform some kind of like network
communication or write to the database
or write to the file system and so forth
so going back to our example of reading
a particular blog post let's say we have
our get request that is to read blog
post 0 well in our view and go to our
code we're gonna again just call into
the database right so find one you have
an index 0 this is going to look it up
by calling in to Doe the DAAD the model
and policy mono policy's gonna fetch the
particular information from the database
right so we're gonna have a road that is
alice's blog post this blog post has not
yet been published so the policy that
comes with it is that alice is allowed
to read it and all the alice's or ones
who write it now the model policy
replies back to the view controller so
we get back this row but this row has a
label attached with it so if we say had
a request incoming coming from Eve well
at the particular boundary we would
check whose is evil how to read this
particular information and the policy
says that only Alice's so we're gonna
disallow this particular right the other
hand if Alice was the one performing two
requests well this would naturally be
completely allowed okay so when we step
back and I'm gonna go a little bit more
into detail on how we actually do this
and why Haskell is an interesting
language to do information flow control
but to complete the picture I want to
talk about the kind of application or
architecture that comes out of doing
this model policy and view controller
separation right so like our new
paradigm has two kinds of code on the
one side we have the model policy this
is where you keep defining your data
model as you typically have done but you
additionally
specified policies right these policies
are functions from rose to labels and
this is a piece of code that you need to
get right right so if you specify policy
that is too permissive you now have a
vulnerability right so you need to make
sure you get your policy right but
importantly you don't actually need to
care about the rest of the codebase and
that's the views and controllers so
right this is a code that implements all
the UI and handles all the user requests
right so this is the code that we don't
need to trust at all to again to enforce
any security policy you might still want
to have some policy code in the view and
controller to actually reply back to the
user would say meaningful error message
but importantly you don't have to
actually do that and from this
particular architecture we also get
extensibility right so information flow
control which I'm going to go into a bit
more in a bit gives us the guaranteed
that this satyam the view controller
code can't actually leak your data right
so that means bugs and the view and
controllers are not security
availabilities so what that further
means is that now you can have
third-party developers implementing
these views and controllers right so you
might have started out with an
application that has say your standard
view controller that you've implemented
yourself but now you can extend your
application to third-party authors who
might want to say implement a mobile
view controller that interfaces were the
same model and policy you know you don't
have to trust this piece of particular
piece of code because information flow
control system ensures that whatever
policy you've associated with the data
is actually enforced regardless of who
wrote the actually on controller code
now using this model we built a bunch of
applications I'm gonna tell you a little
bit about them the first one is called
get star guess our was basically a
github clone that let you modify the web
app the core web app features yourself
as a user of this particular platform so
say you didn't like the notification
system well screw it clone not a
notification system modify it however
you want and then just deploy it on our
platform another thing that we built was
say commenting system similar to discuss
this was actually built by high school
student who also worked on this task
management system so this particular
soon is awesome but I think like it also
highlights that you know Haskell is a
language that you can use even if you're
on experience if you're given to write
primitives and finally we build things
like
conference review systems we're coming
from the academic world and a blogging
system so let me show you this
particular blogging system that was
similar to if you've heard of school of
Haskell that will let you execute
arbitrary code server-side to actually
like have say interactive blog posts
particular part that I want to show you
is just say the post views so on the
right hand side here so we here we have
basically you know your standard list of
old posts then we have say Alice's
particular posts so she has two posts
one is public one is private and here
I've opened a private one so and here
I'm also logged in as kind of the
anonymous user right so I'm not logged
in at all and I can read all this
information and the reason for it is
because I've set a bad policy now this
is the default when you start with a
system that's not hails and normally
you'd have to go through like at least
these three different places to make
sure that you know the current user does
making a request is a lot to read his
particular data inhales all we would
have to do is change this particular
policy to actually be correct so this is
the policy for blog posts and I'm gonna
kind of just explain to you in detail
what the policy after he says can you
guys see the code in the back yes no
okay so maybe I'll make it a little bit
bigger
all right so it's actually pretty hard
to work from this angle
okay so the policy contains different
fields that the first one is who's
allowed to read and write there's
particular database itself or well
saying anybody's actually allowed to
have access to this and the kind of data
that we can store here can be maximally
sensitive so like hale's also has a
support to like just not let you save
overly sensitive data to the database if
you're paranoid about things like
corporate channels this is the
interesting policy about blog posts so
we're saying the blog post is a document
and then these are the particular
readers and writers for this particular
document
well again who's allowed to read this
document or if the post is public than
anybody otherwise anybody so this is
where the bug is instead of just letting
anybody read the particular blog post
when it is a draft we should just say to
collaborators right so in this case I
have co.labs and this is basically
grabbing your collaborators from the
document itself
and finally to kind of explain to you
what these other fields are well they're
basically telling the Hale system that
this is how we want to index and
actually find particular objects into
database so now with this new policy I'm
gonna just recompile and basically once
it's ready just refresh the pages to
show they're filtering in action I need
a better laptop alright so the app is
running and now again as an anonymous
user i refresh the page should no longer
be able to actually see Alice's private
posts when I try to access to post
itself so I knew that like we are
leaking that a post exists so I might
have the actual post ID itself but when
I try to access it while Hayles will
tell me that it's not found and this is
actually important as opposed to telling
you that you're not allowed to access it
because sometimes you might not want to
tell people that post exists and finally
of course the last view is the one that
has all everybody's posts so I had one
person I always had more private post
but now we only see two public ones okay
all right great so that's what the
system looks like in practice when you
look at the actual applications we
wanted to see like what is the TCB
actually look like so we're making the
claim that you can write systems that
are secure by actually considering most
code untrusted well how much of your
code is actually trusted all right so if
you look at the applications that we
built in particular to get started a
platform that as a clone of github well
we had to write one particular mod on
policy right this declared say project
two declared collaborators and declared
I get access controls and so forth and
the total amount of code that we had to
write for the policy was about 250 lines
of code the rest of the application if
you look at the different features say
like the project manager or the code
view or even a wiki this all added up to
a total of around 200,000 lines of code
this is old code that we don't actually
have to trust nor care about and a bunch
of it is code that we just pulled off
from hackage right so now hackage is
slightly more more secure as a package
jerk because at least you can't override
somebody's package but at the time we
were building the system that was not
the case and perfectly have to care
about that we could just pull packages
from anywhere because we can guarantee
that this third party code can't leak
your data and for the other applications
which are like I guess there's they're
simple applications but nevertheless
they actually like implement real
functionality that kind of companies do
and ease again are you know sublinear
one considered open compared to the
actual application functionality itself
okay so we have a small TCP like how do
we actually implement this well and like
what exactly is Hales
well Hales is just a haskell library and
it consists of a few components the
first one one is an HTTP server and
client so that your web app can actually
handle a request and it can talk to
remote hosts of course it has the data
base layer and we have kind of nice DSL
x' for actually handling routing and
specifying policies there may be the
most interesting component is what the
runtime provides and that's one user
authentication and to the enforcement
system itself so an enforcement system
is an information flow control system
and it's called Li oh so this is kind of
like what Europe when you're deploying
hails what it would actually look like
so you'd have your functionality
whatever libraries that you might pull
in and your policy code which is
untrusted and finally like our oh I oh
and Hales framework that are mostly
trusted themselves so those are on you
order like a thousand heads of code but
their code for which we actually have
some semantic guarantees no you might be
asking white haskell so and the reason
for it is well we're trying to do this
pretty intense enforcement mechanism
right so we have dynamic information
flow control and it's really hard in
general to design systems that don't
inherently leak data right so the
programming language community has been
building these dynamic information flow
control systems for like at least a
decade and most if not all have at least
the Billy's like leaked data by just not
terminating a program and we're like we
can't actually have that if we're trying
to deploy real systems and real web
service for example can't actually just
stop the world when you're detecting
that something might be trying to leak
information all right so like things
like concurrency exception
and even the ability to inspect security
violations have been really hard to deal
with that Haskell actually makes this
easy and the way it makes it easy for us
to handle this is by letting us to find
a sub language within the ecosystem and
like you can think of l io as an
information flow control secure kind of
sub language within Haskell and finally
write like Haskell is fast and at least
part of it is amenable to formal
reasoning so we hope that like once we
actually have the sub language well we
can actually make it fast enough and we
can actually prove something about it
and this did actually happen now what do
I mean by sub language well if you think
about Haskell right
Haskell is a purely functional language
so what is a purely functional language
well the first thing that it gives us is
we have functions that can perform any
side effects right so say my render post
function which will take a post object
and convert it to HTML for example can't
actually have a function or like a call
to something called like leak to evil
server and the reason it can't do that
because leaking to an evil server might
require a communication to network this
is side effecting right so we can't
actually allow this so this would not be
part of a peer function and it's that
that's great right like once we have
pure functions what does that mean well
it means we can't actually be data by
using pure functions so we can already
use a subset of Haskell immediately -
like a write code no we do need to talk
to the world and in order to talk to her
well you have to use distinct hole the
IO monad now how many of you have heard
of the IO monad alright so the audience
knows already
okay well just I guess as a recap for
those who don't ldiot monad is just a
way of encoding side-effect in code
right so here i have a function called
leak to evil server that i had in the
previous post a previous slide i mean
that takes a post and basically leaks it
to a server anyway it does this is by
using di a monad and he's a few a few
things called actions right so first he
would do say open connection then it
would actually say convert my post to a
string and then send a string to the
server and finally close the connection
to the server this is all made up but
the thing to take away is that the I
mode basically gives you a way to write
imperative code and
now the interesting thing about this is
that this is just declaring that you
want to execute and leak this particular
post in order to actually execute
something your i/o actions have to be
bound from the main symbol right so you
actually have to say somewhere that you
want to run this particular action and a
second interesting thing is that well
the Haskell type system forces you to
reflect the fact that you're performing
something said affecting and a type of
the thing that you're describing right
so in this case we have to say that leak
to evil server actually has type io
units so it doesn't return anything but
it's something that performs IO right
and and what's really important is that
the system doesn't actually have a way
of taking something else I hear
something and just converting it to that
something so there's no function that
goes from IO a to a and this right like
would completely let you bypass the type
system and do all kinds of unsafe things
okay well so we have pure Haskell and we
know that we can control you know the
yeah your actions that we want to
execute so to get security well just
don't execute any I action it's right
this is awesome we have 100% security
and you know can't do much so how do we
actually do something useful
well we define our own custom o-net
right and this is DL IO monad which
stands for labeled IO so it was just a
wrapper around yo monad but it doesn't
one additional thing and it's thing that
it does is it associates
a current label with IO computations
right so this type down declaring hero
IO a is just a function from an IRF
which is just a global variable of a
label to the actual IO computation that
we're going to perform and we're gonna
expose two different things in this IO
Mona atom so this in in defining Ramona
we're kind of declaring our language
right now our language for now contains
two things now one thing is get label
that would just tell us what the current
label is and then raise label which
takes a label and performs an action and
they actually ID performs it basically
just changes the underlying label that
is associated with the IO computation
now the point of this whole dis label
which again just encodes the readers and
writers
it's to reflect what we've read so far
in this particular computation right so
the label keeps track of what you've
read and when we define new primitives
well we can use this label to restrict
where you're actually allowed to perform
rights so let's like actually look at
that so suppose we want to extend our Li
AO language well okay sorry before I
actually get into that one thing that I
do want to point out is this Li OTC B so
it's really important for you to not
actually export this and we use
abstraction and safe haskell to do that
because if you can just get at this
particular symbol right like that will
let you execute arbitrary IO actions and
make them look like Li of actions we
really don't like to do that because
that would defeat the whole point of
this whole system okay so back to you
actually looking at how we restrict
reads and writes and how we enforce
information flow control well whenever
you're performing say an action that
would read something what we do well in
this case I have say reading a reference
we basically look at the reference of
that thing so in this case there would
be O and we raised the current label to
reflect that we're reading something dis
sensitive so that's what Ray's label
does and then it actually performs the
real read reference right so now our new
label when we perform Rito IRF will
include the fact that we've read this
particular reference and importantly
when you actually are performing rights
we want to make sure that you can only
write to places that would not make
information all right so when we say we
want to write you a reference well what
do we do we get the current label this
label again is a history of what we've
read and we want to make sure that this
label can actually flow to the label of
the thing that we're trying to write
here right so you can only write two
things that would respect this
particular label and this is what this
can flow see function does and if you're
now allowed to perform this particularly
right well we just falen throw an
exception okay so stepping back
what is the l io sub language well it's
the sender library that actually wraps
most of the haskell io library and we
have things like exceptions threads
references file systems and so forth but
additionally like all these functions
perform a label check before actually
performing the i/o underlying action so
you can think of us as a sub language
that gives you security and a sub
language consists of two parts one is
the standard library and two is pure has
all right so we can use pure Haskell's
and the Ohio monad to write our whole
kind of VC and NP computations right so
any program written in this particular
sub language can be considered untrusted
right because we make sure that
information flow control is actually
enforced whenever we perform any
individual actions and importantly the
type system is the thing that actually
restricts us that allows us to restrict
these untrusted computations to DLL
monad
okay so what do we get with this well
the two things first is our computations
are guaranteed to preserve
confidentiality and integrity right so
we can make sure that you don't leak
your data and you don't corrupt your
data and we have formal semantics for
business for this so I hope you trust
that that's actually true despite like
the hopelessness that Adam was talking
about earlier and to by writing code in
Li oh well you effectively have a
program that's secured by construction
right so if you don't use any of the
unsafe parts of the l io system like the
TCB stuff what you actually need when
you are sending i/o then we actually
have a guarantee that this will this
that the security on to you will keep
going though of course is a gotcha all
right and that's that you have to set
good labels right so if the label is
super missive then you have a
vulnerability and a general setting
labels has been a pretty hard topic and
the information flow control community
but one that we've actually managed to
start tackling so the hole and PVC model
that I talked about earlier that hale's
provides is a way to simplify policy
specification and setting labels in a
way that's automatic and doesn't
actually have to deal with these
particular level details but it seems
like we can actually generalize this to
other kinds of systems we've looked at a
few in the domain of client-side
applications and some other people have
looked at say IOT and so forth and it
seems like if you're actually looking at
how to structure your applications in a
way where you can specify policies on
data then you can use something like a
io underneath to actually protect its
data okay so to summarize I think we can
actually build secure systems but we
have to do so in a way that considers
most code on trust
right if if most code is untrusted then
that means that bugs in this particular
code won't be security vulnerabilities
and we don't actually have to convince
our developers into futile attempt over
actually writing bug-free code and the
approach to do this is well to separate
your policy and your security code from
your the rest of the application and
make sure that this policy is actually
enforced everywhere I guess thanks and
feel free to contact me and try out la o
or Hales and we're working on some new
stuff so be happy to talk and answer any
questions oh yeah
yes right so it is approach embeddable
in other frameworks the answer is yes so
we implemented Hales kind of with what
the whole premise of actually wanting to
build platforms like Facebook where you
have deliberately on like third-party
code but the whole model of just the
NPDC approach actually works elsewhere
so you can have solutely use that but
you still need something like Li o to
actually enforce the policies that
you're specifying in fact one of the
projects on the previous slide Elmo Ned
is doing exactly that
so I think can you take the basically an
information flow control mechanism there
are six to read and writes and tie it in
with other rounding frameworks yeah yeah
totally absolutely right so like what
one thing like you can just do is say
use the li o system by itself and run it
in your in your framework so whenever
you have a controller you can say this
controller will now execute an li o
action and I'm gonna specify the
policies somewhere else that will make
sure that when I execute the controller
those policies are she enforced all
right any other questions
cool thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>