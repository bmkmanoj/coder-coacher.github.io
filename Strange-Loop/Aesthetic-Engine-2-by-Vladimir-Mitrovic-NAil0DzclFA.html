<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Aesthetic Engine 2&quot; by Vladimir Mitrovic | Coder Coacher - Coaching Coders</title><meta content="&quot;Aesthetic Engine 2&quot; by Vladimir Mitrovic - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Aesthetic Engine 2&quot; by Vladimir Mitrovic</b></h2><h5 class="post__date">2017-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NAil0DzclFA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm glad Amir I'll be talking about the
static engine too which is an art
project image its generative data
sculpture and it's taking HTML data as
input and interpreting it in a in a
non-standard way so you can say that in
a way it's a web browser but it's an art
project so please take it with a grain
of salt so very quickly I'm a software
engineer from from Belgrade it's the
city famous for its nightlife and the
clubbing scene but also it's a city
filled with brutalist architecture which
is influenced me a lot both both as an
aesthetic movement but also as a
philosophical one so if you're
interested in breweries and this is the
organics tower in Belgrade also known as
the Western city gate it's pretty
impressive when you stand next to it I
have an engineering background so I
majored in computer engineering at
University of Belgrade and for the past
10 or 11 years I've been working
professionally mostly on on in rat
interactive software and games and also
some some work on distributed computing
and low-level networking code and 9/5
was ok but I kind of wanted a different
dynamic so two years ago I started doing
some some freelance consultancy work
which allowed me more time to focus on
the intersection of engineering and art
which is really what motivates me and
more specifically the computational the
design subfield I often found myself
between two camps
so for artists I'm a geek and for
engineers I'm a hipster and so I decided
to kind of go official and give give my
practice in this space a name and I just
named it after the architectural style
and what you see here is is a generative
logo I created and it's spelling out the
names spelling out two letters in the
studio name and this was my first take
on algorithms brand identity and
incidentally I wrote about the process
of creating this logo on my webs
so I live link to to everything at the
end of the talk and most of the stuff
I'll be talking about here is open
source so you can check out the the
github account
I was solely the link to at the end so
you can inspect the code and hopefully
find it interesting as a learning
experience
I followed the anti disciplinary
philosophy I don't know if you've heard
about it it's a definition I read in MIT
Journal of design and science which
which is a publication that started
coming out I think like two two years
ago and here's a quote by Drake Ito
interdisciplinary work is when people
from different disciplines work together
but anti disciplinary is something very
different it's about working in spaces
that simply do not fit into any existing
academic discipline a specific field of
study with its own particular words
frameworks and methods so in many ways I
think generative design and design in
general fits this description very well
and most of the time I'm trying to stay
away from definitions of how things
should be done which also includes this
definition as well so here's a very
quick overview of some of the past
projects that were conferred past years
so this one's branding campaign for the
Center for the promotion of science of
Serbia it's a government institution
which is promoting science to mostly to
young people and this was a branding
campaign which which included the
generative logo at its heart and it's
built the campaign is built around light
as the medium of cognition and as the
carrier of information and the logo
itself represents a light beam which is
bouncing off the walls of a visible cube
and shifting in frequency as it does so
so this was my this is my first
commercial project and it was sort of
getting my feet wet and in generative
brand identity then since I have like I
said some game development experience I
worked on as a side project on a
volumetric train engine which is a
terrain generator which is working with
volumetric shape definitions so it's not
using
your typical height field approach to
generating terrain but it's using using
only input parameters and lots of math
so in this way it's easy to define
overhangs tunnels arches and stuff
that's well let's say nonlinear and
that's not easy to represent which with
your typical height field terrain and
one of my more ambitious projects is
recursive city builder game it's the
city it's a game in which you build a
city on multiple levels so you build it
in reality and you build it in each of
its inhabitants dreams so you can sort
of drill down into the head of each of
its residents and continue building the
city there and it was influenced also by
the mechanics of of city population
fluctuations and a lot of the stuff
that's written in in Christopher
Alexander's book called a pattern
language which is sort of like which is
one of the most popular books general
books about architecture I suggest you
read it if you haven't seen it yet
sponeck means monument in serbian and
it's a game where huge concrete
monuments can protect the neighborhood
so that migration gentrification and
other human processes cannot destroy it
I worked on this project for roughly a
year and it was it was very intense
development I worked on it full time and
I needed I needed a break I needed to
work on on some other project for a
little bit and this is where first the
static engine was created so I wanted to
explore seeded generation so a static
engine one takes a word you type in as
input and then from that word generates
a procedure like does the procedural
procedurally generated 3d mesh and each
each 3d model that gets generated is
unique to that word so it's repeatable
so if you if you enter that word word on
another device you get the same
structure and this is where
sort of unknowingly I started exploring
data hurt and I really liked it because
most of what I liked about spawning
development was the procedural approach
to architecture so all the architecture
was created procedurally along with the
monument geometry and that's the part I
enjoyed the most so I decided I should
pursue this subfield in more depth and
this where I came across the term data
dramatization of course I immediately
liked it and at this in hindsight
I mean this probably describes my
approach to to computational design
pretty well and here's a quote by
architect Liam young it says data
dramatization as opposed to data
visualization presents the data set with
not only legibility or clarity but in
such a way as to provoke an empathetic
or emotive response in its audience and
my interpretation of this is that
accuracy is not paramount in in work
that I do but extracting your personal
perception of the data is and I'll talk
more about it later as this is basically
what the static engine to is is built on
so in this slight German of a new idea
started to form
I started looking at web data and how in
the beginning HTML was conceived as this
human readable way to describe web
content but it was sort of lost along
the way as as our as our systems became
ever more complicated we started
thinking about ways to to sort of hide
hide this complexity under more and more
layers of tools and what you see on this
screenshot is just a small subset of
google.com right click view source so I
wouldn't say it's humanly readable at
all so there there's this clash I think
of human understanding of what web data
actually is and what it actually is and
what the web data that the browser
ingesting actually looks like and I
wanted to sort of redisplay the actual
shape of this data as as its complexity
has now grown beyond human understanding
and aesthetically I wanted to continue
exploring vector fields and the vector
field for those of you not familiar with
the data structure it's it's in well the
technical definition is that it's an
assignment of a vector to each point in
a subset of space and you can you can
have many underlying representations I
mean you can implement them in in many
different ways and probably the simplest
one is to use four for the 3d case is to
use the three dimensional matrix so as
you know the matrix is a discrete data
structure but you can easily make a
vector field continuous if you if you
I'm sorry if you query the vector field
at at a random point in space and then
find the eight neighboring points at
which the vectors are defined and then
you use linear interpolation to kind of
figure out what the actual vector in
that point a space is so this is a very
simple visualization I think this vector
is a four by four by four matrix and you
could see here that I just interpolated
at a much greater resolution and it
stays smooth but I wanted a different
way to to visualize vector fields and if
you look them up online most of the
visualizations look similar to this most
of them are are even in two dimensions
which which is cool if you just want to
get yourself familiar with the data
structure but I wanted to visualize the
the actual structure of the field and I
started building this simple tool in
unity which is just taking a couple of
lines starting at at points very near
each other and then just slowly reading
each value of the value of the vector
field drawing a line to where the vector
is pointing and then moving the
current position to that position then
iterating across many lines so in my
opinion this this is visualizing the
flow of the field much better and I
could already see that field is not that
so this was a completely random field so
at each point in space I just generated
a completely random vector in space and
I could already see that it's not it's
not well it's not a smooth data
structure if you will so you see that
even though a couple of points are very
near each other as you start they
diverge very quickly as they they
encounter differently differently
pointed vectors in the structure so this
visualization enabled me to do some more
iteration and to just start start
drawing many of these lines to start
sort of get a feel for what the entire
field looks like or at least what the
subset of it looks like because I think
there's no there's no good way to
visualize this in its entirety because a
vector field is if you think about it
it's a volumetric data structure and
there's simply no way to to show all the
values in a huge volume of space using
projection in 2d space which is the
screen but I was sort of getting at
getting a feel about how how this looks
like and I was satisfied with with the
aesthetics of it I knew that there were
some problems I needed to solve so you
can see in a couple of places that there
are some vortices forming and maybe this
screenshot doesn't show it well but
there were cases where an actual vortex
was formed so you can just have many
many lines coming into this one point
and then the point was just for swirling
into itself so this very simple line
based visualization allowing me to
eliminate those problems early on and I
actually prefer doing doing very basic
visualization in the start because I
feel
that it's somewhat similar to what you
would do if you were trying to sketch
out the problem on paper so you just use
lines simplify it as much as you can and
try to abstract it away and it worked
pretty well so this was all done in
unity and I wanted to switch the the
technology stack I wanted to move to
move back to using open source tools
because at this point I was using unity
heavily for four years I think and even
though it's an excellent tool I I wanted
to use a purely open source set of tools
which I can drill down into and inspect
every every part of it so I just rewrote
the vector field enclosure script and by
the way yeah so static Engine 2 is also
open source so you can read as much of
this code as you can I won't go into too
many details here so as soon as I had a
representation in closure script I'd
just started sculpting the field so like
I said I immediately started to
eliminate those problems I encountered
with completely random fields so I was
here experimenting with the amount of
directional data that the field takes so
for example here as I'm generating the
field I'm I'm adding a configurable
Direction vector to each value so I'm
generating a random field a random
vector at each point and then adding a
direction vector of configurable
intensity to that to that value so using
this I could very simply tweak the the
flow of the field so if if you use a
very large value for the direction
vector the field war would basically
look like one direction field and I
wanted a good balance between those two
extremes and so after sculpting for a
while I was satisfied with how how it
looked visually and how it looked
structurally on the screen I mainly
wanted to to have the final piece
accommodated the the standard screen
aspect ratio so I wanted to have
sort of a left-to-right aesthetic and as
I said earlier I think there's this
clash of human understanding of web data
and what the machine is actually looking
at so I needed to to add some distortion
to this image like using this very
nice-looking flowing field
look just to tranquil to me I wanted it
to have more more visual distortion so I
used the second vector field which is
mostly pointing in an opposite direction
of the first vector field so and I have
two fields and then as I'm walking each
line along one of the fields at
configurable points in time I just
switch to walking the other field so
that I get the align these lines which
are switching in direction and tweaking
these parameters is its it seems it
seems interesting and I guess it is but
it takes much more time than then then I
would like because there's a playful
element to it as well you can just tweak
these parameters for this you know you
have to know when to stop and at this
point I wanted to give some more weight
to these lines I thought I was done at
this point with using simple line line
visualization or debug view as some
people like to call it and I needed a
way to produce three-dimensional
geometry around this life and by the way
if it wasn't I think it's not
immediately obvious but the static
engine too is the 3d sculpture so it's
slowly rotating in space even though the
the colors in the shading are sort of
presenting presenting it in a 2d way so
I was already using thing which is an
excellent computational design library
written in closure and closure script
it's I recommend you go check it out
it's insane how much depth it has and
the author is really cool guy so I was
using it for quite a while
and mostly for for vector math
rotations and stuff like that so like
low-level stuff which I didn't feel I
want to implement myself and it turned
out that he had an implementation of the
parallel transport algorithm which if
you're not familiar with it which I
wasn't when I encountered it I actually
asked the author of the thing library to
to help me and he pointed me to this
algorithm which of course he has had
already implemented anything and this
algorithm takes an arbitrary
two-dimensional shape and projects it
along an arbitrary three dimensional
curve in space so if you don't take a
curve you just take a simple line in 3d
space as an example and use a circle if
you project a circle along that line you
were you'll get a perfect cylinder and
fun fact since we're here I didn't know
this but two days ago I came I came
across I mean I saw of course the the
arch and when I was looking at at the
Wikipedia page it said that the basis of
each legs were equilateral triangles so
I thought well this is the parallel
transport algorithm it's just varying
the size of the triangle as it's
transporting it from one leg then
keeping the size ever smaller and then
increasing it again so this is the
parallel transport in in practice and at
this point I was sort of exhausting what
the the thing a library was was able to
give me in terms of the peril transport
algorithm book because in this example I
was just using like random randomly
placed lines in 3d space and using a
Pentagon and extruding it but that was
all I could do with with the
implementation that was there at the
time so I had to add a way to modulate
the size of the shape as it was being
transported along the line and
I've come to realize that in these these
types of exploratory projects that there
are often changes which are not general
enough to to justify a pull request and
sometimes it's okay to specialize freely
and because there is no such thing as
perfect general generalization
especially here if you think about the
parallel transport algorithm you can
always implement some kind of changes
which fits exactly your use case and
sometimes copy pasting code and just
tweaking it is working just fine I'm not
advocating I'm just saying that if
you're doing exploratory type of work
you have to do it and some point and
then it's your best judgment if you're
if you think that the changes are are
good enough to be put into a pull
request and by the way incidentally the
thing library doesn't seem to be very
maintaining the moment so I'm currently
treating it as as a snapshot of time in
time and just using using code from it
and iterating it in my own code so after
breaking the ice with those first
parallel transport mods I continued
adding more variation so for example I
added the ability to rotate the 2d shape
as it's being projected along the curves
so it all the way on the left that read
that fat red line you can see that it's
actually ending in an angled way that's
because I'm rotating the the rectangle
that's being projected from minus 45 at
minus 45 degrees that starts towards
plus 45 at the end so I could achieve
this kind of felt tip marker aesthetic
in 3d space and this was a period of
much iteration so I spent a lot of time
of iterating on the parallel transport
code they added I added the brush
capability so I wanted to be able to
express the type of shape that's being
generated in a more abstract way
so I created a couple of brushes so to
speak which are defining the shape
that's being projected the resolution at
which the curve is being sampled and
some other parameters so you can see
here I already have like thin lines
thicker lines triangular shapes
rectangular shapes being projected and
so on you might not see it but I do
and this was the moment that the really
hard part needed to be done this was a
big to-do on my list and I think it's a
big to-do on on every project I work on
I experimented with the black and white
except aesthetic for a little bit but in
general I feel that the time running
away from the problem whenever I switch
to black and whites and I can easily I
can easily make a piece look good I mean
it's a it's a personal preference of
course but to me it can look good easy
in black and white and generating
randomly generating random palettes in a
controllable way is a hard problem and I
already try to solve it with the static
engine one I had a palette head working
power generation code written in C sharp
which is another lesson I learned during
the years that you shouldn't attach
yourself to one language or platform if
you're doing any kind of exploratory
work because that platform either might
not be suited for a critical problem or
it might become outdated over time the
only thing that I I inherit from
projects along the way is my
understanding and the processes in the
algorithms not the code itself I think
that rewriting code in in another
language is the most trivial task in any
project so you already have another an
algorithm written in another language
you know how it works you just need to
write the code so I could have spent a
lot more time on perfecting this C sharp
infiltration but
I haven't and I wanted to try a
different approach I wanted to step up
the game a little bit I was thinking
about making a machine learning model
and teaching it the pallets I liked so
creating some kind of a training set
which would overtime train the model to
have the same taste if you will as me
and and then later on if when I build
the model I can just submit randomly
generated pallets into it and it would
know to classify it as good or bad I
thought about using neural networks at
the time I was finishing the machine
learning course on Coursera and I needed
a real world that world exercise I was
also reading a book which I forgot the
name exactly about neural networks it's
really good and it's open source and it
has and it has the reference
implementation of everything in in
Python so I thought maybe I can write a
feed-forward neural networking enclosure
as an exercise and then also use it to
to build a color palette learning - so
that's what I did I wrote it and along
the way I just checked it against the
the reference Python implementation I
know there are a couple of closure
libraries for this but I specifically
wanted to write from scratch just as the
learning experience so if I were to do
this again of course I would use an
existing library so I built a small tool
which on the right you can see it
generates random three color palettes
and I also for each color I add just a
little bit of of variations so that for
example not all blue colors are exactly
the same blue they vary just a little
bit but I thought that it gave you more
visual fidelity of the image and I could
perceive the palette in a better wave if
I had these variations and
so I built this talent - I just manually
entered yes no yes no - each color
palette that came out and the colors
were generated completely randomly which
later turned out to be a problem but I
had around 2000 training samples of
these three color palettes and I started
feeding in them into the network of
course a subset of it there's a training
set and then the rest of it was the
validation set and then you can see that
in these first experiments on the left
there the error rate starts to go down a
little bit and then it just starts to
oscillate widely and it never actually
goes to - a satisfying error rate which
is zero of course so I couldn't get the
error rate down and I even went so far
as to make a separate tool that
automatically generates these meta
parameters so if you're familiar with
machine learning terminology meta
parameters are the parameters you use to
build the architecture of the neural
network and then the actual parameters
are what the network learns along the
way as if you're feeding data into it so
I made a separate tool - to generate
these meta parameters run the learning
process figure out the learning error no
make a note of it then generate another
set of parameters and then I could kind
of have brute force way C which which of
those was tending to to give smaller
error rates and some of them worked
obviously better than others but I could
never get the error rate to - to
satisfying levels and I started thinking
that maybe my neural network
implementation was wrong so I built a
separate red color classifier which is
you on the bottom right and I just made
it a one input neural network and I just
generated one random color and I said
yes only on red colors and all no other
colleges I said no and you can see the
that's the way the error rate should
look like so it should learn over time
to classify red colors and at this time
I just gave up so it was a tough
decision but I just couldn't couldn't
spend any more time on it and I dug
around some machine learning forums and
with people having similar problems and
it turns out that the color space the or
rather the input parameters faced for
three color palettes and for only 2000
training samples is very large so if you
think about it each color has three
color components so for three color
palettes that's nine input parameters
but if you look at each of these
parameters they are pretty much quasi
random when you look from one sample to
another
in hindsight I I should have probably
only trained it to generate for example
bluish palettes then maybe the inter
parameter space would be more focused
and then maybe the the neural network
could learn could learn more more
precisely but I didn't feel like
generating more training data because as
you can imagine for 2,000 parameters
it's it just takes a lot of time so I
moved on from that I went back to
geometry I started adding data
classification I introduced four classes
of data header which is your typical
HTML header Dom nodes then content which
is all visible all all elements which
are visible to the user so things like
paragraphs images input fields and so on
and a header is visualized as these red
lines in this image like forming the the
backbone of the entire structure and
contents are these larger triangular
shapes because I wanted them to be more
prominent in the visualization
I also added the scaffolding class
which which are these slightly thinner
lines which are emanating from the
center and then just going in one
direction towards the outside and
scaffolding is the class I invented just
to have miscellaneous nodes which don't
fit into any into any other category and
one other class was the external nodes
which is all the CSS and JavaScript
files you encounter as you're reading
the webpage and this image probably
shows it better so the the external
lines are the ones which are wrapping
around the structure because I wanted it
to feel as if all those JavaScript files
are keeping keeping everything in check
you know so I had classification in
place and it was time to proceed and
iterate on both the geometry and the
colors try out various color palette
approaches and geometric and structural
parameter combinations and I had to take
him to consideration a very wide range
of inputs because as you can imagine I
am not under control over which which
data comes in so the way aesthetic
engine currently works is it reads it
has a couple of predefined sites it's
reads it startup and then once you hit
spacebar it just takes a random link and
it's found inside the web page and goes
to that link so it's a one-button web
browser and you cannot anticipate how
many nodes there will be there are some
pages which have just like three nodes
in it and there are monstrosity is like
youtube.com which is just insane mess of
lines it looks like a hairy cat so and
all of these all these input parameters
have to look good so I spent some some
time on on on modifying the way geometry
is placed so they always occupies the
the so it doesn't go off screen and this
process is
never really completed so you can
iterate however long you want and it can
give good results five times and then
the sixth time you get something
terrible and you're like I can't let
people see this monstrosity I have to
fix this so this this process took like
I think two months way longer than I
want it of course this was all part-time
work I didn't work on it full-time and
feeling like 90% satisfied I packed it
up and shipped it so these are couple of
screenshots of what the final version
looks like
so that's roughly how I made static
engine 2 and this is the URL at which
you can check it out you can download
pre-built binary which I have for all
three major platforms it's written in
CoffeeScript and WebGL and it's using
electron as the host I didn't want to
embed it into a web page because of all
the cross-site tracking stuff and I felt
that it will look better as a standalone
project so I encourage you to read the
code it can be educational especially if
you walk through get history you can you
can see my terrible comments of course
but you can you can see how it was
evolving over time and so I just want to
spend on a couple of words regarding my
next project which since you're here you
might find interesting
so I'm again exploring the the
mechanisms below our threshold of
perception and I'm continuing down the
path of sacrificing visual visualization
accuracy and the heart information that
can be gained from it and for the
increased perception about the shape of
data that's being observed while
hopefully dramatizing it along the way I
also be exploring the different orders
of system perception which is somewhat
philosophical topic I wrote a short
short post on on my websites so I
encourage you to read it if you're
interested in philosophical topics and
to quote Bruce Schneier surveillance is
the business model of the Internet so in
this project I'll be turning the lens of
surveillance back on 2/3 of the existing
massive algorithmic systems which are
observing us and the first piece which
you saw on previous slides and this
light here it represents detailed
network routing graph of a certain
company which specializes in the social
graph and the other tools they're still
in the very early stages of
conceptualization so I'm planning to
show this triptych in a gal
in spring of 2018 and I hope I'll see
you there thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>