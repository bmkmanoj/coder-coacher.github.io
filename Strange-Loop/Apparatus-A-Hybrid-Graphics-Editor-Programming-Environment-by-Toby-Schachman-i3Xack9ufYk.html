<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Apparatus: A Hybrid Graphics Editor / Programming Environment&quot; by Toby Schachman | Coder Coacher - Coaching Coders</title><meta content="&quot;Apparatus: A Hybrid Graphics Editor / Programming Environment&quot; by Toby Schachman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Apparatus: A Hybrid Graphics Editor / Programming Environment&quot; by Toby Schachman</b></h2><h5 class="post__date">2015-09-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/i3Xack9ufYk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so how do we
Munich eight mental models so if I have
an understanding of some system how do I
communicate that understanding to other
people well we have various forms of
media for doing this you can write an
article draw a picture give a
presentation make a physical model write
a computer program all of these
communication media are also thinking
media so I can use these media to
communicate with myself so the process
of making any one of these things
develops my own understanding further
lately I've been really interested in an
emerging medium of interactive diagrams
interactive diagrams are pictures that
move pictures that respond to a view of
viewers interactions and I like these
because they can help you develop a
geometric intuition for the system that
you're studying they can help you
explore a parameter space
interactive diagrams can help you
understand causality in a system
they can help you understand
relationships within a system how does
one part affect another part if I change
one thing how does that affect all the
other things interactive diagrams can
explain a process
and interactive diagrams can help you
see connections between multiple ways of
looking at a system
today people create interactive diagrams
by writing code I claim that this is
problematic for several reasons first of
all there's contact switching so when
I'm writing code I'm thinking
symbolically but when I'm designing a
diagram when I'm sketching it on paper
when I'm playing with the diagram I've
made to see if it looks the way I want
it to look what figure out what I need
to change all of this all of the design
of the diagram I'm thinking spatially so
in this process you're constantly
switching back and forth between
thinking symbolically and then looking
at your diagram in thinking spatially
and I think this context switching could
be better supported second there's a big
disconnect between viewing and authoring
so if I find a static picture that I
like and I want to modify it or build
off of it it's easy for me to draw on
top of it or collage it in Photoshop and
make a new picture out of it but if I
find an interactive diagram on the web
that I like well maybe I can download
the source code but now I'm faced with
this huge obstacle of understanding the
source code and finally writing code is
difficult and it takes a very long time
often hours or days so in this talk I
will be presenting some new work
apparatus apparatus is a hybrid direct
manipulation graphics editor combined
with a dataflow programming environment
and in this combination apparatus
supports both spatial thinking and
symbolic thinking and it also helps both
of these modes of thought support each
other there's a gradient between viewing
and authoring the interactions that you
use as
viewer interacting with the diagram
drag-and-drop are the same as the
interactions you use as an author
editing a diagram also drag and drop and
finally apparatus aims to bring the time
scale for creating these interactive
diagrams down to minutes rather than
hours
so here I have apparatus it's a direct
ment of English and graphics editor so I
can have shapes and move them around
resize them the shape that's selected I
have an inspector that shows me all of
the attributes of this shape and I can
change these manually within the
inspector and I can also write
expressions in here so I can say 1 plus
1 and then apparatus says that's 2 and
it makes the scalex of the circle two
expressions can also reference other
attributes so I can say 1 plus scale Y
and now when I change scale Y scale X
changes accordingly these references can
go across shapes so I can take this
rectangle and say I want scale Y to
control the rotation so I change scale Y
the rectangle will rotate so this is
data flow it's like a spreadsheet and
like a spreadsheet it has to two really
nice properties for one there is no
hidden state so all of the state is
there it's always visible and second
this editor is live meaning that there's
no separate edit mode versus run mode
there's no compile button there's no
play button you're always both editing
and playing and if you think about it a
graphics editor also has these two
properties there is no hidden state and
there are no separate edit mode versus
run good
so I'll do an example
so I've drawn this this face and this
this outline shows me all of my shapes I
can label them and reorder them things
like that
so we've seen how shapes have these
attributes we can also create custom
attributes these are called variables so
I'll make a variable called surprise and
I'll use that to control the mouth scale
Y and let's also have that control the
size of the eyes
so what we've done here is essentially
created a program that's procedurally
drawing a picture and it's drawing it
based on this parameterization of this
this variable called surprise
incidentally this is a structured editor
so there's you can for example rename
any of these variables and everything
else just renames accordingly in a text
editor of course you'd have to manually
somehow change all these references so
we've seen how to procedurally draw a
picture now how do we add interactivity
to the picture well the picture is
already sort of interactive in the
editor in the sense that if I - if I
were to click and drag on a shape it
moves around so that's a form of
interactivity but this this is just the
default interaction so you'll notice
when I put my mouse over the shape the
the X&amp;amp;Y attributes are highlighted in
red because it says these are the
attributes that are going to change when
I start dragging what I can do is click
on this control circle and now when I
highlight over the mouth this wow
variable is highlighted in red and when
I drag on the mouth that variable will
change so this control mechanism is very
flexible
so here I have an example that has three
variables that are controlling the
shoulder elbow and wrist joints of this
arm linkage and I can select the hand
and then have it control any of these
variables so I can make control wrist
and then when I drag it wrist will
change or I can make a control elbow
when I drag it the elbow variable
changes our shoulder or it can make it
control all three of these
so what apparatus is doing to the way
that this is implemented is with
numerical minimization essentially when
I click and drag on a shape apparatus
says okay I'm allowed to change these
three numbers how can I change them so
as to minimize the distance from the
current Mouse position to the shape
that's being dragged so as I drag it's
solving this minimization problem and
then adjusting the attributes so this is
very flexible for example I can make all
of these variables have the same value
and then when I drag the solver just
knows what to do
so next I'm going to talk about reuse so
in code we we can reuse a chunk of code
by wrapping it in a function and then
calling that function in other places or
we can use like objects and classes so
we can put a method on a class and then
all of the objects will inherit that
class so this is how you do that kind of
reuse in apparatus so you'll notice that
all the diagrams we create there's a
little icon in the create panel that's
made for every diagram so if I make a
new diagram to reuse this face I can
just drag it right out
and each of these instances is it's sort
of like a copy of this master shape the
instances don't affect each other so I
can change the surprise of one and it
won't affect the other one and they also
don't affect the master I can even open
these up so I can take this face and
open it up and see maybe I'll change the
the head the color of it and I'll make
it like that so so light copies you can
change anything about them it's like you
copy and pasted some code however it
changes to the master get inherited by
the instances so if I go back to the
master and I take the these eyes and I
make them white instead of gray then the
instances inherit that change structural
changes get inherited as well so I can
add some more shapes
I'll make some pupils for the eyes
and then both of all those changes get
inherited by the by the instances
changes don't get inherited if they're
essentially overwritten so it's like
prototypal inheritance so if I change
the the surprise of the master then
that's that's not going to affect the
instances because I've overwritten
surprise in each of the instances
likewise if I change the color if I
change the color of the master well then
this one inherits that change because I
haven't overwritten the color but but
this one keeps its color because I have
overwritten the color so this this form
of reuse is very handy for creating like
reusable widgets so if I wanted to make
like a slider
well a slider is just a there's like a
track and a handle and the slider has a
has a parameter that's its value so I'll
set the handles exposition to be that
value and it'll make the handle a
controller for value so now I can drag
the handle back and forth and the value
will change and then I can reuse that
slider so I'll put three of them out
here and I'll make a I'll make a color
picker so a color picker just has three
sliders it has a red slider green and
blue and it has a swatch that's going to
show the current color it has a variable
called color that's an RGB a value of
red green blue alpha component of one
and now I'll use that color for the fill
of the swatch and now I have a color
picker
so then I can use these anywhere I want
so maybe I'll bring a slider out and
have it control the surprise of the
faces maybe I want one face to be
surprised and the other one not to be
surprised so I'll do one -
can bring out a color picker and use it
for use it to change the fill color and
then a color picker for for that face
over there so sort of a future
trajectory I think of apparatus is
moving towards sort of bootstrapping the
editor within itself so this this
drag-and-drop
you know I've you can make you can make
sliders which control you know maybe
this is a thing that's for interacting
with the diagram as a viewer of it but
but these things are also useful as an
author of the diagram I can I can use I
can use these interactive widgets to
edit the diagram itself so there's this
is what I'm talking about it's there's
no separation between the viewing
experience and the authoring experience
there's a gradient between viewing and
authoring viewing is just dragging fewer
things than authoring
all right so now I'm gonna talk about
looping looping and apparatus so if I
have a rectangle here I've got these
attributes that I can change and
attributes can be singular values like
zero or they can be they can be spreads
and so I'll show you what a spread is if
I say spread zero to ten what this does
is it makes on essentially ten different
values so rather than X being just one
value X is now simultaneously zero one
two three four up to nine and apparatus
will draw the square for each of these
things so then I can reuse that so I
take this X and I'll make it control the
scale Y and then you get something that
looks like that right so they're ten X
values and ten scale Y values that are
that come in pairs you can say x times
two and it'll do what you expect or sine
of X spread also has an increment
optional third parameter so I can say
spread zero to ten by 0.5 and then
that'll say zero zero point five 11.5
etc I'm going to break out that
increment variable
and I'll set the scale x2 it so this is
how you'd make a bar chart
an interesting thing about spreads is is
how they combine so so I've used one
spread and I'm using that to control the
the X of the rectangle and also the
scale Y so it's essentially there's one
four loop you could say that's
controlling both X and scale Y if I
write in another spread so if I say I
want Y to be spread zero to four this
will do the cross product of the spreads
so you can think of it like two nested
for-loops
so that means that there's a difference
between referencing a spread and
creating a new spread so for example if
I have if I want to make a grid I can
say spread zero to five and that'll make
my rows and then I can say spread zero
to five for y also and so that makes a
grid right but that's that's different
having these two separate spreads it's
different than reusing that spread right
because then this will do sort of the
component-wise version of it so spreads
were created to answer this question of
you know you sometimes you have some
variable and you scrub it and you say oh
that's really interesting it's really
interesting how the picture changes as I
move that variable around and you want
to see all of the versions of that so so
you just take that variable and you say
spread and then you can see multiple
versions of it so it's sort of implicit
looping and spreads can also be used to
plot functions so this rectangle if I
open it up I can see that it's actually
made up of four anchor points
that I can move around so so really
rectangle is just a it's just a path of
anchor points so I can delete those and
I have a triangle so if I want to graph
a function I can use spreads essentially
what I'm gonna do is I'm just gonna
spread an anchor point so I'll take this
anchor point and I'll say I want the X
to be spread 0 to 10 and so that's gonna
make 10 anchor points and then I'm gonna
set the Y to be sine of X right so then
this is taking the 10 anchor points that
are distributed along the x axis and
moving them to be sine of that value I
can turn off closed path and get rid of
the fill let me make it a little thicker
and then if I want more precision I just
put in an increment write that so then
so now I have a hundred anchor points
going from zero to ten that are graphing
this function so that's how you would do
a Cartesian graph in apparatus
so those are the the fundamental
features of apparatus now I'd like to
show some examples that were created in
apparatus so last week at my lab we had
a little micro Jam we had got her bow
doesn't have a sat around a table for
two hours and played with apparatus and
you know to see what we could make so
I'm just going to show a few of the
things that came out of that that
session
so Brett Victor made made this one I
think it shows sort of the expressivity
you can get out of apparatus if that's
what you're going for Josh Horowitz made
this diagram of a cycloid do you know to
cycloid is so if you take like a a
bicycle wheel and you put attach an LED
to one of the edges and then you roll
the bicycle wheel then the LED will will
trace this path so I like this one
because I think it's a really good
example of how spreads can be used so so
Josh had started with with with this
diagram that just does that and then he
said well I want I want to see what
happens when that gets traced so the
answer is well you just use a spread so
you take that progress and say will
spread zero to ten so now I can see ten
different values of that and change the
increment and so the few modifications
and you and you get it to to this
Paulette Abe made this diagram of a bike
and you can pedal it and it moves you
can also change the gear ratio so you
can change the size of the gears and
then as you pedal it it'll move
differently so Paula made this and then
Josh saw it and he said oh that reminds
me of a puzzle so this is the puzzle so
you you have a bike you you tie a string
to the pedal like this right and now
you're gonna pull on the string you're
gonna pull backwards on the string and
the question is does the bike move
backwards or doesn't move forwards so
I'll give you a moment to think about it
all right so the options are it moves
backwards and moves forwards or it
doesn't move at all so how many people
think it moves backwards all right how
many people thinks it think it moves
forwards and how many people think it
doesn't move all right so a range of
responses most people think it moves
forwards so we decided to try it out
with our model so we made the pedal a
controller so now I can take it and I
can drag it backwards and the bike moves
backwards
I'll do it again so take the pedal drag
it backwards and the bike moves
backwards if you're not convinced I
encourage you to try it with a real bike
which is what we did at the lab there's
also this video right so so it's sort of
this this balance of forces like you
know you think that you're pedaling the
bike clockwise so you think that that's
you know really go forward when you do
that but but the bike also you're also
pulling the bike backwards so which
which of these two forces is acting in a
stronger way it turns out that the gear
ratio is actually important for this
problem if you're in an extremely low
gear like you're going up a really steep
mountain then when you pull the pedal
backwards the bike actually moves
forwards so it snaps around because the
numerical solver is finding solutions
over there but anyway you can you can do
this and it turns out that that what
matters is the the gear ratio on the
bike compared to the ratio of the wheel
versus the pedal so the radius the
radius of the wheel compared to the
radius of the pedal and so when the gear
ratio exceeds that other ratio it the
bike gets pulled backwards otherwise it
goes forwards so we can actually see
that happening so I made this other
model where I just took the bike diagram
I made a spread of it so I've got I've
got six bikes here and you'll notice
that this
that gears getting bigger and bigger as
I go down so I'm testing out a bunch of
gear ratios all at once I can pedal them
all simultaneously so you'll see that
the bicycle is with the higher gear
ratio move forward more with the same
amount of pedaling and I've I've drawn
this red reference line here that shows
the starting position of all the of the
pedals and then what happens is if I if
I drag this of just a little bit so if I
just pedal just a tiny bit you can see
that the bikes in the lower gear the
pedal is now behind that original
starting place whereas the bikes and the
higher gear the pedal moves forward more
so they all started here and then the
the lower gear once they move behind the
one at point five that's that's where
the the ratio of the pedal to the wheel
is exactly equal to the gear ratio in
that case the the pedal moves straight
up so in this one the pedal moves
straight up on the on the initial
pedaling
so to sum up apparatus is a graphics
editor combined with a programming
environment you use the dataflow
programming environment of it to
procedurally draw the picture so that's
a case of the symbolic thinking
controlling the spatial thinking so
you're using algebra to drive geometry
then you also set up these controllers
where you can now drag a shape and then
that moves moves your diagram so if the
algebra is setting up the state space of
your diagram its setting up all of the
possible states that your diagram could
be in then when you drag the geometry
it's moving through that state space
so that's geometry driving algebra and
this is how it unifies the symbolic and
the spatial way of working you can do
reuse I guess I didn't mention that this
is this form of reuse is coming from
Jonathan Edwards sub-regional subtext
paper and I think it's called call by
copying in the paper and it's really
nice because it's is essentially like
you're copying and pasting right you can
change anything that you want about the
instance but it's still inherits changes
you make to the master and you can't do
that with textual programming languages
you really need a structured editor so
imagine if you had you know your code
and you you copy and pasted one bit of
code and put it somewhere else and you
made some modifications to it and then
you changed your original code there's
it would be really messy to try to
automatically propagate those changes to
to your instances right to the to the
version that you pasted but you can do
it if the editor is sufficiently aware
of the structure of your program and
then this reuse enables you to make all
these widgets that you can reuse
and you create this working environment
where it's the same viewing the diagram
feels the same as authoring the diagram
so this is just a gradient between
viewing and authoring for looping we use
spreads which enable us to see any given
variable or attribute across a range of
values and finally I showed some
examples which I think demonstrate that
apparatus is not only a communication
tool but it's also a thinking tool so
you can use apparatus to to simulate
systems you can perform experiments in
it
apparatus not only is useful for
communicating the answer to a problem
but it's also useful for generating
questions as we did with the bike
diagram so apparatus is free open source
it is on the web as of late last night
it's on github I would sew sew apparatus
has gone through many iterations over
the past year or so so I'm really
excited to finally be releasing it
publicly I'd love to hear your thoughts
on it I'd love to see diagrams that you
create in it there's a there's a mailing
list there's a Google group for it and
if you're interested in working on the
editor
I would love to collaborate on github
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>