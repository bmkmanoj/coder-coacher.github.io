<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Kotlin: Uncovered&quot; by Victoria Gonda | Coder Coacher - Coaching Coders</title><meta content="&quot;Kotlin: Uncovered&quot; by Victoria Gonda - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Kotlin: Uncovered&quot; by Victoria Gonda</b></h2><h5 class="post__date">2017-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_qQ6fchwKfM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's good to see you all here this
morning I am going to be talking about
the common programming language and what
we can learn from it um from decompiling
it's by code a quick note before I get
started I do have my slides tweeted out
um at T tuganda if you want to follow
along or reference them later on alright
so a little bit about me I'm a software
developer at collective idea we are
consulting company based in Holland
Michigan we provide custom software
solutions for our clients
becoming a software developer was a
little bit of a surprise for me I
thought I was going to be a dance
teacher so it's funny how those things
work out when I got started with
programming one of the things that
interested me the most was all the
different programming languages when I
was a computer science student one of my
favorite classes that I took was the
programming language design and
implementation so did I enjoy
programming in snowball not really but I
did find it really interesting and have
I written in law code just for fun I
most definitely have languages have
always fascinated me and programming
languages have fascinated me in the same
way so when I found out about Kotlin I
was really excited to try it out I
didn't really have much enough of an
idea of what to expect going into it but
I came out rather impressed and now I
would take working with Kotlin over Java
any day so what is collin seems like a
good place to start on the website it's
described as a statically typed
programming language for the JVM Android
and the browser so let's dig in a little
bit more into what that means it
statically typed so we get the same type
safety as we do when we're working in
Java we also can get some great
autocomplete
it's statically evaluated so that can
inform the IDE about what's a lot what
makes the type system different is that
the types can be inferred we don't have
to specify what type of variable is if
it's clear so in this example we're
assigning the string Victoria to name so
we can leave out that it's a string just
say val name Victoria instead of final
string name equals Victoria null safety
is also built into the type system the
nullable and non null annotations can
only get you so far in Java with the
types of system built-in we always know
if something could be null and the
compiler forces us to check for it this
means we run a much lower less risk for
null pointer exceptions it's one thing
to run something that you just wrote get
the exception know exactly why I
happened of course you've forgot to
assign that variable it's another when
you're in uncharted territory you're
working with an outside API or some
legacy code and you're not sure where
your null pointer exception is coming
from or even worse your user finds it
those I could definitely live without
some other goodies I like about Kotlin
are the boilerplate reductions and the
functional language features if you
haven't heard count line is much more
concise than Java
but it's compact in a good way it's not
necessarily terse the way some other
languages can be written where they can
be written rather unreadable like this
Perl example you'll see lots of examples
of how Kotlin can be delightfully
concise it was also developed by
JetBrains so you know you're gonna have
some great tooling
my primary editor these days has been an
Android studio and then there's also
some really great support in IntelliJ
and then if you're an Android developer
you should be excited about the
announcement at Google this past Google
IO that they're supporting Kotlin for
Android and then what's important to so
many people is that it's a language for
the Java Virtual Machine
it also targets native and JavaScript
but in this talk we're going to be
focusing on the JVM kaolin is completely
interoperable with Java you can seem is
pretty much seamlessly called Java from
your Kotlin code and Kotlin from your
java code it makes it really easy to use
the Java libraries you're already
familiar with when you're working with
Kotlin we both compile down to bytecode
for the JVM to run which brings us to
the main point of this talk because
Kotlin compiles down to bytecode we can
decompile that bytecode into Java we can
do this really easily in Android studio
or IntelliJ and I'll show you how to do
that at the events talk I started out
trying to decompile this bytecode kind
of outta curiosity and for fun but I
discovered a lot from this and it helped
me better understand Catlin I also found
that it also helps describe the
performance in size in method count
implications of using Colin I was in 2d
compiling Colin through this blog post
by theother about Colin delegation and I
was really excited about the delegation
but possibly a little bit more excited
about this d compilation thing and I'll
show you his copy printer example in a
little bit but first I want to cover
some other basics so by the end of this
talk we're going to look at data classes
null safety delegation class extensions
and lambdas so let's start with a simple
class this is the first kind of thing I
ever tried decompiling
let's take a user with a first name and
a last name both of them strings let's
say the first name is non null and
immutable so we can't change it and the
last name is mutable and nullable so you
can change it at any time and it could
be tensional and here's what that would
look like in common we have the class
name and some properties
um there's Val and var making it the
property's immutable in mutable
respectively and then we have a question
mark after string for last name marking
it as nullable already we can see how
much Colin does for us it's concise with
just the information that we need so
let's put the bytecode for this through
the d compiler and the result was all of
this some things are what you might
expect if you're familiar with working
with Java but let's break it down and
look at each part the first thing to
notice is that the class is final by
default so we can't extend it limiting
inheritability it can make our code less
burdensome to maintain in the long run
and having classes by final by default
could introduce a slight bit more
legwork if you do want to extend things
you just have to mark it as open but
generally it's worth it and then we have
the fields there private by default
which is pretty great first name that we
wanted to be immutable is marked as
final and then we have the nullable and
non null annotations and then we have
the constructor notice the first line of
the body it's check parameter is not
null null ability is built into the type
system but it could only get you so far
such as if you're calling some colin
from java java doesn't have that type
that null save typing system so Kotlin
does a check for us to be safe just in
these cases and we can take a look at
that method and
we can see that it explicitly points us
to exactly what it is that's not exactly
what parameter so that we can quickly
find it and fix it I often find B stack
traces easier to read because we have
that exact variable it's find it faster
and if I have to live with nulls
this is the way that I want to do it on
top of that we have our gutters and our
setters so there's so much less code
service we have to worry about notice
that they reflect the mutability there's
no setter for first-name we also see
that it includes the knowable and
nominal annotations you will keep seeing
these everywhere okay that's great but
we can get even more by making it a data
class and we do that just by adding that
data keyword to the beginning of the
class declaration so are you ready for
this yeah
all of that we have everything that we
had from before plus some new parts so
we're just going to look at the new
things we have ordered components for
each of the attributes so component one
for first name and component two for
last name these are used for
destructuring class declarations we can
use that to break down a user into the
different parts this feature can be
helpful with in lots of different places
on one example is in loops if you're
looking through a list and using all of
the properties on that object we also
get a copy method which can be really
useful if you're working with immutable
objects for copy there's also a
synthetic bridge method what we really
care about what this is what it means
for us it makes it so that developers
can choose this they want to modify a
property when they're copying it or just
make an exact copy so that means we get
all of these options for copy make it
exact copy change one of the attributes
change both of the attributes
we also get a - straining it that
clearly includes all of the properties
it's very simple and helpful and then we
have hash code how it calculates it it's
less interesting that it gets it right
is what I'm interested in I don't want
to have to worry about hash code and
with this I don't have to and then we
don't have to worry about equals either
we get that for free so we get all of
that from just four lines of code and
those four lines could really be
condensed down to one one more thing
before moving on from classes is that
you can default declare default values
here we're saying that if a value is not
provided for first name then you can
default to use the string Victoria in
this creates a synthetic method similar
to what we saw with copy we compare
default values with named parameters as
sort of a substitute for builders here's
an example we're clearly creating a user
with just the information that we care
about we're leaving first name off so
it's going to default to Victoria in the
past we were using Lombok for our
getters and our setters and our builders
and by switching over to Colin we were
able to completely eliminate that
dependency cool so you've seen how Colin
takes care of data class boilerplate
boat about null safety it's one of the
biggest things we hear about when people
talk about Colin already we see how it
checks some parameters but what about
those forced null Chuck's and what are
our options for dealing with those you
notate that something is knowable with a
question mark so if there's a question
of mark its nullable otherwise you're
safe
it's kind of similar to Swiss optional
if you're familiar with that there's
some similarities if you don't check a
nullable variable for null
before you use it it just straight up
won't compile so here maybe string is
nullable it's marked with a question
mark after string but we're not checking
for null before we call that length on
it so there's a compiler area because we
can't compile this one we can't
decompile it so let's look at a
different example this is the safe call
operator that's the question mark after
maybe string before dot length what this
does is it performs the call if it's not
null and returns null otherwise it's so
much nicer than wrapping a whole bunch
of things and if not null block so let's
decompile this one this is the result
but it doesn't exactly make sense if
maybe string had been null this would
clearly crash when ID compile this I was
confused for a second but then I was
reminded of the work that the compiler
does for us so let's see what happens
when we really don't know that value
will we get that null pointer exception
let's find out here we're calling a
method to assign a string to or null to
may be string and then calling that
length on it ok so it is adding the null
check the compiler just knew in the
previous example that it could not
possibly be known we were assigning a
non null value a string to in a mutable
variable so it knew that it couldn't
possibly know and it removed that extra
check for us if the compiler is doing
this for us
imagine what other things that it's
doing for us ok so if you really really
really like null pointer exceptions and
you can't imagine living without them
that's the turning point if you decide
to move to Kotlin or not don't worry you
do have options you can use a double
bang with this you can get around those
pesky
compiler
Aires and just call your method on that
variable well there's not null or not so
you can get your nullpointerexception so
here it is when we D compile it into
Java no doubt we'll get our null pointer
exception it explicitly does a check for
null and throws that exception if it is
not a couple other null safety options
we can combine the null save call
operator with higher-order functions
such as let for null safe scoping by
doing so we can pass an entire code
block less dependent on that value not
being null here if maybe string is not
null it is assigned to a variable it and
then call dot links to it otherwise it
returns null it's a little bit
unimpressive for the small example but
it's really helpful especially when you
have multiplying blocks of code so when
we do compile it it uses a ternary to
check for null it returns the length of
it's not null and all otherwise if we
had passed in more lines to that block
that you would have used on an if
statement instead of a ternary and then
the last null safety operator or the
null safe option that we'll look at
today is the Elvis operator and if you
turn your head on your side you might
recognize the familiar face but with it
we can easily give an optional value if
a variable is null so it's kind of like
and is not an alternate with this it
will return the links if maybe string is
not null in zero otherwise so it's nice
and short and sweet and it returns and
it produces the return area we might
expect if not null return the links and
0 otherwise null safety and data classes
are two of the biggest ones for me when
it comes freak out
but there's lots of other things that I
like too I mentioned delegation earlier
so let's take a look at that next
delegation can be a good replacement for
inheritance using composition over
inheritance is one of the ways that you
can get out of some of the sticky
situations that you can get into with
inheritance and delegation is a form of
composition it can also cut down on some
of our cognitive overhead and the number
of things we have to keep track of when
we're reading through and trying to
understand some code so here's the copy
printer example in common remember this
one's not my code it's from the blog
post that I mentioned earlier in this
talk the most interesting part of this
is the Capri printer class declaration
it says that it copies by copy and it
prints by print right there and then
after that we just have our interfaces
for copy and for print it's really clear
and pretty simple so let's decompile it
okay so many more lines of code but if
we break it down we can get a good sense
of what's going on we have the class
that implements copy in print and then
we have our fields to store our copy and
print objects that are called delegate 0
and delegate 1 then it takes a copy and
a print object into the constructor and
it assigns it them to those fields from
there it forwards the copy in the print
methods to those copy and print objects
that were passed in in the constructor
and then finally we just have our
interfaces for copy and print which look
as you might expect we can see all this
is nothing too crazy but it's another
example of how count linear adduce is
our Bugaboo surface area and can improve
our code reading comprehension ok moving
something that has been really useful in
Java is to have static utility classes
some of these methods that we put into
these can be pretty application specific
but some of them feel like they could
just be on the class itself for example
checking of a string is empty it can be
annoying to have to call these utility
classes all the time but Kotlin has a
pretty smooth way of handling this with
extensions it allows us to access these
methods directly from an instance of
these objects extensions are a way to
add functionality to a class without
having to extend it or wrap it at all
and from Kotlin it looks like we're
straight-up modifying a class it sounds
kind of crazy if you're coming from Java
land but it's really helpful one place
that we have found it really helpful it
was when we had to do a lot of with math
with time we had to find a fixed set of
boundaries around a time and instead of
having to call this external like date
time you total class we were able to get
it directly from add a time so let's
look at an example of extending the
string class remember string is final so
you can't um
it can't be inherited well make our own
is empty and here's what it looks like
in Collin it kind of straight up looks
like we're modifying the class when we
declare the function name we dot it to
the class name so here we have string
dot is empty and because we want to be
able to call it on a nullable string
we're doing string with the question
mark and then we have the body of our
method also take quick note of the name
of the file name string ext Katie
that'll be important for just half a
second and then when we call it it looks
like we're calling method that has
always belonged to string this may not
be unexpected from say like an
interpreted language but it's so
different from what we're used to in
Java so let's see what's going on
okay so it basically does the same thing
as if we were to create a utility method
ourself it creates a class a class as
the same name as that file string XT
Katie if we wanted to give this class a
different name there's an annotation
that we could have used for that and
then it has our public static method
that does as we've described then when
we call it it calls that static method
as we would with a utility class and it
passes that object in as the first
parameter in fact this is how we would
call it if we were to create our
extension function in Kotlin and then
use it in another bit of our java code
I mentioned that Collin has a lot of
functional language properties so we
should take a look at some of those I'll
admit I'm a really big fan of functional
language properties when I first started
learning how to program in Java I was
kind of upset that I couldn't pass a
function into another function and then
I got really excited when I found out
that you could
so let's look an example let's solve a
problem of creating a list of the first
n squares in Java you probably have a
counter and loop through and add squares
to lists and so on until you reach n so
some looping and some conditionals how
could you do this in Kotlin and there's
this option what this is doing is it's
passing a lambda or a code block into
the ArrayList constructor and it's
performing that code block on each
number 0 through n represented as I in
the block and then adding that as the I
thought limit of the list I realized
that this is actually computing the 0
through n minus 1 but decided to keep it
this way for simplicity you can imagine
what it would look like if we were
multiplying I plus 1 together instead of
I we saw a small code block being passed
for let and that was pretty
straightforward so let's see what this
one will look like okay a bit bigger and
a bit more complex um so that we could
read it a bit but better I rename some
the variables and remove some
unnecessary casting and boxing so
looking at it it's creating a list it's
looping through the numbers and adding
the square to the list and breaking when
it reaches in so it's the same concept
as we might have done if we were working
in Java we might put the conditionals in
a different place or use a different
type of loop but it's the same idea but
the common example was much more easier
to read we could have easily called a
function and that block as well let's do
so real quick just so we're getting
correctly the first and the squares
instead of 0 to n minus 1 the only thing
here that changed was that call to
square in that code block and then when
we D compile it only the one line
changes to call that function the
examples of functions that take lambdas
that we've seen so far have all been in
lined he uses an example of the let
declaration it has the inline keyword
right after public so pump public inline
fun and then the rest of the signature
this means that the compiler generates
the code to insert right where we call
it this is consistent with what we've
seen before so let's see how we can make
one let's do this for the function that
takes a string print it out performs an
operation on it and then prints out the
result to declare that we want to pass
in another function we put the inputs of
the function into parenthesis then an
arrow and then the type the function
returns and then we're also including
the inline keyword in the function
declaration we print the starting value
call that function like we would any
other function and then print the result
we see that a function takes a string
and a function one object we can look at
the interface for function one the one
corresponds to the number of parameters
and it has one method invoke the first
thing inside the body of this method is
two checks to see if the parameters are
null we've seen that before
and then we're concatenating the string
to print out and then it's the
interesting part to perform the
operation specified we call function dot
invoke and this is not in Tyler it's
surprising since we saw the interface
for function one then after that we can
catenate the result to print it out
again so we have our muffin let's try
calling it there are a few ways to call
it depending on what information you
want to include in what practices and
styles you're including inner project
but we're gonna start with a more
verbose example just so that we can
understand all of the parts you'll
recognize some of the things from what
we did before passing in the string
hello is just like passing in any other
parameter so that's easy so lambda is
passed in in curly braces then we have
the name and the type of the variable
we're passing in and arrow and then the
operation so let's to compile this to
see what the result is okay so it looks
like we just copied and pasted that code
I'm just kind of what happened we have
our start string and our concatenation
to print it out we perform the operation
and then we print out the result nice so
that's inline functions they can be
useful for some performance
optimizations because otherwise we would
have to instantiate
a function object you
time that it was called a quick detour
before we look at what it would be if it
was not in mind let's see the different
ways that we could have called before
and after so the first line is what we
just did because the types can be
inferred that we can leave off that type
declaration and that's the second line
if we had not specified that we wanted
that variable to be called string it
would have defaulted to it that's that
third line and then if a lambda is the
blast parameter to be passed into a
function it can be taken outside of the
parentheses final thing let's see what
it looks like when we don't have that
function in line the only thing we're
going to change is that we're going to
remove that inline declaration so here's
what it looks like now it's kind of
funky null dot instance what is that
I do most of my investigation using
command click in my editor but that
didn't work for this for this I had to
take my shot at trying to read bytecode
and I never thought a day would come
when I would try to read bytecode
actually enjoy it but it came and I
think I figured out what was going on so
here's just a section of the bytecode
I'm not gonna make you sit there and
read through it this is specifically the
invoke method but I'll show you some
pseudocode with what I found okay so we
have a class that extends lambda and
implements function 1 as we might expect
it implements invoke and that uses a
string builder to concatenate the given
string with world and then it stores the
result wherever it puts return values
the other thing I saw they might expect
as a static instance to get one of these
objects and those seems to be all of the
relevant parts that I saw so why am the
Java code instance was called on null
instance was on a class
that was internal to the bytecode so
when it was decompiled it didn't have
that class to reference and the best
thing that it could come up with was no
okay so we've looked at data classes no
safety delegation class extensions and
lambdas there's so many other things
that you could explore using the D
compiler there's companion objects and
smart casting there's so many more
collection functions there's other
control flow structures and operator
overloading and then named parameters
are also pretty interesting before we go
I want to show you where to find the D
compiler so you can keep up discovering
these things on your own beforehand you
need to make sure you have the Collin
plugin installed and the dependency
added this is in IntelliJ or Android
studio I'm gonna sue me you have that up
that set up and a common file you want
to decompile you can go to menu tools
Kotlin show Kotlin bytecode or command
shift a and just search show Collin
bytecode there you'll find a button d
compile and there you go
you can narrow continue this
investigation on your own and since I
showed you how to go one way I should
probably show you how to go the other
way
Android studio offers a way for you to
convert your java code into Kotlin code
and to find that you can go to code
convert java file to common file or
command shift a and search for that if
you do nothing else when you do this
make sure to watch out for those double
bangs because those are where your null
pointer exceptions are gonna come from
and I'm guessing that when you're
converting from Java to Collin that's
one of the things you're trying to
eliminate after spending a quite a bit
of time with Collin and then working
with Java again Java can seem like a
long construction detour I can still get
to where I'm going but it can be rather
annoying especially if I don't plan for
it I find that a program faster in
Collin and
um my code is much more readable there's
a lot less typing to do less thinking to
do interestingly enough I feel like it's
made me a better programmer in general
I've noticed that it keeps me focused on
better programming practices and
patterns I can more quickly recognize
when something is using say a map
implementation and I'm more aware of
watching out for nulls it's been really
neat to see you and I encourage you to
give it a try to see how it works for
you that's all I have for you today
thank you for listening you can find me
up here after or any time the rest of
the conference or catch me online on
Twitter thank you for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>