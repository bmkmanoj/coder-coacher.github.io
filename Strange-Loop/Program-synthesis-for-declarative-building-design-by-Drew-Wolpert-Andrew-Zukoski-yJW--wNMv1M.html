<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Program synthesis for declarative building design&quot; by Drew Wolpert, Andrew Zukoski | Coder Coacher - Coaching Coders</title><meta content="&quot;Program synthesis for declarative building design&quot; by Drew Wolpert, Andrew Zukoski - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Program synthesis for declarative building design&quot; by Drew Wolpert, Andrew Zukoski</b></h2><h5 class="post__date">2017-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yJW--wNMv1M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone thanks for coming I'm Andrew
Zhukovsky this is a three walpert we're
here to talk to you about program
synthesis for declarative building
design in this talk we're gonna run
through our motivation for this I
wouldn't talk a little bit about
buildings and how they get made we're
gonna talk about a couple of the
technologies that we you guys pretty
heavily and that we wanted to share a
lot about sat solvers and satisfiability
modular theory solvers we're gonna dive
into the anatomy of these solvers and
how you put them together we're going to
talk about our experience things
augmenting these tools to reason about
geometry and shapes so let's talk about
buildings this is a picture of the
Shanghai Tower it's one of the tallest
buildings in the world second of the
Burj Kalifa 126 stories it's two million
square feet it's four million square
feet of glazing oh no I have those
backwards thousands of people go to work
in it every day and it's really pushing
forward how the world designed to
constructs buildings it's a really great
example of what we're capable of doing
it's a very complicated design it has
this like sort of fascinating double
skin where there's this you know outside
layer that sheds a lot of the sunlight
and doesn't let it pass into the
inhabited spaces inside so this reduces
the electric electricity utilization of
the building in maintaining a sort of
appropriate working environment inside
and it's cool this is the largest
building that's ever been LEED Platinum
certified and it is serving as a sort of
shining beacon for how well we can
design buildings today and it's good
that we can design these sorts of
buildings the buildings are really
important right construction in the u.s.
is 8% of GDP and I know everyone here
like really cares about like economic
stuff like that I was try co2
okay so buildings you know their
construction and their operation is 39
percent of co2 emissions in the United
States in size of cities it's even
higher in New York City did a study of
where their co2 came from and I found
over seventy percent came from going
construction and building operation as
electricity for the lights as
electricity for elevators as it's
burning natural gas to heat the place
okay maybe I'm care about co2 even
beyond that most of us spend most of our
time inside of buildings eighty seven
percent you might say and the spaces
that we're in have you know such as such
an important effect
on all of our interactions everything we
do everyday you would expect that
architects and software engineers would
have gotten together and built the sort
of like amazing fantastic tools that
like break down any sort of barriers
between thought and constructions simply
simply by conceiving of and demanding
you know buildings of a certain
configuration of certain performance we
should be able to create these designs
and go off and construct them right yes
no unfortunately not
construction and architectures and
Industry is a industry that's not
received a ton of sort of technological
advancement in the last you can say
either in the last few decades or the
last few millennia although I did see a
few Pro Corps jackets around guys
we designed buildings largely the same
way we did 2,000 years ago we've shifted
from drawing on paper to drawing on the
computer but the process is largely the
same and it's a very painstaking process
you know blueprints are still the de
facto way that buildings are designed
and reasoned about design of the
building comes down to figuring out all
sorts of details all throughout the
building and like minutely pushing
around you know symbols and lines in 2d
and 3d drawings and there are a lot of
these details to get right you know for
a building like this you have to worry
about building code so this will specify
things about occupant safety health and
wellness um you've concerned about
constructability you know I mean you can
go design something like this but like
it no one's actually put the thing
together then you know you're you're out
of luck owners have their own
requirements that we bring to the table
they care about you know the space and
how much of it there is and they might
have sort of special requests about
materials performance is an emerging
concern
um so as we said you know buildings have
a huge environmental impact and people
are waking up and starting to care about
this and states and countries are
ramping up energy codes year over year
driving up building performance and then
lastly designers of buildings bring
their own aesthetic criteria that they
want to impose on the building to the
table and you have to get all these
details right um do we I'm sorry yeah
you have to get all these details right
and it's a slow process so let's talk
about parking um
tom Alcorn in the audience knows a thing
or two about this if you're building a
parking structure and you want to make
sure that they're going to be enough
people who can park in it
you have to count the number of parking
spots and the way this is done right now
you might say oh it's great I'll just
script something up that uh
you know we'll lay out each of these
spots and we'll have some rules in it
about you know like different egress
requirements and spacings and making
sure that turning radiuses are large
enough you might think that that's how
it's done
that's not how it's done right now the
state of the art is that some you know
probably probably kind of bummed out
junior architect goes and takes the
outlines to the parking structure and
draws each of the lines for every
parking spot okay and then they count
the number of parking spots that they
just drew and that's how many parking
spots fit in your parking structure I
know that's okay fine like we do that
once it's great but you have to do this
every time anything about the building
design changes if you push one of the
walls you know someone has to like on
digitally I guess unroll the drawing and
go back and revisit each of these
parking spots and redraw them and
recount them and it's slow okay but it's
really important cities won't let you
construct these buildings unless you
have enough parking spots you know they
don't want you imposing sort of like
worst traffic problems on downtown and
if you're building like a commercial
establishment you know what people are
going to drive there you want to make
sure they actually have places places to
park so you have to get this right and
you have to like make the best use of
the space you have available let's talk
about safety if you got a piece of glass
that you're gonna be near and you might
bump into it and break it it would be
great because that's probably gonna make
your day bad enough if it didn't turn
into sort of a set of like jagged knives
like you know cut you up and made you
bleed out on the floor that would be
awful and so there are rules out there
for where you need to put safety glass
glass that will either resist breakage
or if it breaks will break in a way
that's safe um and these rules are
complicated and are dependent on the
situation of the piece of glasses and
there are different rules for doors
there are different rules for windows
they depend on spacing and whether or
not there are barriers and you gotta get
all of this right for every piece of
glass in the building you gotta get all
of this right for every piece of glass
and the Shanghai Tower all two million
square feet of it let's talk about the
building exterior building exteriors you
know like many other parts very
important as a number of competing
things that have to be considered you
have to provide appropriate acoustic
isolation so that you can hear too much
what's going on outside you have to
provide enough insulation you're not
like you know burning through your
budget heating the building um you need
to keep the water out
and you need to ideally do it in such a
way that it's fireproof um so these
competing concerns and you have to get
all these details right and you have to
do it like on a reasonable budget and
these details really matter there's a
picture the Granville fire it happened
in earlier the spring and summer in
London and I mean it's just this like
incredibly tragic event and it was
caused you know there's there's a lot of
reasons that it probably that it
happened I mean I so I don't want to
trivialize it but the reason the fire
spread so quickly is that someone got
the details on the outside of the
building wrong okay they used a
flammable substance and they used it
with an air gap so the the part of the
exterior of the building that worked to
shed water
well I'm had an air gap between it and
the insulation underneath and this meant
that if any water did get through it
could run off the trick is this air gap
also acts as a chimney in the case of
the fire which leads the fire to spread
much more quickly and just this like
credibly tragic event and so you have to
get these details right but they're not
always the most funding to reason about
so we're here asking the question what
if designed tools could actually help
with this problem what if you know we
can take a solver of some sort embedded
in the design tools and have it figure
out the details you know have it satisfy
all of these constraints on building
design whether they're code related
safety related fire related etc so we
think really exciting things you're
going to start down this path and you're
gonna go start off and build this thing
you might say okay buildings are spacial
I know a thing or two about mechanical
design can we do this using a geometric
constraint solver and the answer is well
yeah let's try so Q metric constraints
the geometric constraint solving problem
is a problem that's been explored
heavily in the mechanical engineering
domains it's used and all of the tools
that underlie like the design of your
iPhone or the design of a car or you
know the bracket that we saw in the last
page and the geometric constraint
problem is the problem of given a set of
geometric entities points lines curves
planes whatever and a set of constraints
on them so things like equality
containment symmetry around a reflection
plane angle between lines a tangency
between curves like is there an
assignment of all of these entities
positions in space such that all of
these constraints hold and you know this
is fairly well trod field there are a
bunch of implementations out there of
this as fairly well
most of them work by taking a geometric
constraint problem that's composed of
entities and constraints on those
entities and decomposing or excuse me
transforming it into a constraint graph
so here we've mapped geometric entities
to nodes in this graph and that
constraints are mapped to edges between
these nodes okay so let's step one and
then I guess that's step zero or zero
indexed and all of our procedures once
we got this graph the first thing and
there's there's a number of different
sort of variations of this but almost
all of these solvers follow a strategy
of first decomposing this constraint
graph into clusters and creating a
solving strategy so you guys might
remember from geometry class in high
school how they were you know if you had
a parallelogram and you knew one of the
angles and it was really easy to figure
out the opposite angle or like for
certain types of triangles it's like if
you got a little bit of information
there's like very straightforward ways
to determine other algorithm or sorry
other values in this geometric problem
so I mean doing this decomposition you
leverage rules like that and you find
subproblems that are very
straightforward to solve and that you
don't have to do any sort of complicated
iterative methods to solve once you've
found them you solve them one at a time
and propagate values to neighboring
clusters you go through solve a
subproblem take you know whatever the
shared values are propagated to another
you know another neighboring cluster and
so on and so forth until you've solved
all these problems okay this is great
right we're done we've solved all of the
geometric problems and buildings are
largely geometric and so we have again
broken down you know barriers between
thought and construction and like
through sheer force of will are now able
to like you know pull whatever things we
need from the ground not so much the
problem is one of choice so geometric
constraint solvers don't support
disjunction very well and it's very
exciting how expressive they are there's
no you know all of these different
entities that they support and all the
different constraints is very expressive
but it's very difficult to say hey I
need I need something to be either the
length of the short cinder block or the
length of the long cinder block I don't
care which but it's got to be one of
these two these sorts of things are very
difficult to express with existing
geometric constraint solving techniques
and this makes it very hard to reason
about options or choices in your design
and this is too bad because building
design especially in comparison to
mechanical design is absolutely chalk
full of choices that you have to make
you choose between different design
options or different components you
might say oh and you know this window it
comes in two sizes or like you know
these chandeliers they come in a variety
of different sizes or different
configurations that would work in
different situations you have different
patterns for how you place these things
in space and then you have entirely
different strategies that you have to
choose from for satisfying different
building subsystem requirements and this
is where the term entry constraint
solvers break down so a geometric
constraint solver isn't going to be
enough off-the-shelf let's back up to
another of these examples of disjunction
that we saw earlier so one of the sub
bullets in the safety lazing rule is
that if the window is large so greater
than 9 square feet within 3 feet of a
walking surface less than a foot and a
half above the floor and more than 3/4
in the top is more than 3 feet tall so
it's it's placed in such a way that you
could fall through it as you're running
or walking by then it needs to be safety
glazing so this doesn't necessarily
exactly look like a disjunction to you
but if we rephrase it a little bit we
see that it's either safety glazing or
it doesn't meet these other criteria so
this looks a lot like a problem that may
be familiar to us as computer scientists
boolean satisfiability so does there
exist an assignment of variables that
satisfies a given propositional formula
this is the first problem proven to be
np-complete by kokkonen 71 and live in
again in 1973 independently so it's
received a fair amount of attention for
that reason it's a search problem so I'm
going to take you back to undergrad CS
class for a little while and understand
the algorithm that underlies most Sat
solvers even to this day because
understanding this will be important for
the extensions that we're gonna add to
it later to a recent about other things
besides boolean so how do we solve set
so this algorithm by Davis putting them
low German in Loveland in 79 it is
basically a backtracking search
algorithm with eager application of a
couple of ideas so the first is unit
propagation so if a literal appears
alone in a clause so the clauses are the
thing
between the ends here so if a literal
appears alone then if it's not true then
the formula is not satisfied so that
little needs to be true we can go ahead
and assign it to be true and simplify
the formula and see what we have left
second is pure little oil assignment so
if there's a literal that always appears
in the positive form or always appears
in the negative form then we can go
ahead and assign that literal in the
form where it appears and simplify the
formula because we know that assigning
it that way isn't going to reduce our
chances of finding a satisfying
assignment so with these two rules we
can go through and eliminate large
unfruitful sections of our search space
and arrive at a solution if one exists
actually fairly quickly so let's step
through an example so first do we see
any units that we can go ahead and
assign a yes so we can just say a is
true or I remove that clause next we
don't see any more units but do we see
any pure literals that we can assign yes
so you removed that clause great do we
have any left nope yeah nothing left so
we have to make of ranching choice now
so I'm going to make that choice let's
say V is true when we assign B to be
true we can remove a clause and we can
simplify a couple of the other clauses
so now we're left with this simplified
formula and we can go ahead and recurse
on that simplified formula
so now let's keep applying our our
simplification rules so can we you know
propagate do we see any units that we
can go ahead and assign now nope I think
how about purely roles yep so C is true
now we're left with just d's and f's so
now I need to make another choice just
for fun I'm gonna say that D is false so
when I say to use false I simplify my
formula again and I see that I have now
not F and F so this is problematic
satisfiable so we turn around and we say
okay if these other assignments are true
then D cannot be false so let's
backtrack so now I'm back with D's and
F's so we learned D can't be false so
what happens when D is true now we see
that we're left with just not F so
that's pretty easy to recurse on can we
propagate any units certainly we can so
now we found a satisfying assignment we
can return the satisfying assignment and
we're all happy so this algorithm is
been around for a long time its underlie
underlies most solvers there are a few
improvements that can be made to it to
make it even more performant so first is
we can backtrack a little bit more
intelligently than we did did here so
here we just found an unsatisfying
assignment and we said okay the last
decision we made must have been a bad
one so let's backtrack one step but we
can actually analyze the conflict that
we have arrived at when we do that and
find that okay this set of literals
can't all be assigned this way at the
same time so we can both back jump to
the appropriate decision point and add
that clot that new Clause that we've
learned which is that this set of
conflicting literals can't all be
assigned these way this way together add
that new Clause and continue from that
point so we've actually learned
something from the unfruitful branch
that we went down so it's called
conflict driven and college learning so
second we can make better heuristics for
what which branches we choose to explore
so people have looked into like to which
when do we want when to choose which
literals to assign true or false and how
do we branch there and then when you're
starting to reason about large numbers
of clauses it becomes important what
types of data structures you use to
store your clauses and reason about the
unit propagation step so in practice
we're actually able to handle thousands
to millions of clauses this way does
that mean that we're done so now we've
learned disjunction and then we have
geometry and we have disjunction
not quite done so let's go back to our
safety glazing example from earlier so
here we turned all of these predicates
into boolean so we had safety lazing or
not near the floor large high and narrow
walkway but all the rest of these things
besides is that safety glass or not
aren't actually boolean s-- right so how
do we reason about things that aren't
boolean's
so in particular near floor and high or
both inequalities right so Sat doesn't
know how to reason about these symbols
this like be less than eighteen stuff
for T greater than 36 but we have that
we have other algorithms that are able
to efficiently reason about these these
types of theories so how can we extend
boolean satisfiability to reason about
other useful decidable things so this is
what we call a satisfiability modulo
theories so the atoms in our
satisfiability formula are no longer
just boolean variables but there are
predicates from other theories like
linear arithmetic or arrays or bit
vectors so there are three different
ways that we can do this one idea is we
just convert our formula to a Sat
formula maybe it's a larger set formula
but we now have a Sat formula this works
for some theories and then we can just
feed that into a Sat solver off the
shelf and get back a result translate it
back into our theory and we have an
answer so this works for some theories
and the downside to this is that we end
up working pretty hard in the Sat solver
to discover things that a solver that
understood something about the theory so
a solver say that understands the theory
of unvalued functions would know that if
a equals B then we can also say that F
of a equals F of B but as that solver
has no concept of functions or equality
it all know is about is boolean
variables so it's not going to be able
to do this propagation it will just have
to explore the boolean search space and
come back with an answer if it has one
so we'd like to actually use solvers
that understand each of you understand
these theories because we we can
so if we use one of these theories or
use a solver for one of these theories
and use assets all over each as their
own little black box we can first take
our formula as it was and keep all those
boolean variables as atoms and we feed
that formula into the Sat solver
and we get back an answer and now we
aren't sure whether it's satisfied in
the theory or not but we can go and feed
that into the theory solver and ask the
theory solver is it satisfied in your
theory the theory solver maybe says yes
it is and then we're happy if the Z
resolver says no actually some of these
are in conflict then it can tell us
which ones are in conflict we can add a
new clause and we can go run our Sat
solver again so this is what we call
offline because we are calling out to
the Sat solver and calling out to the
theory solver so in this architecture
the master solver is just a simple
coordinator and there's a Sat solver
which can be any Sat solver exploring a
boolean space potentially exhaustively
and then there's a theory solver that
just checks all of a solvers assignments
so this again is nice because we can use
a Sat solver off the shelf we can also
and we can use a theory solver off the
shelf we don't need any particular
properties of either of these it doesn't
matter what algorithm either of them
uses but we might like to use this the
theory solver to actually guide the Sat
solver so instead of exploring that boy
in space exhaustively we want to learn
early when we have conflicts in the
theory and use that to guide our swap
solver so we can stop exploring branches
that are going to be unfruitful
so this is we're going to call an online
method so we have a couple requirements
to be able to do this so first the thing
that's exploring boolean space the Sat
solver now it needs to be able to accept
new clauses so we're sitting we're going
to use our DP ll algorithm but now we're
we're accepting new clauses online as we
did in conflict Riven Clause learning
from the theory solver and the theory
solver is checking the partial
assignments so
partial sets of predicates out of the
formula for satisfiability so let's take
a look at how DPL looks when we've
modified it for theories so we're still
doing this back talking search and we're
really applying the rules that we have
for propagating assignments so one thing
to note is that we no longer want to do
pure literal assignment here since when
literal is we're just true or false we
could safely say that ok if I need it to
if it's useful for it to be true or
doesn't harm for it to be true I might
as well sign it but because a theory
solver may find that assigning that
literal that way is in conflict with
something else that we need to happen
we're no longer going to want to
greedily make that assignment second is
you know propagation so we can actually
learn a lot more with theory solvers and
propagation because not it's still true
that a predicate appears alone is going
to need to be true for the the overall
formula to be true but it's we also are
able to use the theory solvers to deduce
more about the the truth or falsehood of
predicates based on assignments that
we've already made so so far I've mostly
been talking about using a single theory
solver and and a Sat routine or a single
Sat solver but a lot of the problems
that we want to reason about aren't just
a single oranges boolean problem was
with a single theory added to them maybe
you want a reason about multiple
theories like we have both functions and
linear integer arithmetic or we have
arrays and we have integer arithmetic so
let's look at how we can combine a
couple combine multiple decision
procedures to have multiple theory
solvers working together to help us in
the DP ll for the S&amp;amp;P solver so let's
take an example here we have to predator
a few predicates from both linear
integer arithmetic and some many valid
functions so we're gonna take this
algorithm from know thin and often which
the first step is that we're going to
purify
the set of predicates in two sets of
predicates that a single theory solver
can reason about and to do this we may
need to introduce new variables so that
the only shared symbols between our two
sets of predicates are the variable
names and equality and no predicate no
theory solver is left trying to reason
about front about symbols that doesn't
understand second once we've done that
we can discover relationships within the
theory of solvers between variables and
then propagate those relationships to
the other theory solvers and then back
up to our satoru team so back to our
example we see that all of these involve
something from the theory of linear
integer arithmetic and the second two
also involve simple form of evaluated
functions so our first step is going to
be to purify into predicates of a single
theory so before we do that let's
backtrack for a second and say what's
the theory so a theory is a set of
symbols and operators and associated
interpretation rules for them so like
boolean x' and and and or and not or
like plus minus equals greater than less
than greater than equal to less than or
equal to integers or equality and unev
al uted functions those are all theories
some examples of pure predicates so a
and B is a pure predicate it's just
variables with with and X plus Z greater
than 2 has a pure predicate that's just
linearithmic f of i equals g of h of j
is just under valued functions some
impure predicate a and B equals 2 we
have both boolean and we have a boolean
operator but we also have an integer X
plus D of 1 is greater than 2 we have an
array but we also have integer F of I
equals G of 4 we have a number and we
have a function so now let's purify our
example so first we notice that the
first two predicates here are actually
already pure we can just stick those in
our theory solver one bucket t1 the
third one is not pure yet so that one we
actually need to split up
so we can do this by introducing a new
variable a and say that a is 1 and f of
X does not equal F of a so then we send
the one to the left and we send the
undervalued functions over to the right
to teach you you can do that again with
our second one and now we've purified
and we've we now have a set of
predicates that each of these 3 solvers
can reason about independently so now
what can we learn in each of these
theories solvers about the predicates so
that we have here so T 1 is able to tell
us so T 1 is sorry so we're going to
reason about what's inside of these each
of these buckets in the theory solver
and then we're going to propagate what
we learn over to the other theory solver
and eventually up to our parent so what
are one of the equalities that were
allowed to propagate so we need to
propagate things that are shared symbols
between the two theory solvers because
it's not useful for me to propagate
something that the theory solver I'm
probably eating too doesn't understand
so in this case the only thing is that
we're able to propagate our equality and
their variables that can be shared so
that's like a equals x x equals y or H
doesn't equal G so first we learn from
t1 we can see that either x equals a or
x equals B because we're dealing with
integers we can't tell that one of these
that one of these particularly is true
but we know that one of them needs to be
true so we can first try propagating the
the first branch over to t2 and see what
we get so I'm gonna do that we combine x
equals a with the predicate that teach
you already had and it tells us sorry
unset so we can backtrack can we say ok
so x equals a is going to result in a
conflict but what if we choose x equals
B instead so we can send that over oh it
unfortunately is not able to say that x
equals B either because f of X does not
equal F of a and does not equal f of B
so we've actually learned that this
for predicates cannot all be true
together and we can propagate that back
up to our set routine and use that to
continue reasoning about the boolean
logic okay so now we've learned how to
use boolean satisfiability algorithm and
pull in theories about other things and
reason about them so we ought to be able
to do anything we want to now right so
back to our safety glazing example we
hovered boolean safety glazing we we
covered these hoops these inequalities
of integers we've still got a couple
things left so large and near a walkway
what are these yeah so we can replace
large with a reasoning about the area of
the window and we can replace you know
being quote-unquote near a walkway with
a distance between whatever the walking
surfaces and the pane of glass and so
these are examples of geometric
predicates these are the sorts of things
that geometric constraint solvers are
pretty good at so we're gonna do we're
gonna bring geometry to disjunctions via
dpi level theories and this lets us
hopefully reason about disjunctions you
know different options and the sort of
geometric spatial relationships that
underlie a lot of buildings and like
that's really gonna get us there we're
gonna finally be able to you know do
whatever we want to do with buildings
that's right so this is rhino
it's a 3d design tool sort of you know
maybe some folks are familiar with it
and this over here is a little
playground we have for playing with some
of these ideas and working on toy
problems with some of these programs
synthesis algorithms so the first we're
going to do which is just a very simple
uncommon satisfiability modular theories
example is the send more money problem
hopefully this is at least somewhat
legible anyway the idea is you've got
you know send as a word more as a word
and if you add them together you get
money which is a word but wait it's not
you know what we do is assign a digit to
each of these letters and we do it in
such a way that this little piece of
arithmetic holds and so just to give a
feel for how this sort of works we
we create you know create logical
variables for each of the letters we you
know make sure that each of the
variables is like between 0 and 9 you
know we assert that none of them are
equal we construct you know sort of
logical variables that represent the sum
of each of these variables and then at
the very end we assert what we came here
to do which is that if you add these two
numbers together if you had send more
you get money so we can come here and if
we solve this if we take this up and
turn it into a set of SMT clauses and
hand it over to the solver we get back
this variable assignments and you know
as an exercise to the reader you can you
can go off and check this yeah okay
let's look at a really simple geometric
thing okay so this is really complicated
right what we've got here are three
lines 1 2 3 and a point and what we want
is this point to be on a line okay and
we don't care which line we're saying
like yeah we want you know the point can
be on the first line or the point could
either be on the second line or the
third line so similarly we have these
logical variables representing the lines
in the point what we can do is hit the
solve button and this passes this off 2d
PLL of theories so we've got a boolean
set solver that's exploring the really
complex again
boolean space of the simple combination
of ORS and and then passes off you know
a particular assignment there and
explores you know different
possibilities for how we might assign
this point to these different lines
they're actually infinite lines not line
segments okay so we do that look at
something just a little bit more
complicated so here in this example
we're gonna create a trellis where you
create a trellis okay and it's this sort
of shape you know you might hang things
off of it or maybe just use it to sort
of in effectively block this on the so
we designed this charles we sort of like
the shape and we like the relationship
between these beams and like this is the
shape we got okay and it's these um
fixed beams that are linked together and
the beams come you know we're placing a
beam over here and what we're saying is
say each of these beams is either short
100 inch
or it's long 170 inches long and what we
want is to get this trellis to actually
stretch from this column over here you
know this pesky detail of actually like
being you know structurally supported so
what we can do is come in here and we
add a few assertions we're gonna first
assert that the distance between the
left column no sort of structural
support point and the leftmost trellis
point is zero point zero right
and we're add another constraint for the
right one okay and once we've added
these two constraints um we're gonna be
able to first you know run it to see
whether or not those some assertions or
failings and that interesting
see without we had any typos which we
apparently don't and now we can take
this problem and we can pass it off to
the Torah solver okay and so what the
solver does is it's partition this out
and it's taken the boolean assignments
the choice for each being whether it's
short or long and it's taken you know a
sample set of assignments there and it's
propagated into the constraint solver
that figures out how to satisfy the
requirements that the trellis support be
supported on both ends and that each of
the beams you know join at the endpoints
and this allows us to explore this
design space so we can pull this in and
now we can start to click through and
see you know different configurations of
beam lengths that actually meet the
structural points and you know our legal
of assignments of different lines so we
can select one of these we can see it
and boom oh we lost columns again now
we've got this thing that uh yeah I
swear is supported oh there we go right
so these are tight problems and it's
been an interesting experiment building
these things out and starting to play
with them we've a few anecdotes we've
come up with or sort of like things that
we've learned and going through and
actually pulling these things together
and we thought we'd share them for
anyone who might be interested in
extending sad innocent each of their own
problem space first is that these are
very powerful and very mature
technologies it's really you know
amazing what these technologies can do
and then sort of more excitingly
now and this is a more recent
development is that the community at
this point has a lot of experience in
embedding these solvers into new domains
so the type theory community is we doing
a lot of like really exciting things
embedding sat in SMT solvers there's a
workshop yesterday on reasoning about
program correctness using using LOV m
and z3 actually and it's really exciting
so it means there's not only people who
can tell you about all the different
ways that you put boolean propositions
together they can tell you about it
their experience pulling it into and
deploying these in new domains as mature
technologies are exist robust
open-source implementations for both sad
and SMT solvers sort of most prominent
arc heads is z3 it comes from Microsoft
it's under a BSD license it's this just
like it is you know not a not a research
project by any stretch of the
imagination it's just like an industrial
industrial strength implementation
that's been used to solve very important
problems this is a really ripe set of
technologies on that's ready for
application in new places it doesn't
come without complications sort of the
biggest one is figuring out the mapping
between high level domain constructs or
concepts and the nitty-gritty of
individual predicates and clauses as
this presents a few challenges you know
you can do the mapping but there's a lot
of separation between the problem as you
or a user might conceive of it and what
actually gets handed to these solvers
this this leads to several challenges
first performance is often opaque subtle
changes in how a problem is encoded or
actual in the specifics of a problem can
lead to drastic increases in runtime you
know you switch from solutions being
spat out and you know fractions of a
second to something that takes minutes
hours or just never solves secondly
unset is hardly a satisfying result the
you know getting unset back is a little
bit like your compiler hopefully telling
you that there's a syntax error
somewhere in your program and you know
if you want to run this program you
should probably figure out where it is
and fix it you know this isn't this is a
new and there exists tools for
expressing and extracting minimal
unsatisfiable cores so from some set of
constraints pull out the you know
hardest part if you will and you can say
okay this is the part you know we can
solve everything but we can't solve this
part unfortunately that unsatisfiable
core is expressed in the nitty-gritty of
particular boolean Zoar particular you
know other theory clauses and so
translating that back out in such a way
that you as a debugger or
eles as a user can actually effectively
reason about it and understand what it
means to their program is a challenge
yeah and just generally explaining how
the solvers work to users is confusing
you know the an under constrained
problem will often result in like very
surprising or non-obvious
solutions and it's um challenging for
users to sort of work with that that
said um these technologies are amazing
everyone should pull these out and see
what they can do with them um a few
resources that we liked when we were
getting started we really want to shout
out to rosette project from unit 2
airlock University of Washington and her
collaborators this is a just like
amazing system that's embedded z-3 again
actually inside the racket programming
language and it like just completely
eliminates any bit well not anything but
it really lowers the barrier to entry to
expressing new either salt or aided
tools or in fact new solver aided
programming languages so a lot of the
sort of mechanics of doing the
translation between the sort of
programming constructs that we
understand and the underlying solver are
handled by rosette and so it's really
easy to dive in and get started
secondly z3 comes from Microsoft it's
amazing and then for a survey of the
solver field
the annual SMT competition you know
their new solvers coming out sort of you
know every few years and like the the
rankings year-over-year for performance
change so it's a good way to get a
survey of the field yeah that's a that's
it that's us will leave up a few
pointers towards anyone who wants to do
a little bit further reading um and
we'll take questions offline guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>