<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Shen: A Sufficiently Advanced Lisp&quot; by Aditya Siram | Coder Coacher - Coaching Coders</title><meta content="&quot;Shen: A Sufficiently Advanced Lisp&quot; by Aditya Siram - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Shen: A Sufficiently Advanced Lisp&quot; by Aditya Siram</b></h2><h5 class="post__date">2014-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lMcRBdSdO_U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is ditch I live here in st.
Louis I work at intox meters since today
is National Talk Like a Pirate Day I
will be pointing the slides with these
in case the first one breaks I have the
second one down there because that's
important so today I'm talking about
Shen it's one of the newer entries into
the list family and one of the more
interesting ones so let's get let's just
get some syntax out of the way real
quick this is how you define a function
in Chen you start off with define which
is fairly set which is fairly routine
and the name of the function but all of
the arguments are pattern matched right
so that first pattern match only happens
if the second argument is known if the
second argument is not nil it just falls
through the second thing so if I go
welcome strange loop nil it's been it's
just going to say welcome to strange
loop if I say welcome strange loop st.
Louis that's going to say welcome to
strange loop dancing it was so this is
not very list bitch this is very mlah SH
but it's still less trust me it's just
got this pattern matching which is
actually really nice it's also got
optional type checking which you turn on
by using the form TC plus it's turned
off by default and you have simple types
so here's a function that checks to see
if a number is positive it takes a
number it outputs a boolean as you can
tell by this Ted signature right here
and the body of the function is pretty
simple stuff it just checks to see that
X is a number and that X is greater than
zero but note that when you run the
function in the normal way the output
actually has a type attached to it in
this case it's boolean so that's pretty
simple but Shen also supports
polymorphic types as in the standard
definition of map so map tape is a
function that takes some a to some be a
list of a's and outputs a list of BS in
the first case if the list is empty it
just outputs the empty list in the
second case a pattern matches against
the head of the list and the bar
actually pattern matches against the
rest of the list so XS is pattern
matched against the rest of the list you
apply F to the head of the list and then
you recurse on the rest of the list if
you are at all familiar with Haskell or
gamma or any kind of a now this is a
familiar encoder so something to note
when you are running this function is
that chin support scurrying by default
so I don't have to go map lambda X X
plus 1 I can just go map function plus 1
and also the second thing to note is
that the output has type list number
even though we've said in the type
signature that the output is of type
list B the Shen the Sheng type checker
had sort of the intelligence to figure
out even though we didn't tell it we're
giving it a list of numbers that had
figured out that a list of numbers is
coming out without me telling it
anything by the way those types of
signatures up there are mandatory if you
have type checking turned on but only at
the top level you only have to give the
type of the actual function itself you
don't have to give the type of each
individual thing inside of the function
you can also turn off type checking and
that's the default load and in that case
the type signatures are just ignored you
can have them in there and it's kind of
useful for when you have a file full of
type check functions and you just want
to figure out if some function is
working or not just turn off type
checking run it no big deal so when you
run it in this case the output is just
the value you don't have a type attached
to it but notice elso snuck in this like
weird alternative the lambda syntax that
jen has its slash dot ah and the reason
they have that is because if you squint
at it right it kind of looks like a
lambda
that's that's it that's the only reason
that's there you can just use the lambda
if you don't like that oh yeah
the lambda L am BDA which you can I
guess Emacs can rewrite that to a lambda
character for you sorry
so that was a crash course on sunshine
syntax so some reasons why Shen is a
good thing
first of all optional type checking ah
it's the language that really made me
reconsider my original thinking on
optional type checking and now I think
it's actually a good thing if done right
it's also got a very very flexible type
system and we'll get into that quite a
bit more in a second it's also got not
just ml style pattern matching the
prologue style pattern matching which
means that if you use the same wildcard
in a pattern twice it means the same
thing
it made it it's equality right there so
if you want to check and see if you're
two arguments to a function are the same
you just use the same wildcard twice and
you don't have guards or anything like
that and it makes code a lot more
concise it's also got a full Prolog
engine and the reason it has that is
because the author needed Prolog to
build his type checker and just expose
that to the user it's also got a full
parsing engine for the same reason
because the author needed a parser to
parse Ram code and just expose that to
the user we'll look at that more in a
second but the best part is a decompile
is a very very small schema SH s
expression based language called K
lambda and basically what that means is
that Shen is extremely portable if you
can write a scheme interpreter and if
you can provide about 45 primitive
functions like if and or' read file and
about and a few more you basically have
a shin sitting on top of your platform
so the idea is that at least the
approach that I take with Shannon why I
think it's a good idea is so you have
some polyglot project you have
JavaScript you have Ruby you have like
at least 15 other languages sitting in
your enterprise it's easy to porch into
all of these different platforms and
then encode common data structures in
the variants in Chen and test it once
that's the theory anyway the author
calls it a unifying meta language and I
think that's kind of a like a long way
of saying what I just said so
I have a couple of web app demos really
simple stuff the backend is written in
the the Shen port of Ruby the friend is
written in the Shen port of JavaScript
it's not important that I used Ruby or
JavaScript what's important is that all
the common code is written in Chen and
it's all type check engine not type
check value checked and type check all
the checking is done in Shen so the
first demo I have is just a simple user
name and password form and if I type in
blah-dee-blah
it's going and try and send it loops
back it's going to complain and say the
username must have only letters and if I
type in a bunch of stuff with a password
try to send it it's going to complain
and you can't see what it says all the
way over there but it's saying it must
contain the same number of letters
digits and one of at least underscore or
Bank and all of this validation is being
done in Chen and it's being done both on
the JavaScript side and the Ruby side so
if you were to send these as query
string parameters with curl you would
get exactly the same message back from
the Ruby side without any duplication of
code okay so how do we do that so we
have this top level data structure
called model up there and by the way the
twos Asterix is surrounding model are
sort of this Lisp idiom that means this
is a global mutable data snowed variable
I don't know why it's called that but
they call it earmuffs so just to lisp
ism so inside of model we have a vector
and a vector in Chen is designated with
the app-v and inside of the vector we
have two pairs are designated by @p the
two pairs represent the two fields a
username and password and aside from the
string username and password we have
associated functions to validate the
user input of the username and the
password so running a validator
basically means taking a key which is
either username or password iterating
through those pairs finding the
validator function running it on the
given value and then handing that back
to the user the lookup function is very
simple but the only reason I show it is
because it uses this idea of
prolog style pattern matching as opposed
to ML style pattern matching so notice
here we have a vector and a pair with a
key and we've passed in a key but the
wild-card is exactly the same so we
don't need a guard to check and see if
those two things are equal this first
pattern will only fire if those two
things are equal and we just kick out
the validator at that point so parsing
in Shen parsing you build a parser using
this def CC a keyword it's actually a
macro but may yeah and you're calling
the parser alphas this is to parse the
user name we're just parsing only
letters at this point so it's parsers
are delimited by semicolons and in two
rules so what this is saying is that if
I can parse a letter followed by more
input then go ahead and stick the thing
I just parsed into a letter and stick
the rest of the stuff that I can parse
into a letter the last rule is saying
that if I've reached the last letter
just stick that all into a list
concatenate everything and hand it back
so a parser is just a simple function it
D compiles to just a straight define so
I can call it a function and I run the
parser using this compile function which
then takes a list of bytes by the way
not actual characters so I have to
convert the string to a list of bytes
and outcomes a list of bytes but we
actually don't care about the parser
output all we care about is the fact
that I've actually parsed so we have a
function called parses which takes the
parser and the input compiles the parser
up runs the parser on the input returns
true or returns false if a if an error
occurred so notice we're doing this
thing called we're using this do macro
for imperative style programming and we
have this construct called trap error
for exceptions slightly more interesting
is the actual password parser because
notice it had to have equal numbers of
letters numbers and one of a couple of
special characters so the password
parser consists of four rules so if
you're parsing the password you're
either looking at a digit a number in
which case you add a function called add
digit which I haven't shown you yet to
the list
you are either looking at a special
character
in which case you add a function called
add special to the list or you're
looking at a letter in which case you
add a function called add alpha so
basically the thing to take away from is
a big mess of code is that user input is
being translated into functions so if
the user typed in hi 1 2 3 bang
underscore that gets translated into a
list with function add alpha at alpha
for the hi add digit digit digit for the
1 2 &amp;amp; 3 and add special special for the
bang in the underscore and this is what
add alpha digit and special look like
they're just a triple and all I'm doing
is incrementing the hub the right point
via the right position that triple for
alpha it's the first four digit it's a
second and four special it's the third
so Shen has this really handy function
called compose which takes a list of
functions an initial starting value I
just runs it all the way through that
list of functions so high one two three
I guess that should be bang underscore
it gets turned into the triple two three
two four two letters three numbers and
two special case characters and to
validate that you just have this
function call validate validate password
which takes that and does some very
simple boolean operations on it so in
order to call this from the Ruby from
the JavaScript side there's a function
called call by name which takes the the
Shen function as a string and passes
them some values on the Ruby side it's
just passing a message to an object
really simple stuff so that's in a
nutshell how you on the high level how
you do sort of common code sharing among
you know multiple you know multiple
tiers basically but we really haven't
looked at the type system just yet and
to look at the type system I have a very
simple demo also called counter all this
does is increment the counter so
increment the counter if I put a
negative number it's going to complain
if I put in anything other than an
actual positive number it's going to
complain so I'm using the type system
here to make sure that what I'm put what
I'm inputting is actually a positive
number and to do that I have about two
or three different functions so a
function calls string to a positive
number which takes something of types
readable string and output something of
type positive number I have not shown
you what readable string or positive
number are yet that is coming up I have
a function called add positive which
takes two positive numbers and outputs a
third positive number and I have the
function that we saw before called is
positive that takes a number and outputs
a boolean so how do we make a data type
in Chen we use the keyword actually
macro data type called positive number
and data types are segregated into a
bunch of what are called sequence a
sequence means a bunch of conditions
that must be true a bar and the actual
thing that you're trying to prove that's
all they are the thing above the bar has
to be true in order for the thing under
the bar to be proven so what this is
telling you is that if I have seen if
you're if I'm looking at a form which is
plus X Y and I want to prove that that
thing is a positive number I have to
show that X is a positive number and I
have to show that Y is a positive number
that's it that's all there is to it
actually that's not it but that's it for
this example
so Shen also has a really amazing
feature of the type system called
verified types
now what this funny-looking sequin has
is it has no conditions above the bar
that means it's true it's true if the
thing under the bar has just matched
what this is saying is that if I see the
form is positive X of type verified in
the list of assumptions when I'm trying
to prove that X is a positive number
then X is automatically a positive
number what this means in practice is
that if I have a function called make
positive and I have that form is
positive X as a where clause on one of
the on one of the patterns the type
checker will see that form syntactically
match it against this form over here
and just go okay he's got some check
over there that returns a boolean go
ahead and rubber-stamp this function as
a positive number this is something that
you would use in you know languages like
Haskell or camel you would use phantom
types to do something like this so you'd
have an empty data type and
if a function passed some check you
would stick that data type on it and
expand you know that kind that data type
designates to the past and shenyu just
cut out the little man and just pattern
match on the actual arm and the actual
validation function itself so parsing
the digits from the counter is pretty
simple the digits parts are looks
exactly like the alphas parser we just
saw but we're in this case we're also
accepting like white space around the
digits so here's a function that takes
out the white space I mean a partial
that takes out the white space by
parsing white space digits and more
white space just digits and white space
and so on and we compile that as we did
before using the compile function and a
string two bytes and it outputs the
numbers but again we don't actually care
about the output of the parser we just
care that it actually parsed so here I
have a function called number string P
which checks that some string is
actually readable as a number it does
almost exactly the same thing as the
parses function that we saw a couple of
slides ago it returns a true fat parcels
correctly it returns a false if it fails
but the difference in the most important
thing here is that you have this declare
statement down here which basically says
but notice all this code was dynamic by
the way there's no type signatures on
any of this this is saying that take
some function from dynamic code and just
go ahead and give it that type don't
worry about it I got this just go ahead
and give it that type so on the type
checker and count when you turn type
checking on and it encounters this
function number string P it'll say okay
user you've told me that it's of type
string going to boolean I will just
believe you and you know and just go
with that so this is either awesome or
terrifying or both and oh I don't think
so
so the final rule of positive number
takes this number string P that we just
created as a guard which is now
allowable inside of the type checked
environment because we've declared it so
and then output something of type
readable number so the same way we did
make positive number we can go make
readable which takes the string and
outputs a readable string because it has
that guard form sitting right there and
at this point everything along your
chain is type checked so this is a
trivial example of the type system and
most of you are like hey why don't you
just go parse int and catch the
exception like I yeah I get that like so
like but the reason I'm showing you this
is because I wanted to show you a less
trivial use of the actual Shen type
system which is to actually give you
strongly typed JSON so where I work we
talk back and forth in JSON MacLean
talks to the server in JSON and the
server talks to the client back in JSON
ah it it it it's nice because it's you
know there's some kind of like you're
not you're not doing anything janky but
at the same time we end up having to
recreate code twice once on the Ruby
side once on the JavaScript side both
parts on the same JSON and if something
goes out of sync like a key then
everything goes to hell and it takes a
while to figure out so what I want is
strongly typed JSON and not just any
strongly typed JSON I want a whitelist
of keys that have turned into types so
what I mean by that is this so given
this JSON over here imagine that it's
converted to this internal Shen
representation on the right so it's a
pretty well it's it's a one-to-one
conversion key value key values are
represented as pairs so now what I
actually want is under type checking
I want this internal representation to
type check as the type on the right so
notice that all of the keys the string
keys have turned into types so like look
at this last phone number type of this
last phone number so here we have a pair
of phone a strip the string phone and
the phone number has turned into the key
value pair of the type phone and a list
of numbers so what I actually want is
when I look at the type of a function I
want to know exactly what the structure
of JSON
it takes without me having to go figure
it out and look at the actual code of
the function and so the exercise is now
turning that JSON that internal
representation of JSON into a type and
Shen is not a dependently type language
so this would be so like Duck Soup and
sort of a dependently type language so
we have to use like meta programming and
macros to make this happen but it will
sort of show you a lot of what Jen can
do so the first thing we need to do
actually if we're going to turn this
form into a type is iterate over
everything inside of the object
so basically iterate over all the pair's
at the type level the way we do that is
using this data type called object
iterator so the first thing we're
looking at is the thing underneath the
bar
so we're pattern matching on an object
on the list on the list where the head
is object and XS is pattern matched on
the rest of the list and we're saying
that the type of that is object and
whatever KVS is so what is KVS so for
that we need to look above the bar so
for the first thing we do is take all of
the things that that are after object
and we separate them using the separate
function which is a value level function
you can mix type and value level
functions in Shen so separate takes like
if you had an object of a B and C set up
a V T on the data type matches on a B
and C and separate takes that and turns
it into this comma separated list down
here with a comma B comma NZ that's what
it does and by the way the comma is just
a simple all we're doing is marking that
this list came from came from the json
object type so once we do that we can
actually have a data type rule that
pattern matches on something comma and
more stuff so if I have something comma
then we figure out what the type of that
something is and we put the rest of the
stuff as a nested type inside of that
and the same with when I get to the end
so if I have an object of a B and C the
actual type is going to end up
in a open parentheses the type of a open
parentheses inside of that the type of B
and open open parentheses inside of that
the type of C so by the way if you
haven't figured it out already the a
type the B type and the C type will
correspond to the key value pairs in the
JSON so the first thing we do is we wrap
up the pairs into some in into another
type so that this rule doesn't fire on
all pairs so what we do is if we see kvx
it is of type kv and the inner and the
int and the type of the inner pair so
all we're doing is so if we have a kv
and a pair hello 1 it type checks to kv
string number so what we actually want
now is that now that we have the object
iterator and now that we have a way of
wrapping up all of the pairs we actually
want to type check these these strings
these strings into actual symbols so
forget all of the other keys for now
just stick with user the user key so
what we actually want is for the user
key we want to generate a fresh data
type for the user key and what this is
saying is that if I have a guard on some
function that checks to see that user is
the first thing inside of that tuple the
string user is the first thing inside of
that tuple and if that thing is of type
string star and some other type B then
insert into the list of assumptions
required for some proof P that this
thing is actually of type user star B
and so what that means is in order for
me to convert a string up star a into a
kv user star a all I need is to wrap it
up in this kv and have that guard that
checks to see that user is the first
thing in that tuple and what I want is
to generate this for all of the keys
that we wish to pass around so for that
we need metaprogramming
so
first things first we have a couple of
helper functions the first function
makes a key type so like when we're
generating the user type over there this
is all this function does it takes a key
say its user and outputs user - type for
the maker which is this make function
over here it just outputs make -
whatever it is that you pass an user so
we're just generating strings at this
point so the first thing that we do is
we generate this data type right here
and that data type corresponds exactly
to this data type up here except for the
fact that all of the round brackets have
become square brackets and square
brackets and Schenn means don't evaluate
me this is just a list this is
equivalent to I think quoting and in
enlist write with means don't evaluate
this list it's just a list so we turn
all the round brackets into square
brackets which means don't evaluate me
and then we pass that into eval which
then proceeds to evaluate it so we're
building up the abstract syntax tree and
then we're evaluating so here we're
generating the type based on the key
that was passed in and the name of the
type that we generated we do the same
thing for the function so this function
definition over here corresponds exactly
to this function not including the type
signature definition over here so but
there is one piece of awkwardness it's
this cons form it's it's unfortunately
awkward this is just Shen's way of
saying splice that list in and don't
evaluate it so keep it a list so
remember we had to keep that a list and
not evaluate it so here we're saying the
square bracket just keep it a square
bracket don't turn into a round bracket
when you evaluate it and finally we
declare using that declaration that we
are used before odd to just say that
this function that we're making is of
type string star a going to kV and
whatever key that it is star a so at
this point when we run through these
functions so for example take the
original object we're trying to type
check up there and here we have a
whitelist of keys so there's off user
pass first last and phone we map them
all through register key which then goes
ahead and generates those data types and
those functions for each one of those
keys so we're not quite done yet right
we have a we have an object that we need
to translate so we have an object that
we need to translate in order to
translate it we need we can't just type
in that original object and a bunch of
pairs we have to type an object and we
have to use this make off thing because
this thing is a knob like an off key and
this make a user thing because that
thing is a user key in order to convince
the type checker that this is off that
type and in order to do that we
basically need to rewrite the top thing
into the bottom thing and that's exactly
a macro so this is how Shen macros work
okay so Shen macros are different than
macros that I've seen in any other Lisp
because they're not they don't work the
same ah there and they don't work the
same because when you define a macro
you're actually hacking the reader
because Shen doesn't have the concept of
reader because you're always hacking the
reader when you define a macro so so so
you have this def macro my awesome
object macro so in all other lisps if
you wanted to invoke that macro you
would go open parentheses my awesome
object macro and the stuff that you want
to rewrite you don't do that in Shen and
Shen all that means is that if you
whatever patterns appear inside of that
macro so for instance object macro and
whatever else that is what you rewrite
so the advantage of this system is that
you can actually do like infix operation
so basically you can have a macro that
says if i see plus XY just rewrite i'm
sorry if i see X plus y then just
rewrite that - plus XY right so that
you're actually hacking on the reader
every time you create a macro you just
don't know it which is why it looks
different so in order for me to actually
invoke this macro
have to go AAB Macra and then the list
of things that I want to actually create
the macro out of so the first thing we
do is we use this awkward-looking cons
form thing in order to splice the list
back in we have object at the head and
then we iterate over the rest of the
pair's using this dysfunction over here
which when it sees a pair we'll call
that keymakr function on that symbol so
if it sees user key maker X will be make
user right and it will just go ahead and
splice that in and continue iterating
over the the rest of the stuff inside of
that macro inside of that inside of that
form so given object code and this big
thing over here it will actually under
type checking will resolve to this type
over here and so at this point you can
pass that guy into a function that
accepts something of this type so is
there any further work that needs to be
done
sure there is like what about equality
so for instance this type system does
not so if you have a JSON type of key a
and key B and you want to pass it into a
function that accepts key B and key a
you're out of luck with this type system
over here which is kind of a big deal
and also we have a regression block with
the internal representation because you
can now legitimately have two two keys
that are the same using this type system
so I can have two key a key a you knows
yeah two pairs with a inside of it and
the type system won't complain so
there's definitely still work to be done
but it's amazing that you can get this
far and so would be nice to have some
subtyping maybe um and would be nice to
have possibly even have real
polymorphism something like that so I've
just yeah
you order a handle hydrogen in your
definition how do you know what is the
constant or what is a variable Oh
what do you mean constant or variable
yes they are non hygienic so okay so
there are the actual pretend the actual
code that generates the sample there's a
whole bunch of Jensen's that just
generate symbols for things that you
don't want to like pollute the the
namespace or whatever so I didn't show
you that because I want to show you guys
a bunch of Jensen's any case good
question I'm sorry oh so equality
subtyping rule polymorphism just to show
you how easy this thing is I've just
gone ahead and like implemented equality
for you so we can add another rule to
object iterator what this rule is saying
is that if in the list of assumptions in
the list of assumptions that you have
when you're if block if in the list of
assumptions in order to prove that Y is
of type object a you have another object
of type object B then go ahead and take
that B over there and make sure it has
the same keys as a and how do we do that
well we grab all the keys from a using
this lat up here on the top of the bar
we grab all the keys from B we make sure
that the length of the keys is the same
like there's the same number of keys in
both objects and then we make sure that
they have this all the same keys and
making sure it has all the same keys as
trivial it's just a simple function that
pattern matches our list and make sure
that the element of the list is present
in the other list and that's it that's
all there is to it
that's how equality works so if we have
a function that takes an object of type
key a star number and key B star number
and we want to output something of type
key B star number and key a star number
and we're just outputting the object
back
out we're just taking it out putting it
back out it works because of this
definition right here so this is how
easy it was just to get simple JSON
equality
can I get subtyping out of this sure I
can just check and see that I guess the
first objects keys are available in the
second object and that's it I'm not
checking to see that they're the same
length you know real polymorphism
probably take a little more work so the
point of this is not to show that the
Shen's type system is the end-all be-all
it's just that type systems can be
extremely flexible and most type systems
that we've encountered so far have been
extremely rigid including text type
systems like Haskell and O camel and
things like that so this is Shen has
really opened up my eyes to the fact
that you can actually have a type system
that sort of bends to your well as
opposed to you taking something that
somebody else's made and just working
with that here are some resources to
learn more about Shen as the Shen
website there's actually three editions
of a book called the book there's
actually two editions of the book book
of Shen there's also the book of shy
before and there's the Shang googlegroup
and that's really all ahead unless there
was any questions
yes sorry yeah no you pretty much have
to tell it like there's no like solver
or anything in there that like does any
kind of like solving at the type level
just have to tell it that yes so is that
the same as I don't understand what the
ellipses are but is that sort of the
same as where I when I pad and managed
an object the rest of the stuff inside
of that object object form went into
that pairs log card up there
to inject like via macro rewrites
something that sticks up the very end in
s expression without having the in rate
that I don't know the answer to that
sorry yeah time like usual functions
could be accessible in this yes oh oh
the question was I talked about user
level functions being accessible with
type level and he wants to know how that
works so basically just call it I so at
the type level they're operating on
types you're just passing in a bunch of
symbols and they're operating on those
symbols of the user level they're just
they're also operating on the same
symbols that are passed in via some
other mechanism it just depends on who's
feeding the function right so the type
level could be feeding the function or
something the user did could be feeding
the function if they're just operating
on symbols it's static it's this
aesthetic the Schenn also has run time
type verification because there's no
such thing as type of ratio or anything
like that and shenyu
all the types are accessible all the
time they're just symbols but the type
checker can run a user level function if
it can give it the right symbols right
if the type checker can give it a list
and there's a function that accepts the
list and does something with it there's
nothing stopping the type checker from
handing that list off to off to that
user level function like for instance
right here the same keys right so all
this I'm generating a list using this KB
to list the implementation I haven't
shown you it's actually kind of trivial
just in one take up the space and since
that's just a list I can just pass it to
that function that's accepting a list
SOCAN so I guess I think the question
might be can you do arbitrary IO in the
Shen's type system and the answer is yes
you can you can do anything you want in
the Shen type system you can launch
missiles in fact you can do whatever you
want in the type system Oh No thank you
baby
you do want to watch missiles this is a
list fun this is not a school like I'm a
huge fan of Haskell pedo like but that's
not what this is yeah yeah the interrupt
story is exactly like whatever the guy
who ported it makes it to be yeah the
speck does not have an FF I and I think
that's a very good decision on the part
of the spec only because it's meant to
be portable to any platform and if
whatever F of I that you put into the
spec almost always depends on the
semantics of the underlying platform and
if you let the porter's just decide what
that is then you have a lot more
flexibility in my opinion yes
No
so the short answer is no yes that's a
good question so in that list of 45
primitive functions that you need to
implement like in order to it like porch
ender your platform is one of them solve
the halting problem know the answer the
answer is no it's they're all like
pretty boilerplate looking functions
yeah no or who knows maybe it's a secret
weapon behind closed doors I don't know
it I have no like but the answer is no I
don't know the answer to that I haven't
heard of it um it's inspired me you know
if I don't know if it's inspired my boss
enough to how I use it in production so
yeah okay so the problem is the
JavaScript port is still not is still
not quite mature it still generates
bloated JavaScript the ruby port is
slightly better but it takes a while to
start up when it's interpreting all the
Shen so there's still work to be done in
order to make sure that the Shen ports
are good
the only good port right now that I
would use for actual production work is
the SP CL port which is what the author
originally wrote so there's that but
it's they both work they're both correct
ports as far as I can tell the
JavaScript and the Ruby they're just not
quite performant yeah
it's on my to-do list yeah yeah so the
JavaScript port as it stands right now
actually requires node in order to take
some Shen code and output some
JavaScript code and then you include
that JavaScript code inside of your
index.html or whatever and that's what
that's what's gets and that's what gets
interpreted yep yeah that's right okay
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>