<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Point-Free or Die: Tacit Programming in Haskell and Beyond&quot; by Amar Shah | Coder Coacher - Coaching Coders</title><meta content="&quot;Point-Free or Die: Tacit Programming in Haskell and Beyond&quot; by Amar Shah - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Point-Free or Die: Tacit Programming in Haskell and Beyond&quot; by Amar Shah</b></h2><h5 class="post__date">2016-09-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/seVSlKazsNk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to play free or die Johnson
programming and Haskell and beyond
alright so so what is this thing play
free our point free is a style of
writing function definitions a point
free expression is a kind of function
definition but point free is kind of
bigger than that it's a way of talking
about transformations that emphasizes
the space instead of the individual
points that make up the space so what's
this other thing tacit right so tacit is
just a synonym for quiet and tacit code
is quieter than noisy code and here's an
example of a point free definition down
here at the bottom and it's point full
counterpart so both of these definitions
describe the same function it's the sum
function and you could say the first one
sort of reads like this to take the sum
of a list of things do a write fold over
that list starting at zero and using
addition to combine items or you could
just say sum is a right fold using
addition starting it's here alright so
why would you want to use the point free
definition what's the point
of removing all of these arguments from
your I didn't mean to do that
from remove from your functions all
right so it's really simple I'm going to
say there's there's two rules but I
haven't even put them on the slide so
nevermind point freestyle is a tool for
Tacitus and Tassin is just is just a
tool for communication so that means
that when you want to make your your
code communicate better you can you can
use tests in this and you can use point
freestyle too to make it quiet why would
you want to do that one reason is that
uh is that tacit code can keep you
talking at the right level of
abstraction so that you're not
constantly switching between low level
and high level constructions here's
another example
it's a lengths pretty useless function
in fact if you ask me really but lengths
can take a list of lists and map the
length function over that list of lists
or you could just say lengths is a map
of length
so point free definitions are a way that
you can be more expressive with your
code here so so here's one more example
alright so here's a function total
number of a list of lists to get the
total number of the items and my sub
lists I want to take the lengths of all
my sub lists and then I want to add all
those together or I could just say the
total number is a composition of some
and lengths so I can use a composition
operator right here and then you might
say something like but point free has
more points okay so that little dot it's
not a point its composition and you're
better off thinking of it as a pipe if I
have two functions outside and inside
their composition works like this the
composition is a function that takes an
argument applies inside and then applies
outside I can do some Pascal magic here
I can use the dollar sign operator here
instead of parentheses just means the
same thing essentially that I want to do
this part first and then that first that
part and I can squeeze out the
toothpaste here I would say and I can
move my dollar sign at the end here and
replace it with composition of course
when I have a lambda abstraction that
takes an argument and does nothing but
applies a function to that argument that
I don't even need the lambda abstraction
so you can read this as outside composed
with inside that's probably the best way
to read it if you want to remember that
it's a composition all right so why or
so I already said that
all right so when should you use the
point for your definition because you
can use definitions that aren't point
free and you can use some that are and
here are my two rules which are really
just one rule use it when it's good and
don't use ones bad okay all right so
this was that this was the definition
that we came up with them total number
is this is the composition of some and a
map of length I decided to ditch lengths
and this is a point free definition but
if you ask me this is kind of another
useless function because for one it
doesn't communicate a lot more total
number does it communicate a lot more
than the composition of some and map
length really if you think about it I'm
mapping lengths and then I'm adding them
up that kind of gets across the idea and
another problem is that like if we take
the total number of a bunch of sub lists
that's like one way that we can
summarize all the sub lists but it's not
the only way we might decide that we
want the total max like we want the
maximum value in each sub list we want
to add those together or we want might
want the number of items in each sub
list that meet some criteria and we'll
get the total match by adding them all
together at the end so one thing I
really like about functional programming
is that encourages you to think in a
general way about problems whereas my
experience with object oriented and
dynamically typed object-oriented code
is that it really encourages you to do
the opposite is it encourages you to say
things like you ain't gonna need it so
don't bother thinking about the case
that uh that um that you haven't
actually started to use you functional
programming on the other hand because
because if you're using pure functions
you're you're restricting and you're
searching side effects you can use
wholemeal programming where you think in
the broad think about when the general
constraint applies and then you can
narrow it down to the to the specific so
to see an example of that let's extract
a little helper here total number is
this the sum composed with the map of
length but it's also just a way of
aggregating these sub lists and we're
aggregating here using length we could
aggregate using another function
aggregate here is actually a
helper function and its definition here
is a composition of a sum and the map of
that metric which I'm calling F you look
at this you actually think this is not a
point free definition because I've got
an argument over here but it's not
really a point full definition either
because what it returns is a function
this thing is a the result of doing this
thing one result is total number so
total number is a function here so we
can see all of the arguments by using a
process called a de abstraction aid
abstraction looks a little like this
alright so there's a missing argument
here there's a hidden argument a tacit
argument we can add it by applying this
quantity to the new argument and then we
can unsquare toothpaste here and then of
course you know go back to the way that
normal sane people write parentheses all
right so you saw eight abstraction but
the UM the trick here is that like a
that definition of aggregate that we saw
this one down up here at the top it's
also not point free so we can make it
point free we can remove arguments with
eight or reduction which is the opposite
of eight abstraction alright so this
looks complicated but I'm going to walk
you through this all right so we have
aggregate f and it's the composition of
sum and map F composition remember is
just a function it's being used here in
an infix notation but it could just as
easily be used in a prefix notation so
we'll just do that now over here I just
have the parentheses here and I'm
trading it for a dollar sign it just
means that I want to do this first and
then I want to apply this function
afterwards I can squeeze out that
toothpaste here and make this a
composition and apply this at the end
and now just to show that like I don't
really want this argument anymore I'll
just switch it over here and write this
is an anonymous function like a lambda
abstraction here with them with the
argument starting here and it's not so
much changes here and because I have a
lambda it starts with an argument and
doesn't do anything but apply a function
I don't even need that argument I don't
need to write a lambda so
oh I've got the composition here of this
thing and Matt and I can just write that
in fix as kind of like a it's called a
section so I've got half of the
composition half of the composition of
some compose with map that's great that
makes a lot of sense right I mean like
it's that's easy to read it's easy to
understand alright so we have these two
things we have this not point free and
not point full definition and we have
this one it's completely point free and
and you know you're already probably
thinking like this is terrible because
they don't know what this thing is I
don't even know how to say it so let's
look at it a little more closely it's
it's a function that takes two functions
F and G and it composes them in a weird
way it combines them not quite composing
them composes this part with that and
that things like half of a composition
alright so this thing we can a to
abstract this thing so that it looks a
little bit better and you don't have to
go through all these steps just take my
word for it you can see the X filtering
in here and then I realize I can add a Y
to and I end up with this down at the
bottom and what I have is a pipe I have
something I have a function here that
takes two arguments one argument after
another and then it applies another
function to the resolve so this thing is
a company a Combinator it's a lambda
expression that refers only to its
arguments there's nothing that it does
that isn't here the only stuff that it
does that is that isn't here is part of
the system the application of a function
so it's a combination of combinators we
have this one the one that we're
currently investigating this one up here
is composition the one you've already
seen because it just applies X applies G
to X and then F did to the result and
these things that you've also seen are
not combinators because they make
reference to items objects that are not
here in the argument list so
we have our Combinator and it turns out
that this Combinator hasn't
it's the Blackbird alright so where's
that name come from this is a Raymond
Smolyan he is a he is perhaps was he is
um a professor of philosophy and logic
and and he wrote a puzzle book a logic
puzzle book - Malcolm Mockingbird and
other logic puzzles a an amazing
adventure in combinatoric logic so
basically takes you on a tour of the
forest you get to meet a lot of birds
and the birds say different things when
you tell them the names of other birds
and this bird is a black bird all right
so here's our blackboard I decided to go
ahead and give it a name I'm going to
give it a name dot dot dot and it looks
like this if you give if you can apply
it and fix here FG f Blackbird G or the
black bird of F and G it means that and
I can add or reduce again and this is
just the same distance that we already
traveled and we can get back from this
expression back to this one it's a pipe
with two inputs you know what it turns
out that this isn't since this isn't a
point free expression I can go ahead and
write a point free definition of
blackbird if you want to see it
so this is crazy the Blackbird is the
composition of composition and
composition alright so we have a new way
to write our our function aggregate it's
the Blackbird of sum and map now I'm
actually not I'm actually serious here
like I don't think this is a joke I
think this is this is great because just
like hear me out this is great because
just like how composition is not a thing
that we think about like it's not like
I'm it's not like when I try to
understand composition I go back to the
Latin words and I tell oh it's the calm
of the posing like instead I'm just like
composition is a is a pattern that I'm
familiar with I see it and I and I and I
become I become familiar with it
Blackbird is a is a pattern that you can
also become familiar with you can
remember to start off that it's a pipe
that takes two inputs takes the two
inputs and then it applies a function
and then applied to another function but
after a while you just remember that
it's black alright so I want to give you
an example I apologize this examples a
little bit mathy but it's like the kind
of math that if i mean it's if you
forgot it that's totally fine but it's
like it's it's it's it's up very early
from from your math education alright so
you might remember the Pythagorean
theorem and a squared B squared C
squared right so there's the distance
from the origin to a to a point defined
by a vector you just square up the sides
take the square root but that's not the
only way that you can measure distance I
mean you know if if you wanted to tell
me how to get to some other part of the
city I wouldn't care so much with the
crow flies distances I want to know what
distance it's more like this how many
blocks do I have to walk to get there
and to get that you just add up the
absolute values of the components in
your page so um so what if we wanted to
to to work with n-dimensional distance
you know like um say we're talking about
big data and we're talking about vectors
in space and how and how close these
vectors might be to each
well then we might use coordinates in a
list instead of just two of them all
right so with a couple of helper
functions here we can go ahead and write
these definitions like here's the square
there's a square root and here's an
absolute value and so we're aggregating
squares and then taking the square root
to get the Euclidean distance and we're
just aggregating absolute values to get
the Manhattan distance of course we can
run these through the the console and we
get some we can for one weekend the
sandy check here this is this is a
little further distance than a Euclidean
distance but there's something here
between these two definitions that's
like trying to get out there's something
they have in common that um that maybe
we can extract and then we can
understand distance a little bit better
as a general case so let's try that
what's happening here we aggregate an
inner function and then we apply an
outer function so here we aggregate
square and we apply the result square
root here we a great absolute value and
we well it doesn't really fit the
pattern like something's missing here we
don't do anything here but it turns out
that not doing anything is also a
function so now we have these in the
same form that means that we can
actually write a definition that we can
use to derive these and here it is
distance outer inner is the O composed
with the aggregate of I and so these
point free definitions here generalize
distance or they are special cases of a
generalize distance all right so there's
a there's an example but you notice that
like distance oh I equals o composed
with aggregate I that this is not a
point free definition right well we can
look at a couple point free definitions
or we can look at one in particular
you'll eventually get here with a de
with a de reduction but of course if you
know about the Blackbird then you'll get
here which is not as ugly but still it's
not it's not really good honestly it's
not good because um what is half of
Blackbird me and that's half a blackbird
of aggregate I don't know this
definition isn't bad but it only
mentions the oh and not the I and kind
of think of these functions when you're
talking about distances like there
they're on the same plane of importance
so I would stick with them but the
second one here and I wouldn't go to the
point full definition because I don't
want to have to talk about the
coordinates if I'm talking about the
distance all right so tacit programming
is not an all-or-nothing thing and of
course you know I tricked you all to
come here by giving you an extremely
fanatical title you're not gonna die you
should use just enough Tacitus to
communicate that and sometimes you'll
find often you'll find that the
partially point free definition is the
one that you like the best
so you should learn to do a reduction by
hand a reduction in data abstraction you
can find tools to do it for you because
it's completely mechanical and so you
can let the computer do it but the
result that you get might not be useful
to you so it's worth it to learn how to
do this really mechanical kind of
algebra all right now I've been showing
you examples in high school point free
isn't really about high school it's just
a concept it's easy to do in high school
and F sharp and okay and well I've heard
it's you can jump through some hoops and
do it in closer and elixir I don't know
any of those languages to be honest so
I'm going to show you one that I do know
one that I get paid to know sorry so
let's see some point free Ruby right all
right so if you know some Ruby this
might make sense to you otherwise you
can ignore it
a monkey-patching proc
okay basically Ruby doesn't to have
first-class functions in Ruby you have
to use an object an instance of a class
club proc and you can make these literal
procs this way but otherwise you don't
really have first-class functions you
get past methods around you can't pass
functions around so monkey-patching proc
here so that like calling to actually
calling a function is going to be less
noisy and and i also actually defined
compose so i'm monkey-patching that you
and you can see these examples i have a
function here that anonymous function
that that I give that I've given a name
plus 1 and adds 1 to something I have
another one that times 10 if I plus 1 of
2 I get 3 if I times 10 of 3 get 30 if I
if I make a pipe out of those two and
then apply to you to it I get 30 so
let's see what compose looks like here's
compose and of course Blackbird is the
composition of composition and
composition and we have aggregate as
well and these are these are all
definitions that you've already seen so
I'm so I'm not going to spend a lot of
time on them and we can have all of
those versions of distance as well these
are all the same function they do the
same thing
I didn't write tests to verify that but
so the most point 'fl one looks like
this I've got I take an outer function
an inner function and a list of
coordinates and then I have to aggregate
the inner function over the list of
coordinates then perform the outer
transformation and these definitions are
just like the ones that you saw on that
list but why are they so noisy like why
aren't they so messy just a reminder in
Haskell it looks like this and really
it's looking like this so the reason has
to do with something called currying
alright um something that you may know
if you know high school is that have a
high school function any high school
function only receives a one argument
and if you don't know how school I
probably sound like I'm crazy
because I just showed you a bunch of
functions that have more than one
argument but but in high school
functions are automatically curried so
an expression that looks like this you
know take XY and Z and then do something
return something actually is this take X
and return a function that can take Y
and return a function that can take Z
and then return you some value so high
school makes a deduction easy by
automatically currying all of its
functions because when you ate a reduce
you're removing one argument at a time
all right so I'm I discovered point free
notation I think like just a few months
after I kind of got into Haskell and I
got really excited by it
and I kind of went overboard with it and
I was doing some I was doing some
problems some exercises involving the
game mastermind so if you want a little
refresher game mastermind looks like
this many fun hours I'm sure you spent
with them with your hated siblings um so
there's a code breaker and a code maker
the code maker is a secret code it's
made of pegs and they're in colors and
the code breaker is trying to guess that
code and every time that code breaker
guesses a code they get feedback that is
um you have this many exact matches you
have this many pegs in the exact right
spot and the right color any of this
many color matches which are like the
right color but who knows what spot so I
have a couple of definitions I did have
a couple of definitions in my exercises
um this was for a CIS 194 course you can
just find online and do if you like um
and let's look pad for exact matches so
I pulled it up
oh sorry well I'm actually going to walk
you through exact matches first all
right so say this is my code or say this
is yeah see this is the code and this is
my guess against that code or how do I
decide how do I calculate how many exact
matches they had and this is this is
fairly straightforward we just need a
pairwise comparison we just go through
and these are the same so so that's what
this is if we if we ask you are these
the same answer is yes no no
no add up the yeses and we get one so
one exact match alright so here's my
definition for exact matches alright so
don't how to parse this in your head
just notice right away that this is the
point free definition and notice also
that I've got this little pattern here
which you might remember as the
motivation behind naming a blackbird so
let's go ahead and fix that all right so
now this is somewhat somewhat less noisy
to look at there's like less parentheses
it's sort of easier to see and we have a
blackbird of this pipe and zip with
equals so basically I have a pipe that's
like kind of in two parts or you could
think of it in three parts I've got
these two parts and this part over here
is also in two parts and it takes two
lists of pegs zips them together with
the with the equals comparison filters
the ones that are passed the comparison
where where the value is true and then
takes the length of the result so so
here's a comparison of those two of
those two functions now it's my opinion
that I'm that the one on the top
communicates better and maybe that's
something that that I might need to sell
you on a little bit better but a point
free definition here lets you stay at
the the level of abstraction where
you're talking about transformations on
lists I have one transformation that
brings two lists together I have another
transformation that um that filters out
the ones that that have the values that
I like
I have a third transformation that
counts up the values all right so let's
go look at how I'm how I did with color
matches all right so we're looking at my
old exercises from not really that long
ago and this is this is a possible
scenario here same scenarios before so
how do we decide whether how many color
matches we have all right the first
thing we need to do is that we need to
ignore position because position doesn't
matter anymore
we need to collect
pieces that are alike that we want to
compare so we can run both of these
codes through a function that um it
changes the way they're structured and
we have something more like this all
right so we've got Reds over here greens
over here
blues over here and I've got two on both
sides so I've got two matches I've got
one over here and two over here so I've
only got one match here I've got 0 &amp;amp; 1
so I've got zero matches so it's 2 plus
1 is 3 so I have three color matches all
right so here's some code that does that
alright so this was this was the code
that I that I attempted to pass off as
as code that is easy to understand and
communicates what it intends to do and
it's it's it's it's objectively awful
and if you went to any presentation
presentation today where like someone
told you that you can prove things with
code somebody please prove that that was
awful all right so so um so that didn't
work so so let's go back to a fully
point full definition all right to get
the color matches of two sets of pegs
two lists of pegs what I want to do is I
want to count the colors in each of them
I want to zip them together taking the
minimum of the values there accounts and
then add up those counts together just
like we did on the slide a couple a
couple slides ago but if you ask me this
is really irks me that I have to say
count colors twice here like like I have
this kind of I have this um this
transformation it kind of looks like
this I have this two lists they're
coming together like this and I have to
do something here to put them together
and then I've do something after I've
done that but then before I put them
together I actually have to run the same
transformation on both of them so I
think something I didn't know when I was
when I was writing that old point free
definition was that um was that there
was a way around this that was much more
elegant in fact have this kind of
problem involving combining functions
I wonder there might be a combination
for that and there is um it's called the
side Combinator and it actually lives in
Haskell it lives in a module called
data function and it's called on here's
a type of on you can do have the console
and see this this looks a little scary
if you're not used to it but it's okay
this thing is a function that thing is a
function and because this little bit is
automatically curried it's not presented
in parentheses but it's also a function
to so on takes a binary operator that
takes two B's and makes them into a C it
also takes a function that transforms an
A into a B and it will give you back an
operator that will take two ways and
then give you a C as a result so I can
use it here I can take this zip with min
on count colors and here I'm using an
infix notation instead of a prefix
notation you could imagine on being here
but the back ticks might mean that I can
put the in the middle so this actually
reads well too so if I count colors of
both I can zip with min them together
and I get a function that looks like
this
choose two lists of pegs and they give
me back a list of numbers all right so
let's go ahead and try it out all right
so now using on I can do something like
this if I want the color matches of the
two lists of pegs I can zip with men on
count colors apply that to the list of
pegs and then get the Sun and of course
I don't need to use the dollar sign I
could use the parentheses instead and of
course this might be even easier to
communicate to people who are not
familiar with high school but if I'm
looking at this there's actually a
pattern here that we've actually seen a
few times if I want to get rid of these
I wonder how would do it and it turns
out it's not too hard what I have here
actually is a pipe of a function taking
two inputs and then and then I'm using
an outer function so I have a blackbird
all right
so here's the point for you definition
of color matches that I think
communicates very well we want to zip
with men on count colors and we want to
take that result and summit all right so
here are two functions that look alike
now see here's the point full version
the version of that that worked being I
guess and here's a version that I that I
came up with them just by using a de
reduction with what I knew and here's
what what we could do today so when
someone says you don't bother with point
free you're just going to end up with
obvious obvious cated code it's not
worth it
remember that there's more than one way
to do point free there's more than one
way to to arrive at a point free
definition but what did we do
differently what was different here like
why did we come up with something that
was better a cleaner more elegant and
the difference was that we knew about on
and we knew about this way of composing
things in a pipe that takes two inputs
so some advice if you want to do point
freestyle learn a de reduction because
you want to be able to find the
intermediate step that works best for
your communication and learn Combinator
so that you can use them so when you see
a pattern that comes up again and again
you'll be familiar with them because
this is what we do when we learn to
program we learn to see patterns that
come up again and again and we learn to
apply them alright so this is a guide
two point three point free without
dieing point free is just a tool for
communication and tacit code isn't
better unless it communicates better so
point free and die point free or die the
choice is yours alright so I wanted to
say some things that are beyond there's
a lot of stuff that um that I said that
I would get to that I didn't point
freestyle has a really long pedigree as
a long history and it comes from from
conversations in computer science about
how we could make programming and how we
can make computing more composable and
how we could actually build abstractions
that are concise and still don't leak
and that's something that we're still
chasing today and I know a lot of people
will look at syntax the point free is
all about questions of syntax a lot of
people look at syntax and say
syntax is just not important but I think
nothing could be further from the truth
syntax is where we communicate and how
we choose to communicate will make
programming what it is for the days and
years to come
Thanks
looks like we have time for questions
yeah question was what if you have a
function that takes three arguments and
the answer is I leave that to the reader
all right
any more questions yes do I consider let
I've never thought okay the question is
do I consider lens operators point free
I've never really thought about this
I think the question of whether their
point free is a pretty easy one to
answer it's just the point free is a is
a is something to say about the the
implementation so if you go back and
look at the implementation and it has
arguments written then that's a that's
not a point free definition but if it
doesn't then it is a point free
definition but I guess maybe the
question can be more like can you do
point free stuff what that's something
off to take home and think of that but
thank you because because now I have
more to think about anymore
yeah it's a great question so the
question is like um if you want to get
to the point where you're used to seeing
patterns and use them over and over
again like how do you get to that point
and how do you communicate it to others
um I think that like you notice this
there's more than one way to learn
things right I mean there's the there's
a way that's like um you're going to go
out and get a book about it and read it
and learn it and then or practice it
until you learn it and then there's also
the way of like just doing things that
are kind of in the same zone until you
start to pick up the the skills that
sort of happened again and again I think
both are valid if you want to learn
count Combinator's by going on studying
Combinator's I'm planning to get through
this logic puzzle book the Mokka
mockingbird and I would love to read it
with some of you if you just want to do
exercises that help you get to know
Haskell and get to know functional
programming better I think that these
patterns going to come up and you'll
just become curious about them yeah the
title of the book is to mock a
mockingbird
I believe the subtitle is and puzzles
and combinatorial logic or something
like that it's by Raymond's mullion any
more questions yeah
yeah well if her I've heard people say
things like um like syntax is not
important or let's not get into
conversations about syntax I think it
might be it might be like a sort of
defense mechanism against getting into
arguments about syntax because it's it's
easy to bike shed about something where
like where there's no there's no like
clear answer it's not it's not clearly
true that this definition is better than
that one I think I presented some
definitions that maybe some of you
didn't think we're better than the UM
than the the counterparts and so it's
easy to get into an unending sort of
conflict over like which one's better
and I think that some people avoid
conversations about syntax just just to
avoid that um I think that the fact that
we can't come up with a clear-cut answer
about syntax indicates that it's very
important and that it's uh that the
syntax is a really really important
thing it's it's it it's um it's where we
have many strong feelings because it
really matters so so yeah I think syntax
is important but but I don't pretend to
say that there is one right away all
right well thank you all for coming
and hope you enjoy the rest of strangely</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>