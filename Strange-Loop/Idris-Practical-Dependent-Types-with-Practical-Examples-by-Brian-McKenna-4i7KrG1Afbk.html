<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Idris: Practical Dependent Types with Practical Examples&quot; by Brian McKenna | Coder Coacher - Coaching Coders</title><meta content="&quot;Idris: Practical Dependent Types with Practical Examples&quot; by Brian McKenna - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Idris: Practical Dependent Types with Practical Examples&quot; by Brian McKenna</b></h2><h5 class="post__date">2014-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4i7KrG1Afbk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm going talking about Idris Idris
is a new program language based on
dependent types I could just say that M
types types that depend upon values and
I'll be done I go home now I don't think
that's very useful so I prefer to
demonstrate it and point out where
dependent types actually come into
action so this is a this is some
motivation this is a drone that runs
something called SEO for it's done by
the people in Nick tar in Australia the
SEO for is a formally verified kernel so
it verifies that you can't have buffer
overflows kind of integer overflows kind
of null pointer exceptions all memory
access is safe if the drone itself tries
very hard not to fall out of the sky
which i think is pretty cool in pretty
important there was this great
presentation by welter called a ventures
in extraction it was an experience
report of writing X mana in Cocke kakuzu
is a language for formal verification
and with depend types in the experience
report he says extraction is not yet
mature extraction is the concept of is
that is the implementation of taking
formally verified dependently type code
and creating an executable from it and
he says it's not yet a matured
technology this is in Cocke and this was
from like four years ago but it's about
the same right now users piano numbers
so this is an inductive data type so
what he was doing is extracting from
 to Haskell and piano numbers are
really inefficient is just an inductive
data type so if you have to represent
1,024 you have to have 1,024 objects in
memory which is not good used a lot of
unsafe coerce which is telling Haskell
to just trust the extraction process
which I don't and there's a lot of blood
sweat and shell script that's not good
we don't want to write some formally
verify codon and have some shell script
involved and in fact here the said
script to patch
so he wrote formally verify code how the
dodgy shells a sad script to go and
replace things in the in the formally
verified output it's not nice I don't
want to have to have a said script when
I'm trying to implement something
correctly so address is a take on trying
to make dependent eyes more practical so
when I say dependent eyes being
practical we can see that SEO for is a
thing and that people actually using it
to try and make drones not fall out the
sky which i think is very practical but
in terms of making executables I don't
think that's the case with SEO for as
far as I know there's a there's proofs
written in Isabelle about some Haskell
code high-level Haskell code that
implements this kernel and then that is
extracted or manually translated into C
code to be executed on the drone so
there's about three layers going on
there's Isabel which is doing the formal
proofs of the memory access and of
overflows and then there's the Haskell
layer which is a high level
implementation and then C which is the
real implementation so there's a lot of
cost involved in that and there's a lot
of margin of error so we can do better
and I think executing dependent having a
dependent type language that compiles to
executables is the way to do that and I
want to come up with some practical
examples a lot of the examples are like
concatenated vectors together I'm sorry
but it's not very practical
so one do a little bit better I don't
know if I'll get all the way they belong
to a little bit better so here's a
project called iridium this is something
that I started working on it's a window
manager just like X monad but ringing it
in interest it's about six percent
interest and 40 percent objective-c
that's to call into the Mac api's I need
to go into the idea is that's going to
be extracted though we've got this idea
of being able to interpret these effects
to execute on the platform so we could
theoretically have it work on x11 or Mac
so I'm just going to show it working so
we can see some dependent types actually
running
let me create another window first there
we go
so we see dependent eyes actually doing
things here moving windows around
changing layout so that's all paddled
through address so we can actually write
real programs for dependent types which
i think is awesome and we finally go
into that stage what I really want to do
though is actually write some different
types in front of everyone
so we can learn together and I'll be
able to point out where depend types are
coming into effect
so let's yeah let's let's do it so the
first one I want to do is a proof of an
algebraic law about a data type so I'm
going to define something called a bit
it's got two constructors I and I and oh
this is measuring zero and one of course
what I want to do is write a function
that does a bitwise or over this data
type so I'll just implement this it will
we'll see we'll see how we go so the
implementation we have to see something
about X and X 1 so it just allows us to
deconstruct these things and create
pattern match on it so in the case that
we've got oh and that should be X 1 in
the case of I that's you're just VI
does everybody agree that this is or
please don't because I'm going to prove
that this is somewhere in the right
direction
so what we should what a property of or
is that it's associative so what that
means is that A or B or C equal
a
so that's the associative property and
we should be able to prove that that is
the case it's not going to prove
everything about the all function
there's a lot more that we could prove
but this is one step for proving our
property of this or function so we know
that if we were to prove this we know
that at least we didn't stuff it up that
badly we might have still stuffed it up
but not not that badly so I'm going to
make a function call or associative it
takes a bit a little bit a little bit in
this code I wrote just here is actually
exactly what won't approve that's
actually address type the type is that
these things are equal that's actually
typing interest so the first thing if we
load this up it just says we're trying
to prove this thing which is well
exactly what I wrote down and we've got
a beam scene scope now it doesn't know
what the a beam sees actually are so
what we can do is again pattern match
load this up and now we've got different
things that we have to prove so we have
to prove that or B and C is equal to or
B and C that's pretty easy right
so there's actually constructor called
raffle in a dress that does exactly that
when two things are exactly the same and
a Juris knows that there is likely
saying that you actually show it to you
as being the same thing it's the same
thing raffle is that thing the other
goal that we had to prove was that I
equals I I think that's pretty easy as
well what I'm actually doing is pressing
ctrl c ctrl a that gets addressed to do
a proof search so we'll actually find
the proof for me I'm not actually typing
it like interest is constructing my
program for me we'll have to do is pad
match and it found the program for me
which i think is pretty awesome
now all probably isn't very practical
but I've got a little bit a little bit
more that we can do
so we've got this bit string which is
list opiates and see how I've just
defined a type as if it was just a value
so what we'll do is make call BS or just
because so this will take a bit string
a bit string and we're talking pestering
this is like all but with whole strings
rather than rather than just one and
again we'll get you just to we'll see
well interest will patent match for us
and so what we'll do in this case is
just accept whatever your interest is
given this I don't know I'm just making
this up
I don't think that's right there is it
right I think it's basically right in
this case that it's going to be a bit
more interesting we don't want to accept
whatever it just gives us so this one
will or these two and then what do we
want to do
something like that I don't know if I'm
doing it right but it just will
hopefully help me out in a minute so
we've got this bit string or tried to
implement or / bit strings and all over
just a single bit will do basically what
we did before except now we're working
with a bit strings rather than just a
single bit
so everyone see that what we're doing
we're doing any bit strings rather than
just bits so approving the associativity
of whole strings bitwise or the whole
strings so interest is going to tell us
what we need to prove which is likely
we'll just stated what we can do is just
accept whatever it is going to give us
so in the case that we've got an empty
we've got the we've got the empty bit
string then it's the same like B is just
it's just BS or B and C and we just keep
deconstructing each of the each of the
fields in any case where we've got an
empty one we're done once we get an
empty bit string we can prove that those
thing is just using the other two now
this one's a bit more interesting
so this one's asking us to prove that
these two things are the same and
there's there's multiple things going on
here so there's the social dividend and
then needs to prove the associative 'ti
of the rest of the list so what we can
do is come up here an interest will ask
us to start proving things so it just
got true languages in it one of them is
the Idris language which you can write
the value level on the type level but
then it's also got a tactic language so
you can actually write proofs in
different sort of language which is a
bit more familiar with bit more familiar
for most people and also a little bit
more success for a lot of cases so
here's the goal that we have to prove
that or and/or is associative we can see
that they're different and we need to
make them the same thing that the goal
is to make these two things the same
thing the the these two wars this one
and that one so we've already proved
that or is associative right so we can
do is rewrite that goal with our proof
and you see that can everyone see the
difference there so we've proven that
the first part is the same so a part way
there and what we should also do it's
pretty the last part
do those things at the same nail so
we've done it for the second we've
proven that the first part of this list
is the same proven that the second the
tail of it is the same so we can write
now is trivial here's the best part
right QED only your interesting sets
that out so it's it's proven that that
our bit strings are especially like at
least got that much rate I might have
gotten some other parts of the algorithm
wrong but I've at least proven this
property I could prove a lot more about
it but I'll stop there and move on to
the second part so that goal was like
correctness we could prove certain
properties about a program what I want
to show now is the expressiveness of
depend types and try and implement
something that you probably couldn't do
unless you have macros it's actually one
of the motivations for things like
macros so I'm going to make something
called bin char it's indexed by a
character so we've got a value at the
type level hand we'll do something
similar like we did before so you've
been charm we can actually use a
character and put out the type bring it
to the top now much ba1 know yeah so now
we've got these two constructors and
they've got a they've got a value thing
in the they've got a value at the other
type level so now what we need to also
do is have some I want to make a proof
that everything in a list can be or
something hold some sort of a predicate
so this predicate is actually going to
be from a from some value in to a type
that's going to be that's going to be
how we predicate a value and I'm gonna
have a list of those things so the proof
so we'll have a list of the values and
also the proof that a particular value
sorry we'll have a proof that the
predicate holds for each of those values
this curly brace is actually full
setting something is implicit so you
don't have to give it each time when you
construct this address we'll try to
figure it out for us so we'll have some
predicate and I can make an every so if
you give me an empty list that pretty
good holds if you give me a cons
then you have to give me a value that
that you have to give me you have to
show me the predicate that that value
holds ball and then give me a sorry give
me give me the title
oh yes thank you
so what we've done here is said that
flora valued at the predicate holds form
and a tails for so for the rest of them
that rest of the list that this thing
holds for then we just put that value
onto the list and say that it holds for
everything in that list again I'm going
to write a function that says for every
for every bench are in some list we can
get out our given given a natural number
we get out on that so this is going to
be converting from these binary
characters into a natural number then
that there's going to be an accumulator
so again we'll split
what we have to do is actually split bit
more than this because what this ones is
what we have in scope it's just some bin
char we won't actually do something a
bit more interesting that we want to we
want to see what type of in charities so
in this case we just want to curse in
the case that it's oh it doesn't
actually so it's zero it doesn't
actually add anything to the number
we're just this accumulator is the
actually sorry the count of how many
bits we have so we're just decrementing
that but in the case that we have I we
want actually raised true to the power
of K and then Lim recurse
I don't know if this is the right thing
either I'm sorry but what we can do now
is that given a string we can also ask
for a proof that everything in that
string is a bin char and so I can't
remember the name for going from a
string to a list of characters but what
I can do is search for it if you can see
that so you just kind of have like a
built-in overwinter which is pretty cool
and so we can see here that there's
something called unpack that's the one I
want so I can just type unpack s so what
I'm doing is unpacking the string that
we get as an input and asking for
evidence that everything in that string
is a pinch R and I should print under
than that so we can do is here this is
actually using the proof so we can
actually use the proof at the value
level we're going to save so this was
going to be from bin chance and
something like that so I should be able
to load up the repple now right so Idris
doesn't find the evidence it doesn't
automatically find the evidence that
every of every character in that string
is a bench are so interest actually has
a feature and you just put Auto before
that and we'll do the proof search like
I said before how we're searching for
proof is going to do the same thing it's
going to try and see if we can construct
a bin child for every character in the
list so if I reload this this caused
your network supposedly that's 23 I
don't know if it's true I know that's
three so you can see that we've kind of
made our literals in some sort of sense
because we can't type in that it just is
not going to be able to find evidence
that that's a bin child because those no
those those digits have have been chars
you know only work if you put in putting
things like that what we can actually do
is say well what's the SS is five that's
four that's great for and so if we go
example one so it'll say it's a
completion error and I'll actually give
us the real thing
so we can actually even leave examples
of our evidence
sorry eval eval program in inside those
types and say this thing holds true and
if we were to modify this any of our
functions it would only compile if this
also compiled which i think is pretty
awesome it can leave examples in and
only make a compile if if the value
level holds which is pretty cool and so
I've got one more example and this is
probably my favorite on so I was looking
for some sort of example of computation
of complexity so I asked my coworker
what's what's something that you've done
recently where the computation
complexity wasn't very good he was
describing this algorithm where he had
he had to compute things over days
every day and so every day depended on
the previous day so for day one it
depended on day zero which didn't exist
but so we computed for day one day two
depending on day one and then day three
and day one day two so we can see that
this is this is growing you know in a
bad way this is actually a factorial
complexity I'd like to prove something
has a factorial complexity which i think
is pretty cool so what I'm going to do
is try make a doll type good cost
so we're going to make a double toggle
cost it takes some sort of type and it
also takes an at but that is the actual
cost of what it takes to compute that
value of that type the constructor will
actually take the cost because it's at
the type level we don't really care
carrying around a value level we don't
have to do that we'll just carried
around the type level we don't need to
carry around the runtime cost at runtime
so we'll make a function put own cost
we'll take a cost
you just wrote my program I was pretty
cool um but this will take the value out
of the cost this costs a dollar type
that I've just created so we can we can
just use it without having to wear
without having the type be actual will
contain the cost awesome I'm going to
make this a monad there's an interesting
reason why I'll get to that in a minute
but we'll make the return just take a
tea
give us any any cost so we can return
late if we want to say return and say
the cost is a thousand we can do that we
can make any value any cost which is a
problem and it should probably be
private but I'm sorry okay
so I'm going to write a monitor this is
going to be the blind so given a cost
what should the cost of this one that be
you want to take a guess
and plus them which is pretty cool so if
we have these depending computations
it's just the cost of doing those both
of those
so I'm doing some not very nice here but
so we calculate something we calculate
the B cost so the cost of doing B we
actually remove the cost completely and
then we say well the cost is actually M
plus M so here I'm doing something but a
bit loose and I'm just saying
trust me it's n plus M it's just
something that I've defined the one that
is M plus M I could do n times and and
it just will just accept it so there's
there's no there's no verification here
this is just just stating that bind
means n plus M so what I'm going to do
is write a function that says given some
tell me to do something n times
and something that cost something and
also initial value like an accumulator
then the cost should be anyone wanted to
get to this if we're doing something if
we're doing this cost n times
watch the Kospi yeah so the cost is just
going to be doing that thing n times
it's it's really simple
it's in the case that we get to the end
so we've done things n times this is the
base case in case that we've gotten to
the end and we need to do things zero
times then we can just return it and say
the cost of doing that the cost of
returning is value is 0 so this return
is actually the type of it is is is
going to be cost of zero of a in this
case we can you start using the do
notation this with the cost this with
accumulator so if we do the thing we get
the value out of the cost because that
we get passed in then we also want to
recurse and do it a few more times just
append these things together I'll do a
cumulative plus so interest is just
verify that that is in fact n times n
this should not compile there you go
yeah so it's we haven't proven that it's
asking for a proof that I'm sorry it's
saying that the they're not the same
thing that n is not is not n times M it
means I'm not actually saying that but
that if you keep going and keep
increasing the balance that's what you
get to so they're going back to my
co-workers problem he said that uh for n
days it was a factorial the cost was
factorial so I want to this isn't his
problem this is nobody was trying to do
but I want to show you something with
complexity of factorial
string
so we should be able to construct some
sort of value that has this cost as a
factorial cost
so uh no this is a function that should
theoretically yeah it type checks so it
does something factorial n times this is
because we're recursing over doing the
day and we're also doing it in n times
so I'm just going to show what this
outputs is if I ask for the day zero
so you can see that it's that it's
climbing up in cost so I went from cost
of two to cost of 24 exceed cost of five
has gone up 220 right yeah you can see
that it's making some big string what if
we asked for day seven it's kind of
costly so this is some huge value is it
like five thousand or something I don't
know I don't want gotta leave blank here
we go so it's it's some huge string that
we'd probably want to have a compute so
theoretically we should be able to bound
this and say never compute anything
that's what value I put in seven should
never be able to compute anything more
than seven so theoretically I can make
all of this private and only expose this
function where I say I only do things
that are less than than seven
so there's a function like they can go
from so Finn is a is a actually there's
a there's a cool feature in address here
if I can remember up here we so on we
can say like we can ask for
documentation so Finn is something
that's less than some balance we can say
Finn of seven would be have to be some
number less than seven so we can run
programs as long as you give me a number
that's less than seven and it's also in
fact takes a natural number so need to
go from a fennel and to a nap and here
we go there's that there's a function
for up
that's going to give us a string
so we should be able to do that fin -
nothing again
if we load up the repple so if we u-turn
the user ah more firmly exposure on in
this module we could run anything that's
less than less than seven but we can't
run anything more than seven we kind of
run we can run seven has to be less than
this it's pretty cool that we've proven
that our so first of all we've proven
that the cost of evaluating this
function is factorial so the
computational complexity is factorial
doesn't necessarily have to be
computational we could theoretically
make this memory so the memory usage
would be factorial we've proven that is
factorial and we've also proven that
we've also made a function and meter so
that you can't run factorial for
anything greater than six it should
pretty cool so we're going T that the
runtime is within the some sort of
bounds look is there anybody impressed
by that
I was it's pretty good yeah so so you
just learnt the ABCs of I'm sorry the
algebraic laws the binaries and
complexities of of Idris I think this
gives some motivation algebraic laws
give some motivation for correctness if
we were to write a lot of algebraic laws
about data types we could have some sort
of confidence that our algorithms are
correct
I've given some sort of idea about the
expressiveness of different types we can
have binary literals so we can prove
that only zeros and ones are in a
particular string and not only that but
they can be converted to a natural
number and we just use them I've also
showed that we can track computational
complexity inside of the type system and
we can put limits on what what we would
like to execute what I showed with the
computer with the complexity was that we
can calculate exactly what it is but we
could also theoretically have best
cached worst case and also average case
there's no reason why we can't try that
inside the type system I also showed
that we could do we could write examples
inside of our programs and only let him
compile we thought if that example
actually worked at the value level so we
don't even have to open open up a raffle
don't have to write some tests we can
just write them as types inside of Idris
that is all the content I have and
there's one final photo of my dog he's
he's at home at the moment I'll miss him
yeah that's that's it thank you
we've got six minutes for talks for
questions yeah
yes I mean I won't say it's a cost it's
an assertion okay I'm happy to cast it
like so yes I have to I have to verify
that the blind that I've done the right
thing there but I could come up with a
different model maybe I wondered so that
cost multiplies each other
I don't know
yes blind has to be correct and
everything is predicated on that yes yep
it's pretty cool even if it's cost
oh no I'm gonna have some more questions
I've got like six minutes there yeah
like a like a
yes you have to do exactly this you have
to give me some you have to give me
evidence that everything in the list can
be converted into a binary character so
you have to write some sort of filter or
prove to me in some way that everything
in that string has a binary character
and you have to give me them but yes we
could do that like it's it's very simple
study is exactly the evidence you have
to provide at at runtime sorry I
compiled time to prove that your thing
at runtime is going to work yeah very
easy yeah
sometimes works what do you mean by
through cools I don't know what that
right do you have to manually pass
through everything and show evidence the
question was how well does a dress work
with actually having to carry through
proofs everywhere throughout your
program and show evidence to the
propositions that your that you're
claiming like I said straight before
like here so we've got these square
sorry what these are we've got these
curly braces that means it's implicit so
you don't actually have to provide it
address address will file in the
environment so that's the first thing
and also Auto means that it will do app
research but that's usually for things
like literals in the case where if you
have things from runtime you'll have to
explicitly pass it in you can't just
rely on it just automatically finding
your proof that's for something that's
happening at runtime and can't do that
are we cool they're impossible but cool
so yeah if you if you make things
implicit interest will fly into the
proofs and or make the carry them
through which is pretty useful otherwise
it's really verbose and really ugly and
really annoying but it's safe that's
pretty cool yeah yeah
would you be able to guess yeah so it's
yours is just kind of lots of things it
works by unification so if it's see
something at the value level sorry if I
see something if it sees a value that
has the right that has a particular cost
then it can infer that the cost is is
that thing so what you could
theoretically do I don't know if this is
going to work we'll give it a go so
let's say we've got F which takes a cost
let's say it's 2 it costs to the
computer string and we have gee I don't
know what the cost of this is but it's
going to use F okay so it wants me to
prove okay so going to work so usually
what what can happen is that uh it just
can sometimes in figure out what that
not actually I sort of said to some
reasons given me not I'm not sure why
after yeah so it doesn't it doesn't
actually give me that but there are some
cases we can just leaving question marks
and say just just search for the
evidence that this is so you could
theoretically do research I think it is
Oh nigga that work so now I can ask for
what's the cost what's the type of G
okay
does that work there we go if you say
three is like there you go so yeah it
did so you can see that that it's
inferred the cost so we didn't actually
have we can put in we can put in the we
can say that it's a cost and there's
gonna return a string we don't have to
fill in the particular cost and we can
let that be inferred well you're just
doing your proof search it does is if
you just type inference a lot of people
say dependably types languages have bad
type inference but in my experience
that's not true at all and furs a lot of
things basically because it works on
unification has a lot more information
but my program it's really cool
I've got always I think I've got no time
left so if you want to come talk to me
hope you awesome I've got like lots of
exercises for people to play around with
and I've got like lots of I can work
with people I really want to want to get
people interested in a dress and I
didn't mention before but I wouldn't use
interesting production so don't don't go
off doing that I'm not trying to give
I'm not trying to give you impressions
that a dress is a perfect program
language and doesn't it bugs there's
actually a couple of bugs in here that I
didn't want to point out but okay I'll
point them out I've got I've got a few
seconds so notice how does this quickly
line here it's actually giving me a
warning that this thing is not total but
it is - trust me I know more than a
Juris if I rewrite this and there's
actually work around if I rewrite this
in a slightly different way it says this
total but it should be isomorphic the
two ways I write them they should be
exactly the same so you'll have to trust
me that that's a bug but yes if you want
to work with me playing around with
these things like we should be writing
blogs in which be writing blog blog
software in dangerous relation be
writing product production software but
that's right that's right I'm going to
common what does it come and markdown
let's start formally verifying that I
don't know let's let's play around i
don't i don't recommend us using it at
work straight away because there are
bugs but we should start playing around
with it so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>