<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Origami Software from Scratch&quot; by Robby Kraft | Coder Coacher - Coaching Coders</title><meta content="&quot;Origami Software from Scratch&quot; by Robby Kraft - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Origami Software from Scratch&quot; by Robby Kraft</b></h2><h5 class="post__date">2017-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kOF_fZFXTj0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone welcome this talk is
going to be about origami software
software that came before me software
that I wrote and a little bit of my own
personal journey folding paper okay so
I've been folding since I was six years
old at this point I could fold I'll fold
anything I'll fold in any style I've
folded pieces that have only been
attempted a couple times however I am a
complete beginner at origami design and
I am suddenly suddenly I'm suddenly I
need to change this about myself like I
need to be a contributor to the origami
community I need to figure out how to
design origami and so a year ago I set
out to do this I resolved to figure this
out oh yeah I'm gonna use this okay so I
think about this quote whenever I
approach something new I got this from
Philip Glass it's in his documentary so
this pertains to music specifically but
you can probably find it being said
about other art forms by other people so
in the case of origami my experiences I
encountered curved creases were probably
the thing I was most fascinated by there
may be the most unsolved problem and so
I started there I'm gonna explore some
create some curved creases on my own
with some of my creative coding
experience and I got some cool
interesting things and and but one thing
you'll notice there's a lot of these
designs they don't collapse in on
themselves there's not too much material
hidden and I alternate I also kept
hitting walls and I knew that these
walls were because I was avoiding I was
avoiding what I knew they needed to be
doing I needed learning classical
origami design how do I fold an animal a
flat foldable animal that was my
challenge to myself I was going to
figure that out okay so I set out to do
this a year ago and it's been a slog I
have I spent like four months trying to
flow
the dog and I failed for months amounted
to nothing
however this spring I got something
I made a made a crane of my own design
and I'm so proud of this can't tell you
ok
however this crane designed becomes
three-dimensional very early on in the
folding and it's a little awkward to
teach I thought this was close but it's
not quite there something caught my
attention about sea turtles I thought
that maybe there was an opportunity
there and then just a couple months ago
I did it I got a sea turtle design it
folds flat so well while I was doing
this I'm I'm gonna switch over and talk
about software in a second but as I set
out on this quest I also started to
build my own software so my software
this is my software rendering my crease
pattern and the flat folded State on the
right and I thought okay so people build
sea turtles by the way here is here's
one of the prototypes of it so people
put shells on sea turtles this is a
thing origami artists have been using
hexagons can I take it a step further
let's map a real turtle shell onto it I
threw it into my software and it gave me
back a turtle shell mapping and I've got
a turtle shell on a turtle now all right
so let's go let's go back into let's
dive into software the software that
came before me I'm gonna I'm not going
to talk about tree maker very much but
I'm gonna go over the other three real
quickly and then and then but so I need
to say why am i writing software a good
question if if you look at Lange's work
around that time he he made when he made
tree maker he suddenly he was able to
take and take a deer and
take the mapping of the deer's antlers
and how in the branching pattern and
then the ratio of the branches getting
shorter and replicate that directly in
his work and he was able to do that with
the software that he wrote people are
able to so I have to write my own
software what's my con what's my like
thing that I'm gonna build right okay so
so let's talk about reference finder
I used everybody reference finder is
probably the software that's used the
most in origami and let me show you a
use case so here's my turtle base that
you all just saw when you open it up
there's there's these sets of lines up
here at the top they relate to each
other and then there's the set of lines
down here and they they have their they
relate to each other the trick is I need
to find font when I'm folding this I
need to find either either of these the
the trick is that these depend on this
position and this position depends on
this position so so you you end up with
this often in origami and hence this
software what I did is I designed this
piece I figured out what this point is
and then I throw it into reference
finder and reference finder will tell me
how to find this point using the origami
axioms put a note on that we'll come
back to axioms and say and with with it
just a few simple folds it'll find the
paint and notice that notice that
there's errors going on you want to you
want to pay attention to that when
you're using the software okay so
software number two let's see clicker
you got this okay
software number two Arriba think of a
repo as illustrator helps you draw out
crease patterns all right
the the the thing that you get for with
a repo though however
is and if you fast-forward it will
simulate the flat folded state so it
will fold your crease pattern for you
okay
so 2000 2005 I think that's right 2005
was when this came out and I and I'm I
say this because there was a minor
little revolution that happened in that
moment because suddenly we could design
with algorithms in a new way and I want
to talk about this one artist ray-ray
shamp this is one of rays pieces I love
this piece so much this piece was made
with a few simple maneuvers in Arriba
you draw the draw these diagonals and
then you draw one of these units and
then you use a repost reflection tool
and it goes across the entire piece this
piece is flat foldable and shoes I just
I love it
what I have up here is one of rays
pieces as well and do y'all know black
MIDI yeah where where it's just oh yeah
you have a question oh good question I
know I'm going to answer it later but
I'll just answer it right now flat
foldable means so this let me show you
something that's not flat foldable this
is not flat foldable because it has
parts of the paper sticking out of a
plane yeah ok and when I had this thing
all collapsed up which I could do it
real quickly the base of it
one one little catch right there and
then okay
this lies in a plane yeah
flat foldable okay oh yeah totally
how's that thank you for this feedback I
appreciate it
all right okay
yeah yeah black MIDI black MIDI is where
you just google it if you don't know
it's like streams of no it's just it's
like it you you make it by by using MIDI
software it's it's a it's kind of a
hilarious take on like music making but
I thought that this might be considered
like black MIDI of crease patterns
nobody's folded this I don't think
anybody would ever want to race race
certainly hasn't but I think that it's
flat foldable I still need to ask him
about that it's at least these units are
okay you might have to switch over to
the mouse okay
last bit of software what was that 2008
Auriga miser told me he wrote ah Qi so
I'm here at Uchee software helped me
fold this this is the Stanford bunny
also gnat flat not flat foldable it's
not meant to be what I did was I
simplified the Stanford bunny model in
blender fed it into Toma hero software
and his software gave me this back and
then I folded this and now I now I
colored it be based on based on my
experiences writing my own code I was
able to parse what is even going on here
because this is such a new paradigm of
origami design and and I really wouldn't
have been able to fold it or just really
get an idea of what's going on if it
hadn't been for my experiences building
origami Voronoi out of my software which
I'll get to in a bit
okay so I'm so Robert Lang took told me
the words planar graph and I went on my
journey this a crease pattern is a
planar graph it's like the first screen
of Zelda
so here's been a couple a little like
snapshot of my last year building this
software a planar graph what is the
planar graphical planar graph is built
on a graph mathematical graph nodes and
edges graph I built the graph I switched
over I switched over to typescript at
the time tight-roped is great and by the
way big fan has had over JavaScript so
so graphs type planar graphs for built
on graphs graphs my graph works
beautifully when a when a all the
adjacent nodes and adjacent edges like
there's these are discrete answers they
give me back the right answers you clean
the graph everything works perfectly
when you move to planar graph however it
all crystal hard because of the
Epsilon's it's all because of the
Epsilon's when you have lines that are
almost parallel do they have an
intersection when do you call consider
them parallel what I found is I had to
end up ended up having to write write
all of the fundamental 2d geometry stuff
myself and and ended up just rewriting
it rewriting it there were times when
like so Koch plane Co collinear
intersection when a line intersects a
line from below it registers the
intersection like when it's like on the
line : is what that means when it's just
right there but when it was from above
it wasn't registering it like what's
going on okay
so I have a couple screen grabs from
inside of the code what I was just
referring to this is from only inside of
a planar graph data structure some
classes and then some of the functions
some of the geometry functions things
that I didn't actually think I would
encounter I was gonna mention the
clockwise angle from function okay so
y'all have y'all encountered the thing
where one node two two rays extending
from the node all right and when you're
doing that whole like atan2 math cosine
etc you have this zeros that way to
positive 180 zero to negative 180 and
you have to measuring an angle across
that negative 180 positive 180 thing
that's a thing there's the whole thing
around the head Stack Overflow has
answered this thing for us whoo thank
you but what I didn't anticipate was
okay so just measuring the angle is fine
but what if I need to know the clockwise
angle from one to another so these are
here's two rays coming out there's two
angles there's this angle and then
there's this angle and how do I know
which how do I figure out which one is
clockwise
it's a actually a real simple and
elegant solution but I had to figure it
out Stack Overflow didn't know that one
so this is this is sort of been my like
last year building this thing okay so I
think now I'm just gonna start demoing
some software escape that of here over
here okay as I was working on this I was
building visual tests and throwing them
up on my localhost so I could just keep
track of what's going on
so as I'm building this I rely start to
build things around it and realize that
I'm building the documentation
documentation is the tests and I can go
back I'm very useful it would break
things and I could go back here and just
check what happens
everything still works so here's here's
a page just describing the epsilon that
I was talking about when do you consider
two things in the same place this
fragment function just hovering the
mouse over it it's it's clear like what
this function is doing its chopping the
edges right there and then that's
important because I need to find the
faces in a crease pattern so I am
walking down I used the edge walking
where you walk down most immediate right
turn most immediate right turn keep
doing that until you end up where you
began and you found a face but the
fragment function needs to be just like
error-proof another thing real quick is
like when you're removing nodes so these
are two edges right here when I remove
this edge it identified that one node to
be a co-linear node and it will remove
it and merge those two edges into one I
actually I feel like this is a game by
the way minimum number of clicks to
remove all the edges if anybody wants to
make that please okay okay so I
mentioned axioms let's talk about the
axioms for a second these are the four
for putting a crease onto a page there
are seven ways to do this given two
points you can fold a line between them
as such given two points same inputs you
can fold a line where you put the two
points together and then this one was
cool
this one justified my whole like reason
for for doing this to begin with I had
been introduced to axiom three like
something like this where you get one
line back right crease a line to a line
and you get a line that's kind of
running through the middle of them it
didn't occur to me that there were two
lines possible like maybe I would see
this example and I would still see the
blue I would just see the blue line
whenever
I would be given that command it didn't
occur to me that there's two answers to
results from axiom three axiom four and
then this is about it as far as
practical origami as a folder we really
only use axioms one through four in our
like actual practice because they get
kind of cool and kind of weird but
here's another one that gives you two
results back axiom 600 finn invitation
I'll put your name of fun here a lot of
these use compass ruler geometry and
it's been a joy to build it's math that
I really enjoy that one happens to be
extra complicated axiom seven okay so
this is the seven origami axioms okay so
this is what I was thinking about when
you asked that question I am gonna go
deep into depth about what flat foldable
means I'm checking the time to make sure
I'm gonna explain to y'all how this
algorithm works
you're gonna leave today knowing this
how do you turn a crease pattern like on
the left into how do you simulate the
flat folded state on the right using a
computer okay things to notice the
crease pattern on the Left doesn't have
any mountain valley lines we don't need
that for this one and then the the
folded state on the right is translucent
that's a key those are key things to
think about
Oh Mountain so they are represented by
different there's actually competing
standards but a mountain and valley line
is if you look at this on edge this is a
valley line because it's making a valley
and this is a mountain line is because
it's making a mountain and and if you
flip it over a valley becomes a mountain
in a mountain becomes a valley it
doesn't exactly matter which one is
which but that they are opposite they're
opposing each other yeah okay okay so
let's let's dive in for the simplest
case
fold one crease we're gonna need three
tools to do to accomplish this so tool
number one we're gonna need a reflection
matrix okay so here's how we do this we
pick one face it's going to be the face
that's always going to stay on the table
and then the other faces are going to be
reflected so a reflection matrix we need
a reflection matrix a little bit a
little special because we need this to
not just reflect through the origin
which is what this reflection matrix is
doing as you see just the the four the
four numbers are moving around
we need a translation column so that we
can move away from the origin and at
those that last column will move to so
what we do is we build a matrix that
reflects a polygon across one of its
edges that's all we need bring that back
to here and we've reflected the top
polygon across its edge that's really
simple right like I feel like
everybody's probably following along
okay
good good step to take what you just
learned do it with this all right same
thing pick a face it's gonna be the face
that stays on the table and doesn't move
let's make that the far left face do the
same thing we just did step to the right
so let's store that reflection matrix on
that face alright let's do it again
step to the right and the store that
local reflection matrix on that face so
we're just just the line that we just
crossed from the parent to the child all
the way down to the leaf node all right
each face is storing its local
reflection matrix and then when you
apply the algorithm the leaf node or in
this case any any note any face will get
multiplied its reflection matrix times
all of its parents is reflection matrix
up till the root node okay lad aha
nodding head okay y'all are great
y'all are following me okay so what we
just built there was tool number two a
what I'm calling like a adjacent face
tree where we are just from root to leaf
the path of who's the parent and who's
the child because we need to know this
because you need to be able to apply if
your parents reflection matrices okay
essentially we've we've made it here's
this here's that that that data
structure that we just built together
visualized I'm using the mouse to just
change the whatever the root face is
okay so what we just did will accomplish
accomplish the flat folded state however
there's one thing that I I know that
some people are thinking about right now
and I'm gonna I'm gonna talk about it by
focus on these two these two triangles
right here you'll see those the small
ones I have to move the mouse back
those two small triangles are leaf nodes
from very different branch from
different branches right however they're
touching each other okay so you're
imagining this algorithm applying this
algorithm these phases so essentially
you're cutting the paper between between
all the pink lines right you're cutting
the paper where that those two faces are
these faces fold up and they fold they'd
go on their journeys up down towards the
root node how do we know that those two
faces are going to line back up again in
the end so that that edge they're
sharing that same edge you know how do
we know that the trick is to lumber
three and if we can prove on every node
on this crease pattern that every node
passes Kawasaki's theorem which is very
simple those are four those are four
lines sharing and sharing a vertex count
up and this works for any even number
for six a count up all all the evens and
all the odds every other one each one
each some of each angles equals 180 and
180 if that's the case if you can prove
that for for every node on the crease
pattern then that thing I just said
happens
the edges will line up it's not because
it's not the case for every every SVG
you throw at it if you did that if you
applied that to an SVG faces would be
they would do their thing they would be
all over the place but if you can if you
can prove Kawasaki's theorem that's the
only that's the only things that's the
third thing we need you can apply
Kawasaki's theorem on every node that
then that's it you do this reflection
matrix thing and you'll get everything
showing up right in place all right oh
yeah the picking where you start the
root doesn't matter yeah
it's just to say if you were to apply
this algorithm would the paper be like
end up where it like next all the faces
next to each other sharing the edges
that they need to share yeah oh you know
I thought about this and I couldn't oh
thanks thanks yes so the question was is
it possible that there are multiple
solutions I think that I don't know I
don't know the answer to that but but my
speculation is that there's not
everything I was throwing at it it's
showing me one at one solution let's
let's talk more about this okay so some
things that I have built with my
software here is the crease pattern
validator it's doing what you all just
learned
Kawasaki's theorem the projector is
making that a little small I didn't
expect that that should be bigger sorry
let's let's see one with errors okay
when I design so here's here it is
pointing out which spots are not passing
Kawasaki's theorem so when I built my
when I design my sea turtle I
I'm I'm building like the more
complicated base here that is I made
some errors by the way wouldn't it be
great if I could just like just grab
that like I know that it's close that's
the thing if I could just like say
computer just wiggle it around I know
it's really close so I built that here's
a here's a crease pattern that that I
got from Ray champs github repo and Ray
I finished your crease pattern for you
yeah here's one where you can see it a
little more in action since that one had
a lot of nodes yeah so here's the cool
thing as you can you can sort of move it
around in real-time and as long as
you're gentle with it you can sort of
you can change the shape of it so it's
wiggling into place okay so let's let's
go back to Arriba the illustrator type
application where you're inputting lines
the thing that I when I I still remember
when I first opened it up it felt like
how academic software sometimes feels
like where you look at it and you're
like I don't know what to do I can tell
that this application is is asking me to
bring my master's degree to the table
and it doesn't it doesn't need to be is
the thing this we we know we just
learned the origami axioms right with a
blank sheet of paper there are four
creases we could make with with these
with these seven axioms actually right
now I have it running only three so
let's show the people those possible
creases we could make here they are and
if I want to pick one I select it and it
shows me all the new creases that open
up so you're not you're not asking
anybody to like bring required reading
to this application they can just sort
of click around and and sort of explore
it on their own right problem is you'll
notice that this as I add one more line
and then maybe one more it gets really
complicated I think that there's
something quite beautiful about this
shape and I'm but but as far as a
practical tool if I want to crease this
this like bisector right here that's
that's hard that's too hard to do so
that's so what we need is a different
method I'm exploring this right now
maybe we can do something like this but
also like something something a little
predictive like this but also give the
user a little more control over what
they're trying to aim for okay so same
same type of tool I've built here you
all we talked about a repo let's talk
about reference finder again when I'm
designing this turtle let's revisit that
point again
so design this turtle and to fold it I
need to find this point there's a
reference reference finder we'll do that
the only thing that I wish that it would
do is for my design I know that I'm
folding it into thirds I know that I'm
folding I'm folding like from that I'm
folding these 45s up and then so what I
know is I know that I'm putting lines
into it I have a certain set of lines
that are definitely going to be in the
piece and I would wish that reference
finder would consider those in as a part
of their equation or to sort of
prioritize those in its in its equation
so what I want to do is I want to find
my point which is two eight eight so
about right there and it turns out
there's a line did it zoom yeah you can
see that there's there's the line using
the lines that I know are gonna be in
the piece already there's an axiom three
white which act my favorite axiom by the
way line that takes me right to where I
need and this is how I fold the piece
now I use this okay
so last thing I'll share is that I
finally gotten this this this library to
like a working state and I can begin to
have fun with it actually I'll put up a
put up some diagrams here here's a
Voronoi diagram generator it happens in
real time so you can really explore it
like that so I use that to build this
and it's just it's just as easy as
hitting the download button and then
sending it to your creasing machine
yeah okay so my what do I want to say
about this I had a thought and it's
escaped me now
mm-hm must not have been important okay
okay okay back to the presentation
okay so oh right so I just remembered
this slide helped me remember I'm
building it in JavaScript I'm building
this library in JavaScript that's
intentional I wanted this to be on the
web I wanted to there's there aren't
many origami artists out there we are
all spending time alone in our bedroom I
wanted to fix that a little bit so so
with regards to that last example I was
using D threes Voronoi algorithm and
that was the that was the other reason I
picked JavaScript so the community and
then let's like let's let's be able to
tap into all these tools that are
available to us right okay
something I it's really I'm really keen
on doing is making it like oh as close
to a one line of code as possible so
this will throw up a crease pattern up
on your Dom if you include this the
source file and yeah there's always more
than it's just the one line I I spend a
lot of time with creative coding
applications like processing and open
frameworks and what I did was I built a
wrapper around paper Jas
by the way paper J yes how about that
that's what I've been using to visualize
it so I built a wrapper around paper J s
and called it origami take her and so
you can make an origami paper and I'm
modeling this as close as possible you
can see like I'm to like some of these
processing type of programs so this is
sort of like your empty project like if
I handed this to you all jam on this
here's your this is you got an idea of
like how to interact with it okay so
here's some of the ideas I'm exploring
whenever you make a crease it stores who
how it was made the what if it was a
certain axiom that was made what and
what were the parent creases that made
it so I could design a piece on a square
piece of paper and then perform it on a
rectangle and maybe it will fail at some
point but it can attempt it at at least
and maybe it would come up with
something that I didn't expect if we
have the system where lions know where
they came from we can auto generate
diagrams now diagrams are the things
that if you open up an origami book it
starts with a square and it has an arrow
drawn in a dotted line right these
things can be auto-generated now with
this type of data just like trying to
like push the boundaries like if we have
this data like can we have can we can we
ask the computers to start to design if
we if we actually get these large data
sets can we do machine learning on it so
thank you all very much for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>