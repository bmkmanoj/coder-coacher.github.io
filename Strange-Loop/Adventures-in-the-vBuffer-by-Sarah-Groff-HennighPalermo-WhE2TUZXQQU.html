<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Adventures in the vBuffer&quot; by Sarah Groff Hennigh-Palermo | Coder Coacher - Coaching Coders</title><meta content="&quot;Adventures in the vBuffer&quot; by Sarah Groff Hennigh-Palermo - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Adventures in the vBuffer&quot; by Sarah Groff Hennigh-Palermo</b></h2><h5 class="post__date">2017-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WhE2TUZXQQU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so just let you guys know my name is
Sarah Groff honey Palermo that's a lot
of names I feel like if it's good enough
for royalty it's good enough for me
you can find me online usually as Sarah
GP or Sarah GHP I'm on Twitter it's
super SGP so if you really like this
talk feel free to tweet about it if you
don't like this talk please don't tweet
about it if you want to follow along
with the slides especially some of the
code slides it's at Sarah GHP calm
before there's just a PDF there and the
code that I'm talking about and the
examples that I have are also up on
github at worst cat that's a name of a
very funny tumblr that I stole for the
repo for this project so after the talk
if you want to see things on your own
machine feel free to head over there so
a little bit about me I'm an engineer at
Kickstarter there's a whole bunch of
Kickstarter people here too
thanks for coming guys and in my spare
time I like to make digital art and
today I feel like I'm here in both roles
is both an engineer and an artist and
this is the result of sort of a long
adventure that I took from being a
designer who kind of admired digital
aesthetics and the way we could use art
to interrogate things about code to
becoming somebody who's equipped both
artistically and engineering-wise to
answer those own kind of questions
myself and in some ways that adventure
started when I spoke here at Strange
Loop three years ago about data art and
JavaScript I still have the same haircut
so some things I'm doing right and I
talked a little bit about the why the
why I thought the work that other people
were doing was really amazing and vital
and then I went to the school for poetic
computation so the recurse on air I made
a p5 library I worked with the office
for a creative research and got a
master's degree all sort of to get
myself to doing the kind of work I
really admired and along the way I've
taken a number of self-directed
accidental quests and journeys and so
today I'm gonna tell you about one of
them in this adventure took me through
investigations into the kinds of differs
that power things like
react through the wit the basics of
WebGL
through questions about performance
mostly in Chrome and then through
immutability both in JavaScript
libraries and enclosure script and all
of these were done in the pursuit of art
and tools for art making and I think
this is really important for two reasons
the first is that when you're an artist
you're not always an expert you're like
trying to make this thing that you want
with the tools that you have and that
can make a really interesting experience
working with code you know you're not
doing work for money you're not doing
stuff that has to work under some
definition of like people come to your
website and you know expect your form
not to crash and that really gives you a
lot of freedom to do things counter
intuitively and to find out new stuff
and it can be a really fun adventure and
so it's respect that spirit of adventure
today's talk is going to be in the form
of an adventure story where we'll follow
a heroine who bears an uncanny
resemblance to me I have no idea why and
she's gonna meet some characters like
the differs the keepers of the secrets
to the V DOM some helpful Bush creatures
there are some friendly ghosts and
witches along the way finally she'll
meet the garbage collectors and a wise
old lady who pretty much will know
everything at the end in her quest to
write fast and cool graphics programs
using the latest in JavaScript tech so
now we're gonna join in on our
adventures in the V buffer all of the
illustrations that are really cute are
done by my friend Emily Griffin she's
Emily with curls on Twitter
she's great working with her was great
I'm so excited to share her fun slides
with you guys so please be sure to give
her credit too
so anyway as all adventures do ours
begins with a heroine who has knowledge
but also discontent she lives here in
Webb town by the sea um she's a GL er
which is to say she's part of the group
responsible for hardware-accelerated
painting and she has known since she was
small and you might know this - that
WebGL is an API for drawing on canvas
elements it uses the graphics card in
the same way the games do to make
hardware-accelerated drawings
it uses an API very similar to OpenGL
which is how non web graphics
programming happens
and these incantations can all be a
little bit mysterious I'm sure they look
very mysterious and our heroine knows
that WebGL can be a bit peculiar in
particular because it's parallel
processing means lots of threads do lots
of calculations all at once but to keep
them going you have to talk to them in a
particular way and here at the beginning
of our tale the full workings of GL are
still somewhat mysterious to our heroine
she does however have a vision of the
standard look of GL work it looks kind
of like this or maybe like this or
sometimes it even looks like this and
while the math is amazing and hard and
the art can be really great you know
it's just not our heroines aesthetic she
wants to make things like these
generative sand creatures but maybe like
10,000 of them or something like these
really cool forums that are made by
exactly Berman who is one of my teachers
and is generally just always doing
interesting stuff with 3d work or you
know she might say what would Lydia's
Papes artwork look like if it was
reinterpreted in GL town or some Olga
Rosa Nova but like 10000 and animated
you know and she's been starting slow
messing around with things like some
simple Brownian lines that interpolate
their colors here and some box collages
and as sometimes happens you know in any
given village a traditionalist will come
by and be like well why don't you just
build this in SVG if that's what you
want and you know she says but certain
things are really difficult to
impossible with SVG even though we don't
always think of WebGL is being 2d so the
color interpolation on these brownian
lines is incredibly difficult to do in
SVG but relatively easy in WebGL or say
something like adding all these weird
pixelated textures to a bunch of cubes
much much easier to do using GL so why
not make something that she wants why
not find a way to make something that's
nice and fast that does not have as many
weird witchy incantations that we can do
without thinking about global States so
much and something where we can use a
really cool declarative syntax like we
have on the right where instead of sort
of managing buffers or the way the
computer understands memory we can just
say this is my data now please draw at
every X amount of times so this is her
goal and this is what she wants to find
but these questions aren't going to be
answered by staying here in WebGL town
where everybody did things the same old
ways so instead our heroine packs up her
dreams in a bag in the night and had
that first thing to discover the best
way to build the tool that she wanted
for in her country it was not enough for
ideas to come to one's mind one must
seek previous adventurers and scraps of
wisdom and really where is it different
and so she's had sets out after
traveling some time across the plane
that abuts her home our heroine first
encounters a group that she has heard
praised but never seen and these are the
differs it's a sex that is made speed
out of distinction as she asks if they
will help her the differs multiplied
from 2 to 200 and begin to confer among
themselves chatting and trying to
convince one another sitting when
they're unwilling to change their minds
again and finally resolving back into
two with a stable decision yes
and so they reveal to her the view Dom
this is a strange machine it works much
like the differs themselves had worked
taking in data computing and then
reaching out and changing the world once
they have their final answer in its work
it seeks to answer this question given
two versions of the Dom what is the
smallest change that can reflect the new
truth because accessing and changing the
Dom can be slower than comparing two
JavaScript objects Avedon works by
creating a virtual representation of
each state in JavaScript then when a set
of changes comes down the pike the
differ finds the smallest change that
can reflect that new truth and usually
the path looks something like this we
start off with an initial tree changes
happen and a new tree is created with
those changes the trees are then
compared and a list of patches is
generated from the comparison the list
of patches is applied to the Dom and the
initial tree is replaced with what was
the new tree in this cycle and it all
starts over again
so let's talk a little bit about
creating a tree the data in the tree is
usually an atomic representation of the
system we're virtualizing so in the case
of the Dom that would be something like
an element node in this case an h1
element nodes can have children etc it's
your it's the Dom node you're probably
most familiar with sometimes you can
have something even more basic like text
which is a node type but it's much less
complex so it's nice to pull it out for
itself
however there's a third type of data
that differs really like to leverage and
that's the thunk and so this is a
concept that's often used and two
slightly different but interrelated ways
and at base it's about delayed
evaluation and so sometimes delayed
evaluation means a thunk is a function
that knows how to dip itself and other
times a thunk is a function that's memo
izybelle which is to say that once
evaluated it does not need to be
evaluated again unless the arguments
change in react a thunk of the first
type a node that knows how to dip itself
is what you're creating when you write a
custom should component update function
that's because otherwise react is
testing whether things are the same just
by checking their object reference are
they literally the same object and we'll
look at this a little bit more in a
second
a function of the second type a memo
izalith function is usually a pure
function which I know you guys are all
exchange loops so you know this but it's
to say it's a function his output relies
only on the arguments passed to it and
one of the best parts about this pure
thunk is that you can just compare the
arguments which means you only have to
compare smaller pieces and so both
approaches attack the central problem of
diffing which is to say when two
Virender comparison is costly and the
only way to sort of completely know that
the content of a data structure has
changed is to iterate through all of
that content and so a data chunk that
can tell you whether to re-render or one
that allows you to compare smaller units
are the keys to the differs magic know
will this same magic work for our
heroine for WebGL the differs do not
know they only know about the DOM and so
she must go on further to find out about
how the GL incantations work and so our
heroine walks into the dark wood night
comes things get darker and darker and
gothy ER and Goffe err until finally she
arrives at a clearing with a fork each
each path from here seems to delve into
one connotation of what people mean when
they talk about WebGL to the left is the
best worn path and she can see through
the trees meshes cameras light scene
graphs there's even a really cosy
looking a-frame off in the distance
this is GL as a way to create
three-dimensional worlds and objects and
it's cozy it's replete it's full of
libraries this seems really nice but
it's not necessarily what we want to the
right the path leads into a tight
thicket out of which sparks lines and
really weird trig equations seem to come
zooming this must be the shaders a
heroine has heard of these shaders that
they can make weird art very quickly but
apparently their magic is strange the
programs operate on each pixel very
quickly but only alone they have no
knowledge of the world no history no
sense of the future that seems maybe too
weird she'd probably end up like that
three-eyed Raven guy instead ducking an
errant equation she heads forward where
the path dips down and then appears to
dead-end into
holder's it's dark and our heroine is
tired she lights a fire here by the
boulders to cook up some hotdogs
pilfered from the differs or I guess it
just resolved itself back into one
hotdog
damn chomping away our heroine notices
there may be some drawings on the
further rocks she grabs her flashlight
and heads out to explore and there live
the basic secrets of the GL pipeline
revealed finally behold graphics are
made in the following way the user
starts by designing a set of triangles
which when combined together form more
complex objects this combination is
called a mesh each triangle has three
vertices and each vertex has information
attached to it the its position it's
color text coordinates etc it can hold a
number of arbitrary pieces of
information at any given time and then
these are sent via the draw call to the
vertex shader which manipulates the
described objects in a scene eventually
setting the vertices location via GL
position which is a special GL variable
often this involves multiplying location
values by a matrix uniform which has
been generated prior to the draw call
and this is the sort of matrices that
you'll see if you're like when you
generate 3d perspective objects from
here values pass through the fixed
function which is sometimes called a
rasterizer or an assembler and this
changes the position values from
theoretical spaces into pixels that are
on your screen if a type of variable
called a varying variable has been
provided to the shaders this roster Iser
also interpolates the values for that
variable so for instance for a gradient
each vertex might have one color given
to it and then the varying variable will
calculate all of the interim colors that
you would get on your triangle now we
have pixels and these go to the fragment
shader which determines the final color
of a pixel using its location in
uniforms and this is where those crazy
partiers when people are like i coded up
all these crazy shaders man this is sort
of where they're doing their thing is in
the fragment shader a lot of times they
just draw like a flat rectangle and then
lots of fun trick to make your crazy
fact all shaders
and so encode getting everything to the
rendering pipeline before this happens
looks kind of like this you initialize
the canvas and get a context and then
you set some global state flags you
gotta make a program and then you tell
it about the shaders that you need and
then you get the locations for all your
data what you're gonna need in a minute
you generate your data you tell GL where
to find your shaders you set the
attribute in uniform locations remember
we save those like three steps ago and
then you send an element array to GL to
tell it how to index into all the
information you gave it you compute your
matrix you set your matrix you draw your
element and then if you want it to turn
you throw all of that into an animation
call and that's it hey that's like super
easy all you have to do to animate a
single cube it's great instead of
looking at all these calls one thing
that may jump out at you that I want to
address really quickly is that they're
very procedural and you're usually using
a single WebGL object so why not set
everything directly on the object all at
once you might say well because the GL
context is used by a number of programs
on your computer there's sort of no
guarantees about what context it's going
to be indexing into at any given time
you could lose it and then you're gonna
get a bunch of errors so you mostly have
to go through step by step to be sure
that you are in your right context so
instead we're here binding sending data
to the GPU then rebinding and making new
calls when the data changes so for
instance if you have position data you
bind that in send it by your color send
it and now you have new position data
you need to rebind it and resend it and
why is that
that's because inside WebGL is very is
like the granddaddy of global state and
so anytime you're working with an array
buffer there's one array buffer that GL
is working on at a time and if you want
to work on a different one you have to
be like no no now we're talking about
this other thing I told you about before
so it's a lot of code and a lot of state
to keep straight it occurs to our
heroine that this whole Vidan thing
might be adapted to V buffers maybe that
would be really cool and so she sits
down and begins to put things together
hammering and sawing typing and humming
she assembles her V buffer renderer and
a test example we just example can
render two types of cubed
trees a traditional cube and a sliced up
one and this is to test the effects of
attribute buffer swapping it animates
the rotation on these cubes creating a
case for regenerating a matrix and then
rebinding that matrix uniform each frame
so in WebGL we create the object and
then the way you can appear to see it is
based on our matrix excuse me
and it represents its data in objects
for each type now and so these contain
the type of data that it is it's shader
variable and then as well as a name so
we can see that the positions use the
same shader variable it's always the
position but the names are useful inside
our renderer and then we have our data
and our pointer and the pointers all the
information GL needs to read the data
that comes out it's a float every vertex
has 3 pieces with it
etc and then the animation function just
assembles these objects and mutations
together and shoots them over to the
renderer the rendering function this is
the V buffer differ the core of the
project and this is how it works so a
component comes in and if it's a draw
call we always run it through and call
it that's sort of how you measure when
WebGL is going to call it your next view
otherwise if it's new we get an enabler
location and then go through to bind and
set the buffer or uniform and save a new
tree if it's not new the question
becomes well has it changed if it has
anything yeah we're done we don't have
to do anything if it has changed then we
go back to the binding and setting the
buffer because we already have its
location and then it goes into the new
tree and in this case the differ uses
the component name as the key for the V
buffer representation and so if it
doesn't exist it instantiates the
element getting its location and then
going to bind and set and saving that
copy into the V buffer for the next
round when the key does exist the
question becomes whether the data has
changed
fortunately lodash which she packed away
to bring with her has a really nice
equality check is equal so our heroine
doesn't really have to think about what
different means win-win she begins to
run the program
one cube looks good
ten cubes still nice and smooth 100
cubes they're looking good a thousand
yeah and then three thousand all this
once a thousand it's kind of slow chugs
a thousand was okay
parrots spinning so fast but why this is
a big problem
our heroine can see into the art itself
but she doesn't really know what's going
on underneath
how could she figure out what's wrong
she sits down to give a really good
think to things and promptly falls
asleep
no wonder mrs. venture has taken days
and when she wakes again it's Twilight
everything is still the fragment Faria
seems to have calmed down or maybe they
just disappeared not everything is still
after all the bushes seem to be shaking
our heroine definitely just saw some
glowing eyes or maybe a paw a package
comes sliding out from the bush
creatures wrapped in leaves and vines
there's a coarsely scribbled note hold
this over your box and so she does
countdown appears four three two one and
it's replaced by this a view into the
box or maybe it's the performance tab on
Chrome and so the way this works is
these red bits up at the top let us zero
in on our slow frames in this case every
frame is a slow frame a slow frame is
anything that runs under twenty frames
per second which is 16 milliseconds per
frame and a film runs at about 23 frames
per second just for a context and we can
see which frames are the slow frames so
up at the top right there there's that
little red marker on them in the candle
chart and when you click on that you can
either scroll down and see the spots
that are taking long because they have
very wide runtimes or we can look at the
very bottom pane here which lists the
functions themselves it's also possible
to view of frames per second overlay
while the function is running this is a
little bit hidden but if you go into
chrome and type rendering into the
command menu a screen will come up and
you can pick it it's really helpful and
so in this other view these are this is
our view of all the functions now just
sort of pulled up
anything that has a very high self time
is a function that is itself slow and in
this case it's a bunch of low -
functions probably because deep
comparison is expensive but it's hard to
know when it's inside a library and you
can't really change libraries especially
when you're trying to make art and not
necessarily start opening PRS on
open-source projects so the next step
may be to see what happens if we go
library free which our heroine does she
strips all the low - from her code
bings a few things around hits play and
nothing happens she loads up the
performance window but nope it has no
insights this time the stupid Glade must
be cursed she decides noticing some
steps cut it out of the unmarked
boulders suspiciously absent till just
now
our heroine climbs up and over the
outcropping and marches away down the
newly revealed path sitting there
getting angrier and angrier huffing and
puffing lost in her own mind about this
bug about an hour later
in fact she's so angry she nearly bowls
over a woman wearing a pointy hat and a
t-shirt with which-which written on the
front who are you our heroine demands
this is of course the reference which
she can tell you which is which and what
is what she foster static analyzers and
enjoys making a bother of herself but
she proceeds to do until our heroine
explains that the example is broken the
reference which holds it turning it
slowly until the problem is revealed
you're never copying the object as you
pass it through there differs
reconciliation pipeline she points out
low - must have been copying it for you
before that means as soon as you update
it here it's updated at the end and if
it's always compared to itself new data
is never sent to the buffer you don't
want to test if they're the same objects
she laughs only if the data has changed
the witch saps the example a few times
causing the differ to emit updated
objects when the data changes these are
then copied to the V buffer so now it
goes review the element if it's new
create a copy using object Auto sign
make the binding and draw calls like we
did before and then update the old tree
with new elements copying those over
again this works to make sure that we
are copying them all the way through
because if you have a reference you can
be popping them recursively because if
you have a reference
deep inside an object and you copy the
object the reference is still inside
there in the same and so this is quite a
bit faster 1000 is smooth 3000 is still
looking good it's a little blocky 5000 I
mean this looks roughly like a thousand
did before with low - and even ten
thousand though chugging is still moving
but since this is all of our code what
could be causing the problems now what's
the bottleneck we're hitting at ten
thousand we grab our frame again count
down four three two one and end up back
in the summary tab here we notice that
there's actually a link to the line of
code that's been identified as being the
problematic piece of code so we can
click through and it turns out that now
we can see the execution times for
various lines of our code over there in
the left and one thing that's weird is
the line that we were originally linked
to down here to nineteen that's not
actually what's taking forever but now
that we're in here we can take a look
and we can find out that most of the
execution time occurs when we're doing
the mapping to generate the values for
the new matrix and that makes sense you
know as the number of values in array
accuses you have to do more work and she
decides to check the reconciler and here
a bunch of time is being spent in the
main function that goes through each
data piece and that includes the
attribute checks which are taking a lot
of time this is one of the pieces we're
changing every time so it makes sense
that it would take a lot of the time and
we can dig into which sub function so
that has not changed that makes sense
and then deep inside has not changed it
becomes impaired n't that it is the
content comparison that's taking a lot
of time that's what this array is so the
second most time arises every time we
diff in check but of course that's all
we have left once we've broken the line
of references we have to look at the
actual values the reference which is
familiar with the problem but sadly she
cannot help my magic is a bit limited
she sighs but she has her tell of an
even stronger magic adaptable but
unchanging and those who guarded secrets
up on the immutable a mountable by two
castles facing one another across a
chasm
they are mostly similar but slightly
different they don't care much for my
kind up there on the
mountable she says and the climb can be
grueling but that's where you'll want to
go our heroine
plucky strong and fortified by
sandwiches from the reference which
makes the climb as she comes around the
two castles she sees one is on her side
of the road and the others across the
ravine just as she was told a broken
bridge sticks halfway across our heroine
knows where to start
immutable J s is carved into the facade
of the castle which seems to be
inhabited by friendly ghosts there they
are waving from the windows they welcome
our heroine in and begin to explain that
of course the keepers of immutability or
ghosts after all they never change they
then begin to explain how to adapt the
experiment we don't use plain objects
they explain we turn them into maps and
we don't use dot syntax we use get and
set this JavaScript is strange and
arcane and our heroine has not seen
these spells before and so the friendly
ghosts oblige you see immutability means
that whenever you change the contents of
a data structure as we might with set
you're actually making a copy you may
keep the name the same the identity but
instead of mutating the structure you're
just making a new copy but because
actually making new copies would take
forever we use the persistent data
structure that use a structural sharing
to make fast copies persistent data
structures usually use a tree structure
way in which each node has some number
of slots often to for lustrated purposes
and each slot contains a pointer
repeated on down the tree until the
final leaf contains the value the slot
at the very top gives us the length of
the list when something is added or
changed instead of copying the entire
tree a new pointer or set of pointers is
added to reuse as much of the current
structure as possible currently these
are mostly implemented using shallow
trees that have 32 slots per node to
keep insertion and lookup fast lookup
itself is performed using bit
partitioning which uses digits is a PEZ
path keys and employs powers of 2 like
32 for instance so that bit shifting
optimizations can be used in lookup
operations instead of needing to divider
use modulo there's a really great
write-up from Jean Nicolas L'Orange
about all of this that's in a ton of
detail there's a link at the bottom here
and then we'll be on the slides my
reference slides at the end did super
worth reading probably liked
even go to other sessions just go back
and read about persistent data
structures but with images of trees
dancing in her head our heroine has led
up to a very nice room by the ghosts in
put to bed she wakes in the middle of
the night to discover the ghosts across
the ravine are calling her over our
heroine creeps out of the castle it
turns out night is way less scary when
the ghosts are very nice and heads
towards the bridge where the paren
ghosts have gathered they wave it heard
across hypnotized she walks towards the
center of the broken bridge each step
lights up an opening friend along the
handrail then when she gets to the
center where the walkway disappears the
closing friends all light up in the
bridge completes she continues across
and as soon as it is in and is soon in
the great room at schloss clojurescript
the other ghosts explained that the
previous Castle stole their data
structure idea which is why they
installed this magical bridge here
rather than adapting javascript the code
is entirely different even though it's
JavaScript that comes out at the end so
now here we can see how our data
structures look in closure script the
interesting thing with this approach is
that instead of deciding where to enter
into the world of immutable data step by
step as with immutable j/s data is
always immutable by default and instead
mutable structures can be explicitly
chosen for instance using an atom this
means that instead of thinking about
where it's faster to be mutable and
immutable piece-by-piece
we're just--we're more often mindful of
which actions are fast and which are
slow so for instance the ghosts insist
use a sock it's much faster than merge
they also note the reference versus
values comparison appears here too in
this time the choice between using
identical and equals so for instance the
best babysitter's and my fav
babysitter's are not identical they're
not the same data structure but they are
equal in the sense that they both
contain Staci and Claudia clearly the
best babysitter's we also get access to
some weird cool closure spells like
hardcore destructuring what you can have
access to the inner contents as well as
the object itself which you can't do in
JavaScript still
we can have some very elegant pipelining
that's what's going on with that little
double arrow macro down there you can
pass your data through a pipeline in the
same way you might chain map calls in
JavaScript and there's some really nice
built-in expressions like if not which
is one of my personal favorites
now heroin does find this code to be
very pretty but is it fast she sits down
and begins her work she decides to leave
functions that involve close interfacing
with the GL API in plain JavaScript and
that way we can limit the interrupt to
passing data structures through once
they've been finalized this limits the
amount of time spent converting between
data structures which is a problem
you're going to run into anytime you're
using something that writes custom data
structures on top of JavaScript at some
point you're going to have to convert
through to vanilla JavaScript and being
mindful of where you decide to do that
can be very helpful but how do these new
ghost versions work turns out the answer
is not great tragically at 3000 the
immutable version is down to 9 or 10
frames per second while vanilla is still
at 26 closure scripta meanwhile slips
between 100 and 1000 in fact for this
last one our heroine had to turn on CPU
throttling for the hundred objects view
in order to see what was causing
problems because one of the interesting
things is that when your performance
tools use WebGL and you're trying to do
WebGL performance when you break
everything sometimes you don't have
access to the tools anymore so that's a
case where the CPU throttling really
comes in handy and so this is not better
right this is worse but why she looks
deeply into the programs and notices
that each time things get slow minor
garbage collection is high it's pretty
much will be the top function that's
being called the ghosts look sad and nod
the drawback with this type of
immutability is it produces so many
extra data structures the garbage
collectors have to come by and clean
them up and in fact our heroine begins
to suspect that the immutable amount of
all is built on a big pile of garbage
collected data structures
and so she had to go to the garbage
collectors themselves the ghosts float
to a window on the opposite side of the
room and points and there across a plane
at what must have been the very edge of
the world was a land shrouded in
darkness where buzzards in Ravens
wheeled this is the land of the garbage
collectors her heroine sets off to find
the truth when she finally reaches the
border of the garbage mounds she comes
across this adorable but troll-like
woman guarding the crossing here she is
told that she can never return if she
enters garbage collectors are unknowable
but the woman does offer her a slightly
different art running box explaining it
has a new approach to running art and
it's called a safari when our heroine
runs her examples on this box she finds
that they are running slightly more
smoothly not dropping a frame or
chugging where the chrome example will
stop and that's because of Riptide which
is a new algorithm the garbage collector
explains so all garbage collectors visit
each object in memory and mark whether
it's still in use or not this can take a
long time relatively speaking especially
if you're making and discarding
thousands of cubes frame by frame in
this newer version the marking is done
concurrently on a separate thread from
that used as the browser that means that
the garbage collection won't block the
browser's operation and cause slowed
frames it's also done in parallel
meaning each pass can proceed more
quickly riptide uses generational
marking which the garbage collectors
note helps in particular with programs
that allocate a lot in our heroines case
for instance she's been using the spread
operator with wild abandon our heroine
is fascinated by the garbage collectors
explanation but she knows she's reached
the end of her trail and it's time to
head home this is not the end so right
now our heroine doesn't know it now she
only knows she will return home without
a good solution no parades no triumphal
tales around the fire no strangers
buying her beer at the bar it's very
tragic in a few weeks after her tart
return she is redeemed from her moping
an old witch of whom she had taken
little notice before invites her in and
asks her what did happen on her
adventure soaking like it's her job our
heroine tells the witch all I learned
was that I made a mistake but being old
and very wise the witch's like just
tell me your story it's okay if it's not
a triumph mistakes the world the best
learning happens and so our heroine
recounts the story I've told you today
and together they find out what they
really learned to start small we can say
we've learnt immutability x' biggest
limit is probably going to be when
you're dealing with a lot of garbage
collection which yes I just rediscovered
some of the problems with Lisp but I did
it really cute so without careful
attention or mutable escape hatches
using immutable data structures in a
quickly changing program is going to
create a lot of things to be disposed of
immediately and this might not matter if
you're not doing animations or a slow
moment here there is bearable and so
more broadly we can say that she learned
that not all clever adaptations are
right for all problems for instance
creating and dipping virtual trees is a
great paradigm and can support some
really great mental models namely one
where our view is a function of our data
but if you cannot prune the tree easily
diffing can quickly become slow
meanwhile mutation which has been on the
outs these days is everyone discovers
how great FP is which let us all a great
super great mutation that was really
fast it's probably what you need if
you're updating 10,000 objects every
frame that not all clever
adaptations are right for all problems
is a keyless lesson the witch notes and
one which we tend to have to relearn
every time we find out about a paradigm
we hadn't heard of before next she found
out that membranes matter she would just
to say she had the chance to apply
different tools to the same problem and
in so doing investigate their primary
distinction which is where each placed
the line between reference and copy the
boundary where one piece of data became
- and the ramifications of these choices
the decision of where to place a
membrane what to expose through an API
what to ask your users to configure
which characteristic will determine
downstream capabilities these are at the
core of the choices we make when we
build or choose tools which is to say it
matters where we decide to draw our
lines and so in the case of this
adventure vanilla JavaScript because it
mostly defaults to reference allowed us
to draw the membrane for copying in a
small tight place where we create the
virtual tree it does have to be done
recursively
but it can still be in a very small
single location immutable j/s makes it
possible to move the membrane wherever
it works best for you
though it mostly recommends the opposite
which is making things immutable where
you're first creating the data and then
using internal escape hatches to make
multiple mutable changes to a data
structure this is a very interesting
approach I think it's a little bit too
the expense of syntax and it does
involve a lot of overhead always
considering how you're deciding to
manipulate your data finally closure
script has what I would say is an
inverted membrane from vanilla
JavaScript where mutability can be
declared at small points and this is
very interesting but comes with a high
cost of garbage collection and that
takes us to this lesson which is to say
that limits are inevitable whether the
limit be reached at a thousand five
thousand one hundred objects it exists
and if speed for ten thousand is what
you need the weird witchy incantations
of WebGL are probably already optimized
for you but a really nice interface can
exist for a hundred and a thousand and
depending on what your art is that might
be enough oh yeah so what was your art
project anyways ask the witch other than
the search hero heroine picks up the
test example and shows the old woman as
they look at it sort of sludgy they
notice that it has its own charms if you
look at it just right and though it
wasn't intended to be the best art just
kind of a test for some limits it turned
out to be a little bit beautiful after
all and that's our final lesson failure
is a really great medium z-fighting
which is what happens when your 3d
objects and matrices don't line up right
it's kind of beautiful glitch art is
definitely a compelling aesthetic and
further afield works like slow hot
computer by Sam Levine which is about
making your computer fail is art and
criticism of capitalism it's a really
great piece
there's glitch paintings you know not to
mention every novel with an anti-hero
failure can be really compelling too if
we explore its limits and outlines and
meantime what's next well there's always
these options we can make an art tool
with fewer than a hundred objects
well you can look into GPU optimizations
and see the art of getting the most
things on screen as possible or head
back to the fork and pick up that crazy
fragment shader path but for today
that's it everything in this talk is
based on the work of intrepid
adventurers who have preceded me there's
a whole bunch of link slides after this
in the PDF so you can go through and
read through and keep the exploration up
and they can have their credit and
speaking of credit I want to shout out
Emily Griffin again my illustrator she
did such a wonderful job and so please
check out everything online and thanks
so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>