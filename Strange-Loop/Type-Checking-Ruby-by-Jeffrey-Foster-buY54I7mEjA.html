<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Type Checking Ruby&quot; by Jeffrey Foster | Coder Coacher - Coaching Coders</title><meta content="&quot;Type Checking Ruby&quot; by Jeffrey Foster - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Type Checking Ruby&quot; by Jeffrey Foster</b></h2><h5 class="post__date">2017-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/buY54I7mEjA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right thanks everyone good afternoon
my name is Jeff Foster I'm a professor
at the University of Maryland in College
Park and I'm really excited to be here
to tell you about some work I've been
doing for a while on adding some static
ish types to Ruby so so probably you're
here because you're interested in Ruby
but but just in case so Ruby is a sort
of a combination of small talk and Perl
it's really popular for web apps so Ruby
on Rails is probably the the main thing
that language is known for and the goal
of our work which we've been doing for a
while is to come up with a type system
that adds sort of optional but useful
types to Ruby so you know you know this
is the sort of the normal kind of
gradually adding type story we want to
be able to develop a program without
types rapidly and then add them later on
slowly to get checking where you where
you need to so that you can find
problems as early as possible in
development and sort of the punchline
which I'll and I'll tell you the reason
for this part way through the talk is
that after doing this for a number of
years I think we finally have it right I
think we finally have a reasonable
solution for a language as dynamic as
Ruby that can that can add types to it
so so what I thought I'd do first at at
risk of screwing up is is do a demo so
the the code for for this system that
I'm gonna show you called RTL please
don't ask me what already L stands for
because I don't actually know it's up on
github and there's there's a gem for it
and here's a well you can see where I
come on the VI Emacs war so here's my
Emacs buffer where I've written this
this fantastic function or method sorry
called the answer that returns a string
42 and that's it right so if I run this
it doesn't really do anything because
I'm not actually calling any code I'm
just defining a method and using RTL
what we get to do if you want is so we
can load an RTL and then we can enable
annotations and once we have annotations
we could say that my intention was that
this method should take no arguments and
return an integer and I want you to type
check this method
after it's defined and if you do that
then and then when you load this program
you get this sort of catastrophic
message which if you look at the top of
it has something interesting to say
which is that at this line six it got a
string where type integer was expected
right so this is one of the things that
type systems is about and you can think
of this as as adding redundancy right a
little bit of redundancy into the
program so I don't actually know if the
program is incorrect or if the type
annotation is incorrect but at least
know that they don't match right so
somewhere there's there's a problem that
I can find
so of course you could find this these
kinds of problems with test cases but
one of the nice things that you can do
with type system so let me let's add an
argument here and I'll I don't care what
that argument is so I'll just say it's
any possible kind of thing so let's say
if X is true returned 42 otherwise
returning the integer 42 and the nice
thing about this is if I run type
checking on it I get that type error
again right but I didn't have to add any
more annotations so the one type error
enables reasoning about all the paths
through the method whereas if I was
doing testing I would have to write two
test cases right to cover each of the
two paths through the program so that's
one of the that's one of the cool things
about type systems I think and that's
one of the reasons that I would like to
add them to Ruby is because I find
myself maybe maybe I shouldn't admit
this but of course I make all kinds of
mistakes when I program and there are so
many of those mistakes that I think
would be caught by type systems that I
want to be able to do that all right so
let me show you one other sort of
feature of this of this type system so
maybe maybe for some reason I decide I
want to return 42 as one plus 41 and if
I do that then actually I get a type
error and the type error is is kind of
odd it says well there's no information
for the instance method integer plus
alright so if you remember Ruby
everything is an object when I'm cutting
when I am doing 1 plus 41 I'm actually
invoking the plus method I'm 1 and this
is complaining that it doesn't know
anything about the plus method right so
the way this type system
works is if you call out to other code
you need to provide some kind of type
annotation for that and there's actually
a library of these things so if you want
to get those you can load in the core
library types and if you do that then
then this program will type check just
fine and those library types of course
you can look on github and you can kind
of figure out what they are but you
could also query them with this
command-line tool so here are all the
types for the plus method of integer
I'll tell you what those those sort of
multiple types mean later on or maybe
you just want the types of everything in
the integer class right or maybe I don't
actually know why you'd want to do this
but it was fun to implement so I did
maybe you have an integer and you want
to get another one so you just want a
method that takes an integer and gives
you one so those are all those methods
or maybe you just really can't think of
an integer but you have something else
so give me something that takes anything
and gives me an integer well there are
all the things that do that all right so
so now I'm due to fear I'm gonna move on
to slides because I don't want to risk
any more demo so so so my plan here is
to tell you more about the sort of the
types that ruby offers and why they're
interesting and why they're designed
that way and then tell you a bit about
maybe some some open questions at the
end
and if you get bored during my talk here
there may be a few interesting things to
think about so I said before you know I
want type systems to find bugs in my
code but there are all kinds of ways
that types are useful and one thing to
think about is whether having a kind of
type checking system like the one I just
showed you is actually is actually
useful right so one of the main things
that types help is actually even before
you write the program is with design
right so you get to write down you get
to think about the API of of your
program or your library or your methods
or whatever and the intermediate values
of your program in terms of types and it
gives you a little bit of structure for
thinking about them right so in fact we
did a long time ago we did a user study
we were trying to check whether an
earlier version of our deal was helpful
and we found we actually
kind of screwed up the user study
because we made the problem too simple
and it was it was too simple in the
sense that all the programmers who were
who were carrying out the tasks we asked
them to do knew that when they had X it
was always an integer so they didn't
actually need sort of the RTL type
system because they just knew by name
that if it's X it's an integer right and
that's because the program was kind of
small you can imagine in a bigger
program types are more useful with the
design
another aspect aside from finding bugs
is that types are automatically checked
right so this is kind of nice because
you know how often does documentation
about code actually match the code it's
pretty much almost never but the nice
thing about types is that if they're
checked against the code you know that
there's this sort of mechanical tool
verifying that they match so you can
trust them and in fact we found in doing
the course of this project we found a
few places where the Ruby documentation
doesn't exactly match what the types
what types are actually accepted by
various library methods and then finally
types are really useful for maintenance
right so as a kind of dumb but really
useful example suppose you've got a
method that you use a bunch of places in
your program and you want to add an
argument to it well it's really easy to
add that argument and then if you have a
type system you know that the compiler
or the type checker is going to tell you
every single place you need to update to
now call that method correctly so that's
like so I don't know about you but when
I'm programming Ruby without types and I
go to add an argument to a method I get
really worried right because now all of
a sudden I need to know did I actually
remember to test every possible place
that this method is called and if the
answer is no I could have screwed it up
and with types because it's for there's
sort of one type for method annotation
it's a lot easier all right so so let me
show you some of the kind of typing
features that Ruby has that RDL has
explained so why it has them and sort of
most of these examples are from type
annotations for the Ruby core library
and the goal of all this was to come up
with a type system that matches sort of
the Ruby documentation and what Ruby
programs do so there's nothing in here
that's added just because it's sort of
intellectually nice right everything is
in here because there's some code that
had a pretty good reason for using this
kind of feature and in the end I think
of this as kind of the kitchen sink of
type systems so there's really not any
new kinds of types in the system but
there aren't many or maybe not any prior
systems that just have all this stuff
jammed together in in one type checker
all right so so I showed you an example
this before but RTL has basic types
right so like the this is new annotation
syntax so before the type annotation was
just for the next method this type
annotation is for the first line says in
the string class the plus method takes a
string gives you back a string the
insert method takes an integer in a
string gives you a new string and then
finally ruby has lambdas or higher-order
methods or code blocks so that an
example is on the bottom of the slide
where the up to method is being called
so a up to Z iterates from A to Z and
calls this code block with an argument C
passing one one character or one string
to that code block and printing it out
and as an aside I don't really know why
Ruby has this up to method I can't think
of any other use besides this slide but
it's in there right so okay and and this
syntax with the colon if anybody doesn't
know Ruby that's just a symbol which is
an intern string all right so the last
annotation up there is is just the type
signature for the up to method all right
so so we found that in RTL we also
needed Union types so ORS so there's the
code for the answer again and suppose
that the correct that it was actually
the correct code and that the type
annotation was wrong and actually it
should have returned either an integer
or a string so you can say that like you
see on the slide and so if you have
something that's of type integer or
string or a or B that means you can
invoke anything on it that would work
for both a and B right because you don't
know which it is that's it's a union so
unions are kind of an interesting thing
to have in a type system they're really
useful but there's no exact consensus on
the right way to add them right so
different languages have different ways
of doing it
so for example C has actually a Union
key
that lets you create untagged unsafe
unions of things and that sort of lets
you overlap things in memory that's
that's the way a lot of C programmers
think about it but it you know it's
incredibly useful so it's in there in
Java you can do this kind of thing but
you need an interface right so if you
want something to be to be either an A
or a B you have to think about well what
method do I want to call in that let's
say it's m and then you make an
interface having a minute and then you
say both of those things implement em or
implement the interface right so so
unions are useful in RDL we have them
and you can just create them on the fly
using or instead of having to name them
or giving any separate identity besides
just using them where you want them and
of course wherever you have unions
you're going to have intersections right
so in our DL there are intersection
types and the intersections are
restricted to being only at the very top
level of method types and they're used
for overloading right so an overloaded
method is one that can be called with
different types types of arguments and
it might return different types of
results so actually maybe this is a sort
of a bad example because all everything
here returns a string but the string
slice method has many different kinds of
things you can either give it an integer
argument to return one character to
integer arguments return a range and so
on so so this is kind of surprising
right because Ruby does not have
overloading except for Ruby does have
overloading as you can clearly see
because it's used all over the place in
the standard library and then the core
library right so what's happening is
that Ruby instead of having the compiler
decide at compile time which overloaded
methods call it does runtime type tests
instead so we need to model that in our
DL so we have overloading I one really
common use of overloading is for
optional and variable argument types or
at least for sorry intersections so the
chomp method string takes an optional
string as an arguments the delete method
of string takes one or more strings as
an argument and you can see we have the
the question mark operator and the star
operator similarly two regular
expressions to indicate optional or zero
or more
and so those are really useful to have
and as an aside one of the things that I
discovered when I was building this type
system that I thought originally that in
Ruby you would have required arguments
first and then optional arguments and
then variable arguments because that
would make sense right because then you
could count to figure out exactly where
the arguments went but that's not true
so actually you can have optional
arguments in the middle of other
required arguments and all kinds of you
can sort of have whatever you want
so inside of RDL it actually uses a
non-deterministic finite automaton it's
trying to its charge you the matching so
that that's possible I don't know if I
actually have the algorithm correct but
it seems to work most of the time so the
the types so far that I showed you they
all use names right there all nominal
they just refer to classes and most of
the time I think that's what you want
but some of the time that's too
restrictive so for example the puts
method just prints something out and it
prints almost anything out so I don't
want to have to list every single class
that puts could print because there's
essentially an unbounded number of them
right so instead we can use one of these
structural types where puts takes zero
more arguments of some kind of object
that has a 2's method that takes nothing
and gives you a string so that type
makes sense but actually there's there's
sort of a deep philosophical question
here that I don't know the answer to
which is when do you want to use nominal
and when you want to use structural
types right so if you use nominal types
it's easy to understand and the
annotations are short right but they
might not be flexible right because
maybe you're gonna add another class in
the future and that class is not going
to match that annotation and then you're
gonna have to go change the annotation
right or you can do structural types and
it looks fine for this example but some
structural types are too big like what
if you have a method that takes
something that could have a plus and a
minus and a times and a divide and a
modulus I could write all that down or I
could just say that darn things an
integer right that's much easier to say
it's an integer than to give the full
structural type even though saying it's
integers maybe not exactly precise so
that's a question I don't have the
answer to but it's something interesting
to think about in the design of a type
system for a dynamic language
rtl also has to have generic types
because ruby has a raise right so this
is what they look like so so up here we
declare on the first line that array is
parameterised by some type t and then
type declarations like the declaration
of push says that it takes zero or more
T's and returns an array of T okay so
that looks sorta straightforward well
what's interesting is because ruby
doesn't have types built in once you
have these these generic types or these
parametric types it's hard to know what
the type parameter should be without the
programmer telling you for example here
is an array 1 comma 2 I'm storing it in
X and I can't really tell without the
programmer saying whether that's
supposed to be an array of integer
whether later on they're planning to
push a string on it you know I I just
don't know right and there are sort of
different ways to do it but probably
whatever choice you make if you force if
you just assume that 1 comma 2 is an
array of integer that's probably too
restrictive and it's probably to start
annoying people so what we do in our DL
is we just require the programmer to to
annotate that so if you don't put it if
you don't supply a type parameter then
our DL doesn't check it actually allows
any kind of contents but if you want to
you can supply a type parameter you
could say that's actually an array of
integer with this instantiate notation
and then if you try to push a string on
it then you'll get an error all right so
and then one interesting twist on this
is of course maybe 1 comma 2 isn't
really an arbitrary sized homogeneous
array maybe it's actually supposed to be
potentially heterogenous thing of size 2
right so this is a this is an
interesting choice that a lot of dynamic
languages make right so so if you come
from a sea world there's a dramatic
difference between an array and a linked
list right because an array is like a
contiguous block in memory
you can't extend it unless you get
really lucky and there's free space
after it and you can reallocate whereas
a linked list you can just allocate
cells in memory and they could just be
all over the place but you can have them
you can have the list be arbitrary sized
and somehow a lot of languages like like
Ruby have decided well we're only
have one kind of thing and I don't care
if it's slow some of the time but we're
just going to say an array it can be
arbitrarily sized right and you can use
it in these two different ways so our
deal has to account for these two
different styles of programming with the
same thing so here's a method F it takes
in this case an array with one and in a
string foo and then it uses multiple
assignment to assign the components to a
and B so if I let's say that I just
assumed
of course I you know without any
annotation I wouldn't do this but let's
say that we give this type array of
integer or string using the Union type
that's not going to be precise enough
for this example because then a would be
an integer or string and so would be so
instead our deal has a special tuple
type right which is the sort of natural
thing with the square brackets here that
says it's an integer in the first
position of string in the second
position
but of course maybe later on we discover
that's false so RDL has some sort of
fancy footwork inside it so that when
you write down an array literal it
assumes it's a tuple type and then later
on if it decides that that was the wrong
assumption it goes back and it converts
it into an array of the union of the
tuple types and then recheck so that all
the typing constraints are still
satisfied and it does the same thing for
finite hashes because hazards are also
used as sort of heterogeneous and
homogeneous containers
depending on the application all right
so so there are more features in RTL
alright so there's there's a self type
right you need that for things like
clone because if you inherit clone from
a superclass and you call it you're
going to get an instance of your class
not of the superclass and the only way
you can get that to work is with the
self type it turns out you need
singleton types too so this is kind of a
dumb example so here the real query
method of integer I'm indicating it
always returns true so maybe that's not
very important to know but it turns out
that inside the type system it's really
useful to sometimes know that certain
things are exact values so that when you
branch on them you know that you're only
going to take one branch or the other
and that that's particularly useful when
there's code that implements overloading
and when it dynamically checks to see
the class of something and then
it's cases depending on the class so
because I want to support that I want to
have singleton types and there's also
some weird cases in the math library
where like things return PI or 0 or
things like that so it's nice to be able
to write those down and then finally we
found it's it's as you'd expect really
useful to have type aliases so here
percent real is an alias for the union
of integer float and rational and so
that's one way you can get sort of this
interface style notation for things
without having to declare one if you
don't want to all right so so that was a
really quick sort of dive through
through RDL and actually it took a long
time to build this system so this is a
it's kind of a funny slide so every box
on this slide is essentially either a
paper or a piece of software or both
that we built and we started working on
this I guess I should be embarrassed
about nine years ago so it's taken this
long to figure things out and there's an
edge from one box to the other if
something sort of directly influenced
the other so we kept building different
kinds of systems for adding types in
Ruby's so he sort of came up with the
type language reasonably early on but
then we tried you know static things we
tried some things with profiling we
tried making things dynamic and we did
all this work on trying to get things to
work for Ruby but there was a massive
problem with everything we had done that
was sort of embarrassing right which is
which is this kind of example from Ruby
on Rails alright so this is this is some
code that I wrote for a website to keep
track of talks like the one I'm giving
now right so a talk has a speaker and
has a location and has an abstract and a
time and so on right and in the system a
talk so this is part of the model class
for talks so they this was for rails 4
so it extends active record base talk
also has an owner which is the user that
creates the talk and they're allowed to
edit it afterward alright so and so
there's this line here that says belongs
to owner that indicates that a talk has
one of the owners and because of the
names of things don't quite match I have
to say that that's an instance of the
owners is an instance of the user class
with this fantastic one-line method
owner query which takes a user and it
just returns true if and only if the
current owner is the user parameter and
that ridiculously simple method could
not be checked by via the previous
systems that I had been working to
develop so all those boxes and the
errors between them they couldn't check
this code and the reason is that that
method owner isn't actually defined
explicitly anywhere in the program right
there's no def of it anywhere and that
caused essentially all the previous
systems to to fail right so this is an
example of meta programming what's
actually happening is that through some
magic when I call it belongs to up there
it's actually on the fly creating and I
don't actually know exactly how it's
creating there's there's many ways to do
it it's creating the owner method which
I'm then using later on in the code and
this style of meta programming it really
permeates rails and because it permeates
rails it's it permeates Ruby because
lots of people will program in Ruby they
look at at Rails as as a good model
which you know I think there are a lot
of great things about it and they sort
of do similar things so there's tons of
meta programming in Ruby and so it's not
something that that that can be ignored
I think all right so so so what do we do
to sort of solve this this problem well
fortunately what we realized is we could
take all that stuff and even though it
didn't solve the problem we could put
together bits and pieces from the
previous systems we can take it to type
language we had before we did some
profiling stuff that gave us the idea of
running the code see what it does we did
some stuff with runtime interception we
did some stuff with static checking and
we could kind of put it all together
right so so the reason I'm showing you
this is not that not that I want to
admit it took me so long to figure this
out and then I sort of had so many you
could sort of call them false starts but
just to show you no I we worked on this
problem for a long time like eight or
nine years and I'm gonna tell you that
you know what we figured out and it's
gonna take me you know like two minutes
right and that's how we make progress
right I mean if it took me eight years
to figure something out and then to
explain it to you it took another eight
we're never doing anything right so
Sonia it's just sort of something to
think about you know cuz I do a lot of
research and I always think about it as
you know you know it's not trying to
come up with a complicated idea it's
trying to come up with the dead simple
idea that it just takes a long time to
understand so that you can then build on
that and and do great things all right
so what's what's the the idea that I
think was great coming out of us well it
combines two things so the first is that
type annotation that I said was an
annotation is really just a method call
right so I didn't put the parentheses
around it because you don't have to do
that at Ruby but it's just a method call
at runtime so when I say you know a type
string etc etc all that's doing is
storing in some global table a mapping
from saying the string slice method has
this list of types so they're just
global type table and that's why I could
do that funny thing with RTL query all
that's doing is loading up the the Ruby
environments it's loading in the types
and then it's just going through that
table and spitting out the data right so
these type annotations are our method
calls and then we can do static type
checking against those types but we can
do it at runtime when stuff has been
loaded so so that call up there where I
said I guess this doesn't quite match
before but let's so foo has type integer
integer and I say type check colon now
what that's doing is it's it it's when
the method foo is added it it sees it as
the type check now annotation and then
it's grabbing the source file parsing it
finding the Foo method inside it and
then doing static type checking against
that global environment which has all
the types that came before it in time
right now that's actually kind of
useless except in demos you don't
usually want to type check things right
after you define them for example
mutually recursive functions kind of
don't work that way but a really good
way to do it is you can just put some
label on the type check annotation you
can say type check at label and then you
can do do type check at that label
sometime later and so that lets you
actually turn type tracking into a test
so you can write a test case that when
you
cute it just type checks some chunk of
your program right alright so now that
we have that feature we can solve them
at a programming problem I have to do a
very quick aside just to show you some
education so in addition to this static
stuff RTL also has some dynamic stuff so
it also has contracts in it and it lets
you check pre and post conditions so so
here's a line here's an example where we
have some Foo method and we have a
precondition that it's argument X has to
be greater than zero so if you put that
annotation on and then you call foo of
minus one you'll get an error that you
violated the precondition and you can
also do it have a post condition which
is similar right down there alright so
when you have that pre call we can abuse
it to intercept the belongs to call and
create type annotations on the fly so
now of course when our DL takes over the
world this will just be part of rails
but until it does we have to sort of
tack it on afterwards so the way we do
that is so we add a precondition on
belongs to so we're doing this purely
for its side effect not to actually
check any conditions we're going to take
the same arguments that that belongs to
takes which is the name and the options
and then we have some code that creates
the type annotation so if options.exists
then class Turing's is options of class
name otherwise class string is name dot
singular eyes camel eyes so that kind of
crazy string manipulation is really not
something I would want in my static type
system right like rails has an internal
table that has singular and plural
versions it knows exceptions like it has
the plural of octopus is octopi I don't
want that in my static type system I'm
sorry that's just too messy but it's
perfectly sensible to have in runtime at
rails when the entire rails environment
is loaded and it's a trivial call right
and so once I have that I can then sort
of do the computation and then I can
call type to create the type annotations
and so now that belongs to call whatever
kind of wacky thing it's doing to create
the owner method at runtime I'm just
also having it create the type
annotations at the same time right which
seems perfectly sensible if you're going
to go to all the trouble to create
method at runtime it's really not much
more terrible to create types for it as
well so now all of a sudden this method
that looked dead simple that should be
really easy to type check as long as you
have the right annotation from long sooo
it is really easy to type check and that
I think is the key idea that really has
enabled us to to apply to Ruby and to
Rails code for real so so like I said
this approach it works with all kinds of
meta programming it doesn't matter what
the exact implementation is the
efficiency is probably not too bad
because the meta programming code you're
not going to do meta programming in a
tight loop right you're gonna do it kind
of at the outside which means the type
annotations are not going to be in a
tight loop they're gonna be on the
outside and if you want you can disable
all this stuff in production so there's
an RTL disable module you can load
instead of RTL and that's just going to
cause all the type annotations to be no
ops and rails there's some stuff for RTL
so that that will be done automatically
in production I don't want to say that
rail support is bulletproof it's still
kind of sketchy everybody but the core
ideas are there all right so so that's
most of what I wanted to tell you let me
wrap up with just sort of a few
high-level things that I don't know the
answer to that are maybe worth thinking
about so one question that anybody who
designs one of these type systems for a
language that doesn't already have it
has to answer is should the type system
be sound meaning should it be the case
that if the type system accepts a method
in this case then the method will not
have any type errors at runtime so one
example of this question comes up with
generics right so here is a method F
that takes an array of integers and then
it passes that array to G and G takes an
array of anything and it prints out the
array and then it returns and then
inside of F we return X sub 0 plus 1 all
right so it's just some nonsense code so
should we allow that well it looks okay
and this kind of code would actually be
allowed in Java right but there's sort
of a standard type soundness problem
here because arrays are immutable so if
instead of just printing out the array
inside of G if I had actually messed
with it like here I've changed X sub 0
to be this symbol foo which I should be
allowed
because G takes an array of any so it
should be allowed to change it to
anything then I'm going to get a type
error inside of F when it returns
because now X sub 0 can't be added to
one so like I said this is a standard
problem we have two names x and y they
both refer to the same data structure
they have different types and that data
structure is mutable so there is a
trade-off there actually there are
different answers to this right so the
first example adds flexibility and you
know it adds fewer complaints it has
fewer complaints from the developer
right so dart does this it allows this
because sort of the goal is to find bugs
and not really get in the programmers
way but on the other hand if we if we
don't disallow the second example then
there could be bugs in the program that
we don't warn the programmer about and I
don't really know what the right answer
is this is one of these cases where
there's not a clear consensus right so
there are lots of languages that have
done different things and you know this
is not like static typing like or static
scoping so I think so basically every
language has agreed that static scoping
is the right choice there are sometimes
you want to use dynamic scoping but not
that often so static scoping is the
default this is not so clear the jury is
still out of it what about if untyped
code calls type code right so so here's
the F method I've annotated with integer
to any let's assume that I've type
checked it even though I haven't put in
the annotation so now I have this
wonderful method I've done fantastic
type checking I know there are going to
be ninja type errors and then I have
some untyped code that I didn't check
and it passes a string in and then it
violates the hole type annotation and
you know just blows everything up right
so that's potentially a problem so we
can solve that problem in our DL by
adding this wrap annotation so if you
set wrap to true in the arguments of
type it will actually treat the type as
a contract and it will dynamically
enforce that the argument has to be an
integer and the result has to be any so
that's good because it helps soundness
but it's bad because it adds runtime
cost and it means your production code
might fail so again this is one of these
sort of sticky issues where there's no
there's no clear answer one way or the
other all right so I mean in general I
think it's real
interesting to think about when types
are a good fit for your program right so
when is this kind of system gonna work
so it's gonna work well this is going to
sound a bit like it cetology right when
the code is mostly typable using the
system we think well if it's typable
using standard reasoning right so the
examples I showed you they type check
pretty well but if you're you know if
you have code where you say well this
argument is a string except on the third
Monday of the month if it's a full moon
then it's an integer that code is not
going to type check using any reasonable
type system right so that kind of
complex reasoning is not going to be
amenable to typing on the other hand if
we made a type system that could do that
kind of reasoning maybe it would be
really hard for the programmer to
predict so maybe the type system
wouldn't be as useful right so one of
the reasons types are useful I went back
to the the idea of design if you can't
predict whether the type system will
accept your program or not then it might
be hard to internalize that model of
type systems and use it to help design
your program so that's that's a really
interesting trade-off and going with
that you have to be willing to write
down type annotations to use the system
right so we are doing some work on type
inference which would lighten the burden
but at some level you know you you have
to be willing to annotate which means
your code has to be in a reasonably
stable state right because maybe if
you're furiously changing things all
around you don't want to have to also
change the types as well and you have to
be able to use the kind of types that
are written down without the annotation
burden being too high so for example if
you have heavy reliance on rubies
sometimes called duck typing usually I
call it dynamic typing and you want to
use structural types everywhere in your
program well that's gonna that's going
to be a lot more effort to do right so
you may not want to use our DL in that
circumstance all right so so that's most
of what I wanted to tell you let me give
you a quick status report so we're
working on making this a more robust
type system we've gotten some interest
from industry we're getting some pull
requests on it so that should help make
it more bulletproof and easier to adopt
I hope we're looking into additional
features to it like being able to serial
that type database so that you can do
more stuff online you can I can envision
implementing some actual overloading
with it which might be fun
better handling of certain features of
Ruby like method missing and then on the
research side we're looking more into
type inference and they're the
challenges we want to be able to provide
useful types to the programmer which is
actually hard because usually type
inference systems in first structural
types which turned out to be big and
complicated and incomprehensible in
practice and we're also looking at
verification so can we actually prove
properties that are deeper than just
types all right so that's already L this
type system we've developed for Ruby and
I think the punchline here is that to
get it to sort of fit with this dynamic
language the key insight is doing static
type checking somehow static but doing
that at runtime so still being able to
reason about all possible paths through
a method but doing that reasoning at
runtime after metaprogramming code has
been executed and it took us a long time
to figure that out but now it seems
completely obvious to me that that's
that's the right way to do this the
latest version of RTL is available it's
on github and there's also a ruby gem
try it out and let me know what you
think all right thank you
we have time for a couple questions yeah
yeah that's a really good question so
the question was what about things that
either return a useful result or return
nil and my answer was to punt because
because actually there's been a lot of
there's been a lot of research on
building type systems and other kinds of
program analyses to try to reason about
null pointer errors right whether
something could be no later on and based
on looking at all that work my
conclusion was that it's not really so
simple to do and that if you if you
actually put if you actually try to
treat nil differently and not allow nil
where other classes are allowed then
you're in for a world of hurt as far as
the annotation burden for programmers
that that didn't design their program
with that in mind so so we just punted
that and did the usual Java you know C
etcetera trick and nil is just a subtype
of every other type in the world and so
you can use it where those other types
are so you can still write the
annotation so so a lot of the standard
library methods are decorated to say
they return like Class A or nil so that
you can still see that but when checking
the types we don't check for nil we just
allow it to appear anywhere - just just
sort of get out of what I think would be
a very hard system to use yeah
yes so there's so four so four mix-ins
you can definitely say that something is
is an innumerable and then it will check
the type of the they will check the
against the innumerable annotation just
like it right so if it's if it's an
enumerable we'll just look at the normal
a little type signature and we'll just
pull types from that and it will work
just fine the one thing that I'm not
sure if we support in the implementation
yet is if you are if you're actually
type checking mix in and the mixin calls
out to something that's not defined in
the mixin but will be in the class that
it's added to I don't know if we type
check all that correctly we actually
have that we're working on the
verification part and we have that for
verification but I don't know if we
ported it into RTL yet but if not that
will be coming soon yeah
all right so what's what's my take on
gradual typing so that that's a that's a
good question I I don't know I mean I
will say that this system does not do
the full gradual typing thing of rapping
untyped code so that if you call into it
you can blame the right party and I'm
not doing that because I think that the
runtime burden would be too high so so
like I said we built some previous fully
dynamic checking systems for Ruby and we
found that it was just way too expensive
like just everything slowed down way too
much so I didn't do that so I guess I
think that it's it's sensible that you
would want to be able to add types to
these languages and both write code
without types and write code with types
and maybe want to switch a little bit
between them but I don't think we know
exactly what the pattern is right so for
example one pattern could be all your
libraries have type signatures and then
your application code dozens and you use
the type signatures for the libraries -
instead of like soundly enforcing types
for your applications to do more like
you know squiggly underlines in your IDE
about things that might be suspicious or
to give you code hints for completion or
something like that so you know that
that would be one design point and then
I think another one is just people you
know just saying we're just gonna always
use types right I mean I think I think
in practice if you want your program to
be typed you kind of have to design it
that way from the start but I think that
the reason RTL works for a lot of code
is that people do write so like even
though ruby has dynamic types because
maybe everybody has been so brainwashed
or maybe because it's a better way to
design programs people
to write their programs in a typed way
anyhow so maybe gradual typing is more
about giving people a way to just reduce
the annotation burden at the front but
not really to change the way that they
program so I haven't really given you a
good answer but it seems to me that what
industry is actually aiming for with all
these gradual type systems and what
researchers aiming for is really just
type systems that are going to be there
and is it just is it just the right type
system for the program and probably
there's not going to be I think if
people find the right type system there
may not be that much gradual about it in
the end we may wind up just programming
with types most of the time all right
well again thanks very much for
attention I had fun I appreciate you
being in the audience thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>