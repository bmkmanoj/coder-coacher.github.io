<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Make the Back-End Team Jealous: Elm in Production&quot; by Richard Feldman | Coder Coacher - Coaching Coders</title><meta content="&quot;Make the Back-End Team Jealous: Elm in Production&quot; by Richard Feldman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Make the Back-End Team Jealous: Elm in Production&quot; by Richard Feldman</b></h2><h5 class="post__date">2015-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FV0DXNB94NE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome this is make the back end
team jealous l/min production so my name
is Richard Feldman I work at a company
called no red ink and we make grammar
and writing software for English
teachers and our stack since day one has
been Ruby on Rails so there are two
parts to that you got the Ruby part you
got the rails part talk about Ruby so
Ruby is a language that's known for
having a good user experience to use
it's a nice language it's designed to be
a nice language its pleasant to use you
get a lot of stuff done at it I'm really
big on user experiences I love creating
user experiences I love building user
experiences I love watching people be
delighted by the stuff that I build I
also care about the tools that I use I
like being delighted by my tools because
I care about user experiences and
because I build for the web which I
personally believe is the best app
delivery platform the world's ever seen
I spend a lot of time with a different
language this language JavaScript
JavaScript you know has some things in
common with Ruby but there are there are
some some things that you know are not
not as nice there are some some sharp
edges shall we say and I've spent a lot
of time thinking why good JavaScript be
more like Ruby I'm jealous of the
backend like why do they get all the
nice tools and of course there's a good
reason for this which is that on the
back end you're writing for the server
the server you can write run machine
code you can run whatever language you
like on the browser you've got
JavaScript and you can write whatever
language you like as long as it's
JavaScript or compiles to JavaScript so
on the server any language in the
browser any JavaScript you like so since
I'm a UI guy I spend a lot of time
dealing with this question so Java
scripts getting better you know this es6
is fewer sharp edges than es5 kind of
sort of we've seen CoffeeScript get a
lot of adoption it's sort of taking
JavaScript anymore Ruby ish direction
making things a little bit nicer
polishing off some of the bad parts and
just removing them and then of course
now we're seeing languages that have
very different semantics from JavaScript
compiling to JavaScript such as element
well come back to that in a second first
I want to get to the other part of that
so rails rails is not a language rails
is we
an idea that's sort of an architecture
for the way you can build web
applications so we've got another big
architecture that we use at no red ink
which is reactant flux I remember when
these came out Facebook open source them
and we adopted them pretty much right
away they've been fantastic they've
really made it easy to organize things
that used to be problematic especially
as code scales so whereas before we used
to have this potentially large tangle of
things where this updates this and then
this updates this which updates that
which maybe updates the first two things
and you get kind of these cascading
updates and things get difficult to
manage react in flux organize things
much better so we have a lot of wires
going on here
there's a lot of stuff happening but you
can very cleanly see the organization of
it you can say okay all of the orange
wires are grouped together they follow a
certain pattern the yellow wires the
blue wires the green wires they all kind
of come together in a coherent system
and so despite the fact that there's a
lot going on it's organized it's easier
to deal with so I want to show you
quickly one of the interfaces that we
build using this stack so this is Ruby
on Rails CoffeeScript react and flux so
essentially this is for teaching kids
how to do active voice and passive voice
raise your hand if you feel totally
comfortable with active voice in passive
voice all right all right cool pop quiz
Halle Berry's new movie was watched by
me at the IMAX theater well it's the
active voice version of that nice
alright yeah so it's I watched Halle
Berry's new movie at the IMAX theater so
because we care about pedagogy we care
about efficacy we care about teaching
kids how to do this stuff one of the
goals of our tool is to get kids not
just to get the right answer but to
actually understand why they got the
right answer and to make the the
mechanical motions that they're making
in the course of answering the action
answering the question line up with what
they should be thinking about when
they're going from passive voice active
voice this is the interface we ended up
with so there are a couple of different
things you can do here you can drag
around any of these sections you can
click to cycle through the ones with
dots under them so we can do this
basically rearrange this sentence to be
what everyone shouted out so we'll say
okay I want to say I watched so I'm
gonna drag those and then I'm gonna
click to change I watched Halle Berry's
new movie we have this extraneous by so
we can drag that
the sentence and there we go I watched
Halle Berry's new movie at the IMAX
theater so in the course of doing that I
was physically rearranging the sentence
in the way that the students mind would
be working when they're thinking about
the transformations to make if we just
had a big text box yeah they would have
more options they would have more
flexibility but they wouldn't be
focusing on the right things for this
type of question so a couple things to
note about this interface it's actually
kind of a lot going on even though it's
pretty simple just drag and click for
example we have this grouping of
sections which works great when you have
sections that are small like this but
when you have longer ones they either
need to wrap or you end up with when you
have several long sections this big
stacking thing that no longer looks like
a sentence so we had to do this
ourselves this is wrapping there's no
CSS for display - jagged edges - wrap we
had to come up with this ourselves and
you know do the wrapping ourselves and
still make it feel to the kid as though
it's just one section and of course when
you pick this up it stops doing that
another thing to notice since I picked
this up at is lower case but if I drag
it to the beginning of the sentence and
drop it it capitalizes it for me
I also can't drag it past the period
that periods always got to be at the end
of the sentence so we're again we're
trying to focus on the things that
matter in this sentence and leave the
kid not worrying about capitalization
punctuation stuff like that just active
and passive voice this has been really
effective I've seen Josie our curriculum
lead we do these classroom observations
or will go and show a new interface that
we're working on the kids and just make
sure that it's actually doing the job
that we wanted to do so I saw her give
this was middle schoolers we're not even
supposed to have learned this yet about
a 30 second primer on active voice and
passive voice and just set him loose
answering these questions and at first
they were getting him wrong they were
struggling with it but as they started
to learn the motions and get the
feedback from the system by the end of
it after about 15 minutes they were all
doing it they got it it worked and
that's something we really care about
but that was not the first version of
this interface the first version of this
interface let's say it seemed like a
good idea at the time
kind of like solve the problem in sort
of a you know direct way it was a lot
simpler than that we didn't jump right
to implementing our own CSS wrapping by
hand we said okay we think this is going
to be effective and then we took it out
and we showed it to kids it was totally
not effective there's totally lost like
it was bad scene who said okay we care
about user experience you care about
excellent efficacy
we're gonna go back to the drawing board
we're gonna come up with a new design so
we did we iterated said great okay we're
gonna iterate on this we're gonna find a
new design that we think will be more
effective cool builds it took a while to
build great took it out to the kids and
boom nothing
still still not good so we had to write
again and so eventually we got to that
design it was effective everybody wins
the trouble was in the course of doing
that we had to rearrange all of this so
we had this very neat organization
thanks to reactant flux but now we said
okay we got this current design it's not
effective we need to get to this new
design and the English description of
how you would get to that new design if
something around the order of okay I
need to take every third orange wire and
swap it with every other blue wire now I
didn't just say very many words but you
know if you're thinking about that ooh
that's not gonna go that's gonna okay
there's gonna be a lot of unplugging and
plugging back in it's gonna be very
error-prone right and if you're working
with this stack coffeescript react flux
when you have something of this form
that is conceptually easy it's you guy
can describe it in fairly few words or a
whiteboard diagram of the design that is
mechanically error-prone where you're
moving a lot of things around you end up
getting a lot of this and it takes a
while it's um it's pretty unpleasant
honestly and you want your tests to save
you from this ideally because tests are
great for regressions when you make a
new feature and you change some small
thing you run your tests again and it
says oh hey some things that you thought
was true is no longer true you need to
fix that but the problem is when you're
making such a big changes this when
you're plugging all these things out and
plugging them in in other places you
just broke all of your tests so in other
words now I could say my tests
thoroughly covered the design that no
longer exists kind of a problem well
what is the consequence of this well
essentially the consequence is time it
takes a long time it took us months to
get from the first design of this to the
final version that we were actually able
to ship because iteration was so
expensive and because we wanted to
iterate we did have a choice we could
have oops back when iteration is
expensive we pay the price in either
usability or ship date so either we
could have said ok this is not effective
but we don't care ship it
or we could have said okay we care about
it being effective it's a problem that
this first design isn't effective so
we're going to take the time to iterate
on it iterations expensive then you take
that route your ship date gets delayed
it takes months to get it out instead of
weeks
those are months that those teachers
could have been using the new interface
so if we could just get cheap iteration
if we could be able to make these
changes more cheaply without having to
stumble over all these rough edges and
undefined or not functions and things
like that
angry Lucy Lawless we could just ship
good stuff sooner it would be better it
would be improved it would be Africa
that efficacious effective and we could
still get it out on time and the thing
is I knew that there was a way to do
this because I had this experience with
dream writer so I was here last year
talking about dream writer back when it
was react and flux and CoffeeScript and
at the time I was talking about it
because it totally works offline but
this is just a side project of mine it's
open source and basically at some point
I decided that I was going to do a major
rewrite and I was going to rewrite in a
functional language in part for learning
but in part for other reasons and the
language I ended up deciding on was Elm
some of the things that stood out to me
that made me choose Elm for this big
rewrite one was this it was this
benchmark comparing the way Elm fares
compared to other JavaScript frameworks
at this to do MVC application so Elm
compiles to JavaScript it works a lot
like react in that you has this idea of
a virtual Dom where instead of saying I
want to change this part of the Dom I
want to change that part of the Dom and
this sort of jQuery like sense instead
you say here's what I want the page to
look like and then after the user does
some input and something changes you say
now I wanted to look like this and the
engine seamlessly for you compares those
two versions there's a very efficient
diff and says okay here's the minimal
set of Dom updates required to make that
happen
so what react does it's what Elm does so
I knew that that was a nice thing
organizationally speaking react influx
big fan I knew that I could keep that
nice organization of wires with Elm but
I would get these other benefits and one
of the benefits would be speed it should
actually be faster despite the fact that
it was compiling to JavaScript and stuff
written in raw JavaScript for react nice
benefit another was this the
time-travelling debugger
be honest I actually ended up not using
it that much but it's very cool and it
has a lot of potential I think I'm
really excited about the stuff that it's
going to be when it gets the next couple
of versions of it but if you wanna check
this out
Elm - Lang org you can check it out you
can rewind time or you play things very
cool stuff semantic versioning is
guaranteed for every single package this
might be a big deal to you if you've for
example hypothetically seen a minor
version of underscore.js get released
that breaks everything hypothetically so
the way it works in elm is there's
actually semantic versioning enforced
automatically by the package manager so
what that means is if I make a breaking
API change I change the way something
one of my public interfaces and I try to
push that to the package repo it will
actually give an error and say I reject
your change I will not accept it unless
you bump the major version number so you
actually can really rely on semver
for elm packages right it's awesome so
there were these cool things that were
drawing me to Elm for a dream writer but
really having now used Elm for a bunch
it's not those big flashy things that
make it awesome it's actually when I
think of why I like using element why
it's such a nice user experience it's
just the little details the little
polish the little pieces of user
experience that make you feel great on a
daily basis let me give you an example
so here's some elm code we've got a list
of numbers and saying numbers equals and
then one two and three
I'm gonna say 'first equals we're gonna
call list dot head on numbers so lists
at head just gives you the first element
back out of a list so in JavaScript you
would say numbers bracket zero and same
thing in Ruby and elem you have a
function called list dot head I'm going
to say double first equals I'm gonna
take that first and multiply it by two
so if first is equal to one in other
words the first number in the list I
multiply it by two I will get back to
pretty straightforward okay so that's
easy enough to follow but there's an
edge case here right
what happens if numbers is empty now
what happens so I call this stat head
says give me back the first element that
there is no first element there aren't
any elements what happens here so
different languages handle this in
different ways let's start with our good
friend JavaScript
in JavaScript if you were to point this
code to JavaScript and
you would get double first equals not a
number so it would take the list dot
head they'd get back undefined it would
multiply undefined by two and say that
makes sense here's not a number and if
you ever dealt with a not a number
related bug and people haven't I suppose
um here's what it feels like you have
your interface in somewhere you've got
these nice series of numbers and one of
them just says na n you're like oh and
then you kind of basically bust out the
Tylenol and then after another hour or
so trace back okay this is not a number
because this thing had not a number why
did this thing I hope because this thing
and I thought okay why was it all
undefined right okay
it's pretty painful Ruby does a better
job of this so Ruby list dot head of
numbers will give back nil and then if
you try to multiply know by two it
errors out early it says no method error
undefined method asterisk for nil that's
much better I would much rather have
that than have the error silently
propagate through my program meaning
that I have to trace back and figure out
where it happened earlier is definitely
better when it comes to errors when
things are going to break much prefer
this way here's what Elm does so look at
this code I'm going to tell you that
this is not a valid Ellen program this
actually won't compile if you run this
through the compiler it will give you an
error it will this error will never make
it to your users and not just if you
have numbers being the empty list but if
you have numbers being any less
specifically what it will tell you is
you have a type mismatch so list dot
head and elm doesn't return a number it
returns a maybe number which is sort of
an opt-in version of null or nil or
undefined and essentially what maybe
says is look I'm aware that there's the
possibility that nothing's going to come
back here and you should be aware of it
too so what it gives you back is this
maybe container that says either I've
got nothing inside me or in this case
I've got a number and the compiler is
aware of that
so it says ahead of time look something
is messed up here the left argument
asterisk is causing a type mismatch it's
got the line number on the left nine
line 10 it actually squiggly underlines
as if it were Microsoft Word the the
actual variable that's got the problem
in question and says hey as I infer the
type of values flowing through your
program I see a conflict between these
two types you're acting like this is a
number but it's actually a maybe number
you got to handle that edge case it
won't let you forget pretty cool so this
is how you handle it there's a maybe
library
has all sorts of convenience functions
for dealing with them quickly the most
obvious of which would be with default
so I take list out head numbers and I
pass that to maybe dot with default 0
which means that if the list is empty
I'm going to get back to 0 and if it's
got stuff in it I'm gonna get back the
first number this will actually compile
okay but what if I made a different kind
of mistake that's not the only type of
mistake you can get what if I had a typo
what if instead of maybe not with
default I wrote out maybe that with
default that's again the type of thing
that's going to make Xena Warrior
Princess angry and JavaScript land what
about an elm land what does that look
like
again the compiler catches it naming
error cannot find variable maybe dot
with default this is again squiggly red
underline line number says hey maybe
does not expose with default maybe you
meant one of the following maybe not
with default so it actually tells you
the thing that you've messed up it tells
you the right version right come on yeah
this is how it ought to be when you mess
something up you know to have a helpful
compiler that tells you what you messed
up not just undefined it's not a
function deal with it this is so much
better if you would like to take the
stuff we just learned and actually build
a complete UI that's too long for this
talk but I have a blog post called
building a live validated sign up form
and elm there will be a link to it on
the slides afterwards and if you like it
starts from just assuming that you know
JavaScript and nothing else and just
takes you all the way through building
this live validated ajax the whole nine
in elm so no prior Elm or functional
programming experience required start to
finish just JavaScript okay so here's a
fact about elm everything in elm is one
of two things immutable data and
stateless functions so immutable data
means you can't change it once it's in
sanchita that's it no changing it no
changing anything inside it no changes
ever if you want a new version you're
going to copy it
fortunately elm uses persistent data
structures under the hood which means
that copying these things is actually
very fast it doesn't actually copy the
whole thing it only copies whatever's
necessary and has all sorts of nice
optimizations around that which is
exactly how it can do really well in
that to do MVC benchmark despite the
fact that everything is immutable data
stateless functions if you're not
familiar with them also
as pure functions referential
transparency stuff like that I like the
term stateless it's nice and descriptive
essentially the way they work is you
have a function it takes values in and
then it returns a value and that's it
has no side effects doesn't look at the
outside world doesn't read from a
database doesn't do Ajax doesn't do any
of that stuff it just looks at its
inputs and returns the value you give it
the same inputs it will every single
time return the same value and that's it
with no side effects so at this point
you may be wondering I just said a
minute ago that I've got this blog post
where allegedly we're doing Ajax
I also then said everything in Elm is
stateless functions which are not
allowed to do Ajax in the middle what's
up with that so essentially the way that
Elm does effects is instead of doing
them as side effects where you can have
them in the middle of any program it
does what are called managed effects
which is you represent your effects as
data so instead of saying I'm going to
imperative lis run this line of code and
it's going to do this thing as soon as I
hit that line of code what you're doing
instead is you're building up a
description of what you want done which
you then ultimately hand off to the
runtime and the runtime performs that so
you'd say essentially you have these
things called tasks so a task is just a
data representation of stuff you want
done it's a list of instructions you can
think about writing them down on a
scroll so instead of the action you're
doing being going to the store and
buying a list of things what you do
instead is you write down go to the
store and then buy this thing buy that
thing buy that thing on a scroll and you
hand it to a Lackey who does it for you
because doing things yourself is for
suckers
so essentially tasks let you accomplish
the same sorts of things just in a
different way and this is sort of a
recurring theme in elm it's that you're
doing the same kinds of things that you
were before you're just doing them in a
slightly different way we'll see what
that gets us a little bit later so tasks
are composable like promises they have a
notion of success or failure you can
chain tasks into other tasks to build up
an even bigger description of stuff you
want done that can branch off and chain
conditionally and stuff like that but
like callbacks they are harmless to
instantiate you can instantiate as many
tasks as you want and doing that
instantiation is just like writing stuff
down doesn't actually cause anything to
be done it's only once you altima tand
it off that something else actually runs
them so here's an example HTTP GET
string HTTP is elms ajax library it's
really nice getstring is the simplest
most bare-bones one you can do you give
it a URL
and it's going to give you back a task
which will go hit that URL take whatever
it gets back and give it to you as a
string there are other ways to deal with
JSON and stuff like that that are nicer
than this but this one is the simplest
the point is if I run HTTP GET string
what I'm going to do is get back a task
and I can then hand that task up someone
else but calling this code right running
this line of code does not make any
network requests I can run this code 100
times zero Network requests it's only
once I take the task that it returned
and hand it off that it actually gets
run what this gets you is these great
guarantees so think about this for a
second suppose you have a JavaScript
function and it's calling five other
functions each of those functions is
calling five other functions and there's
just this whole big graph of things
going on functions calling other
functions and at the end of the day you
have this bug whereby the end of
somewhere in your code local storage got
into a weird state something modified
local storage you're not quite sure what
and you're looking at this function this
function that calls other functions and
functions and functions and you're like
who did that I don't know how do you
find out I guess you start grepping for
local storage sure hope you know that
string doesn't appear a lot of times in
your codebase maybe it was in this
function maybe it was somewhere else in
Elm you could just look at what that one
function returns doesn't matter how many
other things it called did this function
ultra ultra local storage no because it
returns a string if it returned a task
it might have been able to alter local
storage because altering local storage
is an effect but this this function
calls all these helpers but the end of
the day I can see right there very
clearly it returns a string so rather
than spending debugging time digging
through all those functions are grepping
for a very common string and throughout
my code base I can just say no and move
on
imagine what this does to your debugging
experience did something you take this
value we've got a bunch of functions
calling other functions in JavaScript
you could have a global you could have
all sorts of ways that this function
could interact with this other function
even though neither of them is calling
one another in Elm nope values can never
be mutated that's just a guarantee you
just know that if you're trying to hunt
down a culprit you can say yeah yeah and
it couldn't be that because that doesn't
exist in this whole language did I miss
any cases in this refactor I renamed
this thing
I've got a big codebase in a lot of
cases you find out maybe days later
maybe weeks later hopefully you have an
integration test that finds it but maybe
not and there's an error that good it
comes up an Ellen that error happens at
compile time even though it's some file
you haven't touched in six months the
Ellen compiler still remembers it still
checks it and says hey got about that
one cool so whenever you do a refactor
you can be really confident that you
didn't miss any cases because if you did
that compiler would have told you about
it all of this gets you this once it
compiles it typically works on the first
try with no regressions or runtime
exceptions this is just what life's like
in Elm this is normal people who have
done this will back me up on this now
let me give you an example of this so
this is dream writer again an open
source on github this is a poll request
I made I made a couple of changes here
there are a few things that have changed
I guess you could say the diff is
there's a diff like I guess one or two
alterations there are some pollutions
maybe some additions ok so some stuff
changed right when this compiled it just
worked on the first try with no
regressions and no runtime exceptions
and if you think that's crazy
what's also crazy is that I've had this
experience so much I was like well yeah
of course I guess is normal okay I don't
count big the diff is not gonna break
that's just what my life's like now I
have to be careful not to get used to
this cuz maybe I won't work at door
waiting forever and I can't use awesome
tools like this but man am i enjoying it
while I'm here
okay so let's come back to active voice
in passive voice so I was retrospective
on this with my teammates and thinking
about how long it took us to ship this
thing using react flux and coffee
scripts and I couldn't help but think I
had this experience as dream writer if
I'd written this an element said from
the get-go it would have shipped sooner
even counting all the setup costs even
counting all the stuff that comes with
using a new language all the sharp edges
that you find out because you're kind of
on the frontier and there's just not
been as that many people exploring it
even counting all that counting the
learning curve it still would've shipped
faster and then I would have ended up
with much more maintainable code so why
didn't I I mean I I knew about it I knew
that was an option but I didn't do it
why not
well cuz I was scared I mean it's a
scary thing you know you jump in you're
like this is gonna be awesome
then you're midair and you're like am I
actually gonna land this I don't know
and you really can't know until you do
it so I thought back to the experience
that I had with reacts like I said we
adopted react right when it came out I
mean looked at that said this thing is
great let's try it out we did there was
a lot of risk at the time reacts pretty
mainstream now but at the time it was a
risky thing to do there's a lot of
set-up time there again because it was
very new we were apparently one of the
first people using react with Internet
Explorer 8 because which we don't
support anymore thankfully but back then
we did and we actually ran into some
documentation problems where it was
describing how to get things working in
IE 8 and it didn't work so then I get to
become a react contributor technically
by fixing that but it's it's one of
those things that just comes with using
something very new and of course there
was learning curve you know nobody on
our team knew react we had to learn it
then we had to teach each other what we
learned was it worth it oh yeah it was
so worth it it was amazing I mean that
comparing our experience with react to
the stuff we were doing before it's just
so much better everything is cleaner the
problems that we were having went away
so I'm reminded of this amazing quote by
Tina Fey you can't be that kid standing
at the top of the waterslide
overthinking it
you have to go down the chute so we did
went down the chute we said look let's
not make this mistake again
we know Elm will solve these problems
we've been having let's do it
so here's what we did we chose a small
unscary project to try out Elm
specifically what we did is we took one
of our flux stores just one and we
pulled out all the logic that was in
CoffeeScript and replaced it with Elm
and essentially the way we did that is
using Elms port system so if you haven't
heard of this this is how Elm does
interoperation with JavaScript so
essentially you have all these
guarantees in elm land you don't want to
sacrifice those and sharing code with
JavaScript is a pretty good way to start
introducing those JavaScript type bugs
back in your application we don't want
that so the way Elm deals with that is
by talking to JavaScript basically like
it talks to a server you just pass data
back and forth so you're using these
ports you can say I want to send some
data out to JavaScript or I'm gonna get
some data back in from JavaScript it's
the pub/sub system so essentially
there's no code sharing it's just got
the
same kind of characteristics as you have
when you're talking to the server you
don't really care what the other
languages in this case is JavaScript
okay whatever
obviously this is a lot faster than
talking to the server because instead of
doing the network connection it's just
more of an abstraction but the basic
idea is that you get to preserve all of
your guarantees while talking to
JavaScript so we use this in all sorts
of ways we use this for date picker
libraries that we don't want to be
implemented Search Indexing just any
kind of JavaScript library that we don't
want to rewrite an elm we will just use
a port to talk to it and that's exactly
what we did in this case except it was a
port talking to our old code so we were
able to do this change and replace all
the logic in this one flux store with
Elm logic without changing any other
JavaScript files basically just each of
those methods instead of having a bunch
of logic in them in CoffeeScript we
ripped all that out and just had one
line that said send out to an L
important that was it so that worked and
that we got a good sense for what it was
like to get Elm integrated into our
build process there were some sharp
edges there too we had some stuff where
we had to you know figure out how to do
things on ourself because nobody else
had done an element aggression with
rails and now we've benefited from there
you know you look you guys who don't
have to run into those because we did
but it was worth it so if you're
wondering how to do that also have a
blog post on that introducing Elm to a
j/s web app and it's basically doing
exactly the same thing we did except
with the flux to do MVC applications so
it's just taking that and then ripping
out the guts and replacing it with
talking to Elm so if you're wondering
how to do that check out our company
blog it's got a post on that too okay so
again we're faced with the same thing as
we were with react
we've got risk we've got set-up time
we've got learning curve was it worth it
so worth it whoa I mean this was like
react was a big upgrade this is just
mind-blowing ly good I mean you're just
a short list of things we've seen so
fewer bugs
weh-weh if you were bugs code is just
way way miles ahead as far as buggy this
than our old stuff I mean the compiler
can't catch absolutely everything but
man does it catch a lot improve team
spirit people are really excited about
using it people are happy using it it's
been an awesome experience you just
people just start smiling when we start
talking about it we've seen an increase
in job applicants people are excited
about working for us just because
we're using this cutting-edge awesome
technology by the way we're hiring and a
surprisingly low learning curve I mean
this is this is about as hardcore as
functional programming gets on
theoretical levels right
everything is immutable only stateless
functions anywhere you would think that
because that's so different on paper
that it would take a long time to get up
to speed I don't know how else I can
dispel that besides telling the story of
one of our co-workers basically she was
not a programmer she went through a boot
camp where she learned JavaScript her
second day on the job is being her first
programming job she was writing elm code
for production unsupervised
it can happen I mean she's really
awesome
so I don't know if I should make the
claim that everyone can do that but it's
totally doable I mean you can get up to
speed doing that and the way we did that
was just threw a bunch of hair
programming we have a big culture of
pair programming we do it about 50% of
our time is pairing we even do remote
pairing with our remote people and that
was all it took was just you know a week
or so of that and she was up to speed
she's off and running
so in summary got a clean UI
architecture the same kind of stuff as
react in flux a delightfully helpful
compiler that I really hope I never have
to live with that again semantic
versioning guaranteed for every single
package and change is cheap it's so
cheap that we now just refactor pretty
much at the drop of a hat we were just
talking the other day and I estimated
off-the-cuff that we probably refactor
our elm code about three times as much
as our CoffeeScript code just because
it's so easy I mean we'll come through
and we'll make some change and we'll say
oh you know what um this could be better
why don't I just change that you'll make
the change and if it compiles you're
just pretty confident that it's gonna
work and basically pretty much always
does in short stuff is reliable it's
really nice so we started off asking why
can't javascript be more like Ruby this
thought that I've had all the time and I
was so jealous of what people got to use
on the back end because what I had was
just so much clunkier and less nice to
use but now I've come full circle and
with elm now I'm asking the question
I can't Ruby anymore like hell thanks
very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>