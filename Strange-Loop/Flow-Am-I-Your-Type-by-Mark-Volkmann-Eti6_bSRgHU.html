<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Flow - Am I Your Type?&quot; by Mark Volkmann | Coder Coacher - Coaching Coders</title><meta content="&quot;Flow - Am I Your Type?&quot; by Mark Volkmann - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Flow - Am I Your Type?&quot; by Mark Volkmann</b></h2><h5 class="post__date">2017-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Eti6_bSRgHU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right I'm gonna get started with
some introductory remarks here my name
is Mark Volkmann I work at object
computing right here in st. Louis we are
the home of a web framework you may have
heard of its called Grails we do many
other things consulting and training and
we have a booth that's on the second
floor so come and visit us to learn more
there are three tools in the JavaScript
space that have really made a huge
difference in my life as a JavaScript
developer and those are es lint I bet
many of you are already using that and
then there's prettier a really great
tool for formatting your code then third
would be flow that I'm going to talk
about today and as you'll see when I
start going through these slides they
are probably the most dense slides
you're gonna encounter at this
conference they're kind of old-school in
that sense and it really is on purpose I
want it to be the case that if you're
convinced to give this a try you can go
back to work and share these slides
which you can find at that URL with any
of your co-workers and they don't have
to hear this talk they can read through
the slides and they'll be able to
understand how to use this so that was
my goal and preparing the slides in this
way there's so much I could say about
flow it really cannot fit into the 40
minutes that I have so I'm gonna try to
go quickly I'll have to leave some
things out but there are many slides
here that you can read later and catch
up on that so first we'll go over an
overview of what flow is we'll talk
about how to specify types how the flow
server works that's the piece that is
checking your code for potential issues
then I'm gonna get into just the
beginning of how to set up the use of
flow on a project but I'll leave the
details to the slides that I'll be
skipping over and then there's lots of
bonus material so first something very
basic when you use a statically typed
programming language and you compile
your code that's when it tells you about
the errors of course you don't get that
benefit when you're using a dynamically
typed language you typically learn about
the errors at runtime which is not a
good thing and so that's why we have
type checking tools like flow and
typescript to help you find out about
those kinds of errors before you
actually run the code and so why should
you use types really in any code well a
one that I already mentioned is
that you'd like to find out about errors
in your code before you run it another
is that it's great documentation about
what you were expecting to happen in
your code you wrote this function what
kind of arguments did you expect to be
passed what kind of value should be
coming back or you wrote a class what
types do its properties have it
increases your confidence when you're
doing refactoring and this is maybe the
biggest benefit that hit me really
quickly when I started using flow is
that once the size of our project grew
to a certain size and I had to make a
big refactoring I could with great
confidence say I want to change the name
of this property let me just do it and
see what it breaks oh these 10 files
need to be modified ok now I see where
the changes have to happen and so it's
really great for that it removes the
need for you to add your own type
checking in the code you probably have
seen functions that people have written
that the first thing that happens in the
function is it checks one of the
parameters to see is it a string or a
number so you don't have to do those
kinds of things and you don't have to
write type related unit tests and the
last one is that pretty much any editor
or IDE that you pick nowadays has
plug-in support for many tools and flow
is certainly one of them and so your
editor or IDE can tell you about issues
in your code with all of those benefits
there are still reasons that you should
avoid putting types in your code and one
is that it's gonna take some time to
learn the syntax and I'm gonna try to
help with that today and show you how
all that works but it takes a while to
really master applying those types
it makes your code more verbose that's a
big reason why people don't like to use
types it makes the code look kind of
ugly you wanted it to be very concise
and no it's not concise anymore but I
think you'll see that the benefits
outweigh that desire and you can still
keep the code relatively concise and the
third reason you might want to avoid
types is that if you're trying to do
some rapid development or prototype
something it's sort of getting in your
way but that's a nice thing about type
systems that allow you to gradually add
types is that you don't have to do it
right away so you can still do
prototyping without the types and then
if you decide that Pro
type is going to live on into production
code you could add the types then so
when should you use types well if your
application is large or complex or it's
critical to your company you think that
it's gonna live for a long time and thus
it may need to be refactored those are
good reasons to use types if the code is
gonna be written and maintained by a
large team of developers that's a good
reason but sometimes none of those apply
and maybe you should skip types for an
application like that so flow is this
static type checker that comes from
Facebook and it runs on your JavaScript
code and tells you about potential
errors and it does this by using flow
analysis and that's the basis of the
name it is tracing the flow of values
throughout your code so if I call a
function and I pass it something inside
that function it might take that value
and pass it to something else which
passes it to something else and flow is
watching all of that to see how you're
using that value and decide what that
type might be and so that's where the
type inference part comes into play
because you can do gradual typing flow
doesn't just throw up its hands and say
I don't know because you didn't tell me
the type it says I looked at the flow
through your whole application and I
could see that this value is only ever a
number so it must be a number so that's
the type inference part so as I said you
can gradually add types all the es6
features are already supported and even
things beyond es6 can already be used
with flow and it understands those and
of course because this is something from
Facebook it has special things to work
with react and with JSX the syntax for
putting HTML into your JavaScript but
that doesn't mean that flow is tailored
to react it's just that it works well
with that another competing tool is
typescript from Microsoft and this does
type checking just like flow but it also
acts as a superset of the JavaScript
language and that means that it adds
some features beyond what
in the JavaScript specs and I have a
list of some of those on this slide and
so this is maybe a slightly
controversial thing one way to look at
this is that those are good features and
they'll probably be added to the
JavaScript language at some point and if
that happens great but what if they're
not added to the JavaScript language if
JavaScript adds something that's similar
but not exactly the same what will
Microsoft do will they change theirs to
be like the standard or will they keep
their proprietary syntax we don't know
and so that's a point of concern for me
typescript compiles down to JavaScript
and the way you indicate that you want
to use it is you give a file extension
of dot TS instead of dot j s so it's
doing two things for you it is type
checking your code but it is also trans
piling it down to a lower version of
JavaScript like es 5 so that you can run
it in a browser or run it in node and so
on the one hand that seems nice that
it's doing these two things for you on
the other hand this is also a
controversial point do you want it to do
the transpiling a reason you might not
want to is that Babel is a really great
tool for transpiling JavaScript code and
many people have written these great
babel plugins to do different things
with your code and so if you're
bypassing that and you're using
typescript to do the transpiling you're
kind of opting out of that well not
entirely because you could tell
typescript would you compile down to es6
and then I'm gonna take that and run it
through babel as a separate step but
that's kind of awkward to have that
extra step in your process another point
of comparison is support for third-party
libraries so you might want to add types
in your own code but what about all
those third-party libraries things that
you could get from NPM did those authors
put type descriptions in their code
probably not and so other people have
done that for us and they've put it into
libraries and the one for typescript is
called definitely typed and a really
large number of people have done this
for a really large number of libraries
and
so there are over 2,000 JavaScript
libraries that have type definitions for
typescript I wish I could say the same
for flow the last time I checked it had
570 type definition so quite a bit less
the only saving grace here is that there
is a tool for flow that can read in a
typescript type definition and convert
it to one that is compatible with flow
it doesn't work in every case but it
gets you pretty far along that line but
I have to concede this is a point in
typescript favor that it already has
type definitions for so many libraries
both of them flow in typescript have
good integration with editors and IDs
and flow has a goal of remaining
compatible at least as much as they they
can stomach with typescript syntax and
they've done a pretty good job of this
and I would say in standard usage of
adding types to your code they're about
95 percent the same there was an earlier
talk where the speaker said that if you
implemented your code and flow it might
be an ordeal to switch it over to
typescript or vice versa
I think I disagree with that assessment
I think it's actually not a big task
because the syntax is so similar so if
you want to install flow there are a lot
of options that are described at that
website the simplest thing you can do is
install it globally the confusing part
is that you do not want to ask it to
install flow you want to install flow -
bin that's the piece you really want and
then you can ask what version you have
installed and you're gonna ask for help
but this is really just to get off the
ground with flow you don't really want
to use it this way you want to have flow
be a part of your project a a project
dependency that's recorded in your
package JSON and in my later slides I
talk about how to do that but just to
get you off the ground you can do it
this way then the next step is you need
to tell flow which of your files you
want it to type-check because remember I
said that you can add the types
incrementally and so a one thing that
you need to do is add a comment at the
top of your file and tell it to use flow
and so slash flash at flow is the
easiest way to do this
a kind of a downside is that if you
forget flow isn't checking that file and
there's no warning for you that you
forgot this and so you might be going
along all happy that you don't have any
flow errors and decide later oh I didn't
turn it on for this one file there is an
es lint check that can tell you if you
forgot that if you want to demand it for
every file so you could opt into that
remember I said in typescript the way
you opt in is by changing the file
extension to dot TS but here you add
this comment then if you want you can
ask flow to just check one file and you
do that by saying flow check - contents
and then you can redirect into that the
content of a file and that'll output any
errors it sees but really you want to
run this on all the files in a project
and let's describe later when I show how
to set this up as an NPM script in a
package.json file when you're first
getting started you might like some help
in determining what the appropriate
types are for a piece of code and so
there's this flow suggest and you give
it a file and it will output your code
with the types added at least what it
thinks it can't guess correctly in all
cases but if you look at this very
simple example I have a function that's
gonna compute the area of a rectangle
and I pass in a width and a height and I
return their product and then I have a
call to that and all is good but if I
want to know what flow believes the type
should be I run flow suggest on that and
it says hey I can see that you're doing
some multiplication here so I'm going to
say width and height are numbers and it
looks like you're returning that product
so I'm gonna say the return type of that
function is number and so this is very
simple example it can do more
complicated things but that's great that
if you're confused flow can give you
some suggestions as you might imagine
when you add these types into your code
other tools don't understand it so I
can't just run this code with node and I
can't run it in a browser I have to
strip out those type definitions and so
there's multiple approaches to this but
a simple approach
if you're wanting to use node is to
install node remove types and this gives
you two utilities it gives you flow node
and also flow remove types and so flow
node is like a replacement for the node
command you just give it a JavaScript
file that may or may not have type
definitions inside it and it will strip
those out and run that code it doesn't
rewrite the file it's just kind of doing
that in memory and then it's able to run
it if you really want to remove them
from the file you use remove a flow
remove types and give it the file and
then direct that output into a brand new
file so there you are creating a new
file and by default it's sort of whiting
out the type so it doesn't change the
spacing of anything it's just replacing
all the characters in your type with
spaces if you'd like to collapse that
space then that's what the - - prettier
option does either way it's not doing
anything for you unless you have
annotated the file to say you wanted it
to use flow so the slash slash at flow
is still necessary there's another
approach you can use where you put the
types inside special comments but it's
just really ugly I think you should
bypass that and just put the definitions
in in a normal way okay so here's a
simple example of what flow can catch
for you without you even adding any
types because it's doing the flow
analysis whether you add the types or
not now I did still have to add the at
flow comment but here I have this
function where I pass it two things and
it returns those multiplied together so
I haven't told it anything about types
but you can see in my call I'm passing
it a number and a string and flow says
hey you're trying to use that as an
operand of an arithmetic expression and
that's not right so it caught that for
me without telling it about the types
interestingly this is a thing that
typescript cannot catch typescript wants
you to tell it the types and it'll say
that this code is ok and every time I go
over this slide somebody with experience
with typescript says really did you test
that with the latest version I don't
think that could be true and then they
go check it and make
conceit oh yeah it really didn't catch
that uninitialized references this is
probably the biggest thing that Flo was
catching for me when I first started
using it not so much that I passed a
number but it should have been a string
it's that I was expecting a value and I
didn't account for the possibility that
it might be null or undefined and Flo is
really good at this because by a default
it assumes if you do specify a type that
it won't be no or undefined and we'll
see examples like that coming up but in
this example I haven't specified any
types and so in my get last initial
function expecting you to pass me a
person object and I'm expecting that to
have a property called last name and so
in the first line of that function I'm
using destructuring to pull out the
value of the last name and then I'm
going to check and see if it was there
and if it was I'm gonna get the first
character and return that otherwise I'll
return an empty string and so then I
create a person object that has a last
name and I call it everything is good it
outputs a capital V for me but then at
the bottom I'm declaring let and I
didn't give it a value and then I call
that same function and flow is gonna
catch this and it gives me three lines
of errors so first it's saying that that
call to get last initial has a problem
and then it says well the problem is
that inside I don't think there's gonna
be a value for last name or there may
not be and then on the last line there
it's saying a person is the problem here
that could be uninitialized okay so
that's great that it catches those sorts
of things for you so I want to go into
some detail now about how you specify
types because up until now I've just had
the number type or I haven't specified
types at all and there's a lot of detail
about this that you can find at the flow
website but I'm gonna try to hit the
high points here and the basics are that
after the name of a thing it could be a
variable or a property or a parameter to
a function or the return type of a
function after the name of a thing you
have a colon and then it's type and so
in this
simple example the type of score is
number and I also can initialize it so
the type can often be inferred but the
question is what will it think the type
is so if I didn't specify a type here if
I didn't say it's number it could see
that I'm assigning zero but would it
know that it's a number well it would if
I had used constant instead of let
because then it would know it can never
change to something else but since I'm
using let if I remove the type of number
it doesn't know if I may be assigning
that to something else later
actually flow will figure it out because
it's gonna follow the flow through my
application and it might run across the
line where I assign a string to that and
then flow it infer that the type of
score is number or string it can be one
or the other okay and so my point here
is that ya can infer the type but if you
use a let it's got a look at all the
rest of your code and see if you might
later assign something else to that a
flow call something a maybe type if it's
value might be null or undefined and you
signify that by putting a question mark
in front of the name of the type and so
here I'm saying that score is maybe a
number but it also could be null or
undefined and you do that with the
question mark typescript can do
something like this as well where it's
gonna check and make sure that if you
didn't allow something to be null or
undefined that you didn't use those
values
that's called a strict null check and
that's an option that you need to turn
on it's a fairly new feature of
typescript but this is the default
behavior and flow that nothing can be
null or undefined unless you say that
it's a maybe type so the basic types are
what you might expect boolean and number
and string it supports the wrapper types
for those which are rarely used in my
experience if you want something to have
a type of null you just say no if you
only want it to be undefined you have to
use void that's the word that means that
it allows undefined
interestingly you can also say that the
type of something is a specific literal
value so a number that is always seven
or a string that's always foo or a
boolean that's always true it seems odd
I may be trying to come up with an
example of where that would be useful
and I'm gonna show one later where we
talk about type discrimination maybe
twenty more slides here another type is
any and this basically means I've grown
very lazy and I don't want to think
about this anymore so just don't do
anything with this it's really a bad
idea and there's a related type called
mixed which is a better idea
mixed also means it could be anything
but it says before I actually use it in
my code I'm gonna do some checks to see
what it really is right now and we'll
make it safe and so in this example at
the bottom I have this function foo that
takes the parameter V and that's mixed
so it means it can be any type but
notice that down in the code sometimes I
multiply V by two and sometimes I ask
for the length of the thing before I
multiply I verify that it's a number
before I get the length I verify that
it's a string and if it was anything
else I'm just returning it and so that's
gonna be okay no matter what the type is
so this is a thing that's called a type
refinement and it's something that you
must do if you say that the type is
mixed so mixed is a way of saying I'm
gonna do some work here I can't exactly
tell you what its gonna be but I'll
check before I use it and make sure it's
gonna be okay of course the best thing
to do is specify a specific type if you
can and so here's an example of some
basic types I've got this get chars
function and I can pass in some text
that I want to get characters from and I
can tell it how many characters I want
and what I like to get those characters
from the beginning of the string or from
the end of the string with that boolean
at the end and then the return type of
this function specified after the right
paren is that it's going to return a
string okay and so that code is doing
all the right stuff and then I have
three calls to it and the first two are
fine the first one is getting care
from the beginning the second one gets
characters from the end the third one is
just completely wrong everything is
wrong there I'm using a number where
it's supposed to be a string I'm using a
boolean where it's supposed to be a
number and a string where it's supposed
to be a boolean and I'm gonna get three
errors output for that line it's a very
simple example of using primitive types
there are a lot of things that Flo
understands out of the gate without you
having to tell it and so if you look at
this github reference there you'll find
the files that are in the blue boxes off
to the right and there are very readable
definitions of those things but Flo
already understands all of the things
that are built into JavaScript it knows
what you can do with an array and what
you can do with an object and a string
and a date and so it'll check all of
those for you it knows about the Dom it
knows about the methods on an element or
a node all of those things it knows
about the browser API things in
geolocation and WebSockets all of those
kinds of things we want to mean by that
is that it knows what are the functions
that those define and what kind of
arguments they take and what they return
and so if you use them incorrectly it
will flag that for you it knows all
about node J s and so all you have to do
is require a node module in the normal
way and the ones that are in core things
like FS for the file system it
understands all of those functions and
will tell you if you're using them
incorrectly and it knows some things
about special events that react uses so
that's just some highlights of what it
already knows how to do without you
defining the types now when you get into
defining your own types it's often the
case that if it was important enough to
define you're probably using it in
multiple source files and/or maybe
multiple places within the same file and
so you don't want to keep repeating long
definitions for example if I'm gonna
specify all the properties that can be
in a certain object it could be a long
definition and so what I want to be able
to do is is give that definition a name
and I do that with a type alias and that
for an object is just telling me like
the minimum requirements for
this kind of object it can have
additional properties but it has to at
least have those that I specify that's
something that's called with subtyping
I'm just specifying a subset of the
requirements for this object and so to
define a type alias you say type and you
give it a name equals and then the
definition of the type and it's a widely
followed convention and flow to make the
name of these types end with the word
type you don't have to do that but it's
a convention and there's an es lint rule
that can tell you if you didn't do that
a related keyword here is interface and
interface is very similar to a type
alias and I have a URL there that you
can go to to read up on the minor
differences between those when you want
to specify types for a function we've
already seen some examples like this but
here I have this monopoly related
function and I can tell it whether I'm
passing go and what I rolled on the dice
and what piece I'm trying to move and we
have types for all of those and then as
a result of this move I have a result
and so that's result type define there
so we'll assume that that's a type alias
I've defined somewhere else okay and so
that's great for specifying the types
for this one function but what if I had
multiple functions that had the same
signature
I'd like to capture that and a type
alias and be able to say that various
functions are that kind of function then
I could also use this for cases where
I'm passing a function to another
function so I need to say the type of
that parameter which happens to be a
function or a function that returns a
function and say that that's its return
type so in that case I'm defining a type
alias my F and type and it looks very
similar to that first line the biggest
difference you'll see there is that
after that right paren instead of a
colon I have an arrow and that's just
the difference in syntax when you're
defining a type alias for a function
signature inside a function definition
if you want to have optional parameters
you do that by putting a question mark
after the name of that parameter and so
in my distance from origin phone
type you can pass in an X and a Y and a
Z coordinate but maybe you're just
working in 2d and you want to leave the
Z coordinate off and so I've made that
be optional also if I want to say that
something can be null or undefined as we
saw earlier you put the question mark in
front of the type so if you're familiar
with implementing callback functions in
node usually they take as their first
argument an error but there might not be
an error it could be null and so that's
why I have that red question mark in
front of error for my callback function
and then there's a result well I may not
have a result and so that's an optional
parameter and if I do have a result in
this case I'm saying it's mixed because
it could be anything
for this particular callback so those
are all the ways that you can describe
types for a function I'm moving on to
arrays I want to describe that something
is an array of a certain kind of value
and there are two ways you can describe
this you can say the name of the class
array and then angle brackets to tell it
what kind of elements can go in it
or I could use the square bracket syntax
and so we see two examples here of
saying that I have an array of dates
they're really equivalent you also can
nest these if you want a type that is an
array of arrays of something and so here
I have an array of arrays of numbers in
an example of using that and at last
here you have this special kind of array
that is a tuple a tuple is kind of an
array that has a fixed length but it
allows all the elements in the array to
be different types and so I could say
this is a tuple with three things in it
and the first element is a date and the
second one is a string and the third one
is some kind of person object but in my
simple example here point type it's a
two element array where both of the
values happen to be numbers so with a
tuple it must be fixed length and you
are not allowed to use array methods
that mutate the array that's a
restriction just for tuples now on to
objects this is a really common case
you're gonna run into and so the kind of
lazy approach is to say yeah this is an
object
but I'm not going to tell you about any
of its properties and you can do that by
using the name of the class object or
you can just use curly braces empty but
you'll probably want to go further than
that the most specific thing you could
do is to have a class and say it matches
that class and that's number three on
this slide it could be a class that I
defined or it could be a built in class
like date but then that middle option is
a really common one where I'm going to
specify a subset of the properties that
objects that match this have to have and
so in my example on the right I'm
defining a typing alias for person type
and I'm saying that every person has to
have a name and it has to be a string it
cannot be null or undefined because I
didn't put a question mark in front of
it everyone has to have a birthday that
must be a date and you might have a
spouse that is an optional property in
this object and if you have it you are
allowed to set it to null or undefined I
think it's a bit odd to use both of
those question marks it would be more
common to say well if the property is
there it should have a good value or to
say it always has to be there but you
might set it to null or undefined but
I've done both in this example and then
below that I'm using it I'm saying that
Tammy is a person type and then I create
that object and notice that Tammy has a
height property but I didn't say
anything about that in my type alias and
that's okay because all I'm specifying
is the minimum requirements it always
can have additional properties and then
at the bottom I'm defining a mark type
and it has all the required values plus
a height plus it has a spouse and this
is a little unusual because somehow I
ended up being married to Tammy but
she's not married to me so we'll fix
that on the next slide when we see how I
could define a class that does this with
a method that could associate us and so
here we have an es6 class person and
notice the syntax in the beginning of
the class where I can specify the
properties but these properties are not
required it just says that if you have
those properties that have to have these
types
and then I have a constructor function
where I can pass in all these things and
whatever you pass in gets assigned to
those properties and then I have a meri
method and so I can pass in another
person and here's where I make it so
that they're both going to be married to
each other with the two assignments you
see there and so then I create two
person objects and I have Tammy Mary
mark and now everything's good and so I
have this logged person function and I
can pass it a person object and it
prints out information about them and
that works great when I pass mark to it
because mark is a person type and that's
what I said
logged person required but on the very
last line I'm passing in a date object
obviously that's wrong and flow is gonna
flag that for me unions allow you to say
that a type can be one of a number of
possible types and so here I'm saying
that a primitive type is a boolean or a
number or a string and now that I've
said that I could say that value is a
primitive type and then it's okay for me
to assign 7or true or the string foo but
if I try to assign an empty object flow
is gonna catch that that doesn't match
any of the possibilities now a more
interesting thing and this gets into
what I mentioned earlier about how you
could say that a type of a thing is a
literal value well that's what I'm doing
on the next three lines notice that
animal type animals have a name and they
have a type which is always the string
animal I can't have any other value and
then animals have a leg account which is
a number mineral is similar it also has
a name but its type is always mineral
and it has a hardness which is a number
and then finally vegetable type that has
a name it has a type which is always
vegetable and it has a color which is a
string and you'll see on the next slide
why I really want to do this but for now
suppose I create this thing type but I
say a thing could be an animal or a
mineral or a vegetable okay and then I
say that dog is an animal type and I
assign an object to it and that works
just fine because I did give it a name
and I did say that the type was animal
and I gave it a leg count everything
good they're the same for mineral it has
a name and has the right type it has a
hardness my vegetable has a name it has
the right type and it has a color but
now I want to assign dog to that
variable thing and I said that thing is
a thing type and so this works great
because a dog is a kind of a thing
according to my definition I could do
the same with a mineral I could do the
same with a vegetable but down on the
very last line I gave it an object that
does have a name but it has a type which
doesn't match any of the three that I'm
allowing and so flow is gonna catch that
for me now at this point that might seem
interesting but not overly compelling
the compelling part is right here when
we use that for type discrimination so I
have this function where you can pass it
a thing type and then I go into a switch
this is the important part I'm switching
on the type of that thing and flow knows
that there are only three possibilities
and it's gonna demand that I have a case
for each of those and then I don't have
cases for things that aren't possible
values so I have them all covered I've
got a case for animal and mineral and
vegetables and then inside that case I'm
logging things out and if it's an animal
I'm logging out the leg count if it's a
mineral hardness if it's a vegetable the
color but flow is checking that for me I
cannot try to log the color of an animal
it knows that only things with a type of
animal have a leg count and similarly
for the others so this is a really cool
part of these disjoint unions and using
them in a type discrimination like this
you can also use unions for a simpler
thing just a basic enum and so here I
have an activity type swim bike or run
and so I can assign swim or bike or run
to that but if I want to assign collapse
it's gonna complain about that so now
that I've created these type aliases for
different things I want to share them
across my files and so I need to be able
to export them and import them and to do
that just like in normal JavaScript when
you're exporting an import
with the module syntax you have to have
a module bundler that can stitch it all
together the same is true here and
webpack can take care of this for you so
here I'm exporting the type named type a
name type as just any object that has a
name property which is a string it could
have other things and then I have this
function say hello that takes a named
type and then down at the bottom in a
separate file I'm importing the type and
I'm importing that function and then if
I create an object that has a name
property it's okay to pass that to say
hello but at the very bottom when I just
pass a string that's not a named type
and so flow will catch that sometimes it
can be difficult to make flow happy not
often but sometimes you might be
confused about how to tell it what it
wants and so there's an escape hatch
here you throw in a comment with dollar
flow fix me and maybe some additional
text to tell it what's going on there
and that'll turn off flow just for the
very next line of code obviously you
want to not do this if you don't need to
but if you're really stuck and you need
to get some code running that's
something that's an option for you now
I'm getting short on time here so I'm
gonna go pretty quickly here and tell
you about the flow server the flow
server is the thing that is watching all
your files and if you make changes it's
doing type checking on those and files
that import those to make sure
everything is checked but an interesting
thing about the flow server is that it
doesn't output any errors it's just
collecting all this information it has
gathered about your code and it's
waiting for something else to ask it hey
flow server did you see any problems and
so typically it's your IDE plug-in that
is doing that for you and then reporting
the errors to you another thing to know
about the flow server is that it starts
up a bunch of processes so that it can
check your code in parallel on my
machine it happens to start up ten
processes but that's based on the number
of processors that you have and so I
have some detail here on how you start
up the flow server but typically when
you're using this from your editor or
your
IDE it's doing that for you so here is a
very important checklist for you to look
over if you want to get started with
using flow on a project and I recommend
going through all of these steps so
first there's some dev dependencies you
have to set up and there's a slide here
that shows you all of those then you
want to add some scripts to your
package.json to make using flow easier
and there's a slide on that then you
want to set up es lint to check that
you're using flow correctly you want to
set up babble so that it knows how to
strip types out of your code when it's
bundling everything together you want to
create a flow config file this is where
you can set up some options for flow but
it also acts as a stopping point for the
flow server because if you're down in
some subdirectory of your project it
needs to check possibly all the files in
your project if it hasn't already and so
it walks up the directory hierarchy
until it finds that file and then it
checks files below that so it's very
important that you have that file at the
top of your project and then another
step is to set up this tool called flow
typed that's how you pull in the
definitions of third-party libraries
into your project the flow type
definitions and it does that just by
looking at the dependencies in
package.json and then it goes off and
tries to find those and adds them to
your project and last you'll want to
setup your preferred editor or IDE so
that it works with flow and I have a
slide with some details on how to do
that for maybe six different popular
editors so I'm gonna skip ahead here and
get to a summary slide so I think you
need to give some thought to whether
taking the time to specify these types
would really be beneficial in your
project and in my experience it was very
beneficial as soon as I had to start
doing any kind of refactoring that it
was catching all of these problems for
me so whether you use flow or typescript
I think they're both great I highly
recommend that you give at least one of
those a try and start simple just add
types to a few of your files and then
gradually build that up over time and I
think you'll find that your confidence
in working
your code will improve as a result of
that and then one last thing I want to
go over you might be wondering why is it
that I prefer flow over typescript and
here's just a quick checklist of things
that I prefer so the first one is that
flow does a better job of catching
errors before I even add any types to my
code I think that's a really nice thing
flow is really good with this strict
null checking I think it's really
important that that's the default
behavior because that's a big thing that
it catches for me that I didn't account
for the possibility that something might
be null or undefined flow has a more
compact syntax for saying whether
something can be null or undefined I
just put a question mark in front of a
type it's more verbose in typescript
flow uses nominal checking instead of
structural checking for object types
this seems like this could take me a
long time to describe but basically what
it means is that if I have this cat
class and I have this car class those
are totally different things but what if
I said that the only property they have
is that they have a name and then I have
this variable that I said is a cat type
and then I create a car object could I
assign it interestingly in typescript
the answer is yes and why does it think
that's okay because it uses structural
typing and that means that it looked at
the possible properties and it saw that
they both had a name and it said well
those look compatible to me so go ahead
I think that's a wrong decision and so
that's what I really like about flow it
uses nominal or by the names
I like that flow just does the type
checking for me and doesn't try to do
the transpiling because I want to use
Babel and use all the features that
Babel gives me and then that was the
last one oh that the last piece here is
that flow just adds types it doesn't add
new syntax features that it's
anticipating JavaScript might add I
really kind of want to stick to the
JavaScript language and not use things
that won't necessarily become a part of
the Lang
so thank you very much for listening I'd
be glad to take any questions you have
about flow later I'm out of time now but
have lunch with me and we'll discuss it
more</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>