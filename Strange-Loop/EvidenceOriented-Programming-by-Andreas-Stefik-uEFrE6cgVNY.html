<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Evidence-Oriented Programming&quot; by Andreas Stefik | Coder Coacher - Coaching Coders</title><meta content="&quot;Evidence-Oriented Programming&quot; by Andreas Stefik - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Evidence-Oriented Programming&quot; by Andreas Stefik</b></h2><h5 class="post__date">2015-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uEFrE6cgVNY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay my name is andreas tefik I'm a
scholar that works for University of
Nevada Las Vegas I work in the computer
science department I'm an assistant
professor and I'm gonna be talking to
you about a paradigm change in computer
programming languages that various
scholars have called either evidence
oriented programming or evidence based
programming and this started at least
from my story there's a number of
scholars that have had slightly
different stories on this but I'll tell
you just mine because I me and I started
working on this problem around 2006 or
so when I was a PhD student
investigating this idea of different
kinds of people that were learning
computer programming in my case I knew a
number of individuals that were working
in industry that were actually blind
right so they I met a number of people
on the internet that were professional
blind programmers and one of it one
example of one of the people that I know
is named Sina Brahm he's was a White
House champion of change if you've heard
of that program he runs a company called
prime access consulting and he's an
unbelievable programmer I mean just in
every respect but he happens to be blind
right so I was really curious I mean I
was a PhD student I was young and
predominantly stupid so I thought well
that sounds interesting so I wonder how
hard it is like how hard is it to
program Wyant or like how hard is it to
debug like can you debug or like can you
use all those cool editor features that
we sort of take for granted like code
completion and editor hints and
refactoring tools and even those little
block languages like scratchy type stuff
you know can we do all that so I just
started by talking to people I started
investigating by sitting down with the
number of blind programmers typically
over the Internet so not really sitting
down and just asking them questions and
just sort of becoming their friend and
trying to think about these problems and
as is probably not that surprising
programming blind is really hard right
even for pros right this isn't like a
uniquely novice problem it's just that
when you're trying to represent computer
coming through audio it's just damn
difficult right so I thought well okay I
know a couple of blind programmers that
are professionals but what do kids do
like do they have programs for this like
there's somewhere in the ballpark of
like 40 K blind children in the US
something like that do they have any
programs to like learn computer science
because that's a job you could really do
right hypothetically so I started asking
them and I just started looking around
and saying well are there blind children
that want to learn this stuff and it
turned out that there was a lot and we
started having them try just doing
various things like try see see how it
goes how hard is it is it tough or is it
easy and the key observation is that
it's not easy it's not just hard it's
really that's three really hard right
there's even italics on that one so just
be aware it's tough right you can
imagine why by the way at the bottom
here this is one of our programs that we
have to my research lab called epic
program which is was NSF NSF funded for
many years and bla bla bla
this is nowadays about half teachers of
the visually impaired about half just
regular K through 12 schools that
actually use our programming language
technologies which is called quorum by
the way alright but let's get back to
this so programming is hard for a lot of
reasons and as I sort of just sat down
talking to people and trying to figure
this out
some of them jumped out so c-style
syntax believe it or not it's pretty
hard when it's an audio well why is that
because you have to actually physically
say for left paren int I equals 0
semicolon I less than 10 semicolon I
plus plus right paren now how many
people in this room would think that's a
little easy to miss one yeah right
it is debuggers at the time were either
practically or actually worthless by
Pratt by actually worth us I mean it
made no sound and thereby you can't use
a blind by practically worthless what I
really mean is that you could use it
like it might make sound but what it
would say would be so unbelievably
absurd but you can't really use it for
debugging right
so like you might tell you that there's
a line of code and it'll give you an
object code like it'll say you'll hit a
line it'll say 137 and you're like what
and that wouldn't be like a line number
that'd be just be an arbitrary number
for the graphic or something like that
so no real semantic meaning and then
besides that a lot of the features that
many of us take for granted all the
features in a normal development
environment they typically wouldn't
translate to audio so sometimes they'd
have special graphics toolkits that
render on top of things and they weren't
hooked up to screen readers or or
whatever and then on top of that there
was effectively no educational programs
in the United States to actually learn
this stuff which is hard by the way
that's what they gave me my PhD for so
oh wait wait I forgot my joke I'm so
sorry I said being a naive little kitten
maybe I can fix them these problems
hahahahaha sorry but so okay so
understanding seeing audio is hard well
that's cool but I had this nagging
question why does he have the design
that it has like what's the evidence for
it like do we have evidence for the word
for like why is it plus plus like what
is the data on that I was curious so I
started to try to look it up so I just
started reading a lot of papers in
programming language design and there's
lots of proofs I think most of us know
that right we we do prove some
programming language design all the time
and have for many many decades right and
we gather lots of performance data right
like we want to know how fast it is
because that's really important right if
you want to scale if you wanted to
actually work then you do proof some
performance data that's sort of
bread-and-butter programming language
design computer science but I found
something unexpected and that was that
there didn't appear to be any human
factors data on programming language
design these changes were just sort of
created so at this point in the talk I
actually have to take a step backward in
time just a little bit and the reason
for this is I'm gonna ask how many of
you have actually studied experimental
design in college like a handful how
many of you know the history of behind
experimental design yeah like a small a
couple people so usually I like to talk
about this stuff a little bit too
you a sense of context right so let's
jump back in time and let's look at this
paper by this fellow named Ted Kaptchuk
he's a medical researcher that studies
placebo and he wrote a paper a few years
back that influenced me a lot on sort of
the history of medicine why why are
studies designed how they are what's the
evidence for how you gather evidence
right that's a little med I suppose so
believe it or not there's about five
phases according Kaptchuk and he stops
around the 1940s or 50s the first phase
in at least the medical history in some
of those areas was really to detect
fraud right there was a lot of so to
speak snake oil salesman in the late
18th century by the middle of the 19th
century it's there's this sort of weird
quirk of history where the actual
homeopathy were actually doing the best
experiments for the time which is sort
of ironic we'll get to that excuse me
by the late 19th century it turned out
that psychology got involved and they
started doing things like double-blind
so had some randomization stuff like
that but after that pharmacology got
involved and then by around the 1935 or
the 40s or 50s especially we started to
see what has become sort of standard in
effectively all other disciplines except
computer science which is the randomized
controlled trial and even though
captrick actually stops around the 50s
it's not as if other scientific
disciplines said Oh RCT czar the way
that that must be the only thing we can
do in fact other disciplines have gone
substantially forward since the 50s we
now have been rethinking statistical
practices to sort of increase
replication and studies we have standard
replication packets there's this concept
of registered randomized controlled
trials in medicine which became popular
nowadays for corporate fraud actually
amongst other reasons anyway you get the
idea
so let's actually talk about these
phases individually to give you a sense
of the kinds of things people were
fighting against at the time so like
what kinds of science were they doing to
try to do a little bit better in our
knowledge well it turns out that one of
the first things that scientists fought
against in the
late 1700s actually spearheaded by
Benjamin Franklin like that actual guy
on your all the hundred dollar bills in
our pockets right or one dollar bills
I'm a professor come on I'm kidding we
get paid fine and he was actually hired
with the Commission by Lou the 16th to
evaluate this thing called mesmerism how
many people have heard of this so
there's like a million different
versions of it that are all slippery and
tried to be as untestable as possible
but it's basically a sham movement from
the late 1700s that didn't work right
and Benjamin Franklin along with his
crew used this concept of sham
treatments basically they tricked people
into thinking the mesmerist was healing
them they really weren't doing anything
and lo and behold
mesmerism doesn't work but interestingly
even though Franklin had basically
discredited it by the end of the late
1700s it basically persisted in medical
science and textbooks and all that kind
of good stuff for like a century or so
because you know the experiments weren't
good enough right which they actually
weren't but that's irrelevant so by the
mid 1830s or so
by the way homeopathy came around also
in the late 1700s however it didn't
really get tested for around 40 years
right because you know they were busy
and the first time that this was tested
was done by this fellow named Armand
true so who basically had did the first
placebo test at the time they used
something called bread pills to my
understanding it just means bread and a
pill but maybe I'm wrong but I think
that's true and by the late 1800s or by
around that period we started to see
more techniques like double blinding
right now double blinding believe it or
not at the time actually didn't work
very well because blinding doesn't work
very well without randomization which
you'll see in a moment anyway homeopathy
has been thoroughly debunked since
literally 1834 yet it's still funded by
the UK today
ouch if you ever have time
say what
that I cannot disagree with that at all
a fair point
is there okay now psychology started
moving forward in part because they were
investigating things like sensation this
is like if I had two weights and I
wanted to see how much I could sense in
the weight that's like a sensation type
test or perception tests but they were
also investigating sort of frog-like
psychics or talking to the dead or weird
junk like that
right now psychics in this case believe
it or not they actually introduced
randomization approximately this time
think of the idea like I have a deck of
cards and I've grabbed one at random and
I try to psychically project it to you
right which doesn't work
that you know that's randomization of a
form it's not very good randomization
but it's something again guard against
quackery fraud and biases oh you know
what I forgot to say that by the way if
you don't know quackery is like not like
a making fun of term quackery means that
you believe something that's thoroughly
debunked right that's really all it
means fraud means you're telling people
something you know is a lie right all
right my face for we have this sort of
icky story but I'm going to tell you
anyway there's this guy named Charles
and warred brown stick wired which I'm
sure I'm butchering but forgive me and
he actually took guinea pigs and pulled
material out of their testicles and was
injecting it into people right as you do
and interestingly at the time
experimentation was considered like whoa
what do you mean experiment that's BS
and so what many people in the medical
communities wanted was actually case
histories so think about what this means
for a second
they say deploy the testicle material
worldwide and then let's see what
happens right kind of like lambdas in
C++ right
just saying I'm kidding actually there
is no studies of that right there
actually isn't before it was deployed
worldwide just saying obviously it's not
testicle material but interestingly the
best part about pharmacology is by this
time they had seen experiments so the
community very quickly said what the
hell and they started looking up and
figuring out how to do a test so within
like two months of this guy having his
claims they started doing experiments
now their methodology was all wrong they
didn't really know how to do it but they
started experimenting using different
kinds of placebos actually having
control groups and these sort of things
that we sort of take for granted until
we eventually hit phase five which is
actually not modern it's not modern
randomized controlled trials but it'll
give you a sense of the pathway
specifically in 1935 this fellow named
Fisher wrote this really influential
book called the design of experiments
which I imagine you can guess is about
the design of experiments and in this he
really formalized mathematically the
concept of randomization now this was
crucial to the design of experiments
broadly this is not just like an
immaterial mathematical theorem without
this we would not have randomized
controlled trials it's very important
now interestingly at the time many in
the medical communities consider this to
be esoteric right like doctors are okay
with blinding but you know people die if
the treatment doesn't work so they would
cheat a little bit or they would have
these little tactics it's it's not so
much that they were trying to commit
fraud it's just they were worried about
their patients it's legitimate to a
certain degree but the problem is since
you can't get good data good information
you needed some way to guard against it
so eventually even though in 1955 the
Journal of the American Medical
Association wrote treatments should be
kept in the hands of the general
practitioner and not on the basis of
experiments even though that's true by
the 50s eventually medicine formalize
this into what we now know as phased
controlled trials we
are not perfect by any stretch we still
today have corporate fraud and all sorts
of other problems but nonetheless it's
an important step on the evolution in
scientific experiment designing so the
first randomized controlled trial was
actually done by this fellow Austin
Bradford Hill oh by the way he didn't
use the word randomization any study
because he was worried about scaring off
his colleagues it's interesting he was
controversial all right so here's the
key observation scientists over time
have increased their evidence standards
to avoid bias fraud and other issues
settling on randomized controlled trials
as the gold standard when you're
evaluating things involving human beings
right for good reason giving you plenty
of examples about fraud and other issues
but let's get back to programming
languages because this seems like it's
unrelated so here I was I was
investigating programming tools for the
blind I was working with kids I was
talking to professionals and it seemed
like things were hard I was inventing a
whole bunch of tools auditory code
hiders little navigation tools talking
debuggers all sorts of little stuff and
they seemed to help a little bit but see
itself seemed really difficult to hear
and I could not get this nagging
question out of my head why does it have
the design it does and where is the data
where is the data so I started looking
and I recruited a team from all over the
place Germany now Finland there's people
in Chile there's people all over the
United States and what we found was
there was no evidence in fact
systemically since the 70s programming
language designers have systematically
refused to collect it think about that
they have ignored centuries of empirical
study design and simply not collect data
now here's the key observation
historically anecdotes have not been
helpful in evaluating things like
medical science because it's too
complicated it's just the world is a
tricky place and anecdotal evidence is
actually ill suited to a task as complex
as understanding the programming
language Wars
that all of us have to deal with all the
time even if we don't really think about
it much so we created a paradigm called
evidence or any programming and I have
to give credit where credit is due
there was another scholar in Germany
named Stefan Hana Berg who at the same
time that I was working with blind kids
was working on aspect oriented
programming because he couldn't get this
nagging question out of his head what's
the evidence that it's actually
effective and it turns out it's actually
not but he didn't know that yet and so
he came up with the same idea basically
the same time so here's the basic idea
design features of a language must have
corresponding evidence from
appropriately constructed randomized
controlled trials using modern standards
that we know from other scientific
disciplines like psychology medicine and
other places as best as we can there's
actually some systemic problems in
computer science preventing us doing
from some of the most modern especially
registration of control trials however
it's the best you can do given the
culture language authors must allow
external community members to suggest
changes to a programming language API or
whatever using the actual scientific
method right not anecdotes the actual
scientific method as known in other
disciplines and finally evidence from
other techniques software repository
modding educational data or whatever is
fine to influence programming languages
so long as it's rigorous now that's an
important thing because even though
randomized control trials are useful for
some things they are generally smaller
in scale than the things you can do by
looking at like a github repository
analysis because you get lots of data so
it's okay to look at data across
different paradigms and try to
reverse-engineer what will help humans
that's the idea so then my wife and I
who is a compiler writer invented quorum
which I keep hearing online was
crowdfunded but is actually funded by
the National Science Foundation to my
knowledge it's the first and only
programming language to use a scientific
evidence standard for human factors of
course we run tests as much as you do to
to make it work make sure it works but
that's a different issue so let me give
you sort of a short tutorial on the
types of things we do when we evaluate
things like syntax and semantics choices
as opposed to what you're used to in
programming languages for example how
many can look at this phrase here
by show of hands until they
approximately what you think that would
do yeah
so can people with no training because
we've tested it right middle school kids
they know what that does to how
efficient is that and it's just as
efficient doesn't matter right it's just
a phrase now the way we do this is we
usually start out with something like
surveys these are not RCTs but they're
useful because we can often figure out
what kind of words and symbols make
sense so let me sort of show you this if
you look at loops here if you take
non-programmers people with no training
by the way you want to do both because
there's a bias effect and there's this
equation where you can predict it that's
a long story but novices usually tell us
words like repeat makes sense which they
kind of do and ironically if you've
never heard this result before the three
worst choices in every replication of
every study we've ever done have been
for while and for each in that order
and I swear to God I just believe that
results so much I replicated at another
university same result which is funny so
so but the thing is evidence for
improving doesn't mean that you like
through magic have one language to rule
them all right like there are many
contexts of use that people use
programming in and that's reality right
a NASA engineer just isn't the same
thing as a child making a PowerPoint ish
type slide thing in scratch it's just
not the same and in addition evidence
from some of these studies can actually
be very confusing sometimes it's not
clear what the answer is and a really
good example of that is actually the
exception system in quorum which looks
kind of like this specifically whether
exceptions are helpful in a language I
actually haven't found any evidence of
yet but whatever which words imply best
the concepts is a little unclear which
I'll show you some data in a second and
the exact structure of the code we have
a little bit of evidence on but I'm not
very convinced by it it's like a start
so here's an example if you look at some
of these words by the way we don't show
people the words try-catch and stuff
like that there's a scientific
methodology behind how you do surveys
and you can look that up it's not like
it's way too complicated to describe
right now but if you
have non-programmers you get words like
check or test things like that which
kind of sort of makes sense but it's
kind of not also so maybe the
non-programmer just didn't understand
what we're asking the programmers they
seem to sort of understand the concept
they will use words like try but they
don't like them so I don't know what
does that mean well it's hard to say
exactly right but the thing is surveys
can only tell you so much so knowing the
history the next thing we tried with
sham treatments right same thing right
kind of like placebos except you have to
come up with an idea for what a placebo
would be in computer science
this result is kind of well known but
I'll say it anyway our idea that we had
initially for a placebo was to randomly
design programming languages so
literally I had my graduate students sit
around and roll dice laughing her ass
off and then eventually we came up with
a language called random oh right now
yeah it's wonderful it was ridiculous ed
you'll never pass peer-review with
ridiculous just get pissed off at you
which is probably true but I actually
appreciated that comment it's good you
may have it you may have it absolutely I
did not I did not trademark so one of
the things we found right away was in
multiple studies it turns out to be the
case that the programming language
languages Java and Perl for novices are
actually no better than random oh I'm
gonna stop for a moment
now what's interesting is when we first
did these studies we had no idea why
right we just got these effects we're
like what the hell as we stopped
laughing but it turns out we came up
with an idea which ironically I figured
out how to do from designing talking
debuggers for blind kids called token
accuracy mapping and believe it or not
it's a DNA processing technique I went
to your DNA talk and I was thinking of
it the whole time but anyway the idea is
you basically splice what the
programmers put out as this sort of fake
DNA sequence and you can get a map as to
which tokens and symbols cause the
problems right it gives you clues clues
and it looks kind of like this so on the
left here this is some data from our
experiment this is a repeated measures
design it's way past 1935 but
nonetheless it's very well known in the
academic literature you can look it up
easily but here's an example of a token
action about now this is actually quorum
before version 1.7 and what happened was
when we ran our study we found out that
we had messed up so many things on
quorum and we basically found data on
particular tokens like if you have it
then at the end of an else there's only
a 25% chance and our replication that a
novice would type it correct
why who knows but I'm sure as hell
removing the then right and this was
actually was interesting to me because I
assumed at the get-go that natural
language would make sense novices turns
out not true what matters is the
specific word choices that you make and
the specific ordering that they're in
right so if then makes sense to some of
us I think but it actually doesn't make
much sense to novices which is
surprising to me braces and stuff don't
do any better but Ruby did a great job
because it just didn't have tokens for
that stuff so guess what we did we
copied Ruby right oh by the way except
for the equal sign that one it turns out
if you use a double equals instead of a
single equals it causes an Eightfold
increase in their lack of understanding
or accurately whatever you want to call
it right all right so what about other
systems in quorum because we're trying
to build a language based on evidence
knowing full well that there really
isn't a whole lot of studies
that unfortunately we have to write a
lot of them ourself as the literature
catches up right
well what about type systems well this
one's actually more well-known because
in the last three years largely because
of Stefan Hannah Berg who was doing this
kind of stuff as I was playing around
with kids and words now specifically the
data from this show is pretty clear
evidence that static typing actually
does improve your productivity for
people like you right professionals or
people that have a little bit of
experience right but here's the catch if
you're a novice you get a statistically
significant negative impact but it's
pretty small right so maybe you see
where I'm going with this if you're a
novice you get a significantly negative
impact but it's kind of tiny it's not
that big of a deal on the other hand if
you're a pro you've got a significant
bump and it's much bigger so who should
we wait for probably the pros because it
makes a bigger impact so guess what we
did oh by the way if this theory is
correct it implies that sometime in the
novices sort of experience there should
be a drop at some point in the type
system errors if this theory is true
which is a directly testable hypothesis
unlike a lot of the literature right
I'll show you some stuff that just came
out a few months ago which blew my mind
so here's some example of some of the
data from the static versus dynamic test
that we've done this one is it exceeds a
top conference in software engineering
and static tends to do better than
dynamic how you analyze this is use
something called a two factor ANOVA it's
a standard technique again way past 1935
but nonetheless it's well known in the
literature you can look it up it's easy
on the right here is this conference
oops uh although the data looks kind of
messy it's basically the same result
more or less now get this it turns out a
few months ago these fellows in the UK
all tawdry and brown they came up with a
way to analyze out of that you know the
blue jay group have you heard of that
okay not many there's a group over there
and they basically tracked compiler
error for students to gather 37 million
of them right it's a lot of data right
and take a look the green there's a typo
on the slide that should say type there
asked him but this green line here is
type systems notice at month nine we see
a drop it doesn't prove that Theory's
correct but it doesn't disprove it it's
at least plausible but interestingly if
you look at over here on this graph
you'll notice there's this weird spike
around the same time this drove me crazy
for months I could not figure out why
this spike was there I pestered Niels
and he's the professor a hundred times
it turns out it was a bug in his
analysis script so we don't know what
that is it's like a bug that's something
this is a time measurement and some
people didn't ever finish so it has they
need to scale it in a certain way so
we'll see what that shows but anyway
just be aware that's what's going on
there if you read the paper so he
emailed me really apologetically and I
was like it happens do you do so this is
science well it's true ok so let me
break down a actual action it's called
an action because that's what the data
shows in quorum for actions are just
methods or functions that sort of idea
now in quorum there's a whole bunch of
different regions here so if I look at
the method up there get class sorted in
package that has Pascal case right
so why Pascal case and that's because of
David Binkley's paper from 2009 which
showed compared to underscore you get a
teeny teeny tiny increase in
comprehension it's really small but it's
nonzero so we may as well use it for
these word choices like and return
repeat repeat while these come from a
combination of our surveys and token
accuracy map results because we have we
literally have data unlike that word and
from a number of different perspectives
so for example if a novice uses that
word and repeat most of the time the
data shows they get it right about 67
percent of the time as opposed to the
word 4 which is usually around 18 I mean
this is really specific this is not like
we're making this up there's a lot of
data besides that you can see I already
talked about that equal sign there but
one of the interesting parts here is
this text packaged he now text and
string actually both do pretty well in
surveys
word string is just fine text is shorter
so we tend to reduce typing if we have
the choice but nonetheless but
interestingly the question is if we have
this compromise for static and dynamic
typing for novices versus professionals
what is the compromise so in our case
the debt what we think the data tells us
as best as we can today we have to have
the static declarations on the bind
points otherwise all of you folks get a
negative impact by the way in the
studies we videotape people and it turns
out that if you watch people just sit
there and do it when they the time
difference you observe and static versus
dynamic typing they literally jump to
another file and are looking for what
type to pass so I mean like it's pretty
clear from the videotapes that that's
what's happening but if you look at the
inside of functions the inside of
functions the impact for novices is
pretty low and you can use some amount
of type inference to get rid of it we
know this because if you look at static
and dynamically typed language on the
inside of functions you can tell exactly
which regions are problematic so you can
have a little bit of inference but
unfortunately we have no idea how much
inference should be allowed there's a
number of chops ins that you can make
but we don't know what it is yeah oh yes
actually there is the word oh wait for
the inclusion no there is not and I
would love to see a study on that I
would love to see a study on that but I
don't know of one so yes there is for
the word but that's pretty shallow right
okay now a couple other regions I want
to mention if you look at the hash table
mark here it looks like there's some
form of generics now unfortunately every
study we've done on the syntax of
generics has failed we basically don't
have a good design for the actual
syntactic properties of generics however
what we do have is a study by Hannah
Berg showing that it increases
productivity of all of you right the
amount it increases is not that much
it's just a little but it's nonzero and
interestingly if you look at this study
by this fellow named Chris pardon if you
don't know his work he's a totally
awesome scholar he did basically an
analysis of all of github to look at
what types of generic
beep features people actually use and
the answer is not so many right if they
use generics it's usually list string
like literally just list string and then
all the advanced features like question
mark extends or all the stuff they have
in Java they're just not used that much
now that doesn't prove that you
shouldn't have them in a programming
language but nonetheless that they
weren't adopted is an interesting data
point right it's at least something and
then finally this word returns on the
top right there our data here is
actually pretty bad we don't have a good
choice for the word so the only thing
we've been able to think of is to make
return types quote/unquote optional
which just means if you don't see when
the compiler ignores it but if there is
one you're stuck with the word Returns
which novices hate and always get wrong
so the point is evidence-based
programming doesn't mean quorum is this
magic like bastion of goodness it means
that we're actually using data that is
refutable and we're using the best
available evidence to date which is not
that much in the literature
unlike medicine which might have
thousands and thousands of trials right
so what about other systems well you can
look at inheritance
there's only to my knowledge three
studies ever on the topic of inheritance
one is by Walter ticky which is a great
study but somewhat inconclusive as terms
of like like for example we don't really
have a good handle on multiple versus
single versus mixin or any of those kind
of questions to my knowledge it's never
been studied it's kind of important
there are quite a few studies on
compiler errors believe it or not even
professionals are profoundly impacted by
the design of compiler errors Google
actually did a study on this not that
long ago finding that their engineers
just got totally flabbergasted by
certain kinds of errors and if you want
to know which ones you can go read the
paper it's fascinating in terms of
concurrency there's a couple studies now
probably my favorite so far is Chris
Ross Beck's work out of UT Austin
although I think he's at Microsoft now
and they basically compared
transactional memory versus locks and
they found that transaction memory led
to fewer bugs in code now of course
that's easy to say but we all know that
transactional memory has like technical
problems as well depending on your point
of view
so this isn't a panacea right it doesn't
magically tell us which things are good
and bad but it's it's the point is that
we're starting to collect evidence which
never happened before right so from our
list of thousands of papers quorum to my
knowledge takes into account every paper
that exists in the literature so far on
human factors of language design so why
should you care about this so I want to
I want to end with sort of a brief
explanation of why I think not just
novices not just professionals not just
teachers not just businesses why I think
people should care about this problem
notwithstanding the fact that
programming languages make up literally
the entire foundation of our modern
technology right and it hasn't been
studied in depth but I think programmers
should care because there is solid
evidence that these issues impact
productivity right when I program in
languages that make flaws it takes me
off because they could look it up for
some of the things that are known right
so you should know that you should know
that there is research on some of these
things and you should care there are
solid evidence that language designers
are not following historical scientific
norms so if you're on the internet and
someone says this language is better you
should say do you have a randomized
controlled trial as evidence and if they
say what's that then you should say
bye-bye right and I'm I'm completely
serious right in other fields scientists
would not stand for the evidence
standard that they use in computer
science it simply would not pass peer
review ever but in computer science it's
fine why should teachers care well
there's solid evidence of these issues
impact students now some people that
I've talked to you say yeah but I don't
care about students students aren't
professionals and that is true however
sometimes the design decisions that you
make for students can impact may not
have any impact on professionals but
they might like help them and not have
an impact so for example if you all had
to make the ultimate sacrifice and type
repeat ten times I think you'd be fine
you know you'd probably understand it
right it wouldn't be that big of a deal
but for a novice it makes a big
difference
like a really big difference besides
that languages change all the time so
educational institutions and students
actually have to pay money when these
things change
so when C++ 11 comes out they have to
buy a new text box which either the
University or the students have to
handle that's a problem because
education is already exceedingly
expensive and this probably isn't
helping right now why should businesses
care because productivity costs
businesses money and I'll talk about
this a little bit more in a second in
fact the language worse itself may be
costing industry a fortune and we have
no idea how much it costs so here's the
key point as programming languages
change or as you use particular
technologies consider carefully whether
the designers following historical
scientific norms if they're not it may
be costing you or your organization time
or money that is the facts so let's
break it down with the thought
experiment now I don't mean this is some
sort of like serious economic analysis
I'm not an economist and don't pretend
to be however suppose just for the sake
of argument that developers lost one
hour per week just one how many of you
lost one hour per week to something that
made you less productive how many have
lost five Wow how many you've lost ten
how many just don't want to go to work
anymore
okay so I have no idea how to measure
this right I've thought about it but I
don't know how to measure yet but if you
made the assumption that developers lost
one hour of productivity due directly to
language design considerations which I
have no idea how to measure and I admit
and you use the Bureau of Labor
Statistics average for software
developers which is 4488 an hour and you
have ten developers that cost you about
23,000 a year give or take now of course
that doesn't mean you fire people it
might mean you're more productive but
whatever right if you have 10,000
developers which is not even really that
big right you could have a company like
at JPMorgan or other places where that's
totally feasible that would cost you
twenty three million dollars a year it's
a lot of money
and this doesn't even take into account
all the other stuff that goes along with
programming languages as they change as
new toolkits are introduced the language
might change that might have to require
training time it might require that you
go to conferences read new books that
takes time right and that time cost
money right now that doesn't mean that
we have an easy answer to this problem
but the point is well not intended as a
serious economic analysis productivity
issues may be very expensive for
industry so for example in the medical
studies they went to randomized
controlled trials because of death right
because they were literally killing
people right we don't have that problem
we're not gonna like if you have to type
you know a four loop it's not that big
of a deal right especially for pros but
nonetheless the issue we would care
about is how much is it costing us right
and it's probably not cheap
no one knows there is no Studies on it
but probably not cheap all right
so that's what I've got usually then of
these talks there's always a couple
people that want to know if they can
contribute anything and sometimes
running experiments is hard but there
are a whole bunch of things that you can
do to contribute to these projects if
you think it's interesting and if you
don't look okay one is you could help us
flesh out the standard libraries we have
a bunch we have game engines we have
legal bots libraries
we're working on a linear algebra
library we're working on some science
stuff all sorts of things but
nonetheless there is no way in hell that
we could do all the cool stuff that you
can do in many languages without people
like you to say dude guys that library
sucks please let me rewrite it and that
would be okay do a small project in
quorum so a lot of times when you're in
academia you test more with students and
with professionals we do a little bit of
both oh okay we do a little bit of both
but if you try a small project email us
and give us feedback
I need libraries to do this I need these
things and then finally if you really
want to you could come to our conference
it's invitation only but we do let
people apply it's usually relatively
small quorums a JVM language you can
call down to Java C
plus if you want to stuff like that and
there's the website thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>