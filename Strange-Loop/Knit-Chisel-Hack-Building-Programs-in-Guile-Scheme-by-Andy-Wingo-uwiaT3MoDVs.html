<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Knit, Chisel, Hack: Building Programs in Guile Scheme&quot; by Andy Wingo | Coder Coacher - Coaching Coders</title><meta content="&quot;Knit, Chisel, Hack: Building Programs in Guile Scheme&quot; by Andy Wingo - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Knit, Chisel, Hack: Building Programs in Guile Scheme&quot; by Andy Wingo</b></h2><h5 class="post__date">2016-09-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uwiaT3MoDVs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right y'all thanks for coming we get
this train departing on time here I'm
Andy and this to talk about scheme but
it starts out with being a bit of a talk
about craft in a sense and like because
I I was thinking about like think things
that guy'll is like and and there's some
some essence and all of these things
that like woodworking and gardening and
like I find many programmers that
actually have attractions to these
things folks that are you know growing
their own weird stuff and brewing their
own beverages of all sorts that you know
make clothes and make furniture and all
sorts of things and and what is it about
it but about these activities about
these these crafty activities that like
binds them together like is there some
essence that makes some programmers or
some practitioners attracted to these
practices these crafts and and what's
the deal you know so it's like why do I
like crap why am i into all these things
whether it was my basement full of junk
you know that I make this stuff with and
it's really like there's a there's a
pleasure involved in in the production
of any of these things and one of the
pleasures is you know just the process
of making and building stuff also after
a day of being at the computer you know
it's good to make things in the real
world but when you're done with the
thing you have like you know this this
result which was made hopefully with
quality obviously you get better with
time and that that's another side of it
which is like you know even the process
of starting something new started
starting a new things like the best
right because you can only get better at
it right you can start off bad that's
fine you know like as you get better and
better that that you know makes you
makes you feel better and then like the
the result is is made for you for your
use cases for the thing that you that
you were thinking about when you when
you started the project you end up with
with something that's made to fit you
and not made to fit like some some
generic thing and in contrast like I
think there are things which are which
are not crafty and I didn't put any on
the slide because you know you don't
want these things at text but anyway
like if we think about McDonald's for
example right well there there's nothing
really crafty about consuming McDonald's
food right it can form like a
a really valuable like place in society
and like you know can make many positive
functions is food it's not poison but
it's like like there isn't this crafty
nature there and on the production side
which is I think okay so one it is about
producing things more than about
consuming things but on the production
side I mean you can't really get better
at it right like you get to this level
and you're designed to give this level
like really fast and you're designed
like not to really progress in your
production of MacDonald's artifacts
right and so in contrast like a crafty
thing is is something that you can get
better at right it's made on a human
scale in general which is you know why
often we see people doing woodworking
with chisels and hand tools and planes
and whatnot it's it's bespoke it's not
made like in it in a generic way and
I'll it it manages to get both touching
roots in the sense of practices that
survive into now that are historical in
nature like woodworking is a very old
thing but it's not like only looking
towards the past like it looks towards
the future as well and and here I count
like wearables is a wonderful like
fashion craft electronic for looking you
know not so you know bound by tradition
as well like and I think that also has
the crafty nature and so thinking a bit
more about craft I of course you know
looked it up on the internet and okay we
got a bunch of definitions and look like
guile is actually like if you if you
google craft like this is what you get
right so that it's also kind of a crafty
introduction to this talk so yeah I'm
Andy and I echo main ting Kyle and I
have Co maintained guile schemes the
language of meditation since about 2009
or so I've been programming and guile
maybe since 2003 or four or something
like that and and the work that I do on
guile is generally working on its
implementation I use it a lot in for
many things but the thing I enjoy the
craft that I practice is the craft of
language invitation and building
compilers so I read about that on on the
website so y'all check it out later
and this talk has a thesis and the
thesis is that guile is a language which
helps you build programs
which have this crafty spirit both in
the practice and the product and
everything else so craft so start with
quick demo alright we here actually uh
I'll go ahead and start up again you
started here I'm starting from the build
directory maybe I make it smaller so
that it doesn't wrap you know see if I
can pull it off to the side here so
we're not see the whole thing right so
it's just you know go prompt and it
starts off with a standard FSF thing
that says okay whatever right so
language we have numbers which is kind
of cool like we have you know
floating-point numbers we have like
fractions and stuff we have you know
complex numbers and things and this is
already kind of cool because many of us
work in languages where we just have
these limited precision things that wrap
around or don't or cause undefined
behavior or whatever okay
numbers great we have we can give names
to numbers we define X 3 and the same
define can define like a procedure here
we use the famous lambda that everybody
knows about here lambda n so we'll
define oh say it's F right
lambda and plus I don't know and to
something like that right and we have
this standard like smaller syntax we can
just like these two last lines are
exactly the same
might just one sort of a alias for the
other I take an F I get procedure okay
so in scheme as we know we start
procedure applications with a
parenthesis so if I do F of 3 that's
procedure call and then you also have
like the data so you have like a quote
before that's what we get right so
that's that's it right so we're done
right so thank you for my talk so thank
you so the thing is is that what you
need is not just like this small
language so so we're talking about the
arc of the talk goes from small programs
to big programs and the crafty nature
and small and large but what we need is
not just like
you know like here's some would go build
a thing right you need some more than
that you need some tools you need like a
workbench and stuff is to print from the
18th century of a joiners workbench in
France mark Andre ruble and as you can
see these aren't just actually tables if
you look closely they have holes for
putting in pegs to hold wood against to
stick some clamps in so you can clamp
your wood down you've got vices on the
side and so that's what the repple is
actually for us like I can I don't know
let's for example if I get a problem all
right so let's say I'm gonna map F over
the list 1 2 3 4 right ok I get out a
nice nice result what if I like put five
at the end right so I'm not gonna I'm
gonna be like adding 2 to 5 ok I get an
error but it's an error and like a
recursive repple at which point I can do
my back trace I can go to like frame 3 I
can print out my locals and I have no
local variables yeah sorry that's all
the do I have any anyone anywhere else
maybe I have them far zero locals no
locals you very well the optimizers are
often I smell is this a classic gdb
thing I think in the end this is
obviously girls repple here we also have
a number of other tools we have profile
we can profile expressions we can
disassemble our functions we can set
breakpoints we can time things we can
see what the macro expander does we can
see what the optimizer does also one
level the optimizer because we bolted on
another one underneath it's kind of
harder to express in scheme yeah we can
look at back traces as we see and most
importantly there's help which can show
you all the things that you can do so is
it it's like our art workbench for
making small programs and we spend a lot
of time in gaol just at the repple
testing things out building our program
secure mentally as we all do here is
strangely so so the problem is is like
how do you take like a small program or
small thing and you make it bigger but
you you want to preserve this like
crafty nature right like how can we
preserve that that quality as we go
bigger the next step up from like repple
like calculator style interaction I
think of it as scripts and for me a
script well ok so
right yes scripts but first a little
story time all right so this is a
picture of my garden from earlier in
summer so things aren't like is rampant
and big nor are they as dry as they are
now because we've had a drought for last
a little bit and I've just been
gardening for about four years or so and
it's been wonderful because you get
better at it right Mike also like things
different things happen in different
years and you get to eat the product but
one thing I learned with with gardening
is that like as you started to make
Gardens you can't just like make an
undifferentiated thing like they need to
be like rooms outside habitable spaces
for people they need to have structure
in which you and habit the garden as a
person so that you can enjoy it not only
do they produce the thing you want but
they should be nice places to be so the
the structuring bit that we were going
to use to start to go from calculator
style interactions the scripts would be
let's say let's pull in some modules
right so we can pull in like our pattern
matching module that it helps us match
over data structures now we can pull in
some web modules and so here we have
okay after having used the modules we
match our program arguments we fetch
this URL we get back the headers object
and the body and we can display the body
to standard out so we've like done a
little simple web client and for me like
a script is this it's like a few pages
it uses modules we have a number of
modules for lots of sort of standard use
cases standard batteries the POSIX
support and guile is great like I think
that's like where it's it's best knishes
in a way like it is a scheme that fits
very much into POSIX and UNIX and such
we also have you know obviously the web
is the new POSIX in a way right the
standard on which we make our programs
so we have you know the client libraries
the server all your HTTP stuff we can
deal with input and output not only is
in bytes so in that regard
going you know yeah like you can do
character input and output but y'all
encodings right and it's it's not common
as common as it should be right in
addition you know we can talk to you
know standard data formats and libraries
and data and stuff and there's a manual
it's like hundreds and hundreds and
hundreds of pages long it's alright you
know so check it out that we helped like
make make that step so it a script is a
few pages of code uses modules to do its
job that's what I think of as script
anyway when we think of like a program
I think of like I'm going to grow this
to something even bigger so I can't just
have like one page right I need to like
break it into like rooms that I can you
know construct and then arrange together
so that's to me what a program is and
that's the sort of next step maybe of
modules and yeah there's my thesis I
don't actually think anyone knows what a
system is you have to do basic science
on a system to determine like what it's
composed of and how does it perform so
so the to move from scripts to programs
we need to like a bit more rigidity so
we apply a few techniques one is
separate compilation we can compile and
test our different modules separately
and we have tooling that as you evolve
your system with modules as you move
from scripts to programs as you break
into separate parts you're going to need
to evolve those things in different ways
right you're going to need to deprecate
interfaces different people are going to
be managing different parts so we have
excellent keyword argument facilities to
sort of progressively enhance this more
functional procedural interfaces between
modules our compiler warnings are pretty
good we you can determine when you're
calling something with not the right
number of arguments or with a keyword
that's not supported or with variables
that aren't reference it's okay right
and they definitely help and we have
facilities for deprecating interfaces
and saying you should be using this one
instead so they do help you migrate your
and grow your program like keeping a
nice structure but also a continuous
flow from from scripts on over to
programs and yeah so we used to talk a
lot about scripting languages and I I
think it's in that an anachronistic
historical category right it's a
language that doesn't that you can add
strings and numbers and that doesn't
perform well right so that to me is what
is scripting languages and and there
shouldn't there should not be this gap
between like real language and scripting
languages there should just be languages
that can can perform well in their
domain right in their entire domain so
in the future I don't think this is a
category of language that will exist or
they're describing or your language as a
as a scripting language it may we just
don't mean the same things
it's just be a language I think you
program your whole system in and to
bridge the gap again going from small to
large you're going to have performance
requirements right yeah how is your
program going to at some point you're
going to have different metrics you need
like certain memory consumption you need
certain startup time you need certain
throughput and I'm not going to be able
to stick with this language I started
with making these nice interactive
calculator like experiments growing into
scripts and growing into programs isn't
going to be able to actually bridge that
gap and guileless speed is okay right
now I'm not gonna claim like we're you
know beating the entire world but it's
definitely alright and getting better so
I did some testing earlier allocation
right pretty okay almost Giga second and
and actually the speed we you can think
of it mostly it's it's limited by its a
bytecode interpreter still let's talk a
bit more about that later we have a
custom virtual machine and our speed is
generally limited by instruction retire
like that's a very good metric to to
think about like how fast is it going
and we can do you know four or five
hundred million instruction or timers a
second if you start it you saw me start
it starts up pretty good and if you do
if you check out the memory usage and
this is with 64-bit words it's about two
two and a bit megabytes it at the start
so it's okay and one of the tricks we
use to get good memory usage is that we
actually compile our modules to elf
format like the elf format that Linux
shared libraries and programs use and
and we use it not because we want to
interoperate with other tools because
horror why would you ever want to depend
on anyone else's code right so it's more
like elf has made a lot of really good
decisions and thinking about how you
would encode your compiled output into
elf helps make performance systems and
so in particular elf is design such a
way all these horizontal lines are a
page a four kilobyte page and the the
biggest bit is the program text being
the bytecode and in follow that is a
read-only data any other big section is
the gray bit which has some metadata
that needs to be reading to at lunch run
time so only like some of this will be
actually a per process overhead the rest
will be shared
between all your processes with no
additional overhead and then at the end
we have actual dwarf debugging
information so when we need to determine
what function is this instruction in we
do the dwarf lookup and in the side
table and we don't need to do this
normally obviously but still it's pretty
fast so we're able to like you know keep
our good debugging but our memory
consumption down right but Andy you know
why what this instruction retire rate
this is trash why are you telling me
about this thing that makes no no
meaning you know how do I actually you
know what what is it what is the
performance really Andy it's hard to
answer right so I work on compilers for
living and so so I have a license to
micro benchmark because I didn't even
know what you're testing right so I just
need to test like I've looked at the the
decompiled I've looked at the assembly
for c4 for this loop up to a billion
case I've looked at the assembly for
scheme and I just want to test like how
fast can I loop up to a billion right
it's not a real-world test but it does
give you a lower limit on some some
compilation right like like how fast can
you imagine yourself going on a general
order of magnitude scale on the Python
side I I think this does the right thing
but I'm not as good in Python as I used
to be so I'm not going to you can throw
out my numbers for Python if you like so
it says Python 3 so per iteration I did
a measure on this about a month ago or
so I mean and I in Python 3 about 80
cycles guy'll to a little bit faster by
the same order so for for some early
compiler hackings it was okay
we have gal - - coming out very soon
that actually released the latest
pre-release - dot one dot for last week
doing much better I think the recent
compiler and virtual machine work is
success in that regard and then itÃ­s
sitting as GCC okay so GCC - OCR
produces trash like bad assembly and and
it ends up in in this you know five
point six cycles per iteration just it
just increment number if you do - oh one
you get the the increment and jump loop
that you expect and if you ever do like
serious performance work you're gonna be
measuring instructions per cycle and if
you get before then
ask for bonus right because you're doing
your job right
so GCO one does produce the optimal code
pretty much about 0.8 cycles per
iteration so it means we're off by about
a factor of 15 from sort of PTH speed V
co2 of course this loop it doesn't do
anything so it optimizes it out so we
will catch up on C I'm gonna say we're
gonna like beat it or anything right
because there are so many considerations
here but when we start we have a decent
compiler now so we're gonna do a decent
ahead of time job and I met native code
and that will come in I don't know a
couple years or something
so that's like where it's going but
there are some places that you know
we're not gonna really catch up on C
right like we're just gonna leave some
of these features behind okay so right
it's got a bit a bit bigger in a way so
right now it's very classic you know how
do you build small programs that run
fast
what is it web scale you know I could
scale out so what we do have for
horizontal scalability is not only the
POSIX normal for King Zurich and all
that we have POSIX threads as well they
work pretty well
we have no Gil it's it's hard to
recommend it because we don't have a
right now baked in nice concurrency
reliable concurrency support but that's
a new thing so I'm gonna not answer this
question right now because I'm going to
defer it and then make a bit of drama
right so I'm gonna answer two unrelated
questions in the mean times so tools we
have to take your program like to help
it scale up so the first one is macros I
don't have to talk very much about this
because this is strange loop the second
one is prompts and I think maybe not
most folks have worked with these these
are also known as is delimited
continuation so if any of you I'll
program in the system with limit
continuations all the racketeers are
raising your hands aren't saying it like
it with hands down if it's not in racket
like doing a continuation somewhere else
anybody know okay right okay it's good
to know there's about a third of the
room for the video that's something like
a you racketeers yeah so
macros I just touch on it I say they let
you cut your program to fit your problem
right that's that's the general thing I
know you know all the patterns and how
they work but that's that's the crafty
nature of macros that they produce a
bespoke thing that fits you that allows
you to creatively concisely express
yourself in a way that it's pleasing
right okay that's macros not to talk
more about that but I am gonna spend
some more time on prompts okay so every
program is an operating system to
another program almost right like there
are very few programs that are really on
the on the leaf of this graph and and
when you run your program at the command
line here I have sort of tcsh % there as
a in a reason I'll explain in a minute
you have like the left side which is the
operating system in effect the shell and
you have the right side which is the
program you're running which is sort of
user space process and the fact that the
left side is actually another user space
process is not really relevant right the
fact that only the kernel can make the
operating system boundary that we think
of it that way is it is again a
historical accident like it's just
programs that contain programs that run
programs that provide different levels
of isolation and abstraction for sub
computations so what-what guy'll has in
what racket has also are prompts which
are delimited continuations there same
thing and and the continuation is
delimited by the prompt right because
when you when you run program it doesn't
really reference its parent it only
references that in like some bookkeeping
sense but it doesn't include in its
address space where it was called from
there's been like a division which is
made in this case by the fork and exec
ve call between the outside and the
inside so you have system and you have
user and you see this in a smaller scale
in many other programming languages like
even try-catch in a way is a is a
delimit of continuations you have the
thing that you're that you're trying
that you know that something's going to
raise an exception and you have the
system code which is all the non
metallic stuff here which
which handles the exception you're
making a barrier between two parts of
the program in a kind of dynamic way
so prompts provide this facility in a
language in a very generic way and the
three things that I see prompts as doing
like the three facilities which they
offer to me are early exit
they offer a co routine like facility
and they offer non determinism I'm not
gonna talk about this last one but I'm
gonna give a couple examples of the
first two so here is making a prompt
right we're going to include the module
which has a bunch of this prompt related
stuff it's called ice nine control and
the prompt looks like the prompts it's
really really a pun on tcsh right and as
this was introduced by 20s Lysander I
sit around all these folks back in the
eighties and nineties and this is the
way that I like to understand it there
are a number of formulations shift and
reset and various things but but this is
this is the way that makes me understand
it so I hope that I'm able to convey my
understanding to y'all so there are two
parts there is the thing that we're
putting inside the villany continuation
and there's a handler so the expert is
inside then the second thing the handler
is outside in this case the handler will
receive this K argument that I'll talk
about in a minute and then all the other
arguments and it's going to return false
okay so actually that % it's not the
primitive our primitive is call with
prompt Mike racket right and and that
percent macro is a macro that expands
out to this so you're welcome right so
each prompt is identified by a tag it
like identifying that location that
delimit between user and system and then
we include the body which is actually a
thunk which is actually inside a lambda
and then the handler is there as it was
before
so tag body escape handler so to use
prompts in an early exit way we abort to
the prompt so you establish your prompt
with your call with prompts and then
this abort to prompt call is going to
abort to the prompt name tag with the
value 42 so 42 is going to be the one
which is passed as
early return value and then we return so
there's this plus three bit like it
never really happens right we abort the
the computation at that point and we
return from the handler no because we
returned the 42 yeah everybody misses
stuff but this is a very common pattern
to be able to early to return something
early so let's put it in a module right
let's start to you know separate our
things and build them up we're gonna
make our module and we're gonna export
this macro called with return so with
return is going to take an identifier
return and then its contain contains
some body expressions and in there we're
going to make a tag and we run the body
and then the return returns the values
but then the neat thing is this this
return is in scope of the body and it's
a function that when you call it it will
return those values so you can say with
return return plus 3 return 42 which is
I think a much nicer way of saying this
and since it's a function you can
actually map it over anything pass it to
inside things so you can return from
that function frame from many nested
call frames which is kind of cool and
what it returns depends on the order in
which map goes over 1 2 or 3 it's going
to return probably 1 or 3 but it depends
on which way map is going to which one
it's going to map first in this case is
gonna be 1 but I just know that because
I wrote map you know
so what about this Kate argument that
that's kind of an interesting thing
early return means you don't need to
actually come back in but that K is what
happens is when you abort the remaining
part of that continuation between the
prompt and the abort place is bundled up
into a function and that function is the
dilemma and continuation phase passed as
K and that's like the meaning of the
rest of the program until the prompt
right so it's delimited by the prompt so
for example all right we have a our
function f we make our tag we call with
mom tag in our body is plus 3 we abort
to prompt and in this case we're going
to abort with no extra values and so the
continuation that we returned is that
continuation it's plus 3 box right plus
3 something like it's literally the same
like those things are literally the same
there's lambda X plus 3 X and this
continuation which we return here those
are they're the same right and so if I
if I bind that k 2f + 3 + 1 is 4 + 3 + 2
is 5 and so right when I do limit
configuration suspense and this is
something that took me a while to
understand the first argument of the
handler is a function that can resume
the continuation and I don't know like
ruby has call/cc sometimes schemers
talked about call with current
continuation I guess many of you all
have heard about this thing that scheme
has always had continuations and we're
better than you and back yeah so it's
trash right because this is operator
this delimited continuation operator is
so much better and call CC is not a
function
there are continuations which you get
when you in delivering continuations and
call it prompt you can call them and
they return the configurations you get
in schemes call CC you call them it
doesn't return right you just like jump
off into the ether it's not composable
at all so for that reason these
continuations are sometimes called
composable continuations right so what
can't do with them well as you can see
you can suspend a conversation and come
back that's exactly what you need for
modern evented IO servers of all kinds
so what we have been building recent
and just I don't know why we did it so
late to be honest actually I do no
reason but we have lightweight fibers
now so in addition to kernel threads we
have lightweight fibers which are
userspace threads built as a library
entirely as a library not baked into the
core of guy'll at all which are threads
which suspend when they would block and
it would there are three ways right now
that they could block one would be
asleep obviously another would be maybe
they want to read some bytes from a port
or write some bytes out to a port and
that's the reason why I didn't happen
until now because in order to be able to
suspend and you have to everything in
between has to be in scheme you can't
like trampoline through C and come back
because then you're saving like a C
stack frame and and you can't put that
back on the stack right so if you had
write to a port with bytes or read and
you can't do it then it suspends adds
that file descriptor to an e pole set
and when the file descriptor becomes
readable again then you resume the
thread so that means the state for a
fiber is small it's like a handful of
words it's really wonderful you can have
like you know man many many many many
obese we additionally have channels but
its new so we're kind of it's kinda like
baby's first concurrency in a way I feel
real dumb when I'm working with this
stuff is like is this gonna work is this
gonna work it's it's nice to be able to
experiment it with a very low level of
commitment because it's a library like
we can make mistakes but since our core
primitives the callers prompt stuff has
been around for 20 years it's gonna work
ok right so if this library doesn't work
out then something else will work fine
the cool thing about this is like in
JavaScript for example you need to add
asynchronous something to this well
you're gonna have to break into
callbacks or break into promises or
transfer all your functions from being
of type T to promise to type T or async
this or that it works transparently we
have the web server which we wrote and
scheme in a very normal imperative way
but composing that with the prompts
facility means that now we can actually
instead of serving one request at a time
we can spawn off a little fiber for
every different client and and we're no
longer like vulnerable to that slowloris
attack or somebody like feeds you byte
by byte by byte so it's pretty cool
hey we really enjoyed so yeah here's an
example of a a simple client-server but
yellow ball scene you know this bond
pattern in Erlang and go and wonderful
thing which is like tulip and everything
else so I assume this is very normal for
y'all
although if you show something like this
at a JavaScript conference it doesn't
really work though because they're
everywhere are the callbacks and you
might call backs for speed okay right so
uh are we when I'm scale I don't know so
I wrote some simple programs and a
little ping would get maybe 50,000 you
know back some force per second per core
and a little HTTP server including
parsing all the headers the proper
scheme datatypes you're not doing with
byte strings or anything like that
there's about 10,000 requests a second
per quart which is okay you know it's
probably not the bottleneck in your
program so flight suits and victory
right something like that so we're doing
okay right so work in progress lot stuff
to be done experimentation it's it's an
active area of development and we'll see
yeah so this is one place you can check
it out there are two or three other
folks prototyping libraries like this
since it's done also as a library you
can have different event models like
integrating with UI event loops like GDK
event loop or something like that as
well okay I'm finally I'm enjoying a
little time so as we scale even more
like web scale maybe we need like
orchestrate right orchestrate it's a big
word so we have a really cool thing now
and it's it's wonderful it's driving a
lot of folks to God which is great I
like anything that's driving folks to go
or attracting you're driving which which
way is the positive way anyway yeah so
there's this project called geeks and
geeks is like NYX if anyone has heard of
NYX it's a declarative system for
declaring what a package is and how to
build it and if anything changes it will
end up rebuilding things so so geeks is
like NYX except instead of being the NYX
language on top of pearl and shell and
Ock and all these things that are
embedded in in the NYX language to build
packages everything's in guile
actually the whole thing and there's
4000 4500 package
is now super huge velocity I think I
know for the project right now and and
so this is how I am going to be
declaring and installations making
virtual machines making containers and
everything in the future and then it
solves one problem which is how do you
build a docker image right it's like you
don't start with the base image and then
modify it mutate it with something like
Geeks you can actually declare like what
are like the different components and
then build them up constructively
instead of from unknown maybe not
reproducible base and then mutate things
so it's a pretty rad new development and
I definitely suggest it focused check it
out okay so a little bit early because I
speak pretty fast but the website has
been redone recently I don't know if you
all have seen the lovely new website
it's very nice so go and check it out we
have IRC channel which would be very
happy to see you all in and when you
make a thing and make a thing share what
you make you know come on like let us
know what's going on so since we're a
little early if anybody's got questions
about what's going on hit me up what's
up yeah
oh so there's this stuff the world
pauses what happens is well okay so the
we use the bomb collector it's a little
shameful but but it works real well all
right so we have thread-local free lists
the allocation rate as you see is fine
you can turn on an incremental node the
mark phase is in parallel to stop the
threads it sends a signal all right so
it you can inhibit that in some ways but
but yeah tends to work yeah this is good
bad short answer yeah anything else so I
have not yet program gonna make things
in gal gadot is its narrative causality
right it started with a story and then
the software was generated by the story
right so in glue you have like projects
which are served loosely coupled in a
very technical way but like more copy
coupled in a narrative way and I
narrative way somehow infected the mind
of make maintainer we decided to add
guile extensibility and in and make so
you there's like a little keyword that
you can run like dollar open-paren guile
I think to run guile code inside make
how it works
I don't know
well like Kiselyov maybe okay make is a
functional language something like that
yeah yeah so the question I owe this or
not repeating questions before the
question was about guilin and scheme
shell and could guile move up a level
could it be an ice shell so we have a
lot of facilities which are directly
modeled from scheme shell facilities and
even some stale references in the manual
too like if you're familiar with scheme
shell this is like that which nobody's
familiar steam shell so I don't know why
they're there it's an old project we
have lots of little historical things as
the question is is guy like good shell I
think it's a great shelf or gal like for
for gal programs but is it a good shell
for processes and stuff you can make a
language but I think it's hard I have a
I have a hard problem with parentheses
on the command line I don't know if
that's heresy for God maintainer you say
that so I don't know if it would work
very well I I suspect that some other
language might be more more appropriate
but I don't know yeah definitely give it
a try though you know report back
sure what you make yeah all right on
excuse me dinner
yeah so the question is like do we have
access to like dangerous project posix
and the answer is generally yes so you
can change buffering on follow
scriptures and such you can use those
same interfaces on ports which are have
their own user space buffer like C
standard IO ports and more or less does
the right thing in the sense of like
sometimes you you want to use that same
interface both on a buffered schema
object and on a file descriptor file
descriptors are incredibly dangerous
like in a scheme program right we
recently added something file descriptor
final Heiser's it'll be called before
guile closes a file descriptor I I was
surprised that what wasn't added before
but like obviously with multi-threading
is an issue yeah so we have dangerous
scheme if you need to provide like a
safe subset to for users in some context
then you need to like construct that
environment out of only safe things but
I think most most production languages
have that problem in the sense that like
always you can use FFI unsafe or
whatever yeah so there's something yes
yeah so I do I have internet here
actually so there's some inert if you
search for ich raven ECR avian there's
someone who did a bunch of benchmarks
over a bunch of screens if you search
for his are seven arts benchmarks which
is a subset of scheme the question was
is gal slow right so gah was slow and
the weird thing is we had convinced
ourselves that we it was so fast you
know
so but when I started with guile it was
of course with the modular synthesizer
project as many of you like starting
with your programs do he's like I'm
going to make this modular synthesizer
I'm gonna make it in really nice
language I'm gonna make it with scheme
with flexibility and C for speed which
was so dumb right because like languages
don't have speed limitations which has
speed if I if I did over again I
probably would have started with a more
proper scheme and some like this guy was
maybe less proper at that point so in
one that six one eight eight days there
was just an interpreter in to zero sort
of basic compiler and to to the compiler
is now quite nice we beat all other
interpreted schemes more or less like
all of them well more or less right so
not gonna say every scheme is beautiful
right
but we're beat sometimes we beat schemes
that compile to see like chicken but
only on some benchmarks generally the
schemes that have a JIT or do native
compilation b-cup so I am hoping my
compiler is alright now
so I'm hoping they're like once we start
to lower things down to assembly
skipping the C step entirely that we're
going to be up at the top but that's
hubris also so I it's not science at all
yeah yeah thank you all for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>