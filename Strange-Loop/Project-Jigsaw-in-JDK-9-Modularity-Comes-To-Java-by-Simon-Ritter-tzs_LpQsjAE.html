<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Project Jigsaw in JDK 9: Modularity Comes To Java&quot; by Simon Ritter | Coder Coacher - Coaching Coders</title><meta content="&quot;Project Jigsaw in JDK 9: Modularity Comes To Java&quot; by Simon Ritter - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Project Jigsaw in JDK 9: Modularity Comes To Java&quot; by Simon Ritter</b></h2><h5 class="post__date">2016-09-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tzs_LpQsjAE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">what I'm going to talk about this
morning and I've got like 40 minutes so
hopefully I can get as much information
into this session as possible is about
modularity in JDK 9 now there's been
let's not sure yet since I don't know if
you've seen that there been a couple of
announcements this week one of which was
that JDK 9 originally was intended for
launch in I think March of this year and
they didn't quite make that date so then
it was gonna be September of this year
which they haven't quite made so then
they pushed it back to March of next
year and they've decided that they can't
quite make that either so now it's going
to be July of next year
so more time to get it right which is is
good I think because this is very
important anyway so we'll talk about
modularity on what this means in terms
of JDK 9 now the first thing we have to
talk about before we get into the actual
modularity side of things is some of the
details around what's happening from the
API point of view and how structural
changes are being made to what you use
in Java so the first thing is
understanding that in Java there are
lots of api's and they are classified in
two ways there are public API is the API
is that you are allowed to use and
encouraged to use and these fall into a
number of different packages so there's
the ones we're familiar with there's
java dot star there's java X dot star
these are the ones that are defined
through the Java SE specification
through the JCP through the jsr but
there's also some other api's included
in the jdk in the Artic java file which
are public api so you are encouraged to
use them things like Kong Sun star and
there's things like HTTP server that's
available through that which you can use
there's also Sun in JDK dot star which
is if you want to use things like the
compiler programmatically rather than
for a command line you can do it through
that but then there's a whole group of
other api's
the reason that these are a pee eyes are
there is because we have our tea jar it
includes all of the api's all of the
classes that make up father but in order
to have those classes there are a group
of classes which really are sort of
support classes ones that make those
classes work and these fall into the
sun.star package the most famous or
infamous of these is son miss a
f--- now I personally really like some
misc unsafe because there's a clue in
the name unsafe don't use it that's the
idea but lots of people have so we'll
see how that makes a difference in a
moment now one of the things with Java
is that son and then Oracle have been
always very concerned about maintaining
backwards compatibility and aside from a
few sort of minor things where backwards
compatibility has been broken overall
very good in terms of compatibility JDK
9 will introduce a few changes which
could potentially break your code but if
you're a good programmer and you haven't
used private API is in your code then
chances are you won't really be hit by
these things so these are the things
that will change one is that the
internal API is these private API is
many of them will be encapsulated they
were encapsulated so that you can't use
them anymore well kind of discuss that
in a bit more detail in a moment a small
number of api's will actually be removed
go way back to jdk 1.1 and the
deprecated tag was introduced for Java
Doc's JDK 5 we had the introduction of
the deprecated annotation so we could
mark what api's were intended to be
removed at some point in the future all
well and good in JDK 8 how many of the
api's that have been marked as
deprecated do you think of ever been
removed zero that's right absolutely
nothing have been wrote JDK 9 six
methods have been selected for removal
now you think yourself well six what
have these six done so bad that they
need to be removed
and again we will come back to that I
will show you why we need to remove
these six later on
the structure of the JDK itself will be
changing its binary structure
it's just flattening out the directory
structure so you don't have a separate
JRE directory you don't have to bin
directories you don't have to live
directories and tidying things like that
up there is a new version string format
and both this and the reworking of the
structure of the JDK may impact your
application if you rely on either the
position of files in the JDK or on the
format of the string to do something in
your application code most people
probably won't be troubled by that and
then there's this very small thing that
a single underscore is no longer going
to be valid as an identifier in Java so
hands up who has used a single
underscore as a variable name at some
point okay a few people no no don't
laugh don't mock no no there is a very
good reason now I'm hoping that when I
explain this that this is the reason
that you people have done this because I
thought as well that you know this is
not a good idea and then somebody
pointed out to me that actually there's
a very good place where having a single
underscores variable name actually works
if you have a lambda expression and you
have a single variable which you don't
use in the body of the lambda expression
using a single underscore as the
variable name you're not in good is a
very good example of where to using that
underscore as variable name but you
can't do that anymore when JDK 9 a
couple of other things have been removed
really because of the fact that we're
introducing the module system is the
endorsed endorsed standard API override
mechanism and the extension mechanism
these are both things that are primarily
used by people like application server
providers where they want to load a
group of classes before you actually
start running your code the reason for
this is that the way that the class load
is is it being used in Java changed a
bit with modularity unfortunate I'm not
gonna have time to talk about that in
detail but this is just a consequence of
that so when it comes to the internal
APIs we can further subdivide these
so we've got public and private API is
we've also got the idea of splitting the
private API into two groups there's
what's called non critical where we've
got a set of api's which are really no
use outside of the JDK there so kind of
specific to the JDK that actually needs
to use them outside of it and then
there's a group where they're really
just used for convenience because there
isn't a public API available good
example that was prior to JDK 8 there
was no you you decode or you encode API
public and so a lot of people use the
internal API because it was just easier
to do it that way
critical api's are ones where the
functionality provided by those api's
will be either extremely difficult or
just downright impossible to replicate
outside of the JDK some miss code safe
is a very good example of that because
it kind of delves down into memory and
with Java you can't write that API
unless you're in the JDK originally for
JDK 9 the plan was to just take all of
these api's and encapsulate them so you
would no longer have access to any of
the private API inside of the JDK a lot
of people go upset by that idea and they
said well hang on we know we're not
supposed to have used these api's but we
have if you take them away from us it's
going to break our code and we're not
gonna find any easy way of solving the
problems of fixing these api's so Oracle
decided that they wouldn't quite go as
far as that and they would come to us at
a compromise the compromise is JEP 260
JDK enhancement proposal 260 what that
says is going to happen in JDK 9 is that
all the non-critical JDK internal API
will be encapsulated so these are the
ones we just don't really care about
then they're going capsulate all the
critical api is for which there is a
publicly available alternative ok you're
going to have to change your code if you
use those api's but there is a way of
doing it so you can migrate to JDK 9 in
a reasonable kind of way what they're
not going to
do is encapsulate all of the other ones
so all of the critical API is which are
being used by people like some miss gun
safe these will be deprecated so you're
being warned that in a future release
JDK 10 maybe later they will go away but
the idea again is to provide a public
API supported API that will allow you to
replace those things and be able to
maintain your code in that way if you
want to know what your code is doing
there is a nice little tool called Jade
Jade EPS Jade EPS will run on a jar file
it will look at all the api's that are
being used and give you a report of what
packages you're using that way you can
look at your code and you can go up yep
I haven't used any internal API so I'm
good with this code always a very good
idea to run this not just on your code
but any jar files that you got from
somebody else because even though you
may not use these API is somebody else
might have done so you can find out
exactly what's going on and you can see
whether you need to make any changes in
terms of your coke so having talked
about that let's start looking at the
module system as defined by jigsaw so
the first thing is what were the goals
for project jigsaw and really the
primary goal is to make Java SE more
scalable and more flexible if you go
back to the beginning of java jdk 1.0
quick chef hands anybody used jdk runs
at zero okay reason number there were
about 200 classes in the standard class
library and I remember when I started
using Java that I'm thinking to myself
this is good you know 200 classes I can
keep those all in my head so I can
actually remember all of the classes
time goes on and we get to JDK 8 and
there's a bit over 4,000 classes in the
standard class libraries now clearly you
know for myself I can't keep 4,000
classes in my head so I do refer to the
documentation a lot but that's a good
thing because it means you know we don't
have to write a list class we don't have
to write a sequel statement class we
don't have to write
an XML parser class they're all there
for us so we have a rich set of
functionality but there's lots of api's
which we don't need in our application
because you know with 4,000 classes
there is no application I could possibly
think of that would use all 4,000 at the
same time you know I mean we've got
corba there so you know enough said now
in terms of what we want to do here is
break it up into manageable chunks so
you can say my application needs this
bit of functionality needs that bit of
functionality and then bring it together
and create a smaller deployable instance
of Java this is very useful in terms of
things like IOT embedded applications
and you're trying to target something
with reduced resources less memory less
processor power but it's also applicable
if you're dealing with enterprise
applications where you going into like
micro services because you might want to
have a smaller runtime for your micro
service so you can deploy it in a way
that doesn't use as much resources and
just works better in that kind of way
there's other goals in terms of things
like security the less ap is that people
have access to through your application
the smaller the attack surface
for potential exploits and breaking into
your application maintainability
performance you know performances is
sort of a bit of a debatable one in
terms of how long it takes to load up
things at the startup time how long it
takes to search down the module par for
the class path and so on but it's all
about simplifying things so simplifying
construction deployment maintenance of
large-scale applications and really
trying to get away from class path hell
so we'll see how we get to do that in a
moment
now fundamentals of modules what is a
module well a module is just a grouping
of code now if you think about it in
Java we already have ways of doing that
so you have classes which group together
methods and state variables and then you
have packages which group the other
classes which are you know part of the
same kind of thing so you can group them
together in packages module is just the
next level up so it's grouping together
packages so you've got a set of
functionality available in a single
module but unlike a package where you're
restricted to just Java classes a module
can contain other things as well if
you're doing something like native code
if you've got J&amp;amp;I then you can include
native libraries if you need resource
files for translating messages you can
put those in the module as well if you
need property files and configuration
data
those can be put in the modular as well
and what I've done here is I've just
created a simple module where I gather
together two packages both of which
you've got two classes and I've called
it comm da soup okay so that's what I
want to be my module I wrote two
packages how do I make it into a module
well what you need to do is you need to
define your module and the way you do
that is you create a module info Java
file module info dot Java file in its
simplest form is simply the name of the
module so you say module and then its
name and then a set of empty braces now
that in itself is pretty useless module
as we'll see in a moment because it
doesn't really do anything the other
thing to note about this is that people
will immediately go oh hang on you've
got module there is that going to become
a reserved word in Java does that mean I
can't use module as a variable name and
the answer is well yes and no it is
becoming a reserved word but it's a
restricted
reserved word which means it's only a
reserved word if you use it in the
module definition for other Java code
you don't need to worry about it
becoming a reserved word so you create
your module info Java file you put it
into the module with your compiled
classes or you with your code and then
you compile it and you generate a module
from that now the important thing is
that module is often used code which
comes from another module so you have a
dependency between one module and
another we need a way of defining that
in our module definition so within the
braces we can now say that this
particular module requires another one
our module called Zoop requires another
module called Zeta so it's going to
access packages classes and so on in
patan module theta we call so then to
take that to the next level and we'll
say okay we'll create an app we'll have
our app which is going to require commas
all Zoop and it's going to require one
of the standard Java class library
modules which is Java SQL you know I'll
come back to how that's been broken up
in a little bit later but for now we've
got a job in our SQL module what we can
do from that is we can create a module
dependency graph module dependency graph
allows the compiler and the virtual
machine to understand what modules are
required by each module so that it knows
all the things that need to be loaded
and the visibility that's required
between these things so as we can see
here we've got our app and that depends
on zoop zoop we know depends on Zita and
our app also depends on Java s queue up
at the bottom we've got Java dot base
and this is the sort of base module
which all other modules depend on and
it's an implicit dependency which means
you don't have to state it in your
module in folk Java file you can if you
want but you don't have to it will just
be there by default because we know Java
SQL also depends on some things we can
see that XML and logging are
dependencies on that so we get our
complete graph the important thing about
this is that it has to be an acyclic
graph we can't have any loops in that
graph so each module can only depend on
one or on the the dependencies between
modules must go only one way then we get
into the idea of readability versus
dependency so if we look at part of our
scene part of our graph here what we see
is that we've got our app depends on SQL
SQL depends on logging okay we might
have a piece of code like this where we
say okay we get our JDBC driver and then
from that driver we can get a reference
to a logger and then we log a message
okay that's pretty soon
pretty straightforward the problem is
that app has a dependency on SQL so it
can use the driver without any problem
but it doesn't have a dependency on
logging so it doesn't have visibility of
the logger class how do we solve this
well we could solve it explicitly we
could say that okay in your app you know
you're going to use logger from the
driver so you have to explicitly say I
have a dependency on Javadoc logging but
that's not a very good way of doing it
because it it's down to the application
developer to remember to put that
dependency in every time so to get
around that we use what's called implied
readability
there's modifier that we can add so when
we say that Java dot SQL requires
logging we add the public modifier what
that will do is it will provide implied
readability to any module that depends
on this one so that the module app that
depends on SQL will also have access
access to any of the exported publicly
available packages within the logging
direct no logging module so that way it
solves a problem and so you can compile
your code the compiler sees that the
relevant relationship it can resolve the
modules it can resolve the packages and
so on this then leads to an extension of
our graph from just having our
dependency graph to having the implied
readability graph and we can see that
now because we know SQL depends on XML
and depends on logging and these need to
have implied readability to anyone that
uses SQL we see that there's now edges
in our graph to show the implied
readability between app and XML and
logging so that's readability but then
we also have the flip side of this which
is visibility now I said that the the
first example where I just created a
module with no information in it and
just a name wasn't very much use and the
reason for that is it doesn't export any
packages
so there's nothing actually being made
available from that module in order for
somebody to use something from your
module you have to tell the module
system which packages you want made
available so you explicitly have to
state exports for all the modules that
you want so here in our soup module we
say that it requires Zita and then it
exports alpha and it exports beta and we
can qualify that by saying that in the
case of beta we only want it visible to
a certain other module so in this case
we're going to say that it's only
visible to the app module if somebody
else came along and used this module
they wouldn't have access to the
packages in beta because it wasn't being
exported to those modules it's only app
that can access it in the case of alpha
it doesn't have a qualifier so own so
anything in alpha can be used by
anything that has a dependency on the
zoo package now this is where things
start to get sort of more interesting
because one of the things that you you
have to do is you have to say explicitly
which packages you want to export and
you could have a lot of packages so you
think just off okay so I've got to put
an export line for every package yes you
do now there's a big discussion about
this because you know there's this magic
in computer science called a wild card
and so you think should stuff well okay
why not I just have a wild card and I
can just add all the packages in this
particular thing no can't do that
because they don't like wild cards and
they say that there's there's reasons
for not doing this so you can't use a
wild card you have to explicitly state
each one on a separate line now what
this leads to is the idea of
accessibility so accessibility now is
the way that we determine whether we can
actually use a package from another
module this is a sort of two way thing
that needs to be defined so firstly in
order for this this package to be
visible you have to have it exported by
the containing module
that module I'll have to do it
implicitly to all modules or it has to
explicitly to the module that you're
using so you either just leave it as
exports that particular package or you
have to say to the one that you want it
to and then the other flip side of that
is that the module that you you're
defining has to specify a requirement on
that module so have to be exported and
you have to define that dependency once
you've got both of those then you have
visibility of that package and again
there's a little sort of side point on
this a lot of people who sort of start
thinking okay well how does that work
with reflection because obviously a
reflection allows you to to bypass some
of the standard sort of restrictions
that you have in Java code and the
answer is that this encapsulation is
hard encapsulation so you cannot bypass
it with reflection you simply can't get
around this with a reflection and so
this is something that's actually come
up this week because a lot of people
were saying well you know we liked
reflection and for certain situations we
need a way of being able to use
reflection to get at things you know in
in particular way so the proposal
earlier this week was that there's going
to be a new modifier in terms of the
module so now we're going to have the
idea of a weak module that will allow
you to say okay a weak module doesn't
fully encapsulate things to the extent
that you can bypass the encapsulation
using reflection this is still something
that's being discussed so it's a work in
progress we'll wait and see what that
actually kind of comes up with I did
actually tweet about this when i saw
this and i said what's next phantom
modules and and soft modules and
reinhold actually replied to my tweet
but it was quite interesting to see that
now what this actually means is that
there is a change in the way Java
language works this is to me is one of
the sort of biggest things from point of
view modularity in jdk 9 in Java as we
know it there is this sort of hierarchy
of accessibility so as we know
that means it's accessible to everybody
protected subclasses package is only
classes in the same package and private
only within that class that changes a
bit in JDK 9 because public now doesn't
really mean public you see because
you've got the modules and you've got
the encapsulation and enforcement of
that you've got the idea of public to
everyone you've got the idea of public
but only to specific modules and you've
got public only within a module so it
depends on how you define a particular
package being exported from your module
if you export it everybody can use it if
you export it only to certain packages
sorry only a certain modules only those
modules can use it and if you don't
export it it can only be used within the
module itself so now public doesn't
necessarily equal accessible not in the
same way that it did before so it is a
bit of a fundamental change when it
comes to what we think about from
accessibility in Java so this now leads
us on to how do we take the JDK and
break it up into modules this has proved
to be very tricky now
bear with me yes so this this a chart
graph here is a graph with JDK 8 and
what it does it looks at sort of
packages within JDK 8 don't worry about
actually trying to read it it's just
there to show there's lots of lines lots
of edges in the graph and lots of nodes
but the problem is that obviously Java
has evolved over time so we started off
for 200 class libraries gradually added
more more things to that and as people
have added class libraries what they've
done is they said oh okay well we can
use anything that's in the class
libraries to implement this new library
and that makes sense but it has led to
some rather interesting and and
unnecessary
links between different parts of the
system and I'll give you a demonstration
of that because if you sort of drill
into a bit more detail you probably
still can't see this beyond about three
lines back don't worry about it in there
there is a John Jack's W Java WS module
or package I should say Java WS package
which is web services and that has a
dependency on the beans package so you
think yourself ok well that kind of
makes sense ok somebody's written Java
WS and they've used beans in there so
that's a reasonable thing to do if we
look at another part of the graph what
we find is that there's beans on the
right there and there's desktop and
desktop is or like a WT and you'll see
that there's a dependency between
desktop and beans so you think okay yep
again that kind of makes sense you know
desktop babies beans that make sense
right good but there's also a graph line
between beans and desktop so the
dependency between beans and desktop and
then you start thinking oh why why does
beans depend on desktop then you have to
start digging into the source code and
looking at what actually goes on and it
turns out in the beans sort of API there
is a beam descriptor and I can only I
can only imagine that they gave the bean
descriptor task to an intern because
what I did was they said ok well yeah
what we'll have a bean descriptor bean
descriptor will have a name it will have
certain other information it'll have
description all these sort of good
things
I'm in the interim being the intern
decided they go like the next step and
they they make it even better and they
thought well let's have an image to
associate with that so we'll have like
an icon that we can put with that beam
so in order to do that you need to
dependency on AWT because you need some
way of rendering that image so that the
the bottom line here is that you now
have a dependency between Java WS so Web
Services and beans which has dependency
on desktop so Web Services is now
dependent on desktop not a very good
situation because if you're trying to
separate out the modules in in the Java
API because it's all these links it's
very difficult to tease it all apart and
separate these things out so this comes
back to why there are six api's six
methods that have been selected for
removal in jdk 9 in order to break some
of these links and make life easier so
we now have a much simpler graph in
terms of platform modules this is like
one of two so it is far far simpler um
now I won't go through all of this but
essentially you've got a module system
where there's this kind of standard
modules that are being defined so you've
got things like Java compact 3 Java
compact to Java compact 1 which are the
compact profiles that we had in JDK 8
there's also a whole bunch of other ones
it's like desktop and naming and logging
and all those sorts of things but
there's also java SE and that's like a
meta module doesn't actually contain any
classes or packages itself but it's a
way of grouping together a set of these
modules as well and then we got slide 2
of 2 because we've got another meta
module which is called Java dot s EE no
confusion there I'm sure and that's
because a lot of there are a lot of
api's in Java SE which are also related
to Java EE so there's web services
there's binding this transaction support
SQL all those sorts of things so there's
lots of sort of links between those and
the the ones I put with a dashed line on
is where there is no implied readability
most of the the modules do provide
implied readability to other modules but
in the case of a few there are there is
no implied readability right so let's
just look at a little bit of how we
develop code with modules so the first
thing is it's very simple
all we have to do is compile our code in
exactly the same way that we did before
now I mentioned that we need to move
away from the idea of class path hell so
we won't use class path anymore we're
called module path instead a bear with
me it does get easier so we have the
same kind of approach we can plan our
code we specify the module path as to
where the modules come from and we can
then resolve the dependencies we can
resolve the different methods and
classes and so on and everything will
work and of course we can part our
module info Java file into a module in
fed-up class file how to create a module
is we simply create a jar file we create
a jar file which contains all of our
classes that we've compiled plus the
module info doc class file it's really
the module info dot class file that
turns a jar file into being a module jar
file and in order for it to work you
have to place it at the top level of the
directory structure so you can't have
more than one module defined in the same
jar file we can create that using the
Java command it's exactly the same as
before this like one extra option or so
on there but it's all pretty much
straightforward and then there's a new
command line options that you could take
the jar command you can say with my jar
minus P and it will print out the
details about that module so I'll give
you the name of the module it will tell
you what it requires in terms of like
Zita Java Base Java SQL and what the
main class is so we can specify a main
class so that we know when we want to
run it where the main entry point is and
we don't have to specify that explicitly
on the command line so when it comes to
running our code it's obviously far
simpler than it was before now we don't
use minus CP for class path Muse minus
MP for module path again it's much
simpler
right now then there's linking now
linking is really about creating a
runtime for your application so what you
can do is you can say right I want to
have my application bundled with a JVM
and if you want to do that you can now
you can obviously leave a standard JVM
on your machine and then just run lots
of applications on top of it but if you
want to deploy your application with a
specific JVM with restricted set of
modules you can do that with j-link
so you can say ok j-link specify the
module path where the module is coming
from which module you want to add in
this case we're just adding Java doc
base it's not going to do anything and
then output to a specific place where
you want the image to be created and
then if you run the Java command in that
image that's been created what you'll
see and do - list mods what you'll see
is just Java base if we do this for our
application that we saw before what we
do is we say in this case that the
module we want to create the runtime for
is is commodores or door app we don't
have to specify all the other bits
because the dependencies remember we're
encoded into the module info dot Java
dot class files and now what we'll see
is if we do the list mods we'll see that
we've got job base job logging SQL XML
app the tube Zita all the things that we
need are there the observant amongst you
will also notice that there's is extra
bit of information there at 9.0 at 1.0
and you will be getting excited you will
be thinking oh look we've got versioning
No do not get excited about this because
the version number there is simply for
information purposes only and I actually
quote from the document which has been
written called the state of the module
system it says it is not a goal of the
module system to solve the version
selection problem and just just recently
they've even if such shaking his head
they've actually even gone further than
that because they've now taken it so
we're not just going to ignore
versioning we're going to actually
remove it now what does that mean so
they think there's a
posle which says well we don't want
people kind of sneaking in versioning so
we don't want people to say right we'll
put a version number in the name of the
jar file so the name of the module so
you'll have you know foo - 1.0 foo - 1.1
and so on
aha the module system will then look at
that and go oh look they put a number at
the end let's strip that off again it
still still up debate we'll see whether
that actually comes up - whether whether
it really comes to fruition anyway so
let's just talk briefly about
application migration since I'm running
out of time this is your typical
application in JDK 8 so you've got the
JDK at the bottom you've got your
application jar files at the top and
then you've got a bunch of jar files in
the middle which your third-party you
know frameworks and and so on in terms
of how that looks at the moment what
you've really got is the class path so
everything that's a jar file has to go
on the class path and the JVM uses that
to resolve the things that it needs in
terms of classes and methods and so on
now if we then move to JDK 9 we have our
JVM JDK broken up into modules so we've
got modules at the bottom now but we
still got all these jar files above it
and what we don't want is a situation
where we've got to change all of our jar
files into being modules straight away
so we need a way of running existing
code without him doing recompilation
rebuilding or anything like that and the
answer to that is what's called the
unnamed module essentially everything
that's on the class path becomes one
module the unnamed module and that way
you can have the unnamed module
depending on all the modules in the JDK
and everything can get resolved from the
module perspective that way when you run
your code on jdk 9 you don't have to
make anything different you can still
use class path you can still use all
your jar files and everything will run
without any backward compatibility
issues so that is good if we simplify
that a little bit so let's just use a
sample application that's got two jar
files for the application and it's got
three jar files for like
party bits what's gonna go on there okay
so typically this is where we get into
class paths help because we have to
specify all the elements that go on the
class path and we say okay it's my app
my Lib this job that job so on now I
know but a while back I think it was
Java c7 if I remember rightly the the
engineers at Oracle Sun did discover the
wild card so they were able to use that
and you could simplify this a bit but
you still have to specify all these
dependencies on the on the class path so
let's say we're going to move our
application forward and we're going to
make our code into modules so now that
the top part we've got my app in my Lib
are going to be modules because we've
got modern info dot Java file in there
but we've still got these three in the
middle of the dejar files now that's a
problem because if I define the
dependencies for my application I need
some way of specifying dependencies on
these Java files and one of the
restrictions is I can't specify
dependency on the unnamed module so this
is getting a bit more complicated right
well what I really need is modules
everywhere so I need modules in the
middle and if I look at the dependency
graph this is kind of what I get the
problem is that in order to make these
into modules I'll actually have to take
the jar file unpack it create a module
in photo Java file compile it put it in
the directory structure repack the jar
file and then make a module which is
kind of nasty because I don't really
want to have to do that and the answer
to that is automatic modules so
automatic modules are still real modules
you put them on the module path and what
you do is you just take your jar file
and you put it on the water path then
the module system will look at it and go
oh there is no module info class file so
this is an automatic module we will name
that module the same as the jar file we
will export all the packages in there by
default because we can't specify which
ones we want and we will have a
dependency on all other modules in the
module path so okay that will work so
that's great if we then look at the
dependency graph we end up with a slight
more complex situation and the other
thing that you'll notice here is when I
started talking about this I said that
one of the important things is it has to
be an acyclic graph that's not an
acyclic graph because everything has to
depend on everything else in terms of
automatic modules and this was a good
question that came up when I did this
presentation a couple of weeks ago I was
like mmm you're right how does that work
so I looked at the documentation and it
turns out that what the module system
does is it says oh okay well you can't
have an acyclic graph with your explicit
dependencies but if you then use
automatic modules which will by default
introduce cyclic references within the
graph will kind of handle that for you
so it takes care of it sort of magically
afterwards so you don't have to worry
about that so the mud of the class path
does become a lot of class part hell
goes away and we just have module path
now and we just say okay all the modules
are there the dependencies are all
specified through the definitions and so
the resolution can happen and everything
is a lot simpler just summarize a little
bit of more information
one thing is tooling support who's a
NetBeans user come on thank you there
must be one because I'm a NetBeans user
okay so if you are an it means user
you're lucky there is some work going on
in terms of supporting JDK 9 and there's
where graphing the dependencies so you
can put in your module info dot Java
files and it will show you the
dependency graph for you hopefully
they're going to make this is a slightly
more pretty graph than the way they've
done it at the moment
just to summarize then a modder ization
is a big change for Java it's primarily
because of this encapsulation or private
API is splitting things up and then
having to specify dependencies having to
export things and so on there are some
potentially disruptive changes around
things like some miss concise and the
private API is and things like that
developing modular code will require you
to learn a little bit so you know
there's still things going on in terms
of figuring all this detail out but it
is worth spending a bit of time to
understand how these things work placing
more information
openjdk java.net is the place where
OpenJDK is being developed so there's
all sorts of information there things
like the Jets JDK enhancement puzzles
project jigsaw has its own page and you
can get the documentation which is the
state of the module system download that
from there explains a lot about all
sorts of other things like class loaders
services which is another thing which I
haven't had time to talk about there and
as I saw we have a build we do of open
JDK so there's a binary that we create
early access of JDK 9 as well as JDK 7
and 6 if you want to have a look at that
and that is just about me done in 40
bits there else thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>