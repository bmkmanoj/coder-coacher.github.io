<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Feet in Both Worlds: From Objective-C to Swift&quot; by Andy Matuschak | Coder Coacher - Coaching Coders</title><meta content="&quot;Feet in Both Worlds: From Objective-C to Swift&quot; by Andy Matuschak - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>&quot;Feet in Both Worlds: From Objective-C to Swift&quot; by Andy Matuschak</b></h2><h5 class="post__date">2015-09-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/q_Y070VAP0c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everybody I hope your
conference is going well I hope you are
not to lunch komedi today we are here to
talk about interoperability language
design we're here to talk about the the
unholy are very beautiful depending on
your predilections combination of a
thirty-year-old language and a very
modern one check to see and Swift
my name is Annie Matuschek I lead mobile
engineering at Khan Academy which is a
nonprofit trying to make a free
world-class education for everyone
everywhere and before that I spent many
years at Apple building UIKit I should
add a disclaimer that I was not one of
the contributors to the swift language
so I don't speak from that particular
position though I sure did give them a
lot of feedback so this this talk is um
it's really gonna be it's gonna be an
exploration on the theory side and on
the practical side and so to kick it off
I want to start with a bit of a history
cuz I think some people don't realize
just how far back the roots of this
system go 1983 Brad Cox published
Objective C 1983 33 years ago it's a
it's kind of amazing I mean it's like a
pretty obvious small talk based language
it got taken up pretty quickly
a few years later by next for next step
which was their beautiful library of
objects that you could use to build
applications it was trying to be an
object-oriented suite which is this very
novel idea at the time this idea that it
should be like going to the hardware
store and pulling these things off the
shelf and recombining them and new and
novel ways a few years later they
published another major framework called
the enterprise objects framework it's
also based on objective-c that
ultimately became a lot of the
foundations for web objects which is
still shockingly in youth today for the
iTunes Store which you know delivers all
of your apps and it's also it's also
core data so that this is this is a
foundation of a system that we still use
today and next step the set of
frameworks was taken with honestly not
very many modifications
and it became coca and you see that
legacy with the prefix NS in front of
all those api's and it wasn't really
until years later that that sort of
framework started evolving to become
their own still very much based on this
history now becoming decades old when
OSN started the system itself was you
know it was really a lot of C there's a
lot of sequels plus and over the years
particularly with iOS more and more of
the system began to be implemented in
Objective C Objective C started to be
used as a course systems programming
language not just an applications
programming language and that's that's
an important evolution because it really
explains a lot of why it has been so
important for Swift to have excellent
objective-c
compatibility this thirty years of
history is something that can be
capitalized on it's something that's a
liability because there's tens maybe
hundreds of millions of lines of code
that are underlying all these operating
systems now that have to stay functional
so in 2014 when Swift was released one
of the most unique features about the
language one of the ones which consumes
so much of the syntactic and semantic
complexity or weight of the language was
its interoperability with Objective C
on the one hand this is a great thing
because when new languages come out they
very often have this awful
chicken-and-egg problem where no one's
gonna use language until there's a great
set of libraries for it and nobody's
gonna write a great set of libraries for
it until there's much users the language
so Swift defeated that by having into
this thirty years of legacy that users
of the language could leverage and you
know compared to a lot of other systems
where you would use sort of FFI like
implementations in order to access these
these legacy systems
it's a comparatively more pleasant
experience using these older api's and
swift on the other hand this Interop is
a liability and and that's largely what
we're going to explore today it has a
lot of cost in the language
that cost their semantic cost and
there's also a huge opportunity cost all
of the things that the language couldn't
be because it had to continue on with
this legacy now in that commentary I've
been mentioning there it's really mostly
about theory the the design of the
language and you know my imaginations of
how it might evolve in the future but
there's there's another interesting
component to this which is the practice
of integrating Swift into these legacy
systems now apples got tens of millions
of lines of objective-c but anybody
who's been working on these platforms
probably has maybe tens of thousands of
lines of objective-c
that is living this thing is like as
this organism it's not allowed to just
die and be replaced we have to do some
kind of strange mutants graph of the new
host onto the body and I've been doing
that with my team at Khan Academy and I
have a report from the field on a
comparatively large project on how
that's going and and a number of tips
that that one might use in order to
combat the the numerous issues that want
encounters while trying to integrate
Swift into a large objective-c code base
even a comparatively you know new and
modern objective-c code base so when we
talk about the weight of the objective-c
Swift interrupts I feel like this really
sums up that weight most directly this
book is about 200 pages now it doubled
in length with Swift - in in some good
ways you know that there's a bunch of
examples now which is nice but it is a
200 page book about the Interop between
Swift and objective-c and for the
foreseeable future what this means is
that all new Swift programmers and well
really everybody's a newspaper cover
must understand not just Swift but also
objective-c and not just Swift and
Objective C as independent entities but
also the extended ligament sure
connecting the to a table see whether
implicit
or explicit is something that all Swift
engineers must consider so when using
the target action pattern when using
delegation with a cocoa API when
interoperating with any Objective C
system one has to ensure that one
symbols are being exported to Objective
C sometimes that happens implicitly
sometimes you have to specify explicitly
with this symbol and so the rules for
when something can be exported to
Objective C are something that one must
have a very deeply ingrained in one's
gut I'll must be thinking about at all
times
and related to that is the mass of this
very large mapping layer that exists
between Objective C and Swift this is
the mapping layer that does things like
every time we see an ID we convert it to
in any object that's a comparatively
simple transformation but there is more
complete complicated transformations
like the behavior of former NS error out
parameters being transformed now into
these sort of interesting exception
style error handling blocks and of
course for all of these mappings or for
most of these mappings there are
exceptions which you can explicitly
control there are places where when the
mapping fails you can override the
mapping and control the mapping yourself
but even as a consumer of these mappings
when one reads headers and documentation
one must have the mapping sort of
memorized and and in one's hands so to
speak in order to be able to use the
language fluently
even simple things like numbers the
rules are kind of complicated an integer
can automatically be be boxed by an NS
number but if you have an NS number you
can't automatically use it as an integer
because you know it might be a double or
something
the rules for NS array and array are
perhaps even more fraught because NS
array is heterogeneous it can have
elements of many diverse types
whereas array is homogeneous they must
all it must all be the same type and so
when you move across that bridge there's
there's actually like a there's a number
of runtime often operations which are
performed
there's this this list goes on and on
I'm not really going to go through it
I'm just gonna go to some of the more
esoteric items that that one must
currently be aware of and which are
adding to the weight of this language
mmm and it's managed is an interesting
hack and I bring it up because it
introduces a meta issue in the
interoperability between Swift and
objective-c and that's managed is a hack
introduced to the Swift language in
support of core data accordion is a
library right so this is this is a
language support feature which exists
for the purpose of a library and exist
for a purpose old library in a legacy
language and what it does is it says if
you if you mark a property as ns-managed
then it it tells Swift that it doesn't
need to synthesize storage for that
property it doesn't need to expect an
implementation for that property core
data is going to provide one while the
specifics of this particular hack for
core data are not particularly
interesting it does bring up the first
of many impedances that we're going to
see core data fundamentally doesn't make
sense in a large number of ways in Swift
it's the thing that heavily relies on
dynamism it heavily relies on string
rains in programming and on a more meta
level it heavily relies on shared
mutable state and subtyping both of
which are things which Swift is
de-emphasizing and yet it's this burden
that we have to kind of drag along to
the extent that we're adding syntax to
the language in support of it now this
and and the other piece of you have the
other pieces of syntax that I've been
mentioning so far aren't so bad because
when we no longer need this legacy
baggage when we're no longer using core
data we don't have to worry about these
keywords when we're I guess no longer
using foundation we don't have to worry
about the mapping layer that will come
but probably not for a long time the
ones that that get a little more
interesting are the ones that don't go
away we'll get to those in just a moment
this one is sort of transitionary
and it's copying is a swift variant of
the objective-c property copy attribute
the objective-c property copy attribute
exists so that if you have a string
property and somebody passes in a
mutable string that mutable string is
going to be copied before it's stored
into the instance variable so that if
the client changes the mutable string
you're not gonna see that change now
that feature only makes sense in a
language where reference semantics are
used for value types which is to say
where it makes sense to have an NS
mutable attributed string which can have
multiple owners now that's not a thing
that makes sense in Swift in Swift we
would just use a struct for that we
would use value semantics and so an
explicit declaration of copying of a
reference type which relies on a
protocol to find in a library even
though this is a language feature is not
a thing that makes any sense and this
confusion between reference types and
value types is something that we are a
little bit stuck with as will continue
to see so now I want to talk about some
of these deeper costs that I alluded to
namely the ones that that don't go away
when we stop using the objective-c
libraries when we stop using the
objective-c parts of the system these
deeper costs begin with the aesthetic
this is a really surface level thing but
let's just talk about keyword arguments
in Swift they're very strange the syntax
of the keyword arguments is such that
the the first argument you don't specify
the keyword inside of the parenthetical
body instead you specify it as part of
the function name stem however all other
arguments you specify explicitly within
the parenthetical body so wit color is
specified in the body but rect is not
this is the case only because of this
objective-c heritance write it this is
the case because of the objective-c
selector syntax
and even when you're no longer using
objective-c we're stuck with this
interesting wort and this interesting
word is particularly problematic because
it's not consistent initializers for
instance don't have this property and
neither do closures neither did free
functions in Swift 1 but in Swift 2 they
they do have this property so these are
these are a set of rules that you're
gonna have to remember and that you're
you're not going to get right the first
time for quite a while these add to the
startup cost of the language for
beginners learning Swift even when they
don't use Objective C libraries dynamic
is another interesting wort that to some
degree were stuck with dynamic is a
keyword that you can put before our
property our method which specifies that
that property or that method has to
always be dynamically accessed ie
we always have to go through the runtime
it's not legit for us to access it by
doing some pointer math that's compiled
into the binary and you might use this
in a place where you want to be able to
do runtime shenanigans you want to be
able to swap out the implementation of a
method you want to be able to add a new
implementation at runtime those very
concepts are very obscene maybe they
belong in Swift we could debate that but
the dynamic keyword has the effect of
making all this stuff available via the
obscene runtime it's not like there's
some new set of Swift runtime api's that
were using to access this stuff we're
still using the obscene runtime the
obscene runtime which is full of locks
and full of all of these features that
we don't really want to use and the
whole reason that dynamic uses the
obviously runtime is so that things like
kvo can work and things like core data
can work even though those are library
features again and there are library
features which are sort of anti patterns
in Swift
this one is a it's me going out on a
Ledge a little bit more but it's
something that bothers me a lot in Swift
you can make a cycle you can leak memory
which doesn't seem all that strange or
alarming or unusual but in Swift you
can't in general make a right to a
dangling pointer you can't have an exact
bad access crash that whole set of
problems is to find a way the set of
strong and retained cycles is not
defined a way is there something
fundamentally harder about one of these
problems than the other I claim that no
and the reason that Swift still uses
essentially a manual memory management
automated by the compiler is the
objective-c Interop heritage that it has
to have is that if Swift wanted to add a
manual cycle collector it would be
tantamount to requiring Objective C to
support garbage collection again which
as we may recall didn't work in the
first place it was too much of a burden
on the frameworks it was removed and so
because we have to support this
interrupt we don't get cycle detection
in Swift that's that's my thinking on
the subject the fact that we don't have
cycle detection in Swift is crazy and
then perhaps most disturbingly there's
the opportunity cost so Swift Swift is
really split if you look at the standard
library it's like pretty much all
structs and enums it's very data
oriented it's very pure and yet the
opinions the design opinions which are
expressed by the divide by the standard
library seem to be contradicted by a
large number of language features by the
disproportionate weight of those
language features and those are the
language features that are in support of
essentially legacy object-oriented
programming patterns the idea that we
should extend a class in order to
implement draw rect by making a subclass
rather than using composition making
something which has a drawable for
instance rather than is a drawable the
fact that all this object-oriented
programming stuff has been introduced to
the language adds tremendous weight even
though the standard library seems to
contradict its use if we look at the
Swift programming guide some of the most
complex topics in it things like the
rules for overriding initializers trying
to remember what's the difference
between like required and designated and
convenience those are some of the most
complex topics in the book those are
topics that were stuck with similarly
the interesting conflation between
reference and value semantics and
classes and structs there's another
thing which we're stuck with largely
because of this objective-c heritage so
the thing that pains me the most in
terms of these costs is it's not really
the words that we see like the weight of
these keywords but rather all of the
nicer design elements that we can't see
that couldn't be considered that weren't
possible because we had to support all
of this legacy not saying that it's the
wrong decision to support all this
legacy but from a language design
perspective it's an interesting thing to
consider now the issues at hand here
they go outside of the language itself
and they extend to the libraries we've
been talking about all of these
objective-c libraries which have all
these idioms which have forced various
elements of language support eventually
these libraries are probably going to
have to be swift to 5 to some extent and
and they already have been into a degree
you know we have we've added these
generic annotations to collections and
objective-c libraries we've added you
know null ability and non null ability
and yet some of the more fundamental
idioms such as the heavy use of sub
classing
and the use of shared mutable state
everywhere and the use reference types
of our value types everywhere those are
things that can't really be changed so
readily by annotations so this is
something that we as a community are
going to be dealing with over probably
the next decade on the other hand we get
the excellent benefit of being able to
use all of these pre-existing libraries
on day one being able to leverage them
and really enjoying the composition of
being able to write adapters as we
please to hide the worst parts of these
libraries even right now so that's
really what I what I have to say about
about Swift from the language design
perspective the cost of these decisions
on the syntax and the semantics of the
language but I think it might be fun at
it to shift into sort of a storytime
mode where and I can tell you about this
this project that we've been working on
at Khan Academy we were one of the first
big products to adopt Swift we have a
it's it's when I say big it's you know
it's always relative or not you know
we're not saying Xcode can't handle our
skill although it does take eight
minutes to recompile our project is
thirty thousand lines of Swift and an
interesting thing about it is that it
used to be about 30,000 lines of
objective-c no it's more like 10 and
that wasn't voluntary we had this idea
we were led astray we had this belief
that what we would do was for all the
new features we would write in the Swift
and all the old stuff would kind of stay
as it was and then you know as we
rewrote the older features we would you
know maybe consider rewriting them and
Swift when it made sense in practice
that clause when it makes sense was
pretty much all the time we were forced
to do it constantly and it slowed us
down enormous ly as we started
implementing new stuff in Swift we were
constantly forced to rewrite and shim
old stuff I don't know that it was the
wrong thing to do because now we have
this shiny new code base and we have a
lot of experience in Swift which is
lovely boy it did make us very slow for
many many months so we did learn a few
tricks about how to deal with this
interoperability and the impedance that
occurs within it and really the issues
appear when you try to write swifty
swift code when you try to use mean ohms
when you try to use struts when you try
to use generics if you write objective-c
e swift code you'll be pretty much ok so
that's always an option you can use
these classes for everything and don't
use generics and use any object all over
the place as you would use ID in
Objective C and then your interrupt will
be okay but if you want to write swifty
Swift if you want to Swift that feels
like the standard library Swift it that
feels like what the language can do then
you very rapidly run into these
interesting impedances where the types
that you write in Swift are completely
invisible to Objective C and it's not
clear how to bridge that gap so I'm
going to walk through a bunch of adapter
strategies that we've been using that
you can use in your own apps in order to
try to make this stuff a little less
painful when start with enums enums
are significantly more powerful and
Swift and they were in objective-c we
can now think of them more formally like
some types
you know younam's can be deployed
anytime that we might have value a or
value B and we can employ methods on
them and we can make them generic
they're really really spectacular of
course they don't cross the bridge so
let's let's look at the scene um for
example so that we have an icon view and
you know when the image isn't loaded
from the network yet we're just going to
display a placeholder that's like a flat
color and so the icon view knows how to
display either a color or an image this
is a great example of something that
wasn't possible in Objective C at least
not in a straightforward fashion because
if we were to make an enum for icon in
Objective C we don't have a way to keep
the Associated values going along with
that you know
now if the icons a color and then we
have a color value if the icons on image
then we have an image value which is
much more lovely but of course we can't
use this icon view practically speaking
from objective-c so I'm going to
introduce some solutions that are going
to make you wince and the goal is that
they are isolated from the nice
implementation so that you can pull them
out as soon as you don't need them
anymore
they're shins so the shim we've been
using looks like this and you can put it
in an extension the obscene adapter
support for the icon view and now your
Objective C can initialize icon views as
it please is it'll be just fine it's
ugly but it works and I've got more of
this to go so that's when you want to
use the Swift type from Objective C but
what about if you want to have an
objective-c type that deals with icons
so you have some view controller that is
gonna use that icon view that we were
just looking at but it has all this
other code and you don't want to deal
with migrating view controller which
contains the view to Swift so we're
leaving the the view controller which
contains the view and objective-c
nevertheless we have to pass an icon to
it or through it this code doesn't
compile obviously so
what we've been doing is is something
like this and you know again this is a
situation where it's very easy to see
where the shin is it's very easy to see
what the adapter is we we just separate
out the variance of the enum and if you
need your objective-c type to actually
be storing your impedance mismatch Swift
type like this which also doesn't
compile I have another shim for you
this shim requires a slight detour into
box which I think that that many of you
might have met already box is a friend
in impedance mismatch and Swift support
failure territory box allows us to sort
of hide a value within a reference type
it's a generic type which means that we
can't directly reference box from
objective-c but we can use it as an ID
so here's the thing we've been doing the
so first off you can't add storage to an
objective-c class from within an
extension so we have to define the
storage in objective-c
we just define it as an ID and we do
this lovely thing we're going to
redefine the type of the ID in comments
which unfortunately we're doing all over
the place and the nice thing though is
that then any Swift code which is a
clients of this view controller it
doesn't have to go through this ugly ID
thing it can actually go through a nicer
API so it does limit what you can
actually do with this icon from
Objective C land but you can't store it
and you can pass it on to something else
which is useful when you have a layer in
the way of you and some shiny new Swift
thing right so in this example the icon
view is a shiny new Swift thing that
uses this shiny new Swift enum but the
icon view was inside of this owner that
is not shiny it's not new and we just
need like a past
so this will help us with the
pass-through situation if we actually
need to expose the icon in the public
interface we can do that with another
shim where note that this computed
property is a table C so it's visible
table C and here we you know we can we
can return a value if the icon is a
color and we can return nil otherwise
it's a partial function
I guess it's total insofar as it returns
an optional so it always returns a value
but you know obviously not ideal but
does function we have used this kind of
pattern it has gotten us out of some
binds the implementation here isn't so
bad because it's using the Swift
implementation icon the computed
property icon which is doing that ugly
box transformation and we saw in the
previous slide so at least the
implementation isn't so bad and again
it's in an extension its independent so
we can tear it out when we're done with
it
now if you´d aren't using associated
values with your enum then there's
another option open to you so here is a
representation of card suits maybe we we
have a computed property on the card
suit type which allows you to determine
what color it is is it red is it black
well we could define the suit within
Objective C and then it's easy to store
with an objective-c because it's just an
objective-c enum we can reference it and
construct it with an objective-c so
that's all fine and we can have this
fancier computed property defined in
Swift and yes only available to Swift
clients we could write another shim to
make it available to Objective C clients
there's some external property or sorry
external function but here we've cut our
losses a little bit so to speak let's
talk about drunks
also significantly more powerful and
swift also I would argue a building
block of a modern Swift application
anywhere where you don't need multiple
owners for a type you should be using
instruct they're significantly easier to
reason about but unfortunately their
interoperability with Objective C is
very very poor if you do well really if
you have a struct defined in Swift you
can't use it from objective-c even if it
doesn't do anything fancy even if you
have a struct event so you can't use it
from Objective C which which does limit
your options somewhat so let's walk
through some some shims that we've been
using to to help bridge our object our
Swift's trucks into Objective C land say
that you have a user mm which has two
fields and you have a profile view the
profile view knows how to display user
and you want to make a profile view from
obviously land well just like we did for
in ohms we can make in an extension an
obviously visible initializer which
flattens out the fields of our user and
we can tear this out when we don't need
it anymore and if we want to be able to
deal with this thing from an objective-c
implementation again the situation where
we have like a wrapper view controller
it's still an objective-c around a swift
fancy view then we can do something like
this again flattening out the fields and
if we need to have storage for the user
then we can do a similar trick it's what
we did before where we use a box not the
most beautiful thing in the world but it
has gotten us out of a lot of bad
territory if we need to be able to
access the fields of the user struct on
that view controller we can do something
like this we can define say a property
for the name of the user and when
getting it we just project out the swift
name which we can do because we're now
in a swift extension on this legacy of
you control
so we're allowed to actually do things
to the user and when we set the username
we construct a new user substituting in
the new name and keeping the other
fields the same a lot of boilerplate but
again this is save this now this
situation is sort of the analog to the
suit situation if you have a struct
which is representable in Objective C
modulo some sort of extended swiftie
elements like this one because both of
the fields are doubles you can represent
this with an objective-c so you could do
something like this
where the method is only available to
Swift here maybe you don't need that
particular method from your objective-c
source so you can you can put that in an
extension and it'll be visible to your
Swift source and now otherwise your
struct is visible to your objective-c
you can construct it you can pass it
around you can store it and if you
really need to you can make a free
function to shim in Swift which is
exported objective-c and now you can use
your coordinate distance from Objective
C as well generics are another of the
really important features in Swift which
allow us to program at a higher level of
abstraction they allow us to share more
code and they allow us to move more
quickly and they're also completely not
interoperable with objective-c despite
the introduction of generics within
objective-c that doesn't really mean
that you can use your own generic types
from Objective C the example I'd like to
look at is something that I see
everybody trying to do as soon as they
get Swift because it's like it's this
very enticing and beautiful thing they
say oh yeah we're we're gonna we're
gonna make a tableview datasource that
is reusable its generic we can use it
all over the place it doesn't really
matter what it's showing it's just going
to implement the UI tableview datasource
protocol based on this data-driven
approach where you know we give it a
bunch of items and it'll it'll answer
the table for use questions as need
this code doesn't compile or it might
silently fail at runtime I forget it
does one of those two things because
this can't be a UI tableview datasource
because it's not exposed to objective-c
it's it's not visible to Objective C so
the strategy that we've been using for
this kind of thing is to make a separate
type that uses closures to bridge so
this is this is I think the most code
that's going to appear on one slide in
the talk let's talk through it here we
have the tableview datasource as we had
before which just has an array of
sections so this is this is a very Swift
e-type it's also not a UI tableview
datasource the top class doesn't conform
the UI tableview datasource instead it
has a property where you can get this
adapter that does conform to UI
tableview datasource the adapter is
super dumb it doesn't know how to do
anything it doesn't even know how to
reason about this the sections
collection that we had all it does is
store a few closures i've elided the the
fields that you would need in that
bottom class so as to make the slide
legible but as you can see the bottom
classes initialize with a number of
closures and those closures correspond
to the methods that are defined in the
UI tableview datasource things like
number of sections a number of rows per
section the bridge datasource computed
property in the top class can supply
closures to the bottom class which
capture the generic values so that now
the bottom class can be exported to
objective-c this is this does generate a
lot of boilerplate when you do it but
thankfully that the client ends up
actually looking pretty nice the one
word and the client is that they have to
use the table view data sources bridge
datasource rather than the original type
itself but they otherwise don't have to
you know implement this this large set
of table view methods and they can deal
with their table views now in this
nice day too directed fashion now in
this pattern of sort of erasing these
issues that we're having with generics
is is useful more generally we see it in
a swift standard library with types like
any collection and we can use it if we
wanted to access a section from
objective-c
so section remember was a generic type
that had a title and a list of items and
so we can make a variant of section
called untyped section which we can
export to Objective C because it's items
property is a list of any objects and so
given a section that we have in Swift we
can get an unsafe section from it
provided that the sections type is it's
a second of objects and then you know we
can we can we can do objective-c II
things to it it would be much like if
you had an NS array of items from
Objective C I guess that's literally
what you'll have when you access items
on one type section you'll have an NS
array and you're gonna have to do the
normal casting thing that you do when
you use an S or a so you're not really
worse off than you would have been if
you tried to implement this abstraction
in Objective C two years ago when you
use it from Objective C but when you use
it from Swift you get to use the nicer
more types properties this this thing
here is showing off a neat Swift tube
feature that you may or may not be aware
of this is an extension which has a type
restriction so I'm only supplying a
definition of unsighted session here
this computed property for sections
whose item isn't any object I can't
supply a definition of on type section
four sections whose item is some struct
for instance you'd have to box the
struct you'd have to map the section of
struct to a section of box of struct and
then you could and you could get the
untyped variant of it not pleasant but
again this is this is build us add on
numerous occassions
so that's all I got in terms of those
adapters and the mentality that that
I've been using when thinking about this
stuff is is really just an underlying
belief that Objective C not just the
language but all of the idioms which at
portends it stays are numbered and so
I'm looking for ways to temporarily
isolate my shiny new stuff which doesn't
have to be sullied by as much as
possible by these these older means of
programming so that when I'm eventually
able to rip out all of my shared mutable
state oriented programming I can do so
cleanly in just like one little slide so
I hope that's been helpful that is all I
have for you today and I would be very
happy to take questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>