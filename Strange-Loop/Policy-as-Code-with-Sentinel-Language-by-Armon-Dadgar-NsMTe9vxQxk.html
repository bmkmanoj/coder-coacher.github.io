<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Policy as Code with Sentinel Language&quot; by Armon Dadgar | Coder Coacher - Coaching Coders</title><meta content="&quot;Policy as Code with Sentinel Language&quot; by Armon Dadgar - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Policy as Code with Sentinel Language&quot; by Armon Dadgar</b></h2><h5 class="post__date">2017-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NsMTe9vxQxk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my talk today is gonna be about policy
as code sort of more generally and then
we'll talk a bit more about kind of
specific framework that we introduced
last week called Sentinel for those of
you who don't know me my name is Armand
agar this is my first strange loop
actually so I'm super excited to be here
I've heard only great things so excited
to be able to come out here and present
and for those of you who don't know me
you know I work at Hoshi Corp I'm one of
the founders and CTO oftentimes people
know us less by the name of the company
and more by the name of our tools and so
you might have played with vagrant or
terraformer or one of our other tools so
I'm not going to necessarily talk about
any of these tools specifically today I
want to talk a little bit more broadly
and more generally about policy as code
but before I talk about policy as code I
want to sort of set the foundation my
first kind of going back a step and
talking about infrastructure as code
which you know is much more of sort of
our traditional wheelhouse and if you've
played with tools like terraform and
packer that has sort of their driving
motto is this notion of everything
should be sort of codified and your
whole infrastructure should be driven by
code so we'll sort our talk about the
evolution of infrastructure as code and
sort of the how and the why and the what
so in sort of the world before
infrastructure is code how did we
actually provision our data centers
bring up VMs you know manage our sort of
multi-layered infrastructure you know it
was honestly it tended to be a little
more artisanal and handcrafted it's sort
of what we saw as sort of the standard
right people would log in so user
interfaces and sort of point-and-click
to boot a VM and you know if you needed
100 VMs you just pointed like a hundred
times more and so there was a lot of the
sort of manual bespoke management of
things right
very often UI driven very very common
disease are just SS aging into
production and sort of apt-get
installing their appropriate set of
packages and maybe are syncing things
between machines but in general is the
sort of more you know handcrafted
approach and this was kind of fine when
we only are talking about a handful of
machines right sort of overkill if
you're only dealing with a handful of
machines to really automate this whole
thing as we saw more scale and sort of
more need to have rigor and sort of
operational discipline we've seen
infrastructures code increasingly
becomes or
the common approach right the idea being
here how do we have sort of a single
source of truth in terms of how things
are actually supposed to look instead of
you know we have to get installed five
packages on this machine and six
packages on that machine and you know
they both seem to work and so you're in
the sort of world where you're like
there's really no particularly
well-defined source it's sort of like
the things that exist and are working
are kind of the source of truth so
moving away from that to actually having
that definition that source of truth and
then if you have this it lets us get
into this world of automated
provisioning right so now if great to
stamp out one VM we just run this sort
of codified definition if we want the
thousandth VM right we're just doing the
same thing in an automated fashion a
thousand times so it enables us to get
to scale in a lot more sort of a same
fashion we don't have this sort of you
know our test Ville Management times a
thousand and in some sense it's this
sort of transition from if we're
building one or two things it's fine for
it to be handcrafted but if it's
something where we expect to be doing
you know 10 VM deploys a day times a
hundred or times a thousand it starts to
just become impractical you need a
little more automation you need a little
more standardization and rigor on how
this is done right and so it makes sense
that this becomes sort of a natural
evolution to say how do we reduce the
sort of error in this much like you know
going from handcrafted thing into sort
of an automated Factory and so what are
the benefits as we start going down this
route in some sense it's kind of just
pouring over all the things we learned
from software development right it took
the software development community many
many years to sort of establish what are
best practices around version control
and peer review and branching and
merging and having these sort of higher
level sort of hygiene that we apply to
the practice to make software of higher
quality and some sense what we're trying
to do is drag that over to to kind of
how operations folks do things which is
you know closer to I manage the source
code on my laptop and FTP it to
production
it is sort of state of the art and so if
we bring this sort of notion of hey the
things that we're doing in software
development actually apply to operations
if we take an infrastructure as code
approach then we kind of get all the
same benefits we get versioning and we
have roll back into you know older
well-known states we can do peer review
so we can ask hey you know fellow
operator can you look at this does this
make sense
you can start getting abstraction and
encapsulation so defining sort of
higher-level modules and sort of
treating that as a black box and then we
can start getting code reuse across our
organization we're not sort of just
reinventing the wheel all over the place
within our organization in accra sort of
the community and what all this leads to
a sort of more automation more leverage
so that you can manage sort of larger
fleets more more easily and so great do
we can we just adopt this sort of
infrastructure as code approach you know
in a silo without really you know
changing anything about the world around
us and it turns out not really there's
sort of some prerequisites to making
this approach actually work right and so
in a traditional sort of provisioning a
datacenter world where we're actually
buying from you know HP and racking and
stacking there's a lot of people
involved right you have your developers
we have some guests about how much
hardware you need you have finance who
have some capex budget and a different
effects budget you have procurement
folks IT op folks legal networking so on
and so forth and all of these different
groups have to be sort of coordinating
in terms of provisioning that data
center and so this has to be a really
challenging situation because it's very
hard to codify all of these roles right
they tend to not like that and so
there's this sort of prerequisite which
is you actually need to hide a lot of
these things behind an API before this
approach even starts making sense
because otherwise there's really no good
way to deal with your legal department
and an infrastructure as code way and so
you start needing to say okay how do we
replace these various ticketing
workflows that were sort of flowing
through the system with API contracts
right because if we have an API contract
then we can automate it then we can wrap
it and apply a sort of infrastructure as
code methodology to it
and so in some sense the big push that
started making a lot of this possible
was public cloud right it started
consolidating many of these different
concerns and putting them behind an API
for us and so the private cloud is sort
of catching up but in some sense what
it's trying to do is provide those same
api's and so once we have these api's
once the API sort of approach is
ubiquitous then it really enables
infrastructures code because now we can
think about sort of booting a VM or
managing a DNS record or managing our CD
and all is just various API calls and so
this starts to lead to a huge leverage a
huge increase in our leverage
the challenge with that is this notion
of sort of the paradox of automation
right is that once you have huge
leverage it can be used both for good
and for bad and an example of that is
you know what if I just fat finger and
it's like I meant to provision 50 VMs
but I accidentally put 5,000 right you
know traditionally if I sent that ticket
over to procurement and they're like
well last year you bought 40 and this
year you want 5,000 they're gonna come
back and say are you sure all right
they're gonna be like this doesn't
really make sense here if you ask the
cloud to provision 5,000 VMs for you
it just says great no problem here's
5,000 VMs like we're happy to bill you
by the by the minute and so there's this
loss of sort of sanity checking of the
sort of context that a human would have
right your legal department or your
procurement department has some context
of like what is normal and what what
makes sense to be done right if you call
you know the networking team and say my
apps not getting traffic can you just
route the cables around the firewall you
know they're gonna be like that doesn't
make sense right versus AWS you're like
to set every ingress rule to allow cool
great let's do it and so we lose this
notion of sanity checking right and so
we get into this interesting paradox of
automation where we have this incredible
leverage right and we can do things a
huge scale but then it sort of opens us
up to these a new set of challenges that
we didn't really have right before which
was one of the big ones of just
accidental error right I just fat-finger
5,000 right before there was enough sort
of checks and balances that somebody's
gonna catch it hopefully right right
like you know if nothing else finance
catches it then you have issues of sort
of compliance by passive like you know
and this is not malicious it's sort of
like my app isn't getting traffic it's
it seems to work when I disable the
firewall right in sort of a more
traditional world you can't ask the
networking be able to route the cables
around the firewall and then the last
one is sort of malicious intent is like
if I actively want to bypass controls
right for sort of malicious reasons
who's gonna stop me and so all of these
things sort of lead us into thinking
about you know is there a different way
of doing this right and this is sort of
how we started getting to this notion of
policy as code is how do we actually
govern what infrastructure as code is
valid right so that you can't just write
whatever you want to be like yeah just
every ingress rule
to allow and what we really want to do
is not sort of have a sort of check
pointed human sort of ticketing process
again it's really how do we define that
sandbox such that as long as you're
inside the sandbox run free do whatever
you want right provision 50 VMs
provision 100 BMS don't provision a
thousand VMs right and so if we're
within it we want people to have that
leverage have that sort of agility but
then we want to bring back that sort of
sanity checking that we had before the
sort of like are you sure you're doing
this right and so part of this is also
how do we get back to a little bit of
that separation of responsibilities of
having this like you know that the sort
of secondary group that's doing the
sanity check because that does give us
this sort of bulkhead against failure if
you're just doing decisions unilaterally
there's no one's second-guessing
anything there's no one saying like are
you sure and so part of it is not let's
have a person to it it's can we have two
different sets of codified rules one is
the infrastructure as code which is
evolving rapidly and you know is being
written by sort of operators that has
this huge leverage and maybe you have a
separate group that's defining what that
sandbox is understand sandbox should be
a little more static but this way it's
sort of the you know it's the separation
of you know you don't want a Co a bug in
both the code to affect sort of the test
as well right is it's like as long as
the test is sort of an independent
verification of the code it gives you
this sort of sanity checking that
they're not both wrong and so part of it
is it's a separate set of code written
by a separate set of teams that's
providing this bulkhead against failure
so okay let's look at sort of policy as
code more broadly what are the kind of
things that we start wanting to enforce
if we think about the sort of meta
contract right if we have code that's
governing our infrastructure is code
what are the kind of things we look at
part of it can be things that are
actually not even about the code at all
they can be sort of just like process
workflow changes which is you know maybe
I only want changes to take place during
working hours right like I'm glad you're
really excited but please don't go port
deploy to production at like 2:00 a.m.
on a Saturday right like you make
everyone's life more challenging then
there's things that are actually
specific to kind of the the actual
application maybe we say you know we I
want to have a minute a maximum number
of sort of instances per service tier
right we don't want to have only one
instance because then you know there's
no sort of availability in case that one
node dies and we also don't want you
know 10,000 instances because we're
paying by the minute then
you get into things like what about
which types of instances are allowed
like you know do we want to standardize
our fleet and only a handful of types of
instances or you're not allowed to go
spin up you know the the 512 gig
machines then you get into things like
public cloud regions so maybe staging is
always us West and production is always
us east how do you enforce that so
someone doesn't just accidentally deploy
you know staging staging traffic into
production and then you start getting
into some of the more sort of like
enterprising concerns which is like how
do I make sure any resource I boot I'm
tagging it with sort of a billing sort
of a key or a tenancy key like who which
which sort of line of business owns this
resource or if I'm deploying out into
production how do I make sure it's not
just you know developers are picking a
random black box with you know 15 own CV
CVEs and deploying it straight into
production right it's like is there a
curated list of you know containers or
amis that were said yes these things are
certified these are what you're allowed
to deploy not just like whatever you
found on the marketplace and so what are
the sort of organizational challenges
you start running into when you start
thinking down this approach right which
it tends to be very sort of developer
operator mindset is that oftentimes it's
not the developer operators who are
caring about these problems right it's
the security and compliance teams right
it's their jobs to define and enforce
these policies and they're not
traditionally familiar with an AZ code
approach right they they take a more as
word doc approach to things and so how
do we get them to be familiar and
comfortable with this way of doing
things but also give them ways to sort
of build sort of confidence to be able
to test their policies actually are
doing what they think they're doing
right because in some sense the goal is
to remove you know people from the
enforcement path and so this brought us
to a project that we called Sentinel it
really grew out of just working with
people on the infrastructure as code
side and trying to answer a bunch of
those questions they had which is like
how do we actually impose some sanity
around what's being provisioned without
having to have an army of people just
doing code review all the time and so
the our project the Sentinels code
project they'll spend some time talking
about it's sort of one stab at taking a
look at how can we how can we think
about policy as code as sort of this
broader effort right and though it's
four really four different pieces on one
side it's a language
suffocation so we've published this sort
of open spec in terms of what this
language looks like there is you know we
have one at least one runtime
implementation of it we expect there
will be more runtime implementations a
simulator tool will talk about how and
why that's useful and then an import SDK
in sort of a way of thinking about
import sort of external information into
a policy so starting out even before we
get into it is like what were the goals
here what were the goals in terms of
while we were thinking through a policy
is code sort of approach the one of the
biggest things really became that it has
to be non programmer friendly and this
have a lot of implications is that we
very quickly found the kind of people
who are reading and writing these
policies are not sort of traditionally
developer background so how do you get
them comfortable with what's going on it
has to be sort of easy to embed and
we'll talk about why we want the
language to be simple debuggable and go
friendly and we'll talk about sort of
why some of those maybe don't seem
obvious so this one was really the
biggest issue we found is that the
language is largely going to be read and
written by those with little to no
programming experience so it's not that
these folks that don't want to learn
they're happy to learn but they're not
coming from a background of hey we're
just two throw you into a sort of an
object-oriented system and have fun with
this right like they at most know a
light bit of sort of shell scripting and
so how do we make them comfortable as
they're learning and sort of easing in
here and so we want the traditional
constructs to be available as well if
you have a really complicated policy and
you're like hey I'm just gonna borrow
developer for an afternoon and have them
do it you don't want them to feel wholly
out of place as well of like what is
this thing the other one that's super
important was it had to be easy to embed
right and this really is more of an
impact to the runtime than the language
there's elements of the language that
get impacted by this particularly we
don't want support for things like
unsafe you know arbitrary memory access
it makes it hard to embed something if
that's possible and so it must be easy
to sandbox the application you don't
want it to be able to do unsafe things
because it's running within the context
of some sort of parent application and
if we can actually embed it then what we
can start moving towards us this notion
of active enforcement which is how do we
prevent a violation from happening as
opposed to passive enforcement which is
we can just detect that a violation has
occurred and sort of trigger
some remediation workflow right and so
it's much much easier if we can be in
that active enforcement path and just
not have to deal with a compliance issue
before him the next one that was
important with simplicity right having
simple types at the expense of
performance or exactness and part of
this will come back to really comes back
honestly from that first one again which
is sort of complex types are hard to
explain like the difference between
float 32 and float 64 to someone who
doesn't have programming experience
they're like why what difference does
this make and you're like it's kind of
hard that you're like it doesn't really
matter anymore
and so then the other one is really how
do you make sure these policies are
relatively simple to write and because
they don't need much flexibility right
like the kind of things you're
implementing are like here's this
hundred page Word document of policies
and you're sort of translating that into
a codified definition so you want it to
be a relatively simple translation
they're not doing you know you're not
writing your application in a policy
language so you don't need crazy
flexibility here and you want them to be
sort of ideally one way to do something
right sort of in the vein of Zen of
Python you don't want there to be 50
ways to achieve the same goal this way
that you get some sort of
standardization of if I if you know ten
people write the same policy it
effectively kind of looks the same all
ten versions are identical the big big
other one is especially for people
coming in without sort of a traditional
background is making it easy to debug
right how do they understand why the
system isn't working why why did the
policy pass when you didn't expect it to
pass why did it fail when you didn't
expect it to fail and we find that this
is often one of the sharpest corners
when learning a new language is just the
debug ability and feedback loop of the
system right most languages are not too
complicated to learn if they have a good
feedback loop it's like it's when they
have a terrible compiler error that's
just like failed to compile you're like
great the other big one that was really
more important for us than sort of more
broad to sort of policy as code was this
notion of NGO friendliness the majority
of Hacha groups tools are written and go
and so it was just important for us that
whatever we're sort of using is easy for
us to embed in our tools right so we
wanted to be simple to integrate minimal
changing to the rest of us or a tooling
and process and to not have sort of
performance implications and that was
sort of a big one when we started
looking at different options so the
first sort of big question right and
this was a big
internally to is like how do we invoice
venting a language right like ideally we
don't want to do that we don't want to
have to educate people on something new
because then it's like all of the burden
of sort of education becomes on us as
opposed to like if it's an existing
language and so we really started out
with this right with the with the intent
that we would be able to sort of fit it
into an existing language and get it to
sort of work for us and maybe maybe
there's a higher-level framework that we
have in terms of helping people make its
or simpler but there would be a DSL in
one of these languages and so honestly
the big two that we started with and
spent a lot of time with was JavaScript
and Python
you know Lua and Ruby to a lesser degree
but ultimately it really came down to
those three issues that made it really
hard for us one was the sort of how
friendly is this to non-programmers how
much time are you spending sort of
teaching sort of programming constructs
as opposed to just like they just want
to be able to write policy really easily
how easy is it to embed in the tools in
sandbox effectively so sandboxing the
execution of it was pretty was obviously
important for us given that it's
embedded in our tools and then how
friendly is it to go and we really
struggled with all of them in terms of
trying to hit all of these requirements
we probably got the closest with what
sort of Python and and you can kind of
see when we talk about syntax that it
reflects sort of very pythonic kind of
views and so we didn't we didn't find a
way to make any of these work for us and
so we started saying okay if we were
going down that route what are some of
the design decisions we'd start to take
based on our express goals and the first
one the biggest one that had kind of the
most impact of the design of the
language was dynamic typing and in some
sense it was much against our own will
right we wanted the system you know
writing everything and go you know we're
very happy that you get these like great
feedback from the compiler when you have
static types and this is just a lot more
sane as a developer but what we found is
it's just so much friendlier to
non-programmers if the design is if the
type system is dynamic that it was
almost just became a no-brainer right
the whole like explaining a type system
to someone it really just sort of
derails the whole thing pretty quickly
and so it's like okay just from a
pragmatic standpoint of the people we
expect to be writing this don't want to
deal with a type system we have to sort
of hide that from them the other thing
that made it much much more complicated
is sort of external integration
right so if you start sourcing data from
external systems to make policy
decisions and we'll talk about what that
looks like it becomes a lot harder
because now you need sort of schemas
that expose like okay this is what the
format of the data coming in from the
other side is going to be here's the
types that you should be expecting and
then you start getting really weird
errors when the types mismatch and again
you're dealing with people who aren't
sort of familiar with type systems and
so they're getting like typing errors
and so they really don't like that so
then you know here's a quick snippet and
we'll get into more of the syntax of it
in a little bit of what what Sentinel
actually looks like one of the other
things that was important was this
notion of a first-class rule so I've
sort of bowled with them here is that
these are actually first-class to the
language itself right and we'll talk
about sort of like why right why have
this notion of a rule you know in some
sense rules are actually equivalent to a
function so the language also supports
functions defining and calling them and
so why bother with a specialized
construct well it turns out a one side
functions seem sort of scary to people
it goes back to the sort of friendliness
they're like it makes it again seem like
they're programming versus when you're
like no no you're just declaring a rule
then all of a sudden it doesn't seem
like you're writing a program and so
it's like we can just rewrite it to
being a function without them realizing
it's just kind of syntactic sugar the
other things that became nice about
having this thing is a first-class sort
of a construct is just by watching how
people would translate their sort of
written policies into actual policy as
code is it's incredibly redundant right
like if you've ever read one of these
sort of compliance guys it's sort of you
know every sentence sort of repeats 90%
of the previous sentence and so when it
gets translated policy as code it kind
of looks exactly the same as like most
of the code is like highly redundant and
so what we were what we did once we sort
of built out this notion of a
first-class rule is to make it lazy and
memorized right so we actually only
evaluate the rule if there's some other
rule that's referencing it that we have
to get to and so if you have these
incredibly redundant rules that really
only apply under specific situations
you're not evaluating on most of them
you just sort of skip the rule entirely
and then you can memorize them so that
you're not getting this performance
penalty for basically expressing the
same logic over and over and over again
and this is particularly important when
you start talking about sourcing things
from an external system so an example of
where we would see things
like this all the time is maybe you have
a rule that's like you know we're gonna
call out to some external system with
some expensive calls so we're going out
over the network we're gonna query some
system it's gonna take 20 milliseconds
to get our response back and then maybe
we have some other rule that's saying
like are we in an internal override and
you'll start seeing things like this all
the time where you're like external
ready or not external ready an internal
override and so if you didn't memorize
this you start making you know this
redundant call over and over and over
again times 10 per policy evaluation and
so yes you could sort of just have them
define it as a function and then
memorize that value into some other
variable and reference that variable but
then it's like that becomes a very
programmer II way of thinking about it
like they would not think to I'm gonna
write a function and then memorize its
value and then use the variable like
they just don't do that and so in some
sense by just wrapping it in this rule
and doing this behavior for them
implicitly they can sort just do the
rote translation from here's the word
document into the rule without getting
the sort of performance penalty it's
like they can sort of just translate in
it and it sort of does the right thing
they get sort of optimal performance the
other big one was this notion of
dedicated existential operators so again
this has just become syntactic sugar you
could do this by just having a for loop
in the language has four loops but it
turned out that so many of the policies
that we'd see basically fall into these
two categories where you're like all of
the artifacts that we're deploying to
production must come from a trusted
source right or any of the tags on the
instance you know one of them must be
the billing ID or the tenant ID and so
it turns out most policies are sort of
like any of all of type of expressions
that's very rare that's like a half of
the things we deploy should be trusted
the other half like whatever so you just
don't see that very often and so in some
sense these things are just again
syntactic sugar around for loops and
maintaining basically a boolean sort of
counter and then doing some
short-circuiting if possible the other
one that was big was just plain English
operators right so in addition to sort
of the standard like you know equal
equal double pipe all of those things
just having the sort of pythonic English
equivalent of andor contains in makes
the policies both a lot more readable
and it just seems less scary to people
coming in so all the traditional
operators that are the equivalent are
all there as well so if a developer is
sort of working on it it won't feel like
you know and knowing that it's totally
retooling it but for folks that are less
familiar who want sort of a more
friendly looking syntax they can use the
sort of more English operators the other
one that was big from the design of the
language was how do you handle errors
how do you actually handle things that
don't make sense right you know there's
a few different sort of paradigms that
we've seen borne out in terms of do you
just return an error do you have you
know you know an exception workflow and
sort of control flow around that do you
return undefined values so there's a few
different things there but at the end of
the day errors exist and you have to
deal with them somehow you must
propagate the error and so the direction
we ended up going with was this notion
of sort of the infectious undefined
right is that if you hit one of these
errors the result is actually just an
undefined value and that value then
interacts with other operators by
causing sort of more undefined results
and the idea here is oftentimes what we
found is these undefined values would be
escaped by other higher-level boolean
logic right and so most of the time they
the undefined actually just gets dealt
with sort of naturally and then
otherwise there's an explicit operator
that will deal with it so I'll show you
what I mean by this so here's an example
of a policy where we expect valid bar to
get basically evaluated as undefined so
here very specifically we're sending the
object to null but you can imagine the
higher-level system may be object it's
sort of a request object so there's a
request being made to the system and
we're sort of introspecting on this
request to be like you know did this
particular value the user pass in is it
equal to 42 well what if they didn't
pass in that value right or the request
isn't fully sort of properly formatted
this is going to be undefined so instead
of exploding what will happen is valid
bar just gets lazily evaluated and saved
as being an undefined value and that's
fine because then valid time maybe is
actually valid maybe it's after 8:00
a.m. and so when the rule evaluates it
hits this clause that's basically valid
bar valid time which is undefined or
true right and sort of anything or true
logically is true and so the system sort
of escapes being in this undefined value
right because it doesn't really matter
what the value of valid bar is because
the higher logic is higher level logic
is saying I don't really care what the
value of bar is as long as the time is
valid and so we sort of end up escaping
that
and then if we're in a situation where
neither bar or time are valid and then
the else Clause is sort of an escape
because undefined or undefined
it's a becomes undefined itself and then
else basically the operator acts as you
know if the left-hand side is undefined
take the value of the right-hand side
and so will sort of escape the fact that
both of them are undefined and end up at
a false value and so it makes it a lot
easier when you have these deeply nested
sort of rules where you're just
introspecting on these deep structures
and saying like you know doesn't match
what I think it does to just get this
undefined value that often times get
sort of naturally papered over by a
higher level kind of construction cool
so now I want to do a sort of just like
a brief tour of some of the syntax we
won't make this exhaustive the
specification is online so feel free to
check out for the extensive syntax but
some of those sort of is sort of just
showing off kind of like what the
higher-level kind of constructs and
ideas and how this translates from sort
of the design principles so here's a
very simple policy which is basically
just arranging over a set of object and
it's saying hey every one of the objects
that we get must validate against this
particular reg X it turns out this is a
really common type of policy that you
see which is like I want to canonicalize
all of my inputs it should kind of look
like this and I just want to make it
easy to sort everything is like that and
so this sort of shows both the power of
having that sort of existential all
operator right makes it a lot easier
instead of saying like you know all true
and then doing a for loop and breaking
out if it's false and doing all that
instead it's also it becomes a one-liner
and then Matt shows doing sort of a
regular expression against a string
we've integrated as as a native sort of
operation so if you use the match
operator it expects the right-hand side
to be a reg X and it compiles that and
saves that as so that you're not
recompiling the regular expression all
the time and so this becomes sort of a
really easy rule to understand what's
happening here here's one that shows
kind of more of the sort of standard
programming constructs of it where it's
like we actually have a function call
and we want to do sort of a traditional
for loop and increment a counter it
still ends up being pretty simple we'll
start out in sort of our main rule block
and then we can call into a function and
we sort of have the normal kind of looks
like we're just writing Python almost
and then here's a little more of a
complicated one looking at basically
what if we want to restrict you know in
this case or vaguely based off of
terraform you know what
the sizes of instances that we're
actually allowed to deploy and what are
the regions were allowed to deploy in
depending on if we're in staging or
production so here we basically have one
set of rules that's checking you know
are we deploying into the right region
based on the environment that we're
currently in and the other ones checking
are all of the instances you know the
correct size right and if those two are
valid great this sort of infrastructure
as code definition looks good so that
covers sort of from a high level the
kind of design principles behind the
language a little bit of what the syntax
looks like hopefully gives you sort of a
flavor for it so as the actual runtime
of centinall look like
we decided to keep it very simple and so
you know it's almost as simple as
something like this can get and we'll
sort of talk through that it's pieces
but it has you know standard lexer
parser semantic checker that it uses a
sort of an evaluator interpreter and
then it has a built-in standard library
so the lexer parser is actually pretty
heavily borrowed from the way go does it
they do a really good job maintaining
sort of all the offsets and providing
sort of user friendly error messages in
terms of like where a syntax error
happened and sort of collecting multiple
errors at a time instead of bailing on
the first one and then supporting a
negative sort of writer or a thumped
command so there's sort of one true way
to do it you know this has been
something that we've loved at Hacha corp
is that there is no sort of religious
wars about what is the correct format
it's like there's one source of truth
and it's whatever go font says it is
right and so it doesn't really matter
you know what your opinion is it's like
run it through go thumped and so we
wanted to have that same sort of thing
where you don't have a sort of battle
around you know what's the right syntax
for this policy it's like who cares
right to however you want then run it
through font it always comes out the
same and so this canonical format we
found it to be really nice and we want
to bring that over to sentinel as well
the other one that is once we've
actually parsed it and built out the ast
can we do some amount of syntax
semantics checking to ensure the program
you know won't explode once we're
running it and so this gives let gives
us an opportunity to kind of give an
early warning to users for any obvious
type errors any sort of obvious like you
know it doesn't make sense the way these
functions or rules are being referenced
making sure the main rule actually
exists so you've defined a policy that
can be enforced if you're importing
things that the imports are actually
valid and available things like that and
then it gets into the actual evaluator
it's
so the evaluator operates directly over
the ast today and there's some stuff
we've sort of talked about around you
know eventually do we do some amount of
sort of translation to bytecode or even
you know potentially getting it but for
today it's it's a pretty basic ast
Walker and there's a few things that the
runtime does one is as we mentioned kind
of that rule memoization so we see very
very redundant sort of evaluation of
rules so how do we make sure that we're
sort of just memorizing policy caching
so tends to be that you're evaluating
the same policies over and over and over
so caching sort of the parsing of the of
the tree and we'll talk about imports
but there's a lot of work around making
imports efficient because it turns out
you know spending up-and-down plugins is
sort of time expensive so we'll talk
about that in a little bit and then
sandboxing is a big one so because this
is embedded and running within the
application we want to make sure that
you know you can't run for an arbitrary
amount of time you can't use an
arbitrary amount of memory your stack
depth is limited and so these things are
operating in a pretty small sandbox they
really can't do a whole lot outside of
that and then sort of the final piece is
how do we avoid user functions right
user functions really just begin making
the system feel very programmer e and so
oftentimes we want the policies to be
able to be written entirely with sort of
built-in functions and so it's important
to have a standard Lib to sort of escape
that right so for a lot of the common
things that we've saw was things like
you know dealing with time dealing with
math parsing of cider blocks like is
this IP and our corporate network things
like that manipulating strings so as
many of these things that we start
seeing as sort of a common wheel of
policy bringing that into a standard Lib
then there's a notion of sort of
enforcement levels right it's not that
sort of all policies are created equal
and so what we found is you know you
want to have this sort of awareness of
at least three different levels of
policy advisory soft mandatory and hard
mandatory and basically as an advisory
policies kind of what it sounds like
right it's allowed to fail and what
happens if it does fail is we just
provide a warning and so these can be
things like you know what this type of
instance class is deprecated the user
should just know that we'll just issue a
warning if they're provisioning it but
otherwise don't stop this action from
taking place the next level becomes
something you want to stop generally but
there might be circumstances that you
should be able to escape that
that policy right so a great example of
this is like don't allow changes outside
of business hours
right so you defined that window but it
might be that the site is actually down
at 2:00 in the morning and there's a
good reason to be doing it to play
outside of business hour and so if it's
a soft override policy you can set an
explicit override so you as a user are
still acknowledging that yes I know this
is in violation of the policy but I've
acknowledged that and I'm overriding it
as long as you have sufficient privilege
to do it and the last category is things
that you just cannot override right it's
like they must pass there's no escaping
it it's things where like your
regulators are gonna be really unhappy
like every key just has to be 128-bits
like sorry and so this is all integrated
into sort of the runtime it has this
awareness of this because it changes the
way you'll do short-circuiting right so
if an advisory policy fails you can't
actually short-circuit you have to keep
it valuating with other policies but if
you get to a mandatory hard mandatory
policy that's failed there's really no
point in bothering to evaluate the rest
of the policies like you're not gonna
let that request through anyway and so
by having this it's sort of lights you
break it out into these smaller you know
smaller policies as opposed to these
monolithic policies and just install a
ton of them to handle all the different
sort of use cases and so this really
covers kind of the runtime which is
designed to be embedded so by being in
the data path it lets us do this sort of
active enforcement so you don't have to
detect sort of post hoc that you've
deployed something that's in violation
you just prevent it in the first place
but then you end up with this
interesting question which is like how
do you actually develop and test these
policies if it's embedded right how do
you deal with it so this is where the
simulator tool came from is how do we
actually let that user experience when
I'm writing this be a lot nicer and so
the simulator has a few commands one is
sort of apply to be able to actually you
know test the policy and interact with
it one is Doc's so it sort of has a sort
of a canonical format of documenting
things and sort of emitting a
documentation around the policy the
thumped to have that canonicalization
and then tests which we'll talk about
provide sort of a test framework around
policies so apply kind of does what
you'd expect it to do you can pass in a
policy and I'll show you the sort of
execution trace of it to be to sort of
debug and interactively work with the
policy and understand you know why did
it pass why did it fail and so I'll give
you some feedback in terms of like what
were the clauses that caused your
overall policy to go wrong but that's
really only useful when you're like sort
of like a lie
writing it testing and that sort of like
interactive write test loop what you
eventually want to do is kind of exactly
what we do with software which doesn't
have sort of test Suites and regression
testing right so how do we actually
start defining tests so that we can you
know under situation a B and C the
policy should pass and under XYZ it
should fail and so we have sort of this
layout where you can define a four year
policy sort of the passing tests on the
failing tests and then for each test you
basically can assert you know given this
mock input so if the time of day is you
know this you know I expect the overall
policy to go false right and so you can
set up all the different scenarios and
sort of stress test the kind of edges of
the policy and then you just run the
full test suite over it so for a
particular thing you can run all the you
know supposedly passing supposedly
failing tests and make sure that
actually matches and though the goal of
this is you kind of do the same thing
you do with code which is put it in a CI
system so as you're writing and testing
policy if you're like I'm gonna add this
new clause you make sure it doesn't sort
of break the system right that it
doesn't invert allow behavior it
shouldn't so the last piece is the
import SDK is how do we actually allow
you to make decisions based on external
information so oftentimes what we find
is that policy decisions can't really be
made in isolation it's sort of a
coordination across multiple different
systems and so you really need a blade
to sort of source information from an
external system and use that for a
policy decision and so this is was the
goal of having an import SDKs it allows
that you to sort of define your own
plugin and then use IPC to basically
query these external systems and so the
runtime you know I mentioned it does
some work to make this efficient because
as you can imagine forking and exacting
a plug in for every request would be
pretty prohibitive so the runtime does
some things around you know fork it ones
maintain it if it's not used for some
amount of time garbage collected and it
multiplex multiple requests to the same
plugin so you don't need 500 plugins
running at once and so the goal really
ends up being a few fold one is that
over time we want to have sort of an
ecosystem of these of these plugins for
common systems but then it makes it
possible to integrate with your custom
internal systems and you can sort of
also extend it with arbitrary logic so
you can have a plug-in in some sense
there's not calling out to any system
it's just implementing sort of user
defined functions and some of the stuff
that we see that becomes neat about this
is the sort of crossest
protection right is that if I submit a
job to be scheduled you know to my
scheduler and say I want to start a web
service that thing can then call out to
the configuration system and say you
know is the service actually configured
are you trying to launch a system
without any configuration set for it in
which case reject it and then likewise
are you trying to delete configuration
for a system that's currently running in
production like you can't delete the
configure of a running system right go
stop the system first and then you can
go delete the configuration for it so
sort of the high level use cases that we
think about policy is code is at least
these sort of three big ones that we
used to come out one is this notion of
how do we have these guardrails around
infrastructure as code right how do we
get back to that sort of somebody as
sanity checking when we ask for 5,000
VMs the other one that we find is very
useful for simplifying the compliance
story is just instead of a detection and
remediation workflow you just prevent
the activity to begin with it's just
like now we don't need to worry about
what a remediation looks like and last
one is this sort of like fool me once
shame on you kind of a thing which is we
all make mistakes but how do we keep
ourself from making them again and so
sort of talk about that and so this one
sort of we've talked about a few times
it's really about defining that sandbox
and imposing the sanity checks without
having kind of a manual process the
compliance one is really about
translating kind of the word document
form into an actual codified form and
that way we can automate the enforcement
of it and so really what it lets us get
to is the sort of ounce of prevention
scheme right so we're not dealing with
now we need the sort of our early
detection of anything that's not a
violation if files are taken and pages
you and now you have to go kind of
remediated and and sort of you know let
the auditors know it's like well it just
couldn't happen and it didn't happen and
then this last one is really realizing
that Paulette the policies will never be
exhaustive there will always be sort of
the edge of the sandbox or some way to
screw something up in production and so
in some sense what happens is oftentimes
we stub our toe and then we're like okay
I'm going to remember next time you know
not to deploy a service without you know
actually having configuration set for it
the problem with that is our memory is
finite right and there's only so many
things that we're gonna recall to check
and make sure like OOP did we handle
that edge case and so in some sense this
gives us a framework to codify against
that so yeah the first time I deployed
my you know instance to production
without configuring it shame on me the
second time around I wrote a policy so
the system was like no you didn't
configure it
at first right and so it's sort of much
easier to scale the set of policies than
it is to scale our memory right so in
conclusion you know policies code really
is building upon this existing kind of
idea of as code is how do we take these
processes codify them have the single
source of truth and sort of get all the
codification benefits so it's sort of
shared with everything about
infrastructures code shared with what
we've learned in software development
and sentinels just sort of one play at
it it's our sort of stab at doing this
policy use code thing and it sort of
composed of a few different pieces and
our view is sort of this is what it's
going to take to get to that next step
in infrastructure automation as having
more of these guardrails so that we can
do it you know with some sense of
comfort instead of saying there's three
people that we trust enough to actually
go out and automate this and that's all
I have thank you guys so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>