<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Faster Objects and Arrays&quot; by Gil Tene | Coder Coacher - Coaching Coders</title><meta content="&quot;Faster Objects and Arrays&quot; by Gil Tene - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Faster Objects and Arrays&quot; by Gil Tene</b></h2><h5 class="post__date">2015-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rEs6UdWByKw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone we're going to talk about
faster objects in a race in Java it's
it's a I find it hard to give this a
good title and the the subtitle here is
probably a good description of what what
this project is attempting to do Java is
fast it's actually pretty fast really
fast compared to what people think it is
but there are some inherent things about
a language what you can express in it
that make certain things inherently
slower with Java than they are in some
other languages like C C++ things that
give you a little more layout control
and object layout is a project that aims
to close that gap and I think it's
actually the only remaining inherent gap
in speed between Java and C based
languages when I say the only inherent
speed gate gap I'm not saying that this
is the only gap in speed I'm saying it's
the only one that is inherent to the
structure of the language and to what
you can express in it well we'll get
into some detail this is a
forward-looking talk this is stuff we
are proposing to add in a future version
of Java but there is working code with
working proof that it actually does what
I say it does so we're actually very
hopeful we can put it into a future
version of Java I think Java 9 will be
somewhat ambitious although we're still
going to try but Java 10 I think would
be a good target I'll talk a little
about me and then get to the actual
subjects my name is Gil tenor I'm the
CTO and one of the cofounders of Azul
systems I've worked in lots and lots of
things around Java for the last couple
of decades and lots of other things as
well one of the things probably people
know me a lot for is garbage collection
and Azul we solve garbage collection we
think it's done we solved it so you
don't have to and that's it we have a
very think different kind of approach
everybody's been doing that for 20 years
we went the other way for
the solution so you don't have to do any
of that anymore but that's not the
subject their talk here except to say
that I'd like to play with garbage
collection for this you've seen suddenly
talks I apologize that I keep using the
same picture but it's only cool funny
one that I look younger didn't I know
this is a trash compactor in my kitchen
it wasn't working I had to fix it the
job of a trash compactor is to perform
minor G C's during the week so the full
GC where you pick the bag up enough to
go outside in the dark only happens on
the weekend in this case the compactor
was broken the defrag function on it
wasn't working and there's a fragments
that were stuck in it I had to affect to
get him out and compacted and all that I
thought it would be funny to take a
picture with the actual GC book at a
time and this was 11 years ago so I've
been thinking that's funny for a while
beyond garbage collection I've played
with lots of other things I've build
virtual machines and physical machines
helped design CPUs operating systems
drivers kernel stuff firewalls and
switches and subscriber management
systems that manage millions of people
and basically we had to build our own
app server in the late 90s because that
wasn't around yet you know all kinds of
stuff up and down the stack so I've made
a lot of mistakes and I've learned from
some of them one of my favorite things
to do is go around telling people how
bad they do stuff about measuring
latency and response time and that's
another subject they spent a lot of time
on but again not the subject for this
talk what we'll talk about today is
object layout this is a project that we
started a couple years ago he first
presented this at the JVM language
summit one year ago and it's it seems to
be a popular subject since so you know
I've been bringing it to developer
forums one more object layout is
basically about matching the speed
benefits of C in Java for the specific
things that have to do with memory
layout with the layout of memory and
speed that comes from or that hurts
because you don't have the right memory
layout involved um we want to expose the
benefits of memory layout to Java in a
natural way to regular Java objects Knox
do some new syntax that only works for
new code so this is an approach that's
very holistic for all of Java rather
than than other things and the idea here
is to look at speed nothing else just
speed for regular Java objects on the
heat this is a mantra there's just what
I'm saying it slow its speed regular
Java objects on the heap and I'll repeat
it a few times in the next couple of
slides because the next several slides
are going to be about what this is not
about this is what it's not about okay
in the context of object layout we could
care less about footprint I am NOT
trying to reduce the footprint of memory
I'm trying to not trying to save memory
I'm not trying to pack bits together a
bytes together or get a few more words
into a cache line this is not what it's
about
I'm purely looking at speed not at
saving memory or saving other work this
is not about off heap solutions I
already mentioned that garbage
collection is simply a solved problem
it's silly to waste engineering time
trying to work around it again but yeah
I understand other people still want to
do that this is not what it's about it's
not that it's wrong it's not that it's
right object layout is about speed for
regular Java objects on the heap do what
you want off the heat but not with this
and then it's also not about
immutability immutability is really cool
you can do a mutable stuff with object
layout but you can also do mutable stuff
this does not have a mutable immutable
religion in it okay and it does not come
with if you bind to the mutable the
immutable way of life then this is good
or if you have tiny little structures
then this is good so all these are not
good or bad they're just orthogonal they
have nothing to do
what I'll talk about today and there's a
reason I highlight this and that's
because for the last couple years every
time I raise this subject people say oh
you mean like value types or you mean
like packed objects or you mean like one
of those things so I find myself
explaining why it's not like that and
here we're gonna explain why it's not
like that for two or three slides then
you can stop with that okay so the
relationship to value types is zero the
only types are really cool I can't wait
for them to be there in Java I want to
use them for so many things but this is
not one of the useful things you could
do with value types it's also got no
relationship to packed objects or Jnr
FFI which have their own very good use
cases for various things like calling
any native library without having a
write wrappers or efficiently dealing
with memory that is not on the heap like
graphic card buffers or communication
systems not that and not our concerns
here this is laser focused on the
problem and what's the problem speed for
regular objects on the heap okay so
there's no conflict between this and
other projects you can do both
there is almost no overlap but some
overlap always exists you can for
example do some things in value type so
you can also doing structured around
object layout and you can also do with
packed objects but that's the same as
you could use an ArrayList and a hash
map to store objects there's overlap
there that doesn't mean that that it's
wrong to have the overlap they just have
different qualities and purposes and you
just want to use the right tool for the
job a pictorial way of this looking at
this more of a Venn diagram there's
value types object layout in packed
objects you know an FIA group together
so we look at what they are and what
they're for value types are for on heap
stuff um young heap they are very useful
for on stack things passing parameters
getting return values that have
more than one thing in them don't you
wish you had that forever tepals
you know they're very very useful for
that without having to create objects
not just from a syntactic point of view
but from a work point of view very good
for that great for that in fact I
believe that value types will be amazing
for on thread local thread operations up
and down the stack parameters and the
rest little things that you pass around
the thread as well but once you put
value types in the heap they have
interesting limitations value types are
going to be me to pull the Java notion
of value types is not say the c-sharp
notion of value types they're very
different things that often leads to
confusion value types in Java are going
to be immutable things that need to be
changed atomically so if you cannot see
a partial value if I replaced your
immutable thing you see the new
immutable thing when unthread without
concurrency that's a very easy thing to
do
when you start putting on the heap you
start running into issues like wait word
tearing I have five words I write the
think at 70 see half a word and that's
not allowed
and there'll be interesting solutions to
that some of them will evolve just
boxing the value types in heat or
synchronizing them in some weird way in
the JVM we don't quite know which it'll
be but value types are going to be great
not in the heap so much but in the
parameters that we run around the stuff
packed objects give you precise layout
control on exactly where things will be
within a structure of data an object of
bits and and give you that to a very
fine degree and there's a really really
good reason to do this because sometimes
you talk to things they're not Java and
TCP likes to have the protocol byte here
it's not up to to JVM to decide where to
put that you have to explicitly lay it
out whenever you're dealing with some
other data string under than Java you
have to describe the layout of the
actual memory you're communicating with
and the structure of it and many many
ways to do it packed objects is a way to
try and express that from within Java
mrs. stem acquaint now it does that very
well for off heap it actually has a non
heat version and the common use cases
are their object layout is speed for
objects on the heap right now one key
key differentiator is going to be this
with value types it's going to be for
new code once you have value types you
write new type new things that are used
value types and only other cool things
that know how to read value types can
look at your new things so this is only
for new code right fact objects the same
thing with object layout we're looking
at doing this for pojos we're looking at
letting these things participate with
things that we've written eight years
ago and can take one of these things
could take objects that are in one of
these things they already know what to
do with them there is no special need or
special understanding or limitation and
what you could do with it you want
unlock that objects go ahead I don't
know if it's a good idea but you could
you want a hash code on that object go
ahead no limitations it's a full-blown
Java object and its members are that too
okay
that was a that was a lot of what this
is not and please don't confuse it with
others there's the overlap an array of
small footprint things right immutable
values especially but let's look at the
origin and why this is actually being
done this came out of an argument
actually Martin Thompson and I had a
long long argument he reminds me that we
sat in my car it's out of his hotel
until 2:00 a.m. and the argument is a
common one it's not the first one I've
had it it's not the last time we'll have
it it goes something like this on the
one side you say we really need structs
in Java why because look at all the
stuff that high-performance people end
up doing to Java or wit Java just
because we don't have them we build
these off heap byte buffers or in--he
byte arrays and we run these flyweight
things on and with cursors that make
something look like an object with an
API but actually
bits are spread across different arrays
or within an array and in everybody does
this themselves because there's a
library for it and there's no standard
way to do it and the compilers don't
understand what you're doing sort of
optimizing it as well we just need
structs just add strips to the language
it's a natural thing right and I think
that's a pretty good argument but I like
to be contrarian so I came in with this
you know let's look at this we actually
have something that's a struct in in
Java it's called an object it's a struct
and then some it's it should be able to
do everything you want in a struct in
more it shouldn't be less there's
nothing inherent to an object that makes
it weaker than a struct in what you
could do with it what we're actually
missing is the right speed semantics to
let your code go fast when it deals with
those trucks and that's what's actually
wrong here so Martin and I like to argue
and then we like to actually figure out
who's right and I think neither one of
us was exactly right but Martin took on
the thing of let's try to code this and
then I took it over from there and we
basically started coding code in Java to
see if we can capture semantics right
and came with the notion of exposing the
enabling semantics limitations that give
you speed as the key thing we're looking
for in that code and it's not about
adding features it's actually about
taking them away so that the result
would be legitimate to optimize in
certain ways it's the fact that we have
too many options in certain data types
that prohibit certain operations you
know get into specifics here where the
speed come from where the speed were
interested in here see layout has two
dominant factors that give it speed the
first one is what we call dead reckoning
the ability to get to some memory
location without having to jump through
other references on the way there so for
example when I go in an array of
structure struck number 17 field X I
don't have to go through a pointer I
just know it's 17 17 times size
Plus sex and it's right there right so
you can dead wreck into the address
without hopping through memory that's a
huge speed boost how both for random
access and non random access the other
one is streaming if you lay out an array
of things and they are strided correctly
in memory then prefetches are going to
do an amazing job for you
you just run ahead of you if you have
any kind of access pattern you don't
even have to say it's there CPS will
detect your stride and run there three
different professors the right way for
you and what's actually happening there
is the CPU will burn bandwidth to reduce
your latency and hopefully not burn a
lot of bandwidth because you really
weren't gonna use it so while memory is
hundreds of cycles away when you know
that the next 17 operations are also
gonna do the same thing they're on
flight on the way to you and when you
need them they're already in your cache
that's what streaming gives gives you
there now both of these come naturally
out of flatter memory structures and
they're natural to express in languages
like see an example of that limitation
can be seen in the difference between
objects arrays in Java in arrays of
struct and see their syntax is somewhat
similar but one of them is inherently
faster let's look at the actual
semantics of what this means in Java an
array of objects is a mutable array of
same base type objects mutable because I
reek I can replace any member anytime I
want I can deposit a new object a
different object that cell number five
than there was there before so I can
mutate what is in there ray and same
base type because the base type here is
object we can get make an array of
points that tells you there are points
in there but they can also be subclasses
of point in there it's an
object-oriented language and as a result
we don't know what the size of a point
is in our array in C we have an
immutable array strange to hear
immutable and C together but it's an
immutable array of exact type object
it's immutable because element number 17
in an array of structs is element number
17 an array of structs there is no way
to replace it that's what it is
you can mess with its content you can
make mutate what's in it but not what
number 17 in the array is which is why
you can compute its address from the
array address it's exact same type all
the structures same size which allows me
to figure out that number 17 is 17 times
size if I didn't know what the size of
each element as was exactly there's no
way to compute the address of number 17
we're no good way no easy way mutability
and non-uniform members are what hurts
both the dead reckoning and the
streaming capabilities the reason we
have the know speed the capability to
match here is because both of those are
options in Java we don't know they're
not happening so we actually have to
assume they might be and we have to
actually find and follow the reference
to number 17 rather than in computing an
example of capturing the semantic
limitations is here a structured array
of type T this is a Java collection and
object layout is an immutable array of
any Java object as long as its
constructible that the object could be
mutable or immutable that's up to you
it's very common for them to be mutable
in actual use cases but they are exact
same type like an array of points is
array of points not an array of
subclasses of points and that's very
simple to capture by simply saying you
can make one of these you can get
elements from it but you can't put
anything in it if you can't put anything
in it you can't change what the classes
are and you can't mutate it when you
create it you say what type it is it'll
go ahead and make all the members of
that type that they're not going to
change later that's a simple example of
capturing the limitations in once you
capture them that collection can be
optionally depending on your JVM laid
out exactly the same as an array of
structs would be because it's valid to
do so
it's no longer wrong to do it because
there's no way you could change we're
number 17 is so it's valid to do it that
way that's an example of this now the
target forms that we looked for object
layout are three they're commonly used
cases for for laying things out I just
described an example an array of structs
a struct inside a struct there's another
common thing a flat structure rather
than an object that points to another
object and the last one is a very common
one and messaging communications other
things
it's a struct that has a dangling an
array off the end variable size dangling
array a message strength yeah things
like that right now you can express the
equivalent logical relationship of every
one of these in Java today there's
nothing that stops you from modeling
this but you can't match any of these on
speed in Java today we can express them
but our expression has too many cool
options like mutability and different
sizes and that means the layout is not
going to be flat it's gonna have to have
references and e references in it and
we're gonna capture all three of these
with object layout so the starting point
has some rules in it we actually try to
look at this as something we want to
adopt into Java the language or actually
as you'll see not the language Java the
spec so we want to capture all these
semantic limitations create the right
data structures for them that give us
the right contracts and the theory is
that we could do it with zero language
changes so not Java the language but
Java the spec you know we want a library
in Java that has these semantics if you
use them JVM knows what it is and will
make it go fast so we'll capture this
it'll work vanilla on any JVM starting
with Java 7 I initially targeted Java 6
but as you've seen some of the code
later Java 7 has some features that are
useful for helping construction and
visibility and then we want to have JDK
s have
the option to say I know what this is
I'll lay it out right and normally could
go fast that's an option it's not
required the code will work the same way
either way in fact the vanilla and
intrinsic ID implemented cannot behave
differently except for speed the idea is
to capture the spec of the data
structure it's not the underlying
behavior and implementation but the spec
needs to be carefully selected to enable
optimization
right now we have respected prohibits
optimization of these layouts so the
model for this is probably the most
successful external contribution to Java
in its history Java util concurrent
similarly started with Java sucks on
certain things let's change that came
from outside of Sun Oracle Dudley and
Friends and it captured the semantics
that allowed good concurrent operations
how many of you use Java util concurrent
before is it what's called that so you
know what I'm talking about
you know you unius juego some people
still have that code around right so you
capture it and then you don't make
language changes you just have libraries
Java util concurrent to this day does
not have any language features in it
it's just the library and you implement
it in vanilla code it might be slow I
mean you can do an atomic long compare
and set with a monitor with a lock it's
not fast but it'll work and it'll do the
right semantics right and then you teach
JVMs that you know that's what it means
let's make it go fast and that's one
instruction that's up to the JVM to
optimize and one important thing is you
move that into the Java namespace so
it'll be stable so G VMs can really know
what it means
stable and you also get safe access to
things like unsafe under the hood that
allow you to implement it with space
rather than require you to employ I look
at that as a model we're trying to do
the same thing here in structured array
we'll try and follow the same rules
right no language changes vanilla
implementation and then capturing
semantics so that jaebeum's could
and transfer them we talked about this
form and structured array is the next
deep dive we'll go I want to go into
that structure and explain what it is
exactly
structured array is just a Java
collection for this type it feels like
an array so that's why it's called that
and structured because we didn't find a
better name it might be a wrong name I
don't know but you know we could just
say a righty
but you know then don't confuse people
it's a collection of objects of type T
everybody does collections the Java or
reg aneri should know what that is
it's arranged like an array so you can
sort of assume that it's got you know
good get index that doesn't have to walk
a linked list but no that's that's an
implementation detail the collection is
immutable you can't put in it it's got
to get right and you can't replace
elements right and you instantiate it
with a factory so when you make it the
collection and everything in it was made
like that that's kind of a requirement
if it's immutable it's hard to do it
other ways and then almonds are
constructed added stenchy ation time and
you can't touch them later now the
interesting thing is when you look at
how to actually offer this and look at
use cases you come up with all kinds of
cool ways people want to instantiate
things inside because i have an array
with a thousand elements they're gonna
be constructed when i instantiate
they're right how should they be
constructed so yeah there's the easy use
the default constructor and everybody
yeah but what if you need to pass them
parameters what if they have final
fields what if their values depends on
their context like their position in
their array so all these things are
taken into account and supported we have
this thing called a constructor and args
that we created to do that and this is
an example of context based creation of
an array suppose I have this class doof
and it's got it kind of knows what its
indexes in the container because it
wants to write I don't know why but it
wants to and here's how I create sorry
here's a I get the constructor and I
want a length of eight and here's the
code this is strange it rolled off the
bottom okay here's a code I think
there's a missing line there but okay
here's the code for actually
instantiating this array there's a bunch
of spelling here hopefully you're not
too crude but I'm making a new instance
of structure to write and actually this
should have been the mock structure yeah
but over here we're basically based on
this context constructor and orange will
use that constructor and index of the
context as a parameter to this so that
they'll know what to initialize for in a
final variable in the member that's an
example of the kind of weaving you might
do I'm showing it to show you the level
of complication you could add if you
want it's not this complicated if you
don't need to pass context based stuff
into your members but you can we're
trying not to limit what you could
construct in there a very important
quality of structured array that took a
lot of design thinking is liveness when
you have a collection and remember we're
trying to keep it all together in memory
right pseudo work right is this when
when we started this we thought that
basically if you have anything alive in
a structured array the structured array
would need to be alive as a result and
the reason we thought that is that's how
every runtime that implements inner
pointers to structures actually works
either every other one time we've looked
at so if you in any runtime not Java but
others have some bigger structure and
you allow a reference to a field in it
or a reference to a member of an array
that inherently keeps the container
thing you point into the middle of a
live because because it'll be a problem
if it isn't so we started from that
design and looked at how do we support
that on the hood what are the semantics
that are needed it gets very complicated
and then how do we tell programmers that
this is happening and
stop surprising them and all that and we
were about three or four weeks into
thinking about this when when Michael
one of her GC guys kind of said remind
me again why we're trying to keep the
array alive and answers because that's
what everybody else does isn't a good
answer it's why did they do it
and it turns out that the reason people
do it is is because that's the only
thing they have liveness on if you point
to an integer in an array an integer
doesn't have liveness so you need to
take the closest thing that has liveness
is keep that alive he took point to or
to a member of an array or struct and
all that but our members are objects and
objects have liveness already and more
than just having likeness they have
intuitive relationships to their
collections so a structured array is
just a collection it's not something new
and surprising a collection keeps its
members alive that's always true but the
members don't implicitly keep the
collection alive
it would actually be surprising if I
made a big hash map kept a million
things in it let most of them die but
one of them's alive and I still have the
million things alive because that one
thing is a lot that would surprise a lot
of people and hurt a lot of performance
right so that would be bad behavior
structure to rate doesn't have that bad
behavior
under the hard implementations will do
all kinds of things to try and keep this
together track whether or not it's
contained and move everything together
but that's an implementation detail when
you're thinking about this it's no
longer a weird thing to think of it just
naturally falls out you know what
collections behave like they feel like
collections there's no special rule here
the benefits of this liveness is well
beyond intuitiveness it's also fast and
easy to optimize for about 90% of the
work we thought we had to do was gone
the minute we decided this we thought
we'd have to teach things how to do this
relationship collectors already know how
to do wouldn't need them to do mostly
there's some things we needed to add and
then you know because there
regular objects all the rules can be
applied to them we don't have to limit
what you could do with them so locking
in hash codes and in the rest of the
stuff are not are not something we have
to rethink which goes into that you can
play with eight year old code you know
you could give your structured around an
object to somebody you can give a member
of your structured array as an object to
somebody you could take a structured
array and use a linked list that goes
through it you can index your structured
array fifteen different ways with
whatever you know how to index objects
with and it just works and it's not
surprising right
so natural right that's one of those
things where once it happens you know
it's right and until then we thought you
know we were working hard on the wrong
thing okay some more things about
structure to raise small detail
hopefully this'll make you happy we
thought you know a no-brainer right we
shouldn't even discuss it
nested behavior is supported you can
have multi-dimensional arrays and the
non-leaf arrays are themselves arrays so
for example a structured array of
structured array you can take a member
of the outer structured right and that
is a structured right it's an object you
could pass to other things you can take
your rows and index them for example
right or whatever it is you do with
multi-dimensional stuff it's also
subclass able which allows a lot of
interesting code patterns we think are
missing and we'll get back to that and
very importantly it's not constructible
now this is not because we think people
don't want to construct it it's because
to allow the semantics we need we
couldn't make it constructible in Java
when you construct an object anything
other than an primitive array the
constructor is constructing something of
a fixed size that is known from the type
and with no arguments the constructor
later put stuff in that object but the
constructor if the constructor figures
out later how big the thing is it can't
affect how much was allocated
the factory doesn't work like that a
factory could be told things and it'll
go allocate the right size and then put
stuff in it so we had to use a factory
semantics I showed you what it looks
like there it's not that strange but
there's an interesting contradiction on
the screen here has anybody noticed us
we have a subclass Abel class that is
not constructible that took me a little
while to figure out how to do because
that's is that's a contradiction to
subclass you have to expose a
constructor
if you don't expose a constructor nobody
could subclass you but we don't want
subclass thing to happen and the cool
thing here and by the way this might be
useful outside of the project if you
guys have a need for sub bless abandone
constructible things it's something I
call constructor magic it's actually
implemented under the hood and it works
on the following trick remember we need
vanilla an intrinsic copper
implementations to work exactly the same
way and I cannot let you construct a
structured array so I can't let you do
something in vanilla that I couldn't do
in intrinsic but that doesn't mean I
can't you write a call to a constructor
I just need to make sure that will never
ever work on any implementation and then
I never have to deal with it so the
implementation does have constructors
and you do expose them but if you
attempt to construct a structured array
the base class would throw an exception
at you the only valid path for
constructing a structured array is one
that comes from within the factory and
there's constructor magic under the hood
that keeps track of that makes it
impossible to break or I claim it's
impossible to break welcome you're
checking it ok I need to hurry up a
little because of time here because I
think I have about seven minutes or less
optimized JDK implementations basically
we'll need to track a new concept that
new concept is contained and contain it
containing container objects you don't
need to know about them but actual
garbage collectors and he'd need to know
about them a container object this
object that has other objects inside and
moves together
from a given contained object you need
to be able to walk backwards in some way
there's 17 ways to do this depending on
implementation to find your closest
container and then walk for walk beyond
that if you do and the main thing this
is for is that if the garbage collector
ever moves anything that is in the
container it needs to move the entire
container together or we would need to
compute addresses differently and break
all the code so that's what this is for
it's all under the hood stuff it turns
out to be very simple to implement in
every garbage collector we've looked at
and we actually have an open to decay
per ologies implementation we've got
Xing implementation but we've looked at
other collectors and we haven't found
one where this is a serious challenge
it's not zero work but it's not a new
concept that's hard hard to deal with in
addition to that there's some
optimizations needed streaming actually
comes for free once you lay it out right
streaming reggae you know but dead
reckoning needs a little more compiler
support so we don't have to dereference
to get their own in 17 right because
there's a way to compute it but this is
the way to compute it so that's a
semantically the address of element X is
the index times the element size plus
the right plus the body size because
it's subclass of all and this could be
any type well these two things are not
constant so I need to go get them from
the array that's technically as bad as
dereferencing not necessarily for each
point but still luckily there are
various implement optimizations that I
call analogies to class our key analysis
and to inline caching it's not the same
thing but it's like the same thing the
JIT compilers commonly do where they say
well yeah but if this type of structured
array only has points in it in the
entire world that can prove the size so
one constant goes away right and if it
doesn't the array doesn't have any
subclasses I can prove the body size and
then I get constants and I get the
faulting out some of these in the
implementations we have these two
optimizations aren't there yet we just
have the intrinsic it so there's some
more detail somewhere else
about this the other two I'm gonna go
through really quickly structured rains
probably the best example that look at
is one is struct and struct
I call that an intrinsic object
intrinsic not in a sense of compilers
but in the sense of English so you know
if an object instances intrinsic to
another object if you'd look it up in
the next chain it means they were made
together they have a strong relationship
to each other that's what the language
says not Java the language this is how
you say that in Java now in vanilla you
put an add intrinsic and C that's just a
regular private final something but it's
annotated with an intrinsic and it's
initialized with a factory there's a
little cumbersome spelling here I wish
we didn't have to pass any of these
parameters some Java version with a
language change might allow us to save
some spelling but these are just to make
it so we don't have to change the
language this lookup thing right there
is why need Java 7 because Java sex
doesn't have it
we are going to look at a private final
field which by definition requires stuff
for security and we didn't want to break
all security because we want to actually
move into the core libraries so we
needed to do a way to secure and there's
some details about surviving silly
things like reflection over writing
final fields and how do we do it safely
and the reality is you can't do it
safely but you need to detect it and the
optimize your code and run like the old
stuff without the optimization if
somebody was silly enough to write over
a final field a struct within a right
and is modeled this way you basically
subclass an array subclassing is a
simple way of modeling a struct that has
something else after so there's struct
with an array and it then is just to you
know for primitive arrays of primitive
array of Long's is just an array of
Long's with whatever else you put in the
subclass semantics capture what you need
and that goes all the way to primitive
references or reference to right
structured array is subclass able so a
struct with an array of structs at then
this captures distractor array already
same semantics ok we talked about the
forms these are the three forms and
their parallels these are composable
together which turns into really cool
stuff we didn't think about when we
started so I like to use this picture a
lot you have the heap in the heap you
can have a structured array of
structured array of foo inside there's a
structure array of foo foo might have to
intrinsic member bar and do and bar
might be a constant like stretch at
array of MU and this is a completely
flat data structure right this is an
example of putting it together
an octagon could have a constant length
Lang structured array of points in it
flat not be referenced the the
structured array of points itself is
naturally gonna be flat of points this
is how you go and get a point
natural syntax you can then have an
octagon Stipe that you know has many
octagons in it again flat and here you
have let's get point X of octagon number
3 point number 7 there is not a single
dereference in this line from the
address of octagons i can compute that
without going through memory and that's
the power of putting it all together
the composability is cool these
iterators are also optimizable they
don't have to go through memory there's
not necessary next next next there
there's just an increment of the
reference so notnot recomputed you know
dereferencing every time status wise
because i am short on time on a little
over time actually there is vanilla java
code up on github that works has tests
and actually has a little micro
benchmarks point written and jmh so
develop well-written and image it's
fairly mature and we've worked on a lot
of spelling stuff they're still hearing
their questions of
should we have variants that only
protected subclass of Allah race so you
don't have to expose your guests to your
customer and stuff like that there is an
intrinsic ID implementation coming soon
for both Alby to decay and and Xing
coming soon meaning I it's it's actually
on my side to actually write up the Jap
and stuff and propose it to to openjdk
some early numbers look good for example
a hashmap
ported from open JDK 8 to use a
structured array as a spine rather than
an array of nodes as a spine is between
5 and 12 percent faster and hashmap get
that's without you even knowing what
structure to write is it could do that
and the next steps are to try and do
actual project work with it the aim is
to put it in some Java version in the
future we will be looking for support
hopefully from people here and elsewhere
and the really simple summary is here
new classes no language changes works in
vanilla on any java version 7 and above
the go-fast is an option that we hope
for a fill up where everybody will take
over time and we're saying we absolutely
intend to make it go fast even with java
7 so you don't have to wait for Java 9
or 10 to get the speak and with that how
does the Q&amp;amp;A part of this work when is
the next actual talk is at 11:50 or 12
oh well that's great then so what I'm
keeping you from is not a next stock
it's lunch
which means you you those of you that
are actually hungry can they'll eat but
I'd be happy to stick around as long as
people want to ask questions and talk
about this
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>