<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Write the Other Half of Your Program&quot; by Jason Hemann and Daniel Friedman | Coder Coacher - Coaching Coders</title><meta content="&quot;Write the Other Half of Your Program&quot; by Jason Hemann and Daniel Friedman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>&quot;Write the Other Half of Your Program&quot; by Jason Hemann and Daniel Friedman</b></h2><h5 class="post__date">2014-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RG9fBbQrVOM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is Jason Hyman nice to meet you ah
I'm Dan Friedman we are going to talk to
you today about how to take programs
that are functions and turn them into
programs that are relations on the
surface this sounds may be familiar to
some of you and maybe not but we have a
quite a bit of a different take on that
particular process but we're going to
start we're going to start with the idea
that maybe you don't know Minnie Cameron
which is what we're going to be talking
about so first we're going to give a
quick introduction to Minnie Cameron
all right so Dan here's a quick mini
Cameron program all right so equal equal
quote a quote B and I have no idea what
that's going to do so this we attempt to
make those two terms syntactically equal
relative to the things that we've
already made syntactically equal that's
the idea so it's obviously going to fail
all right what is that oh well goodness
Oh No
did you break it so we can't just go
ahead and you use our equal equal like
that this what we're doing is
essentially building some complicated
query like equal equal code a to quote B
and if we want to get the kind of
answers we want out of it we're gonna
have to run that using a mini cannons
run operator so I'm running for one
answer relative to some variable Q and
I'm see if we can make these two things
the same eye on the whole list of thing
ways that this query can succeed and we
get back an empty list so it means it
couldn't do any of them let's try one
where you get something at it I don't
think that'd be nice
okay so how can we make Q equal to quote
B how many ways can we do it well let's
ask for all of them that's the time and
there's exactly one
and again there's going to be a list
that's counting so to speak the number
of values that we're going to return so
this in this case again it's 1 all right
let's uh try something a little more so
much introducing another variable okay
let's build a new get another variable
oftentimes it's when writing mini-camera
programs it's useful to have more than
one variable so we build that with the
operator fresh you know keep count keep
track of the count for the number of new
names you're learning it's it's almost
over so that looks good let's see what
it does
it says it's succeeded and it doesn't
really care about any kind of value and
that's because the variables that we
started with are still fresh but it
still is success it means we succeeded
so we don't have any information about
you can you do more than one these
things are called con John's can you do
more one of these okay here let's how
about we get another variable and let's
say Q is the same as Y Y is the same as
X and by the trend and X the same as the
symbol cat and so by the transitive
property we figure out that Q is the
same as Y is the same as X is the same
as cat so there's one way to make that
succeed and it's if they're all the
symbol cat what else can you do well
you've got more than one those are
conjunct so in a fresh they all have to
succeed let's let's see the way if we
can introduce some choice let's do it we
do this with the operator Conde so Conde
similar to this is the fourth operator
condé by the way is is taken from the
syntax of cond so that people who are
familiar with the kind of some lisps
excluding closure of course but it
doesn't really matter as David Nolan has
demonstrated quite well that you can
play games with mini-camera in closure
in using core logic want to change them
all to letter or something like that
okay we could do that but this should
work - shouldn't it it should so how
many answers should I get God knows
well three okay there's three different
ways where you can succeed mm-hmm okay
we'll give you something else so now how
many answers any ideas oh sorry
any ideas okay so that is the small
little core of men we gotta run but we
have to throw in one more and that's
called either is equal slash equal or
dis equality and what it says is where
equality says it'll always be the same
this one says they will never be the
same basically or they aren't the same
no matter what happens they stay not the
same and if you do something little
later making them a make them the same
and if you do you you fail all right so
this was a big hefty hefty answer it
says it's anything you want so long as
it isn't dog pick anything you want just
don't let it be dog and that's it that's
the entire language we're going to use
today
I always feel weird when I say we
because the way is fairly large includes
will bird only kissing of and a host of
other people who were involved in the
development of mini camera so now we are
ready to look at our first recursive
definition and that is going to be a pen
and because of time and space etc we are
going to just use the name app now this
is just a vanilla function so we're
going to demonstrate and that it works
so let me know how it works but we're
going to make sure it's still working
this is still part of the cell phone
just do we want to say what that thing
is gonna be I'm guessing yeah okay
that's probably what it should be
so we've abbreviated the append function
an app oh here is the mini Cameron
relations so in mini Cameron because
there are a lot of functions running
around and relations running around we
use the basically the superscript o as
the announcement that it's a relation
that we're dealing with this by the way
is a superscript in case you missed yeah
well I bet Emacs will let you do that
but it's fine anyway so there's the
program it's not a terribly complicated
program but we're not gonna actually
talk about this program we're just gonna
test it make sure it's doing the kinds
of things we were hoping it would do so
the app that we've seen we can app o
work similarly run one queue and it's a
three place so first thing we got to do
is change app to app oh and put Q in the
last position so how many ways can I
have this app oh we're the first list
and the second list combined to make the
third one there's one way to do it so we
didn't lose anything by writing it in
mini-camera
we get the same behavior of our of our
app
and that's nice now we can throw a
variable and that Q in a different spot
but you're gonna have to change your
data okay so if you put the Q say first
all right so we oh you wanna both don't
get confused with those quoted symbols
by the way so but that's gonna bear
little introduction a second but so
let's see here's a space missing perhaps
yeah oh yeah - right right this space
one more by the B yeah we know space
there oh I see just retreat values okay
nevermind I thought it was the period
here I can I bet it doesn't look like a
period some say new faces there we go
plenty can plenty of room okay so
alright so what's one way can do it if
the first list is empty and the second
list is the output than those two stick
together so thank you mini can or mini
Karen's kind of sassy with the answers
it gives back it's as lazy as that is
lazy it can be it's not doing a whole
lot of extraneous work but bunch of oh
yeah let's get more like yeah oh my call
up and there they are and you can see
that that's sort of like yeah so if the
list you come in with a list a and then
the list BCDE
you stick them together and you get back
the out so gives us all the answers and
that's with one relation when when we
used our app function we got the usual
way of running it stick two things
together and get a third but here we can
use it in this way too or we could go
ahead and write a checker
this is why we call the equal equal
operator the big hammer now so we can it
not only use it these different
varieties we can also use it to test
whether three elements exhibit this
property and again that's with one
program so that's kind of a neat tool to
habits one of the promises of this
relational or logic programming well I'd
say that we're down now done with the
introduction I hope that we didn't go
too fast but it's except for this little
piece here or we want to sort of give
you a flavor for how we went from app to
app oh okay so the first thing we did of
course we changed the name by adding an
older than to it to make it a relation
and we have a third argument or the last
argument that we refer to as the out
argument and here we're just using oh so
that part of the code is pretty
straightforward
then the conde is used in place of the
con but in the first con D clause as
opposed to the first con clause we're
saying that L has to be the empty list
and that's what we're in the first one
we said if it is we do something here
we're saying it has to be and then if it
does if it actually happens to be then
we get a value or out of course that is
the s and the else clause you see all
those nested things they're like the app
of the coder of L and the Caravelle and
all that we have to remove all that
nesting and we refer to that as
unnecessary bol basically for every one
of the operators and in some sense so
here we want to break up L into a car
and a cutter so we can get both of those
at the same time so we introduce a
variable to two basic variables and they
show up here and so we importantly are
conde clauses they're here they're non
overlapping so either we it's the empty
list or it's some kind of a pair this is
this is our notation for saying it's a
pair we're constructing a pair here
where a is the first element D is
the second element and this is this back
quote comest business is just what says
that build a pair of that structure so
either it's the empty list it's not a
pair or it is some pair those are
non-overlapping cases and as Dan said we
do a whole lot of that uh nesting here
okay well I think we don't want to go
any further in this direction because
what we have to do now is talk about
what the goals of this system we're
going to show you today and one of them
is it will be mostly automatic that is
to say there will be one little thing
that we can quite do automatically just
yeah but it's mostly automatic and in
your within an escape control tea meta
control tea operation to get it to be
exactly right now the other thing is
that we need to show you sort of what
what the code is going to actually do so
this code was hand designed and built
carefully and it's correct we're going
to try to show you how if you had a
language for writing functions functions
not relationships but functions
carefully crafted then it will be
possible to take that program and feed
it to another program that will produce
many cameras so all you really end up
having to do is write functions but in a
somewhat stylized way yeah alright so
you want to go try one let's try one so
here's a program that will take the
union of two sets represented as lists
and with no duplicates and here's that's
a pretty standard definition that member
for those of you who
are familiar with racket and we they do
things and and all those games and lisps
and I know when member runs it returns
the list whose car matches what we were
looking for and that's always very
useful but not for us so we're gonna
have to define our own member so BC a
DAC okay so but well we'll get there
mm-hmm yes we will all right so let's
define this Union now okay so we've got
our original function let's let's start
doing some of that transform go for it
first thing you start off doing is we
don't have anything like an O and mini
camera I mean I primitive like that but
I do have a great way to see if
something's know and it looks a little
bit like this
null is the same as asking me if it's
equal of the empty list and equal
something I kind of feel like I could
turn that into mini camera if you ask me
- all right so first first step down
those first step and then we return as -
remember we are only writing functions
continue so cutie left is like a pattern
matcher and if it fails it will go down
to the next line but if it succeeds it
will take the body of the left and it
will run it so here is an example and
all we're doing is doing very simple
transformations to our program
all right so what is that kind with a k'
well where'd that come from it came from
this file called Lane get rkt okay is
that not what you wanted
I don't know so we it it's something
that ensures that those lines are
non-overlapping it's something we wanted
to make sure it's the case so we D
structure s1 into this structure a dot D
and then every place where we got a car
I know how to write that now every place
where I've got a cooter I know to write
that now
right and we should be able to go ahead
and run that yes we should remember only
functions
all right no harm no foul okay so do you
have any other tricks up your sleeve
Jason yeah okay so we're not quite there
yet no I'll leave that secon we want a
cake cond well yeah
or maybe something else you want to do
something with that yeah I wanna know
who that members bothering me you
pointed that out now it's bothering me
so member is one of those calls we got a
Dean Esther I can't have that sitting
there and moreover as Dan pointed out
member in what we want what I want is
really a predicate so we can go ahead
and write that or pull one out of the
oven I'd say I pull it out of the oven
it's okay enough
so do you know the metaphor if pull it
out of the oven this is uh from the
Julia Child school of cooking if if it's
not done by the time the show's over
well look we had one here the whole time
so there's a couple of those going on
all right so we have the trivial
definition of member but now it returns
a boolean which is a whole lot better
all right but I I see you know I see a
con yeah I know how to handle do some of
those again you know equal no I just
have break the carne could or otherwise
yeah so UD let okay comedy 2s1 didn't
realize how I might call on your body
right so now you can change those cars
and cutters within ya these Andy's that
we won in the first place
and now that I've got a member I can go
ahead and use it okay all right so now
that we've what's you want to keep
working on this so we remember out of
the way what's done here yeah all right
that works as a con except we don't have
Elsa's in mini cannon else is is
implicit implicitly overlaps with all
the other cases I can't make these come
in any order I want that the neat thing
here is with these two lines now I could
flip them and they'd go in any order I
wanted this QT let has the property that
if it if the s1 doesn't D structure into
a pair it just falls through to the next
line so I could flip these whichever way
I want after you get rid of that else
yeah after I well this one I can't this
one I can't yet but let's give it a
whirl so what does it mean here they
else mean what it means here is not
equal XA okay so I can now those those
outer two Khan lines and the inner two
Khan lines I can put those in anywhere I
want the function still works that's
neat that sounds like one of those
properties we wanted because after all
we don't want what's called overlapping
do you happen to have anything in your
not the time yet see us afterwards that
will show you this really awesome
three line program that shows you really
why you have to have this notion of
non-overlapping so all right so I can
pull these out and you have to introduce
that those oh sorry this always program
me a minicam
yes it is so the other one has that fall
through behavior this one this one
doesn't this one's this is something
that if it doesn't D structure that
pattern raises an exception there and
that's a good thing to have if I'm still
in function land there are times when
debugging Mini Cameron programs are all
kinds of mess I've got or Dan and I have
dozens of students that can attest to
that including ourselves
yeah recently I feel like as long as I
can stay in the land of functions I just
feel more comfortable and this is one of
those things that's a nice handrail so
when I let the value of member be that
res then what I want to know here in
this case was is the result res equal to
quote T our hash T mm-hmm and I know
what to do otherwise now this is neat
when I can say if it's not hash T then I
know based on the program I wrote that
it's hash F because my predicate either
returns true or false all right and
we've got one last little you have to
get rid of those nestings yeah then
that's my dog won't hunt so how about
what do you want to call this one the
value of the recursive call rec yeah
all right so don't use cons here we've
got a concise way to write that comma
a.com or rec rec and wouldn't you know
what we already evaluated this call so
we can just drop that in right there and
this too should still run we should be
able to just go ahead and what happened
to turning that conned into it oh yeah
another kakan okay i mispronounced it so
is that all we have to do I think that's
about it we should be able to give this
a whirl okay so the next step
just make sure go is going to be
I know it's not their hand but we'll
give it a whirl
or Katy
Oh what is that s one that was LS huh
that's gonna work a lot better
and still now you promised money I could
reorder these however I want yeah knock
yourself out
that's a valid order I can do that
alright anybody another one another
permutation I think so now swap it back
I'm nervous go ahead guys let's see if
it does union for us by the way this is
a little reminiscent of Dykstra guards
if anyone is old enough to remember
those oh well I got to put it in the
right directory Oh
oh well can't actually run it before you
is it turns out the actual program needs
to that that order doesn't matter yeah
all right and there it is okay so now
what we can do is hand build the mini
Cameron from this and then with
remaining time we will show you how to
how we do it automatically so you ready
Jason I'm stick it back into the usual
wording that just feels a little
friendly or ordering because that looks
a little bit more like what we had
before yeah okay - now remember again
okay so we're many Cameron izing these
two definitions based on what we've seen
and part of the magic of this system I
hope you'll notice is that we basically
only use control Y and escape control K
something like that all right
okay so search and replace in surgery so
the first most important move when
writing mini Cameron programs from
functions is to stick an O on the end
everywhere that's that's uh that's gotta
be done that's got to be done all right
now we're in mini Cameron land and O's
everywhere another oh this one's an
output variable right that's poorly
named but the the idea is I say three
place relation from a to place function
alright so con goes to Conde and this
equal so we sort of premise goes to
equal equal of mini Cameron and so we
don't have we don't have return values
instead unify that with the out exactly
now this leg here has just luckily
enough set up for us exactly the
variables that we're gonna need to
create to freshen so refresh a and D
pull that up here
and so what I want to do is I now want
to unify those variables together
I don't need my let anymore so now got
another condi and equal equal we're now
hash tea is unified with the out right
otherwise it's not equal case just how
manner translate not equal
how about equal / equal how about not
equal that sounds pretty good and finish
her off and this Patel so you're just
throwing they are gas along the out
variable and recursive call okay so this
one's done you're doing to demonstrate
it okay
it's demonstrated will demonstrate and I
want to come back and draw compare and
some contrasting yeah of course I'll let
you do that if Kronos will
run 1q fresh one good be friends
remember question mark o quote X and the
list a B X C with oh wow oh how about
comma B you're gonna do that a B X Y
comma B Z with Q well it's a for you
made X first that's not very friendly
okay
w WX alright that return true return
true twice okay and we're done right
because it's a run star which means all
of them so that you can go all right now
that's a proof and there's there's two
ways it can it can be in there it could
have been that this was the X or it
could have been that this with the X but
either way there's an X in there we know
that there we get there's two ways to
there's will be in there and it could
not be in there because this variable be
it either it either could match on this
line or it could match on this line and
that the answers were getting okay so
what we want to do next is for the Union
okay okay let's take something in I just
wanted to do a quick compare and
contrast what I thought was neat one of
the things I thought was neat about this
is we found a way to write our our
functions in a way where the mini can
adjust can kind of fall out naturally
that's uh that's a neat thing to have
that member turn member question mark
turns into member question mark oh with
with not too much thinking whereas in
the looking at app and app app oh we
wasn't so clear as to how we got there
this one we managed to massage it in a
way where we could just so this tool
that you have going to be
Napo yeah but let's not but there's
gonna be opportunities for everyone
that's it so if you're not vanishing
after this ya know and it's going on the
github and such so let's run the same
play over this one
okay so watch how fast this you knows
Union oh oh we gotta get that member up
can't forget that member who knew and
now you can use condi and then equal
equal and then o equal equal as - oh and
then this cutie let is just going to be
a fresh and D and then an equal equal of
that to s1 what happened to that end
where's that coming from
that was in okay I was in there for ya
mmm-hmm and we have another little all
right so team like not to deal with now
it's set us up for a couple of a couple
recursive called variables we need to
make again let's you need res and you
need rec so we can fresh res and rec and
now I know what just slip the Rose right
in the end there pull it out do the same
thing for Union yeah
so you may have noticed that we had to
be cursive calls here inside this fresh
and that is somewhat problematical
sometimes and that's one of the reasons
why this is more of a proof of concept
than a completely running wonderful
unbelievable system it is just we're
starting this line of thinking now this
is what the plain straightforward
translation gives us is it turns out
when we did if we done this with with
app to app o we'd have had the recursive
call above the above that unification of
there so if we if we transport a PO we
de started we didn't wind up with this
and that's gonna fix it we had to do an
escape control T okay so we ready to run
this now yeah we should be able to give
it a living in the shop
let's go with that after I ate our union
yeah run one cue union Oh a b c d c e q
and there you have your answer and you
very nice start playing all sorts of
games and the standard ways can you do a
run to and get something interesting one
to try it you can run three and try it
but you need to put some variables more
variables in there okay give me a yeah
yeah sure i see what you're going for
let's uh let's run it in those in those
different ways like we've been doing
before remember that a this union is
virtually the same as append except it
doesn't allow duplicates right of course
isn't that true
right that's what that's when we think
about it it's just it's just a pen and
it avoids duplicates so are you ready to
show us the magical thing that's going
to happen now yeah sure so we well
better make sure we can see the output
so equal equal q2 plus s 1 comma s 2
that's good we're ready to go see what
we get
ok what does that DB thing doing down
there now that does not look good in I
think that's a real problem Jason so
what we promised was that s1 and s2 were
lisps with no duplicate and mini cannon
has produced a list with a duplicate we
said they were sets but we never
enforced that they were sets that was
just something that we said you all let
us live by with it no thank you by the
way so and this is the sort of thing
that happens off when you and you're
doing mini cannon programming and that
means you sort of dig through the
relation and believe it or not the
program's get a little bigger than this
will and Dan a bunch of people have
written relational interpreters to
generate Kwan's or that you can use for
fuzzers they've written type inference
serves that work also as type and
a bunch of really neat kind of programs
but trying to make them work just so
you'd leave out a quasi code or a comma
you put a consonant a Conde things like
that and trying to figure out what's
going wrong is it's kind of a mess and
so do now that we've got this sort of
mechanism for taking functions and
turning them into mini-camera relations
the problem was in our function and so
what what I now like to be able to do
the goal is so that we could then go go
back to our function that we started
with figure out oh oh here's what
happened I didn't correctly constrain my
inputs let me go add an assertion about
one of those inputs there and then after
after we add that assertion
we just rerun these steps and end up at
another relation try it out give it a
whirl we don't like that want to fix it
up a little bit more but to go back to
the functions work in the functions and
do the translation and that's that's
what we're hoping again all right so
does this you some of this is automated
thing yeah so let me take a look
so this is a little different than the
one we showed so Trent transformed too
many we take that boy that's got a
little big dinner
so you'll notice a couple things and
we've got a few more to the structural
quasi quotes in there we put it inside
one big let rec and we added the call at
the bottom but I can take a program like
this oh I don't need two of those and
run back and generate the mini Cameron
program that we wanted it's got the run
one at the end variables in the right
places and this goes ahead and runs - no
can you run that
so
Oh
and they'll get back everything's okay
can you go does anything else gonna show
us anything else like some micro Cameron
perhaps I don't know what that is then
Oh
Micro Cameron is this really small
functional core no macros allowed then
it gives you enough power to do
everything that many Cameron can do but
only always functions some languages
there macro systems maybe aren't what
rackets is or or even scheme so we have
wanted for a long time to just have a
small tiny what is it five operator yeah
so little operator mini Cantor in this
implementation is written in terms of a
bunch of racket macros that are written
in terms of racket function so we took
function written in racket transformed
it into a language that uses racket
macros and that we now see sugar it back
into racket functions or we can take it
all the way down transform plus run and
just transform it all the way the answer
I'm noting in the micro where's your mic
oh that was this this big hole monster
so it's a more like an assembly language
than they but it's kind of neat because
you know assembly languages you know you
tinker and think about them a little bit
in ways that you maybe wouldn't thought
about things so I kind of liked it a lot
okay yeah alright but that's us thank
you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>