<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Unlimited Register Machines, Gödelization and Universality&quot; by Tom Hall | Coder Coacher - Coaching Coders</title><meta content="&quot;Unlimited Register Machines, Gödelization and Universality&quot; by Tom Hall - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>&quot;Unlimited Register Machines, Gödelization and Universality&quot; by Tom Hall</b></h2><h5 class="post__date">2016-09-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7Q-UwjgZ0q4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello thanks for coming when when
there's so many choices I appreciate how
many of you had turned up to see me my
name is Tom I'm that Tommy Hall on
several internet you may know me for
retweeting pictures of mountains roughly
once per day
follow me of you interested in pictures
of mountains I'm gonna talk about an
idea today that I had studied before but
was sort of brought to my the front of
my mind by a new book by a contemporary
philosopher called Dan Dennett so as you
know from the title its topic is
unlimited register machines so Dan has a
section is book or the seven secrets of
computing power reveal and the idea is
to demystify how computers work for for
the layman as or as sometimes that the
audience for these books are is let's
say the enthusiastic and non specialist
so like not not somebody who's prepared
to work but doesn't this isn't
necessarily sort of steeped in the
theory or whatever so and what I wanted
to do is kind of go through a similar
process to what Dan does but then take
it a little further um so I've
introduced unlimited register machines
and then go forward and the goal of the
talk or a goal of the talk is to build
up to a universal machine so we have a
program that can simulate the behavior
of any other program so like a universal
Turing machine which you might have
heard of or whatever so unlimited
register machine so the first question
obviously what is a register I'm
realizing I've done this I've asked
people have asked me about my talk over
the last few days I've tried to do a
sort of five-minute version of this talk
about a hundred times so and excuse me
have you had all this before if you have
spoken to me in the pub or whatever and
so a register is just the location to
store a number it's a it's a natural
number
it's unbounded so it can be arbitrarily
large and but it's it's finite you're
allowed to use as many of them as you
want there's an unlimited number of them
so though the contents of an individual
one is unlimited in size you can have as
many as you want it's unlimited but
there's some finite number for a
particular program and so you can use as
many as you like a program is a finite
sequence of instructions again
it's finite and we don't allow infinite
list of instructions for you to fear to
follow and there's free instructions in
this particular formalism so the three
instructions I have here I'm not unique
you can have register machines with
different instructions but the free I've
chosen is the same as the one in the Dan
Bennett book and I think it's somewhat
parsimonious so the free instructions
are and helped with your finished
computing increment register N and go to
instruction M so your lines of your
program are labeled and every
instruction over than halt is a go to
so you're incrementing register M move
into instruction M so you're jumping
around your program dev stands for
decrement and branch so this is the only
conditional we have in the formalism you
decrement register M and then if you
successfully decrement it you go to
instruction M if you try and decrement a
register that's already zero that's your
branching condition so then you're going
to jump instead to instruction P so
that's the only thing our programs can
do and as again a program is a sequence
of these instructions and you're jumping
around and every instruction other than
halt as I go to so hopefully that's
simple the state of the computation at
any moment there's a program counter
which says well what line are we on of
course that's updated with everyday
boring construction there's finitely
many registers each containing a number
so we need to carry that around well as
we compute them with these things and of
course as a program
our universe our own them said it right
the first time our unlimited register
machines don't modify the program
although I do happen to carry the
program around in the state so that I
can draw it I'll show you in a second so
computation is a sequence of states you
say what instruction we act now we
update the state we jump somewhere else
what instruction right now we are p.m.
we execute that instruction and you keep
going until you execute to halt
there's another way that if the
computation might end and this is like
an erroneous program but if you try and
jump to an instruction that doesn't
exist
that's just considered to be a fail
you've you've got a sort of invalid
program so we did we just hold on that
condition as well so our first program
that
like this five instructions in that zero
and we decrement and branch remember
register one and then we go to line one
or if it's already zero we go to line
two so the way that most books that
teach this teach you how to do it is you
write out the program you write out a
list of registers you can see what
registers are used by going down the
further after the instruction so one
zero two and zero are used they're the
registers we use so we've got register 1
0 1 &amp;amp; 2 &amp;amp; L is what line in the program
are currently at so we start by always
at like a line 0 as a convention and
we've Inc we've left register 0 as 0 in
the initial State that's because for
these things we put our answer in
register 0 so register 0 should always
be initialized to zero and the other
registers as many of them as you need
are considered inputs to your program so
anythin teresting thing with these all
these programs there therefore are very
addict so they actually go from any
number of input registers register 1 2 3
4 5 as many as necessary and then they
always give out a single number as an
answer so they're firm but they're all
very addict as well if I was the set
register 3 as say 7 here our program
would just ignore it would be look at
them none of our instructions reference
that register so you could call it with
3 arguments if you like so that every
one of these machines is very addict so
we're at line 1 and that's the state of
the registers line one says decrement
register 1 and then go to sorry line 0
the the first line off by one error and
so they I do that all the time because
the books actually start counting at 1
and so decrement register 1 goes to
instruction 1 otherwise go to register 2
yeah so with decrement register 1 that
would be now be 0 we jump to line 1 so
you'd write register 1 becomes 0
we're now at line 1 and then just copy
all the other registers so change the
register you're changing right the new
line you're at copy all the other
registers and then you go tick tick tick
tick tick answering the same question
each time I think I actually intended to
go to go to give you more examples let's
get back so then we're now tree-lined
why
which is increment register zero and
then go to zero so register zero will
now be one and then will now be
instruction zero is that clear
so then we ran instruction zero and
saying decrement register one and then
go to instruction one so register one
will now we can't decrement register one
can we because it's already zero so that
we're now instead going to instruction
two and then which will tell us to
decrement register two is that clear I
think there was there's definitely a
better exposition possible of that so it
gives me if that wasn't clear but here's
there's a simulation of the register so
you see we tick around and loop in
between those first two while it zeroes
it out so what what what computation is
this program actually performing yeah
it's another it's add in the two
registers isn't it so watch again we
flick around here decrement in one
register until it's zero which is our
only branching condition then we
decrement the other register and every
time we decrement we squirt it into
register with zero which is our answer
so yeah indeed we have successfully
performed addition and my I realized
that the climax of my talk is
essentially executing a program that
adds two numbers together and correctly
and correctly finds the answer so I'll
try and share some of my enthusiasm with
you so another way of representing these
is at this graphical form I don't know
if you can see my mouse so I'll try and
be yeah I think I hope that's visible so
we one way of figuring out these so we
Traverse r1 minus means that remote
register 1 the default next hop is the
is the single arrow the branch on 0 is
the double arrow so if you watch what
happens here at the start of our
computation we decrement register 1
we then decrement register 2 and then
until register 2 0 we're going to keep
adding into register 0 and register 3
and then when register 2 0 we come down
and we keep decrementing register free
into register 2 and then we come back so
this is a little tricky it's worth
thinking through
for a moment so can anybody see what's
happening here Bobby it is a little
tricky that's gonna that's the problem
with these unfortunates what kind of
think them through for a while so for
everything in register 1 we decrement it
and put it into register to decrement
register 3 and and then copy it into
register 2 so this is actually
multiplication so we I don't know how
best to describe it hmm
so yeah you well you for everything so
this is this condition goes round here
the this first loop until register one
zero this this goes around register 2 so
for everything in register two so if I'm
the non zero case of register one's
initialized with a number we decrement
register one and register to increment
register one then we keep doing that
until register two is exhausted so
register three contains a copy of
register 2 so we and we've also put a
copy in register 1 we then copy register
3 into register 2 against if we rebuild
register 2 and then we go and squirt it
into register 0 again so we copy
register 2 into register 3 and and
register 0 then copy it back and we do
that as many times as there is in
register 1 exactly you're done yeah so
as many times as there is register 2 you
copy I saw as many times as register 1
you copy you register 2 into 0 and
another register then copy it back and
then do it again ok again there's
probably a better exposition of that so
excuse me um but so the best way to go
through these is to step through them
and execute them by hand but we don't
have time to to spend many hours doing
that so but the the hope is that you're
intrigued enough to go away and play
with these things awhile and then then
it actually does have some exercises
which is unusual for a sort of popular
book he does invite you to UM get used
to these and figure out what they do and
make your own etc so and I said before I
wanted to do a sort of closure ish DSL
because this isn't a closure specific
conference when spend too long on it but
sequence of instructions is actually
just a vector of instructions and then I
have a way of turning them into
functions so I can I can test them and
stuff all the codes available but yeah I
said we carry around a position which is
where we are currently there's a list of
registers which were operating on and
there's a program that
using program static and like all good
evaluators it's basically a case
statements is what instruction have you
asked me to do conditionally update in
particular registers based on the
instruction so again I won't spend too
long talking about the closure code plus
also to make up for time I lost it
explaining multiplication and so then
then it's sort of three of the seven
secrets are and this is where he becomes
a little hand a little hand wavy so he
says any number can stand for anything
and he gives an example of you know with
the way a computer program can either be
Excel or a flight simulator or whatever
it's a fairly standard stuff we all know
we can write programs to do arbitrary
things and so he says all programs can
be given a number which can then be
passed into a universal and limited
register machine which is obviously a
really cool idea and it says all
improvements on the URM so any fast pcs
you've got or whatever are just speed
ups so the the power of this device is
equal to anything else so it's acquitted
so called shirring equivalence so that's
the gesturing thesis and so that kind of
leaves a big question and answer doesn't
it's like so oh yeah so the program
itself can be a number we can operate
I'm not using another program so I had a
look around to see what treatments had
actually a concrete Universal unlimited
register machine I found lots of good
resources but most of them didn't use
the same formalism that Dennett did
there was one very good one from Andrew
Pitts at Cambridge and so that is the
the URM that would I've built in that
we're gonna look at today so in order to
do that though because our limited
register machine only operates on
numbers in order to have a function or
out of a machine that can take as input
a program and take as input the inputs
to that program and then simulate it you
need to figure out how to represent
programs as numbers and sets of
registers as numbers so we're going to
go through that now and which takes
about ten minutes as well so yeah we're
doing okay
so the idea comes from care girdle and
he used it in this incompleteness
theorems and because it was about formal
systems and in particular the permitter
are kind of arithmetic weaker systems
can be both consistent and complete so
they need to be at least half like as
much as an arithmetic and so there's
that arithmetician of simple systems was
like the key idea and so in order to get
lists of things we're gonna go via pairs
so if anyone's ever done lists once
you've got pairs of things you can get
lists of things so how are we going to
encode pairs of numbers so the trick is
we can use the binary expansion of
numbers and we're gonna say an example
here 2 3 it's encoded by ignore the bars
are just to separate the parts of the
binary expansion of the number so the
number that represents the pair 2 3 is
going to be this number in binary so
we've got zeros coming in from the right
and there's as many zeros as there is in
the thing in the left so there's two
zeros there then there's a 1 and then
the thing on the left is the binary
expansion of the number on the right is
that clear so we can so we can go
through to our is just through the way
closure does binary notation then a 1
then as many zeros as there are so I
think I can demo it now if we're saying
to our old I say code per and then if we
do 5 2 that's this number to our and
then it's the other way around so the
binary expansion of 2 is 10 and then a 1
and then as many zeros as there are the
left things are 1 2 3 4 or 5 there
should be the same number yeah so we've
got a way of encoding pairs of numbers
as numbers formally mathematically
that's actually a badge action so from
any number you get a pair of from any
pair you get a number and it goes both
ways
and it's injective and surjective it's a
projection and
so what we're actually doing here when
we do this is we're bit shift in y and x
plus one places so that's the same as x
and if i - ^ x plus one of you remember
and then we're flipping that bit in the
two to the x position so we want we want
to flip that bit don't we so we want to
send Y over to the left then we want to
flip that bit and all the rest will then
be 0 if we've been shifted so it's
equivalent to this function and we can
write that enclosure fairly easily so 2
to the X x - y plus 1 so once we've done
code and what the reason I like this
exposition in terms of code rather than
a mathematical version and is actually
you can you explicitly have to go both
ways you say in order to in order to
code a pair we do this and I know it's a
decoder / you do this so you say like
take off this is not a very efficient
way of doing it but you say keep
dividing by 2 if it does and count how
many there are
then then factor out that then decrement
it and divide by 2
so rather than just having this function
which is which is a rejection and you
actually explicitly have to describe the
procedure by which you want to pick them
and obviously these function should wrap
around true and so demo pairs I've just
done so once you've got once you've got
pairs you can build up to lists and we
use the same idea as in Lisp if you
notice our function actually excludes 0
so the as I said it was a by ejection
between the integers I slightly lied
we've excluded 1 so the I so we've
excluded 0 and even more bizarre off by
one error we've excluded zero from this
function so we can use it's not a by
ejection I lied and we use that fact we
use the fact that it's not in fact it's
a code lists so we have zero as terminal
like nil in in scheme where we have a
linked list at the second thing of every
pair is up another pair and you signal
the termination by 0 so we're gonna
signal termination by is by so in scheme
you signal determination by a nil we're
gonna say Sigma by 2 0 so if the list is
empty encode it is 0 otherwise take the
head of the list and coda is the left
element in your pair take the rest of
the list encoder is the the right
element recursively and of course our
terminal condition means we're going to
keep coding things until we get to that
zero so and then similarly how do we
decode them we say well if it if the
code is zero then it's the empty list
that's our special case otherwise decode
them the head is the thing on the left
and I'm using some closure to describe
the structure nests or certain words for
those that don't know closure
it's a decoder list if it if it's zero
the code then it's the empty list
otherwise decode it as a pair the left
thing is the head of your list the the
the right thing is the tail of the list
or rather it's the number that
represents the tail of the list if
that's not zero you have to then unpick
that one as well and you recurse in on
until the end is zero so you can
recapitulate a list so how does that
look like in terms of the binary
expansion I can say code list of 1 2 3
and in terms of the binary expansion I
always forget which way round it is but
I think of practicing off the last few
days so it's free to one so we're going
it's the other way around so that's what
that ends on a Wan I think and it's 1
and then 2 and then 3
no so it's just the other way round
sorry so it would be yeah free it's
amazing how stupid I've become one in
front of people yeah ok um I drilled
this I made a mistake at your oklogd
sorry and I just drilled this the last
few days ago I don't want to mess it up
don't wanna mess no they want to mess it
up and for some reason I do but so that
is our way of encoding it so I hope
that's clear and hope you can see it's
much clearer I think from the binary
expansion you've got a strategy for
taking in the list of numbers and
written return and a single number and
you can see that it goes both ways
so hope that's clear and so how to code
instructions is quite it's quite a
decent trick so we've got three
instructions we've got a way of code in
pairs and we've got a way of coding
lists
of things so if we can find a way of
encoding instructions as numbers
programs are just lists of instructions
so we can code individual instructions
as numbers we can then code programs as
numbers does that make sense so that's
that's our goal is one a program has a
number and the way we do it is by using
a nice the problem is we've got three
instructions we can encode IJ as a
number we can code ijk the list as a
number but you don't know when you
decode it which of those two things it
is so we use a nice parity thrift and we
make sure that all the Inc instructions
go go to an even first number and all
the deb instructions go to an odd first
number so when you unpick the
instruction the parity of the left thing
tells you what kind of thing it is so
when you want so if you code an ending
construction as a pair of numbers
because we've doubled it you see we've
got two I will say we're saying that's
an Inc instruction if the first thing is
is even then it's an ink instruction the
second thing is actually just the GA
part of the instruction otherwise
because we do 2 I plus 1 when we code
the the deb instruction we know that
when we decode it the left thing is the
first number the right thing is the pair
that represents the j in the k and we
use 0 again as a special case we
excluded our code pairs excluded 0 so we
can treat n there's a special case as
well so then we can code instructions
and then it's kind of trivial it's like
well once we've got once we can code in
instructions as numbers programs are
sequences of numbers so we can just code
them off oh I didn't call one thing out
by the way sorry just that I don't think
the Machine requires this I have ran the
machine without this trick and if you
use the same code per function to encode
the the second bit of the Deb because it
excludes 0 you don't have a by action
between programs and numbers
I suspect the only reason this second
code function is is used the machine
doesn't seem to require it actually but
then you do get a by action between
programs
and numbers so I'll just explain that
it's it's simple it's there's a
different code per that instead of
excluding zero just decrement the answer
of the other one so it does include zero
and similarly before you decode it you
add one to it so this is this is this is
a proper by ejection between pairs and
individual numbers so I won't spend too
long on math because that I thought I
believed the only reason that they do it
is so that there is a proper by ejection
between programs and and natural numbers
um so yeah in order to code instruction
depending on what it is you code the
pair and you always double the register
or double it and add one to make sure
you're in the Inc and Deb case
so here again of you if you happen to
know closure and this is a more succinct
and less wofully version of what I just
said and if you don't know closure I
should have used the different language
that you did know and but the one of the
key ideas and sort of pleasures I take
in this talk is actually code now at a
closure conference you want can assume a
bit a little bit more but the idea that
actually the does the code expressed the
the idea better than the mathematics I
think it does in many ways because
you're forced to describe both ways how
how you both do it and how you undo it
and also we can know that we're correct
by actually executing it rather than um
you know my description or my
mathematics becomes the idea in your
head or whatever so it's a bit like
Gerry Gerry Sussman and Hal Abelson and
sicp talk about you know using this
using programming or code or whatever as
a way of expressing ideas and I kind of
like if you choose this is a language
you effort you happen to understand it's
actually a better way of expressing the
idea then perhaps the mathematics is
even so clearly we can we can code
programs so now we're going to have a
look and there's still have plenty of
time I think at what what the universal
machine looks like so we've got a
procedure by which now and this is this
is very tricky and but I hope it hope it
I'll give you the highlights of the
Machine and
and we cheat a little bit for reasons
I'll talk about in a moment and so at
the Universal machine or a universal
machine only uses ten registers which i
think is quite interesting the inputs to
the program are the program being
simulated like I said the registers
being simulated now that means the
number that represents the program being
simulated is the input the number that
represents the contents of the initial
registers is the input and then it uses
the other registers I'm including some
auxilary registers to actually simulate
the behavior of the past in program so
this is a kind of aha moment on the
order of sort of first knowing the Y
Combinator and having that nice to har
and it takes a while to work through in
a while to think about and but first in
order to express the idea of the Machine
the URM doesn't allow sub procedures or
whatever to make it easier so you know
do a spot of wishful thinking and say
it'd be really cool if there was a copy
command because if I increment and
decrement registers it takes ages and
the girdle number of a program is
massive so I can't wait for the heat
death of the universe for the registers
to sort of increment and decrement to
copy the the register from one into the
other so I added I had a copy
instruction I what the idea the idea
that the UART the universal machine is
used in is used in registers as a stack
and pushing and popping things into the
stack now it uses the same
representation for lists of numbers that
we use and but there is a sort of
subroutine that allows you to update a
register by pushing something onto the
top of the stack or by popping it out of
the stack so again we're gonna add three
commands so I'm going to show you the
universal unlimited register machine a
little bit of a cheap because it's a six
instruction machine implement in any
three instruction machine but I'll sort
of pay that debt at the end of the of
the talk and so the strategy is copy the
current instruction and halt if it's
tube if it's too big if you've told it
to go to an instruction that's too large
we stop then
and so we copy the we copy the program
we pop the instructions till we get the
one we're interested in we then inspect
that based on the arity we decide
whether it's Inc or Deb and then we pop
the registers to get the one we want we
change it and then we pop the registers
back together then we put them back in
then we start the whole process again so
there's the seventeen instructions using
six different commands though so it's
not meta-circular however it doesn't
host itself yet um so I'll show you the
highlights of this this I know nobody I
may be okay it took me a good slice of a
longish plane journey to truly
understand this so it would be very
unfair of me to go hey see clearly it
follows from and and so I'm not gonna
I'm not gonna even pretend that this is
a real expectation that someone will go
ah I get it but I can I can definitely
show you the highlights so first thing
we do is copy the program then as many
times as this thing's in the program
counter we keep popping the program so
into into another register so we say pop
into that register pop into that
register pop into that register so the
contents of that register is the line
that you're interested in or rather it's
the girdle ization of the instruction
that you're interested in so we keep
popping and if we try and pop too many
our program counter is bigger than our
program what do we do we hold so that's
the first bit that's the top bit yeah so
so far we've explained all of this and
now n contains the instruction that we
want to implement so then we pop it into
another location the unremember based on
the arity of the first thing where it's
either an ink or a dev and what what
this is doing here I'm getting goose
pimples I'm really excited about this um
so what what the bottom right um where
we've got the see decrement seed F M&amp;amp;C
push pop push pop decrement see that's
the way we discriminate are we our door
even at this point and that's where
we've got our two different paths so
here we discriminate based on the
contents of
the instruction what we're going to do
here is that this mplet this am
unusually excited by this um the the n
plus it structure is the extra little
bit where we wanted that we wanted the
its its decode star
it's our decode our function we
increment nothing before we pop it
because we know it's this over K it's
the the decrement instruction and then
we go and pop out all the registers till
we get the one we're interested in we
change it and then put it in and then
put it back together and then this is
reassembling everything posh and pop
until we've raised posh posh am pushing
pop until we've reassembled everything
and then we've got it so and this will
this will I hope give you some joy and
when you yourselves pick through it I
either I don't think with my exposition
but also with the time anybody's
exposition you would really get it you
have to kind of work through
I hope my highlights help you figure out
what is going on at various points but
that is in fact I'm making the wishes
come true
grandiose slide titles so we can um I
what made a thing that grabs them as
well and turns them into graphs and we
can take the program the number that
represents the program the list that
represents its inputs and we can
actually evaluate the universal
unlimited register machine which I
showed you before we can evaluator and
two plus three is indeed five so that is
I did
I've won I won five pounds off my friend
at the back I should have bet him in
dollars because pounds are worth so much
less now I could get people to clap two
plus three equals five so I went so
we've got a little bit of a debt to pay
I'm running out of time
copy so we cheated and we did copy but
can you implement copy using the free Oh
instructions yeah you want a copy our
into s0 alt s so decrement s and go back
to the same instruction take R and
squirt it into Z and s so Z now has a
copy of of R as does s which is what we
wanted and then copy our bucket that's
cooked so he copies that back into our
yeah so we copy the register we're
interested that we zero out the register
that's the target we copy the register
interested in somewhere else we copy it
back into two places and we've copied
okay now I'm gonna do push as an
explanation again the subtlety of this
is rather joyful so we it really is so
you start by increment in Z so Zed's
gonna be its an auxilary register l is
the thing that we're pushing into so
it's a number that represents a list of
things and what we're trying to do is
recapitulate this we want to do 2 to the
power of X and we want to multiply that
by Y so we're starting with y we want to
add 1 to it then double it then keep
keep doubling it by 2
keep doubling by to keep multiplied by 2
as many times as there is things in X so
we do this is our that this is our plus
1 now we come in to Z at once then we're
at the beginning of our loop and what do
we do for everything in L we write 2 zet
twice so that bit is 2y plus 1 and then
what do we do we go we're done then so
the contents of L is now 2y plus 1 we've
done the first bit of this function now
we go to Z and Z for everything in Z
which of course is now contains 2y plus
1 we copy it into n 2 L so L now
contains 2y plus 1
then we do that as many times as there
is things in acts so we go back um so
let me get this right
so we sorry at this point we've gone
round so Z plus one is two plus one but
then as many things as there is in L we
add two things into Zed's that's so Zed
is now 2y plus one then we want to try
and do the run of times it by two as
many times as there is X's that make
sense so we're now going to say we
decrement Z and increment L that's
that's a copy again so we're copying
that back into L decrement and decrement
X and then go back to L so then we're
then gonna do the same thing again which
this time doesn't double it in add 1 it
just doubles it because we're now
starting at L naught at Z so the first
time we went round this loop we added
one then we kept going round add in two
every time
now we come back to this loop we start
at L so this is our actual doubling we
copy it into zev twice for everything in
now but L is now 2y plus 1 and we do it
as many times as there are things in XO
that's our exponentiation that's time
isn't it by 2 as many times as there in
X and I think I said that correctly
I leave poppers and exercise for the
assiduous lately listener the plan was
always to leave puff as an exercise
which is why there isn't a clue there to
remind me cuz I'm not clever enough to
remember what the thing is supposed to
do so next steps I would love so there's
there's a representation I think in Mead
intermediate between the graph and the
list of programs like a block
representation because very often on our
programs we say do this and go to the
next thing do this and go to the next
thing do this to go to the next thing so
it's naturally quite blocky but then we
have a few exits off it and I want to do
a scratch style editor for these things
there's somewhere intermediate between
writing the program and and looking at
the graph and I want to build a faster
interpreter for the free instruction URM
so if you do that if you execute the if
you execute this copy you get stuck here
zero and out a massive register takes
ages and and copying a register takes
ages if you've got the girdle number of
a program it's that many cycles it's the
heat death of the universe before you've
actually copied it um so yeah and then
property based testing these things are
crying out for it because I've got I've
got proper body actions between the
entire integers and programs which I can
then execute oh and also I can't get the
girdle number yet oh by the way I have
expanded out the 17 instructions 17 line
program in the six instruction machine
to a free instruction version which is
about 67 lines but even in the Java
version of the simulator I've got I
can't get the girdle number of the
universal program and of course you
eventually you'd want if you had enough
computer power you'd want to feed it
into itself wouldn't you one can one can
dream um so oh somebody said they were
really looking forward to finding out
the history of this idea I'm afraid I've
barely had time to describe the idea
this is a wonderful book doesn't mention
universe register machines but is all
about the idea of universality including
some wonderful mathematicians they
couldn't how much of a nice chap bull
was um so the this book uses a different
formula symbols also very good any
questions and I've already answered the
first question um any any questions I
know I never got it wrong at several
points but it's fine
why did I oh and discriminate based on
them
and good question I'm not I'm not
proposing that this is at all unique or
the one only has one choice I'm so I
wanted to stress that along the way
therefore the particular girdle ization
chosen you can see a bit later that it
obviously makes it relatively easy in
the instructions to implement so it's
it's it's well chosen in terms of later
implementation but you have loads of
different choices loads of different
things you might do and absolutely non
unique to stress that yeah oh yeah
eventually and one thing I'm really
actually lost a lot of time made that
demo in the space of about an hour then
for oh great I'll do the universal
machine and I just got that you said
infinity as the as the value of the way
of the registers I was like I'm in
JavaScript now aren't I and then and
then I lost I lost many many many many
Tommy hours were wasted trying to get
JavaScript to have large enough integers
and then I did it and then it was too
slow so I'm in a very unfortunate
situation there um my hope was to yeah
have that I think you might have known
that I may have been a troll um
well thank you for your patience and
indulgence I hope you do stare at that
slide and I hope it brings you great joy
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>