<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Universal Reason&quot; by Jacob Bass | Coder Coacher - Coaching Coders</title><meta content="&quot;Universal Reason&quot; by Jacob Bass - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Universal Reason&quot; by Jacob Bass</b></h2><h5 class="post__date">2017-10-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/L0xz-ILKsLE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm Jacob thank you very much for
coming um today I'm gonna be speaking
about reason reason ml I'm really
excited to talk about this I've got a
lot of good content I hope everyone gets
some really good stuff out of it I go
home at the end of the day looking like
this a lot and the reason that it look
like this is that writing correct
software is really hard but it's really
hard doing it in a language that has no
real formal semantic understanding of
what correct software actually means so
I spend a lot of time writing JavaScript
a lot of time writing Ruby a lot of time
writing dynamic programming languages
and in languages that don't have a
strong type system it's very difficult
to actually express whether or not
something is correct so what we're going
to cover today is how using a language
like reason can actually improve your
developer experience improve your day to
day experience improve the quality of
the software you ship and improve your
confidence in the product that you're
actually delivering so how many
different implementations do you think
you could write for the function that's
on the screen so the function should
read as an as an as yet unnamed function
of any possible type a that returns any
possible type a with such a breadth of
applicability there are no restrictions
on the input type the only restriction
on the output type is that the value is
of the same type such a breadth of
applicability how many functions do you
think you can write well if we constrict
the solution space to functions that
definitely respond definitely return
that loop forever don't throw exceptions
and we agree that we're going to be pure
and have no side effects there's only
one implementation there's only one
thing you can do and the only thing you
can do is return the exact same type
that you were given at the beginning the
exact same value you were given at the
beginning and the reason for that is you
actually know nothing about the type you
know nothing about the information that
is being passed into the function which
means you can't actually assert any
behavior that is legal to perform on
that type from a correctness perspective
your hands are tied behind your back
this was a very very confronting thing
for me the first time that I came across
it that having restrictions on the input
types for a program could actually grant
you more freedom and having absolute
freedom on the input types of a program
was very constricting but what I what I
think
but basically like made me realize that
it made me kind of understand that was
looking at the kind of code that exists
in a lot of the dynamic systems that I
work with so a lot of the code looks
like this we have a lot of very very
well named variables we have a lot of
checks for this types of the values of
the things we're dealing with and we
have to rely on things like commenting
or documentation to explain to us why
the function is doing the thing that
it's doing we don't have static analysis
we don't have compiler safety we begin
to rely on runtime exceptions for
control flow to help us kind of
differentiate between the ways that we
are programming and I think the reason
we do that is a lot of the time
languages that give us compile time
safety languages that give us static
analysis are painful to use they require
us to write annotations in every
variable we define or they're not safe
themselves and it just becomes a pain
and we don't get any trade-off or value
for that but what if there was a way to
get a strong compile time static
analysis safety in your program without
giving up the things that make
programming in a dynamic language fun
where you don't have to write a type
annotation on every single variable in
your program well you don't have to deal
with the the difficulty of null checks
at every possible function okay what if
this language was available to you now
to use so the language that I mean that
I'm going to introduce is called reason
reason ml and reason is a language where
it's a syntax and a tool chain
effectively defined over the yokomo
language a camel is a functional
programming language
it's probably about twenty something
years old long history in academia and
in industry and reason is being
developed by Facebook as kind of an
inter draw introductory functional
programming language for people who
wouldn't have come across these concepts
otherwise are born of recognizing that
the barrier to entry with a camel was
higher than most people were willing to
climb over to get to the benefits so the
other really interesting thing about
reason and what positions it for me
today is that it actually compiles
really really well to JavaScript so that
makes it very very compelling for
general-purpose programming as someone
who works on the web if I can't compile
to JavaScript I can't actually do
anything in a browser I'm stuck with
static HTML being
back from a controller it's difficult to
work with it's very difficult to explain
to a products manager why you might want
to downgrade your experience because the
correctness of your back-end system is
important by having something that can
compile to JavaScript we'll get the best
of both worlds we get all of the
dynamism on the front end and we also
get complete compile time safety at
compile time effectively a lot of the
things I'm going to discuss today will
be very very general functional
programming benefits there are a couple
of things that are specific to reason
and to the buccal scripts compiler which
is the compiler that we use to go to
JavaScript um but the vast majority is
just functional programming techniques
or typed programming techniques so we'll
start by discussing the ways in which a
back-end system might be maybe not as
safe as you might like it to be and this
is a really important topic for me
because from my perspective the backend
is the really really important bit of a
web system it's the bit that's connected
to your source of truth presumably it's
connected to your database and in the
end what that means is if that isn't
correct if that isn't reliable then you
really have no way to be comfortable
that your system is performing what
you'd like it to and it's very important
to me that a back-end system be correct
but there are so seldomly so so back on
the JavaScript theme this is a
controller from the Express j/s HTTP
framework and this is a pretty common
piece of code that I see in a lot of
different applications that I've worked
on we have a controller that takes a
request object a response object in the
next object and it checks to see if the
body contains want a variable and if it
does it responds but there's an error
here there's a really really big bug
here it can everyone see the bug the bug
is that if the body is null we throw an
error and don't respond or if the body
doesn't contain either of the variables
were slicing off it we throw an error
and respond which means that there are a
number of code paths that are completely
valid from JavaScript's perspective that
might occur in our system that we don't
protect against and that nothing is
helping us be aware that we don't
protect against we have no tooling or no
information that actually helps us know
hey you probably want to cover these
other cases you
and that might lead to incorrect
software where the house built on
foundations of straw rather than stone
so what can we do to improve this well
the first glaring issue is that Java
scripts of return types don't actually
exist there's no such thing as a return
type for JavaScript because there's no
type system which means asserting
behavior from a static analysis
perspective is very difficult it's very
difficult to know looking at a piece of
JavaScript code what is the actual
return type what is the actual input
type for this so let's look at what we
might do to improve that situation and
we're going to set a very very strong
kind of constriction on ourselves every
function we deal with should take
arguments and at the very least it must
return a meaningful result so that we
know the type of the response of the
function so that we can assert the
behavior of the function so that we know
more about it so we're going to look at
what it means to use the express back
end from inside reason so we're gonna
define some of the foreign function
interface bindings using the buccal
script compiler and we're going to
define them so that we can call the Java
scripts that express exposes from inside
reason but do it in a type safe manner
so initially what we do is we describe
an abstract type of done an abstract
type is a type that doesn't have a
constructor which means it can be
returned from something but not created
by itself we then define four modules
and we'll go into the definitions of
those modules we define request/response
next and middleware request/response and
next all apply to the types that we saw
before the Wreckers and next types
middleware is the definition of what a
controller of what a middleware in our
system is going to look like so in this
case we see what the initial definition
of what a module looks like as far as
reason is concerned a module in reason
we'll get into much more detail later
but for the moment you can think of a
module as a namespace in which types and
values exist and will not clash the
types and values in other namespaces
there are process for allowing us to
encapsulate behavior without clashing on
different named functions so we define
the three modules request response and
next here we give them each an inner
type team you'll see that they have type
T in a lot of modules in reason and
inner or camel it's completely a
convention for what the main type of the
function is but it doesn't actually mean
anything special it's just there is a
type
t-that is available the request object
is very sparse for this example the
response object has our first example of
a buccal script external binding and
what that is is we have the call to send
HTML and what we do with send HTML is we
actually compile that down to a
JavaScript statement that says the first
argument you give this function is going
to be the thing that we call send on the
second argument you give this function
is what we're going to call send width
and we're going to return from that done
so this is the first function that we
can see in our system that can actually
produce a type of done for us
we say that when send hTML is finished
being applied we're done in the
controller we also define our next
module so our next module also has a
type T this time next that's really
creaky next type is not abstract it
actually has a constructor and we see
that next is a function it's a function
that takes something that might be
nullable and returns it done so now have
two ways in our system to actually
return done we can either say something
went wrong and we call next with a
potential error and let that flow take
place always say everything worked as we
expected to or we're gonna send HTML
back to the client
so we're now ready to define a
middleware in this system and we say
that a middleware is something that has
a type T where we have a request dot e a
response dot T an X dot e and we return
done so this is the really really
important bit of this system this is the
bit that I really like we guarantee at
compile time with no exceptions that our
middleware function absolutely responds
to the client and the way that we know
that is the only functions in the entire
code base that can produce done our send
HTML and next dot e nothing else can do
that because of that we have compile
time safety compile time assurance that
we absolutely no matter what else we do
inside a controller respond to the
client so this is what it would look
like then to construct a middleware of
that type we define a function f and f
we see takes three parameters req res
and next and we have a switch statement
so this is an introduction to a really
cool concept called pattern matching for
anyone who's not familiar with it
patent matching can be thought of
similar to like an if-statement
but where an if-statement operates on
values pattern-matching operates on
types so it allows us in the same way
that an if-statement can check what the
value of a variable is and say perform
this code branch if it's one from this
code branch if it's to a pattern match
looks at the types in this case it looks
at the algebraic data type are the
optional type and we're basically saying
if we have some computation that returns
none consider that an error and respond
to the client that something has gone
wrong and if we have a response from our
function that is some if something's
gone right take the inside of that and
response the client in the appropriate
way so we not on the actual construction
of the value rather than on the value
itself and what we can see here the
really interesting thing looking at this
is there are no type annotations right
there's no there's no boilerplate
there's nothing that gets in the way of
us just a defining of functionality so
we don't have to actually write type
annotations the compiler can infer them
from how these functions are used in
this case by passing it into the app
gate function the compiler goes cool app
dog get takes a middleware a middlewares
of type middleware T that means rec is a
request to you raises a responsibility
and so on the responsibility for
actually determining what is going on
belongs to the compiler not to me
because I'm nowhere near as smart as a
compiler the responsibility for helping
the compiler when it gets confused now
is only ours but that lifts a whole
bunch of responsibility off our plate
and it helps us hugely identify that the
only paths that we now need to write
tests for are the insides of controllers
to should make sure that our business
logic is correct that they respond with
the correct data we don't actually never
need to care again do all of our
controllers respond do they catch errors
do they handle problems that they do any
of the things they definitely do the
compiler assures us of this the compiler
not only assures us of it in the happy
path but it also helps us when things go
wrong so in this case we're pattern
matching and we're saying for every song
that occurs respond but we're new to the
code base and we haven't yet learned
what the business rules are and we don't
really know why something might return
non so we say when it returns non log it
because I'd like to check it out later
but logging is not the same as
responding to the client and the
compiler will not let that happen it
absolutely will not which protects us
from doing things that maybe we don't
know well enough not to do we don't have
to have a hundred percent knowledge of
the codebase we can actually push into
the type system the rules around why the
codebase is structured as it is and then
rely on the compiler to protect not only
us but people who are new to our
projects to help them write correct code
so we've seen a way to improve our
back-end system by using the type system
to help us write correct code let's take
a look at the front-end so I have
somewhat of a love-hate relationship
with for a front-end programming I think
I probably only really started to enjoy
it when react was released and a big
reason for that was front-end
programming for the longest time has
been slung with very much abandon it
does not really have a concept of
correctness and a big reason for that is
that JavaScript the language of the
front-end is not correct fundamentally
it is a very difficult language to write
correct code for and you can see this in
a lot of the efforts that have been
created and there are admirable efforts
to provide static analysis for
JavaScript the flow typescript closure
compiler these are all very powerful
tools and a lot of effort has gone into
helping us write safer javascript but
they each have to make trade-offs to
allow code to run that is valid
JavaScript code but that is not valid
correct code so you'll see flow for
instance unifies types that are
unwrapped so you can have straight of
value that is both a string or a number
or null and the compiler doesn't care
flow doesn't care that's a totally valid
state to be in from a correctness
perspective that is very difficult to
deal with so what we're going to look at
now is instead of trying to write
JavaScript correctly let's rather focus
on I want to say that this particular
part of my program should be correct and
I'll deal with the fact that I write
JavaScript in other parts and let that
be as correct or incorrect as I can get
it but I'm going to compile to
JavaScript to this other bit so the
framework that I'm going to describe
this in is reacts are there any people
who use react in the audience a sea of
hands
probably not not super surprising these
days so react as I mentioned before is
reactors developed by Facebook obviously
reason also developed by by Facebook and
interestingly reason was created by the
same person who created react
so Jordan walk was the the person who
came up with react initially and reason
was also created by Jordan and then more
interesting ly reacts initial prototype
was actually in standard ml which means
that by bringing our react bindings back
into reason we've come full circle we
find ourselves back in the ml promised
land so we're gonna go through a little
bit about how we can structure a react
codebase in reason and what the benefits
of that might be so initially to start
with we're going to deal with just the
hello world example we have a greeting
component for honor who's for anyone
who's not familiar with react this is a
function effectively that will take some
data and respond with some HTML that's
effectively the computation that we're
performing and we see here we have a
render method that just takes the prop
that we were passed and returns it the
other thing we can see is that we have
this static member prop types
prop types is a dynamic runtime
evaluation of the types that are passed
as arguments to a react component it's
the way that in vanilla JavaScript we
assert whether or not the values that
we're passing obey the contract that
we've written to make this component
hierarchy work and this is the method
that we rely on when we don't have flow
or we don't have static analysis or we
don't have a language with the semantics
built-in but as with all dynamic runtime
evaluation techniques we have to trace
every single pathway of our program in
order to know whether or not we've
actually hit all of the bits that we
care about these things run at runtime
so we don't have any real easy way to
tell does this actually is this actually
safe everywhere is does this obey the
contract that I wanted to everywhere
unless we trace each of those paths
dynamically so this is one of the one of
the drawbacks with using just pure prop
types one of the drawbacks with using
just JavaScript it's more or less
manageable when you have a very small
project more or less manageable when you
can keep the state of your entire
vacation in your head as soon as you
have anything larger than that it's very
very difficult we find ourselves at the
mercy of our time or our tooling and in
a refactor or in a in a crunch these are
the kind of things that tend to fall by
the wayside we're okay with that Lin
Singh arrow we're okay with that with
that prop side arrow we don't really
mind we'll come back to it later and we
never come back to it later so what can
we do well looking at how reason treats
react reason as we've seen up till now
is a strongly typed functional
programming language and reason react
components are just strongly typed
functions so in this case a reason react
component is just a module like I said
before in namespace that has two members
a component and a make function and the
make function is the thing that is
analogous to a react component to a
react stateless functional component
it's effectively a function of some
props that returns something that
produces HTML and what we have here is
we see our greeting component from
before we define it as taking a message
property and a children property that
we're ignoring as far as the body is
concerned because we don't use it and we
take the component that we've defined by
calling reason react stateless component
and we spread it apart and we override
any of the defaults that we want to
override to change the behavior so now
we have a fully functional react
component so this is the record syntax
from react anything within curly braces
by itself is a record a record is
something that has very particular
properties it's effectively an object
with predefined properties and values
and what we're doing here is we're
saying component comes back with a
number of these properties but we want
to override the render property and well
that's what we're going to use to
produce HTML so here we have a way of
doing something a little bit more
interesting we now want to say that we
want some kind of dynamism in our system
we want to have some state we want to
have some some interaction and reason
react is fairly unique in that it
doesn't it allows you to
compartmentalize that state at any point
in your component hierarchy at any point
in your tree the way that it does that
is by a concept called a reducer
component and you'll see from reason
react that's the function that we
actually use to create the component
variable this time so a reducer
component is a ordinary react component
that has some state and has some methods
to allow you to update that state from
anywhere in your tree I have anywhere in
your subtree rather and so on rendering
this component we can generate a number
of callbacks and past those callbacks to
be used in response to actions that
might take place and then when those
actions take place we call those
callbacks and have the the effect of
that be that the state updates causing a
rerender again and we update the sub
tree so the way that we do that is we
first define a type for action and a
type for state the action is the actions
that we want our reducer to be able to
operate on on so we say that we're gonna
listen for clicks and we're gonna listen
for restarts these aren't magic terms
these are completely arbitrary what I'm
gonna do later is attach those to a
click event we also have some type of
state which is again just a record and
in this case we say that state is a
clicks Council which is an integer and a
restarts counter which is an integer we
define our reducer component using the
real reason react to reduce a component
function and then we override some
default properties on that we override
the initial state function the reducer
function and the render function so we
override the initial state function to
say initially give me back a record
where clicks are set to zero and
restarts are set to zero this now gives
us the time to override those it gives
us the position to override those we
then define our reducer function as
something that returns an update to that
record and you'll see that the the shape
that it returns is exactly the same as
the initial state shape exactly the same
as the state shape we have a an action
that we take in and we have the current
state of the application at the time
that reduce is called we then switch we
pattern match on the action that's
occurred when we've hit a click we want
to update the click counter we want to
leave the restart counter exactly as it
is when we hit a restart we want to set
the click color back to zero and we want
to increment the restarts counter so
this is the the way in which you handle
set state effectively the way that you
handle state propagating through your
system equally then the way that we buy
into this into HTML we attach the
functions that we have available to us
to the HTML nodes to handle the events
and we interpolate the state into a
string so that we can show that
for anyone who works with elm or anyone
who works with redox this should look
very familiar the interesting thing is
that as for the reason react
bindings you don't actually need a state
library out of the box it does
everything that redux does better and
with compile time safety you actually
know ahead of time I don't accidentally
listen to an action that I don't know
how to handle everything that's in my
reducer is also produced everything
that's in my my actions is also part of
my reducer there's no impedance mismatch
everything is handled for you by the
compiler a couple of statistics on using
reason react on the front-end so the
messenger comm website Facebook's
messenger website is at about 50%
conversion for the front-end a complete
build of the system using the baka
script compiler takes about two seconds
an incremental build takes about 100
milliseconds the amount of time it takes
to type check every single statement
inside your codebase is faster than you
can even say the word unit test total
Boggs introduced over the course of a
year 10 which is incredible it's a great
it's a great number and the idea is that
by having these correctness checks hit
us at compile time we never discover
them at runtime we discover them all
while we're actually working on them
which means we don't worry so much about
what the correctness state of our system
is in production we're much safer at
compile time so we've shown that the
reason reacts API protects all of the
things we like about react he gives us
all of the same dynamic features that we
enjoy about writing reacts without any
of the drawbacks of what we would
consider a static analysis system would
be it or comments' our dynamic code with
compile time type checking which is very
valuable and it also helps us share or
compose or refactor these components
without having to worry did we change
something somewhere that we didn't track
so the refactoring is the bit that I
really really like about this process
about the inference I find that I like I
mentioned before I don't write very many
type annotations I'll only write them
when I'm working in a library but in the
actual implementation of the code you
just write code you don't write type
annotations which is really nice because
you don't necessarily have
think upfront completely what is the
bare minimum type that I want to support
here but when it comes time to change a
refactor you don't then also have to
read through all of the other code in
the codebase to go well I changed that
now does it change and break anywhere
else the type system keeps track of that
for you it helps you refactor so I
actually have my wife to blame /
congratulate for this slide she told me
the word for lap about four or five
years ago
that's enough accounts word and it's
really fun to say Phillip is a really
fun word to say but it means like wilted
or limp and that's effectively how I
feel about validation being done in
JavaScript on the backend validation is
a very very important data validation is
a very very important thing to perform
when we have data coming in from an
untrusted source knowing that it obeys
the business rules that we have set for
that data is very important again source
of truth back-end these things are kind
of vital but one of the things you don't
have in a dynamic language is the
ability to know everywhere that I
persist data did I first validate it so
this is the data structure that we're
gonna pass around this is what we're
going to use as a as an example for what
it means to persist or validate data
throughout our system we have a person
and a person is defined as having a name
and an age and we set that the name as a
string we set that the int is a sorry
the age is an int and this is the data
structure that we'll use if we were
gonna deal with this data structure from
from JavaScript we'd have the data
structure come in from some source we've
passed it through a validate function it
would come out the other side of that
validate function we would check the
results if something went wrong we would
say cool get rid of it throw an error if
something went right we'd pass it on to
save but like I said before we don't
have any way to know every time someone
calls save did they first call validate
every time someone calls process did
they first call validate we don't have
anything to help us at compile time
check for these problems so the way that
we tend to deal with this is we either
very tightly couple these operations
into an ORM behind the scenes so we have
some private boolean property is Val
and the ORM will set that property
before it saves and that will then if we
try and save something before it's valid
it will automatically call validate we
can call validate beforehand and it sets
whether or not it's valid but it very
tightly couples the behavior of
validation to the concept of a
persistence layer but there are other
things we might want to validate there
are other things that we might want to
deal with and we don't have a good data
structure or a good safety assurance
that we've done this thing
as a sidenote did you know that reason
was haunted so I'm speaking of phantom
types phantom types are a type
declaration where the types on the
left-hand side or the the variables on
the left-hand side don't appear on the
right-hand side so in this case we have
type T of a equals string the
polymorphic a doesn't appear on the
right-hand side what does that mean well
we have type T of a is string and we can
now define that x and y are both strings
but we say that there are really T
events in T afloat which doesn't really
affect how we can use x and y we can
still concatenate them together using
the append operator and when we log out
the result we still get fubar nothing's
changed so at first glance this seems
like kind of a wacky esoteric technique
for just kind of mucking around with the
type system but if we couple that with
the opaque types that we've seen before
and modules we actually get something
really powerful so before I before I
show how we're going to use them to
protect validation I just want to go
through what the API we'd like to have
is so we'd like to have a way of saying
that a person validator will produce a
person but any operations that rely on
that person being validated before we
before we do that operation to them we
must make sure that we go through
validate first at compile time not at
run time so we see here that we have an
introduction to the pipe operator the
pipe operator is just a way of taking an
expression on the left hand side and
inserting it in the table position on
the right hand side and we can see here
that when we do person validate or make
named age and we try and save it
directly we should fail at compile time
we should fail when we have person valid
a to make named age we pass it through
validate and then we use the option F
map to say if it's non return non if
it's
some perform this operation we should
succeed at compile-time so what does
that look like this is a pretty big
example I'm going to break it up into
smaller pieces but the idea is that we
can define some module interface some
module type to say these are the bare
minimum things you need to define to be
considered a validator and then we can
define some implementation of that and
we can say cool this is how I am a
validator and this is what I validate
with the important thing to note here is
that in the validator type in the module
type person validator the type of T is
abstract in the implementation the type
of T has a constructor effectively what
this gives us is an opaque type it gives
us something where from within the
module itself we can reference the
person constructor but from outside the
module we have no way to do so and the
powerful thing with this is it means
that no one unless they use the methods
exposed by the module can construct a
person which means the only possible way
to get a person is to go through all of
the exposed public interface of the
module so let's go into what that means
and how that's useful so we have a
module type of person validator we have
to opaque types valid and invalid or to
abstract types valid and invalid and
then we have a type T of a T polymorphic
in a and then to find a method make and
we say that make from the type
perspective is something that takes a
string and an int and returns a t
invalid so we saw before that you can
define something as coming back T
polymorphic entirely and we can say them
because T is polymorphic entirely the
make function responds only with things
that are T invalid we then see the only
function that we ever define that takes
something from T invalid to something of
T valid we say that the validate is a
function that takes a T invalid and
returns with an option T valid will use
option here just for the ease of the
demonstration in a practical system I'd
probably use either-or results to
capture why something went wrong but in
this case basically what we do is we say
if it's invalid and our validation
checks fail return none and if it's
valid returns son-of-a T valid finally
we see the method that we're going to
use to show that the the validation
check will fail at compile time if we
try and sidestep it in this case we're
pretending that there's some save method
we can call that
a person and put them into a database
somewhere so let's have a look at what
that actually kind of looks like first
we'll touch with the happy path so we
take a person hi me and we pass them
through validate and then we pass them
through option F map and we save them
because the person obeys all of our
validation rules the construction
happens correctly we get back a t
invalid we then have a T invalid that we
pass through validate the validation
succeeds we get back a T valid we can
then pass that to our save method which
takes a T valid and returns a T valid
all of this works what if we help
someone who's too young so from our
validation perspective we say that we
don't to store people in our driver
database who are under the age of 18 we
have someone who is very clearly under
the age of 18 so we pass them through
validate validation fails we returned an
on type so from the option algebraic
data type we get back the non
constructor when we hit option F map
option F map says cool you have none
don't worry about it this is also
legally like legally valid it's all
correct
we don't actually hit the the compiled
system yet but will receive someone
who's none we don't try and call save
with none we just let that go
what if we do something a little sneaky
so what if we then take person validator
we create a person and then we try and
just save them directly so you can see
that we actually get a compile-time
arrow so this is where the phantom types
really really shine is the fact that we
receive a T invalid from make and the
fact that we've said that save works on
T valid means at compile time we are
assured that we never ever call a
function expecting T valid with a T
invalid really really valuable and we
can see that we get the error T invalid
is not compatible with T valid for save
then similarly if we do something really
really sneaky and we start with not
valid and we try and cast that to a
valid taking advantage of what we think
we know about the system where we know
that it's a person on the other end
maybe we can just automatically cast it
to a T valid they're all kind of the
same concrete type on the other side but
again the compiler says absolutely not
aro type T valid is not compatible with
type T invalid returned by make you
cannot cast between types like that so
there is no way in our system no way
at all to save this object unless it
first passes through validate and we are
assured at compile-time that there is no
way that someone has done this the
really interesting thing about this is
when we look at the implementation there
is no function that makes use of valid
or invalid make doesn't mention T
invalid validate doesn't mention T valid
save doesn't mention to you valid they
were just kind of do stuff the interface
will basically set that that type is T
valid or T invalid but from the
implementations perspective none of that
exists and the reason why that should be
interesting is that we have an
understanding now that our friendly
ghosts don't actually exist at runtime
there's no wrap unwrapped penalty for
using this technique which is really
powerful
we have no runtime penalty for compile
time gating the behavior of our system
we have a huge assurance that our system
is operating the way that we intended to
and we we know that we can do this
performant ly so this is this is very
important this is very useful so we've
seen that there are very very strong
things that we can do to push the
behavior that we'd like to have opt into
our type system the important thing to
note here is that we haven't actually
asserted anything in the type system
about what our validator does it just
validates we don't know whether it bala
dates correctly or incorrectly from our
business rules and we should unit test
to that but we are freed from having to
assert that every validator is called
before safe
we're freed from having to trace every
single controller and service path
through our application to say did I in
this path course save before I call it
call validate before I call save to get
it into the database so these are the
the decisions that it takes away from
you needing to make finally I'll I'll
end on some of the things that I think
are really fun about the language one of
the things that I try and evaluate a
language on when I first start playing
with it is the ability to express
abstractions I really like abstractions
just kind of for their own sake and in
this case reason isn't found lacking so
the first one that we're touch on is
modules and we've spoken about modules a
couple of times modules are actually the
most widely used abstraction feature in
reason
kind of cheating and the reason it's
kind of cheating is that every single
file in reason is actually a module so
when you create a file you write some
statements inside a file the compiler at
compile time will wrap all of the
statements inside that file up store
them inside a module and expose the
module based on that farm name so you
never have to worry about leaking into
global scope there's no way to actually
pollute there's no way to collide the
only place you could collide is within
the column within the the constructs of
a file and the compiler will tell you
hey maybe you didn't want to do that um
so these are the premier code
organization and reuse for the for the
language and the way that we can get a
feeling for that is we define a module
type which is an interface for a module
and we basically say that we're going to
define some add and we define a type T
and we define the type for an add
function and then we define an
implementation for intz and an
implementation for floats so for an int
we're going to say that add is X plus y
for a float we're going to say that add
is X plus dot Y and this is a reason
thing or a no camel thing we're instant
floats are actually completely different
types but doing this we can now see that
we have a very common interface that we
want to deal with and I'll touch on what
you can do with common interfaces in a
second but the bit that I want to show
now is that much like Ruby modules are
actually mixed inable and openal
which means they give us a very very
nice tool for sharing code in between
different places so in this case we
define a module which uses the float
implementation it locally opens it which
makes all of the methods defined on the
float module available but it doesn't it
doesn't expose them outside of the
module so if you then use this module
the the users float implementation
module you can't actually access the
float operations from outside of that
they're only available locally similarly
we could use the include keyword and the
include keyword we'll take that module
take all of the properties and methods
and values and types defined on it and
actually make those available to the
module and make those available to
consumers of the module so we have
mix-ins and we have code sharing the
other thing we have is the modules of
first-class citizens of a language you
can actually pass them as values to
functions and as I said before files are
just modules which means you actually
have first-class files you can pass file
two functions which is a really
interesting idea but so what we've done
here is we've defined a type mono I'd
we've said that a mono I'd is something
that has a type T it has a function has
a value M empty which is whatever the
base value of the mono it is it has a
function M append which takes two mono
heads and kind of squishes them together
and then we define a function M append
list we said that M append list takes a
module M takes a list of a and we'll
fold the list applying M append for
every value of the list starting it with
MMT and iterating the list we have a
little bit of typesystem trickery here
we say that we have a type A which is
effectively like a for all a the way
that module types work is they're
basically constrained inside the module
they won't leak outside of the module
scope so we cheat a little bit and we
say we have some type a and I promise
you the module that we're including its
T is the same as Type A I promise you
the list that we're using is also of
type A so the module type and the list
type are exactly the same so cool don't
worry about it and that's enough for the
compiler to say yes I can restrict this
to things that are bei that type and so
this is how we can write kind of general
first-class functions that have
different behaviors based on what we
pass in to them so rather than having to
write M append a list for addition
multiplication division any of the
operations we can perform instead we
define M append list once for things
that give us an M append and an M empty
and then by defining things that are
built the same way that M append are the
business built the same way that the
interface is we can just pass them into
the function to produce new values or
new functions so in this case for add we
sum the elements of the list and for
multiply we multiply the elements of the
list so this is a very powerful feature
finally before I close up we'll touch on
module functors this is a really
unfortunate overloading of a term that
is pretty much loved by every functional
programming language functors a functor
classically is a way of mapping from one
category to another in reason a module
functor is a way of mapping from one
module to another which is why they were
named what they are so we can see what
they're not f map functions they're not
a way of defining F map they're a way of
taking an input module of a certain type
and then extending it and adding new
code to it to return an output module of
a certain type there are code generation
facilities
similar to type classes in Haskell or
templates in C generics in general
they're a way of generating new code so
we can see that what we're actually
going to do is we define a module
functor it's a module it has some type
input some type output and it uses those
to restrict what we're going to map
between and then we define the function
self which is the make module and the
make module actually just looks like a
function right it's a function of one
thing that returns another thing when
we're done we end up with a new module
that a Bay's the type of the output so
the first thing that I did when I
learned about this like anyone who's
tried to use high school before I
thought well I'll just write all of the
Haskell type classes in front is that'll
be fun and you can actually get really
far you can actually do quite a lot of
them there are a few things that you
can't express or can't express easily
but for most of them but most of the
ones that you actually want functor
applicative monad etc you can get all of
those out of this so what I'm gonna do
is I'm gonna describe how to write
mapable and mapable is just the name
we're going to use so you don't hear me
say functor every 5 minutes we're going
to avoid overloading that term we're
basically going to say we define an
input which is a type T of a and F map
we define an output which is of type T
of a F map and also generates the the in
fix F map and the left F map functions
out of the F map function and we can see
that our implementation here takes the
input F map and says in fix em up is
just F map don't worry about it and also
says that left F nap is just basically
taking your F map function but applying
const to it and taking a value so we
basically say for every single for every
single thing that we F map over don't
return the thing that's inside the
funktones
don't return the thing that's inside the
mapable return this value so when we
wanted to fine now the interface or the
implementation for a certain type to be
considered mapable we define a module
which is we do anonymously here so we
have mapable don't make and next amount
will that make we apply an anonymous an
anonymous module where he said type T to
be option we define F map to be from
none to none from some to some F X and
now we can use option and for free we
get the definition of in fixed earth
method left F map completely for free
just because we know how to define F map
we can generate all of the code here
without needing to write it explicitly
for every possible implementation of
this type so that's what we would use
functors for as compared to module
interfaces the downside two reasons
abstraction system at the moment is that
it doesn't give us ad hoc polymorphism
doesn't give us things like type classes
what it means is we explicitly have to
write functions that we want to pass
these things into we also aren't able to
escape scope which means that
polymorphic polymorphic modules don't
behave quite the way that we'd like them
to there are two techniques that are
used to kind of get around this one is
available now
Jeremy yollop and Leo white I believe
worked on a paper practical hire kind of
types or lightweight hire kind of types
which exposes a way to use something
called T functionalisation which turns
ordinary modules into the higher kind
it's a whole thing which I'm not gonna
go into but it's a really cool technique
and you can use it now it's also
actually available for flow and
typescript from a guy called Julio
County I believe to have that same
ability of higher kind of types inside
flow inside scripts really cool the
other way is the same people are working
on a new o'connell compiler that
contains something called modular
implicit and that will give ad hoc
polymorphism effectively to the language
and allow you to use a lot of the same
features a lot of the same benefits but
until then you end up having to use
functors to kind of mimic the idea of
being able to have this generic
implementation code in a lot of places
so one of the only ponds in the
presentation to take a reasonable
approach we basically for every single
branch every single logical branch we
test twice if you nest a logical branch
you test four times if you messed again
eight and so on how many times in your
codebase do you write unit tests that
assert the types of the input or the
output of valid worse than that you can
only ever really test the things that
you remember to test unit tests only
exist when you remember to write them
but you're then at the mercy of your
memories at your tooling or of your time
and as I said before these are the
things that tend to fall by the wayside
when we're rushing when we're pushing
really hard and we never come back to
them types cover many of the things that
we write unit tests for and with a with
a really powerful type system you can
push a lot of thing
up into the type system to cover that
off there faster than unit tests and
they run automatically reason was born
of excitement it was born of excitement
to introduce functional programming to
web development it was born of
excitement teach new developers these
ideas that they wouldn't have had
introductions to otherwise and was born
of excitement to help give us these safe
by default building blocks for the web
the last couple of years in web
development have been years of tooling
fatigue the waiting depth of the amount
of information of tooling of books of
conferences that you have to go to or be
aware of just to be able to ship a
production application if you think that
the number of Mon add tutorials and the
Internet is approaching too much have a
look at how many different ways there
are to architect a redox application
it's it's really a lot of information
out there reason instead ships a
rock-solid pragmatic approach to
delivering an application and it does so
intending to improve the developer
experience and to reduce the cognitive
load so what if instead of writing
software that way that we've been
writing it for the moment we push all of
the complexity down below the language
stack we cut the churn and we give
ourselves some room to focus on the
things that really matter if this has
been interesting please come talk to me
afterwards I'd love to chat if anyone
wants and help getting set up come find
me I'm getting really good at setting up
the reason tool chain come and join the
discord room there's a lot of really
friendly helpful people in there who
would love to help you out and check out
the getting started guide I'm on the web
site basically the get started using
this is about two minutes of work so
it's pretty easy to just get up and
running and if you'd like to get in
touch with me that's probably the best
way to do it thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>