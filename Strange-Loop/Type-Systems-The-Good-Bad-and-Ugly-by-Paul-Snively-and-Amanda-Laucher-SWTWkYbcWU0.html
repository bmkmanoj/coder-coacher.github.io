<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Type Systems - The Good, Bad and Ugly&quot; by Paul Snively and Amanda Laucher | Coder Coacher - Coaching Coders</title><meta content="&quot;Type Systems - The Good, Bad and Ugly&quot; by Paul Snively and Amanda Laucher - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Type Systems - The Good, Bad and Ugly&quot; by Paul Snively and Amanda Laucher</b></h2><h5 class="post__date">2014-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SWTWkYbcWU0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi
we're having technical difficulties oh
uh
okay so we're going to get started
talking about type systems the good the
bad the ugly so what makes each type
system great
what is we're trying to accomplish so
the first thing we have to point out is
we're trying to write better software I
think everybody here has that common
goal and Amanda and I especially for
those of you who were here two years ago
when we presented we sort of stack the
deck in our favor a little bit by saying
we like type systems but we like good
type systems not all type systems are
awesome and to get back to the goal
what's the goal the goal is to make the
right thing the easy thing yeah I really
want to be centered at the intersection
of easy straight and lazy way I'm not
trying to do more work than I have to I
really want to be as agile as I can and
I want to get the most from my money
right like the most bang for my it from
my buck I want the the easy thing to be
the right thing and if I'm working too
hard to make something work or to prove
that it's correct
that I'm doing it wrong so a great type
system really is the cross between easy
and lazy but not all type systems are
great yes we said two years ago not all
type systems are great and so we want to
tell you exactly what we mean by that
how tired are you of hearing Java sucks
I hate Java everybody says it everybody
says it all the time and it's really
hard to understand what they mean do
they understand what type systems even
are it's hard to tell from that
statement because everybody's been
saying it for so long
okay so what's again going on with the
goal there's a great quote from your on
Minsky we used it two years ago we'll
use it again the goal is to make illegal
states unrepresentable and really that
implies the fact that you had to know
what the states can be in the first
place what is an illegal State making
sure that you've done the reasoning
you've figured out the logic to
determine what are those illegal States
and then having the ability to make them
unrepresentable
yep so none of this is original thought
I don't think I've had an original
thought in my entire life this is this
is all about type theory it is and
there's a huge amount of formal
literature out there what we have here
is called the lambda Q
the big beware sign basically means you
know here there be math if we're we're
not going to actually talk much about
all of that but that is the foundation
for what we will talk about we're
basically trying to do a tldr on type
theory here so before we even get
started with any of that I've been going
around the conference pre conference
talking to people and saying what do you
think think about tight systems what are
your opinions where where we even
starting from to make sure we're on the
right track with this conversation and
all I keep hearing is I don't get the
types of bugs that a type system will
prevent and really what that says to me
is that this person lacks the knowledge
to understand what a type system can do
for them so there's so much learning to
do and it'd be easy for me to say ok you
lack knowledge go read but this stuff
isn't documented in any digestible way
also they may have a experience with the
type system but it may be one of the
ones that's on our bad list or one of
the ones that's on our ugly list you
know we don't know right people
understand that if you have a type
system problem and you can't compile you
you'll either have issues if your issue
is a type system issue and you're
running a dynamic language you're going
to crash right not necessarily you're
doing it wrong at that point you if you
think that crashing is the only problem
then you're doing it wrong and you don't
fully understand what a type system can
give you this is Paul's quote oh yes
right and I have to have to look more
closely at interlacing yeah hi this is
this is this is literally what I told
Amanda if the only type systems I was
familiar with we're Java C C++ Azure
goes I'd be a Ruby programmer too
yeah and and this is exactly why we had
so many crappy crappy crappy Ruby
developers that are now crapping crappy
crappy closure developers certain
originally you can be an expert
programmer you can be amazing at what
you're doing and use those languages but
I tend to think that if you're not
thinking about the types then there's a
good chance you're not a great developer
and actually anton van Straten who's one
of the editors of this current version
of a scheme report is fond of saying on
lambda the ultimate that you have types
in your head so even if you are
programming in a dynamically typed
language you are in fact thinking about
the same things that those of us who
work in statically typed languages are
thinking about and why wouldn't you want
to be able to express those in your
language yeah and I met this really
awesome woman last night who was telling
me she made this statement that if you
own fabric softener you can be a
programmer because you have for some
reason come up with some logic in your
head that made you buy fabric softener
so she can take that that idea to make
you the type of person who can use your
logic and put it down in code so really
very cool so all type systems not
created equal so really just right up
front this this is not intended to be
controversial everything we're going to
tell you was a fact
that wasn't a joke so it's not
controversial unless of course you have
some passion for any of these languages
and then you may be a little bit annoyed
with us or a lot of noid with us
there's still facts yes we will to be
fair we will offer some facts and we
will offer some opinions about those
facts but I do want to put one stake in
the ground and that is that not
everything as an opinion there is
actually such a thing as objective truth
so let's dive right in and say what does
it mean for a type system to be good
what makes a type system good right
and for you 80s movies fans especially
bad 80s movies fans here's here's Howard
so what does he got he's he's got a
plate of curry so this is this is all
about the curry Howard isomorphism and
that that is that is what we're shooting
for when we talk about a good type
system and for those of you who aren't
familiar with it the fundamental thing
that it claims is that a type is a
theorem and the implementation of a
function of that type is the proof of
that field Stalin did you guys hear what
he just said did you process that that
that is so powerful you don't think like
that I don't think like that nobody
thinks like that but if you set set back
and think exactly what he just said that
is so important that is so important the
way we write our code if you're not
thinking about theorems and proofs
totally makes sense but you better have
come up with the logic in advance of
writing that in order to know what
you're doing
yeah it's perfectly valid for it to be
an intuition you don't actually have to
be sitting there going oh you know I
have to have this property of my
software that I have to express this way
and I have to you know write the proof
and all that kind of stuff some of us do
do that on purpose for at least some of
our code probably not all of our code
but it's okay if you don't think that
way at all
oh yeah right the function type function
type the function type is logical
implication the arrow I don't know how
many people are familiar with the
symbology of formal logic where there's
a two line arrow that means logical
implication there's a one line arrow
that means function taking one type to
another type under the curry Howard
isomorphism they're the same thing and
so when you write a function you can and
arguably should think in terms of my
type is actually a property that I want
to express a proof of the proof will be
a function and what I've got here is a
couple of scholars signatures one of
which expresses the notion of for all
you want its Universal quantification
from logic you want to say that
something is true for every value of
some type and it's ridiculously easy to
encode in scholar thanks to type
constructor polymorphism I'm not going
to say anything more about that we need
to move on but this is a good example of
how you can express formal logic
concepts in at least one statically
typed programming language so in order
for a tech system to be considered at
all good it has to have the ability to
express some types this is essentially
saying earlier we talked about making
illegal states unrepresentable if you've
thought about all of the inputs and
outputs for your function you can create
some types that actually allow you to
explicitly say I can only accept this
type or that type
yeah so my favorite example the simplest
example that I can think of this is
errors as opposed to legal values so
with some types you have typically an
either type that expresses the fact that
you've got some type that is only going
to be the value is only going to be of
that type when an error has occurred and
then another type that expresses the
fact that there will be a value of this
type if there was not a failure and that
makes a properly constructing code that
handles failure cases in a compositional
way where you're taking these building
blocks and just assembling them together
much easier so and of course having some
types is awesome but and we'll go around
talking about type systems for the rest
of the conference but you need to
understand that there's more important
things than
just the type system you also have to
have language features that are
implemented to help you use your type
system pattern matching sometimes
without pattern matching is essentially
useless you need to have the ability to
quickly concisely express what what do I
do differently in the case that it is X
or Y yeah without without some types of
pattern matching you're probably using
the visitor pattern and emulating some
types with you know class hierarchies
and all that kind of stuff and we all
know how painful getting the visitor
pattern right can be and getting those
class hierarchies right can be if you
haven't seen a statically typed language
with genuine some types and pattern
matching you're really missing out yeah
Paul likes to say that this is like
sushi until you've had it you might not
think it sounds very cool but the moment
you've had it you want more I may not
know you want it until you've had it yep
so and then another thing that you need
in a great type system is product types
in most languages now get this right we
need records and objects and tuples the
problem is is the implementation how
hard is it to get to that how hard is it
for me to spin up a type quickly and end
do you have product types just by
themselves without any of the baggage
that tends to come along with the way
product types are expressed in popular
languages like if all you have the only
kind of product type you have is objects
then you probably get inheritance along
for the ride and you may not want that
and and we've talked about something
else is really important another
language feature that's really important
is currying the ability to do partial
application on these things
understanding what you want to be able
to be partially applied and what you
want to make not possible yeah what are
your tools for decomposing you know if a
product type is a collection of some
thing of multiple other types how do you
take partial views of that structure
language features outside the type
system have something to say about that
and then dependent types dependent types
is like the final holy grail thing right
like you've probably been hearing about
them quite a lot with with idris and
maybe with scala as well yep yeah in
fact Edwin Brady and Miele Sabin last
year here presented a nice comparison of
Scala and Idris dependent types now and
in the future I think was was the tie
and immediately after us Brian McKenna
is presenting on Idris highly recommend
checking that out we'll talk a little
bit more about dependent types as we go
yeah and this is just quick syntax for a
dependent type signature where you're
checking the size of a vector you're
saying the size of a vector plus the
size of an another vector equals the
size of your output is necessary this is
getting ahead of ourselves a little bit
in the sense that we're going to talk
about syntax because that's such an
important thing about non type system
related qualities but this if you see
the app signature here it seems like it
shouldn't be any more complicated than
that if you have a vector of size M and
you have a vector of size n then the
result type had better be a vector of
size n plus n and why should it be any
harder than saying M plus n where you
want that to be part of the type the
funny thing about dependent types is
that's an expression but it's not
checked at runtime it's not going to
generate an assert this code will not
compile if you try to append a vector of
size three and two in code that needs a
vector of size six for example so this
is a very concise overused example that
in the small makes no difference right
like you're you're not going to write
that if this is your only code you're
not writing this because you don't care
but the syntax here is so simple that
when you do put this in your code you
make it part of a bigger picture then it
does become very easy to to reason about
later and it gives you safety that you
don't get otherwise and that's again
where we're fans of compile time safety
yeah
parametric polymorphism boy it's almost
hopefully at this point almost not worth
talking about right because we all know
that Java got you know got generics in
Java 5 and C++ got templates you know
back in the mid-90s I think it was it's
it's hard to think of a statically typed
language that doesn't have parametric
polymorphism go away
so the question really is what are you
getting for free if you're not getting
anything for free then why are you doing
it in the first place
and type systems give you that
parametric polymorphism seems like it
should be default at this point but it
is really hard to implement so it's you
can't just say go away it's hard to
implement they may be released before
they should have yeah it's it's hard to
implement it's hard it's harder to add
later I think the job and C++ experience
was that designing a language without
parametric polymorphism and then adding
it later on a language that wasn't
intended to support it is is brutally
difficult so I'm I'm waiting for the
announcement from the go team that yep
where we figured out just like Java and
C++ that we need parametric polymorphism
ouch
yeah ad hoc polymorphism ISM is a
nightmare having to go through and make
a new implementation of every every
different type signature you want to
support a complete nightmare
so we also feel like it's really
important for a type system to be
extensible and I'll use the example here
where c-sharp has the ability to use a
sync c-sharp extended the language to
have a sink whereas f-sharp has the
ability to make computational
expressions where you can write your own
async you can write your own option type
if you can write if you have the same
tools that the designer of the language
had you are so much more powerful yeah
and here we have to offer a hat tip to a
couple of the dynamically type language
communities the small talk and those
list communities have insisted since
time immemorial no power to the language
designer that the language user doesn't
also have we agree completely
absolutely so okay we're just getting to
the bad and you guys have an intuition
about what's bad about a tight system
right you all hate writing Java maybe
not many of us do that for a living
however you you have this intuition we
want to give you a framework to
determine what's good and what's bad
right so yeah so what's what's bad is
mostly whoops we went we went black
sorry yeah we're suffering from the bad
type system back in the game extremely
tight programming type programming yeah
go ahead
so this is something that we all see
Paul Paul and I were talking about this
and he's like oh it existed the
boundaries of programming's right when
you're doing IO you have tons of strings
right and that's really where you want
to be a little bit safer in most cases
but I have a gripe that this isn't just
at the boundaries this is all throughout
code anytime I'm reading somebody else's
code when I'm hanging out with a client
checking what they've done they're
passing strings around it's like wait a
minute you have a tight system and
you're not using it yeah I think and we
just talked about this before starting
here I think sometimes people who work
even in good statically type languages
are embarrassed to just say type
whatever equals string or type whatever
equals int in other words to use type
aliases to model something that yeah at
runtime it's a string or at runtime it's
an int but to help the compiler out or
help the compiler help you out by saying
this particular type of string really
belongs in this domain this particular
type of int really belongs in that
domain so huge pet peeve is this new
culture that TDD is dead and static type
checking is not required
I would like to assert that if you are
operating under an SLA if you have a
service level agreement based on your
code you are being unethical by thinking
both of these things I don't even see
how you can believe them at the same
time personally but okay yeah I don't
know about anybody else but the majority
of my career has been in e-commerce
which basically means writing a pile of
code that shuffles around to other
people's money and I do agree with the
assertion that you know there is at
least part of your code that you know if
it goes wrong a bunch of other people's
money falls on the floor you do actually
have an ethical obligation to avoid that
and type systems can help you avoid good
type systems can help you avoid that
that type systems can help you avoid it
yeah just a nightmare to do it right so
we already talked about type aliases and
how they're important however so
languages can either be nominally typed
or structurally typed meaning that I
could have a function that will accept
either X or Y in this instance if it's
structural yeah based on its shape yeah
the only consistently structural type
system I know of is a camel's which is
my favorite language right at the moment
static duck typing static duck typing
yeah so if if a if a data structure has
you know X number of fields of types a B
and C and the function expects the
structure with that shape you know those
fields a b x y&amp;amp;z whatever then anything
with that shape will go through so you
know if it quacks like a duck walks like
a duck the problem as Amanda pointed out
earlier when we were talking is that it
is possible to get false positives that
way it is possible to get data that goes
through that you know the behavior isn't
exactly what you want for that data so
you are sacrificing some safety with a
structural type system it's still worth
having some safety in most instances you
you know this still adds benefit so
really the key to a bad dive system is
lacking connection between logic in your
code and in some language designers you
can tell when you when you look at what
they give you the ability to do they
didn't really understand anything about
logic and code being equal yeah yeah
it's it's difficult or impossible to
express and or not at the type level
right it's just basic boolean algebra
stuff that we do you know at the at the
term level at the runtime level day-in
day-out
you know every day of our lives it's
useful to be able to do that at the type
level and you've probably all seen
horror code where people do do that at
the type level in various languages that
will be part of our ugly gun
conversation to some extent jumping
right into the ugly yes
so talking about syntax for a language
really is that's the core of where most
developers spend their focus right like
this is why people love dynamically
typed languages because the syntax is so
concise and is super easy there's not a
lot to learn yeah so we showed the
lambda cube earlier this is something
that's very mathematical you can read a
PhD on it if you like however you
probably don't want to so Paul put it in
a little table so we can see it very
concisely what we're trying to achieve
yeah I want to argue for dependent types
because they're really just the final
piece of the four pieces that you get
when you intersect terms and types you
know what is what do you what does it
mean when you when you pass a term to a
term that's called a function what does
it mean when you pass a type to a term
that's called inheritance or overloading
what does it mean when you have to type
to a type that's that's called
parametric polymorphism or generics or
templates or whatever what does it mean
when you pass a term to a type that's
what dependent types are and we saw an
example of that syntax at least a
function signature earlier in Idris and
we'll we'll talk about that a little bit
more and we'll look at a different kind
of syntax that of dependent ml you'll
notice something interesting and new
here called with type this allows us to
do dependent typing which is
phenomenally great but if you don't know
it and you approach this code if you
come as a new developer on a team that
uses this code what's the first thing
you do you delete all the extra crap
that you don't know what it does right
like oh cool it gets a delete code how
many tweets have you read in the last
month I've been deleting code I've been
deleting code cool
did you remove some of your safety
measures like it was there for a reason
what was the programmer thinking if I
can tell what the programmer was
thinking because the syntax is quite
good then I'm going to leave that code
because I'm going to understand that it
provides me with some safety if I can't
tell what the developer was thinking and
I can't myself read it gone so syntax
matters I think one of the things that
we really want to communicate is is that
it's not sufficient just to have a
really awesome type system the rest of
the language actually matters you can do
really awesome things in Java yes
that's Java like like this yeah this is
League
this is this is a signature from a
challenge that Tony Morris but forth to
to provide just the the type signatures
for a tic-tac-toe game that could never
be in an illegal state you can never
have a board that you could move on that
was from a finished game for example I
write Java on a very regular basis what
I don't ever want to see that I don't
know what that does that better be a
very important piece of code that is
people's lives or a lot of money is
dependent on right or I don't want to
have to go through the trouble to write
it or ever read it if the codes not
going to change very much and it is very
important to my code base I may in fact
to go through the trouble of doing this
but I'm not going to follow that old
adage that comments mean your codes not
good I'm going to comment the heck out
of that yeah yeah exactly and provide
links to sources and all that kind of
stuff yeah this is the kind of stuff
that in Java I only want to see
protecting other people's money or
protecting lives or you know what have
you yes right is that Tim sorry yeah
that's that's a quote from from Tim
Sweeney CEO of Epic Games I trotted this
out two years ago and it was it was old
then it was two years old then but
basically the point that Tim is making
is is this that you can have all the
expressive power you can have a
turing-complete type system like Scala
does like C++ does like Haskell does and
if you aren't able to manipulate the
obvious entities of your conceptual
domain strings numbers you know all that
kind of stuff if all you can do is
inductive data types and get the
compiler to do funny things by figuring
out through typically through type
inference what to do with those
inductive data types that's a royal pain
in the neck and you know there are
libraries that have gone through that
pain that you can use that are awesome
shapeless for Scala is awesome but if
you look at the source code it is
unbelievably complicated so really that
led to something way more awesome the
kind of the Holy Grail being able to use
types and terms and kinds everything
uses the same language yeah and this is
this quote now is from the paper by Tim
Sweeney and two collaborators at
until labs about a new language that
they have designed that collapses all
the syntax for types terms kinds all
that into one syntactic category so you
can not not go through the pain that Tim
described four years ago type level
programming that's really easy with
safety this is so awesome this is this
is the reason people use dynamic
languages but with safety right you
don't have to make all the compromises
that let me rephrase that
at some point you won't have to make all
the compromises that you currently have
to make
yeah
Oh dependent faking dependent types yeah
so in the meantime folks like Ola
Kiselyov have made sort of the cottage
industry out of taking existing
statically type languages typically
already fairly esoteric ones do camels
and Haskell's of the world and doing
things that are purportedly only
possible with dependent types in them
anyway
the approach to this is something that
was actually originally done in the 70s
for the LCF theorem prover and and
that's why standard ml was created and
standard ml was originally the meta
language ml for a theorem prover and you
can still program that way in just about
any programming language statically
typed programming language you care to
name including the kind of Java that we
saw earlier so again it can be done the
question as to whether it's worth it is
very very domain dependent so most the
reason that people hate type systems is
because of false negatives you're
spending your time changing the types
casting to to change things don't really
affect the correctness of your code you
know if my compiler tells me I've done
something wrong when logically in my own
head I've done something I know that
what I'm doing is correct I just can't
do all the casting to make the compiler
happy that's a nightmare that's what
people hate about type systems and
that's what needs to be fixed yeah
that's the that's the overwhelmingly
most popular complaint that I hear is
you know the compilers are skating in my
way the type systems just getting in my
way and with the weaker type systems
that's probably true you probably have a
pretty good handle on what the actual
behavior of this piece of code that you
have in your head is going to be and all
you're worried about now is getting the
compiler to accept it so that it can run
and do what you already knew it was
going to do that I think is probably the
best capsule summary of what a bad type
system is it does nothing really
effective but get in your way yeah so
you either go to a dynamic language
where in my own case I wouldn't be able
to sleep at night if somebody's money
was depending on that or you use this
and you can't sleep at night because you
can't compile your code
a double-whammy so with type inference
type inference is a double-edged sword
right I wouldn't write code without it
because I depend on it I love type
inference it makes my code really
concise I don't have to do type
annotations I want that I love that but
I have this dichotomy it's either
incomplete but expressive or complete
and weak yeah and from a correctness
standpoint there's also the issue the
type inference gives you the most
general type that it can infer which for
the correctness standpoint isn't what
you want what you want is the most
specific type that is actually satisfied
by the implementation so I tend to use
type inference first of all for noodling
around we talked about that two years
ago just the fact that you can sort of
type and go and if you're not going to
concerned about your types at that point
type infants will save you even when I
scale up though what I wind up doing is
relying on type inference for 90% of my
codebase and then for the stuff that's
really critical I actually do spell out
the types because I want more specific
types than type inference is going to
give me so there's a quote by Benjamin
pierce the more interesting your types
the less fun it is to write them down
and then this is this is unfortunately
always true but ideally this wouldn't be
the case in a perfect language this
wouldn't be the case and I think as we
get towards the more syntactically clean
dependent type systems that will change
a little bit because your type level
programming will look just like your
term level program so you have to ask
what's the cost of proof which costs
more to your company which cost more to
yourself not accepting a correct program
or accepting a program that is incorrect
yeah what'swhat's your loss function
what's what's at stake when you're when
your program misbehaves what's at stake
another thing that drives people towards
a language is popularity and I don't
know about you guys in high school but I
bet a lot of us were really weird in
school right like so people probably
would look at you and say I don't really
want to spend much time with them they
probably don't have a lot going on
they're not very popular now we're kind
of the ones running the world
right like seemed like we were going to
be very popular if we were cheerleaders
and jocks but maybe not so much when it
comes to real world importance yeah now
that we're all adults so so part of the
point here is just personality cults are
not very helpful they're not helpful in
the technology world they're not helpful
elsewhere I just had a conversation with
a gentleman recently bless his heart I
don't think he has spent a lot of time
studying these issues but he was he was
talking about talking about go and I
recommend addressed to him and he made
the observation that the rest community
doesn't seem to be anywhere nearly as
large as the NGO community that's
probably true but is that a really sound
basis for comparing those two languages
that drive us right into culture the
culture of a the culture surrounding a
language the culture surrounding a type
system I think like closure has an
awesome culture in some ways like
they're always out learning more new
things their book clubs like these guys
they're the type of people who want to
learn more and grow but because closure
has such a dynamic feel to it because
everybody wants to really rely on that
type closure how freaking cool right
who's using it right what's the uptake
yeah there's a culture that huge
cultural barrier there so there's also
the idea for for Haskell or statically
type functional languages is really hard
to get into those groups because people
won't listen to you unless you have your
PhD in mathematics I don't want to be
told to RTFM when I have to read through
hundreds of pages of mathematical
documentation or to understand anything
so hopefully you know talks like this
people who are out there trying to to
spread the good word are hopeful
you know making it a little bit easier
not using the mathematical terms yeah
this is this is not about being the
smartest people in the room which I
don't think we are not by far in any
case so there is that stigma you know
there is type theory is a real serious
mathematical discipline of theoretical
computer science discipline you don't
have to be an expert in it to get the
benefit of a decent type system and
especially with type inference and
dependent types and a single syntactic
category for types in terms
ah you know we can actually have a
pretty pleasant experience with this
whole thing yeah if you start to look at
all the things that we said are good all
the things that we said are bad and all
the things that we said are ugly
if you matrix close together what do you
come out with really kind of yearning
for something new yeah a lot of research
is still going on and still to be done
yeah in all of this so we put together
this informal hierarchy of type systems
that you don't have to be a math major
to read well we stole from a blog post
this we stole everything we've done yeah
we have we haven't had an original
thought in our entire lives so just
starting with an informal hierarchy you
have the stupid barbaric horrible type
systems that we we all complain about on
a regular basis yeah they're lacking
they're lacking any of the the positive
features really that we started with in
this in this talk in this presentation
but it's the first thing that you do
when you want to write a tech system
because that's kind of a cool thing to
do so you start with stupid right basic
basic correctness you know this is not
adding strings and integers you know
just really obvious kind of simple
straightforward stuff like that I don't
have any time for languages that let me
add strings and integers you know I
don't know about anybody else
most people here do okay then we go into
X passivity allowing you to really say
what you want to say kind of restrict
you from doing what you don't want to do
making illegal states unrepresentable
generally right and
yeah maybe letting you express things in
formal logic terms if you want but maybe
with some pain yeah and then you've got
 yeah right yeah and to be fair when
you get to the dependent type world I
should I should point this out
explicitly are you talking about a
programming language are you talking
about a theorem prover is it a floor
topping or a dessert wax you know it's
in the case of the addresses and Aguas
of the world it's both actually on
purpose yeah and I I generally don't
want to have to think in magic I want to
understand what's happening so I think I
I don't necessarily need to be all the
way to indistinguishable from magic I
want to be somewhere between between
those last two yeah well hopefully
they'll get less magical as some of the
syntax and other non type system issues
get to get solved so then we go into the
more formal way to look at a type system
and to judge it and you have the lambda
cube and this isn't nearly as hard as it
sounds because we saw Paul's table
earlier and it uses all the same words
using the same words plus a little bit
of math stuff yeah yeah these these are
just some categories you can look at
this stuff offline when when the slides
are available in the videos available
but this basically delineates the major
features of type systems and where they
sit on the cube the cube expresses the
fact that it's not actually a hierarchy
it's three-dimensional
there are three axes and that's more
than we really need to say right right
here right now yep but there are tons of
speaker notes download the slides if
you're if you're interested in finding
out where to find more hopefully we're
giving you at least some ideas that you
can walk away and Google the hardest
part is asking the right questions if
you don't know the questions to ask if
you don't know how to compare type
systems if you didn't even know it was a
thing hopefully this gives you an idea
that you can in fact do that so just
some last-minute director notes it's not
all about the type system however type
systems are really really important
they're not created equal there there
are good ones there are bad ones there
are ugly ones and
an important judgment call as to when to
choose to take advantage of them and
when not to or for that matter when to
change languages and change type systems
we believe that it's it's unethical to
not rely on a type system to not work
with the type system if you are if you
are working under an SLA right whatever
whatever that means other people's money
or certain other conditions lives yeah
all the things that can be at stake with
the stuff that we do yeah and also the
last bullet point really is important if
you over the past few years there's been
a lot of new languages and so I know a
lot of people were starting to get
burned out like I can't learn all these
new languages why do I want to so if
you're one of the people who thinks that
we're done we shouldn't have more
languages or we should just have one
superior language that everybody uses
really you need to be paying more
attention and thinking about where can
we go from here and and in the interest
of intellectual honesty we should say
you know we've talked a lot about
dependent types we've talked a lot about
interests it's probably not production
quality yet you know to be honest so I
think what we're really talking about
when we talk about this holy grail ideal
dependent type system with the single
syntactic category blah blah blah is is
sort of where we hope to land a few
years hence we're pretty clearly not
there yet yep
okay so we're out of time I'm Amanda
Walker I work with neo technology the
company behind the graph database neo4j
if you're interested in working with
people who are awesome and thinking
about this type of stuff and working
with Scala or Java or any of any of our
languages please talk to me
yep and I'm pulse knively I'm at Verizon
on cue we're a scholarship as well come
and talk to us
Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>