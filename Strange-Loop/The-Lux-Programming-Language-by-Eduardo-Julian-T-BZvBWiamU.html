<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;The Lux Programming Language&quot; by Eduardo Julian | Coder Coacher - Coaching Coders</title><meta content="&quot;The Lux Programming Language&quot; by Eduardo Julian - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;The Lux Programming Language&quot; by Eduardo Julian</b></h2><h5 class="post__date">2017-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/T-BZvBWiamU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is eduardo de julio and today i
want to talk to you about a programming
language that i created and i have been
working on for a little while now called
Luke's so first a little bit about
myself basically I am a programmer from
the Dominican Republic I work mostly on
back-end software mobile and internal
things I've been working with several
languages mostly closure JavaScript
yahwah sings on 2010 and basically i'm
just a big fan of programming languages
paradigms abstractions and especially
lists and functional programming but
that's enough about myself let's talk
about looks what is it so basically it
is a purely functional Lisp that draws a
lot of inspiration mostly from haskell
ml and closure from Haskell it takes a
lot of the pure functional feeling and
semantics and some features here and
there from closure a lot of the syntax
and overall look and feel for the
language and from ml a lot of
inspiration for polymorphism and it's
module system and I'm actually going to
touch on a little bit of that later on
I also want to stress that Luke's is not
a research language and it's also not a
hobby language it is a language that I'm
making for practical purposes for day to
day programming and precisely because it
is meant for practical purposes one of
the things that I want is for Luke to
target multiple platforms so currently
for version 0.5 of the language it
already runs on the JVM and Android
devices and coming soon for the upcoming
version 0.6 there will be a brand new
JavaScript back-end so you will be able
to write nice client-side coding loops
and even be able to share libraries
across your front-end and back-end
if they happen to both be written in
Luke's Luke's has static types and it's
not optional it is a mandatory static
typing system with type inference as you
can expect from modern languages several
types of numbers strings topples some
types or variants as they're also known
records and of course Universal
quantification or parametric
polymorphism is also known and
existential quantification
and he has many really cool features so
one feature that it has is first class
modules this actually ties back to what
I said previously about Luke's
inheriting from ml so ml has what is
called the modules system which
basically the way it does polymorphism
basically things are they are separating
two kinds you have signatures which are
like interfaces in other languages you
define your methods and constants and
whatever in a polymorphic way and then
you have a structures which are
implementations of those signatures so
for any particular type to implement the
structure and that's what you use for
polymorphism but something that sets
looks apart from other languages in the
ML tradition is that Luke's models
modules are actually first-class values
what it means is that their bodies like
any other you can store them inside
variables store them inside data
structures and you can even pass them
are running functions which is great for
composition for example in this slide in
the lower left there is actually a
function that given equality's for two
different types it actually builds an
equality for a topple of those types
which is a very simple thing but it's
really nice to be able to do and another
example on the left on the right sorry
is building equality for lists on top of
equality for the individual elements
this is very powerful because for
instance in other languages in the ml
family you don't really have that
flexibility modules are a second-class
citizen but in loops you have all the
flexibility you get with your normal
values something else that looks just
great support for concurrency so
personally I believe that nobody really
knows how to do concurrency properly
there are many approaches many
techniques but ultimately it is up to
the programmer to truly decide what is
the proper way to write their concurrent
code some languages want you to focus on
particular paradigms so maybe one
language focus on focuses on actors or
mainly focus on software detection of
memory or FRP in luke's i wanted to
provide options to people and leave them
with the decision of what is best for
their system so looks as great support
support for promises which are by the
way monadic as you
see from the slide which is great
because that way you can write a nice
code that seems synchronous that seems
like normal sequential code even though
behind the scenes everything is working
asynchronously and taking advantage of
multi-core you have functional reactive
programming I apologize that the example
is not particularly exciting but the
slide was already a little bit crowded
and I had to go for something small for
those of you who are familiar with
software transactional memory perhaps
from working with closure or another
language that has that you're not going
to be left behind with Luke's there is
way support for that and in fact you can
even integrate with the other systems
like when you commit a STM transaction
it just gives you back a promise that's
going to get the value of the
transaction once everything has been
committed and and all the variables have
been modified and for those of you who
are accustomed to working with actors
you will also have this here you can
define all your methods define what
happens when the actor dies and spawn as
many actors as you want and this is just
the concurrency level that is supported
right now there are even more paradigms
that are in the pipeline to be added in
new releases and just for the upcoming
version 0.6 there will even be alien
based concurrency for those of you who
may be familiar with that also of course
Luke's being a list it had to have a
powerful macro system but look this
micro system is a little bit different
and I will leave a little bit more
powerful than what other lists provide
in particular it gives you something
that I haven't seen in other languages
which is macros have actual access to
the state of the compiler and this is
not some weird marketing gimmick this
isn't a copy of the state this isn't a
bill into the state is the actual state
of the compiler the very same data
structure the compiler uses so much so
that if you were to modify that you can
actually do a lot of really cool things
in the compiler by altering its behavior
in this particular example actually did
something kind of interesting basically
it may not look like that from from the
name of the macro but basically this
implements
implicit style polymorphism in looks as
a macro so those of you who are familiar
with Scala you may have already seen
that for those of you who aren't but
maybe you know about Haskell
like type glasses in the way that you
invoke a method and the implementation
of the method magically shows up but
basically it takes into account
something about the local scope what
particular definitions are visible in a
scope and that's how you control how the
polymorphism goes basically in this
matter what I do is that I take in the
inputs the function that you want to
invoke and the arguments that you want
to use and basically it extracts type
information for other stuff from the
compiler it does type checking
internally when it looks for the
alternative structures that implement
the signature that you want and then if
there is a single instance that
satisfies that satisfies your
constraints that's the one that gets in
line for you something really cool that
you can also do with loops macros that
other lists don't seem to have is
monadic parsing of the inputs so
basically for those of you who may be
familiar with common lisp a style macros
like obviously how commonly does it and
also closure basically the macro guest
gets the inputs to it as raw ast tokens
or raw code tokens and basically it is
up to you to kind of manually parse
what's going on you have to ask oh is
this a number is this a symbol is this
whatever and the problem with that is
that that's not really very scalable
when you're trying to build like really
complicated and powerful macros that
maybe require very rich syntax so the
idea like in this particular macro I'm
using some very very simple parsing not
hoops nothing very special over here but
in general basically you have these
composable parsers that you can build up
there are partial combinators and as I
said previously they're monadic so the
level of customizability and power that
you can get it's actually pretty pre
amazing and they are reusable so this is
actually very very nice because if
you're writing a library that involves a
lot of macros you can actually reuse a
lot of syntax and that way you can give
your library your library a very
consistent and homogeneous looking field
without actually having to manually
replicate all the parts that you do in
each macro and another really cool
feature that I really like is that
Luke's has first-class types and
basically what this means
this is a types in Luke's our data
structures now for those of you who are
familiar with the list way of doing
things this might sound a little bit
familiar because in lists we have this
philosophy that code is data and data is
code and basically this is the same
philosophy translated to data types and
what you're actually seen on the left is
actually the type of types this is
actually how you build those type data
structures and the reason why this is
interesting is because you know some of
you may be familiar with using types in
statically typed languages but a problem
that those languages have is that they
impose an artificial barrier between
types and values basically you have your
tiles that live over here and your
values allowable there and they don't
communicate there is this a small
wormhole that connects them called the
type checker but the problem is that
only the compiler has access to that
only the compiler can really see both
worlds as far as the programmer goes
types are just this nice
syntactic thing you write it and it kind
of works but types are not things that
you can actually handle I mean when was
the last time that you actually did type
based computation when was the last time
you pattern matched on a type or you
build type at runtime so basically the
beautiful thing about first-class types
that you build those types data
structures and then you give them to the
compiler you say hey this code over here
this is the expression that computes the
type that I want for it so dive check
for me but even though the compiler has
access to it you never lose the access
so you can actually use types at runtime
and you can actually do type based
computation so in there on the right
side of the slide there is actually like
one of the simplest things that you can
do which is just a small function that
given a list of types just builds up a
toppled type by nesting
product types and this this may not seem
very impressive but later on I'm
actually going to show you some really
cool examples of things that you can do
with this kind of technology now this is
all very nice but cool features don't
make a cool language there has to be
something deeper something fundamental
that ties everything together some
vision some philosophy behind the
language
now I actually want to talk to you about
what is the foundation of what I am
trying to do with Luke's so one of the
things that I want is for Luke's to be
an omni platform language and this
actually ties back to what I said
previously about Luke's targeting
multiple platforms like the JVM Android
and JavaScript however I don't want
looks to be multi-platform I don't want
loose to run in some places and not in
others
I want looks to run everywhere and the
reason is because personally I feel some
measure of frustration with the current
state of the software industry like
right now we have a very fragmented
model of development if you want to
program in one cell phone you've gotta
use this language but another cell phone
requires a different language if you
want to run the browser you gotta use
JavaScript the only place where we get
varieties like desktop development and
server-side because we have many
different languages but even then we
have constraints like if you want to do
something like real low-level you gotta
go with C and C++ everything else is
just not good enough basically what I
want is to give people the capacity to
do whatever they need in loops we are
having to use another languages
basically because you know why is it
that we need to relearn the same things
every time we need to go to another
language why is it that we have to keep
re implementing the same libraries and
the same frameworks for doing the same
things just because we need them to run
in different platforms I want something
different for loops and I also want
looks to embrace the past I know that
there are many companies that have
already made significant investments in
other technologies like Java Python Ruby
and JavaScript and I want people to be
able to interface with those languages
and be able to reuse their investment we
are having to rewrite everything or
having to port things however even
though one looks around everywhere
everyone looks to be constrained by
anything Luke's in a fundamental way
needs to be a platform independent
language the philosophy is right ones
host anywhere and the reason why I say
that is because they're having other
languages that have started one place I
have tried to go somewhere else maybe
they started on the JVM and they
to go native or they wanted to go to
JavaScript but a mistake that they
always made is that the fundamental
semantics of the language got tied up
very early on to the first platform
where they started so maybe the
semantics of the language is dependent
on the JVM or dependent on JavaScript
and what that does is that later when
they want to migrate the language to
somewhere else either they have to
replicate the semantics of the host
platform somewhere else which is
obviously not always possible or they
basically tell you hey this feature we
can replicate somewhere else oh I'm
sorry you're not you're just not gonna
get it and as a consequence when you
want to use a library between platforms
you gotta ask yourself is this going to
work here or did somebody put manually
port this library to the other place so
I can actually reuse it and really
complicates development what I want is a
no code change policy for libraries in
looks basically if the library works on
the JVM
it has to work completely unmodified on
JavaScript on dotnet and whatever you
want to use it and this doesn't even
have to be at the level of libraries it
can even be potential at the level of
programs like imagine the possibility of
writing a database engine in looks and
then you can get it to compiling the JVM
you can get it to compile natively or on
dotnet but let's go even crazier what if
you actually want to use it on the
browser all you will need to do is
change the underlying the underlying a
storage layer so it uses local storage
on the browser something else to store
the data but the rest of the code is the
exact same thing that could be running
on the server the query optimizer all
the machinery no changed necessary and
it may sound really weird but I actually
want to achieve this platform
independence without sacrificing access
to the host platform and the power that
it gives you because we programmers have
a bit of a pattern for achieving
independence basically we just create
this nice abstraction layer and you're
supposed to build all your software on
top of that but you're not supposed to
ever go beyond the layer and as a
consequence you end up with this sandbox
that gives you independence at the cost
of power basically the idea is that the
Luc's standard library will provide
the precise means for interacting with
your particular platform and it will
always be tailored to the platform so it
will be a model for specifically doing
JVM interrupts a model for specifically
doing just interrupts you will not have
like a generic FFI layer that kind of
works everywhere but has its issues none
of that you will have all the power
without the constraints and I also want
looks to be a language for deep meta
programming and this ties back a lot to
its Lisp heritage but also to what I
said before about Luke's programs having
access to the state of the compiler and
types being first-class data structures
so one really cool thing that you can do
once you have those two things access to
type in information and being able to
type based computations is that you can
even implement a type checker in peer
loops and I actually did that in the
local standard library that is actually
a pure Lex implementation of the entire
looks type checker and this is just a
gimmick like right now I am actually in
the middle of rewriting the loop
compiler in peer looks and the type
checker and the compiler is actually
going to be the one from the standard
library so in the future if you ever use
this model you will act you will
actually have the exact same feature set
the exact same correctness as the
compiler gets with no difference
whatsoever and with this kind of power
you can implement some really cool stuff
so this ties back to what I talked about
before about implicit style polymorphism
so what you have in the example in the
middle well bottom middle with the
filter basically this this is how
polymorphism in language like standard
ml kind of works so basically you define
your polymorphic functions in a
signature but then when you want to use
it you have to actually get the precise
structure that implements your signature
for your types however this can get all
pretty fast especially if you're using
methods from the same structures over
and over again you don't want to repeat
yourself so basically with the power of
being able to access types from the
compiler and being able to do type
checking in peer loops I was actually
able to implement the implicit style
polymorphism macro which is it checks
your function it takes it checks your
arguments and it says okay
what structure I can find that satisfies
this comes
trains and it just ends in Lancet for
you thereby making polymorphism in looks
far more easy to use and finally there
is another thing that I want to talk
about which quite sadly none of the
examples that I could get in loops were
small enough to fit in a slide which is
politic programming so for those of you
who may not be familiar with this
approach basically the idea of politic
programming is that better algorithms
that if you really think about it they
are not specific to a specific to
particular types but rather they are
more generic across shapes of types or
families of types so there with politic
programming is that you can define your
algorithms based on the primitive
elements of what types are made of and
how to combine them and then you provide
a particular type and you say hey make
this algorithm for me customize it and
then you're basically getting code for
free in a type directed manner so stuff
that you can implement is things like a
length or size function like you know
you can get the length of an array a
list a set a hash map a tree you can get
any kind of thing implementations of
equality like what I showed previously
on the slide on structures let's say
that you wrote a back end in loops or
some other type checked language but now
you have to transmit your data to some
JavaScript front-end how will you do
that you're gonna turn to Jason now if
you're using javascript it's pretty easy
but if you use another language you may
have to write some function that
transforms your data types into JSON but
there's actually a very straightforward
thing it's pretty obvious so why should
we do it
why can't a machine do it for you well
actually with quality programming you
can actually like generate binary
encodings Jason and codings
automatically in a tile directed fashion
you just give me the type and you get
your code for free now all of these are
things that you could have figured out
by just checking the loops repository or
even checking the loop documentation
however I wanted to make this a strange
loop 2017 talk truly special so I'm
actually going to show
you something that I have kept healing
and secret even from the loose community
for a few months now because I wanted to
show to you guys as a stretch live
exclusive so pretty soon looks is going
to become a really final language now
this sounds really weird like what does
it even mean for a language to be really
finable well actually a few months ago I
was thinking about you know what can I
do to make looks even more powerful what
can I do to make looks transcend what
even other languages have been able to
accomplish up to this point and I
actually came up with a few interesting
observations and ideas so if you think
about it least have a very well-deserved
reputation for being incredibly
extensible and customizable and that is
because they have macros which allow you
to extend the syntax of the language and
that way you can really implement some
pretty powerful features that in other
languages will be simply impossible
however even macros have limitations
because ultimately macros must be
defined in terms of the fundamental
primitives that the language exposes so
what happens when you want to do
something that are a fundamental level
the languages doesn't allow well the
answer is simple you cannot do it
because there is no way to implement new
primitives there is no way to
fundamental extend the capacity of the
language so what if you could define new
primitive functionality just as easily
as you can define new macros now this
sounds like a really interesting
proposal how does this even look like
well in the same way that you can use
macros to extend the syntax of the
language what if you could teach the
compiler the meaning of new kinds of
expressions and if you're introducing
new kinds of expressions it makes sense
that they're going to be optimized in a
different way than everybody else so why
not also teach the compiler how to
optimize new kinds of code and of course
like even semantics optimizations have
their limits you still have to work
within the constraints of your language
so what if you want to break free of
that what if you want to teach the
compiler hard to dinner
new bytecode or new javascript code for
whatever is you're trying to create and
escape the boundaries of the language
and go directly into the host platform
and all of this as simple as defining
macros but I didn't want to stop there
I want to take things even farther
because with those kinds of extensions
all you do is extend the stages of the
compiler but what if you could reshape
the entire compiler as a whole so Luke's
compilation looks like compilation for
every other language you know you some
parsing some analysis some optimization
at the end you generate some code but
what if you wanted to have let's say
like really really really optimized
programs and you want to have even more
atomization you want to add extra passes
of the compiler into the pipeline or
maybe you think you know what I don't
like the looks type system it's not
rigorous enough for me
I want dependent types or maybe you're
doing some concurrency and doing some
resource handling and you want linear
types or that or maybe you don't want
types at all and you just want to have
the freedom of dynamic types why not be
able to change the entire analysis layer
for a different one and leave everything
else unchanged and have everything work
seamlessly and this can be done to
achieve like really amazing things like
maybe you want to have the same language
the same syntax and semantics and the
same optimizations but maybe you don't
want looks to be an eager language maybe
you you love Haskell and you want the
same laziness you can simply change the
code generation layer and now you have
laziness for free now it's really nice
to talk about all of these features in
the abstract but we are programmers we
solve real problems so what can you
possibly gain from these kinds of
features so actually I believe you can
gain quite a lot so for instance
something really cool that you can do is
introduce platform specific
optimizations into the compiler that are
going to be applied pervasively across
your program instead of a per use basis
as we tend to do as programmers I mean
think about it who knows how to make
your program faster some random guy on
the internet writing
generic optimizations for programs or
you who is actually solving a real
problem and who actually knows real
things about the
in which you're working so then you can
also do is bypass Luke thus capabilities
and introducing new power by accessing
the host platform so maybe the way that
you want to achieve higher performance
is by introducing SIMD instructions or
vector instructions for high parallelism
in your programs but Luke's doesn't
support that but who cares why should
you be constrained by what Luke's can do
what can you use teach the compiler hey
this kind of code I want you to use SIMD
for it optimizes for me and then voila
higher performance for those of you who
are like real fans of hardcore
programming and interesting paradigms
you could also use this to input to
efficiently implement new programming
paradigms so maybe you have used Prolog
or other logic programming languages and
you want the same thing in looks but you
know the problem with encoding one
paradigm into another is that there is
often overhead if you have to encode
logic programming in functional
programming there is always going to be
some inefficiencies because of the
encoding and calling a bunch of
functions and whatever what if you could
teach the compiler hey I know how to
compile logic programming code in a fast
way this is how you do it and not only
that but you can get that while still
being able to interface your way of
compilation with the rest of the
compilation pipelining looks such that
your code can interpret with the rest of
the loops ecosystem and thereby you get
performance without sacrificing
compatibility something also something
really cool that you can do is transform
and instrument looks programs in a
thorough way so maybe you want to add
pervasive lobbying and tracing for
debugging purposes or maybe you are a
fan of aspect oriented programming and
you want to add a code weaving layer at
the end of the pipeline to perform per
basic transformations across your
programs all of this can be done or will
be doable and to go even crazier what
about the possibility of even running
other languages on top of Luke's and
having them interoperate
because if you really think about it if
the entire pipeline can be modified you
know
which is departure and thus get a new
syntax I can get new semantics new
optimizations I could run Python on top
of Luke's
I couldn't JavaScript on top of Luke's
I've run even new languages on top of
Luke's and looks glenda becoming a
platform for polyglot programming in
such a way that languages can benefit
from the future support for all the
platforms that looks gonna run and
double that work with other languages on
top of loops so the same program could
have JavaScript called foreign analogues
at Python code run alongside loops code
and it's just the same program working
as a whole so one can you expect these
kinds of features so for the extensible
semantics optimizations and code
generation is essentially gonna come
pretty soon so the upcoming version of
loops will be 0.6 which is gonna come
sometime around November and that's
where the first batch of of this feature
is going to come for the really final
pipelines I'm actually gonna have to
figure out a stuff out away about figure
a few things out about the design to
make sure that it fits well together
with all the other features on the
compiler so let's push it a little bit
later for version 0.6 some time mean
2018 now I want to stress that this is
21st century programming for far too
long
programmers have been at the mercy of
language designers for far too long
self-styled gurus and experts from the
internet have been telling you how to
write your code people who have never
taken a look at your code bases or
solved your problems are telling you how
to do your job I want to change that I
believe those days are over and it's
finally time to give programmers the
capacity to truly shape their
technologies based on what they need and
what they want from now on you will be
the master of your own code from now on
you call the shots
so what can you learn more well the best
place is reading the book I actually
wrote it and it's always going to be
maintained to measure the current stable
release of the language I didn't have to
worry necessarily about the URL
yeah you can look it up on Google get
book looks programming language and it's
going to show up very fast and for those
of you who want to contribute please
feel free to fuck the repo we're always
happy to get new hands and if you want
to say hi and chat with with everybody
we actually have a chat room indeed err
so feel free to come in and say hi
finally I want to welcome you to the
future and thank you very much for your
attention
so I really we have a few minutes so if
anybody wants to ask any questions feel
free
I've looked a little bit and they're not
really an expert in racket from what I
have seen it seems you know maybe I'm
wrong about that
oh wait I should have said the question
so basically he asked about if I had
looked at racket about how about
implementing new primitives into the
language so basically what I have seen
it seems maybe I'm wrong but what I have
seen is it's more like you can like
really fine how racket does a few things
like function application and stuff like
that so when you run another language on
top of that like things are so our
rebound at such a fundamental level that
they behave differently now I don't know
if that works like any compiled time
setting or if it's just like an
interpretation thing but Luke's is meant
to be a compiled language so it is not
to rebound things in a dynamic way so
the runtime behaves in a in a particular
way but teach the compiler hey if you're
going to run in this particular place
this is what I need you to do to get the
features and the performance that I want
so it's all about interfacing with the
host platform
yeah so basically a question was
basically how does the house the feature
of the platform portability and the no
change policy for loops libraries it's
gonna work so basically there are two
particular ways in which I can do that
there is one particular way that has
been explored already in Common Lisp and
enclosure which is for those of you who
may be familiar with the closure dot C
AC files basically you provide like this
snippets of code that say okay when you
compile to the JVM do this when you
compile to JavaScript do that that is
one particular way however that is not
my favorite way it's gonna be in Luke
0.6 and onwards but there is another way
that actually I'm very more and more
interested about which is the idea of
writing platform and specific module
implementations so basically let's say
that you have a file called foo dog
looks the same module in some library
and it's going to suppose some features
but there is one particular way of
implementing those features on the JVM
and there is a very different way of
doing it on JavaScript so what you can
do or what you will be able to do
because actually gonna come for version
0.6 is you will be able to help a full
dot JBM dot looks file and the food the
gesture looks file and for those
platforms that don't have the native
machinery that you need but you could
possibly emulated in pure loops if you
had a normal food that looks file that's
gonna be used as a default in case you
don't have a special file and so the
idea is that you can write libraries
that depend on platform platform
specific functionality but if the hosts
of platforms that you care about all
support them in one particular way to
implement that and then when somebody is
your module they just call the full
module and they don't care where it
comes from and then the feature just
works
anybody else Oh
I'm sorry please repeat a question
okay so basically the question was you
know talking about platform dependence
in terms of optimizations how it's done
so basically in a way there will be like
two different kinds of optimizations in
looks so the looks pipeline what it does
is that the optimist a the optimization
phase takes your program and basically
generates like a procedural version of
how it works but it's abstractly doesn't
depend on any one particular platform
the idea being that the code generation
layer then interprets that and says okay
this is the abstract version of how the
code is going to run let me translate it
into the actual JVM version so in that
particular part those optimizations will
always be cross-platform because they
don't depend on any particular platform
by themselves as far as what the
messages that are platform specific you
will be able to just introduce them in
the code generation layer but at that
point is already platform specific so
there really won't be an issue yes
yeah actually let me go to the slide so
actually all types are modeled as data
structures so in the case of of the
function from A to A it would just be an
universally quantified type like this
list of type is just like the
environment of the type lambda so in
this case will be empty so basically it
will simply be a universally quantified
type where you know it becomes a
function or a lambda type from a bound
type 0 which will be the index of the a
variable to the same bound type 0 so
yeah you can use pattern match on it and
say okay what is this type made of and
what can I do with it and in fact
several macros in the log standard
library pattern matching types to
generate code of various kinds if that's
what you want then yeah sure
how I made a decision to make a type
list or the languages you know it
Douglas
okay well the question was how I came to
a decision of making a typed Lisp well
basically it basically came out of
frustration so a few years ago was
actually doing a one - start-up where I
was building a product enclosure
actually and I'm a big fan of of
refactoring and polishing my code and I
often found myself like breaking things
and spending days like fixing whatever
the hell I broke so my first instinct
was actually to use code type which is
an optional type system in Luke's but
also in enclosure but for a few reasons
that are not going to get into right now
let's you say that coded that didn't
really meet my expectations and then -
it was to go to Haskell because has -
has great eyes but the thing is that I'm
a little bit too obsessed with lists so
I really couldn't do it so then I
figured out hey if I cannot have a list
that I need and I cannot have like the
times that I need I'm just gonna put
them together and and build something
for myself and that's how Luke's came
into being any other question
well as far as this low Oh quake so
basically the question was this features
are nice but of these figures that I'm
going to be introducing which ones will
have like the biggest impact on the
performance of the compiler so what
hurts the most to us to us well
basically the the pipelines because as
far as the extensible extensible
communication system suppose semantics
and code generation that actually came
up while I was doing the rewrite of the
compiler into peer looks because I had
this concept at a low level and loose
called hosts procedures which are
basically like like functions but only
the compiler knows how they're
implemented and that's how I implemented
things like arithmetic and stuff like
that so that higher-level code they
could then invoke it and what I was
doing the rewrite I actually started
grouping those functions in the compiler
using a hash map and then I figured hey
family using a data structure then
technically these things are dynamic so
why don't I expose blocks for people to
start adding stuff however that doesn't
really like change things like at a very
drastic level because it's basically the
same machinery and you just adding stuff
what could have a bigger impact on the
complexity would be the pipelines and
that is actually why it's gonna come
later
in 2018 because I actually needed to get
it to work with some other important
features of the compiler like parallel
compilation and the caching that the
compiler does and that can get a little
bit tricky so that will be the most
complicated thing so I think we're
already out of time and so if anyone if
anyone has more questions and feel free
to grab me afterwards thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>