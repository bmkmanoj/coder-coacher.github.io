<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Modelica: Component Oriented Modeling of Physical Systems&quot; by Michael Tiller | Coder Coacher - Coaching Coders</title><meta content="&quot;Modelica: Component Oriented Modeling of Physical Systems&quot; by Michael Tiller - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Modelica: Component Oriented Modeling of Physical Systems&quot; by Michael Tiller</b></h2><h5 class="post__date">2016-09-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-mvEUuc-sWE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm going to be going kind of
a lot of background in this talk that I
can't assume everybody knows so just I
will try and and then see it clearly and
and give people time to think but but
like I said there's a lot of ground to
cover here so I'm going to be talking
about delica which is a component
oriented modeling language for physical
systems so I'll give you a little bit of
my background just so you understand
sort of how I came to be here
so I've always been fascinated by
programming I suspect I have this in
common with many of you that even as a
little kid I was I was fascinated by
programming I've been doing programming
all my life and I really find it to be a
just a fascinating field
I was also as a child really interested
in math and physics and and that turned
out to be really fortuitous I think
because I find that it's a really
powerful combination math and physics
and science and engineering for that
matter give you lots of interesting
problems to work on that have
computational needs and knowing how to
program and knowing you know
understanding you know how computers
work and algorithms and so on I think
really really can have a big impact in
those fields so I consider myself
fortunate to have sort of those those
combined passions that have such a
synergy together ultimately
professionally I should say
educationally I decided to go into
engineering and so I got a PhD in
mechanical engineering but there was
always an emphasis in the work that I
did on doing on the computational side
or the software architecture side of
things but I have I worked for example
for Ford Motor Company I have always
tried to stay in the engineering and
mechanical engineering field so I you
know worked on you know cars and things
like that as part of my work I'm a
contributor to the Medeco specification
to the metallic standard library and
I've also written two books on the
delica but I also want to make it clear
as part of this background that
medela key effort as a whole was
initiated by a guy named Hilding um fist
he's considered to be the father of
medela qey I'll talk a little bit more
about him later
the madoka sociation itself which is a
non-profit that's set up to sort of
champion open standards in this area is
chaired by a guy named Michael by a guy
named Martin Otter who is
honestly the hardest-working guy that I
know and there are many many other
contributors to the Medela key effort so
I just want to make that clear even
though I'm the person giving this talk
so I'm gonna start in the beginning not
surprisingly I'm going to talk about a
time before cat videos before the
internet before personal computers
before even Lisp itself we had any AK
alright so any act was the first real
computer this was developed by the
government I'm not sure how many people
actually know why it was developed but I
can tell you it was developed to help
the military compute artillery firing
tables essentially these were
simulations so you all know your jobs
probably to simulation because that was
really the impetus for essentially the
revolution that that followed so I
decided I would use this problem
actually as a segue into talking about
Medela kheh so you can imagine you know
firing artillery you know that's kind of
what it looks like when you the
trajectories that you generate
ultimately what the government was
interested in was generating things like
this this is a table that tells you
different firing angles different wind
directions different air conditions
where the where the shells are gonna
land that's really what they care about
right so that's what they were going
after and this was actually surprisingly
difficult to do pre computing right
because you had to have people manually
doing this and of course that's pretty
error-prone so the math and physics
comes in as follows so there are set of
differential equations that you can use
to to model the behavior of a projectile
I've put together some equations here
and there you know there's many
different ways you can model these
things and there may even very well be
errors in these equations but you know
they're they're pretty representative I
think so this includes things like the
wind direction and and it essentially
takes into account the equations to
calculate the position and the velocity
of the shell as it's moving through the
air takes into account gravity things
like that you have to also with these
kinds of systems you have to essentially
initialize them at the proper conditions
so this is an example
how you would get this system moving
which is to say assuming a certain
muzzle velocity from the gun and the the
azimuth and elevation angles you know
what would be the initial direction that
these shells would be heading so this is
the math involved okay but then there's
the programming and that's where it gets
really sticky so you can imagine you
know take there's I showed you the
equations there's an example of a
differential equation that's a
continuous piece of mathematics it
doesn't really lend itself very well to
being put into a computer until you
discretize it and so that's the part
where we're going to do this
discretization we're going to say well
we're going to make an approximation
here to some of these continuous terms
and refer to them in in terms of
successive values of time and successive
values of velocity in this particular
case and in doing so we can take
something like this this equation and we
can transform it into an assignment
statement so I want to be very clear
about this
the first thing there is an equation
it's a relationship between expressions
it's not an assignment statement but
what we've done by manipulating things
is to get all the terms that we know on
the right-hand side and the one thing
we're trying to solve for on the
left-hand side and we've turned it into
an assignment statement so you know I
mean I think you can look at that and
figure out what's going on here right we
are gonna we're gonna end up with this
assignment statement where we calculate
the new velocity in terms of things like
the drag coefficients the old velocities
the wind directions the time step that
we're taking the mass of the shell and
so on so you know you can do it right
it's I think the mapping is kind of
straightforward there but there are
gonna be some themes that emerge as you
try and do this over and over again and
one of them is the manipulation required
so the first thing to note about that
manipulation is that it's tedious
time-consuming and error-prone and one
of the reasons we developed ENIAC in the
first place was to avoid a lot of
tedious time-consuming error-prone stuff
I'm just taking it another step further
and trying to get it so that we can not
just do all the computations but we can
actually do the math in a way that isn't
tedious time-consuming and error-prone
another thing to keep in mind is that
I've shown you a very simple equation
which can be transformed into a
imperatives
easily but I can tell you it's very very
hard to do this for the general class of
problems that Medela addresses which is
you know the formal way of saying that
is that these are hybrid nonlinear
simultaneous differential algebraic
equations which sounds like a mouthful
and it is it's really actually quite
hard to deal with these things
especially when you're trying to make a
language that allows you to moderately
compose these things in a way that non
experts can can can engage in that
activity and not have to deal with all
of the complications that come after it
another thing to note about the process
so far is that it's forced us to
prematurely decide on variables in the
equations that we want to solve for
which is is something that you know
hinders us down the road I won't go into
too much of that now it also forces us
to make a solution method you saw that
descritization scheme I came up with -
in order to get this thing to be an
imperative statement that's something
called forward Euler and it is the
arguably the worst numerical method
possible it has the value of being
simple and that's about it and so it
turns out that there are lots of
different numerical methods that have
different properties you might want to
use but if you mix them in right away
together then they become inextricably
combined it becomes very difficult to
change your approach later on so we
don't want to do that either
so let's talk about my delica because
this helps solve a lot of these issues
Souma delica is a declarative statically
typed language for describing physical
behavior it's the goal with medela is to
encapsulate the mathematical behavior
into composable reusable component
models these are the things that you can
then drag and drop together in order to
simulate a system I like to think of
them as like Lego blocks but in order to
make the Lego block you have to
understand the math that goes on inside
one of the big advantages here is it's
going to defer a lot of this really
tedious time-consuming error-prone and
hard manipulation of equations to the
compiler and I'll talk a little bit
about the algorithms involved in that
and the focus really in medela is on the
problem statement it's on the underlying
behavior that you want to model and how
you want to compose your systems
together and all this really hard stuff
isn't really you know that gets I guess
I deferred to the computer and the
compiler rather than to the engineer who
builds these things and I mentioned
Hilding uncas before he
pioneered this work in fact he did that
he started this work it's kind of a
funny story he started this working
during his thesis his PhD thesis work in
the 70s I think and computers just the
algorithms involved in doing these
transformations are so difficult to work
with they required so much memory that
he basically did his thesis and then had
to put the whole thing aside for like 12
years until computers actually caught up
to the point where they could handle
these kinds of problems in the in the
90s but anyway he helped initiate this
Medela Association which is a nonprofit
that helps advance these kinds of
standards and Mudd the helical language
is something that came out of that so
let's go back to this artillery model I
talked about before and I'm just gonna
sort of walk you through the syntax of
the delica at a textual level so when
you want to make there's the complete
model but I'm gonna go through sort of
step by step we've got this artillery
model we just you know delineated by
these model and end keywords hmm can I
make it bigger yeah it's gonna be on the
I'm gonna go through step by step on the
right so the this has a bunch of
parameters this model that these are the
knobs you can turn in building this
model so that there's a there's a mass
there's a velocity there's a wind
direction there's the firing angles the
the drag coefficients these are the
things that we can sort of play around
with there and they're often that the
columns in the table in addition there
are some variables that we're going to
solve for the position and the velocity
of the projectile as it's coming out of
this and then finally the the not
finally actually next the initial
equations which are going to describe
the initial conditions of this
simulation you'll notice a couple things
here one is that you know there's a
vector notation that you can use when
when describing mathematical equations
and then finally and maybe most
interesting is the behavior and here you
will see the two things you'll see the
continuous equations that we saw it
before essentially I just represented in
in medela Kasese that have time
derivatives of different terms in here
we have vectors we have all the
different parameters that we talked
about before
these are continuous equations
continuous differential equations they
apply at all times in addition we can
describe discrete behavior and you see
down here this when Clause so this
essentially doesn't apply all the time
this applies once the projectile has hit
the ground and then we stop the
simulation so this is our way of
signaling that this is the end of the
simulation there are other things we can
do if you're stimulating for example
logical circuits you could have you know
behavior related to gates changing
values and things like that so that's
just an example of Medela kemal just to
give you a concrete sense of what Medela
qey looks like and is if you take that
model and then you simulate it for
example for different headwind values
when firing a shell you'll get a
trajectory out of it like this so that's
probably what you'd expect at least
intuitively qualitatively so now let's
talk about the component oriented
aspects of the language so I mentioned
before that the goal here is to have
people like engineers compose these
things by dragging and dropping pieces
together and in order to do that we need
to we need to go beyond this just
writing out a bunch of equations in a
flat way and need to create components
reusable components so the first thing
we have to think about is how these
components are actually going to
communicate with each other and when
you're programming in an imperative
sense you can think of functions and you
can think of them as having input values
and output values but we don't really
have that here instead what we have is
points at which different components
interact but there's no real input or
output you know when you think about a
resistor you don't think about it as
having voltages and input and currents
as an output it just is a thing that has
a relationship between voltage and
current but but actually how that plays
out depends on the other things that
it's connected to so we have this
concept in medela kheh of what's called
a connector so given a resistor we would
generally think of a resistors having
two ends to the resistor we could just
arbitrarily call one the positive end
and one the negative end and in that
case we what we do in Medela cos for
electrical components we define this
connector and the connector says that
there are really two pieces of
information that we're going to
associate with
each end of this resistor there's going
to be a voltage at that point and
there's going to be a current that's
flowing through the wire at that point
so those two things are defined here in
this in this connector definition the
fact that current flows through the
element you can is indicated by the fact
that there's a flow qualifier in front
of it and once we have this then we can
we can actually use it in describing how
we would build a resistor so let me walk
through that process I suspect a lot of
you have been exposed for example to
Ohm's law so let's just walk through
this so Ohm's law most people think of
it as V equals IR being a little more
rigorous about it
it's actually the what it says is that
the voltage difference across the
resistor which is that first term there
VP minus VN is equal to the is
proportional rather to the to the
current flowing through the resistor
right so that's that's a slightly more
rigorous statement what that means in
Medela k is going back again to that
diagram of a resistor over there what we
do is you say we're going to create a
model of a resistor it's going to have
this resistance parameter that's a knob
we can turn different resistors that we
instantiate can have different
resistance values each one will have a
pin we're going to arbitrarily again
call one of them P and one of them n so
those are you know the positive and
negative terminals on the resistor and
then we can create in the equation
section a description of that that
components behavior Ohm's law comes into
play here we see right there we're going
to take the voltage at the positive pin
subtract the voltage of the negative pin
and set that equal to the current
flowing through the resistor times the
resistance right that's almost law
there's another thing we need to keep in
mind about a resistor and that is that
it doesn't actually store any charge and
so that second equation is really just a
formal way of saying that whatever comes
into this resistor in the form of
current is going to flow back out again
and that's it now we have a resistor
model and we can then compose that with
other systems now or other components so
let's talk about those other components
typical examples of simple electrical
systems or electrical components would
be capacitors or inductors so let's walk
through that process these are the
equations for the behavior of a
capacitor and an inductor it's not super
important to really have
intuition about what those really mean I
just want to point out that they are
relationships between the difference in
voltage across the component and the
current so this is actually slightly
familiar because we saw this same
essentially the same thing with the
resistor the equations are slightly
different but the big the main players
here the voltage difference in the
current are still there so I'm going to
use that as an example to introduce how
we how inheritance comes into play in in
madela kheh so what we want to do is we
want to factor out the common aspects of
these different pieces the resistor the
capacitor and the inductor and if we
look at this model and you'll see here
this model says partial which means it
doesn't represent a complete description
of physical behavior it's only a it's
like a base class this partial model has
many of the same characteristics we saw
before in the resistor it's got two pins
it's it has actually internally two
variables V and I which represent the
voltage difference in the current and it
also has a conservation equation that
says that whatever current goes into the
component goes back out again these are
going to be the common properties of all
the components that we're going to show
and so I factored them out into a base
class and in doing so what that allows
me to do then is to describe the
behavior of the resistor like this so
the resistor model then just simply
extends from two pin gets everything in
there that is defined and focuses on
what makes a resistor unique versus a
capacitor or an inductor so and that is
the fact that it has a resistance and
that it has Ohm's law and because we've
created these helper variables over here
on the Left the voltage in the current V
and I we can write Ohm's law actually in
the form that most people are most
familiar with it but we can then use
that same we use that same code to
create a capacitor and to create an
inductor so now we're sort of now
removing now we've got a few components
that we can put together so let's do
that so now if we wanted to create a
network of components here's an example
that's purely textual so in medela key
you can not only just declare simple
scalar variables and equations you can
actually compose systems hierarchically
so what that
means it when I create a model like of
an RLC circuit I can instantiate within
their resistors capacitors ground
elements the the components that you
typically see they're a step current for
example to excite the system those all
have parameters so you can see in the
resistor where R comes into play here
we're going to set the resistance to be
10 and then in the equation section
instead of having equations like V
equals IR at this level what we're
actually going to do is we're going to
establish connections so those connect
statements are actually equations what
the stand for is the idea that we're
gonna they're like wires connecting the
resistors in the capacitors but they're
idealized there's no losses in them you
know energy and charge are conserved
across those pieces
so essentially what those connect
statements are is a an abstraction of if
you're familiar with Kirchhoff's current
law and Kirchhoff's voltage law they're
in there to tell us that essentially
these are just ways of connecting the
components they aren't behavior
themselves and they will generate a
bunch of equations as we'll see in just
a second
automatically for us so I want to show
another example it's a little more
practical this is an example of an
industrial robot model in Medela kheh
and if we dig down into this I just want
to show you this sort of the hierarchy
of a more complex model so we start off
at the top level there's a model of the
mechanical aspects of the system you
know 3d pieces of the system and then
there's models of each individual axis
which involves a motor and a control
system and if we bore down into each of
those axes you then get a model that
looks like this where you've got a set
of gears you've got a motor you've got a
controller you've got some sensors and
then if we bore down even further into
just the the motor itself we see
resistors fasters operational amplifiers
some gain blocks some rotational inertia
some EMF effects this actually
illustrates the fact that module ik is a
multi domain modeling language as well
you can model electrical systems
mechanical systems thermal systems I
mean the list just goes on and on and on
and so this is an example where it
combines different engineering domains
in a single component so this is an
example of an industrial robot this
model is not a particularly big
model it's a demo model from the Medela
Keo Sarat library but still it has 4000
variables in it that need to be solved
for there's ultimately 3342 parameters
in there those are the resistances of
all the resistors or the gains on the
operational amplifiers and there's a way
of essentially cascading the the design
of the robot down into those components
but all the way there's there's almost
500 components in this model so let's
look at how this actually turns goes
from components into equations right
what you see on the left is a diagram of
a bunch of components this is how a user
might actually build a system dragging
and dropping the components down
connecting them up this is a nice safe
way to build the system they're not
manipulating equations they're not doing
anything that they can they can really
make too many mistakes about except
connecting them in the wrong way and
believe me there are many mistakes to be
made so we're we're avoiding a lot of
problems there but that diagram on the
left is equivalent to the equations I've
shown on the right and I want to just
walk through how that mapping is done so
you'll see those connections that you
see in the diagram over there are
essentially translated into the
equations you see at the top here these
are essentially conservation laws for
the electrical circuit and an
essentially kinematic constraints on the
voltages like exactly kinematic
constraints but algebraic constraints on
the voltages in the in the between the
components and then what you see here
each of these equations are generated
component by component and as as
essentially flattened equations but so
that had they all the variables have
fully-qualified names within the
hierarchy of this particular system so
generates all of these different
equations from the different components
and so this is essentially the
flattening process that goes on in
medela compilers which translates the
components into the equations and now
we're all going to take the red pill and
see how deep this rabbit hole goes
because there's really a lot that goes
on after this this is just the beginning
so I'm gonna take you inside the matrix
and I really mean a matrix that's a that
is a mathematical matrix on the side
there it's a dense matrix and you see
here that if
the equations on the right but if we
treat each of the variables in there as
a column and then each equation we pull
out the coefficients for that variable
as a row then you get the the dense
matrix I've shown you on the left and
there's something really important to
understand about matrices when you're
trying to simulate things and that is
the computational complexity of
inverting them which is a necessary step
in solving them point out over here the
Gauss Jordan elimination is an N cubed
order computational complexity so that's
that's that's high that's three cubed is
pretty bad and in your sort of best case
here you're getting down to n to the two
point three so this isn't scale too well
right there's a problem you remember
that that problem I just showed you
which is a relatively small problem four
thousand variables okay so now we're
taking four thousand to the two point
three seven three in the best-case
scenario now the thing is we can do
something called equation sorting we can
go through and we can look at these
equations and say you know there's
something interesting about these
equations if we look through every if we
look for an equation where the
right-hand side is known we could we see
at the bottom there's an equation where
the right-hand side is known we know the
voltage of ground is zero so that means
we actually know the voltage at the
ground and if we know the voltage at the
ground then it's a known in that
equation on the on the right hand side
and so we know the capacitors negative
voltage and if we know the capacitors
negative voltage then we know this and
so on and so forth so this is actually
what's called equation sorting and the
result is that you know what if I told
you that that wasn't a dense matrix at
all it's actually a lower triangular
matrix if I'm just simply swapping the
columns and the rows and the trick is
knowing which ones to swap of course but
by swapping the rows in the columns we
now have a lower triangular matrix which
is order n to solve so we and and in
fact translates pretty much directly
into a set of assignment statements oh
we can just throw into any imperative
context so we've gone from for like a
simple model 4,000 variables
computational complexity of n to the two
and a half-ish down to just n
for four thousand four N equals four
thousand that's that's huge and we are
just starting I mean this is this is
just the first step in doing all this
processing so as I said you know that
this is this is a deep rabbit hole so
this is really just the tip of that
iceberg here I've shown you the equation
sorting and the BLT form it turns out
that I mentioned before we get these non
linear simultaneous hybrid differential
algebraic equations it turns out
differential algebraic equations in
general are not even solvable with
computers you actually have to do this
process of index reduction in order to
be able to numerically evaluate them so
we need to do that that that is pretty
complicated then you have to do state
selection depends there's a bunch you
have to pick which variables you
actually want to solve for in a sense
and and that makes a big difference in
whether the systems are singular or not
then there's things like tearing which
give you further benefits when you have
to deal with nonlinear systems and
iterating over variables there's we in
mechanical systems the robot is what's
called a tree mechanism you know it just
kind of hangs out in in air but if you
look at other mechanisms that are closed
mechanical loops once they close they
become over constraints you have to know
which equations you can sort of remove
from that system and still get a correct
answer and then finally we haven't even
talked about the discrete aspects of the
language really except for that one win
cause when you talk about synchronous
systems you then have to deal with
clocks and partitioning and solving
simultaneous equations on clocks and so
there's a whole whole other war and to
go through for that part of the rabbit
hole so just trying to get you to
understand that there's there's actually
quite a bit in terms of algorithms that
are required in order to enable this
kind of functionality there are a number
of different tools out there most of
them are commercial but the tools that
support Medel occur most of them are
commercial so I've listed a couple of
them there and several of them were
actually kind enough to give me licenses
to help prepare for this talk so I now
Wolfram is a sponsor at this event you
can see their booth upstairs I also got
licenses from maple and diamond law to
help prepare this material so there are
also some open-source implementations
implementation called opa delica there's
another implementation called Jayma
delica so if you want to explore those
kinds of things so now I had a little
bit of a tangent that was I kind of went
through that stuff a little quickly
because I wanted to hopefully have time
to talk a little bit about the these
next two slides so I had the great
pleasure of being able to spend about
two hours a couple years ago one on one
with red victor talking about this kind
of stuff I he actually has an
engineering background in electrical
engineering I think and I was bowled
over to when I met him to find out that
he actually had heard of Metallica they
know this is something I'd worked on for
a long time but I just you know it's
kind of a niche thing so it was it was
kind of neat that he he knew about it
and I was then bowled over even more
when he when he wrote his essay what
what kind of technologists do about
climate change he actually had he
included a mention of both Medela kay
and one of my books on medela kheh in
that essay and he asked a really
interesting question in that essay which
was what if there were an NPM for
scientific models and I know this is
something that Brett had has been
working on with his I think his
framework was called tangled I think and
for being able to have sort of documents
that had live mathematical behavior in
them and so it turns out that in the
time between when I had spoken with him
and him writing this essay in fact I had
along with a couple of other
collaborators written a package manager
for Metallica which in a sense is meant
to be like an NPM for scientific models
not that package manager is called
impact but I don't actually even want to
talk about that really what I what I but
his his question was sort of especially
in preparation for this talk was kind of
rattling around in my head and I thought
well you know that is an interesting
question what what really prevents us
from using NPM itself as a way of being
able to manage scientific models now I
want to make a distinction here there
are scientific models that are algebraic
you can think of those as like Excel
spreadsheets okay and that's pretty
straightforward but what I want is
something a lot more aggressive
to be able to take the models like I've
shown you here and to be able to use
them from NPM right that means actually
being able perform a simulation being
able to get trajectories time series
data out of them
but I thought about this and so I
thought okay well let's let's see what
we can do so this is what I came up with
so and this is you know just a session
and you can see the the you know how it
sort of plays out at the top I say npm
install this exogenous artillery demo
this is a the model that I showed you
earlier that can calculate our Tillery
trajectories so that gets installed
right that I made this as a private NPM
module for this experiment and then I
run node and then in there I can just
require that module and then once I've
once I've imported that I now have this
ability with that that model to be able
to say okay I want the trajectory you
know the from this simulation and I can
specify things like the azimuth and
elevation angles as inputs I can specify
that I want the Z which is the height of
the thing to be a trajectory that it
returns to me and then I can specify
that I want the final values of x and y
which is ultimately what you care about
with the artillery is where did it
actually land right and so this isn't
this isn't a mock-up this this really
worked and so it's just an interesting
demonstration I sort of in some sense an
answer to to Brett's challenge about why
don't we have NPM for scientific models
I mean we can we can have that and it's
it's it can be remarkably easy to use
right it's just like this session
indicates so this interestingly enough
you know they're given this then this
provides a means for being able to
incorporate these kinds of analyses into
the backend into the front-end via web
pack I mean there's all kinds of
interesting things that this opens the
door for because NPM is so ubiquitous so
anyway I just wanted to try and answer
that sort of challenge from Brett if
you're interested in medela qey you can
go to medela co.org that's the primary
website for metallica if you are curious
there's a tour an interactive web tour
of Medela that i created on my site so
that's a tour exogenous
and you can actually type in Medela
keycode and run simulations and plot
results and things and it walks you
through a series of lessons just from
the beginning and then I as an
interesting sort of a side I had a
project two years ago where I wrote the
first book on my delicate back in 2001
and I wanted to make something that was
more accessible because it was a the
original book was a text book it was
fairly expensive and I wasn't really
happy about that because my goal in
writing the book wasn't really to make
money it was to make that material
accessible to anybody
so I started this effort and I think it
was 2013 maybe to crowdfund
the development of a new textbook and
the ID with the idea that the book
itself would be available at client
electronically for free thus solving my
problem of making the material
accessible and I was fortunate that I I
the Kickstarter campaign was successful
and and I got a bunch of sponsors for it
including I should mention Wolfram since
they're here and I created the this book
as essentially a crowdfunding effort and
so now you know you can go there and the
book features is not only a book that
you can read through but it has it
features also much like that tour
interactive web-based examples of the
models that are in there so instead of a
classic sort of engineering textbook
where you have just plots in the web
version the plots actually have our
applications that you can open up and
specify different values for parameters
and re-simulate them through your web
browser so that was just an interesting
project and finally I'll mention impact
because I mentioned it earlier which is
not quite just I think not as compelling
or interesting for an audience like this
because impact is really about managing
the models themselves as components I
included the NPM example because I think
it has more impact no pun intended
because it allows people to actually run
the simulations it's not about managing
a bunch of sort of abstract component
models it's actually about being able to
take a real system that's been assembled
and bring it to life and so that's the
simulation part so I mean that's why I
thought that was pretty interesting to
include but impact is is out there and
it's used for essentially in the same
that npm is for Maalik for managing all
these different libraries of components
that are out there and with that I just
want to thank everybody for for
attending and you can get an example of
an animated madela go model so I've got
time for questions if anybody has any
yeah well yeah so so one thing to know
about medela is that it can't solve any
problem you give it I mean that you know
obviously things can be singular or so
you're stuck there but there are also
classes of problems where it's just in
the algorithms themselves can't handle
it
but I would say that Hilding own fists
in the and some of the other people like
Martin Otter and there's several other
should name have worked really hard on
the algorithms for those things to make
them apply to the broadest range of
things possible so with respect to
different shot to break equations the
thing is like a a an index sort of
difficulty is classified by indices so
there's index 1 index 2 and X 3 all the
way to index infinity so generally
speaking like 1 &amp;amp; 2 in this index 1 &amp;amp; 2
can be solved some classes of index 3
can be solved and then basically after
that they really can't in you really
can't solve them without doing something
to them without these transformations
those transformations it's interesting I
mentioned that Hilding started this work
in like the 70s it turned out there was
a really sort of stunning breakthrough
in the I think it's in the 80s when a
guy named Penta leaders came up with
something called the Penta leaders
algorithm which does this index
reduction it's it's kind of amazing to
me because it opened the door for so
much stuff to be done I mean it solved
this really tricky problem pretty
cleanly and and it just changed the way
that people view doing this kind of
modeling so it's a pretty important
accomplishment but that opened the door
to more of these things but there are
different techniques that are used panda
latest algorithm is the main
but you know it has limitations but I
you know I mean I can't tell you what
they are right here but but I can tell
you in practice as an engineer or as a
practicing engineer the the only
problems that we that I would say I ever
still have with respect to that
limitation are what are called variable
index problems the typical example of a
variable index problem is like a
trebuchet where you have the ball in the
basket it's part of the mechanism and
then at some point it separates out and
it has more degrees of freedom because
it's not part of the mechanism or
impacts when things hit each other where
the ball is free and then it hits a
table and then it's it's it's not free
and then it bounces and then it's free
again so that variable index stuff is
still a frontier for improving these
algorithms but that's about the only one
I run into in practice yeah
it won't let you violate conservation
energy that's part of the that's part of
the trick here I mean in inside your
component models you can do crazy stuff
like make energy out of nothing you know
I mean that that part is is on you but
once you're outside the component model
that that whole thing I showed with the
Kinect statements their whole purpose is
to apply conservation laws everywhere
and so there are accountants you know
they're making sure everything gets
accounted for outside the component
model so inside the component model it's
your problem but outside it takes care
of all the rest of stuff so you can be
pretty much sure that as long as you're
not breaking it explicitly in the
equations that you add that it's not
gonna break it when it assembles the
whole system yeah well that was one of
the reasons I wrote the book was to give
professors for example a way of being
religious point students said something
um you know I'm honestly not sure how
many different I know lots of professors
in the Medela community I'm not sure how
many of them are teaching it to be
honest I mean I'm not in that community
I'm not in the academic community so I
don't really know what what it is I mean
if you if you ask me there should be but
I mean that not not just I don't mean to
say they should be using my book per se
but I mean they should be teaching this
because as a practicing engineer I found
it very very useful so
yea-ah
that's a good point the thing about
equation sorting is it's only done once
it's not done at every runtime right and
in fact it's not even in fact it's very
clever the way that these algorithms
work because what they'll do is if the
if the coefficients in the very in the
matrix change with time then you have to
do that back substitution that order in
operation every time but the compiler
can actually determine through
dependency analysis whether the
coefficients even depend on time and if
they don't it can actually do all those
calculations at the start of the
simulation so at every time step it
doesn't even have to repeat them so is a
huge I mean the optimizations are
staggering that can be done for these
simulations that's just one example of
how the compiler could be really clever
about saying well I know I don't even
need to do this every time I can see
that this isn't going to change every
time to do it all up front yeah
okay
right so the question is really if you
have two different sort of models how do
you make them interoperate together and
and I want to point out that I never
actually did that and that was very
conscious what what the the best way to
do this is to put all the components
together in Medela kheh want the
compiler chew on that and spit out code
okay not to break it up because you then
forego a lot of optimizations now let's
say there's a problem where you can
decouple the models reasonably the
typical example is when you build
controllers for systems you can decouple
them and then I would say you should
look at so there's something called fmi
which is what I actually used in part
for that NPM stuff which is essentially
a way of being able to the way I
describe is it's like an exe format for
models it's a way of being able to
compile a model down into executable
code that can then be exchanged and so
that's also am a delicate sociation
standard I didn't bring that into the
scope of this but it's it's also a whole
standard for how to do that and how to
allow simulations essentially models to
be simulated as software components
within other systems so I would just
refer you to that there's a website if a
my - standard org that talks about that
standard okay I'll take one more
here you in the back there yeah you know
yes so that was that would be a layer I
would wrap around this whole thing so
you can for sure have all these
parameters in here and there are many
tools like eyesight and heeds and I
forget the names of some of the other
ones but there's a bunch of these kinds
of tools that do that kind of Monte
Carlo analysis for example use
stochastic stuff on top of this it's not
super important to actually have it in
the models because it really is a
layered on top it's like a for loop
wrapped around the outside so yeah I
mean MMI enables that as well because
you can take a model and treat it as a
simulation as a software component and
then you can just stick it in to a for
loop so so that's how most people would
accomplish that so I'll cut it off now
because I'm sure you're all hungry but I
thank you all for your questions and for
attending and I'll be around if you want
to ask me questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>