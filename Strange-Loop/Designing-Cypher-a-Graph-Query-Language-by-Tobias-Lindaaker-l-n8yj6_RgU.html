<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Designing Cypher - a Graph Query Language&quot; by Tobias Lindaaker | Coder Coacher - Coaching Coders</title><meta content="&quot;Designing Cypher - a Graph Query Language&quot; by Tobias Lindaaker - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Designing Cypher - a Graph Query Language&quot; by Tobias Lindaaker</b></h2><h5 class="post__date">2016-09-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/l-n8yj6_RgU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome I'm to be a sleen dokie I work
as a developer at neo technology we
build this graph database system called
neo4j I've been working there since 2007
now pretty much since since we started
the company as a company the product was
an in-house product in another company
before that but I joined when we started
the company I want to share a story with
you today I don't want to talk too much
about Nia Jay the product that we sell
although it is intricately linked to to
the query language cipher that we built
so it'll be mentioned a few times this
is a story that has some history to it
so I'll go through a bit of history and
then share some lessons we learned and
some some future opportunities that we
were seeing and a few interesting
tidbits to to think about so once upon a
time a long long time ago in a galaxy
far far away in the kingdom is Sweden
it's that's where never j all started it
is actually legally a kingdom even
though the King has no power yep that's
Kenny king we there was a this this
database I had a few interesting things
going for it it was pretty fast it was a
navigational database it was an embedded
database and it will had a data model
that was different from what what was
dominating at the time and I noticed
you're taking pictures and I want to say
that I'm fine with that I should have
said up ahead that if anyone want to
take a picture while I'm on stage go
ahead so that is interesting data model
that model data as a graph
where where pieces of data are nodes or
vertices in this graph and they're all
interconnected using registered ships or
edges so it was interesting but what
wait wait a minute navigational that's
that's been done before that one's done
in the 60s and it failed completely when
when boys introduced sequel and and the
relational database is completely crush
all other data models right so how come
this this thing could be navigational in
the in the 2000s and be successful
that's crazy talk well I'd like to think
that the world has evolved a bit since
since those early days in particular
what I thought at the time was was the
interesting differentiator was how we
write programs the object-oriented
programming paradigm in particular meant
that we could provide abstractions over
the data in a way that we couldn't do
before so we could have an obvious
oriented API a sort of domain-specific
language and the key word here is
language is embedded it's an internal
dsl in an object-oriented programming
language for dealing with a graph
dealing with graph data I think this
having this language was a pretty key
key step for for navy j being more
interesting in its day then what nakoda
soul systems were in their day or in the
day of sequel and but others have done
this before as well so i say that
object-oriented programming was
interesting but the there was in fact in
the 80s and 90s a movement to try to
create object oriented databases why why
aren't those if if I'm here saying that
it all bi Toria the programming was
really good for navigational databases
why aren't these object oriented the
picture is not really showing that but
why aren't these obvious oriented
databases completely ruling the world
case they're also navigational well I
have a theory or hypothesis for for--why
where this is well and I think that in a
in an obvious oriented database what
ends up happening is that you couple
your application domain to your data
domain so your your application logic
and your data representation is very
tightly coupled and what you do in a
graph databases do you have a clean a
clean separate layer for your data
domain that's diff there's a different
layer than your application plane and
this decoupling allows you to evolve the
two independently and it gives you an
easier way to deal with your application
there's a third reason why I think that
that things happen when they did and
that is that our needs for data have
changed data in the early 2000s in the
or starting in the 90s even and today
it's even more true is more connected
than ever before so having a database we
can deal with with the connections of
the data is rather than just doing
aggregations over uniform data is is
more important than it was before data
is also less uniform we deal with lots
of lots and lots of data because volume
Oh volume is bigger as well we have more
data than we do and date and week and
with having more data about more
information about things we have more
diverse data so data is less uniform
which means that we have a have to have
a different way of carrying them and a
different way of storing them so the the
tabular tabular way of storing data that
sequel database it traditionally do and
which are awesome at
lend some stuff really well to two very
uniform data where everything fits in
the same square table but if data is not
so uniform the relational database is
not necessarily as good fit I think
those are a few reasons why why a new
database could when new databases could
arise in the early 2000s where during
the up until that time pretty much no
other data model was then relational was
even you couldn't even talk about having
a database that was non-relational
because he lectures that was crazy talk
up until early two thousands but then
whole of new snow sequel happened and
around that time we thought yeah this
this database that we built that that
was that was not relational and that
we've kept over under wraps because it
was crazy talk to talk about databases
not being relational we could probably
go Polly with that there was another
weird thing with this database called me
for Jay that had some interesting things
going for it I mentioned it was embedded
so what does that mean it means that
it's it's it runs in the same process as
your application does this is really
awesome for the fact that there's no no
latency between your your application
and your data this is all in the same
process is all in the same memory space
you got direct access to your data and
no network hop no nothing but for the
same reason that you that you wanted to
decouple your or similar reasons at
least that you want to decouple your
data domain from your application domain
you kind of wanted a couple your
application service from your data
service as well so this we found out as
we started this company as we started
selling this database management system
to people and to our company's customers
that this was a big
big big thing that they didn't really
like just didn't sit well with how they
were thinking about deploying their
systems they wanted a traditional model
and for good reasons where are you we
have a database server you've got a few
application servers to talk to that
database server and you can update them
both independently you don't have to
have downtime when your database servers
up great they are placated to redeploy
application servers so while being
embedded had some performance benefits
it had some some really serious
disadvantages as well and this is where
our story about the query language
begins because in order to the this nice
object-oriented API that we had didn't
really it was really good in an embedded
setting but once you once you go into
into a client-server model it doesn't
quite work at all so we tried a few
different approaches this is one of the
first ones I'll have years here in the
bottom that you haven't seen I'm not
gonna mention them but they're for
reference if you want to look at them
one of the first things that we tried
because this was this was the thing that
everyone was doing at the time was
restful web services so we try this can
we take pretty much our API that we have
that we love and embed because that's
what we knew we knew our API we liked it
and we were good at writing these
embedded applications with our database
so we thought can we take this API and
create a restful api for it or an HTTP
API i'm i'm a bit ashamed of calling
this rest these days because there are a
few things that aren't quite restful but
then again people use rest about pretty
much everything that's an HP apio htp so
who cares so we had this pretty simple
naive API where you'd this is a request
for the relationships of a single node
it happens to have an ID called
367 it could have been anything and then
this gives us a list of documents that
are representations of all those
relationships and that representation is
pretty much links for getting
information about that so it was very
much hyperlink oriented as a restful
services apparently should be this was
not very efficient this was in fact
pretty horrible in terms of efficiency
it was really good for exploring data so
if you were human interacting with with
system interactively and looking at I
found this no now I want to go explore
really good for that in a web UI but not
so good for for for for actual live
queries from an application because it
was just too much back and forth over
the network all right back to the
drawing board we tried the next thing
with ride was to have the user submit
JavaScript code to the server that used
are embedded API still so send code to
the server uses our server side API for
getting data admitting that Twitter soul
stream like it's written back better
pretty verbose things that you send over
the wire same things get sent to the
server again and again and again so we
didn't end up with with this in the
product what we ended up with instead
was you pretty much took that code and
deployed it with the server and they
sent parameters it gave it a URI and
send parameters do that still in our
products today still widely used
something people run into problems with
whenever we want to change
but they worked so this was around 2011
a few years before that we had another
idea on how we could query graphs
because one thing we noticed was that
most of the queries that we typically
ran over the graph was about doing tree
projections so taking the graph and
viewing it a part of it as a tree and
typically what we would do is find a
starting point one or a set of nodes
based on some search criteria and then
from that node find a tree projection of
interesting things and then return the
leaves of that tree so we thought what
we can express that using something that
can be a pretty simple straightforward
you or I and just do a regulation if he
gets on on something that looks like a
UI ish and get that projection back what
looks like your eyes and is good for
three projections well like spat expect
ice exactly that so we toyed with the
idea of having some sort of query
language based on expat this was some I
don't have the actual notes from the
time so but I'm remember that was
something like this that we wanted to do
what we did with this idea was that we
said okay there's only six of us let's
see if we have some community partner
that can that can take this ID and and
work with it and build something
interesting and build this query system
for us so we won our co-founders Peter
noi Bauer had a friend we was working
with who we got to know through a
company that was an early customer of
ours his name was marco rodriguez and he
took this idea and created a
query language called gremlin it was
originally originally based on xpath it
looked slightly different because
slightly different from the idea that we
have had originally because Marco looked
at our ideas and said that's not going
to be able to do all types of queries
that you're going to want to do this is
limited to just treat predictions so he
created a different system where you'd
instead of what we had in an hour idea
where where you what you do is
essentially stepping over each these
slashes you step over a step over a
relationship to and you know it so
you're always positioned at nodes in
gremlin you alternate between stepping
from a node on to a relationship and
then on to a node on to a relationship
then allowed to alternate between a set
of relationships and I said and a set of
nodes ended up with this syntax of
outgoing edges incoming firdous and
that's where I got lost because what's
the incoming virtus of an outgoing edge
it didn't really make sense to me still
pretty a pretty good system still around
today have evolved quite a bit since
then the first evolution was that Marco
real realized that having this in XPath
it's just unnecessary overhead so we
made it an internal dsl in groovy i
think started out with where you pretty
much do filtering so here you would
filter all get all the nodes from the
graph filter I actually have a pointer
here filter based on they should have
this label which I have this name then
take the outgoing edges of those nodes
filter there's on type filter on a
property etc etc
so it's based on this filtering and
progression type of turbulent then it
has more interesting features in that
and what's even more interesting about
gremlin is the recent development that's
happened that we're where the were
Aurelius or actually now data stacks
believe that's named him just clone
Aurelius group that did that did this or
they think of rock group which is the
open source part of it the gremlin that
they've evolved to and that is to use to
have a intermediate representation
program line I think that is something
they called gremlin bytecode I think
that is something is really useful just
then you can put something some other
language in front of it that is easier
to read because I don't like reading
these and that brings us to why we why
we decided at least at the time to
create our own creole language had
gremlin been where it is now maybe we
wouldn't I still think that this that
gremlin is hard to read and too dense I
still think that lets cipher is a better
language requiring graphs but at the
time it was definitely true I'll
actually stop there and look at another
weird thing that near for Jay did at the
time and that's the notion so I said
that when when we searched for things
the queries that we did where first you
find a starting point and then you do a
tree projection for that those were the
most common queries how do you find that
starting points the original neeraj a
didn't have a concept of indexes the
idea that the founders had instead was
the graph is in natural index an index
is just a tree we can do trees in the
rough because there is a subtype of
props so what you
do in in this graph world that we that
is holy to us is you should encode your
index as a graph and then you start from
a single well-known root node in the
graph and then find the appropriate
index index route from there and then
search through that industry to find
your actual starting point this worked
works perfectly fine but having all
applications to placate implement their
own logic for managing industry's
horrible bad idea so we provided the
first step though is that we provided
libraries for for applications to to
manage these search structures within
the graph and then we looked at those
abstractions that we created and realize
that this is actually just a service
that gives you it takes some parameters
input a key and a value typically gives
you a note back your set of notes could
be not implement that more efficiently
using a system that is tailored for for
being able to do such search so we
implemented the same search structure
service thing using the scene and which
had some interesting implications to it
with a system actually managing two
databases but in a single database but
that's beside the point the interesting
thing was that search structures in here
for Jay was something that from the
beginning was something that the user
managed the user had to explicitly
update this search structure because it
was a separate structure it was not an
index over the data it was a search
structure this will be important later
on when we talk about
cypher our query language so we created
this prayer language this is circa 2011
that we started working on on building
this query language it actually was
interestingly because since 2007 when i
joined being a compiler guy originally
myself i was saying shouldn't we build a
language kind of fun and the founder
said no don't waste your time on City
languages we are building a database and
then we hired this guy Colin dress and
he said I don't care what you say I'm
gonna build this anyhow my yellow
suicide it's awesome that he did and I
want you to do it he looked at these
what we did at the time was that we
spent the fair amount of time actually
writing queries sometimes for testing
interesting scenarios and sometimes
actually for for customers who had or
community members the King to us asking
for a house the best way of doing this
if it was interesting enough and novel
enough we were we would take some time
actually look at it and analyze it
properly the use case that they had and
we come up with well this is how you'd
structure a curry after that and we
managed to get a process for how we how
we implemented queries using our Java
API and the process was roughly like
this we started with a drawing on the
whiteboard of the part of their data
domain that they wanted or the part of
the data domain that you wanted to query
and drawing that out which are the nodes
that we we have what are the
relationships between here where do we
start so here we may be started the
query what we end up want to end up with
is getting the code for it so we created
drawing on the whiteboard and then what
we actually did for documenting this
beyond the whiteboard
we drew translated this into ascii art
in code comments all right now this
starts to look like something you could
actually what if you could actually take
this representation and create a crib
aced on that immediately rather than
have an engineer sit and write Java code
from it so that's what undress did it
took this like big and translated it to
a more linear form so you wouldn't have
to think about where are these arrows
matchup because that's tricky to parse
translate into a linear form I was still
the same kind of ascii art kind of thing
and that's the basic basics for the for
the query in cipher so you match these
you match the pattern you filter it and
then you return project your result in
return that this is actually what it
looks like today at the time remember
those separate search structures was I
was still what we were using is you had
to explicitly say i want to start here
using this particular search structure
so here i'd say i want to start at john
which i find through the search
destruction person where I using the key
name and the value John looks up this
these nodes and then i can continue
matching and match all the friends of
friends of John where John doesn't
already know those friends friends of
friends and then I return the friends
and Friends so this is a simple
recommendation logarithm this was the
first version of cipher looked pretty
much like this I'm I wouldn't don't
don't dare me to put this through a
parser because potentially it could have
there might be some newer things that I
put in some parts of it
okay could do reads only second version
we started doing updates of data so here
we were this is a silly example but in
the vein of carrying on from from
previously from the previous example I'm
doing not only do I my turn the
recommendation but I also write in the
database that a your some recommendation
here so we still start from a from a
from the search structure and then we
match and then we then we could create
or return but the search structures
couldn't be updated so if I if I'd
created more nodes here that I wanted to
put in a search shorter than late later
on wanted to be able to the query on say
that I created in just a new persons I
had to separately using a separate API
update the search structure so a bit
tedious so we sucked down in a room in
Malmo Sweden and thought about how can
we change Nia Jay having changed the
graph model that we expose in a way that
cipher can do everything no need for
these separate api's everything should
go through cipher interestingly how it
gone in roughly two years from don't
waste your time on these silly language
things to how can this language do
anything so we came up with what we
called near for j2o where we introduced
mainly one new concept to to our graph
model which was the label as we allow
you to put a label on node and we use
that from a modeling perspective it's
like saying well this is part of a
collection or this has a certain type
you use it for a few things that up to
your shooting from an implementation
point of view it's key for letting us
binding and index to that note or
putting that note into an index as we
allowed use it to declare
that I want this combination of label
and property key to be indexed so that
you can do lookups on those
automatically without having to
explicitly say I want to use this search
structure so here we do away with the
start claws so we just say I want to
match existences of this pattern and
then it the query planner figures out
automatically like the engineer would do
when I drew this on where like I would
do I figure out what where the start
point is based on the information that I
have granting does it automatically for
me awesome I have information here
saying that the name should be John of
this person node so find you I find that
hey I have an index for that awesome I
can use that for finding or all the John
notes in the database and then again
find the friends of friends where
they're not direct friends already and
another new thing merged I
recommendation Malaysian which is a
crate or a match or create class that'll
create it if it doesn't exist alright so
now it's a good time to look through
this language that we created in this
sort of basic level what are the things
and capabilities that we have so the
main thing is this pattern matching part
where you describe a pattern that the
database should match and the database
will find occurrences of that pattern in
your in your data graph these patterns
can be additionally augmented with
credits that filter the filter of the
matches so I think of these two this
pair of match and whereas the match is
expanding
the world that you're viewing by because
if I only have a single node it's in the
pattern it's just all of the nodes that
match that pattern if I have a
relationship it's like the Cartesian
product of all nodes with with
relationships between them so it's so a
bigger pattern means typically a bigger
set of results whereas the more things
that put in the work loss the fewer
results I get because it's a filtering
thing so those are the basic those so
this is the main basic thing and then of
course you have to be able to project
the results return something from the
query to the user so we have a return
clause which can do the things you can
do in sequel as well ordering limiting
skipping those kind of things and fine
and of course we also in the second from
the second version of cipher we have the
ability to create new data to update
existing data setting properties
removing properties and adding and
removing labels and also the ability to
delete data because data changes over
time you can delete nodes you can also
delete relationships of course one thing
that we noticed around here is that
something you typically end up doing is
huge when writing a psychic where is
this you sent a courier to the server
you get the result back and then what
you want to do with that is based on
that data you get back you want to query
for more so we thought can we do some
some sort of simple sub query type thing
where you can where you can take the
results from a previous query and do
another query based on that immediately
without having to do a round trip to the
to the client side so we came up with
this width statement it turned out to be
really
are useful is a very simple type of sub
prairie where you got a first query and
then a second query and the results
carry on through there and it has the
same semantics as return it's just that
the query carries on with the things in
scope and then we have optional match
which is just like match except if
there's there are no matches it gives
you no less back for the new with newly
introduced bindings so it's matter null
and then merge is like a hybrid between
a home patch and create where instead of
if there are no matches it gives you
know if there are no matches it creates
the data for you yeah another
interesting idea that we had on this
topic of of interesting ideas that we
actually implemented was what if we
actually took require that you put the
version of cipher in your query the N we
supported multiple versions of cipher in
this in the database server then we can
make changes to cipher in future
versions that would be incompatible with
previous versions without breaking your
queries so we did that it turned out to
work pretty well left this room for
change and but not as much as as we as
language designers would have liked I
would like to be able to change things
pretty pretty substantially from time to
time but it turns out that users don't
really want to once they've learned a
way even if it wasn't the best way and
we've done user studies in this this is
awesome to be able to do that we've
actually this has allowed us to actually
get feedback from our user and then
improve the language but even if we do
have the ability to do that users don't
have to relearn so we haven't been able
to do get quite as much back on this
investment us as we would have hoped but
still it was a useful thing other things
that we've done of course is we do up to
my stations on queries
and some of those organizations take a
bit of time to compute but the
realization that will you submit the
same query multiple times this is the
same thing that pretty much all
databases do we use a cache of crazy so
we compile the query once and then we
use parameters you can still have
parameters and to to parameterize that
query and it will be the same compiler
query but we amortize the cost of
compiling it over multiple you using
that query for fractional querying
things multiple times i think i'm gonna
skip this and this and go well into this
so there are interesting things about
language design and in that you realize
all the mistakes you made and those are
interesting to talk about so there are a
few warts in cipher that we are some of
them we're working on fixing and some of
them we we haven't really figured out of
fixed yet this is one of those things
that we have no is is problematic but we
don't or two of those things but we
haven't really figured out how to solve
it yet the first two queries look
extremely similar yet they return very
different results the first one returns
as many rows as there are measurement
notes in the database and it returns the
absolute value of each of the value
properties for that for that particular
note the second one while looking
extremely similar does something
extremely different it actually does
aggregation and returns only one row
containing the average of all the values
so we got two things that look very
similar doing very different things I'd
like to fix that but I haven't
get out how yet the second one which one
is this oh yeah let's get that one yeah
this one is interesting but this one is
even more interesting can someone guess
what the difference between these two
queries is in terms of actual textual
representation the only difference is
that here I've broken up the pattern
into to match classes it's the same
pattern broken up into my losses vs. in
only one nope it's actually a difference
in semantics yes that is the difference
so the first one in a database with this
data would return no rows in the second
one we would return a bound to X be
bound to y and c bound to x as well it
is not actually the node bindings that
that are allowed to be different it's
the relationship so what we don't allow
is within a single pattern for two
relationships to bind to the same
relationship in the database this is a
mouthful to explain and has bitten
people countless times but also quite
useful being able to have them to make
that difference is useful it's just
tricky to to find a good way of
expressing it another thing that's
tricky to balance is how much syntax in
plastic sugar you put in language and
this is true for any language versus
having just one canonical way of
expressing things so here the first case
would be the canonical way of expressing
match all the nodes where
a where the food property as the value
bar and we've allowed a shorthand syntax
for that where we where we use adjacent
like notation for for the property
values of that node there are other
graph berry languages one interesting
one called PG ql from from oracle that's
being developed at the moment i don't
think they have it in product yet but
they have some interesting reaches
prototypes honest has the ability to
express even more complex predicates
within the scope of of a single node
this is not something we allow in cipher
because we sort of drew the line there
it's saying that the first form is
useful because it it actually makes
things shorter but the second form is
when you start allowing putting that
many things inside of the brackets when
you have a bigger pattern it ends up
obscuring what the actual pattern is is
our reasoning for for why we decided to
allow do not allow the second one but
it's still it's a tricky balance of
where do you where do you actually draw
the line and there are cases where where
it actually would be useful to be able
to express things within the brackets
yeah other useful things we learned rely
heavily on parameters so that people
don't compose strings to for queries
because that has cost tons of problems
in the sequel and the last thing I want
to talk about is what we are now working
on which is to open up cipher where
you've invited vendors other vendors of
databases and other types of tools that
do graph quarry and we're creating what
we called open cipher where we are
working towards sort of standardizing
cipher we're relinquish in some of the
control we want to have an open platform
where people
and collaborate on on improving cipher
and creating the next version yeah so
this was the story that I wanted to
share with you unfortunately I only had
40 minutes to do it there's only that
deep you can do it go within 40 minutes
but the beauty of the tradition of
storytelling is that the more times you
tell a story it changes as I'd love to
talk about this story with each and
every one of you in the hallway
afterwards where you can ask me any
question that you like thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>