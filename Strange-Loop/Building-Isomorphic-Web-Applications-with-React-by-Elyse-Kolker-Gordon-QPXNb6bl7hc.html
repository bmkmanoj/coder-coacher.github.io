<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Building Isomorphic Web Applications with React&quot; by Elyse Kolker Gordon | Coder Coacher - Coaching Coders</title><meta content="&quot;Building Isomorphic Web Applications with React&quot; by Elyse Kolker Gordon - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Building Isomorphic Web Applications with React&quot; by Elyse Kolker Gordon</b></h2><h5 class="post__date">2015-09-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QPXNb6bl7hc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah so today we're going to talk about
building isomorphic web apps with react
I have an example uh up on my github so
you can check that out a lot of the code
samples come from it or are loosely
inspired by it yeah so my name is Elise
Coker Gordon I work at vivo vivo is a
company that makes it so you can watch
music videos online maybe you've seen us
on YouTube but we have a product
platform too and I'm a full sack web
engineer and also the web team lead at
vivo so yeah we've been running a
isomorphic react app in production for
eight months and working on it for
probably close to a year now so let's
get started so a loose definition of
isomorphic more mathematical general
term it just means two things that are
of equal form so what does that mean in
the JavaScript world it means practical
isomorphic is what I've been calling it
I've also seen people called lazy
morphic and some other things what it
means is that because of the way that
JavaScript environments are in today's
browser node world you can't get to a
true isomorphic state where all your
code runs everywhere because of various
environment differences but we can get
close and that's what we'll talk about
today so why would you want to build an
app like this the reason that we decided
to do it and I think one of the really
strong reasons is for SEO so if you've
built a single page application you on
the web you may or may not know that
your doesn't get crawled very well by
crawlers so this was a big problem for
us we are an app that's out there in the
world we want to be have good rankings
we're not behind a log
wall so we used to use a service called
rambone which snapshot Adal our pages
like hundreds of thousands of pages put
them on s3 buckets and then served them
debt to the SEO crawlers this was a very
brittle system so that drove us to think
about other ways so one react I came out
we started thinking about moving towards
it and that's still in my mind like a
big driver why you would want to build
an isomorphic web app so there's also
performance benefits when you serve it
off the server initially you can serve a
pretty fast at render all the HTML is
built on the server all you have to do
is have the browser do a paint it's
pretty fast I like to call this
perceived performance though because you
still have to have your application
bootstrap in order for your user to
actually be able to use it and if you
want to get really nerdy with it you can
actually run the application without
JavaScript technically you probably have
no reason to actually do that anymore
hopefully but you could there's also dev
benefits you get a lot more code reuse
being able to run stuff on the server
and the browser you can take advantage
of the full stack engineer right
somebody who can write server and
browser code and move between the
systems and in some ways it does reduce
complexity so this is just what we're
going to talk about next slide will be a
little syntax and I'll take a poll of
how many JavaScript people we have here
versus an on JavaScript then we'll go
through how we're actually build an app
this way how we'd build it for the
browser the server and how we bridge
that gap and then we'll come back to
this would we really want to build
isomorphic web app um so how many people
are familiar with JavaScript oh good
that will make this easier how many
people have done react
okay so less so I'm not going to super
deep dive into react concepts but I'll
try to give you a high-level overview as
we go I the examples are all written
with es6 so hopefully no bar statements
lettin const like this this bottom part
is all jsx when i first started riding
react jsx was really weird to me I was
like why would you want to write like
this but it turns out that it's a really
good templating language and even though
you can't do a lot of logic in line in
jsx like you can with a lot of the other
web temple in languages there's good
patterns for how to do loops and logic
statements and it's actually very nice
to be able to write your HTML in line
with your JavaScript so this part right
here you can put whatever javascript
code and you want it evaluates to
function and runs later you can define
your own HTML tags which are really
reacting opponents so we'll see a lot of
that later or some of it okay so um also
who's doing this right now these are
just some companies I know they were
doing it so obviously I already told you
about VEVO we're running the majority of
our production website with with these
concepts Instagram and Facebook are
doing things with isomorphic react
varying different levels depending on
what app they're running and then Airbnb
was actually one of the first guys to
really adopt this concept with react and
they have a really good blog post about
it which is on my read me for the gay
repo if you want to check it out there's
also some other people who have been
doing isomorphic concepts in JavaScript
land for a while meteor was one of the
first early people to get
on it it's actually the first thing I
ever used that used these concepts so
when I got to react I was like oh this
makes sense this feels like meteor derby
is an MVC framework you can check out
that does similar kinds of things if you
want to broaden your horizons with it
and asana actually apparently built like
their whole own way of doing this all
the way from the server to the browser I
don't think any of it is open source but
they decided to solve it a different way
so there's also a lot of frameworks out
there a few that do isomorphic
specifically at vivo we open source
something we call pellet which is a
framework that does basically everything
uh but also handles this isomorphic
stuff there's also a guy who made this
library called react Nexus that does
things that are very similar to what's
going on in the example for this talk
and then relay just came out last week
if it had come out a little sooner
probably would have demoed with relay
but it didn't so I it is isomorphic as
well you should probably check it out
okay so why are we using react to build
isomorphic web apps well the main thing
is the virtual Dom the way we react
works is it builds you a dom behind the
scenes first using its virtual Dom then
it compares it to the actual Dom and
smart updates only what's changed this
is very powerful for performance but it
also means that we can have a Dom on
node without having any of our normal
browser document support the second
reason it works really well is because
it's this concept of having a view
that's functional ie you put some inputs
in you get out a reliable predictable
view this is the props idea in react
react also has state but I
they encourage you to limit state to
things that are really stateful like
user interactions and try not to use it
otherwise and then react actually comes
with built-in support to build your Dom
on node which is cool so rendered a
string build you a dom that matches what
it will look like in the browser there's
also rendered a static markup which will
just build you a dom which you can't
really use for isomorphic purposes but
if you just wanted to serve a crawler
that would work really well and it's
faster okay so first let's talk about
the single page application experience
so i am using react react router which
recently got a major overhaul and
networks really well isomorphic as well
and then I needed a static assets server
so I started playing with browser sink
i'm using like maybe ten percent of its
capabilities but it's going to serve us
our browser j/s so I like board games so
I made a little example with board games
I parsed a board game geeks XML into
some JSON so uh pretty basic not a lot
going on here but we're going to build
it isomorphic so the folder structure
here matters because of the two
environment thing there's a lot of ways
you could handle this but the way I
chose to handle it is by just having
separate entry points to make it really
clear server only codes got to enter
through our appt j/s I client only code
has to enter through our main j/s in the
client folder almost everything else is
shared to use react router isomorphic we
have fairly different entry points so I
went ahead and made separate routes
files for that too just to make it
really clear there are other ways you
could handle this with abstraction which
is more like what we do in pellet but I
think this is simpler and shows the
concepts well in our shared shared
folder we have components which run
everywhere
it so that's the key part of this so our
build tools are actually pretty
important to get this done so we spend a
minute here we have webpack that's the
most important part what pack is going
to let us do the separate builds really
easily we can have separate entry points
for the server and the browser and we
can do some other fancier things to help
with some of the like abstraction for
the different environments if we want
i'm using gulp and browser sink like I
said just to run the static asset server
so webpack like I said makes a build for
each environment right we're going to
have a server build for node and a
browser build for the browser they're
going to look pretty different the
server build for node is not going to
build up any of the node modules into it
because that already works out of the
box with node the build for the browser
is going to build all your node
dependencies into it because the browser
doesn't know how to deal with those so
web pack has its own include system that
manages that for you require system so
the key thing here is you still need to
make sure your node modules are
isomorphic if they're not even though
web pack will let you build it it'll
probably blow up on you so most packages
today are really good about telling you
whether or not they're isomorphic so
it's not hard to figure out web pack
lets us do some other stuff that's just
nice benefits of web pack we can like
feature flag by setting environment
flags really easily and if you want to
get really fancy with it you can chunk
code into various smaller downloadable
files separate out different parts of
your website so you don't have to
download unnecessary stuff it that's
pretty powerful but not a requirement
okay so this is what the config looks
like so you have your entry point pretty
straightforward somewhere you're going
to put it
and then you also have things like
loaders which this is how we're
processing our trans piling our es6 it's
also how we transpiler jsx because jsx
needs to get converted into a bunch of
function calls so it'll actually work so
one thing you can do is a kind of
require jss you can alias packages this
is one way you can deal with differences
between server and browser dependencies
if you make an alias for it then webpack
can just pack the correct dependency for
you as long as they have the same
interface you'll be good this is why I
was talking about it's really easy to
define your own plugins with web pack
you know you can have deaf or prod
feature flags anything you need to do
around that and this is browser sink oh
so the reason I'm doing this is because
if you want to serve static assets with
a web pack bundled node server you have
to pack the assets into the bundle or
load it through like webpack dev server
I was having a lot of issues with
webpack dev server it wasn't being very
nice so I decided to look for an
alternative that ran more smoothly so
browser sync seems to do that it's very
easy to set up a static assets server if
you want to explore loading your assets
into your node bundle you can but you
know so okay so let's talk about
actually building the client code so
react router is very straightforward it
works like jsx it's basically a bunch of
components that are going to wrap your
react components we define a top-level
path that's where our shared few
elements can go like our header and
footer
I also there's two paths here home and
detail so our home page has all the
cards i already showed you on it our
detail page is very similar for purposes
of this example uh so this was is what
it would look like if you just had the
app the app route with nothing in it
right so uh we also on the client need
to somehow get our data before we render
the view which we're going to do on our
server in a minute but we also have to
do it here so react router has this nice
hook into its life cycle called create
element and AH you can do stuff and
create element before you render this is
also how we get our shared routes in so
that we don't have to have a bunch of
code duplication and we also do use that
history alias to stick the right history
in here so our server router looks kind
of different it's more node request
friendly this match function is part of
react router it returns you a guaranteed
set of params that you can then return
the correct server response based on so
on the Dom we can use reacts out of the
box render we take the routes we stick
them somewhere on the Dom it's pretty
pretty straightforward on the on the
browser and then this is what our actual
like view is going to look like we have
some jsx this stop props that children
is what react router uses to pass in the
child components for the route to the
top level app component which is going
to be your root component you could pass
additional things down here or put you
know additional elements in here that
you want to persist across roads
so yeah so let's talk about how we
actually build the cards like one of
those so the child view this is how I we
tend to deal with looping uh you know we
just abstract your cards into another
function so just our undercards becomes
a really simple loop build an array with
your cards we can easily spread props
into child components here so this is a
really beneficial property to use with
react and then we have a detailed page
just so we have some more interesting
reading going on same general principles
and we rendered the cards again so okay
so declaring our data needs is probably
one of the most important parts lots of
different places do it differently but
it all boils down to having some way on
each component to declare what data you
would like to get and then using that to
go make rest calls or relay does graph q
alcohols so this is just the syntax I
defined for this example so we're going
to define an array of requests that this
view needs you have to go get the data
before you build the view so on the
browser we're going to do that by making
a higher-order component called data
wrapper which is just going to take our
view component wrap it do some state
stuff and then pass it into props to our
view so that our view maintains just a
props clean functional state no state so
pass in our component
this is what the higher-order component
returns right so it's like that
component and some props and some data
that it goes and gets for us so okay
that's the core of the view layer so on
the server how do we do this like I said
previously the server render is for
thoughts and crawlers so share bots
Facebook Google+ come back and crawl
your page Open Graph tags crawlers
Googlebot any other share at any other
colors you might care about so so that
we have some control over what index we
serve or what HTML page we serve we need
to use some kind of node render engine
here so i chose ejs we're going to
render render to string and then stick
it in here so react Dom also supports
this rendered string on node and routing
context is just the way we wrap react
router on the server and then we pass in
our props down yeah in the response we
just pass in our ejs parameters so how
do we get the data on the server
basically same idea as a higher-order
component it's just that in our request
middle where we're going to go make all
these data calls wait for all the
responses to come back and then pass it
into and then render the page okay so
the key part here that we haven't talked
about yet is how do we get that server
render to hand off to the user
experience in the browser this is
probably the only actual hard part of
isomorphic apps so you know the user
comes in to your site initial load goes
to the server request the page
enters the router get some data like we
saw then we use a virtual Dom rendered a
string to render the markup and return
it to the browser okay so now what does
the browser have to do well the browser
has to do then bootstrap react we can
see the page right now but if you're
fast enough you can't actually do
anything with it because no javascript
is loaded yet so we have to somehow a
bootstrap react we have to make sure all
the same data is there or else you're
going to have weird view rendering and
so that when you're one react rebuilds
the Dom you have no diff and then
therefore no repaint and then after that
you can happily exist in your single
page application experience where react
is updating itself based on whatever
flow you define which formerly most
people use some kind of flux like
structure now probably moving towards
relay so to get that data to the client
we have to pass it down to the page we
have to see realize the data in the
template or else will when we get to the
page if we have to make xhr requests
it'll try to render before we have data
and then you basically end up with an
empty view so so when it gets to the
browser we need to somehow do something
with this data so our requests know that
we have it so there's basically two
approaches to rehydrating the Dom you
can hold on to this data and then figure
out how to just stick it back in as
props at the right moment or you can
rehydrate your cash and let all your API
calls run again but check the cash first
so that they return synchronously both
strategies are valid in this case I am
returning them synchronous synchronously
from the cash okay so I want to pause
for a minute now and talk for about node
versus the browser so they're both good
guys but sometimes the fight uh
so the problem here well there's lots of
problems here the high-level problems
here is on browser you have window in
node you have global on the browser you
have window dot location and no do you
have your requests so there's some other
problems if you get on a larger
application you might run into memory
issues or other differences between the
way the environments run so if you're
going to go about building isomorphic
application this is a place to pause and
really think about how you're going to
do this because you know do you want to
make the choice where you force all of
your request data down onto the browser
and use that as your source of truth do
you not care do you use whatever
environment you're in maybe it doesn't
matter for your application we've found
that it does matter you need a single
source of truth as much as possible as
much as you're caching will allow all
that good stuff so yet that my example
doesn't really have this implemented in
it but I encourage you to think about it
if you're going to build an application
like this and use it in the real world
for personal projects you probably won't
run into issues with it but in
production we've definitely had to think
about these problems okay so back to the
pros we talked about this already but as
you can see now we can go to the server
rendered a string get a nice page for
BOTS and crawlers we can get good
initial load times maybe I'll come back
to that in a second and we can get code
reuse between the server and client all
those other nice deb benefits so server
render performance unfortunately
rendered a string with big complex views
it actually doesn't perform very well on
the node it's not optimized at the
moment Facebook hasn't made a big effort
to put time into this
so if you're going to do this in
production you need a good caching
strategy it's super important
unfortunately we got bit by this and
kind of had to spend a bunch of time
backtracking and figuring this out when
we launched our first first page with
react so that can that can definitely be
something you should think about in
advance and something you should really
way if it really worth it because this
can complicate things especially if
you're supporting multiple multiple
devices browsers things so also as we've
seen with the multiple environments even
though the core is simple right like I
can render review I just take my react
code and render it bootstrapping each
environment is really different and like
I said in the beginning you can't
abstract that if you want but somehow
you have to handle it and that's a big
cost so if your whole app is behind a
log in wall I would really think if your
performance needs are strong enough to
justify this right because you're going
to add a lot of complexity in thinking
about these things to get some
performance benefits that you might be
able to get some other way or just using
react in the browser because react
performs pretty well in the browser
anyway you might still want to do it but
if you don't have the strong SEO need I
think there's less of a cell to build it
this way I love react I definitely would
recommend using react but the isomorphic
part does come with a cost it also comes
with a cost to developer understanding
every time a developer sits down to
write code for the view they also have
to remember to think about how it's
going to run on the server and this for
our team has taken some retraining of
thought because it's not where you'd
normally used to at least for the last
four or five years right so so what's
the future here I think that I am
personally going to check out relay in
the coming weeks and see what the
options are there in terms of isomorphic
I really liked using react router for
this project and relay on react router
and now designed to work together so
that gives me hope for this but there's
some other developments around the
virtual Dom so you're starting to see it
pop up in more places I think it's
fairly obviously the next step for the
domin and web and client client
rendering so embers already adopted it
you also see people who are
independently trying to build better
different algorithms better better Dom
optimizations with that virtual Dom so
that's pretty exciting you know I don't
know where we'll get in say the next six
months but people are definitely
interested in this stuff also meteor
just announced this week I think that
night they've now incorporated react so
that's cool i'm not sure i would use
meteor for big production app but if you
have something small to make that has
some potential there so last this is
just recommendations based on what i
built with like i said definitely check
out relay react reacts important to this
uh react router webpack there's also
browserify but i really like web packs
fairly ease of use and then you know the
the choice to do the entry points not
abstraction I think that's very
project-based but I think if you want
ease of use ease of developer use the
entry points is really nice so personal
opinion but I yeah so questions anybody
yes
I haven't seen any problems with that
the question was if there's any
complications with the server rendered
DOM and different browser environments
we haven't seen anything like that the
biggest problem we probably have as a
dom is trying to use libraries that do
not have life cycles that play nice with
reacts dom life cycle but that's usually
going to be stuff you're running only in
the browser any other questions yes
yeah so the initial render happens on
the server right and then when we get to
the browser we rehydrate the data before
we do anything else and then we do
another react render but because react
is smart it will rebuild the virtual Dom
and be like oh these are the same then
it won't do anything so it won't cause
like browser repaints which is a good
optimization right so does that answer
your question yes yeah what we use at
vivo is flux like it's not one of the
official flux models but it works very
similarly the reason I didn't do this
here for this example was because really
was coming out and yeah i mean if i was
going to build a production app i would
use either the flux architecture or
relay architecture i thought it was a
little overkill to use flux for purposes
of demonstrating the isomorphic concepts
flux is really powerful and relay once
you get into the single page application
experience for making sure your data
flow is unidirectional through react to
the way it likes so anybody else back
could you could you speak up a little
bit could you speak up
it just makes it easy to render on node
ejs or Jade just because they play nice
out of the box picking the right tool
for the right environment right back to
our different environments like
different things problem yeah
mmm that's a good question the question
was what things cost the dev team most
in time when we were building our
production version ah well lots of
things there are some learning curve
things with react class name not class
that'll bite you when you first start I
think one of the things that really when
we first started working with it it
seemed like for our purposes not
unmounting components was less optimal
than we would have liked so our
framework optionally for sun mount
components on routes but we got into a
situation so we have a video player and
we got into some state situations that
that was actually like making it
impossible to do certain things with the
video player like at the end of videos
so that was a major rewrite where we had
to go back and be like oh we should have
done that they react way the first time
so yeah
theoretically as long as you're testing
all possible props inputs then you
should just be able to test each node
that's one of the things about react
right since since its functional like if
you pass in props a certain set of props
you get a predictable view render so it
shouldn't be dependent on what you're
attached to in the tree right so if
you're starting to mess with state in
ways they don't recommend then I can't
promise that that's true anymore but if
you stick to the idea that you should
really be mostly using props I think
it's pretty safe to assume
yeah um so what we found is whether you
have breath of components or depth of
components once you start getting over
say I don't know 100 components which if
you're building things the react way
which which small small modular
components then you'll get there very
quickly the amount of time to render
view was getting like high very quickly
like hundreds of milliseconds as you go
up and up which is way too long right
when we coupled that with the fact that
our API doesn't always serve things as
fast as you would hope then we were
really in a situation where we had to
have very good caching so yeah I am
hoping that some of like the people who
are exploring other virtual Dom dephine
might come along and solve that problem
Facebook and react 14 is starting to
break out the Dom implementation the
actual render part from the like
declarative syntax of writing components
which is very exciting if you know about
like the react native stuff but also
means that you could come along and
insert your own dipping into that too so
I think they're that some stuff will
start to show up there it's just you
know the community is growing all the
time so cool
well thank you all</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>