<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;GraphQL: Designing a Data Language&quot; by Lee Byron | Coder Coacher - Coaching Coders</title><meta content="&quot;GraphQL: Designing a Data Language&quot; by Lee Byron - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>&quot;GraphQL: Designing a Data Language&quot; by Lee Byron</b></h2><h5 class="post__date">2016-09-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Oh5oC98ztvI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey everyone good morning good morning
strange loop hopefully by now some
caffeine
honking in I hope by the way feel free
if you want to take any pictures that's
totally cool permission granted in
advance today I'm going to talk about
graph QL which is a query language for
api's that we've developed at Facebook
as a replacement for rest api's I'll
introduce graph QL a little bit for
those who haven't had an opportunity to
check it out yet
but really what I want to focus on today
is actually the problems that led us to
graph QL and the process of developing
it over the course of the last four
years and I hope that some of the
lessons that I learned in the process
will be relevant to all the stuff that
you guys are building everyday so my
name is Lee Byron and I work on a team
at Facebook called product
infrastructure our team is responsible
for building the libraries and the tools
that help our teams build great products
I also work in a lot of our open source
libraries so I was an early contributor
to react I'm the creator and maintainer
of immutable j/s and I'm a co-creator
and the maintainer of graph QL in
product infrastructure we run our team
like a service we're always working
super close to product teams to make
sure that we're seeing the real problems
that they're running into on a regular
basis and four years ago we were looking
really closely with our iOS newsfeed
team they were working on a new version
of our iOS app and they were struggling
with actually just retrieving data from
our servers so that's where we wanted to
go focus that problem ultimately led us
to develop graph QL which over the last
four years has become the major way that
we retrieve data not just for newsfeed
but for all of our mobile apps and I
know a lot of you haven't seen graphical
yet so I'll just briefly show you what
it feels like to use graph QL this is
the hello world of graphical queries I
want to know my name I don't know why I
forgot it but this is how I'll get it
again the first thing you'll notice is
that this looks a little bit like JSON
right you've got these curly braces they
look kind of like JSON objects we call
them selection sets and then within
those things you have stuff that they
look a little bit like object keys we
call those fields
and fields themselves can have selection
sets which lets us describe deeply
recursive or nested data we send this
query as a string to a graphical server
where it's parsed and it's executed and
it gives us back a response that looks a
little bit like this and you can see
that the response and the query have the
same structure and this is an important
part of what I graphical is easy to
learn and use a graphical query
describes the shape of the resulting
data that you'll get but of course we
can request fields that have complex
values so here a profile picture is a
complex field it's got information about
the width and height of the image that
we're going to get as long as as well as
the URL that we're going to need to go
load and I bet you can already guess
what this is going to look like when we
run it right it's going to share that
same shape and it's important to point
out that in graph field you have to
query down to individual scaler leaf
nodes so there's no equivalent of like
select star this ensures that there's
zero ambiguity and what you're going to
get and what information is needed so
that no changes on the server could ever
affect the outcome of what this query is
going to be that ends up being super
important and you're gonna get exactly
what you asked for you're gonna get
nothing more and nothing less but of
course and most importantly graph chose
design not just to careí the properties
of one thing but to smoothly follow
connections between them so for example
if I want not just my name but the names
of all of my friends I might write a
query like this and notice that here's
where sequel were to require some join
operations or a REST API might expose a
list of URLs so I'll have to go back and
load this and another round-trip graph
Gale lets us represent this in a way
that's easy to understand and can be
done in a single round-trip to the
server also notice that when we ask for
one field here we're gonna get it on
every single item that comes back in
that list so it's kind of like running a
map operation across a list of things
and of course we can do this as deeply
as is necessary for whatever the data
needs that we have for the app that
we're building so if I want not just my
friends and their names but I want the
events that they're attending next I
might write a query like this we can
continue to do this and naturally
represent these queries at deeper levels
and we can also pass arguments
two fields and this is an important
feature this lets us customize the
behavior of these fields the most common
example of doing this is to paginate
over lists so here I just want my first
friend and the next event that they're
going to attend and this kind of query
shows up all the time in Facebook's apps
we have tons of interrelated data that
all appear in a single view and it's
critical that our mobile apps can show
this kind of thing and do it over a
typical slow high latency mobile network
all right so that this guy is going to
bring me to some of the motivations and
what led us to actually do this in the
first place why did we build a new thing
well the original motivations for graph
QL were efficiency and predictability
and we've already seen these two in
action just with a couple hello world
queries Facebook's newsfeed is full of
interrelated stuff and the ability to
record request and retrieve that and one
round trip was huge another big
challenge that our iOS engineers were
trying to keep track of was exactly what
data is gonna come back from our REST
API
they were using a REST API as before and
they faced tons of subtle bugs when they
made some assumption of what the data
shape was going to be coming back and
they were wrong with graph QL the shape
of the data is known it's easily derived
from the query and later that actually
enabled us to use code generation for
our model classes to completely
eliminate that kind of problem and
another benefit of graph Gale is that
it's backed by a static type system and
I feel like I'd probably don't need to
elaborate the benefits of that to this
crowd but you know what we actually want
to do when we're building a graphical
server is define this type system and
that sets up the capabilities or API and
as we were doing this we were inspired
by RPC systems like captain proto or
thrift so let's take another look at
that query from before I kind of glossed
over something how do we even know that
this is an OK query to run well the type
system told us that it was within every
query you can compare it to the type
system that our server defines and at
the top of every request we have a route
type we typically call it the query type
and it defines all the things that we
can kind of start with and so here we're
asking for me
which is probably the logged in user and
it's going to return to us a user object
from there we can kind of fold in we
could get deeper into these fields and
we can see that the type system
describes both the fields and the
arguments that are available with types
all along the way and in doing so it
describes not just what's possible but
it also describes what's not possible
via omission right
so unlike sequel which lets you perform
kind of at any arbitrary operation
across any column in your table graph
you'll only describes what you tell it
it's going to be allowed to do this is
going to help us make sure that our
graphical servers are performant right
so we're only sorting on indexed columns
or we're only filtering on things that
are easy to filter but also it makes
sure that we actually think about how
we're designing our API is that we
separated across from our databases and
it gives us an opportunity to make sure
that we understand what we're trying to
share what we're not trying to share so
let's continue we asked for friends and
we're going to get back a list of users
lists and our type notation is done with
these kind of square brackets and now we
can ask the name of our friends and the
events that they're attending and events
is going to realize return a list of the
event type and then we can ask for the
names of those events so by having this
type system we're able to prove that
this query is valid before we even
attempt to run it so is this query valid
no it's not valid right like a user
doesn't have attendees that doesn't make
sense an event does and of course like
we're smart people so we can spot this
mistake but importantly the server can
also spot this miss miss a mistake
so without executing the query the type
system is used to determine if this
query is invalid or not and it can
return a useful error if it is and not
only can the server know these things
but the client can as well because
graphical supports introspection so that
means that you can query information
about the graphical types on your server
with graph QL and this is super amazing
for building tools because we can build
things like rich ID ease that not only
tell us if our queries are valid on the
client but it also lets us interact with
them in a way that we would hope
a best-in-class IDE would let us
interact with her own code bases and we
actually built and released a tool that
does exactly this
it's called graphical and it's an IDE in
your browser that helps you write and
test queries against your API it
highlights issues it has type-ahead
completion and it even has an integrated
documentation Explorer and by the way
documentation is a first-class citizen
in graph QL it's part of the
introspection query and that's super
helpful when you're keeping
documentation up-to-date with your code
because it actually lives in your code
rather than some other website or wiki
or some other source you have for your
documentation and finally and probably
most importantly is that it gives more
power to clients to allow api's to
provide features sooner typically when
using something like rest or most other
web api's the server is going to be
responsible for the shape of the data
that's going to be returned and the
clients are going to be responsible for
the views that they're gonna render so
the clients gonna ask for some resource
and then the server is gonna respond
with the data that you know represents
that resource but what happens when our
app needs to add some new feature it's
gonna require maybe some new data from
that resource and it turns out that
models are in views are actually pretty
tightly coupled so we're gonna have to
go to our API team or into our API code
and figure out how we're gonna change
that and that change might be breaking
because we're now adding stuff to that
shape and that means we're gonna
eventually need to release a new version
of our API with that change included
which might take a little bit of time
and effort to make sure we do correctly
but app developers need to be able to
move quickly we need you know future
development is an iterative process so
we need to quickly lead and change
change change or API as we change our
views and of course if the client is
going to need more data than it got from
that initial response then it's going to
just immediately follow all those URLs
that you just gave it and bombard the
server so now our server sad our app is
slow and everything just sucks all right
graph QL is gonna really change this
dynamic first it's gonna express the
full set of capabilities via
type system and then clients are going
to express their requirements their
needs with their data queries
we've given clients the ability to ask
for what they need within a reason it
has to be within the bounds of the type
system and so now we're having
requesting specific resources our
clients are requesting specific data
shapes and this is actually a real
separation of concerns the server knows
what's possible and the clients know
what it needs and so now the server
doesn't need to know anything about the
client and this means that as client's
evolve and add new features they can do
so without affecting the server models
and views they remain coupled but they
have tighter cohesion because they now
exist within the same code base all
right so what does this look like in
practice well at Facebook we have many
different apps that all get data from
one graph QL API and since we shipped
new builds of most of our apps every
couple weeks and we've been at this for
four years now we now have well over a
thousand the older versions of these
apps that unfortunately are still in
heavy use because people don't upgrade
apparently and they all hit the same
graphical API and four years later we're
still using version 1 of our API we've
never made a breaking change in four
years finally I want to mention a few
things that graph coil is not common
misunderstandings graph code is not a
way to talk to your database it doesn't
replace sequel it's not a competitor to
neo4j or the cipher language which i
think is awesome
languages for databases they're gonna
have different semantics the
requirements that they have lead to
different design decisions than what we
had for web API is graph kill is a way
to talk to web api's and it's intended
to sit atop your existing business logic
rather than on top of your existing
database very much like you would do if
you were building a REST API or you know
any kind of Web API graphical is also
not about formal graphs there's no
requirement to model your data in terms
of nodes or edges or explicit
relationships and what we actually mean
when we talk about graphs is the mental
model that it lends us we need this kind
of interconnected data that makes it
super clear of what we're doing in our
apps it's this natural
interconnectedness of the data that
we're using all the time
that makes graphical relevant rather
than some kind of graph formalism and so
maybe that helps explain where the name
graph QL came from and so that's graph
QL we're happy with what we've built but
actually what I just showed you is super
different from what we built four years
ago getting to where we are now has been
a long journey and I want to illustrate
just a little bit about what that
process was like so let's take a look at
kind of like the history of graph Q over
the last couple of years hopefully this
is in flight insightful and it can you
know dispel any thoughts that ideas like
this arrive fully formed they definitely
don't first was the original idea it
came from my coworker Nick Jacques he
initially initially introduced this idea
he called it super graph and Nick was
actually one of the founding members of
our team product infrastructure and up
until this point he had been responsible
for the data fetching and the privacy
checking abstractions on her servers
which made it possible for any view on
facebook.com to efficiently load safe
data that we knew we could show the
users without violating any privacy
rules and as we started working closely
with more mobile teams he had some ideas
for how we could extend these ideas to
our API and he actually built a
prototype of this in about three days
so from idea to initial thing that
worked pretty short but next came the
initial development of what would become
the first version of graph QL I was
already working with the iOS team on
trying to figure out how to improve
their news Fiat API and Nick and I
started to work together to adapt super
graph to solve the newsfeeds actual
problems and Dan Schafer who was an
engineer on the server-side team for
newsfeed joined our effort and he really
helped make this possible and things
happened pretty quickly from there we
evolved graph grille to meet the needs
of the iOS newsfeed and within three
weeks we had something for that team to
actually start using and a couple months
after that we had actually completed
support for the entirety of newsfeed and
then in August of 2012 we actually
shipped this app we shipped new iOS news
and as soon as other teams around our
company saw one that it was fast and two
that that team was actually excited
about the developer experience we
started to get inundated really quickly
with requests to extend graph QL to more
teams at Facebook so first came photos
profile groups then events and then
quickly the rest of Facebook so we
actually this is when we bothered to
form a team around graph QL we kind of
you know made it a little bit more
formal and during this time really what
we did is we focused on making sure that
our type system still made sense as we
continued to evolve it to support more
use cases and we also found a lot more
varying use cases across our client
teams there trying to do more things
interesting things and we started adding
features to the graphical language and
as we were doing that it got complicated
and complicated and this was a long
period of time so it got really
complicated and in January of 2015
Dan Schafer spoke publicly about
graphical for the first time at the
first react conference and really we had
no idea what was gonna happen we thought
people would be like oh okay that's cool
you guys are doing that but instead we
got this overwhelming reaction we got
tons of people asking us what are you
gonna open source it we're like pump the
brakes we just wanted to like give you a
view into you know what we're doing
this was not supposed to be an open
source announcement by any means but the
excitement was so awesome that it got us
all fired up we were like yeah awesome
when can we share graph QL oh wait what
does that even mean
graph curls like super tied into how
Facebook works how we gonna untangle
that and also we're not really proud of
what graph K looks like now we've lost
over a lot of details when we did that
presentation all those quirks and
inconsistencies and the assumptions that
we made from the very beginning they
were all still there so we decided to
reevaluate to redesign graph QL we made
improvements we fixed in consistencies
and we redesigned both the syntax and
the semantics of graph QL and I was a
big project that took many months and it
required a lot more deliberate and
careful process especially in comparison
to the early kind of like rapid pace of
development that characterized
first few months this ended with us open
sourcing a specification for graph QL
which describes how it works
as well as a new reference
implementation that we wrote in
JavaScript and we did that not just
because we like JavaScript we do but
because it's ubiquitous language so as
many people that could understand it as
possible and it lets us build tools on
top of it so the graphical tool that I
showed you before is powered by our
JavaScript graphical implementation and
any open-source maintainer x' in the
audience probably know what I mean when
I say that open sourcing something is a
beginning not an end right we know that
we're going to get a ton of feedback and
so what we did is we Lise released graph
QL as a technical preview just to set
expectations that we knew things are
going to change right kind of the
equivalent of like oh it's beta where
and over this period of time we got a
lot of implementations of graphical and
other languages all really by the
community which was amazing and today
you can actually find an implementation
of graphical and one of almost a dozen
different languages and that brings us
up to this week after a little over a
year graph kills being used not just at
Facebook but by lots of other companies
and earlier this week I'm not sure if
you heard this but github announced that
its new public API is going to be
powered by graph QL which was super
exciting and to reflect this we removed
the technical preview moniker right
graph QL is definitely being used in
production so we should make sure we're
reflecting that and we relaunched our
website graphical org to help teach
people more about how graphic ale works
and how to use it so it's been a wild
couple four years I've learned a lot and
I want to share some of that especially
the principles that we use when
designing graph QL that helped us the
most along the way and I want to start
with what's hopefully the most obvious
and that's when you're designing
anything a language or a library or tool
it's critical to start with a single
important problem to solve for graph QL
that was getting all the data that we
needed for news feed on iOS over
increasingly terrible mobile network
connections and this basically
completely ruled out using rest as an
option we had tried this we quickly
devolved into lots of
custom json endpoints with resources
mashed together in a way that just very
clearly wasn't rest so we had to abandon
that for obvious reasons also don't just
solve any problem solve the most
important problem you can find 2012 is a
while ago now some I'm not sure if you
guys remember this but our mobile apps
were truly terrible at that time they
were awful in fact when Zack filed our
our IPO Rs 1 he specifically called out
the investor risk that mobile was gonna
drive an increasing amount of our daily
users this was trend was already
happening and we hadn't figured out how
to be good at it yet so this wasn't a
theoretical problem by any means this
was an existential threat to our company
failure to adjust to major shifts like
this like desktop to mobile has crippled
or killed major companies in the past
starting with an important problem
grounds you it keeps you honest about
what you're trying to accomplish and it
helps you drive the early prioritization
of ideas and the most novel aspects of
graph QL you know giving clients control
of the data that they get hierarchical
queries one round trip these were all
established within that initial
prototype in response to the problem at
hand so remember to stay focused on the
most important problem that you're
solving and use that to crystallize what
it is that you're building mental models
they're so important to how we think as
programmers everything we make is
ethereal right but there's lots of
different kinds of systems and different
kinds of programmers and the mental
models that we all use they don't always
match up and an important part of
designing graph QL for us was being
unabashedly driven by the needs of the
client the consumer of the language
hopefully it doesn't come as a great
surprise that a lot of great iOS
engineers are also not top-notch network
engineers database engineers or API
designers our iOS engineers wanted to
think in terms of the model objects that
they were going to use and the JSON that
they wanted to get from the network in
order to hydrate those things those who
take a trivial look at graph QL they
usually accuse us of being database
nerds where we've got our database
language hammer and everything looks
like a nail and then they see doom and
gloom in the future but in practice I
think it's really the opposite you know
we're
people we work with product teams and we
designed the API that we wanted to use
to build products so I think if you're
designing a new language or a library or
a tool and especially one that connects
different kinds of systems together try
to escape the mental models of how it
works especially how it works under the
hood and put yourself in the shoes of
the person who's going to be using that
thing how are they thinking and what is
it that they're trying to accomplish I
love this tweet rethink establish best
practices this was tweeted in response
to us open sourcing reacts at the Jay s
Compaq in 2013 and I'm pretty sure it
was supposed to be like guiding and like
poking fun at us but this has become a
mantra for our team probably the most
common question that I get regarding
Graff Co is why we didn't just use rest
soap OData JSON schema JSON IP I ramble
swagger RDF al corbera or any one of the
other things that art existed out there
and I think that just because a best
practice or even just some other tool
exists out there it doesn't necessarily
mean that it's the right solution to
your particular set of problems and none
of these were right for ours I do think
that it's important to respect and honor
best practices and we evaluated all of
these and even borrowed a couple really
good ideas from a lot of them but it's
also important not to be held hostage by
them Elon Musk talks about this is
reasoning from first principles which I
love if you haven't seen this interview
it's pretty amazing please go watch it
and what he talks about is evaluate
existing technologies but really you
want to boil things down to their
fundamentals and then build them back up
and in order to do that you need a good
feedback loop I'm speaking of having a
good feedback loop it's so important to
have a first consumer of your library
tool or language not like first
consumers a first consumer when you're
designing something new it's really easy
to find yourself considering all the
possible future use cases or hearing
tons of stuff coming from the crowd
about all the things you want to be able
to design for and it's basically
impossible to predict all of the details
of what those are gonna be in practice
and the Devils in the details
so otherwise what ends up happening is
you you basically guess right you guess
and if your
wrong on those guesses those decisions
stick around and live in your language
tool or library forever that can lead to
poor trade-offs and unnecessary
complexity so graph goes first client
was newsfeed newsfeed for iOS we
embedded ourselves within that team we
let their needs and priorities drive our
decisions for how we were going to
design graph QL and that encouraged us
to provide an incremental adoption
strategy as well because they were
already using the REST API before and we
couldn't just tell them to replace
everything they had all written in one
fell swoop that wasn't going to work
they also weren't going to start over
they were under time pressure and so
what we needed to do was come up with a
way for them to introduce this idea a
bit by bit which ended up being super
important because as we expanded to the
rest of the company we were able to do
that one little piece at a time I
actually think I don't have a separate
slide for that but the ability to
incremental adopt the technology is very
very important for it expanding and
scope in the future speaking of adding
features your first response to every
new feature request should be ya guinea
you guys know what this means if you do
you're gonna say it with me okay you
ain't gonna need it I didn't hear anyone
so I'm gonna do this again alright I
want to hear this from everyone what do
we say to adding new features
all right good all right good yeah this
is one of my favorite lessons and
honestly it was the hardest for me to
learn personally avoid implementing
things that you foresee you need in
favor of things that you need to solve a
real problem today the burden of proof
should lie on the new feature to prove
that yes truly we are gonna need it ask
yourself can we solve this problem in
another way with the features and tools
that we already have and if we can but
it's awkward
just how awkward is it really can we
live with it is it worth the cognitive
cost every feature that we add to our
libraries or syntax to language it's not
just that it's expensive to implement
that's that's easy it's more to learn
and to teach and it's also more things
for new features that might come in the
future to bump into we may anticipate
motivating reasons for adding new
features and yagna is a way to keep
ourselves from adding stuff until we
truly know those details of what
real-life examples are going to be like
and we're gonna know exactly how common
those are gonna be so if something
totally sucks and we have one motivating
example for why it sucks but it's super
rare maybe that's ok we need real
examples to understand how to prioritize
changes and during the redesign phase of
graph QL I was talked out of a number of
proposals with this argument and
speaking of that redesign effort it's
really important to avoid the second
system syndrome this idea comes from the
book the mythical man-month by Fred
Brooks it's one of my favorite
programming books it claims that the
first time that you're gonna build
something you know that you're a
beginner so you're just gonna naturally
be conservative but the second time
around you have experience you know what
you're doing you have success in your
belt and so you pull out all the stops
and you do all the things that you were
too afraid to do the first time around
and then you end up totally over
designing it as the primary designer of
the graphical language this was
absolutely something that I suffered
from yagna can help but I think the even
better way to combat this
to have an editor as the designer I have
a propensity for ideas I love to create
new things and I tackled this redesign
there's a lot of creative exploration
and I was gung-ho about all the ideas
that came up with and if I was the
designer then my teammate Nick Jacques
should be considered the editor his role
was to play devil's advocate you know
just to be like an all-around pain in
the ass and argue against all my
proposals but in doing so what he did is
he identified the proposals that meant
well and were interesting but they just
weren't worth it and once I was able to
convince Nick that something was worth
it he'd do a complete 180 and become a
huge advocate for it and this process
also also helped us clarify how we
talked about graph QL and the prot
changes that we were making to it which
later helped us pitch them to the rest
of the company because of course the
whole company relied on this so changing
the syntax and the semantics for a thing
that we all relied on is not an easy
thing to do but ultimately my editor
Nick he ended up in the best position to
persuade others of what we were doing
because he himself had been persuaded
and so if you're if you consider
yourself the designer of the architect
for whatever it is at your building
consider which of your co-workers you
think of as your primary editor because
it's really really hard to keep those
competing mentalities in one person's
head graph code changed a lot in those
first few months and we were able to do
that because we sat right next to the
people that we are affecting with those
changes and later as graft was used
across the company it became harder and
harder to make that those changes
changed still possible even in a big
company like Facebook and we were
prepared to open source
graph QL and when we were talking about
that we realized that as hard it was
going to be to change graph QL now it
would be way harder when tons of
companies were relying on this instead
of just Facebook and so while I had been
interested in redesigning graft Hill for
a while it was really this open source
momentum that drove the spark and
motivation to actually make this
redesign happen I think most of us open
source our projects way too early I hope
that's not too bold of a statement
make I love and I deeply believe in open
source but I believe that it's the
opposite of having a first client if
your idea is actually really great
then you're gonna quickly get a ton of
clients and that's not necessarily what
you want for a young idea that still
needs space and time to evolve can make
it difficult to prioritize it also
removes a lot of that freedom to evolve
and you know be able to talk to the one
or two or three people that you're
affecting with that evolution and
finally you know graph QL could have not
worked out
it was lucky and beneficial that it did
work out for us but it was a huge risk
to build something new especially at a
time when we were really kind of facing
an existential crisis about how we were
going to turn things around from mobile
at Facebook and in my experience solving
a really important problem like this is
typically the time when most entering
managers and teams and companies
encourage sticking to what works and
avoid what might seem like taking
unnecessary risks when Nick schrock
first shared his prototype of super
graph he got a fair amount of pushback
exactly like this but ultimately we were
allowed to prove the idea mostly because
of early enthusiasm from that newsfeed
team we were working with some of the
projects I'm most proud of at Facebook
they all started like this including
both graphical and react and what I've
taken away from this is not just to take
risks but in particular to trust
experienced engineers like Nick to
decide when that risk is worth taking
and then hold them accountable for their
choices so especially if you run a team
or a company try to push decision-making
and accountability to your strongest
engineers especially if they think the
time is right for something new so from
Nick super graph in 2012 depowering
mobile newsfeed at Facebook to open open
source and graph killer last year to
github publicly announcing that their
new API is powered by graph QL just this
week graph gills been through a lot
we're super excited about what we've
built so far but still feel like it's
really just the beginning for graph QL
we're still excited about continuing to
invest and carefully evolving graph
queue
to make sure that has more capabilities
and uses in the future but even more
from that we're looking forward to the
contributions from the community as
graph field becomes bigger than we are
so if you're interested in learning more
please take out or check out graph QL
org and thank you all for having me at
strange loop
and I think I have like a few minutes
for questions in the front great
question so the question was how did you
manage to change syntax and semantics of
the language but then also not have a
breaking change to the API so I should
clarify a little bit we've never made a
breaking change to the data aspect of
the API and then doing what we've just
done that might be considered the first
time that we've introduced a v2 of the
API but we're actually still working on
that internally so even though it's been
open sourced for a year now internally
we're still working on adapting all of
our systems to the newer version of
graph QL and in doing so it's been a you
know we open-source that a little over a
year ago so it's a long involved process
to that kind of iteratively and step by
step and making sure that we never break
anything along the way but we are in the
process of setting up a new server and
what it'll do is it'll actually accept
both the old and the new language and
when it receives the old language it
will first quickly transpile it to the
new language and then run the new query
and that allows us to still have one
endpoint and receive queries from all
these different things and accept both
but yeah that's probably the first thing
that we've done that's a breaking change
is actually just like redesign the
entire language of graph girl but we've
still never made a change to the actual
type system the data within graph go
other questions yes I see a bunch of
hands somebody please shout all the way
in the back there yeah
great question so the question is say
you want to take a graphical front-end
and wrap it around some rusty pis and
you're gonna make a bunch of requests
and then stitch them all together in the
process of resolving a graphical request
will that be slow as the slowest rest
requests dependent rest requests yes
probably it will because you need that
data in order to fulfill the request so
you will wait on the longest of those
requests in order to make it happen
one of the experiments that we've been
playing with in graph QL and it's still
very early days from this so certainly
don't expect anything in the very near
future is to add the ability to take one
graphical query and then describe the
pieces where you say this subtree of the
query I care about but I don't care
about it coming immediately so the you
know I want this piece before I want
that piece and that gives us a little
bit of streaming semantics to sending
the requests back or the responses back
so we're playing with that kind of idea
and we don't have anything like that
ready yet but something that we have to
kind of tackle that kind of longest
waiting on the longest piece of data
problem yes in the back there
great question what happens if you're
loading lots of stuff and one thing has
an error we have built into graph cool
and we did from the very beginning a way
to handle errors and in fact if you
start reading more about graph QL the
first thing that you might see as type
system people and go that seems weird is
that by default types in graph QL are
nullable and you actually have to say
that something is non malleable which is
usually totally the opposite of what you
would do in a type system you'd have the
type and then you would say and then
here's the type or it's not right or
like a maybe so it's the like opt in the
inside out
maybe type and what that does is it
makes the assumption that any field in
the request might fail and if the field
fails and it's nullable that's fine you
can return null in its place and then we
side load a list of errors that occurred
during the preparation of that query so
we can say you know ba ba ba you load
friends you load events and at some
point in that you hit a privacy error
and you weren't allowed to see that
event or this database was down and it
dropped this particular profile picture
or whatever something happens you don't
want to Bork the entire query you just
want to Bork that sub tree that's not
possible and if something isn't capable
of being null and it has an error then
it just simply bubbles up until it finds
the first thing that does so a good
example of that is if you have a news
feed story the actor is probably
something you know the person who posted
the news feed story is something that
should be there it'd be really weird if
you saw a news feed story show up and it
didn't have who it was from so we make
that not nullable and if an error ever
happens during the preparation of the
actor of a news feed story then we just
null the entire news feed story and we
report that air to the client as well
great question though any other
questions I think I have time for one
more here question was are the plans for
streaming data or something like
subscriptions yes we have a bunch of
experiments that are dealing with this
there's still early days we actually
have deployed some of those at Facebook
so even though it's early days we're
actually really using in production
these experiments so we have two
different ways of thinking about this
one we call live queries which is the
ability to say
here's a whole query and then if any
piece of the data anywhere in that query
changes send me a diff with that update
and you might think about that is like
react for your data on the server maybe
a mental model think of that and then
the other is subscriptions which is
layering graph QL on top of a pub sub
system and that is one that we actually
have in production and if you have ever
like commented on Facebook both on the
web and on your iOS or Android device
then you have seen graphical
subscriptions in actions or in action it
also powers our live video feature so if
people are like commenting and like
doing stuff during a live video that's
all powered by graph Co subscriptions so
we're still trying to figure out like
that's evolving quickly and it kind of
leads back to some of the lessons I was
talking about of we we like to keep some
of these things experimental as possible
early because we've already changed that
system a lot and we want to make sure
that we don't say like here's a great
way to do subscriptions psych it doesn't
work for all these reasons after you've
all implemented it and so we want to
make sure that we really get that right
before building it into graphical
alright thank you guys all for having me
it's been a pleasure</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>