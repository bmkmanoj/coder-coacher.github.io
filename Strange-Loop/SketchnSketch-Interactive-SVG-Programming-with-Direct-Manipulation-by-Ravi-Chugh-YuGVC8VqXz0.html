<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Sketch-n-Sketch: Interactive SVG Programming with Direct Manipulation&quot; by Ravi Chugh | Coder Coacher - Coaching Coders</title><meta content="&quot;Sketch-n-Sketch: Interactive SVG Programming with Direct Manipulation&quot; by Ravi Chugh - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>&quot;Sketch-n-Sketch: Interactive SVG Programming with Direct Manipulation&quot; by Ravi Chugh</b></h2><h5 class="post__date">2016-09-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YuGVC8VqXz0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm Ravi chug from the University of
Chicago what I'll be presenting today is
work that my students and I are doing on
trying to combine programming and direct
manipulation and so a running theme for
this talk is going to be Ferris wheels
so here is a picture of the first ferris
wheel that was built in the 1890s about
five hours up the river from here and so
let's suppose that we want to make a
talk a presentation on the history of
Ferris wheels so what we'll want to do
is to design a bunch of diagrams that
help show how Ferris wheels work so to
start let's imagine that we'll use a
direct manipulation system like
illustrator or PowerPoint to make these
diagrams so to start we would draw a
circle for the wheel we would draw a
spoke along the circle draw another
spoke along the other edge and now we
would start to draw circles and squares
from the passenger cars copying and
pasting them and manually positioning
them around the edges ok so now we would
copy and paste our spokes and our
passenger cars a few more times move
them where they ought to be and pretty
quickly we get our first kind of
iteration of our design ok so now let's
say we want to make a bigger version of
the wheel so if we grouped all the
elements and scaled them we see that the
passenger cars got really big too which
is not really what we want so instead we
would probably have to scale the wheel
first reposition it back in the center
and move the passenger cars along the
the bigger wheel now ok so now we've got
our bigger wheel let's say we want to
create a rotated version of it to show
how the wheel rotates over time so if we
grouped all the elements and rotated
them now all the passenger cars have
kind of fallen over which is not quite
what we want and so what we would
probably have to do is ditch the
passenger cars that we made start from
an initial initial perpendicular one
copy and paste it and manually position
it around the edges ok so turning out
different variations is starting to get
tedious especially if we wanted to
change a design parameter such as the
number of spokes where it's not a power
of two ok so instead those of us in this
room might choose to use a programming
language instead to generate these
different diagrams right so we would
open our favorite text editor and pick
our favorite language and then we would
need to start drawing shapes but really
drawing in a programming language means
going
to the text buffer typing some symbols
running it and see what comes out okay
then we would go back to our program
add a couple more definitions run run
run the program and see what comes out
okay so now that we have gotten basic
things drawing now we would think how
can I set up my program so that there's
relationships that are captured in the
output right so now I would maybe go and
add some relationships between the left
edge of the line and the circle run the
program to make sure that they snap up
correctly then I would go back into the
program at a relationship between the
right side of the circle and the line
make sure they kind of line up
appropriately and continue to go back
into our program relating more shapes in
our output okay so now we've got a basic
handle on how the program is working so
maybe now I can sit down and write a
bunch of code to generate a whole bunch
of shapes that are all like already kind
of positioned where I want them okay so
now the design is starting to take shape
and so now we think this might be a good
time to pause and group or refactor our
program to write a single function that
generates the design with all the design
parameters as arguments to our function
okay so now at this point if we want to
change any of the design parameters we
can go back to our function call and
tweak those numbers you know change them
to different constants run the program
and see what comes out if it doesn't
really line up with what we want we
would go back to the program tweak some
more numbers and continue to kind of go
back to the code tweak numbers run until
we get a configuration that we're more
happy with okay and so at the end of
this process it's great because we do
have a high-level reusable function but
remember that it took us like 42 steps
to actually get here okay and so early
on in the design process the program was
really disconnected to what we were
trying to do and only later on did it
start to become useful okay on the other
hand direct manipulation allowed us to
get off the ground really nicely and
with intuitive feedback but then when we
wanted to do something complex it became
really tedious so the goal is to ask
whether we can combine the best of both
programming and direct manipulation in
the same system so that is we'd like to
be able to start by directly drawing
shapes in the canvas and have the system
automatically generate a starter program
for us then
we would like to start declaring
intended relationships in our output
again using direct manipulation and have
the system automatically refactor or
program to match those changes then we
would like to continue to directly
manipulate the output adding and
grouping new shapes and again have the
system refactor our program to match our
changes and then we would like to be
able to directly modify low-level design
parameters directly in the output and
have the program be updated in sync okay
so what we're what we're after here is
really to be able to build interactive
programming systems where we can build
programs with many fewer keystrokes okay
so as Brett Victor has just described it
we'd like to do less blind manipulation
of symbols and instead we'd like to do
more programming by directly
manipulating output so in this talk what
I'll present is a research prototype
called sketch and sketch that we've been
developing to try to start to achieve
this goal for the particular domain of
vector graphics and so I'm going to
spend most of the rest of the talk
demoing the tool and so to give kind of
a high-level overview of what we're
going to see there's basically three
parts of the demo the first part of the
demo is to show how sketch and sketch
comes with a programming language that's
just an ordinary functional programming
language there's not much special about
it you can write code run it to produce
output and in the first part of the demo
will show how to write some text based
code that generates this radial array of
lines this will be the spokes for a
ferris wheel then in the second part of
the demo we're going to build a program
that implements this geometric lambda
pattern and we're going to do this by
starting from a blank canvas and
iteratively building up the program
using only direct manipulation then in
the third part of the demo we'll combine
this geometric lambda logo and our
spokes from before and using both text
editing and mostly direct manipulation
we'll implement this ferris wheel of of
logos okay and so the key takeaway is
going to be that we're going to be able
to build up a high-level reusable
program with many fewer keystrokes than
we would be able to if we're using a
traditional programming language okay
okay so now let's head over to the
application which is just running as a
web app
my browser and the left half of the
editor is a text box where we're gonna
write our program and the right half is
going to be where the output SVG is
rendered so the programming language
inside sketch and sketch is a little
functional language it's got lispy like
syntax but it's not it's just a really
hand rolled kind of small language
there's nothing special about it okay
and so we're gonna start by just you
know writing code to draw shapes on the
output so we can for example draw a gray
line with width for from let's say the
point 100 100 to 200 200 and run our
program and out pops our our first
little line okay now let's say we wanted
to define our line in a name in a
variable first so we can define a new
top-level definition to bind our line
definition and then refer to it in our
little main expression here okay so now
let's take this my line definition and
turn it into a function that's
parameterised over a couple of arguments
okay so what we'll do is we'll define a
function a lambda that takes two
arguments I'll call them CX and CY for
Center X and Center Y and instead of
drawing this line always from the point
100 100 let's draw it from the argument
CX and CY - 200 200 ok so now I can go
and call my line with a couple of
different point arguments and how it
should pop out two lines okay so nothing
so exciting so far so one more thing
that we'll do while kind of doing normal
traditional text editing is to turn this
function into one that not only drives a
single line but draws this radial array
of lines okay so we want this wheel of
spokes so to do this what we'll need is
to define a list of points that's going
to define the end points around our our
wheel or circle and I'll start by just
using the empty list just so that we can
get the the program
set up and so once we have this list of
points we're going to map each of the
points XY that's going to be around the
edge of the circle oh and now I've made
my text size a little bit too big we're
going to map each of those points to a
line that's drawn from the center point
CX CY to the point XY that's around the
circle okay and so once we have our list
of points we're going to map each of
them to this line and the next question
is how do we get this list of points
right so we've initialized points to a
dummy list we need to actually compute a
list of points so sketch and sketch
comes with a library of just basic
functional programming utility functions
and also some useful SVG manipulating
functions so I'm going to tab over to a
window where I have this prelude file
open and show you a function that's
gonna help with our task here endpoints
on circle is gonna take a Center
argument the number of points rotation
radius and it's going to compute a list
of points for us okay so what we need is
to call this this library function
inside our spokes function okay so
endpoints on circle notice takes a bunch
of arguments we have Center X and Center
Y we have those already as arguments to
spokes but we also need the number of
points the rotation and the radius okay
so I'll add those as parameters to my
function make sure I've got enough
parentheses and now we can call our
spokes function with let's say Center
100 100 let's draw a seven spokes maybe
with radius 60 will not rotate our wheel
and so if we've you know typed
everything correctly out pops our wheel
of of lines okay so everything so far
has been completely traditional
text-based programming in the next part
of the demo let's start implementing
this geometric lambda design okay and so
unlike using a traditional language
where we would have to start by typing
code to generate shapes this time we're
going to start using the built in
drawing tools to directly draw shapes in
the canvas okay so we'll start by
drawing
rectangle and notice how sketch and
sketch is auto-generated a new
definition in our program and notice how
the whitespace and variable names are
chosen to be readable so that if and
when we when we need to dive into the
code we kind of have a sense of what's
going on okay and so just like a normal
language if we wanted to let's say make
the rectangle wider we could change a
number and rerun it but better yet
sketch and sketch allows us to directly
manipulate shapes in the output while it
updates the constants in our program to
match okay so we can change basic
attributes like the position the x and y
as well as width and height and other
attributes like the color of the
interior the the fill of the box as well
as stroke parameters okay and so while
I'm making each of these changes sketch
and sketch is updating our program in
sync and re rendering the results of the
program to give us this kind of live
feedback okay so remember we want to
draw this kind of lambda logo so we need
a couple more shapes we need a couple
more lines so I'll continue to use the
drawing tools to draw shapes and the
output and again sketching sketches
adding you know new shape definitions
that are completely unrelated to one
another they all have just separate you
know constants as their design
parameters okay so you know we can start
to fudge our lines a little bit to try
to make it more like a lambda but really
what we want is we want you know the end
points to really kind of snap up exactly
right so how would we do this in a
traditional text-based language so first
we would say okay what are the numbers
that define the position of this box
well that's 73 and 228 what are the
numbers in the program that define the
end point of this line that's 88 and 248
so what we would do with kind of normal
text refactoring is we would do
something like pull these numbers up
into new variables let's call them top
left X and top left Y and now in place
of those constant literals before we
would use our our new variables okay so
by using top left X on top left Y for
both points now the point should be
snapped together which is the
relationship that we want
okay so that's normal text-based
refactoring instead sketch and sketch
provides automated support for
introducing equality relationships like
this okay so I'm going to undo this
manual text editing that I just did and
instead go back to this kind of having
you know three shape definitions that
are completely unrelated and instead
what we'll do this time is we will
select those two points that were
interested in and press this button
that's labeled a equals B to instruct
sketch and sketch to try to refactor the
program to make these values equal okay
so when I press this button sketching
sketch is gonna automate that text-based
refactoring that we just did manually
okay so when we make these two values
equal sketch and sketch has added two
new variables to the program here and
notice how the auto-generated names
indicate where these numbers came from
so they both came from the rect one
definition and furthermore they came
from local variables x and y okay and so
now these variables are used in both
shape definitions and so when we
directly manipulate any one of the
objects in the output the other object
is affected as well because they're both
defined by the same constants in the
program okay so in this way we can
continue to select the pairs of points
that we're interested in and instruct
sketch and sketch to introduce variables
to make them equal so we need one more
one more pair of clicks here and so now
at this point and it keeps getting rid
of my whitespace bummer so at this point
notice how we've got variables for the
top left corner of our rectangle the
width and the height and the positions
of all the other shapes are computed in
terms of those design parameters okay so
that's it for the basic geometric
constraints next let's see how to get
the color and the stroke width of the
different lines to be to match up so
just like we could select positional
attributes in the output we can also
select color attributes as well so we
can select the stroke sliders for each
of our three shapes and again instruct
sketch and sketch to make them
cool and in response we get a new stroke
variable that's been pulled outside the
definitions initialized to one of the
three color values chosen arbitrarily
and this variable is now used to control
the color of each of these three lines
okay and so by changing any one of the
colors the other two colors are affected
as well
and similarly we can select the stroke
width sliders and struck sketch and
sketch to make them equal and so now we
have a stroke width variable that again
is used to control the widths of all
three of these lines okay so one more
relationship that we might want to
impose on this logo is that it always
remains square when we scale it and so
to do that we can use the width and
height selection lines on our rectangle
make them equal and sketch and sketch
has chosen to use the width value now
both as the the width and the height of
our rectangle okay so now whenever we
scale the the shape in one direction the
other dimension is just changed as well
okay so we've gone from having no shapes
to having a program with all these
relationships kind of encoded but all
these shapes and they're kind of design
parameters are designed or defined as
top level definitions in our program
next we want to start refactoring the
program to turn it into a single
reusable function that we can then use
to generate many different variations of
the logo so sketch and sketch provides
several tools for helping with this kind
of grouping and abstraction process so
one of these tools allows us to select a
point in the output and several shapes
that we want to group around that point
okay so when I click the group button
sketch ins got sketch is going to look
for all the definitions that contribute
to the selected shapes and turn them
into a single top-level definition that
generates all of those shapes okay so
notice how when we press group sketch
and sketch has collected all of those
definitions inside a new new group
definition and so now this one
definition draws all three of the shapes
that we had
okay but the design parameters are still
hard-coded constants inside this
definition so to turn this into a
function that's parametrized over the
design parameters we can select our logo
and hit the abstract button to turn to
turn a new group into a function that's
parametrized over these design
parameters okay and so notice here how
it takes no crashing yep good okay good
so we've got a bunch of these design
parameters and the anchor position to
draw the shape and so now our single
logo is a call to the new group function
with this anchor argument 103 sorry this
is kind of like a reverse application
there's really nothing special here call
this group function with all these
arguments and then this point okay and
so directly manipulating this call is
just changing the arguments to that
function and so now if we want to copy
and paste or duplicate what that means
is just add a new function call to the
same function okay and so because each
of the design parameters are different
constant literals we can change them
independently at call sites without
affecting the other shape right so all
of the kind of geometric relationships
were encoded inside the function body
and all the design parameters are you
know per per function call okay so what
we've done is we've gone from you know
drawing shapes to relating shapes up to
building a reusable abstraction next in
the third and final part of the demo
let's put together this logo function
that we have with our wheel of spokes to
make a ferris wheel of lambdas okay so
that's something you hear every day
right so let's get rid of the second
logo we don't need it which is going to
use one one version of it and so
sketching sketch provides a couple of
tools for basic patterns of repetition
so we can select our are lambda logo and
press the repeat around button and in
response sketch and sketch has inserted
a call to a library function called
radial array which takes several
arguments
so the first argument is the number of
shapes in this array and there's a
couple of annotations here so this
exclamation point freezes the number in
the program which tells sketch and
sketch not to change this number when
the user directly manipulates any shape
instead this second annotation 1 to 20
says that this value ought to be in the
range 1 to 20 and furthermore the editor
draws a slider at the bottom of the
canvas that allows that number to be
changed using direct manipulation of
this slider the second argument here is
the the radius of the wheel and sketch
and sketch has drawn this little helper
widget to easily change the radius and
the third argument here is the rotation
which again comes with a slider that we
can use to tilt the wheel left and right
okay and so maybe I'll make the logo a
little bit smaller so we can fit more of
them around the wheel okay good so okay
so one thing that you might have noticed
now is that the lambdas actually aren't
quite centered around the center right
and that's because our new group
function was parameterised over a top
left anchor and not the center of the
logo okay so I mean it's kind of like
translate the anchor point to this logo
function but no problem this is a
general-purpose language so we can edit
the code to write a little wrapper
around our new group function okay so
remember that what new group is is a
function that takes a bunch of colors
and things and then the position to draw
the top left corner of the logo and so
what radial array is doing is internally
it's computing a bunch of points around
a circle and then calling our logo
function with each of those points right
so to make that explicit really what is
going on is for each point XY around our
logo radial array is calling new group
with that particular point okay so I'm
just kind of added a lambda expression
here to make that explicit but what that
means is that if we want to call our
logo function with a different argument
if we want to translate it this is our
opportunity this is the chance where we
can you know translate it a little bit
before calling the function so to kind
of see to kind of make sure that well
let's just start by translating each
anchor point by a couple of hard-coded
constants just to make sure that we've
identified the right piece of code okay
good so now all the anchors have kind of
shifted up into the left a bit but
really what we want is to get the anchor
to be exactly in the center of the logo
right so we want to translate
coordinates by half of the size of the
logo okay so what is the size of the
logo so remember that there is this rect
1w parameter the width or the size
parameter so what we need is we need a
name for our size argument 45 so right
now it's a constant literal so what I'll
do is I'm going to add a new local
variable called size initialize it or
bind it to bind 42 to it and so now we
have a name for the size parameter and
so instead of offsetting our anchor by
random constant literals we can offset
them by size divided by two okay and so
if we've done our math correctly now we
have basically translated the anchor so
that it'll be in the center and then we
call our logo function with that anchor
okay good so let's see we've got our
array of lambdas we've got our spokes we
also wanted remember we also wanted kind
of a central circle in the middle of our
ferris wheel so next let's add a circle
that's going to form the kind of main
hubcap of our wheel oh good and it's
kind of picked automatically randomly
picked a metallic color for me but we
can of course change it if we need to
okay good so we want the center of this
circle to be exactly equal to the center
of our wheel of logos and we want that
to be exactly equal to the center of our
spokes array okay so we can use our
trusty friend make equal to introduce
new variables in our program which have
very helpful names kay 47:59 and just
like before these variables are used to
now control the Centers of each of those
three previously unrelated expressions
okay so we're getting close but now
we're at the point where you know the
way that we control the number of logos
is unrelated to the
we control the spokes and so we need to
kind of make those we need to introduce
those relationships so one way that we
can do that one kind of little fun way
to do this is well we've got these
slider annotations that we can add so
why don't we add slider annotations for
these other parameters as well for
number of spokes the radius of the spoke
or the length of the spokes the rotation
of our spokes and so now we'll get a
whole bunch of sliders in the output
where we can you know change the number
of spokes sorry this is the number of
logos this is the number of spokes we
want them to always be equal so just
like we can select color sliders we can
select these helper sliders at the
bottom tell sketch and sketch to make
them equal and so now we have you know a
single variable in the program that's
gonna be controlling both ooh what did I
do here are they changing oh man what
did I do
maybe I selected the wrong slider let's
see if we can debug this undo undo so
let's see this is the number oh okay
great actually this is good so there's a
lot of demo this is nothing fancy going
on here
so I told sketch and sketch to make 12
and I told sketch and sketch to make 5
and 12 equal what it tried to do was say
okay you're trying to make the number 5
equal to the number 12 but actually this
number 12 is frozen so schedule sketch
not is not allowed to touch that number
so that's why I didn't replace this
constant with the variable that it
inserted so right now I need to you know
unfreeze that number so that when I tell
the sketch and sketch to introduce a
variable it then has permission to do so
okay and so let's see while we're at it
let's just add a slider for the radius 2
so now if we select both of these
sliders for the spokes and the number of
cars press make equal okay now you can
clap instead okay good okay good sorry
okay good so thank you what we can do is
now we'll make the two separate rotation
parameters equal we'll make the two
radius parameters equal and so now we've
kind of locked up all of the arguments
for each of the arrays of spokes and the
logos and so now we can tweak you know
all the kind of high-level design
parameters that that we wanted to either
directly manipulating shapes or directly
manipulating sliders and then when we're
done with all this right we can turn off
these helper objects we can export our
output to you know some other SVG editor
and maybe we can even take this you know
high-level program and reuse it
somewhere else like for example if we
wanted to generate a whole bunch of
ferris-wheel diagrams for a presentation
for example not that I did that I use
PowerPoint but hopefully one day future
work will get to this in a few minutes
okay good so now let's Pat pop back over
to the slides so okay so we've seen a
lot in the demo we started with kind of
a normal text based programming language
we did a little bit typing but then we
did a lot of transformations with a lot
of automated or semi-automated support
from the system right and so in
particular sketch and sketch allowed us
to directly manipulate at various phases
in the design process and sketching
sketch came with refactorings that were
kind of tailored to each of these
developments of programming in this
domain of SVG and we were able to
basically build up this kind of
high-level program with you know fewer
many fewer keystrokes I think then you
would if you were using a normal kind of
programming language and so specifically
if we you know have been using a
programming language from the Year 2015
for example instead of you know having
to start by drawing func writing
function calls in our program and
running them we were often able to just
draw shapes in the canvas right then
instead of always having to introduce
new variables into our program to add
new relationship constraints we were
often able to select things in the
output and tell sketch and sketch to
make them equal then instead of having
to manually refactor and group and
abstract our definitions we were able to
select shapes on the output and again
have sketch and sketch group and
abstract them for us and finally instead
having to look through our program kind
of hunting and pecking for the constants
to change we were able to awfully just
directly manipulate design parameters in
the output okay and so while this kind
of workflow significantly reduces the
amount of manual text base editing
there's still a long way to go to really
kind of achieve a much more seamless
combination of programming and direct
manipulation so next I want to point out
a few of the many limitations that the
current system has which lend themselves
to natural areas for for future work so
in our demo we saw many cases where
sketch and sketch can introduce a
variable to relate to expressions in
more complicated cases discussions catch
sometimes in inserts they really kind of
complicated very verbose arithmetic
expression that is mathematically
correct but is not something that you
know you would write by hand and so in
the future we plan to incorporate a
smarter algebra algebraic constraint
solver that can simplify these
expressions much you know more
effectively before inserting them into
the program another kind of limitation
is that currently our refactorings for
grouping and abstraction require that
the program be in the form of a bunch of
top-level definitions followed by main
and then the user can select certain
top-level definitions by direct
manipulation to trigger the refactoring
but in the future we would like to
provide that similar similar kinds of
refactorings but for programs in
arbitrate more arbitrary structure
another limitation is that the currently
the way that we decide what constants to
change and solve for while we're
dragging the the shapes is relatively
naive it's very naive and so sometimes
you get situations where maybe you try
dragging a shape to the left and instead
it grows to the right and so again by
incorporating a more general algebraic
constraint solver we expect to be able
to provide more intuitive live
interactions for more more cases and
then finally for all of these kinds of
refactorings there's many different
programs that we could have produced and
so currently our approach is to use
various heuristics to automatically
choose one of the options so that we
give the user some immediate feedback
but on the other hand
that often means that the user doesn't
really get the program update that they
expect and so in the future we plan to
include the user in the loop when
there's lots of ambiguity to better
resolve what the user actually intends
okay so stepping up a level so the
approach that we've taken here is to
start with a completely traditional
vanilla functional language and add
direct manipulation capabilities to it
instead of starting with the direct
manipulation system and trying to make
it more programmable and so we've chosen
this approach for a couple of reasons
the first is that we hope that by
starting with a general-purpose language
that we can reuse a bunch of this effort
when we think about other application
domains another reason is that no matter
how many built-in tools come with a
direct manipulation system there's
always going to be limits to what the
tool can do well automatically and so by
using a general-purpose program as the
representation we enable expert users
and library writers to customize
features beyond those that are provided
so the transformations that I showed
some of them are actually general
they're independent of the domain so the
way that we relate and abstract values
doesn't take into account anything about
SVG but other transformations like for
drawing and grouping are domain-specific
and so our hope is that in future work
as we try to build similar kinds of
workflows for other domains like web
application development for document
generation for visualization
spreadsheets and so on we hope that
there's kind of a class of general
transformation techniques that apply
broadly but that each domain will
require a custom user interface that's
really catered to the programming idioms
in that domain furthermore let me go
back a slide so furthermore so the kind
of language inside sketching sketch
right now is kind of a toy little
language but ideally we'd like to be
able to provide similar kinds of
refactorings for you know your favorite
real language like racket or JavaScript
or elm or whatever it is maybe the
Knitting language that we saw earlier
okay great so this this goal of
combining programming and direct
manipulation particularly for the domain
of SVG has been you know sought by you
know many projects over over the years
one area of related work
can be described as dynamic drawing
tools tools such as bread victor's
systems as well as systems like
apparatus and others which tend to take
the approach of starting with a direct
manipulation system and trying to make
them more programmable and in particular
they often try to limit or even prohibit
the amount of kind of text-based
editing that one can do and so in
contrast we've chosen to start with a
general language again because of the
you know potential for reuse and
extensibility another related line of
attack our constraint oriented
programming systems like sketchpad thing
lab and others which allow users to
declare constraints either on the
program or on the output and these
systems lead to a similar kind of
interaction that we're seeking but in
contrast we limit all use of constraints
and constraint solving to the program
transformation phase and so after that
transformation we have a normal vanilla
deterministic program that is we don't
have constraint solving in the semantics
of our programming language itself and
finally what we're you know trying to
build here is definitely an instance of
live programming where you want to see
the effects of changes immediately
including more recent live programming
languages by seán McDormand which are
other also trying to get this kind of
backwards connection as well okay so to
wrap up the kind of like high-level
takeaway here is that we want to be able
to build programs by typing less and
directly manipulating more and so sketch
and sketch is kind of a first attempt to
make progress in this direction by
providing automated refactoring tools
for this particular domain of vector
graphics and so if you'd like to learn
more our project page has our web app
demo it's got our open-source
implementation which we built in elm
which turned out to be a really great
choice for us and we're going to
continue to really enjoy that kind of
development workflow we also have a
bunch of videos that have more examples
as well as papers that explain the
technical details that are under the
hood thanks
so I think there are four minutes
standing in the way between us and
Saturday snacks so if there's questions
I'm happy to take some right right so so
the question that the question was for
those of you in here am i magician
the answer is no so so no there's lots
of these tools that do try to like Auto
generate code and things like that so
now there's I mean there's a lot of
other tools that particularly in kind of
areas described as program synthesis or
program repair that take a program and
maybe a specification of what you want
to change on the output and they try to
fit you know a program a new expression
that fits back into your program in a
nice way but for kind of a more general
kind of like programming domain one
where you really do care about the
readability the concrete syntax of your
program and the kind of visual output I
haven't seen anything like this yet but
for kind of general programming like you
know sorting lists and things like that
there are programs synthesis techniques
that really can take examples of what
you want and you know come up with you
know correct implementations of what
you're after
we haven't but that so the question was
have we tried something similar for
graphics or 3d modeling CAD tools we
haven't yet but that is definitely one
of the many kind of applications that
stack up here yeah I would love to be
able to you know strive for similar kind
of workflows in many domains where you
know there is a good amount of kind of
visual inherent visual representations
of what you're manipulating and a lot of
times it would be great to go backwards
if there are resources or people that
would like to join the project please
let me know we'd be happy to maybe who's
standing in the center
right so that's a good question so the
question was instead of extending
general purpose languages with direct
manipulation have we thought about
starting with Inkscape or something like
that and adding programmability again
that's something that we would love to
do I think early you know before I
started working on this a few years ago
I think I was thinking oh maybe well big
build like a PowerPoint plug-in to kind
of do this thing but so far I think you
know starting with kind of a clean slate
editor was the best way to make progress
on the underlying technology and then
you know once it starts to work better
than I think it makes sense to put in
the effort of trying to you know make a
plug in for a real system but Inkscape
would be obviously a great you know
place to kind of deploy this this work
so we haven't gotten there yet because
we've been actually trying to make like
the simplest choices at each place where
there's a big design space and there's
lots of knobs to turn we keep kind of
like turning it down to like the
simplest setting and it seems to be you
know we're not running into any walls
yet like for example I'm in the way that
we solve for new numbers when you're
dragging things in the output we're
actually being very optimistic
we're not guaranteeing that when we
compute a new update that your program
will even take the same control flow it
did before
okay so we're actually optimistically
assuming that you know the weight of the
program computed this number is going to
be the same even if we change other
values in the program and it turns out
that for at least simple examples when
you've got high-level design
you've got design parameters that don't
affect the way the program runs that's a
perfectly fine assumption but in more
general cases we're certainly gonna have
to reason about control flow and
function boundaries much more but so far
we haven't you know tried to solve that
which might be a bigger bottleneck maybe
one more question and then Saturday
snack
um so I think so so the Ross VG that I
shed really is raw SVG there's no it's
our metadata but you know just before
that step each number in the output is
tagged with some metadata about the
program evaluation that produced it and
so that's actually the hook that we use
when we you know change a number in the
output we say okay what's the metadata
that came with this number that gives us
a bunch of possible things we could
change in the program and then we you
know choose an update based on that and
so we definitely can apply a similar
kind of tracing and provenance strategy
for HTML apps where you have CSS that
you might want to tweak and things like
that okay cool
thanks a lot I'm happy to chat more in
the break</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>