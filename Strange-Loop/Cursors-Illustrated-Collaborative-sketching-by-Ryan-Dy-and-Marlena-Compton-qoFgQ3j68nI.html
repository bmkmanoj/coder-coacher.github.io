<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Cursors Illustrated: Collaborative sketching&quot; by Ryan Dy and Marlena Compton | Coder Coacher - Coaching Coders</title><meta content="&quot;Cursors Illustrated: Collaborative sketching&quot; by Ryan Dy and Marlena Compton - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Cursors Illustrated: Collaborative sketching&quot; by Ryan Dy and Marlena Compton</b></h2><h5 class="post__date">2015-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qoFgQ3j68nI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">what does a square
programming and the web it's just a
shape but so is a triangle circle and
the line with these shapes you can draw
just about anything you could draw a
conversation between two cats
you can group some thoughts together and
you can shed some light on an idea
for some of us it's the web and
functional programming that's simple
while drawing something on a piece of
paper and showing it to someone else is
the hard part sometimes a blank page can
be intimidating where do you start it's
a blank page drawing some lines can help
you divide your page into sections
you'll find that some talks fit nicely
into neat sections while other talks
flow in more of a circle with the
speaker returning to a certain point and
fanning out it's important to remember
that sketching is not about art in any
way but only about making really bad
drawings with a few simple shapes we
hope you feel like drawing with us today
and the plans to give you a talk that's
both technically dense maybe to the
point to overwhelm but this is when
going back to a simple shape such as a
square circle or triangle can help you
can help to give you a new perspective
on what you're trying to understand if
you're wondering where to start drawing
let's start with the square this is a
square but it can be something else as
well this square is a black box that
takes input and creates new output we
could also call this black box a
function it has an input and an output
everything that is happening only
happens in the black box there are no
side effects when we provide the same
inputs we get the same output when we
change the input we get different output
this function is what we call idempotent
the functions output can feed into
another function
once you're at this point you're not
that far from a web app
why does the web need functions in
functional programming I mean there are
plenty of frameworks why do we even need
to react or cursors for the web looking
back at how websites how we use websites
may shed some light on what functional
programming can help web apps started
with the concept of a user looking at
some information on a page then moving
to another page to see this information
click on a link paste in a URL look at
the content then move on to another page
eventually frameworks like rails helped
us to develop web applications that
would put more content our pages after
scrolling through a list of 20 to 50
items we could click a button to move to
the next page for these apps and
frameworks traditional NBC was kind of
the way we do things but as the web has
become more of a focus in our daily
lives we're looking we're looking at a
new set of items when we look at a new
set of items we don't really want to
turn a page anymore but we prefer to
have infinite scroll we don't even want
to have a page in fact we don't even
want to turn pages or have the concept
of a page we're forcing more and more of
our activity into this view of a single
page the web frameworks we use to build
these complicated views are now
responsible for more work MVC might have
brought us here but if we let go of NBC
we think it'll be easier to understand
as an application as a series of
composable pieces these composable
pieces are small and by combining to the
get by combining them together in
different ways we can build new
functionality without having to make new
components we think that web frameworks
that embrace functional programming will
help us keep up with the demands of the
web one of these frameworks is react
react uses functional programming
concepts unlike other frameworks react
focuses on the view layer it isn't as
opinionated on how to structure
applications beyond the view how does
react accomplish this let's go back to
our function for just a moment
we've talked about how functions or a
black box but we could use another name
for them in fact react has another name
for this exact same concept a component
a react component is similar in concept
to a pure function react components must
have a render method when render is
called react draws HTML in the browser
in most web frameworks there's a support
separation of logic from templates react
takes a different approach react
applications are the combination of many
modular components that have a single
responsibility instead of making one
large complex component you want to make
many smaller simpler components that can
be combined aside from composition this
gives you the added benefit of working
solely in JavaScript there is new
templating language it's just code all
of the components are JavaScript
functions the inputs to a react
component are called props they are the
same as function parameters given the
same set of props or react component
renders the same HTML you can rerender
the component as many times as you want
given the same props the output is the
same typically react components are
idempotent like pure functions react
components also have the concept of
state state can be changed by a
component and passed to a child
components when either props or state
change the component is rear end ered
react is essentially reacting to changes
in props and state if you like functions
and functional programming you're going
to like react
here's an example of a web app made from
many components it's a pretty standard
to do up as you can see there's a header
sub to do items and a few buttons that
let us interact with the app having a
look at the front end we can easily
break this app into components react
encourages the use of these components
to break down view behavior into simpler
building blocks this type of composition
makes it easier to share the code
drawing boxes around different pieces of
the app helps us to think about the
component boundaries and ownership react
has a declarative syntax that it uses in
components called jsx jsx makes it easy
to model the layout of the components
but part of what makes react great is
the virtual Dom the virtual domin react
allows it to detect operations in the
real dumb based on changes to a
component the virtual Dom behavior is a
performance optimization and this is
enough for most applications by most
applications we mean ones that don't
render frequently in a few Dom nodes
such as a page of static content on
Wikipedia but not everything is a static
page on the web
we browse through a list of movies each
one giving us a preview without even
clicking we scroll through photos that
respond to our movements and that
responds to animations we navigate
through menus that reconfigure
themselves based on our choices a highly
interactive application will need much
more than just the virtual Dom to
perform well if we want an application
to be fast we need to only render the
real changes to understand this let's
talk about the limits of reacts
out-of-the-box performance on the
virtual Dom
here is a large list of items to render
if we add an item to that list without
any optimizations react will still call
render 10001 times when it attempts to
apply those changes to the dom it will
actually only add one new item to that
list this is 10,000 wasted renders but
we don't have to do this instead we want
to detect the exact number of changes
and not have wasted renders the amount
of work we do in the virtual Dom should
match what our components render the
number of times react renders should be
the same as the number of things we are
actually changing in our case of a
10,000 items the rear ender would only
draw one new item react uses
immutability to optimize the virtual Dom
we can use the same technique to
optimize our component renders with
proper detection of changes there are no
wasted renders the beauty of
implementing this internal react
optimization for our own components is
that a place to win a javis of Java
scripts particular strengths references
and comparison by reference references
are fast cheap and when used with
comparison are a powerful tool for
performance optimization let's take a
brief look at references in JavaScript
Anna now and Bella are references to the
same person Annabel
references that point to the same thing
are equal
what a reference points to something
else it's not equal references are
important because they give us a way to
check for changes in an immutable object
what do we mean by immutability
immutability is the state of being
unchangeable in the memory after
creation we can think of immutability
the way we think of memories like a
baby's first words a baby will say a lot
of words after the first one but the
first one will always be immutable when
we talk about an object being immutable
we mean that the object and its current
state cannot be changed you get a new
copy of the object with the change you
wanted for the purpose of this talk
we're going to focus on the ability to
detect changes with immutable data
structures what exactly does this mean
clearly a is different from be it has an
extra number how can JavaScript check
that these two arrays are different well
there are different ways to do this one
way is to iterate through every element
of both raise and check that the numbers
are the same another way is to compare
the references to these objects as long
as they're immutable
let's take a look at an example of
immutability in javascript using two
different array methods first we'll use
the method push which modifies the
original array by inserting a new number
into the array we're mutating it pushes
an operation that's mutable it's not
possible to know that the array is
different by comparing the reference
because it's the same as before next
let's look at adding an item to array
with concat this returns a new array
with the number added this is an example
of an operation that's immutable the
original array is not mutated by the
concat operation what's interesting
about this is that we can tell what's
changed because of references but what
gets a reference in this array we know
that the numbers one and two did not
change because they are the same
references three is a new reference so
we know that it has changed also we know
that the array has changed because it's
a new array we encountered never
reference changes between the operation
we can see that the two changes are the
ones that are actually what happens in
the concat remember comparing references
in javascript is fast in fact it's the
fastest way to do change detection we
don't have to loop through each item in
an array to detect changes when a
reference is different we know the
object is different and the object has
changed when the reference is the same
we know that the object has not changed
even though references in JavaScript are
fast and cheap javascript has pretty
poor support for immutable operations
since it was never designed with
immutability in mind most operations in
JavaScript are mutable and it's hard to
tell what operations are actually
causing mutations to the data cursors
can help us using mutability for data
and javascript using references will
need to use immutability to get most of
one-way data flow and react but before
we get too deep into reacts one-way data
flow let's think about what one-way data
flow really is to do this let's think
about a set of component
with his components are trying to render
and the ownership involved take the
check boxes in our to-do app for example
what happens when we check a box who
owns that who is the parent who are the
children the most intuitive way to think
about it is that each checkbox owns its
own state in that case what are the
props of this check box what is its
state because each check box is
responsible for itself there is no need
for props there is only the state of the
check box and whether or not it is
checked what if we want to check all of
the boxes with a new component we need
to be able to change the state of all
the checkboxes but right now they can
only change themselves they have no view
into what is happening with the other
check boxes to add the ability to check
all boxes at once we need to move this
responsibility to a parent component we
are saying that the parent component
owns the state of all checkboxes since
the parent owns the state of all
checkboxes each checkbox state is passed
to the component it corresponds to as
props now the parent can tell each
checkbox what to do instead the child
has no control the child can only render
the props the parent passes down to it
but each checkbox still needs to change
when you click it how do we do this if
the state does not live in the check box
the parent passes a function down to the
child which can be called when the check
box is toggled this function is
effectively an intention the parent is
giving to the child this function can be
used to apply the attention at the right
time that is it can be used to
check the checkbox when the child is
clicked one-way data flow is about
having all of the state at the top of
your application and the intentions pass
down to your components this is the
pattern that emerges this is the one-way
data flow flowing downward from parent
to child this is what we want instead of
passing props and intentions to children
however we prefer to package them
together cursors are the mechanism for
packaging props and intentions
kersh's have been recently popularized
by the closure closure ship framework
ohm they assist with traversing an
object and updating data structure
that's immutable which is normally
difficult in JavaScript we're going to
discuss a simplified cursor for this
talk the cursors we're going to talk
about today have two concepts the first
part of cursor is the data that it
points to the second part of the cursor
describes what happens when you want to
update it the cursor points to a data
structure and gives you access to the
different parts of that data structure
the cursor also allows you to update
that data structure certain immutable
operations like push set merge and
splice could be used for example we're
going to focus on push
notice in this example we're
constructing a cursor not only with an
array but with a callback the callback
will be important in just a minute in
this example push is called on the
cursor it doesn't change the original
data but creates a new cursor and a new
copy of that original data with the
change applied
this is where the call back in a cursor
is used the call back of the cursor is
called with the new copy of the data the
callback is then used to update the
state of the application by combining
our change to the data with a callback
the cursor allows us to package up data
flow and react
whenever the underlying data structure
is changed by a cursor whenever the
cursors are updated the rear end during
cycle is initiated through the callback
and all of the components in the react
application redraw each change
represents a single drawing cycle each
drawing cycle is a state
this is the same square we've been
talking about all along pure functions
pure render at any given point we can
inspect the state of the application the
same props as input renders into the
same HTML but this is one square this
function is a single moment and time our
application state plays out over time
and state after state after state a
single state always corresponds to a
single drawing cycle this gives us the
ability to replay the history of an
application over time the application is
completely predictable which means it's
easier for us to understand what is
happening at any given time this is the
power you get from cursors and how they
can help you implement reacts one-way
data flow and pure render why don't more
web apps today use cursors one-way data
flow and pure render immutability isn't
built into JavaScript so it's not
something that anyone who's familiar
with JavaScript will automatically be
reaching for but javascript is in the
browser and it is the language of the
web if we plan to journey with our web
apps into a place that goes well beyond
pages and static content we will need to
reshape our own thinking about how we
build our apps and how we use javascript
today we've shown you drawing how
drawing and sketching with others is a
way to shape your own thinking around
complicated topics with many layers
immutability and pure render and react
can be approachable if we draw them
together
it took time for us to understand
cursors and their benefits what you've
seen in this talk is the two of us
building up a shared understanding
between us about what cursors are and
why we should use them we did this
through writing code and drawing
collaborative sketching is what brought
this talk together we hope you've
enjoyed drawing with us and that the
next time you're trying to understand
something with your teammates you'll
give drawing a try thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>