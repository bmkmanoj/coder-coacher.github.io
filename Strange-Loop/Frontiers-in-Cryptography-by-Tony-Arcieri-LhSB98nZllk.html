<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Frontiers in Cryptography&quot; by Tony Arcieri | Coder Coacher - Coaching Coders</title><meta content="&quot;Frontiers in Cryptography&quot; by Tony Arcieri - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Frontiers in Cryptography&quot; by Tony Arcieri</b></h2><h5 class="post__date">2016-09-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LhSB98nZllk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone I'm Tony RCA thank you for
coming
this is frontiers and cryptography so
today's talk is kind of two talks in one
I'm going to start out by talking about
the past I think one of the best ways to
see into the future is by looking into
the past and then I'm gonna talk
explicitly about the future with kind of
the theme around searching and computing
on encrypted data on ciphertext it's a
quick disclaimer I'm not a cryptographer
I prefer to self-identify as a cyberpunk
where you think I put post cyberpunk in
my bio so I'm going to ask you to hold
your questions until the end both for
the sake of time and because it's quite
likely I won't actually know the answer
so let's start out by looking into the
past
so how many people came to you strange
loop last year in South wobblers talk
propositions as types I'm kind of
borrowing from his theme there if you
didn't see it it was a great talk I
recommend watching it online so to start
out with I'm gonna ask this question how
it aliens encrypt and kind of this idea
is are the cryptographic constructions
we use today invented or discovered are
they things that aliens a completely
different planet would independently
rediscover themselves so what do I mean
by that well I don't necessarily mean
that they're using the exact same
ciphers we are some cryptography is more
invented than discovered to be certain
but there are certain algorithms I think
aliens would independently rediscover
completely on their own so one of these
algorithms is diffie-hellman it's Martin
Holman and with Diffie there and oh wait
who's this guy okay so that's Ralph
Merkle somehow he always gets cropped
out of this photo he was actually the
first person in the public community to
come up with a public key cryptography
algorithm it was called puzzles
and that kind of inspire the ideas of
Diffie and Hellman to develop the stuffy
Hellman algorithm so this is a
public-key algorithm for doing key
exchange the other one which you might
be a little more familiar with is the
RSA algorithm so here are the three
cryptographers invented that so here we
have this sort of textbook history of
public key cryptography that these two
trifectas of cryptographers came up with
these algorithms the only problem is
that isn't actually true
neither of these algorithms were
originally discovered by their eponymous
cryptographers so actually they were
first discovered at GCHQ which is kind
of the British equivalent of the NSA so
this guy James each Alice had been
working on this problem for a long time
originally came out of during World War
2 they wanted to build identify
friend-or-foe systems for things like
aircraft so they wanted a way to be able
to verify a signature effectively is we
would call it today without holding a
secret key that would let you sort of
generate these identify Friend or Foe
proofs he came up with the existence
proof for public key cryptography he
described a incredibly impractical
system for doing public key cryptography
but he proved it as possible and these
other two cryptographers Clifford Cox
and Malcolm Williamson sort of
independently came up with the
algorithms we never as diffie-hellman
and RSA before diffie-hellman and RSA so
these are kind of strange and spooky
problems they have the spooky connection
through this thing called the hidden
subgroup problem so they're sort of like
two sides of the same coin so RSA is but
based on the difficulty of factoring
numbers diffie-hellman is based on
something called the discrete logarithm
problem and they share these group
homomorphism
to where if you solve one problem you
solved them but if one of the best-known
algorithms for doing first solving
factoring something called Pollard's Rho
algorithm so you originally created it
to solve factoring but then a few years
later he made a very similar algorithm
that solves the discrete logarithm
problem another interesting one so
elliptic curves are kind of the best
modern way to do public key cryptography
right now this other cryptography
Lenstra came up with a way to use
elliptic curves to factor numbers and it
remains still one of the best way is to
do factoring a little bit later Shor's
algorithm provided a way to factor
numbers on quantum computers and almost
disastrous way fortunately we haven't
built large quantum computers yet so
maybe you're thinking okay Tony that's
great
public key cryptography is based on math
but what about symmetric encryption
right that's just a bunch of bit
twiddling right certainly aliens when
come up with the same symmetric
encryption ciphers thought we did here
on earth but actually I think maybe
there are some fundamental components of
symmetric encryption they may
independently rediscover on an alien
world so this is something called a
feistel network it's based on an earlier
idea from Claude Shannon's where it
called a product cipher and it's a way
of turning a pseudo-random function so
there's FS there so a pseudo-random
function takes some input and it
produces a mangled output that in theory
you can't reverse back into the original
ciphertext or the original plaintext so
this takes those pseudo-random functions
and builds a network out of them such
that we get something called a
pseudo-random permutation and that lets
you take a piece of plaintext turn it
into ciphertext and then turn it back
again into these same plain texts so
feistel networks for the basis of
ciphers such as the data encryption
standard or des
so in conclusion I think cryptography
may actually be more discovered than
invented in a lot of cases I think there
are ciphers we're making here on earth
aliens would independently rediscovered
on a million worlds
all right on to the future which is
probably the part you came here to see
you
so typically will have a client and a
server and we'll we may have this
encrypted pipe you definitely should
have one of these today that'll prevent
any sort of attackers out there on the
internet from recovering your plaintext
what we like to do is send that
plaintext over to the server and then
the server can provide us all these cool
services we can search things soever can
organize them for you you can perform
analysis and that's all great and then
when the server is done it's gonna give
you a plaintext results again over that
TOS channel there I'm just gonna admit
this for the rest of the slides just
kind of assume that's there then
something that I think a lot of people
would like to switch to is typically
called end to end encryption and this is
where a key is held by the client and
then the client encrypts client-side we
send the ciphertext over to the server
the problem is there are all these
things we want to do and typically we
just can't do any of those to you
ciphertext so it would really be nice is
to have a special type of ciphertext
that exposes some of the properties or
some of the structure of the original
plaintext while still keeping the data
confidential so that we could send that
over to the server perform some of these
operations and either get back a result
that is plaintext or potentially get
back a ciphertext result so word of
caution before I proceed this is sort of
science experiment stage it's
cutting-edge cryptography and generally
a lot of the systems people have tried
to build this way have been broke and so
the main problem we run into is this
idea of indistinguishability so I'm
going to give a little your typical
adversary model diagram here so the part
of the cartoon double here will be
played by former NSA director general
Keith Alexander so typically what we
want is this property called
indistinguishability so this is in
cryptography typically phrased as
something called a semantic security
game and the idea is attacker who can
potentially even provide the plaintext
in this case so let's say keith
alexander here is giving our encryption
oracle plaintext a and b the idea is if
we have a indistinguishable cipher that
keith there cannot tell with greater
than chance accuracy which of the cipher
text was produced from the complaint ox
even if he's in control of them so there
have been a lot of actual production
systems people have tried to build using
these techniques here's a list of some
of them and the problem is they keep
getting broken over and over so it might
be using the word broken of it literally
the creators of some of these systems
would argue that they're just fine and
that the people pulling off these
attacks were doing things that were out
of the scope of what they said they're
allowed to do but I'm kind of a realist
I think people are gonna miss apply
cryptography all the time so I kind of
just prefer things be nice and solid you
may have seen this article so the
researchers who produced these systems
kind of play these cat-and-mouse games
with each other where they keep breaking
each other's systems and there are some
particularly fun ones with trip DB where
they were able to break it with
frequency and all
so your word of caution if you want to
run out and play with this stuff please
cancel a cryptographer before you try to
so I'd like to give an example of the
type of system it would be interesting
to build with us with these sort of
techniques so it's a encrypted email
service you can imagine something like
Gmail where we don't want to store all
of the messages like your entire email
history on your smart phone we want the
server to be able to hang on to these
things but still provide services like
ordering so we only want to see the
latest messages unless we're going back
in history we want to be able to do
full-text search we want server-side
spam detection so the server could
decide whether or not something is spam
without having to send it to the client
first and we want to be able to filter
and prioritize emails so the first type
of technique I'm going to talk about as
property preserving encryption so there
are many different types of property
preserving encryption there's another
type I'm not going to talk about called
format preserving encryption but the
main useful one I think for these sort
of encrypted search cases is order
preserving encryption now the original
conception of order preserving
encryption brokens
you don't want to use that the more
interesting one is this thing called
order of viewing encryption which came
out of a damn Benes group at Stanford
and the idea of this is we create
ciphertext in such a way that there is a
public function we can hand Andy to
ciphertext - it will kind of give us
some sort of locks of graphic order now
the interesting thing about the way they
formulated order revealing encryption is
there is no way to tell if two cipher
texts are encryptions of the same
plaintext so this kind of holds up holds
that indistinguishability or semantic
security property that I was originally
talking about was desirable and also
lets us do things like a range queries
so we can create an encrypted range and
the
and query the cipher talks across on it
really quick here is the paper so this
is the latest order reviewing encryption
paper if you're interested in learning
more I recommend checking that out so
the next thing I'm going to go into is
actually amalgamation of several
techniques which I'm going to cover
later but it should give you a general
idea of what this will provide so we
wanted we want a full-text search on
encrypted documents so this is a bit
tricky there have been many attempts to
implementing lists that have been
shipped to production or the basis of
startups and actually completely broken
so to start off with I'm going to show
you one technique to do this which is
broken this is kind of the naive method
that people might come up with it just
trying to assemble a system like this
from existing cryptographic primitives
so what we're gonna do is a client is
going to encrypt a document and at the
same time also build in inverted search
in Docs that can be updated server-side
so the way they're gonna do that is
they're going to take every single word
in this document encrypt the word
deterministically so that each word
always results in the same cipher text
and then we're going to encrypt the
document as well using algorithm I guess
or something like that and put it in
this document store and then the server
is going to retain this inverted index
of which deterministically encrypted
words map to which documents so the
thing about this is let's say Oh Keith
up there again and keith is able to if
this is an email system he's able to
send this email so keith can send us
some sort of email that contains some
word that he's curious about and then
when the when the encrypted version gets
sent back over to the server uh since
he's the NSA any completely on the
server he's able to look at
how the index changes in response to the
messages I sent and using techniques
similar to this it's possible to
completely break such systems
so in summary here the basic idea is
building this index of a of these tokens
to the documents they point to and then
they're broken because we lose this
property of indistinguishability so you
build secure a searchable symmetric
encryption or going to need more tools
so one of these is called oblivious RAM
or a ram and the idea of this is instead
of keith being able to observe this
incoming cipher tox and correlate which
ones come in based on the message he
sent we mask the data access patterns to
look completely random so yeah as I said
this can be a basis for higher level
primitives including searchable
symmetric encryption but the problem is
by doing all these spurious data
accesses we're going to lose some
performance so next I'm going to talk
about functional encryption so this is
going to use something called lattices
so perhaps you've heard of lattices in
distributed systems for implementing
things like factor clocks or CRT T's and
you're thinking it's a lattice I know
this but unfortunately this is not the
same type of lattice you're thinking of
to make things especially confusing both
of these lattices come out of abstract
algebra so they come out of different
sub disciplines the ones I'm talking
about come out of group theory so yeah
I'm not even gonna attempt to explain
what lattices allow us to implement is
something called functional encryption
so with functional encryption what we
can do is the server could provide a
spam score function and then the client
can actually encrypt
function so it works on cypher talks and
then hand nod over to the server so in
this way the server can then apply that
function to cypher talks get this spam
score out and therefore decide whether
or not an email is spam so there's a
subset of functional encryption called
homomorphic encryption and the idea here
is we have certain operations we can
perform on the plain tox and then there
are corresponding ones that are a direct
mapping of the operations on the plain
text that apply to the cipher text so
there are two sort of families of
homomorphic encryption
it's called partially homomorphic so the
idea here is there are certain subsets
of operations where this homomorphic
property holds so we may be able to add
two cipher texts together and get a
cipher text which is the encryption of
the results of that addition and then
there's also the holy grail of
homomorphic encryption which is
arbitrary arbitrary computation on
ciphertext so effectively
turing-complete functions so before I
get you too excited about this there
there is a huge drawback to fully
homomorphic encryption and that is that
is not very fast this is a quote from
Dan Bernstein he he designed all the
ciphers that we were just about to start
using in TLS so I've kind of taken this
quote out of context but I think it gets
the idea across so some of the big
papers on homomorphic encryption this is
the bgv paper so this was one of the
first examples of a homomorphic fully
homomorphic encryption system that is
approaching practicality so I don't have
exact numbers for this but I think it's
close to a million times slower than the
equivalent computation on
without homomorphic encryption right
this is another interesting paper so
they describe this technique they call
in the indistinguishability office
keishon so it's a way to take algebraic
circuits and effectively of the obvious
gate them such that two office kitchens
of the same circuit are
indistinguishable so you could not tell
whether or not the same circuit was
encrypted twice and this can be used to
implement both functional encryption and
fully homomorphic encryption any more
interesting library and that this is one
you can go download and play around with
is called seal so this comes out of
Microsoft Research so this is this I
don't believe this library is fully
homomorphic but it provides a way to do
all sorts of algebraic operations on
cipher talks and then Microsoft Research
took some of those ideas and created
this cool thing called crypto Nats so
this is a machine learning platform
based on neural networks that was
designed to operate on ciphertext so
this is probably a more practical
example of what a fully homomorphic
encryption could allow you to do so I
think in this case it was like they were
trying to move a healthcare system into
the cloud and due to HIPAA and things
like that
operating on patient data on computers
you don't control would not be HIPAA
compliant so they built the system that
allows you or allows a machine learning
system to make predictions about
patients based on their encrypted
healthcare history so since a fully
homomorphic encryption is slow the
people have been looking at other ways
to do this so one of the things we can
do is instead of using all this fancy
math we can use trusted hardware
instead so there are a couple of
upcoming implementations of this that
are pretty interesting so there Intel
created a system called SG ox AMD is
made a completely incompatible system
called se V intellisense ships SGX on
skylake s SE v is not yet shipped but
the idea of this is you can run a
program inside of an encrypted region
and main memory
so typically main memory has been like
wide open to all sorts of things
hardware can do DMA for example so the
idea of this is they want to reduce the
trusted footprint of hardware such that
the only piece you have to trust is
actually the CPU so you don't have to
trust the RAM you don't have to trust
any of your hardware that can do DMA all
you have to trust is the CPU and the
thing is really when it comes down to it
you always have to trust the CPU if
you're running a secure program on a
Poisson CPU you wait game over you
already lost so I think this is an
interesting technique a lot of the ways
Intel is implemented have raised some
criticisms so what Intel is doing right
now is requiring Intel sign off on every
single program that you want to run
under Astrix so there's some good
reasons for doing that
you know without it people could create
encrypted malware and things like that
so you know this as much potential as
this has to help the good guys I think
you know as just as much malicious
potential but at the same time you know
I think a lot of the use cases where
people would like to use it they don't
necessarily want to hand every single
program they ever intend to run over to
Intel first maybe they just want to keep
their programs confidential maybe they
kind of look at Intel as a bad guy even
though
they want to use the feature but either
way you know I think it's a I I I
wouldn't actually recommend starting to
use SGX quite yet
I'd give it a little more time to settle
down but one of the interesting features
it has is an attestation protocol and
the idea of this is when you hand your
program over to the CPU the CPU has a
key with which it can sign the
effectively the results coming back from
this program so by doing that as you're
talking to this program let's say over
the internet and you want to make sure
the CPUs actually running the program
you gave it it has this protocol that
allows it to tell you that it is
actually running the program you
intended it to so the main sort of
interesting practical application i've
seen done with this is this thing called
microsoft vc3 so vc3 is a implementation
of hadoop mapreduce that works on
encrypted data is stored in HDFS so I
think I absolutely love about this is I
hate Hadoop security so if any of you
have ever tried to deal with a deep
security it's a nightmare
offers a ton of features for doing
security it has its own sort of
transparent encryption feature it has
kerberized access control but it's so
complicated and so difficult to
understand that's very difficult to
deploy
securely correctly so a VC 3 does is it
reduces the trusted footprint of Hadoop
down to the actual MapReduce operations
themselves so for the most part you
don't really have to care about most of
the security aspects of the Joop it's
going to MapReduce your data
pull it into one of these encrypted
enclaves
decrypted their perform the MapReduce
operation and then encrypt the results
and then put that back in your HDFS so
as far as I know this is yet another
sort of science experiment I don't think
they're actually shipping this but it
seemed interesting to me so last I
wanted to talk about something
completely different at the beginning I
had mentioned Shor's algorithm and how
it can be used by quantum computers to
solve some of these problems so Shor's
algorithm is one of these that
illustrates a group homomorphism between
factoring and the discrete logarithm
problem and by using this since these
problems share this homomorphism like we
we've completely lost at this point
using this one algorithm quantum
computers can break all of the public
key cryptography we use today so the
thing about Shor's algorithm is it
requires much larger quantum computers
than we have built right now for the
most part the quantum computers we have
both are very small and do not seem to
be outpacing their classical
counterparts so you may have seen the
d-wave machines which are not full
quantum computers they're what's known
as an annealing machine and they have
generally been losing out to simulations
of quantum annealing running on
classical computers but the thing is
there are a lot of practical
applications of quantum computing that
are starting to drive the development of
quantum computers and I don't think
that's necessarily cryptography so
someone like the NSA would probably love
to have a giant quantum computer but I
really doubt the adult one yet but
beyond that beyond these large
government organizations that are
interested in wide scale breaking I
don't think quantum error I don't think
cryptography is really going to drive
development of quantum computers but
there are other fields where I think
they could really be helpful things like
chemistry and biology and running
simulations of those so I think these
other fields are actually going to drive
the development of quantum computers and
as soon as we reach it's going to be the
thousands of qubits right now depending
on who you ask we're at about four there
may be slightly larger ones but to break
ECC key it's close to 2,000 cubits to
break something like an RSA key that's
2048 bits it's gonna be about 4096
qubits so we're still nowhere close to
actually building quantum computers
large enough to solve these problems
but as soon as we do we can solve all of
these classical problems that we have
used to build public key cryptography
systems just as the ballpark number
different people say different things it
seems like at least a decade is a fairly
reasonable estimate of the minimum
amount of time before we'll see a
quantum computer big enough to actually
run these algorithms on the kind of
public key algorithms we're using today
so there are a number of different
candidates for replacing algorithms like
RSA ECC diffie-hellman with algorithms
that cannot be solved by a quantum
computer so the most promising now just
in terms of their various trade-offs
like how big are the keys how long does
it take to compute so lattices as I
mentioned earlier generally seem to be
the way things are heading different
people of different opinions on this
but the main algorithm that seems to be
the most popular now is this one called
the ring learning with errors problem so
the same problem learning with errors
problem is also used to implement fully
homomorphic encryption but this is the
main algorithm that people seem to be
talking about and implementing there's
another one called n true the only
problem with it is it's patented but
otherwise it's actually faster than what
the curve cryptography we use today
another approach to this is called a
sahjhan ease so there's this system
called super super singular I saw Janine
diffie-hellman which takes elliptic
curve cryptography applies I sadja needs
to do this and produces a post quantum
version of effectively elliptic curve
diffie-hellman exchange and then the
last one I mentioned Dan Bernstein
earlier so he's been doing a lot of work
on post Quon cryptography as well it's
based on linear codes so the algorithms
called McAleese and and Bernstein's
version of it is called Macbeth's but
the most interesting thing I think is
this is actually shipping in chrome now
so if you pull up your chrome inspector
and go look at the actual algorithm
being used to exchange keys and tell us
they have added a post quantum algorithm
so this is a new hope I was talking
about earlier so they built a hybrid pre
quantum post quantum key exchange
algorithm that is based on new hope and
elliptic curve tradition elliptic curve
diffie-hellman so you may start seeing
this in your browser today so that's it
I hope which you take away from this is
that I think cryptography is going to
become increasingly important and
database developments I think we're
going to start
more of these databases so for example
Google has published an encrypted
MapReduce client that's using partially
homomorphic encryption microsoft has
shipped similar features in sequel
server based on their research in cipher
base so I think in the coming years we
are going to see databases that are
operating routinely on cypher talks and
I think this is going to be the future
of databases all right thanks
alright go ahead and take any questions
oh yes
yes so this is all the question was how
do we transition from pre quantum to
post quantum cryptography so the nice
thing is this is already built into TLS
so TLS supports this idea where the
client will send over it's supported
algorithms go hey I support all these
and then the server can pick one they
mutually agree on so you just if both
sides support a post quantum algorithm
the client just advertises that the
server picks it you have to prioritize
it but that just you kind of get that
for free with TLS which is pretty cool
and actually that was the Google example
it's actually using a different
transport encryption algorithm called
quick which was developed in-house by
Google they're trying to standardize it
but it supports the same sort of thing
so yeah
yeah so the question was their first
quantum algorithms into your provably
secure so the answer is no a lot of them
seem kind of shaky which is why people
are somewhat hesitant to ship them today
especially if there isn't a pre quantum
backup so what they're doing today is
kind of hedging their bets in terms of
will use a pre quantum algorithm and
then in parallel or on the post quantum
one so both of these algorithms do key
exchange so you can kind of do pre
quantum and post quantum key exchange
side-by-side and then you feed the
results of both of those into something
called the key derivation function and
so you get effectively the security of
both it will be at least as secure as
the strongest of the two any other
questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>