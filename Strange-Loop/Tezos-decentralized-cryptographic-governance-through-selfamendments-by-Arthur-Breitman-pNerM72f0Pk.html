<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Tezos, decentralized cryptographic governance through self-amendments&quot; by Arthur Breitman | Coder Coacher - Coaching Coders</title><meta content="&quot;Tezos, decentralized cryptographic governance through self-amendments&quot; by Arthur Breitman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Tezos, decentralized cryptographic governance through self-amendments&quot; by Arthur Breitman</b></h2><h5 class="post__date">2016-09-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pNerM72f0Pk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone thank you for coming this is
a talk about Tasers the self amending
cryptographic Ledger before I even get
started
Clare just get it Henry's in the
audience how many people you have heard
or even played a little bit with Bitcoin
okay most people how about a cerium
alright okay a trickier one how many of
you have heard of reentrant seed bugs in
the cerium language alright great
awesome okay so I have to go a little
fast because it's to give this talk I
have to give you basically three talks
and even though I have four bullet
points here it's really three talks
mostly we're going to talk about the
concept of the blockchain what is the
concept of an abstract blockchain we
talk about the paradox of self
amendments and how that relates to
governance some considerations in the
design of smart contracts languages and
little bits I'll talk about defensive
programming you know camel so what's the
blockchain
it's a concurrent data structure
representing a shared mutable segment
right people say blocks are immutable
what they mean is that the record is
immutable but the operations on the
blockchain actually change it and the
way we represent it is through a linked
list of blocks of operations briefly
speaking we have there's two kind of
data structure in the world immutable
and mutable the immutable data structure
our saloon sometimes has a pin only so a
single immutable value is trivial
example simply linked list you'll just
add more elements to your list
trees and some typically aren't like
double linked lists you need to be able
to modify a pointer in already existing
value in order to do that so how do we
do we represent a immutable data
structure with immutable data structure
well we have a simple trick and this is
it
so you have the value which was your and
you want to represent it we replace it
with your so what you do is that instead
of changing it
you just a pin something to what you say
okay this is actually the new value but
you're still in the mutation because you
need to keep track of the head of your
list and in fact once you get into a
concurrent environments this is what
happens and now what so you know you had
your and you had multiple possible
mutation which one is the right one
which was it is a canonical one
okay so how does that relate to
blockchain well a blockchain in the
essence is a magnetic representation of
a mutable state through a series of
operations so for example for Bitcoin we
have a state which is a set of unspent
outputs the UTX owes an operation
witcher's and that transactions so when
I transact with you on Bitcoin I'm
saying you know I could spend this bit
of Bitcoin and now you can spend it
instead of me so this is how we change
the state and generally speaking any
blockchain is going to have a function
apply which takes the state takes an
operation and give you a new state and
if the person is bad it might be an
invalid state but it's still a state
right okay but in general a blockchain
is not a chain it's a tree right you can
have a people can add block wherever
they want and so how do we pick a
canonical leaf on this tree well the
most general way to do that would be to
have a well ordering over branches you
would have a function that would just
look at two branches and then would say
well this branch is better than these
other branch but that's inefficient
because you have to look at the entire
tree in order to do that and you'll
necessarily know the entire tree so what
we do in tezo's and in general in this
talk we're going to simplify this a
little bit and we're going to require
something a little stronger we want to
want a fitness function which goes from
the states and gives you a fitness score
ah which is going to be an integer so
for example I'm going to you get one
leaf and I'm going to ask to this leaf
what is your score and I'm going to ask
that to another leaf and I'm just going
to pick this whichever leaf has a
highest score okay so all existing
blocks and implementations Bitcoin
cerium zero cash you take whatever you
want
they all can be subsumed by one by
despair apply Texas State X in operation
use your new state and fitness take the
states and gives you a score so how do
we actually implement fitness well in
Bitcoin and the first boxing that's the
total difficulty of the branch you look
at a branch you look how much hashing
power has gone in the creation of that
branch and that is your difficulty some
people say the length of the other
branch but that's actually is a
difficulty of the branch if you had a
centralized model you could say well
it's a presence of a trusted third party
signature if I have this signature in
the branch then that's the right wrench
and I trust the third party to only sign
one
and in proof of state systems it's a
little trickier but essentially you have
a set of rules that are going to assign
signature rights to some people and you
can validate and count those signatures
and that can give you your score and
there are many many other models which
you can use to actually pick a branch so
where do we get statefulness because
when we're dealing with mathematical
abstractions when we're dealing with
these concepts there's no set we need to
untangle that with a real world right
now anyone can say anything so how is
there one consensus that actually
corresponds to the world how do we
untangle it with zero of time and so in
Bitcoin the answer is heat right so when
you mining Bitcoin you actually have
mining rigs and you're spending energy
which is costly and they're dissipating
heat and this is fundamental because if
you want to have something that's going
to be irreversible you need to have some
dissipative process happening in a
physical world because if you don't then
you're not going to have a tie to the
physical world only there will be all of
these possible variants and no one is
going to be canonical in the centralized
model
well the statefulness is hard cooling
Authority basically is a way that you
think you pick a fixed reference point
in the world is you say that person or
this group of people is going to be
signing the chain you know which are
those people specifically and that's how
you get the states you pinpoint it down
in some particular place of the world
and in proof of stake you get something
like social or economic activity and
basically you're trying to bootstrap
your reference points based on the
social and economic activity that arises
around the block chain itself so when we
design a blocking protocol there's
really three layers that we care about
there's a network layer and the network
layer is essentially the gauzy protocol
it's how participants in the protocol
learn about blocks they learn about
transactions they know what's up
there's a consensus layer which is okay
we know the blocks we know the
operations but which branch is canonical
and the transaction layer which is okay
we have these operations what do they
actually mean what do they do to the
state and the network layer is not very
controversial right if you want to
innovate in this layer if you say I have
a better way of sending out information
you can do that you can go ahead and do
that and if it's a great way people are
going to follow it and you can be
completely interoperable with everyone
else so network clear there's a ton of
interesting innovation to do it but it's
not very problematic now the consensus
layer in transaction layer are a little
trickier especially since if you want to
have the centralization the trick is
that you're entangling to industry right
in Bitcoin for example the way you get
consensus is because the miners are
actually receiving coins out of the
coinbase transaction when they create a
block so you have a mix between the
second layer and a third layer and
there's always going to be some form of
economic incentives in a decentralized
model for participants to actually
follow the consensus and so okay so we
have this production but who exactly
controls it because we don't you know if
there's no state if we don't have a
centralized party that actually tells us
with the blockchain does you know who
who's who's really in charge and one
answer is that it's the algorithm and in
2014 you talk to people in the Bitcoin
community and that was a very popular
answer you would say okay but who's in
charge of Bitcoin and since no one it's
mass it's purely mass you only have to
chart the mass and that's not quite true
because well we have miners as well so
if the miners in Bitcoin all of a sudden
decides it wants to buy in a certain
different version of Bitcoin
well then mostly most likely you know
you can use the old version but most
likely people are going to follow suit
because maybe that ranch is more secure
even though it's different so maybe the
miners are in charge but in fact the
miners are not really in charge because
the miners are going to mine the branch
they expect other miners to mine and
they don't they don't necessarily
coordinate that well so are the core
developers in charge because the core
developers tell us well this is a
protocol this is the official protocol
this is what you should be following
well not necessarily because maybe the
core developers disagree maybe they
don't convince everyone to switch so is
it the stakeholders the people who hold
the coin and it's really there's no
clear define answer because there's no
governance so the consensus that you end
up having is the consensus that matters
is actually a social consensus it's a
shelling point this idea of saying you
know what is this blockchain to me what
the canonical version of it is to me is
what I expect other people are going to
find the canonical version to be a brief
explanation on what selling point are so
let's say you need to meet someone in
Paris
and you know you Bustos a day but you
didn't set a time in place right you
forgot to do that and so you want to
meet them where and where would you meet
anyone at felt hour at noon awesome you
win under the FL tower at noon that
right in other excellent series train
stations they work in most cities but
Paris has many train stations so it's
not obvious all right so most political
power today and most power in general is
held through games here recall
equilibrium they're held through
shelling points so here's an example we
went from you know this Viking you know
Viking ship to kim jongwan and the big
difference is that the Viking ship
actually holds power because he is very
very strong and even though he still
needs to have a lot but he's very strong
maybe he can beat up everyone in in the
Viking tribe now kim jungeun probably
cannot beat up anyone however so why is
he why is he more scary than the Viking
guy well he's more scary because he has
a huge army and he has guards and if one
of the guards try to attack him the
other guards will attack him because
they all know that if they don't attack
back then they too will be traitors and
in the end he doesn't have the power is
not interesting to him the power is in
what he represents the power is where he
sits in the game it's theoretical
equilibrium ok so what does the people
have in common
so we have here good ol we have doubles
Hofstadter and we have pure super and
the US Constitution so what's the common
thread well we have good ol who became a
US citizen and when he became a US
citizen he was convinced he found a flaw
in the US Constitution and he really
really wanted to bring it to the
attention of the people holding ceremony
to swear him in and he was convinced not
to and the flaw probably had to do with
some of these self Amendment's property
of the Constitution where you could take
the Constitution and make amendments
that would turn it into dictatorship
Peter Suber is a philosopher is now
known mostly for his work on open access
to academic publications but he also
wrote a book called the paradox of self
amendments and a game named Nam ik and
the game na Mike was published by
Douglas Hofstadter who's known for
coining the term strange loop so what is
Nam ik well nah Mike is a game in the
words of Peter Suber not make is a game
in which changing the role is a move in
that respect it differs from almost
every other game the primary activity of
anomic is proposing changes in the rules
debating the wisdom of changing them in
that way voting on the changes deciding
what can and cannot be done afterwards
and doing it and even this core is a
game of course can be changed so why
does it call that the paradox of self
amendments well it's a so-called
vertical paradox where the paradox is
actually true and I don't personally
finding it very paradoxical but the idea
is you have a set of rule that says that
you can change it can you change it in a
way that says that you can't change it
anymore
when the answer is yes so you can have
fully introspective set of rules that
can look upon themselves and change
themselves so what does it have to do
with the blockchain well I wanted to
create a self amending blockchain but
how do we do that well the first thing
we do is that we're going to take this
apply and fitness function because
remember applying and fitness really
define what a blockchain is all about
and we're going to take them and fold
them inside the state then we're going
to have operations which can change
apply in Fitness and remember these
operations are going to be inside the
apply function the apply function is
going to see an operation that changes
itself and now we're going to let also
apply introspect into the protocol so
apply is going to be given a new version
of the protocol he's going to look into
it and it's going to decide if it's a
valid change of protocol or not and what
we actually get out of this is a genuine
change loop so why do we want to do this
well we want to do this for governance
because what we were discussing earlier
is you know who controls abduction and
to a large extent controlling the
blockchain mean being able to change
apply in fitness so who can change apply
and fitness well in this version the
person who can control apply in fitness
you could start with something like a
simple votes you could have people say
we're going to vote on a new protocol
and then we'll have the protocol tally
the votes and the protocol which
receives the most votes or if a protocol
is selected by a supermajority we'll
just have that protocol and hot-swap the
protocol right so this is not a case of
having people vote and then someone just
simply implement a change and sends a
patch it happens on the fly but we can
do better than that when we can vote on
the rules we can vote on different rules
as well and so instead of voting
directly we could say you know what
maybe we can have representative
democracy will elect interested parties
to make decisions and you know maybe if
we don't believe in that we can have
liquid democracy well we'll be able to
change our representants easily you
could instant shit several competing
bodies you could have a nice thing
that's the most interesting part
something like constitutionalism so the
ID would be let's say we have a property
that we really care about
for example we never want more than a
billion token on this blockchain well we
could do is say okay
every new protocol must come with a
formal proof that it preserves the
property we care about and also that it
preserves the amendment right and if we
do that well okay we're going to need
proof checker inside the protocol but we
have good proof checkers and we're going
to need a proof but the proof doesn't
have to be that complicated if you write
the code in a way that where you have a
bottleneck and in that bottleneck you
will forge the property you want writing
improve doesn't have to be necessarily
bad so you can have a blockchain it
doesn't have to go into any crazy
direction because a lot of anomic games
you know go like this it can actually be
fairly conservative and very restricted
in the design decision it makes
searching we can do a few jerky
instead of we know we can say instead of
voting we'll just run prediction markets
see where to see what proposal looks
best and we'll just pick that based on
the betting odds okay why do we want to
have governance you know why not just
keep the blockchain the way it is well
the first thing is that explicit
governance is like having rule of law
right there's always going to be people
who are going to want to change a
protocol and if they don't have a venue
to change a protocol it's always going
to be a question of whether or not
they're being legitimate if you force a
specific venue for having these changes
then the gtb/c is going to be granted by
a known process instead of just yelling
loudly so there was a Bitcoin block size
debate over the past year where some
poor some people wanted to have bigger
Bitcoin block sizes and have more
transaction on the blockchain and other
people say no no this hurts
decentralization and the problem is as
debates you know I don't even have a
strong view on the debates
well why maybe you is mostly that this
should not happen like this it should
not just be who is going to be the most
influential and who yells the loudest
and another example we had recently was
a cerium Hart fork a serum Hart to Hart
fork there
is a heist a smart contract at the bug
someone use the bug to get fifty million
dollars and then a serum say oh no
mulligans we'll just pretend it didn't
happen we'll just like roll it back and
the problem isn't so much that it is is
the problem is that it was done
completely behind closed doors without
involvement in the community without any
process and so it felt completely
arbitrary what matters isn't so much the
rule as a predictability of the rules we
can also reward innovation so right now
if you have some cool ideas in doctrine
space most people they're just crazy our
own blockchain and it creates a
completely fragmented market but what we
would like to do is incentive eyes
collaboration instead of competition and
so one way to do that is to say okay I
have this idea for an improvement so I
write a new version of the protocol and
I'll submit it I'll say ok here's my
amendment let's have this new protocol
instead and as part of the protocol you
can say hey this is a new protocol and
by the way I'm going to create new
tokens and assign them to myself and
then people say ok well you know maybe
we'll vote for that you know it dilutes
it's a little bit but it's it's it's
great for the chain and of course you
could try to vote to vote for a copy
which doesn't have this issuance of new
tokens but if they do that it's a
repeated game they would just physically
shoot themselves in the foot they would
be sending the signal that there's no
point in innovating and you can solve
collective action problem and I think
that's really interesting maintaining
and building infrastructure for the
blockchain evangelizing for it in
general when people look at blockchain a
lot of people have looked at them as you
know the new database and they're really
not data bases they're not about data
they're about coordination and I think
that's what they are their coordination
technology one result I really like in
game theory is a result about super Nash
equilibria so if you have a game you
know there's always going to be this
Nash equilibrium with Nash equilibrium
sometimes sucks if you have a prisoner's
dilemma the Nash equilibria ms that
everyone betrays and everyone goes to
jail and it would be so great if she
could coordinates right if they could
say ok now we're going to make a
contract and then we both won't go to
jail well it turns out that if you take
any game and you allow people to
contract them to have self-enforcing
contracts then instead of having Nash
equilibrium the game have super Nash
equilibrium and the supernatural Ibrahim
is a Nash equilibrium that resists to
all contracts all and all allegiances
and the property is that a super Nash
is actually Perito optimal and that's
really cool it means that as long as
people are given the chance of making
contracts that they can enforce then
they can all be better off and the way I
look at it is you have this landscape
this landscape surface of how bad or
good things are and you can be stuck in
the local minimum where Kim Jong owning
your is your boss but what are we doing
with coordination is digging tunnels
from the surface we are low ourselves to
live from a local optimum to a global
optimum without having to be sharp eyes
away by the other guards okay so this is
why we're doing governance and how we're
doing it let me talk briefly about what
Kamel so tezo's is implemented from
scratch it's not a clone of SEO any
other blockchain in a camel why did IP
go camel well first of all a camel has a
formal semantics almost most of a camel
very large subsets as a formal semantics
and this is important because the
protocol itself becomes something that
we reason about you know when we make a
proposal the proposal is going to be in
a form of okay ml code and it has to be
very unambiguous what we're talking
about the other thing is you can extract
a kml program from cock so cock is a
seer improver and also you can also
search for proofs by itself and once you
find a proof you can extract in a kml
program out of it which means that if
you want to write protocols which have
been really verified you can write them
in Cocke and extract them to a camera
for performance now the alternative
would have been to create a DSL would
have been to say okay you know I need to
have this embedded language where I'm
going to describe a protocol where I'm
going to implement apply and fitness but
implementing applying Fitness is a lot
of code and you know you need better you
need good tooling and you need a high
level language and so razors and create
yet another language I said well you
know a camel is great way to do that a
little bit about defensive programming
as well I know camel so I don't know how
many of you are familiar with a camel
this is a very simple example of an oak
ml module and what I want to illustrate
is how a camera modules give you an
calculation so here we have a module
tokens with the type T and type T is
abstract you know there's a type which
you don't know what it is you know that
you can create this type out of an
integer and you have an addition
operation where you take two elements of
type T and you get another one and here
you have the concrete implementation the
con
imitation tells you that Steve's an
integer it tells you that the up in
function is actually just the identity
you have an integer you get another
integer and it tells you how to actually
implement addition but what's cool is
that once you do that the rest of the
code is only going to sing the signature
so the rest of the code cannot create
this type without actually explicitly
going through this function so there's
no risk that you're actually going to
confirm is take it with an other integer
in the code and also is going to
completely restrict your surface because
whenever you have whenever an object of
type token is being accessed is being
accessed through functions inside this
module so you can control everything
that happens to it so what we did in the
code is we build a pyramid of
abstraction from the storage so at the
lowest level we're storing all the
objects that we have on the state's
inside a database we actually rely on a
key store value based on gets to do this
and then we build up we build up with
higher and higher abstraction up to the
point where we're implementing the apply
function and we're using very high level
primitives which absolutely cannot even
in principle touch the low level storage
it makes it easier to analyze and it
makes it easier to enforce invariants
and part of the reason was that we were
building it with a small team we were
building it from scratch it is really
hard to ensure that you're not making
bugs when you're writing something like
this and so we wanted to have a style of
programming where we could be very
confident in the safety of the code now
let me talk a little bit about smart
contracts now every blockchain TuneIn
use to have the smart contracts so what
are they well a smart contracts is a
piece of code representing and enforcing
a contractual agreement over the
conditions under which shared global
states may be altered okay so for
example let's say you have some type of
wallets on a blockchain with some tokens
you might want to predict it accounts
you might say okay you know maybe I'm
drunk and maybe I spend them and I don't
want to spend them or maybe someone
steals it so you would set some rules
and say okay I can only spend them on
this day or by this amount or at this
rates you can set rules you could have a
swap you could tell okay I want to
exchange tokens with you under certain
conditions by certain amounts for a
certain period of time or you could have
voting you could have
contracts where you receive signatures
aggregate the signatures count votes and
changes states of the blockchain based
on that so how do we implement a
language for a smart contract well the
usual approach when implementing a new
language seems to be first you create or
you pick an existing virtual machine you
know you'll say ok I'll pick the airline
virtual machine or the JVM then you
build your high-level language and you
compile it down to the virtual machine
and then that's great because you get
just-in-time compilation for free you
get a ton of libraries this is fantastic
except for smart contracts this is
dangerous why because first you need a
formal specification of the VM this is
what you're going to record is going to
record in agreements you want to make
really sure that everyone agrees what
the VM is supposed to do second you need
the formal specification of the
high-level language you need to make
sure that you understand what it
actually does and more importantly also
need a formally verified compiler you
need to have a compiler that guarantees
the semantics you have in the high-level
language is also going to carry over to
the low-level language and so that's
difficult but I think also one more
important point is that if you don't
have that and all you have inside the
blockchain is going to be this virtual
machine code and it's really hard to
make proofs about the virtual machine
code now you might say ok well if your
contract you know can have a formal
proof of correctness in a high-level
language why could I just you know take
that proof that means there's a proof in
the low-level language but that's not
quite true when we reasoned about
high-level abstractions is much easier
than reasoning about low-level
abstraction right so in theory if it
proof exists for one it exists for the
other in practice it's very hard so one
of my favorite example is a pigeonhole
principle the pigeonhole principle says
you have 101 pigeons you have 100 holes
can you put the pigeons in holes so that
no hole that has more than two pigeons
and of course you can't because you have
more pigeons and you have holes right
but if you take this program if you take
this problem which is really about
arithmetic and you turn it into a
problem about boolean about a set
satisfiability problem in boolean and
you just look at it in boolean logic any
proof is going to have to be exponential
in size so you turn a problem which is
very simple into a problem which is
going to be now extremely gnarly to
prove why because you've dropped a
theory of arithmetic which is a very
valuable theory and
you were presented this problem in this
very low level you would have to
basically reinvent our aesthetic in
order to get a concise proof so whenever
you go from a high level abstraction to
a low level abstraction you lose
important theorems about your data and
this is y sm t methods have been so
successful satisfiability model theory
their message which analyzed programs
and trying to find how to get into
certain branch of the program and what
they did was instead of saying let's
compile down everything to billions they
actually keep the structure so I think
it's very important when we have a smart
contract language that we can reason
directly about the contract that's being
written about and so we need this
contract to be written in a high-level
language what do we care about we care
about correctness you know you want your
contract to be correct you don't want it
to be something you know want to do but
you also want it to be verifiable the
other side must know that it's not being
cheated must actually trust you enough
that they can verify the behavior of the
contract you want persimmony because
well this is recorded on a ledger that's
going to be replicated everywhere so
spaces in the premium performance and
portability you don't care about that
much why because you're not running
protein folding you're running simple
business logic there's no point in
trying to optimize the performance of
that the number of cycles you need to do
most useful cases is very small
portability you're going to be running
interpreted anyway you're going to be
running on one of the few implementation
of a production you don't need to be
running everywhere and if you do you can
just write an interpreter so I'm not
saying that it performance and
portability have no value but it
definitely should not be a priority so
let's look at solidity so solidity is a
language a high-level language for a
serial it kind of looks like JavaScript
but with more types now the problem is
solidity compiles to EVM EVM is hard to
reason about because it's this assembly
language the EVM compiler is
non-deterministic so you can't even know
if your ATM code actually matches the
code that you wrote in you solidity
there's no spec of the VM there's no
spec of solidity now people when they
sow bugs happen with solidity say well
this is because it's Serie B steering
completes that's the problem because
rice serum we cannot predict any single
Turing complete programs but that's not
that's not the issue that's not the
issue because you can have programs in
non turing-complete languages which are
impossible to analyze and you'll have
problems as well and likewise you can
have programs in turing-complete
languages which are easy to analyze
because they don't make use of weird
features you know if you write your
program in a straightforward way it
doesn't have to be that you can't make a
proof about it
so what really matters is how easy can
you reason about a program not whether
it's during complete or not so the
language we design for this is called
mickelson it's inspired by cats which is
I see now a defunct project cat was a
stack-based statically typed a
functional language in program so we're
also stack-based because I think it
enables concision and we don't typically
need a ton of local variables when
writing smart contracts it has high
level primitives Maps sets lambdas we
want as many high level primitives in it
because it makes you more concise and
it's easier to reason about and it
statically and strongly typed and one of
the cool thing is that the type checking
is done by okay ml itself so we're not
running Co camel runtime it's just that
the object inside o camo is built with
the GED T and when you create the object
you cannot create the object
representing the program in a way that
it will not type check the only way to
construct it is to have well typed
programs so for the contract model
itself this is how we do it we have a
contract it contain tokens a tired
function and a piece of readable data
then we have transactions transactions
are going to take tokens and then going
to transfer them but they also going to
contain any inputs to the contract
function where you're sending the tokens
and a message and the function in them
cells can send new transactions so think
a little bit about small talk where the
transactions are actually messages you
have messages between this different
contracts which carry immutable states
and the changes state and they send new
messages as a result so one famous model
is a TX out model that's a model in
Bitcoin and the main difference in a TX
out model is that instead of sending new
transaction instead of computing what
transaction you want to send you only
compute what would be a valid
transaction you say okay I have a piece
of code that tells me is a transaction
valid instead
of what transaction should I make and
there's been a lot of reading about the
differences between the two model they
are is a morphic one thing you can do
with one model you can do with the other
right one is not safer than the other if
you have a safety bug in one you have a
safety bug in the other the only
difference is that model the ten
transactions by itself can be automated
a little better you don't have to be
running a server to do the same thing
that is the one difference there's no
other difference you can turn one into
the other now let's talk a little bit
about reentrant see bugs so there was
this project called the dow on the
cerium and the dow raised 150 million
dollars that we're going to be this kind
of like distributed VC firm in making
investments but they had a bug and the
bug was a following you could go on the
Dow contract and say you know what I'm
done with this I want to take my funds
and go so you could call a split
function when you call a split function
it will send you your tokens to a refund
address but here's the thing every
address is also a function is in the
serum like in tezo's and so once you
receive this refund the it would trigger
code and the code would ask for the
refund again and the contracts getting
the refund will know yet that the refund
has been processed and they would send
the refund again and again and again and
again and so the person asking for a
very small refund was able to drain 50
million dollars so what do you learn
from that well we were side effects you
know when you're writing in the middle
of a contract when you're writing to
your your storage you are writing to
global variable this is dangerous this
is not a good practice so what can we do
instead well tells us uses continuing
continuation passing style with
syntactic sugar so the first idea was to
say okay we don't want to have any
side-effects inside our function we want
very pure function so instead of sending
transaction inside our function we're
going to return that at the end of our
function will return whatever
transaction we want to get and if you
want to be called back we will actually
give the call back as a parameter to the
contract that we're calling well that
can be cumbersome because it would be
nice in the middle of our code to be
able to call another contract get the
result and then continue what you were
doing so what we do instead is you send
a transaction but whenever you send a
transaction you have to commit the
your new state of your contract and then
you can continue but it forces you to do
that and by forcing you to do that it
forces you to say oh well hang on you
know I have a variable that tells me if
the refund has been processed and I need
to set this variable before I call any
other transaction and if you do that
you're not going to go into reinsurance
e bugs okay so let me give a quick
summary this is a self amending ledger
we are self amending because we care
about governance we want to get good
governance and good innovation we
written purely you know camel it was
written completely from scratch because
the camel gives us good defensive
programming and gives us a strong
platform for defining what is a protocol
and we design or smart contract language
with verifiability in mind Allah one
strong assumption of the project is that
formal verification is about to become
ripe for this type of application formal
verification which makes formal proofs
about programs for the longest time it
wasn't very practical you couldn't pry
you couldn't verify concrete problems
but now we have all these contracts they
have a few lines of code and there's 150
million dollars worth of value behind it
it's a perfect candidate for formal
verification but it's not being done yet
so what's a road ahead well we need to
work on these two things really hard
before we launch dots prevention is
tricky especially when we have the type
of proof of stick model that tasers has
developed and consensus is hard and if
you break either to your network crashes
most other problems if you have that
design if you're slow all of these
things you can fix because we have a min
amendment process but it's things that
we cannot fix easily with amendments or
these two things so that's what we're
working on hardest but we also would
like more eyes looking in the code so
the code is available on github comm
phaser slash tezo's and it's not open
source yet you can run the code you can
look at it it's not on purchase license
yet we're still looking into what
license we want to use and it will be
released under free open-source license
in q1 2017 and in the long run we want a
cool feature well we want to build in
the proof checker in a protocol so that
we could have constitutional amendments
we want to build a declarative language
for smart
contracts so that we don't even have to
write proof so that the contracts can be
self-proving and we would like to
develop a stock library because narcs
they're very cool cryptographic
constructs that can give us privacy but
also a lot of compression ability in the
software all right this is my talk about
Tasers and I'll take some questions yes
yeah I think one of the least
appreciated aspect of Bitcoin is how
well it deals with spam right in Bitcoin
if I come and tell you hey here's a
better chain here here's a better
version you can check that very quickly
all you need to do is count the zeros in
the realm of hashes you don't need to
download blocks you need to do very very
little work to say nope that's not right
and for you to fake it would be
extremely expensive in the proof of
stake system dealing with spam is harder
because someone could say hey here's
this very long chain and if you check it
you will see at the end of fitness will
be really high right so you have to
architect yourself so that you can
reject that I can reject that very very
quickly you want to be able to download
very few blocks and be able to say nope
that chain is lying and that affects
that that consideration affects a lot of
the design of the algorithm itself but
it's and it's still constant time is
still going to take you synthetically
the same time you take with Bitcoin but
you actually need to download a block
you need to analyze what it does so it's
a little trickier the DRH issue comes
with proof of state yes yes
so the verification done by the
amendments it only happens at the moment
where you actually submit a new protocol
which is not going to be a very common
event you know maybe like if there's a
protocol a year that would be a lot okay
so the clever way you I see so the
question is how do we deal with an
accumulation of amendments if we have a
ton of amendment it becomes really
impossible to a greater system so the
trick is to be careful when you pass on
amendments so there are certain things
you should do you shouldn't have really
hard amendments right you should
probably say this is an amendment and
you need to abide by it unless maybe you
get an 80% majority to say it's fine so
you need to have a procedure for
repealing amendments that would be wise
you could also add sunset clauses in
most of your amendments so that your
guarantee that you don't get stuck for
too long the worst case scenario right
the worst case scenario if you get stuck
well you don't have to go through the
system if you get stuck you can hard
fork but why can't we hard fork all the
time well we give free hard fork all the
time then we get the problem of knowing
who's right and what to follow so the
procedure is really about giving
legitimacy to one fork rather than
another one but if you're doing
something outside of the system right if
we have a good procedure for changing
governance and you say no no no let me
ignore the procedure in hard fork you're
going to be suspicious people are going
to say well why do you want to do that
why don't you go through the system
you're not going to get the Schelling
point however if the system is stuck and
you say well this is stuck here's a
protocol that will unstuck it then you
can prove the hard fork because you have
an obvious reason for doing so right
you're not obviously evil yeah
ah what pork are applicable to a
permission blockchain good question well
I think that permission blockchain very
often are solving a political problem
you have a lot of players and in series
they could have the technology for
dealing with your issue but by pushing a
blockchain on them it kind of solves the
problem saying who's in charge right you
don't want to have anyone in charge and
I think it applies to governance as well
because you know permission blockchain
is governance just as much as a regular
blockchain in governance and so in
theory you could have efficient
governance you could say well we'll
Chris's body and his body will govern it
and so on so forth but you won't get as
much flexibility in these governance
rules as you would on a blockchain
and it might be tricky especially if you
have a permission blockchain let's say
for a bank use case where you have banks
all around the world it gets really
really difficult in practice to actually
have these governing bodies and you can
you can look at it and some of the other
permission system which are out there
which don't really have explicit
governance and aren't able to be very
nimble you know look at the internet so
the Internet is actually permission and
the internet has a very hard time
actually upgrading itself yes
yeah
yes
just just make it harder
right so does it make it harder or does
it prevent it completely it makes it
very hard so if you want to have our
insurance II bug you know some persons
bug is another person's feature right so
if you want to have our entrance II bug
you can but it makes it very very
obvious that the bug is here and you
also have a protection if you want to
disable we in turn Z completely you can
say no reenter see because you can
actually control the stack inside the
inside the execution of the contract you
can see who your callers are so if you
don't want to have any reinsurance e
which probably you don't want by default
you can just deactivate that but I think
even more interesting than that is the
ability to change the language itself
you know we have amendments if we find
that there are some cool features we
want the language to have that prevents
more bugs we can actually upgrade the
language yes so what is the initial
governance model what's really important
with the initial governance model is not
that it's perfect but that it is in the
right basin of Attraction so that we get
into a virtuous cycle where we get
better and better systems instead of
worse and worse right and the initial
model that I have is you have a set
schedule for voting which at first will
be fairly often maybe every three months
and then I has an exponential decay on
the lens at which it happens all the way
to one year and we have a 60% majority
needed with a 60 percent quorum and the
quorum itself is exponentially
decreasing based on the quorum of
previous elections so that you don't get
stuck so I think 60% and 60% is fairly
conservative but if people don't feel
it's conservative enough I trust that
the first election would actually raise
that quorum yes
well that's the paradox of self
amendments in a nutshell everything is
open to amendment so things you can
change you can change a consensus
algorithm right you can change the
fitness function so if you say you know
what this proof of sex thing is not
really working for us the risk of data
loss is too high you can switch to a
proof of work system or you can switch
to a centralized system so consensus is
completely in scope if you want to say
you know what we won't Bitcoin you can
turn the entire thing into a complete
Google clone of Bitcoin and have that so
really the thing that is not that you
don't have governance over is a network
layer and the reason for that is that
network layer works like people can
innovate and there's no there's really
no conflict on the network layer yes
it's time all right thank you everyone
for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>