<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;HTTP/2 in Erlang&quot; by Joe DeVivo | Coder Coacher - Coaching Coders</title><meta content="&quot;HTTP/2 in Erlang&quot; by Joe DeVivo - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;HTTP/2 in Erlang&quot; by Joe DeVivo</b></h2><h5 class="post__date">2015-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wpE1ElfZZxI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right um hello so um you know you're
at strange Lou 2015 it's Friday it's 140
p.m. that means it's time for HTTP to in
Erlang yeah so uh I don't that much time
so there's a slack channel you can ask
your questions there ask them as we go i
will get back to you later so I've been
doing a lying for a couple years now I'm
actually four or five years now HTTP is
new to me this year but when I started
both of these things they were very
overwhelming so hopefully I going to
make them a little bit more accessible
for you guys today so let's start with
you know why HTTP 20 we got these two
RFC's here 75 4075 41 they just got
officially approved in mace this is this
is the new hotness ACP one is so over
anyway except that it's not it's going
to be around for a long time a lot of
semantics are still going to be used and
yeah I mean we've got these you know we
have 296 pages of RFC from 2014 just
redefining HTTP 11 it'd be a shame to
throw all that away so soon so we're
just going to keep using it but even
further back I mean HTTP was built in
the 90s by physicists to you know to
just share papers and linked references
and that would be all really cool that
we started using it for everything I
mean it's fine use it for JavaScript use
it for CSS that's fine it's all text but
then we started throwing images added
audio files you know video flash you
know all that stuff so it's fine you
know I can't I came up on the web in the
90s and I had 90s web problems you know
I had broken JPEGs and terrible style
and uh you know you can't blame the
protocol for under under construction
gift that is a mistake we all made
together so did one dot one fix all of
this well um no you know what we did we
threw a ton of bandwidth hit the
probably through broadband everywhere
you know HTTP one not one tried to fix
these things and it tried with
pipelining and it was optional and it
got a failed we try with keep-alive
connections and it kind of works and you
know we have all these workarounds
sharding and spreading and in lining and
it's just you know really what happened
was perceived latency went down as
broadband adoption went up so great
we've all got broadband now we're done
no slower connections are back in a big
way got mobile devices we have edge
networks throughout the developing
world not to mention the whole internet
of things this is where HTTP two comes
along it is like the Scrooge McDuck of
protocols man this thing is cheap it
wants to optimize the wire and it will
do that at the expense of storing things
on either side of the connection we're
going to optimize the wire with a single
TCP connection we're going to make it a
binary protocol for the first time
people are up in arms about this Oh back
in my day we used to tell them that into
servers and look at HTTP requests and
responses well you know what you should
be using SSL anyway so you can't do that
anymore if you take away one thing from
this talk take away that HTTP two is
about efficiency on the wire it does not
try to change the semantics of HTTP
request response get put post all this
stuff it's still around you were just
trying to underneath the hood make it
all faster and binary so I orale well i
work at chef and I'd chef we have chef
servers written in our line and one day
a chef client runs could be served via
HTTP two and when that day came I didn't
want to be stuck without an HTTP to
server to actually do this with um and I
thought you know maybe I could maybe i
could write my own i mean like how r
could it be right well it's kind of so
cool thing about Erlang is that it rocks
the actor model for concurrency each
actor lived in its own little world they
can receive messages which is then
updates its world view on and it can
send out its own messages and even spawn
up new actors and for airline these
actors are processes and it's really
easy to spit up new processes they're
lying Merlin comes with OTP the open
telecom platform and it's a set of
standard libraries which among other
things will help us make it easier to
work with the actor model and the first
one we're going to use is a supervisor
pad our supervisor behavior and I have
one supervisor mighty to be to server
and this thing I pretty much picked it
up verbatim from learning you summer
language is a great reference if you
want to learn you somewhere laying and
you know I think you should but I'm not
the boss of you so you know learn what
you want so a supervisor just spins up
in a listener socket here to sort of
hang out and wait for connections come
along and then what's going to happen is
it's going to spawn all these processes
that just accept these connections and
when a client connects it's going to say
okay I've got this process and I'm gonna
spawn
other accepted to take my place this is
how Apache pre fort works at a unicorn
works this is nothing new I'm just new
to me a bomb our legs is a supervisor
behavior gives you for supervision
strategies that it can use the one we
chose here is a simple one for one which
is a lot like a factory pattern for
actors you just stamp out like new
versions of the same things just just
you know just keep minting them out and
simple one for one is also good Adam
it's good to make him like one kind of
thing in this case HTTP two connections
and it's good at having lots of children
so we can just have it can monitor a
whole bunch of them and it doesn't
really care if you have lots of them so
that's that's perfect for like a web
server right speaking of servers one of
these processes well or like this is
this generic server behavior and that's
great right it's a generic server that
takes care of all our lines messaging
semantics and it's just it's a bring
your own state server so it allows you
as the as the code writer to say you
know forget about her like messaging API
you handle that I'm just going to write
functions that say if you asked for this
I'll do this sometimes doing this means
answering a question you have sometimes
it means just changing my own state and
not even answering you that's fine so I
started with one of these and I was
writing my server and very quickly
became clear that this was not the
answer for me the answer for me was a
generic finite state machine protocols
are more complicated and what winds up
happening is they depend on what's
happened previously right did this
happen already okay then I can do this
and Jennifer Sam exactly perfect for
that cuz it takes Jenn server and it
adds like finite state machine semantics
to it so you can have multiples running
states and you can have different rules
for what happens in each state and you
can define transitions between state to
state not to mention the state that
we're bringing did I say state a lot of
times probably it gets confusing so this
is like a typical gen server right we
got this Erlang init function callback
and this terminate callback and this is
how they these are just sort of cleanup
accounting states for lying so don't
worry about them they can't even receive
process messages what kind of states are
they but this running state can and with
a gen server alignment so with a gen
server you're in one state you do one
thing you just ask lunch of questions
it'll always answer the same and it
might give you different answers based
on its state but that's about it
Jennifer's em lets us have multiple
running states and we can have different
rules for what happens in each
one of these states and this is kind of
a spoiler for what my connections going
to look like but you know that's fine
we'll get there so um we have different
running states and word on the street is
that jen fsm is great for implementing
protocols so I thought I'd see if it
lives up to its name especially since I
Jen's server experiment already failed
and I never built one from scratch
before I'd edited them a bunch but I
never liked wrote my own so here we go
step one is just start a bunch of them
we already did that but the supervisor
pattern it was super easy with so he's
getting show yeah we did it step 2 well
what's step two I don't know well I I
know now but I didn't know then and what
I had to do is dive into the protocol to
really see what was going on so you know
let's go chasing protocols let's see
what's going on in there I was hoping I
got a good reaction to that slide I
thought I might have dated myself there
so the first thing we're looking at here
is an HTTP to frame it's the smallest
part of the protocol and it's it's kind
of part data type part serialization
method but I mean if you think about it
like it's these little pockets of the
waffle right and you can put anything in
that pocket you want now if you put all
sorts of great things in there like
syrupy butter peanut butter you know ice
cream all sorts of good stuff but you
know he can't put in there like rocks
and chalk and like you know dirty that's
terrible so we have the specification
telling us what we can't actually put in
these pockets and that's great so what
do we learn from the specification here
well we learned that every pocket has a
frame header it's a 9 bite header that
basically says what does it say about
the header it says it says what
information is in it we got four things
in there really length which is how big
how big the content of the pockets going
to be type what type of the content is
going to be in the pocket a couple of
routing flags basically say what do you
do with this pocket and is this kind of
the last pocket and then stream
identifier which you know is a way of us
sort of a sort of saying what stream of
information is this belong to and we'll
talk about streams in just a second but
it also tells us how this is represented
in a binary I mean this is nine bytes
there are three bites of length there's
one bite of types there's one bite of
flags there's this teal bit that we just
throw away for no good reason and then a
31 bit stream identifier so then what
well the type tells us what all these
grey blocks are made of what's in the
pocket and each of the ten frame types
have different pocket content some of
them actually have a note pocket content
but you know just savor the taste of the
waffle I guess and then
tells us like what the binary reputation
the representation of this data actually
is so how do we read a frame while or
lying socket API is kind of cool what
we're going to do here is we're going to
just receive nine bites off the socket
and now we have them in that great that
was easy then we pass those nine bites
into this read binary frame header we're
going to turn this into something that
we can actually manipulate in erlang i'm
going to show you that on the next slide
I think and then after that we actually
pull the length out of the frame header
and we can say okay take that many bites
off the socket that's going to complete
the frame and then I have a giant case
statement underneath here or you're not
going to see that basically says okay
based on what type of content this is do
this kind of stuff with a binary and
turn it to something we can use oh I
told you is on the next slide this is
the riot of breed by Terry frame at our
function and it has one argument that
argument is a binary so it will sheff
rounds around it that means it's a
binary and I'm going to you know gray
out the rest of you're not distracted
these colons here are telling us well
the slash bits at the end is telling us
we're talking about bit lengths and then
these colons here are going to tell us
what we're actually going to bind here
and what this works how this binary
pattern match works inner line which is
super fantastic is that as this binary
flows through this function we're going
to bind these variables length type
flags and stream ID to these bits that
are part of this binary string and these
things are gonna be bound as big endian
unsigned integers and yeah we're going
to use those bindings to to create this
frame header record there's an erlang
record it's a totally hacking data struc
that everybody hates but we all keep
using them so I'm going to keep using
them and yeah now we have these four
fields in the record and we can use them
everywhere like we did to figure out
what the length of that frame was so yes
and we're going to wrap all that up in
one function for you and then you never
have to worry about the internals and
began but that binary pattern match was
so cool I wanted to show you it i even
made this photoshop about how cool
binary pattern matching is you're going
to match so many of it was getting so
much fun so oh the patterns will match
now let's talk about HTTP two streams
it's um physically it's a sequence of
frames right all with the same stream ID
they come over in order over this one
tcp connection and we know together they
collectively make this one stream
logically they represent a HTTP request
and response bunch of frames come over
as the request bunch of frames go back
as the response it's that easy except
not because in real life it's not a pie
slice of the waffle
all coming interleaved like this and
it's up for us to reassemble them on the
other side that's part of what our
finite state machine does so part of
them those flags in the frame header and
some of the frame types help us make
decisions about what it is we do with
frames as they come in so we don't have
to wait for the whole stream to come in
before we start making decisions about
it and we get that information from the
RFC the RFC provides this little seven
state ascii state diagram in it and it's
going to basically tell us what happens
when you get certain frames in what you
can do what stage can transition to when
you're in those states what you can do
however for our purposes in Erlang we
don't need Erlang's FS gen fsm messaging
semantics around it so what we're going
to do instead is just um you know create
this referential e transparent or light
function which just takes in a stream
state record and a frame and then
applies that one frame and it tells you
what new stream state isn't that kind of
thing and then there's the HTTP
connection which is kind of like the
plate the waffles are on right it's
persistent between requests and it just
sort of maintains the entire context for
the meal a neat bun and while that you
know the whole meal has context in state
each bite is kind of stateless except
that you're getting a little bit more
full but that's that's your problem so
yeah RJ deficit maintains the solid
state but allows us to process
individual requests in a stateless
fashion which keeps us with the
semantics of HTTP so yeah the short
version is I'm going to read it slide to
you i know it's that's that's fouled i'm
gonna do it the frame is a data
structure in serialization method a
stream is a semantic HTTP request and
response and a connection is a
persistent context for all these things
so let's go put some stuff in the
connection HTTP to provides six
connection settings that you need to set
the client sends them to the server and
the server sends them to a client so
there's actually two sets of them and
you know they both sort of negotiate
what they expect about this connection
right up front so you know it's the
foundation of a healthy relationship and
I'm glad the client-server get along so
well they can also renegotiate these
settings at any time so you know as
things change you can you can change
with the times the first one of them is
the header table size what's the header
table this where H pad comes to the plan
I did a whole talk about H packet lambda
jam and you should go find it and watch
it because it's a half an hour of me
just explaining this one slide however I
can't find it because it's not up yet so
you know watch this face and we'll get
there but yeah the basic short version
is
each side of the connection takes it
keeps a table of headers name value
pairs that we've sent back and forth and
we keep track of them with little
indexes and then if we're going to send
the same one again we know the little
index so we still in that integer over
the wire instead and then all the sudden
it was super cheap and this is some
Scrooge McDuck action right here we're
just send in one little immature and it
gets a whole header name value bear so
that's great and there's two of these
there's one for the request headers
received and there's one for the
responses headers sent and the client
has it set and the server has it says
it's actually for abused serve which is
so cool server push promises allow us to
send multiple responses per request you
ask me for HTML I can inspect that HTML
I can say this HTML is going to need
this CSS this JavaScript these three
images this you know this MIDI file I
don't know what you're doing with the
web but we'll send it all back to you
and you won't even know that you wanted
it when I start sending it back to you
but by the time you think oh man i want
that CSS file it's already there you're
welcome you know I this is great for ABI
is two more can you really get into that
too much right now we're going to talk
about maximum concurrent streams
remember that ascii stream state diagram
I showed you there were seven total
states all streams start in the idle
state the end in the closed state there
are five states in between you can only
have this many in those five states for
any particular connection HTTP two
brings flow control to http you can put
a limit as a credit-based game where you
put a limit on like how many bytes that
you're willing to accept as the server
the client has its limits to you can set
these at the stream level and the whole
entire connection level and it only
applies to data frames and data frames
are push sorry I'm they are request and
response bodies only this is what data
frames are so any control frames headers
you know reset streams go away frames
anything that you need to do to affect
the connection goes around this flow
control is not affected by it so if you
get stuck you can just say you know what
I give up you don't have to just sort of
sit there and hang forever like some
versions of HTTP I know so yes so um you
know data frames they affect these
counts on both levels but you can also
issue credits so say you're like say
your server but you're like on some like
internet of thing
box and you're just sitting there
waiting to accept connections and you
say you know what I can only accept two
kilobytes of data per connection so you
send me to kilobytes we've already
agreed on this in the settings handshake
so you know to stop sending me things i
know i have two kilobytes i got to get
rid of because they want to send me more
so I serialize it to disk I put them in
the database i turn on your refrigerator
whatever it is I do and then I flush
them out of my memory and I say hey wow
my memories empty now I have two
kilobytes free again I'm gonna go send a
window update for him to the client
saying hey and you can start sending
data but only two more kilobytes because
that's all I got hey remember how frames
have size well you can set a maximum all
that and this setting goes great with
MTU right you can just say like oh well
Frank can only be this big Oh packets
can only be this big all right well now
we're just sending stuff and we're
awesome so you can actually tune with
the protocol as well as the network
layer and then max header loose size
right just sends it's a stream level cap
for how many headers you can send over
in a single request and wow that's it
six settings I spent a lot of time
talking about them but you know what we
touched the whole protocol we talked
about multiplexing we talked about flow
control talking about header compression
we talked about server push the only
thing we didn't talk about with stream
prioritization but you know what the
spec says that's optional so we don't
have to talk about it so these things
all imply more state and so we're going
to create an erlang state record to
modify in our gen fsm we got to keep
track of things like how many states are
active what our current credit balance
is at the stream level what our current
credit balance is the connection level
what street states are streams are in
the table of request headers sent over
that's the h peck decode context the
table of response headers that were
going to that we've sent back that's the
h pack encode context peers can have
different values of these settings we
have to actually keep two values of
those six settings in this state so we
have a lot of things to keep track of
and we put them all in this Erlang state
record and this Erlang state record gets
passed along pretty much in every call
to every gen fsm call back what's a jet
fsm call back i am so glad you asked jen
fsm has these six callbacks on the left
and they are required for you to
implement your own gen fsm they could
literally do nothing you could write one
right now that implements these
callbacks and returns just these
particular tuples that require to return
and you're done you've written janice m
gen fsm congratulation
it does nothing so you have to make it
more interesting by implementing some of
these that actually do things especially
these state name ones over here these
are capital letters because they're
variables not not particular
requirements and you need some of these
for the states that you create we're
going to need a four of them and the
fact that they'd only take two arguments
means that we're not actually we don't
actually need responses from any of them
which is all our responding goes all
over the socket so those callbacks that
we need to define basically can take
these forts return types but we're only
interested in these two the first one is
this next state thing which is okay so
we want you to go to the next date now
that we're done processing this message
here's our the next state that we want
you to go to here's that state data that
we've modified and sort of sent along
our way and then here's a timeout value
which we're always going to use a zero
and all this is basically saying is
after you've processed a frame we're
going to send a timeout message back to
our process that basically asks it to
read another thing off the socket
another frame off the socket and then
process that and then you know repeat
until the connections over when the
connection is over we send this stop
tuple thing and that's jennifuh seems
like clean way of exiting here so we
could have gotten around that zero
timeout thing by not using by using an
active socket but I want to choose a
passive socket so I had more control
over things so yeah so this is our
Jennifer Sam we saw before but now it's
square so you should be surprised and
think that it's new the init state and
the terminate state are still managed by
the buyer langa they can't receive
messages so we've got these five states
we really have to worry about it it
basically takes in that listener socket
and you know tells Erlang hey when
somebody actually comes along and wants
to talk to me you know let me know
except today is the thing where it sits
around waiting for somebody to come talk
to us once that happens then the
handshake state is basically us saying
okay are we really an HTTP two
connection are we you know do we have
agreed settings can we do stuff and if
so we move into this connected state
which is all like all right let's
process some frames let's serve up some
data is gonna be awesome and then this
continuation state is weird H pack race
condition which I'll get to I promise
and then the closing state is this thing
where we sort of tidy up the sockets and
make sure they're all closed before we
go home to terminate and that's kind of
it let's walk through sort of like a
little bit more about how that works so
the init thing takes in a socket always
takes in a list it takes in one argument
which is a
but it's a list so we get out of it
really only having seen one or he takes
many as we want it's a list and this is
the callback that data processed
supervisor from the beginning calls to
start everything up right every time it
pulls that lever and factory models a
new actor it calls the init call back to
create a brand new version of the state
that we're going to be using and the
only thing we're going to do is take
that listen or socket in from the
argument and register with our life's a
hair lang you know I know this is a
listener socket you already know about
it so when some client comes along and
asks for something you let me know I'm
just going to hang here and chill and do
my own thing until until you do that so
we take this reference that it returns
which is just sort of like our deli
counter ticket right we've asked for a
socket and it's so so sure your number
17 and when number 17 comes up don't get
your socket so we do that and then we
put that in our state and we leave
because we don't want to hang out in the
init call back too long if we hang out
too long the supervisor is going to get
antsy he's going to think we did a
terrible job at being a process and kill
us in cold blood but we got past that
because we're doing an async socket
except so now we kick it on we go into
the except state and we use handle info
and handle infos were when good messages
go bad handle info is for messages that
are not managed by the gen fsm API so
which is which is good for when the
socket lets us know that there's
something and our deli counter number is
up well it does it in a non jennifuh
semi way and so we can't use a standard
gen-f as I'm call back we have to use
this handle info thing which is cool so
prim ina is going to send us back this
message about our deli counter number
being up and here it is this message
like this is the four tuple it says it's
from it's an async I met thing it's got
this is the listener socket you
originally asked for it about here's
your deli number just so there's no
confusion you're not trying to steal
somebody else's socket and then here's
our our tuple of ok claw socket so this
is the ABS the classifier is the actual
thing that somebody some client is
connected on we want to talk to them so
it's great the fact that we're using
handle info here to receive this message
is good because otherwise from inet
would have to be designed for Jen fsm
use only and then we couldn't use this
in other things like Jen servers or just
even in the command console so it's
great here's our handle info call back
and it probably looks a little admitted
even though I cut a lot of stuff out
with this comment here but we're going
to break it down
for you because this shows a couple of
cool things shows us how to use function
Clause matching and record syntax which
I think are both really useful for
building a server like this so the first
argument to handle info is that for
element tuple that I was talking about
before now we're doing function Clause
matching so we're making sure that this
matches a 42 bowl that I net CA same
thing is an atom that means the first
atom of this message has to be I net
acing if it's not this function Clause
does not run the underscore in front of
losing or socket says yeah we know it's
listener socket but I don't care I'm
never going to use the variable don't
bind it there's our deli number and
there's our socket those two things are
bound we now have ref and cly socket as
variables that we can use in this
function the second argument is except
it means if we are in any state but the
except state do not run this we are
matching on what state we are in and
what state where energy is the atom
except now we're going to take our state
our connection state the state record
that we were talking about we're gonna
bind it to the letter s with that equal
sign there so now s is the state but
we're also going to deconstruct the
record so just by putting a hash
connection state over there we're saying
hey this has to be a connection state
and by the way we're going to assign the
SSL option fields to this SSL option
variable we're going to make sure the
socket is a 2-tuple we're going to make
sure it has a transport define which is
either TCP or SSL depending on you know
how you're feeling and then undefined is
saying the socket the socket itself is
actually undefined if the socket is
defined already we don't want to run
this we have a socket already why are we
accepting sockets we have one so we just
move on and then we have ref down here
again see how that ref is still
highlighted that's not a mistake these
to rest because it's Earl eyeing the
fact that we named them the same thing
means they have to be equal to each
other if they are not this function head
doesn't match and we don't run this
which means we can only accept sockets
from our deli number but once we've done
that we're spoken for we are now a
socket that has accepted a connection so
we're going to go ahead and tell the
supervisor hey there's one less acceptor
in the world we're spoken for spawn up
another one you know pull your lever
make a new socket and sit there waiting
in the accept state so yeah so then we
return this for two but we talked about
with the zero time out the next state
the next date is handshake and this and
this modified version of state but let's
look at that for a second this syntax
without the equal sign is saying take s
now make me a copy that is all
also a connection state with all the
fields that are the same except for
socket which we're going to now make
this instead why do I want to make a new
connection status should I just change
it not in Erlang homes everything is
immutable immutability takes a lot of
complexity out of concurrency and Erlang
super integral currency so it's going to
make you work for a living that's fine
but now we're in the handshake state and
the handshakes date is pretty cool it's
our first actual state name call back
because we didn't actually need one for
except at all except just was covered by
handle info and our handshakes data is
really simple right it takes this
timeout message in and then we're going
to deconstruct the the state a little
bit so we can grab the socket out and
the timeout message just comes
automatically from the fact that we
return 0 from that tuple with the handle
info call that we did before and all we
do here now is we're going to read 24
bytes off the socket it's HTTP too and
we know from the spec that the first 24
bytes have to be this binary string
right here PRI star HTTP to whatever if
it's not we're not an HTTP to connection
that we can just go home right now
because this is Erlang and pattern
matching and stuff if this thing is
equal to anything besides the tuple okay
PRI HTTP to this whole thing explodes
and it spits out giant error log and it
doesn't make any sense that it says
something like bad match and you know
there's a crash dump and everybody's
really upset and so we don't have to be
jerks about this we need to put this in
a case statement and say you know if it
matches this go to one place and if it
matches the other thing go to go to
closing let's talk about closing cuz
it's real easy it's where we clean up we
just have to function clauses there we
do a pattern match the deconstruction
again we say hey is this socket
undefined if it's undefined we don't do
anything that's not going to begin on
define what is there to clean up however
it is defined we're just going to close
the socket before moving on and stopping
to normal and we transition into
terminates that was it that was easy
right handshakes cooler though let's go
back and finish the handshake property
because it because there's more to do no
you guys can stay but HTTP to comes with
this thing called the go away frame and
what it does is it's a way of actually
turning the connection cleanly saying
you know what we're done we can't
recover something catastrophic has
happened so Jen fsm has a clean way of
exiting the jsm process HTTP two has a
clean way of exiting HTTP do connections
so we can actually write a function that
says we'll call this thing go away will
base it on the connection state we will
create a binary based on the spec to say
this is what the go away frame looks
like and then
send it over the wire after we send it
over the wire will go ahead and return
this thing at the bottom that Jen fsm
understands so we've got we got a 24
here right we have a way of telling HTTP
and Jennifer send bolt that it's time to
go home and so we go back to our hand
check it so you know what take this next
day closing business nonsense that we
don't really need to know about and
we'll just swap it with the go away call
and now we can exit both in an HTTP to
HTTPS way and a gen FS anyway and that's
pretty great but what's cool about this
now is that once we've gotten through
this part everything else is a frame and
we're just going to route frames and the
only difference between these states now
is what frames we can route but the good
news is if we're routing a frame it does
the same thing no matter what state were
in the only difference between these
states is which frames were allowed to
route so how do we write incoming Franco
I know how to read them so we've read
them we've got one in memory what do we
do with it well there are 10 types of
frames like I said before and but
there's really two different levels of
which they can operate the connection
level and the stream level but now
you're counting really quick and you see
there are 11 bullets up there what did I
do Joe what's going on well the answer
is their window update applies to both
types of frames are both levels of this
and then go away and reset stream are
kind of the same thing just once at the
stream level one kills the whole
connection and then you got these for up
here the headers push promised
continuation and data and these are the
ones that represent your semantics HTTP
requests and responses they all happen
to the stream level but then data frames
have implications at both the connection
and stream level because it's got to
keep track of all the flow control
credits it's easy protocols are fun so
yes we're writing frames and there's
more parts of the handshake including
all that settings handshake stuff that
we need to talk about the implementation
yet but the good news is because
settings handshakes settings exchanges
can happen at any time we'll all
implement that in this thing called
route frame it'll be a function that we
can call that I'll just route a frame no
matter what state were in and we just
happen to use it for the first time in
the handshake state so yeah so this this
clause right here this round frame
clause was pretty interesting right it
does absolutely nothing that underscore
their means you can even put a frame in
there you put anything in there and it's
not gonna do anything it's going to
return you the same state you started
with that's okay more shouldn't talking
about the spec thing the spec thing is
Erlang super weak type system it's got
to compile time type analysis and it
tells other developers sort of what we
expect so what it's telling you
is that we're writing a function called
route frame it takes in a frame and a
connection state and it returns this
thing that Jen fsm wants to see this
next state possibility states that we're
going into and then a new connection
state and a non-negative integer which
in this case always happens to be zero
it's fine so yeah so I mean you know you
know you're all type nerds here it's
fine so don't hate on my types they're
totally weak and they can't possibly
fight you so back to the protocol i
mentioned that each peer sends the
beginning frame again in the you know
handshake each time and we've got you
know settings frame going over but then
the spec says every time you send a
settings frame you need to get a
settings frame acknowledgement back
what's the settings frame
acknowledgement even it is a settings
frame with no body and an act lag set so
now that flags by it will save one
instead of 0 great so now i have all
these handshakes to handle but you know
route frame handles all these things
with with class right so it understands
how to do a settings handshake and i can
do it now i can do it later i'm not
going to show you it now because we need
to move on to streams and this isn't
really important right now so in the
connected state this is where the action
is right this is where we're actually
processing request at this point we have
an open connection we have a socket you
know just opening the sockets never been
easy we're just sitting here with
chillin with our open socket waiting for
frames and as as a server the first
frame i'm going to get on a new stream
is going to be a headers frame which is
not to be confused with a frame header
because boy reading the speck made that
confusing like use the same two words
and change the order and they mean a
completely different thing it was yeah
but on a new stream ID and a headers
frame means that this is the beginning
of a good old-fashioned HTTP request
just like mom used to make what do we do
with it well you know what whenever
we're running a frame we basically have
to decide whether or not we're at the
connection level or the stream level and
then once we make that decision we can
decide are we going to use this nice
colorful fsm over here we're gonna use
this know glee terrible ask you out of
Sam over here I like this one too but
yeah and then if you're a data frame of
course we have to do things based on
both both levels so you know we have to
maintain all of this in the state but um
let's talk about the connected state
really quick because the callbacks
actually really easy right the way we
built this thing we can just we get that
timeout message we're always getting
time out messages that's sort of the
thing I like least about this design but
I have a
and to fix that but for now we get the
timeout message and then we read one but
one payload off the socket then we're
out it this route frame is going to give
us a new modified version of the state
and it's going to give us this will not
modified right we can't modify things
we're Erlang it's going to be a newer
better stronger faster copy of the state
its evolution at its finest the state is
changing over time but we're getting new
ones and generations we're not changing
anything ever so I say change but I mean
new so yes we've already got some route
frames clauses here for settings
handshake so if you're in connected and
you get a settings frame you know what
to do with it and you just return this
tuple the genitive expects and we just
have to write a bunch more for all the
different frame types and we should be
done well I'm not gonna show you them
all my mind I can show you many more I'm
as much of you one more but let's talk
about the continuation state first cuz
it's kind of weird right so um H pack
introduced does this like encoding of
and indexing of things right and what
winds up happening is when it packs up
the headers it creates a binary block of
data to send over the wire and then we
decode that binary blocking the other
side and it was really small going over
and that's the whole point right if your
binary block of data is smaller than the
maximum frame size you have to break it
up into pieces and if you have to break
it up into pieces what if they come out
of order like all our index is all our
numbers that we're keeping track of like
if we get different headers frames and
different binary payloads for headers in
different orders we're going to mess up
our whole h-back encoding it's going to
be it's gonna be a bad time so what we
do is we have this continuation stay
this ID have a continuation frames which
is essentially a mutex to solve this
problem and what we're going to do is
we're going to say hey if you get a
headers frame and you don't have the end
headers flag set that means
continuations are coming so until we get
an end headers flag we are going to put
the connection and lock down and only
receive continuation frames and only on
this one stream until we get the
anhydrous flight making sure that we can
get no crossed wires when it comes to H
pack because each packet roads not
handle that well so yeah so the
continuation saves mutex us all this but
other than that we don't eat it in fact
we're not going to talk about it ever
again so back to the connection level
it's brand new HTTP requests imagine a
headers frame comes over the wire well
we got a lifestyle function Claus like
this to match it and what we're going to
do you see up there type equals headers
that's we're doing some record
deconstruction but we're not assigning
it to a variable actually assigning it
to a binary integer
which is whatever the type code is in
the in the spec for a headers frame type
so you know we are by nature a mighty
we've got the frame bounds of this thing
we got that we pull the DK code context
out 4-h pack but once we bind all these
things what we're really going to do is
we're going to create a new record
representing that ascii state machine of
the stream and then we're going to go
ahead and run this reference lee
transparent function over right so this
is the thing where we stick a frame in
and we give it a stream stay in a
connection state and you can modify both
not modify create new versions of the
state for each one for everything every
way that the frame affects it and I mean
that just looks like this right you
stick a frame an argument one is took
this tuple of stream state and
connection state and in argument to and
then you get back a new stream state and
a new connection state and you can
actually fold over a list of frames and
use this initial state as the is the
base accumulator so you just acute this
like state machine along you can
basically write these like unit tested
to say okay given like these 20 frames
and this start state of these two states
what comes out at the other side it's
pretty cool so on then the next thing we
do is we make sure that this thing
wasn't was an end headers flag or not
and so we do this case statement we have
this is flag macro thing I'll show you
in a second and basically if it's true
if this thing was end headers then we're
done we've got a complete complete
headers frame then we can use H back and
decode it whatever if it's false then
with then it's a continuation you know
we're off the mutex Berg population you
we're going and we're going to just
can't accept connection frames from
there on out now how we check these
things we actually run this this macro
here that there's a binary and to make
sure or to make sure that these flags
actually present and we need to use this
in a guard later otherwise we just
written our own function for it so yeah
look at this stream state thing it's
really complicated because they're
trying to encapsulate the server and the
client and push promises all at once so
let's take the client out of this
picture and we'll take the push promises
out of the picture now we have a nice
for state for transition machine that we
can talk about and I'll make it prettier
for you basically what what this is is
this semantic HTTP request inner lining
in HD be too it's made up of headers and
continuation and data frames only and
it's broken down into these stream
states where the request is complete
when you hit the half-closed remote
that's because the remote side of the
connection has told us it's not sending
us anymore then we can spin up a content
learn to create a semantic response and
we basically what's what's the request
is complete we take all the frames turn
them as an actual semantic thing process
them like real people with headers and
you know methods and bodies and stuff
and then turn them back into frames put
them back on the wire and we do that
with this spawn link command that Erlang
has and what that does is spawned up a
link process that will basically tell us
if anything went wrong and when
something went wrong we can handle it
with grace so this is the guy on what's
key to Erlang's let it crash philosophy
but how we apply here with the content
handler is we're going to say all right
create this do this spawn handle thing
with just like wraps an anonymous
function here and then use this high
order functions spawn link to take our
content handle or do stuff with it well
what's our contract content handler look
like you can make your own I made one
for static content which takes in a
process ID which is the gen server that
we're going to send messages back to the
stream ID that we're actually processing
and I headers and bodies and stuff then
when we process those we can actually
send messages back to the connection say
hey these are the semantic headers you
want to send back this is the semantic
body we want to send back it's up to you
to figure out how to decode encode them
in H pack and how to serialize them out
to you know binary is on the wire and
you know you deal with it so let's look
at a semantic HTTP request through this
machine right there for what paths that
I think you can take but they all look
pretty much the same and this is the
easiest one right we take this frame and
it's just a headers frame and it says an
end headers flag and an end stream flag
this is a complete single frame HTTP to
request it's probably a get or something
because there's no request body but this
thing goes straight into the half-closed
remote because it is done and we have a
function clause in our HTTP to stream
function that sort of handles this and
basically you know what this is saying
is if it's a headers frame then check
and see that it has both the end stream
and the end headers flag set if that's
true then we're done we have a complete
request and we can use H back to decode
it where we create a new decode context
because H pack has reindex everything
and now it's time to put that in the
state and said and then we spawn off a
new handler to do this response work in
parallel so every other variation
through this state machine is just a
variation on a theme which is a header
frame comes in and kicks everything off
we move into the open state then a bunch
of other stuff happens until we get the
end stream flag in which case we hit
half closed remote and
then yeah that's the third slide and
then we're done then we actually spawn
of a Content handler we serve our
responses and that's it I mean all the
action for a stream happens in half
closed remote as far as server
processing goes I have two minutes left
so on top of a push promise is really
fast I need a couple more api functions
to make it work I created I can create a
new stream record from outside from
inside the content handler and then i
can send a promise back which is
essentially like a simulated request
right i'm saying i know you're going to
request this before this eventually this
is what that request is going to look
like and then we can spawn a handler to
actually handle that serving that
request so we got this state machine i'm
going to pull out the open state now
because we're just dealing with promises
i'm gonna make it prettier because i
like to do that and then we're going to
talk about the push promise frame so
when i read an HTML i see that you need
this CSS script or what i'm going to do
is I want to say okay I promise you this
CSS strip your stream end but I'm going
to deliver the CSS script on stream and
Prime so then I sent headers out on m
prime you know this is a by 200 my
whatever it is and then and then I'm
going to start sending body data back on
m prime so all the stuff comes over on M
Prime and by the time this the client
even knows to ask for the CSS you it's
already sitting there waiting to be
processed you've already got it that's
pretty cool um yes so guess what I'm
probably at a time I have so much more
to say I have so much more to do but
let's talk about one well really quick
the binary pattern matching was great i
highly recommend trying it on spawn link
on the content handler i added
concurrent response streaming you know
for multiple streams up in like two
hours once i realized that i didn't add
it bum you know in the original design
the OTV supervisor was great Jen fsm
lived up to its rep as being great for
protocols Erlang socket library was easy
to work with although some of it not as
well documented as i would have liked
thank you so much i really did learn so
much doing this I had such a great time
you know so much I haven't talked about
that slack channel is open you know ask
me questions come talk to me about this
I've been spending so much time over the
last year working on this that I just I
want to keep talking hopefully I mean
HTTP to end or early a little bit more
accessible for you and man strains lube
go on</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>