<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;End-to-end encryption: Behind the scenes&quot; by Martin Kleppmann, Diana Vasile | Coder Coacher - Coaching Coders</title><meta content="&quot;End-to-end encryption: Behind the scenes&quot; by Martin Kleppmann, Diana Vasile - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;End-to-end encryption: Behind the scenes&quot; by Martin Kleppmann, Diana Vasile</b></h2><h5 class="post__date">2016-09-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oRZoeDRACrY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody thank you for coming in
this talk we're going to have a bit of
live action and props and so if you want
to be able to see better you might want
to move a bit closer towards the front
so feel free to get up and move towards
the front few rows if you like so I hope
you're having a great strange loot my
name is Martin clapman
we're both researchers at the University
of Cambridge in the computer lab our
work mainly involves an - an encryption
and even though that's been around for
decades it's only now starting to make
its way into the mainstream with these
messaging apps like signal or whatsapp
which have actually started using
signals protocols so this is part of a
project we call true data and you can
see that we're cool because we spell
true with a V instead of a u just
kidding we're not cool at all and so
what we're trying to do in this is bring
in to end encryption to a much larger
range of applications so we have it for
instant messaging and email and stuff
like that but actually what if we could
make something like Google Docs and to
end encrypt so that we don't have to
trust Google servers that's the kind of
thing we're thinking about here so it's
still at a very early stage and if you
want to find out more about the project
you can find some information at true
data talk so when someone tells you
their application is secure what they
really mean is they're running HTTPS so
that's running HTTP over TLS or SSL
which what it truly does is make the
end-user devices trusted and also the
server they all of these see the data in
an unencrypted form and while it's in
flight it's encrypted
the internet then is treated as a big
unknown it with unspeakable forces of
evil so you can imagine you're you know
you're connected to a coffee shop Wi-Fi
hotspot and you want to go onto your
mobile banking app so you're fairly sure
that nobody's gonna steal any money from
you while you
transferring money across devices
because even though the coffee shop
owner and others can see your internet
packets throwing to the Rooter they
won't really be able to interfere with
them now we put all this data into the
cloud but just a friendly reminder there
is no actual cloud it's just someone
else's computer and when you're using
stuff like Google Docs Evernote Facebook
or any other web web app what you're
really doing is trusting these service
providers with your sensitive
information so we do not want to praise
placed as much information into these
service providers because what you
really expect from them is to protect
your sensitive information to not allow
any unauthorized access to it what we
really want with end-to-end encryption
is ciphertex all throughout from the
end-user device to another end user
device and the server's cannot see the
text this way we treat both the servers
and the Internet as untrusted the best
example to start off with would be PGP
witching attempts to encrypt emails and
files it's been around since the 80s but
it's very well known for its usability
problems we won't go into the very deep
details of how it works but we'd like to
talk a bit about the basic cryptographic
primitives it uses so the best one to
start with would be RSA again we will
gloss over the mathematical details but
we want to make sure we're all we all
understand each other on the
mathematical notation so now first of
all you might be familiar with the
concept of public and private key
cryptography we've seen that a lot and
RSA is one of the examples that uses it
now when I say we choose the proof
meaning the private key and epub D is
actually
supposed to mean Deanna's private key
Indiana's public key just so we're
certain we choose these numbers such
that in certain mathematical sets when
we multiply them they give the result
one so according to a modular two
exponentiation and modular arithmetic
when we take a number m and we raise it
to the power of deep hub my public key
and then raise this result to the power
of the proof what it really means is we
raise the m to the power of the pub
times t proof and those multiplied are 1
so we get back the message the good part
about RSA and why it really works is the
the success exponentiation is really
very hard to tell to reverse thank you
so it would take actually millions of
years for someone to calculate once
you've taken m to the power of the pub
even if they know D pub it's very hard
for them to get and back they would
really need to know the proof so we keep
our D pub public and private you want to
keep your D proof private now let's look
at how PGP actually uses this usually
when people talk about cryptographic
algorithms they talk about Alice and Bob
but we're not Alice and Bob so we're
gonna talk about Deanna sending an
encrypted and signed message to Martin
in order for me to encrypt this message
what I really do is take a hash of it
and raise it to the power of Dupree of
my private key I didn't send it along to
marching together with the actual
message on his end he can check that the
signature equals the hash of the message
what he really does is take the actual
signature raise it to the power of my
public key because that's public he
knows that and he gets this this number
which is supposed to be the hash of the
message he then takes the message and
raise the hashes it and checks that the
to match if they do he's then content
that I actually are
so the message and can be sure nobody
else wrote it so we'd like to make this
a bit more tangible by actually acting
out on stage so we'd like to do a live
demo and not a live demo on computers
but a live live demo with live human
beings and for this we'd like to welcome
my friend Sam Stokes to the stage please
so the scenario is going to be as
follows Deanna wants to send an
encrypted secret message to me and she
has to do that via a network and Sam is
going to play the role of the network
today so messages can only flow via Sam
I can't talk to Deanna directly and the
network is going to work quite reliably
but occasionally it might turn out that
the network is a little bit evil and and
so the network may corrupt messages or
it may replace one message for another
and we'll see what interesting things
happen when we do that so let's start
with a PGP example so as we said each
person running PGP has some key pairs
there's a public key and a private key
in my case my name is Martin so my
public key is M pub my private key is M
private and I also have Diana's public
key because that's publicly known on the
other side she has her own public key
her own private key D probe and she has
my public key in red and finally Sam has
both of our public keys because he can
just find them on the internet so now
let's run through this protocol that we
had on the slide as well so let's say
Deanna wants to send this encrypted
message
dianna already explained how the
signature works let's go through the
encryption so to encrypt she first picks
a random number K just generates that
randomly and she then uses a symmetric
cipher to encrypt that signature and the
message on that key K so a symmetric
cipher is not the private public key
type but one where the sender and the
recipient need to know the same key K so
a EES would be an example of a symmetric
cipher for example and so once the
message is encrypted under this K using
ek
you get see which is the ciphertext and
now Deanna has to send that ciphertext
along with an encrypted version of Kay
to me and so to generate that encrypted
version of Kay she raises K to the power
of my public key M pub and she then
hands that message to Sam who then
delivers it over the network to me but
in the process Sam may copy the message
he may look at it there's nothing
stopping him from taking copies of this
message so he can sneak le pack away a
message for his own records and store it
in a big data center somewhere and then
deliver it to me thank you so now I
received this message and you can see
it's got here K to the power M pub and
now I can reverse that encryption so I
can take that to the power of my private
key which I have here M Prive and I get
back K or I get ke to the private x
public which is K to the one which is K
and now I can put that through the same
symmetric decryption function because I
now have K I can get DK is the
decryption function I get back the
signature and the message I can now read
the message and I can check the
signature so that I know it was really
genuine coming from Deana so that's
quite nice and it looks in fact as
though we've achieved our goal here of
end-to-end encryption because you know
Sam wasn't able to do anything with that
message he couldn't tamper with it he
couldn't read it but still people are
saying that PGP is not really the ideal
so cryptographer Mathew green for
example compares PGP to this visiting
this museum of 1990s cryptography and
somewhat true because cryptography has
developed a lot in the decades since
then but PGP and GPG it's a
implementations haven't really kept up
with all of those developments and so
what we'd like to do now is demonstrate
some of the problems that occurred that
in particular think about what happens
if Diana and I are exchanging messages
over a long period of time so over the
course of years we exchanged lots of
messages and so some as he delivers
these messages can record lots of cipher
texts
lots of encrypted keys and she can keep
a log of all of those and store them
away for future use but now think about
what happens if that private key that I
have here if that ever gets into the
wrong hands so for example if some
manages to curse me in some way or he
manages to somehow install malware on my
device and gain a copy of my private key
what happens it's a disaster because now
using that he can take any of those
messages he recorded in the past and he
can decrypt them he can take that all
all that log of all of the messages that
ever happened and he can now find the
plaintext so that's a bit of a problem
the loss of a private key in this kind
of setup here is catastrophic and so
we'd like to do better than that some
way that to make loss of a key less
catastrophic so what we really want is
for keys to self-heal when you see a
kick gets gets compromised it wouldn't
really affect them over a long period of
time this is really provided by a
property we call forward and backward
secrecy which allows keys to only be to
only generate messages that may be
vulnerable for a short period of time a
good example using this is
diffie-hellman another cryptography
algorithm it was again developed in the
70s but in 2015 their authors received a
Turing Award let's look a bit at how
that works out
so we have these public constants P and
G which we choose according to some
mathematical rules we'll gloss over now
when I want to send a message to Martin
I choose a random number X here and then
I send to him G to the power of X using
Sam's help
thank you something
now when Martin gets my G to the X he
knows it's time for him to start the
protocol so he chooses his Y again a
random number that he keeps secret and
then sent to me back G ^ y C even though
Sam can see these messages he can't
really figure out what we're gonna do
with them because he cannot reverse the
exponentiation when I get G to D Y what
I can really do is work out a symmetric
key so it will be raising the power
raising G to D Y to the power of X
Martin can do the same on his end and
because the operations are committed e
we get the same key now if I want to
send an encrypted message to Martin I
just used the symmetric cipher we just
created and send it and he can then
decrypt it on his end using our common
shared secret K so this is all nice and
good we can see that it gives us a way
to send messages to each other again
securely over the network but it doesn't
really yet provide forward secrecy does
it what we really want is for us to roll
forward the keys and we can do this
because we choose this X and we choose
the Y and then once we've calculated our
key we can actually discard the X and
the y so you can imagine imagine in this
context I've chosen my x1 sent it to 72
the x1 - Martin he's chosen his y1 sent
it to me we generated the key and then
when I receive it I can generate the
next number along so I can generate x2
and get a K - you back and the only
difference is together with my encrypted
message I'd be sending G to the X - -
Martin so he can calculate the key to
him and so on and so forth this is
actually called a ratchet and it's used
in some protocol it's used as a base in
some protocols like signal and what
so as we've described it so far
diffie-hellman is is really excellent
because it allows us to do this key
establishment without having to agree on
any private area in advance but there's
still a problem here
while two problems actually with
diffie-hellman that I'd like to talk
about the first one is what happens if
the AMA wants to send me a message while
I am offline and so if you recall the
way that we described the protocol just
now
Jan has sent me due to the X I have to
reply with G to the Y and only then
Deanna could compute that K in order to
encrypt the message and send it to me so
that requires me to be on line for her
to even send a message that's a bit
annoying if there are devices that are
communicating I'll say mobile phones
which are offline all the time it's not
a big deal if it's a client talking to
its server when the server is always
online but with mobile devices we have
to think about this offline problem
fortunately there is quite a simple
solution to this problem and it's called
pre Keys and it's used again in signal
and whatsapp for example and it's based
on the observation that this G to the Y
this that I computed doesn't actually
depend on Deanna's G to the X in any way
so I can do this computation of G to the
Y ahead of time so I can calculate a
supply of random numbers Y and keep them
secret and I can calculate G to the Y
for all of those I can upload them all
to a server and the server can store
them on my behalf
and since these due to the wire not
private it's OK for the server to see
them and now when Dianna wants to send
me a message as before she chooses a
random X button rather than sending G to
the Y directly to me
she bears G to the X to me directly she
downloads one of my cheated wires from
the server and then she can actually
immediately calculate the shared key K
by taking the value from the server
exponentiating it to the power of her
secret value X and then sent me the
message encrypted under that K straight
away and sent along with it G to the Y
so sorry G to the X and if I'm still
offline at that point
that's okay that can sit on a server
again but there I have all of the
information when I come back online I
can fetch that G to the X and the
encrypted message from the server I can
calculate K from the G to the X and the
y that I saved previously and thus I can
then decrypt the message so this is
quite nice it allows the messaging to
work while offline the other problem
with diffie-hellman is a bit more tricky
and that is if you look at this we've
moved back to the traditional form of
diffie-hellman here so G to the X G to
the Y as before in this protocol here
there's nothing ensuring that it's
actually really Diana and Martin talking
to each other so there's the risk here
of what is called a man-in-the-middle
attack and that works as follows you can
imagine when Sam the network is talking
to Diana he can pretend to be me and
without any authentication of who's
really going on he can impersonate me
quite convincingly and Diana will
happily do a key exchange with him and
on my side similarly when he's talking
to me he can pretend to be Diana and I
wouldn't know any any difference than
that I'm talking to Diana here so let's
look at how that actually works in terms
of mathematics in terms of mathematics
we start as before Diana chooses a
random X calculates G to the y sense G
to the Y over the network now oh sorry
calculus do you see X sends G to the x
over the network
but now the network rather than
delivering that G to the X to me Sam
actually keeps that for himself and what
he does is instead he calculates his own
random value W in orange and he
calculates G to the W and G is public so
that's easy for Sam to do and now he
forwards
G to the W onto me and so when I
received this from Sam it looks to me
exactly like a message from Diana
because I wouldn't be able to tell the
difference and likewise sam takes that G
to the W and also delivers it to Diana
and to the Anna this looks like my reply
it looks like
my G to the Y however see what happens
now so when I received this G to the W
from Sam I think oh it's a request for a
key exchange coming in from Deana so I'm
going to do the usual I'm going to
calculate a random why I'm going to do G
to the Y as before and I'm going to send
G to the Y over the network towards
Deanna but now again Sam does not
actually deliver it to Deanna as he's
supposed to instead he keeps it once
again and remember he previously sent G
to the W to Diana so Diana already
thought that was my response now look
what what happens here
so I receive G to the W from Sam and as
part of the usual diffie-hellman
protocol I took it to the power of my
secret why and so I calculate this K 2
which is G to the power W wife on the
other side she received G to the W from
Sam calculates up to the power of her
secret X and now she gets a K key k1
which is K sorry G to the X W and now
Jana thinks she says this key with me I
think I share this key with Jana but in
fact we both share it with Sam so Sam
can actually because he received the G
to the X from Deanna and he received a D
to the Y from me and he has his own
private W that is just for him he could
actually calculate the same k1 and k2 so
in fact we share the keys with Sam not
with each other so what this means now
is if we want to actually send an
encrypted message the Anna takes a
message encrypts it on the k1 and sends
it over the network but now some can
intercept it again and because he has k1
he can decrypt that message you can read
it you can even tamper with that if he
wants and then he can re-encrypt it
under k2 under k2 and then pour that on
to me and to me this looks like a
perfectly valid message that I received
from Deanna I wouldn't know
in fact some whose tampered with the
message and read it along the way so
this is a really big problem and in the
rest of this talk we'd like to talk
about some of the solutions we have for
solving this man-in-the-middle problem
but first can we say thank you please to
sound for being our excellent Evo of
man-in-the-middle okay so one of the
ways to actually solve this problem is
to do an authenticated key exchange we
can look again at the way we signed
messages in PGP so that's really
certified that I sent a message to
Martin right well can we apply that to
to our defeat how many key exchange
let's see Oh before I before I move on I
need to mention what in our case what we
really see is a cryptographic proof that
I authored the message I myself
owner of the proof or even someone who
knows they prove let's look again at
diffie-hellman which is our exes and our
wives we did we create our secret key K
and now I want to start to also append
the signature to my message before
sending it please note this is just a
way for us to demonstrate how we would
append signatures but it's actually
broken so don't try it at home
I now hash my message raise it to the
power of the proof and then encrypt the
message appended with the signature and
send it along to Martin he can recruit
it on his end just like normal
check that the signature message matches
the hash of the message that's all good
right but it doesn't really authentic
ate the key exchange per se because the
key exchange can still be
man-in-the-middle by my son this is
really a problem with what we mean by
authentication in real world well well
we're talking now to you we're on the
record we're being live captioned and
recorded we really have to take care of
what we say not to
offend anyone not to say anything stupid
but it's a completely different story if
you're coming tonight at the bar and you
talk to us we won't be recorded it will
be an off-the-record of communication so
while you speak to us we may be more
friend more honest about our opinions on
cryptography or anything else for that
matter we may say something stupid and
when you want to tell someone what we've
said unless you've recorded us in which
case we won't be very happy you can't
really prove to anyone that we really
said it what you can say is word of
mouth and your friends may choose to
believe you or they may choose to think
you're telling lies this really applies
to the cryptographic algorithms we're
showing here with digital signatures
what you get is that cryptographic proof
that I also heard the message and
absolutely anyone who knows my public
key can check that I authored the
message in the case of contracts that's
nice and fine because every one you want
a permanent proof that I signed
something and you want that to be on the
record forever but what happens if you
want that for informal chats you still
want to know who sends your messages but
you don't want someone to be able to
show the outsider the outside world what
you've said so you want this property of
deniability can we really achieve that
one way we can do that is with something
we call message authentication codes
we're showing here the hash based
version of it
what message authentication codes
actually mean is we take a message
and we hash it as you can see in this
case we hash it twice and that's because
of otherwise we'd be leaving ourselves
open to some vulnerabilities but the
good thing about it is once I get my
message also get my shared secret key I
put it through the math calculator get
this number M which is my code and said
that along together with the message to
Martin
his end he can take the message again
and the key take it through the Mac and
then verify that we get the same message
because we're in a two-way conversation
and both of us know the shared secret
when he receives a message that's been
authenticated with a Mac code he what he
really knows is someone with the
knowledge of K has authored this message
that's nice and fine for him because he
knows he did not write that message so
in this case it could have only been me
so that's one way of authentication
but even if he turns evil and wants to
show the world what we've been talking
about there's absolutely no
cryptographic way for him to show that
it was actually me and not him we said
the offending message so just to recap
digital signatures you want that for
things like contracts you want to
certify that someone only that someone
who knows the private key has written
the message and anyone else can check it
whereas with H Mac we get both
authentication and deniability we know
that only the person who shares the
secret K has written the message and
only someone who knows this K again can
verify that it's it's been written by so
we were talking earlier about this
problem of the one in the middle on the
diffie-hellman key exchange now that
we've covered digital signatures and h
max we can talk about how this would
actually work so let's talk first about
the actual message sending part of it so
this is exactly like Diana just
described you would encrypt once you
have established some shared secret K
you can encrypt a message under that's K
the ciphertext C is sent over the
network
along with an H Mac under K along with
this authentication code and that proves
that the message has not been tampered
with and that the message came from
someone who knows K so thus helps
authenticating this particular message I
can on my side when I receive it check
it and decrypt the message given that I
know K but it still boils down to this
problem of needing to securely establish
this chair
secret K in the first place so I'll run
through an algorithm that does precisely
this so this is an extended version of
diffie-hellman it's called the Sigma
protocol where the sign stands for sign
and Mac it's something that's used in
the OTR chat protocol the off-the-record
chat protocol for example I believe it's
also used in some IPSec VPN networking
exchanges so this is something that is
actually used in practice it's a bit
more complicated so I won't go into all
of the detail of exactly why it works
but I'll just give you the flavor of how
it works so we start in the familiar way
you've seen the drill by now
Deana chooses the random X sends G to
the X of the network to me I choose a
random Y and I calculate G to the X that
I got from Deanna ^ my Y and then I hash
it in order to derive this secret K so
now this is where we bring in the
authentication part now I don't just
send G to the Y back but I also send
some additional stuff
I send my public key M pub and then I
sent this it's like a more complicated
expression so I take the G to the X that
I received from Diana I take the G to
the Y that I'm sending back to Diana and
I take my public key I concatenate all
of those so that's double line there
means concatenation I do an H Mack over
all of those under this K because I
calculated the cage as two lines above
and then finally I sign that H Mack
under my private key so it's not really
obvious why this works and we don't have
time to go into the detail so I think
you'll just have to take my word for it
and read the paper if you want the full
detail it's referenced at the end I sent
that over to Deanna and Deanna can now
check the signature because she has my
public key and she can also check the H
Mack well first before she can check the
Mack she has to calculate K but she can
do that given the G to the wide it was
sent now she can calculate K she can
check the H Mack and then she can
respond herself because so far Deanna
hasn't yet proved to me that she's
actually the right person so now she
sends her public key and the similar H
Mack and then sign construction back
over to me and so this I can
then check I can verify using a public
key that it matches the signature and I
can check that the H Mak matches the K
that I derived previously and if all of
these checks succeed then we know that K
is shared only by the two of us and that
there hasn't been any man in the middle
so this is great and this works once
this is done we have mutual
authentication between the two of us and
the shared secret but there still
remains this elephant in the room
question do we actually have the right
public keys for each other because that
is unfortunately the problem with a lot
of these cryptographic systems that
humans can't really remember public keys
very well because they're like yay long
and consists of lots of hex or base64
digits and they're not really convenient
to exchange you can't even print them on
a business card very easily if people
don't like comparing strings of hex
numbers definitely not typing them into
a computer so you need some kind of key
distribution system whereby for example
I can look up the Anna's email address
and find a public key and Diana can look
up my phone number and find my public
key and so we call this a public key
infrastructure and you've already used
this if you've ever set up a server an
HTTP server with SSL support you will
have generated a private key and then
bought a certificate from a certificate
authority or maybe used let's encrypt if
you're new and fancy and what you've
done there and this process is
established a binding between your your
domain name and your public and private
key pair so what the certificate
authority does is it checks that you the
owner of this public key are also the
owner of this domain name and if that
check is successful the certificate
authority signs this declaration saying
that deist the key and this domain name
belong together and now this allows you
to show to anyone else that actually
when you're doing this key exchange this
is actually the correct domain name that
they're talking to this is not only used
for the main names it also works for
people so if you're using iMessage for
example then there'll be some kind of
concept of Deanna's I did
and she might have her email address so
she might have a phone number associated
with this for example an iCloud account
and then public keys for various devices
and so these are all held together in
some kind of binding and there are a few
ways of implementing this kind of
binding so I mentioned certificate
authorities already which as I said is
used for DNS domain names it's also used
for client certificates to identify
people sometimes so I believe for
example the Estonian government has a
system of ID cards whereby which is used
by a lot of government websites and
utility websites where every citizen can
prove their identity using a TLS client
certificate so the stuff is sometimes
used in practice then the next option is
to have some kind of key directory which
is basically a database where you can
query by an email address or a phone
number and get back to public key and
this is the model on which iMessage and
signal and whatsapp abase key base is
doing kind of interesting variation on
this model and then finally well as the
always the option of checking things by
hand
so with PGP people got very excited
about this idea of a web of trust where
you would have key signing parties where
people check each other's passports and
then sign each other's keys and then
there would be some kind of mutual trust
relationship between everyone involving
manual checking of fingerprints it's
kind of a neat idea though I can't
really Ramallah than a very geeky group
of people actually going to that effort
of checking fingerprints so in practice
it seems like certificate authorities
and key directories are a pretty
sensible way of implementing this
finding between some kind of human
friendly identifier and the public key
however the problem with these
authorities and these directories is
that you have to trust them because
again it's the certificate authority
that is issuing this binding and it's
the whole system only works if you trust
that the certificate authority is doing
this correctly and likewise with the key
directories if somebody manages to
convince Apple or manages to hack into
Apple and add a new public key to
somebody's account
or the same of course for any other of
these encrypted systems well the whole
thing falls apart because then that
person can identify as sorry that the
attacker who registered that public key
can now identify as a particular person
and just do anything so we need when we
have these kind of authorities we need
some kind of ways of keeping them honest
and there are a few interesting pieces
of work happening in this area so Google
is pushing this project called
certificate transparency which handles
to a certificate authority case where
certificate authorities need to issue or
need to register in a log all of the
certificates that they issue and this
provides an a publicly checkable audit
trail of what certificates have been
issued and if any fraudulent
certificates are issued or any
accidental Mis issued so if somebody
gets a certificate for domain name they
don't actually own then that will
actually show up in a record and so this
doesn't prevent bad behavior of
certificate authorities but at least it
keeps them accountable and allows the
public to check if something has gone
wrong here key basis as I mentioned has
this interesting thing of proving
ownership of social media user names
using proofs I don't know how well that
will take off in general beyond the
geeky early adopter audience but it's an
interesting idea one thing we are
exploring and in fact Deana is working
on in her research is to use gossip
protocols for exchanging key material
under the assumption that then it
becomes harder for an attacker to
totally compromise the system at least
without being noticed
so they would have to then you can use
the the gossiping as a kind of
back-channel to check whether some key
directory or some certificate authority
really is being honest so let's recap
we've covered a lot of stuff here we
talked initially about PGP which as we
discussed has usability problems but
also more fundamentally has this problem
that any key compromise is catastrophic
anyone who gets hold of a private key
can decrypt all message
past and present and future so we talked
about defeating man and ratcheting key
ratcheting as a way of providing forward
and backward secrecy
that's diffie-hellman is quite nice but
there were some problems to solve there
as well the first one was the problem of
sending a message to someone who's
offline for which we had their quite
neat and simple solution of pre keys the
bigger problem is that of
man-in-the-middle we didn't have
authentication so we talked about the
Sigma protocol for doing an
authenticated diffie-hellman key
exchange but all of those things still
rely on some way of actually knowing the
correct public key for someone and of
course PGP already had that problem as
well and it's looking like that problem
is not really going away as we said
there's some kind of attempt to keep
authorities honest there are other
problems like what happens if somebody
loses their private key loses their
phone how do they recover from this
situation in some way that actually
doesn't compromise the security of the
entire thing but I'm afraid that might
have to be a topic for another talk
because we are getting short of time now
so I will leave you with two pages of
references or really there's actually
really good reading material there we've
put this on the website already I'll
tweet a link to the slides and then you
can find nice links to all of these
finally can I just insert a little
advert break here so this book that I've
been working on for far too long and is
now almost finished but not quite I will
be giving away some like pre print
copies of the first few chapters
tomorrow at noon at the O'Reilly booth
downstairs by the main entrance so if
you'd like to come past you can find it
otherwise you can find it online at
data-intensive dotnet so thank you very
much for coming to our talk I hope you
got some ideas about how these
cryptographic protocols work and how
they can fail in interesting ways and if
you'd like to ask any questions I
suggest that you come up to us we'll be
here for the rest of the conference
but I think we'll make clear for the
evening keynote now thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>