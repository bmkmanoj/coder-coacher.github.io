<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Running Programs In Reverse for Deeper A.I.&quot; by Zenna Tavares | Coder Coacher - Coaching Coders</title><meta content="&quot;Running Programs In Reverse for Deeper A.I.&quot; by Zenna Tavares - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Running Programs In Reverse for Deeper A.I.&quot; by Zenna Tavares</b></h2><h5 class="post__date">2017-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JnonBxKKZsg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everyone my name is Jenna
Tavares I'm an MP a graduate student MIT
and today I'm going to talk about this
project let me be working on for a while
and it's about running programs in
Reverse and so this is what welcome to
my advisor
Amanda salad Osama and my collaborators
Lawrence Edgar and Xavier so this tool
is divided into sorry it's tool divided
into three parts
in the first part I'm gonna give you
some science some psychology experiments
that people have done over the last you
know 30 40 years and it's really about
this idea of mental simulation and as
the name suggests it's about how you
simulate things in your mind and then
I'm going to give some theory about an
approach that we're developing which we
call parametric inversion which is about
running programs in Reverse and then I'm
going to show you some code and the
framework that we're working on in the
Giulia programming language so in part
one I'm really going to try and throw
the case and the case on burden is for
this idea of mental simulation so I
really want to convince you of three
things really one that there's a large
body of experimental evidence which
suggests that mental simulation is a
core part of human intelligence and two
that in order to build AI that's more
general than the aya we have at the
moment we're going to need to emulate or
copy this idea of mental simulation in
machines and three that is a really hard
problem so as far as I know the first
study which you know as approached is
quantitatively was around in a wasn't
around 1970 and rather than Tory the
experiment we can actually do the
experiment here live so in these two
holes in the next slide you're going to
see two geometric like objects Lego like
objects and I'm even this they may be
the same object but from slightly
different or very different orientations
or rotations or they may be
geometrically different shapes and so
what I want you to do is when you see
the objects as soon as you're sure just
shout out same if you think are the same
or different if you think they're
different make sense okay so
same or different same of as I see the
same object yeah different rotation same
or different
what's the thing some some uncertainty
all right it is the thing what you will
do one more same or different
different thing same
so I think we can say this one is
different I think it's different I
didn't do this study and so they did
this with I think 1600 people and I shed
them many more examples and they did two
things one day you know precisely varied
the displacement and rotation I'm so
some of them were very similarly similar
rotations are the world a much more
different in terms of rotation and also
they measured the response time how long
it took people to learn sir the query
same or different and they found a
linear response and so what this means
if you don't know what linear means it
means that if I double the angle of
rotation it takes you twice as long to
answer the query on average and as you
can see is that these are these
handlebars they represent the variance
so as you increase the angle people
become you know there's more the the
correlation is less tight but as far as
psychological experiments go this is a
very tight correlation and so this led
to a whole like kind of sub sort of
similar experiments so for example some
people call this mental I mean it mental
animation has a kind of you know more
general more general concept and so I
can ask you you know if I rotate these
two gears in words or the knob on the
left hand side mesh with the groove on
the right hand side yeah probably right
if I give you two glasses of or you know
different diameters but fill to the same
height and I tilt them which if any will
the water come out first any idea saying
I'll leave you to think about that one
and if I let go of this you know I let
go of the free end of the system
well the lowermost pulley would it
rotate clockwise or anti-clockwise so I
don't know actually the answer to this
question I don't but but I have you know
they did a similar paradigm they asked
people these questions they measured
their results in terms of response time
and sometimes where they look in terms
of the scene and they put up more and
more evidence that the way that people
answer this question is the way that you
probably feel that you're answering this
question right you look at the image you
do some kind of simulation of the thing
in your mind and then you use that to
answer the question so you know I think
it's kind of cool so but why am I
talking about it and why am I talking
about it here at strange dude um so the
reason the reason it's important from a
psychological perspective is because it
provides no concrete evidence for a
psychological concept but can we make
this idea of mental simulation more
precise and so let's use some philosophy
so in 50 years prior to this prior to
any of these experiments a philosopher
who is often my creditor that credited
as the founder of of this idea you know
he put it like this he said if the
organism carries a small scale model of
external reality and of it's impossible
actions within its head it is able to
try out various alternatives conclude
which is the best of them react to
future situations before they arise and
in every way we act in a much fuller
safer and more competent manner and that
sounds like a a good thing right
and before here my physicists hurts you
you may have heard of he was thinking
about the same thing and he said we make
for ourselves internal object internal
images of symbols of external objects in
such in such a way that the consequences
of the images that are necessary and
thoughts are always the image are always
images of the consequences of the
depicted objects that are necessary in
nature we can quickly develop from them
as if from models the consequences that
in the external world will occur only
over an extended period or as a result
of our own intervention and so what they
you know what they'll basically get into
is
the idea that you look at the world you
put a model of the world in your head
then you you interact with that model
you simulator you intervene were there
and if the model corresponds to reality
in the relevant ways you can use the
results of the simulation to answer
things about the real world so this is
something that you probably all you know
you feel like you do but it's still a
remarkable capacity that we have and so
my version much more recently stated
it's the reason about the world simulate
it and interrogate the results of your
simulation and so one of the reasons
that I can state this more succinct Lee
is that I'm relying on the fact that
everyone here has some idea about
simulation because we've had 40 years of
computer simulation right which wasn't
true 70 years ago and certainly not 120
years ago so this leads to an idea of
how we can take this experiment to work
and bring it into a kind of a
computational domain right and this
comes under sometimes I had enough
computational cognitive science which is
trying to use maths and and programs to
analyze how the program analyze how the
mind works in very precise ways and so
the first study that I know which which
which which did this it really came from
peter pettalia who is at MIT is now at
deep mind in london and he made an
experiment so it's a similar kind of
setup you have a tower of of Jenga
blocks like things and he asked people
does he think that how the tower was
stable or will it fall over for example
and he said if you think it's gonna fall
over in which direction so he had a
similar experiment paradigm but he also
modelled the thing and so he built a
model of this problem and the model is
what what we sometimes call it a noisy
Newton model and it's noisy because
there's intrinsic uncertainty in a
domain right so when you look at this
block of towers you don't know precisely
where the objects are you don't know
precisely what their masses are you
don't know precisely what their friction
coefficients are and these are the you
know these are the piece of information
that you need to simulate this model and
so what they do is they sample from a
from a distribution a publicity
distribution of values so for example in
one in one case you know maybe the mass
of a brick will be a hundred grams in
another case will be a hundred and five
grams and so once they sample the
then they run a normal physical
stimulation the kind of you find in the
in the game engine for example and so
you run many of these simulations each
time with a random initial state not
arbitrary but random from some
distribution and you see you get many
different simulations and you collect
the you collect the results of your
simulation and you use that to answer
the query so this is their model of how
you they think you're doing it in your
mind and the results show you know again
a strong correlation with with humans
and so it it's it's a good correlation
in the sense it makes the same mistakes
as humans make it's not always correct I
saw that so it's a great paper I
recommend you read it but the idea here
is that you have a you have literally
something like a physical simulator in
your brain so just to go back a little
bit at my statement one thing that's
different about how I put it versus like
RIKEN hurts is that I say sorry I don't
have organism far don't have humans I
don't have we and I've left the subject
of this sentence
no missing because I'm also interested
in AI and I think in order to build
machines that can really reason about
the world they're gonna need to have
some kind of Faculty of mental
simulation so I gave a toolkit strange
leap a couple of years ago and I said
you know my goal is to build come on the
day to write some Star Trek I still
haven't thought data yeah but if but I
find data a you know a grounding target
because you know data's known for two
things one he's super smart super
intelligent and also he has no emotions
but for me the most remarkable thing
about data is that he can interact with
the out you know with the normal world
with the number world very freely he can
pick up objects examine them you know
he's similarly built or maybe somebody
helped somebody else about this model so
dated to act in the real world he has to
have an intuition about the physics and
the dynamics of the real world in order
to pick up things manipulate things
these are the really the hard things of
intelligence so maybe maybe we're done
maybe we can take this noise mutant idea
get our best physical simulator put it
in data's brain and now data can answer
questions about the physical world
right and so maybe we're done mission
complete
mission accomplished right so the reason
is is obviously not so simple nothing
simple as many problems one what if the
how do we get a simulator that's
accurate what if there's a disparity
between the simulation the simulator
world and the real world also isn't a
simulation overko you know if I don't
need to simulate this example the blades
of grass and the bottom of a cliff to
know that it's not a good idea to jump
off a cliff so they're all these hard
problems of simulation but I still think
there's some intrinsic value to the idea
so there's one problem particular I've
been working on and it's a problem of
causal inference so here again we have
it we have a block of of a giant sorry
Jenga tower but in contrast to the
previous example you can look at this
example and you can think about what
happened before right
so in some sense you can do a kind of
inverse simulation you can say well I'm
looking at this book it looks like it's
falling over and maybe a few moments ago
it was upright and so somehow you're
going from your observations of the
world backwards through your simulation
or backwards through time to figure out
what is the cause or what is the state
forward what I'm seeing another example
where this pops up is in when we need to
manipulate the world so has a robot
called P or Q and is holding some
clothes and folding clothes is a very
difficult thing because you need to know
about the dynamics the texture all these
things about the physics of clothing but
it's not like you can't just simulate
the world and hope that somehow in your
simulation the that the clothes end
up folded right you have to say what do
I need to do how do I need to interact
in this world to get to some desired and
stay in this case have my god my clothes
be folded and so I would argue that both
of these examples really they require
kind of inverse stimulation going
backwards from either an observation or
a target backwards to some input right
either caused or what should I do to
create this output
and so in part 2 we're gonna I'm gonna
talk about my approach how we're trying
to solve this problem and it's a new
person we're quite excited about it and
so the idea as this as it says here is
we're gonna try and run these programs
in Reverse and many people have done
things in like equivalent in a kind of
analogous way but we're trying to do it
literally to run the programs backwards
from output to input so let's do a small
demo ok can you see that just about so
inverse kinematics is similar to this
robot fold close an example but just the
kind of simpler instantiation of that so
if you have a robot arm the robot has
joints and so the joint angles here at
theta 1 theta 2 and theta 3 and the hand
is at some position in 3d space right so
so this this is the junior language by
the way I'm gonna talk more about it at
the moment but hopefully what I've got
here is basically self-explanatory and
so we can construct the function hair is
called the forward kinematics function
and it takes this input theta 1 theta 2
and theta 3 and it outputs a point in X
Y alright this so at this point in X Y
is where where is the hand in 2d space
I've got a 2d robot in this example so I
can evaluate this function and I can
create some reps some random angles some
random faces right using this rand
function just to show you yeah this
function works I apply my random angles
I sorry I apply my function to my random
angles and I get out some random point
in in X Y and I think I can hopefully I
think I can draw this I think it's
slightly cut off right but point is that
I've got a line to another robot arm but
what we what we normally want is to be
able to say I want to put my hand at
some place in space what should the
angles be right so I want to again go
backwards through my model through my
model to say what is the input that
would create a desired output so
I'm gonna choose some target X &amp;amp; Y and
I'm just gonna add that target to my to
my diagram and as you can see my arm you
know my not very detailed arm is not
reaching their desired target and so now
I'm gonna construct this thing called an
arrow and so I'm not really going to get
into what this means too much but an
arrow you can think of as a kind of
function or a kind of representation of
a program but I'm going to construct an
error and it's going to be equivalent to
the function that I wrote up here all
right and so this function again it just
takes him three theta is does some
trigonometry and outputs X Y so I'm
going to construct this arrow down here
basically a program and you can see it
has a similar type and just to show you
that I'm not lying I can apply my random
angles to my my arrow now and I'll get
again a random point in X Y okay but the
magic here is this function invert and
so this function invert it's going to
take my myford kinematic function and
it's going to return an inverse
kinematic function and now what I can do
and I'm doing is you know some degree of
hand waving here is I can I can go from
my XY position back out to my angles
right and so I can run this thing and
hopefully it works and again I can I can
now draw my scene right and so now we
can see that the robot is now reaching
the desired point right and so if that
didn't all make sense that the basic
idea is that I had this four kinematic
function which took in some angles and
said here is my point in XY space and
now I've invited that function and said
Oh take an X Y and give me some angles
which would reach that point right and
so now I can say if I had a real robot I
can say a hair are the angles that you
should choose here's how you should
change your motors such that you can go
and pick up things in in in real space
okay so even if you don't care about AI
or human intelligence uses you should
still care about functional version
because it really pops up everywhere
when you have it as a kind of a hammer
so for example if you had a kind of
quantum simulator which took in some
molecule and said how efficient would
this be in a solar panel if you could
invert this function you can say well I
want highly if
molecule tell me what that is or if you
took eval
right so eval in most programming
language takes the program and evaluates
that gives you some output for example
if you could invert that you have a kind
of program synthesis give me the program
that generated this output or if you
have a boolean formula and you can
evaluate to see is this formula true
given the assignment of values to
variables if I could invert that I have
a satisfiability server a Sat solver and
as I'm sure some of you know is that
phone is one of the the core problems of
computer science or another one if you
have a loss function if you can invert a
loss function you can do optimization so
a functional version really is
everywhere people are always explicitly
defined their problems in terms of
functional version but it really is the
core part of many different problems so
the main you know a risk of giving too
many different examples the main example
that I've been working on is this idea
of inverse graphics so the question that
inverse graphics tries to solve is to
say how do you see in the world and so
I'm sure everyone has familiar with
animated movies like twister and so on
and the way Toy Story works for example
is that they create a 3d model with
geometry of the world they render that
they basically simulate lights to
construct a 2d image and so you can
think of vision seeing as the inverse of
that process I get to the images into my
eyes and I go backwards to construct a
3d representation of the world so that's
like a very old idea but we're trying to
take that idea literally so the reason
that it's hard a difficult problem is
because there's a lots of information
loss in the Ford process so I've got two
different 3d shapes two different X's
and they both create the same image that
as an output right because there's some
cropping and at the same time there's
many things which don't create a desired
output and so this is the kind of
problem is hard for you know normal
machine learning algorithms and so we
need a different approach so
fundamentally why is it hard it's hard
because we're trying to invert a non
invertible function and so a function is
non-invertible it's called non
invertible if there are multiple inputs
that map to the same output and it's not
invertible because different
now to go from output to input I have a
choice right so I'm trying to go from Y
to X should I choose X 1 or X 2 so in
some sense we should have really cool it
non-invertible it should be not uniquely
invertible and so our approach is to say
okay let's parameterize this choice so
we have this thing that we call the
parametric inverse and so we extend the
space we extend the domain with the
space called theta right and so now if I
choose stated to be one for given Y I'm
gonna get our x1 if I choose theta to be
- I get our x2 so I'm basically I'm
introducing a new space - to eliminate
this ambiguity one so this function
takes in Y and theta and returns X and
it's called a parametric inverse and so
for examples I'm sure everyone's
familiar
so the square function is not invertible
because no 2 2 squared is 4 and also you
know - 2 squared is also 4 and so we can
define a parametric inverse which takes
in some value Y and some some value
theta basically one on minus 1 and it
just returns you know Y times the square
root of theta right and so basically if
I put in to my to my parametric inverse
for for some things that I'll get out to
and for some other things I'll get out -
- this is what a parameter is it it
parameterize is the space of possible
inputs that map to the same output and
we can do a similar thing for a similar
thing for addition but basically all of
the common functions that you'll find in
a normal programming language so
addition for example 5 and you know
minus 5 and plus 5 both add to 0 minus 6
and plastics also by side to 0 but with
its parametric inverse we can vary theta
and we get back very you know we get
like a set of different pairs which all
sum to 0 for example and so just this is
a I guess the only real equation so
Paramesh inverse is a function so I've
got a function from X to Y a Paramesh
inverse is a function which takes in Y
parameter theta and gives you our X and
they're kind of the requirement they're
constraints on the prime a inverse is
that for any theta
anyway the ex that I get out should be
an element in the preimage of of why and
the premium is like the set of X's which
in the forward function maps to to Y
right and so all of these X's which map
to why I should be able to get back
going through this parametric inverse so
I'm not going to get into this too much
but you know I showed you it for
addition and I think the square function
but we want to do is invert big
complicated functions so we have a kind
of chain rule of of parametric inversion
which basically says if I have two
parametric if I have if I have a program
in a hand side two functions in it I can
construct the parametric inverse by
parametric the inverting the first
function and the second function unlike
reversing the order this is the basic
idea so just to give a simple example
here I've got a parabolic function right
I've got x1 and x2 are inputs and the
output is x1 squared plus x2 squared and
so the way that I parameter me invert is
I take each primitive I replace them
with the parameter inverses and then
just invert the direction of the arrows
and so there are some there are some
hard problems that we're trying to solve
it's not as simple as this you can't
just do it in a in a trivial way but
this is really the general concept you
take a big complicated function you
replace each primitive in that function
with this primary inverse and then
basically revert the flow of information
and so one other question that comes up
is like what should you choose for your
parameter values I said we have a choice
with the primary inverse but for example
for inverse graphics for inverse
rendering we want to we want to figure
out that the most likely seen the most
likely interpretation of the world not
some arbitrary interpretation and so
we're using a combination of parametric
inverse which basically does the
inversion and a neural network which
says okay of the possible things that
could be of the possible
three-dimensional worlds that could
exist you try and figure out what is the
most likely so this is kind of marriage
of two different approaches
and so here's a simple example it's not
the most complicated renderer in the
world but we still think it's pretty
cool so on the left-hand side we have
the observe image so it's the input to
the parametric inverse and in the middle
you have the output of the para much
inverse so we have to obviously I can't
show you real 3d shape here so I have to
obviously render it again
and on on the right-hand side I'm just
showing you that the output of the
parametric inverse rotated to a
different orientation just to show you
that we actually can really construct
three-dimensional shapes from
two-dimensional images and so there are
there are other approaches that you know
are trying to do the same thing and this
is kind of an active area machine
learning but I would say our approach is
the only one which we you know we
literally take a rendering function and
we run it backwards from output to input
and so here are some more examples a car
a bottle some more chairs and you know
if it's at least an easel arm for this
working pretty well so that's that's the
basic idea so now I'm going to talk
about judea break free briefly so you
know i did a lot of work and find them
for a while and i just want to give you
some reason why i decided to jump over
to Julia so Julia is a programming
language it's out came out of MIT and
it's designed by people who are really
interested in technical computing by
that we mean numerical computing
scientific computing but I think it's
good as a great general-purpose
programming language so just to give you
a kind of a whirlwind tour this is how I
think about Julia is like let's be fast
like MATLAB or C Python all combined but
not in a kind of messy way it's like
very consistent internally so the hello
world is you know similar to Python I
can print hello world people in Julia
love to use Unicode you so you'll see
lots of pies and towels and Delta's in
the code we can do is function
definition so we have this kind of
implicit multiplication by x + 2 and
function application as as the kind of
normal way so this is the longer form of
function definition again it should be
quite explanatory one of the defining
features of Gina is that you have these
these
methods right and they're a little bit a
little bit similar to methods in you
know other languages but they're not
part of an object you know you don't
have a don't have object cool method
that they exist in a kind of external
world so I can say F and I can define F
again but this time taking as input a
flow and so this double Cola means you
know axis of type float 64 64 bit float
and it's returning this string right and
so I can evaluate this and I get out
your X is a float I can do the same
thing for a boolean and again I can
evaluate that with true and I get out
okay X is a boolean and of course I can
create my own type so Julia it doesn't
have many built-in things there's no you
know plus isn't special - isn't special
on the other hand it does have many many
built-in functions right in terms of the
kind of way that MATLAB does it has a
very large standard library so I can
create my own type I just call it my
type and I'm going to construct an
object of my type with input one so this
X means that my type has one field cool
X just it's just a struct so I can call
so I can now define F - taking a value
of my type and return the string and so
just to evaluate that so in X's in my
type we finally won and so you know I've
I've used F many times now maybe you
thought I'm replacing F well I'm
actually adding more methods to f4 and
so I can look at the methods of F and so
you can see this is I guess five here
right so there's the my type the board
the flow and then the two untyped
examples and so I can look at you know a
more common function addition alright
look at methods of addition and you can
see there's a whole range of different
ways people have overloaded addition and
this is just in the standard library if
I import other libraries I'll be you
know hundreds more and so the way that
Julia is based around this idea of multi
method dispatch you take functions and
you you overload them and it's kind of
hard to explain why this is important
but once you get a feel for Judah it
becomes like quite an incredible feature
for for a programming language so let me
just scroll down
and so what I can do is you know import
import import plus and I can add a
method to class
with my type and so I'm just going to
add to my times which means just adding
the internal elements together and so
now I can you know add my type one my
type one to my type too I can do the
same thing for multiplication and so now
I can multiply values of my type one
thing I can do now is create a matrix
right and so a matrix it's just in this
kind of list comprehension syntax a and
I can create a vector B all of my types
with random inputs like random fills and
now I can try to do matrix vector
multiplication but it doesn't doesn't
quite work and says I need to define
zero for my type and go and I can import
based on zero and now I can do matrix
multiplication matrix vector
multiplication of of elements of my type
right and so the nice thing about julia
is that you define a few things for your
own types and you get a lot of things
for free right from other libraries or
from the standard library so that's
that's the very fast version of julia
it's a great language i recommend you go
and check it out people come to julia
because it's it's fast it's efficient
but I would argue julia is a great
language for building your own DSO right
and so in the example I had before I had
this you know I constructed this error
using invert so I took in some function
before kinematic function and I somehow
converted that to some error which I
then inverted and the way that I did
this is using Julia's introspection
abilities so one of the things that you
can do in Juneau which I don't know many
other language that you can do and you
can look at the code after you can look
at the code that you're generating on
the fly so for example I made you know
many different functions and he uses
function code load it's actually a macro
but I'm not going to get into that but
it returns me the syntax of the of the
program that I just wrote and this is
really a syntax tree so I can go in and
I can manipulate this function as I wish
so it has a body it has a body and a
type it's an expression has a head augs
and something song
I can also get the typed expression so I
can say Julia go and do type inference
and time with the types of things right
and now give me back the the source code
again in a syntax tree form this is why
it's kind of a list B language I think
that I can again go in and manipulate
and and use I can even go in and get the
LLVM right and see what is the code
generator on the fly
and so for my my matrix vector
multiplication I can again go and get
the code lrvm and obviously it's a much
more complicated function and so my main
point here is that julia allows you to
really go deep into the code what you're
generating on the slide alright and so
when when i had build this arrow from
the kinematic function i was going into
the code of that function analyzing the
source code and actually building a
computational data flow graph the kind
you'll find in languages like tensorflow
which i think there's a talk on maybe
earlier later today and then I do all my
inversion stuff it would be super
cumbersome to do in Python or many other
languages because they don't have the
kind of introspection abilities that
julia does and so if you're building it
DSL I highly recommend you check out
Julia ok so just about to wrap up so the
main idea I wanted to show you was the
mental simulation is this cool idea it
has all these problems it's very hard
but I think it can offer a way that we
can think about a more general kind of
human intelligence to do this I think we
need to invert programs and I've shown
you a kind of a way that we're trying to
do it we think it can scale to bigger
programs and this is what we're working
on actively both of these things are
very hard contributions of welcome if
you're interested in this kind of thing
coming talk to me yeah that's it thanks
a lot
so do questions but I guess I could take
some questions
it's so the thing about kinematics is
that there's many joint angles which
reach the same output right so if the
target is here my hand could be here or
had to be here had to be here so R an
inverse it just chooses a random
solution yeah sorry
yeah yeah basically we've reversed the
code of the function that's basically
what happens as in animals I mean
there's lots of yeah there's a lot of
work with like monkeys and they they
sometimes they measure from their brain
when they're reaching yeah so there is
some work I do it's I think a lot of
that work is trying to figure out what
parts of the brain are involved in this
kind of motor control for example yeah
yeah I mean there's definitely like
lower-level things that we do which to
certainly don't require a big simulation
but you can you know swat a fly very
quickly so this there's some there's
some kind of balance between you know a
general kind of simulation and when you
need to do things quickly fast response
and reaction and that kind of great
gradient is the heart of our question
why using your network so we actually do
a bunch of things we do like variation I
reference and we use in your network I
sort of I guess the way that I think
about it is that so the way that we see
the world is driven by physics all right
different by you know how light
propagates around the world and that
since that's in some sense simple right
but figuring out figuring out the most
likely interpretation of the world it's
complicated right it requires on it
requires data it requires knowledge of
the kind of the distribution of real
world scenes right and somehow we need
to model up with something which is you
know more messy than than a program and
so I'm not tied to neuro networks but
they work well with large amounts of of
data and so that's one of the reasons
that we're so so in this case we use we
use 3d data sets but in general you know
I I think that's not really the way to
solve the problem because as a human you
don't really have access to the
three-dimensional world you only have
access to images and so we're trying to
think of how we can do this just based
on image Statesville own but it requires
like some significant like algorithm
changes any more questions
so they see if you have if some as I
tried to communicate the basic way that
we do this is that if you have a program
and it has all these primitives than
that we invert the primitives and we run
the program backwards and each of these
parametric inverses has its own
parameter and so you get out of this big
program a big Fronter space which is
just like the concatenation of all the
parameters of all the individual
primitives now it turns out that on some
subset of that parameter space the
parametric inverse is not well-defined
so you'll just get error right and so
it's kind of like there's many ways to
go backwards through the program but
some ways are kind of dead ends you'll
get stuck right and so the hard part is
figuring out how to essentially not get
stuck right like how like what subset of
the parameter space is the parametric
inverse well-defined upon and so that's
the hard part and to do that we use like
a a whole bunch of different approaches
yeah yeah well let's code you can try to
play with so the framework we're working
on is called aerogel it's in a you know
highly experimental state which
basically means broken but if you if you
want to try you can you can certainly
try
so we list for the two steps so we
basically have a language within julia
and the first step is to take a julia
program another judy program and from
that extract this arrow program i which
is a kind of a dataflow programs that
purely functional it has a few of the
complications of julia and to extract
those we do like a source transformation
and then we have we invert the
primitives of that language so we have
primitives that are well defined in our
own language and we translate julia into
that and then we invert that that make
sense yes I mean again it's a bit like
tensorflow it's a graph based language
yeah it's a it's a computational graph
because it makes things easier for us so
it's okay so the error signal is
basically if you if you start with an
image right and then I use it so I got
my parents you inverse right and I put
in as the image the input and the neural
network is also taken as input the image
and it's choosing the parameters of the
parametric inverse right then I invert
the image with respect to those
parameters and so the error is does the
3d object that I've constructed
correspond to the data that I actually
have in the dataset right so that's one
way to do it's not the only way you
could do it and there are actually some
problems with doing it that way but
that's the basic that's one way to do
yeah yes so this is a kind of a an
evolution of that project so probably
much you had so I had I had a famous for
that which is trying to do the same
thing but using very different methods
this is kind of like the under
approximation of Sigma so Sigma was a
publicity programming language and it
kind of over approximates in the sense
it considers many many possible things
at the same time and that has problems
of scalability right and this has
problems but like basically I think this
approach can scale in a way that Sigma
could could never let's go and so this
is really trying to do similar things
but in a way which no we're pretty
confident we can actually solve 2
inverse graphics so in Sigma I didn't I
couldn't show you the demos like the one
I like we couldn't do this in Sigma for
example but we can do this using
Paramesh conversion I guess</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>