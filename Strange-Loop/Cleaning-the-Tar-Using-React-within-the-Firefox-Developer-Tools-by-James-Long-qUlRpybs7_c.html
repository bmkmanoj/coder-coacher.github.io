<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Cleaning the Tar: Using React within the Firefox Developer Tools&quot; by James Long | Coder Coacher - Coaching Coders</title><meta content="&quot;Cleaning the Tar: Using React within the Firefox Developer Tools&quot; by James Long - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Cleaning the Tar: Using React within the Firefox Developer Tools&quot; by James Long</b></h2><h5 class="post__date">2015-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qUlRpybs7_c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm James long I work on that Firefox
dev tools and I've been thinking a lot
about how we can improve our code so I'm
going to talk about some ideas about
this and just a disclaimer these are
ideas we aren't actually running this in
production yet but we have um some of it
implemented and we are about to land it
soon so and also a lot of these things
are just things that I would like to
personally see so I don't completely
speak for my team but I think a lot of
them seem to be excited about it as well
so there's this idea of ATAR in software
this is something that the mythical man
month book talks about and out of the
tar pit paper which is a fantastic paper
and I think I think especially if you've
been working with software for more than
a few years this really resonates with
you because it's it's just super super
frustrating when you want to do
something small when you want to fix a
small bug that five other things break
that we're completely unrelated to you
and it just it kind of is demoralizing
and it just it's it's a pretty dangerous
thing so of course every every piece of
software has to our every piece of
silver has instant incidental complexity
but it's I think it's extremely
important that we find time to clean our
projects and this you know it's totally
a project project by project by project
basis about you know how much incidental
complexity that you're willing to kind
of indoor but for us I think we've at
least four parts of our code we just
have too much we can move too slowly so
some of the things we want to talk about
how we can move more quickly so we've
accomplished a lot in the last few years
it's really amazing what the dev tools
team has done yeah the web Cole the the
web console does not source my upline
numbers yet so I'm really sorry about
that but we're going to fix that
extremely soon but we have not we
haven't said undefined as out a function
for years so I mean chrome you know it
was really late in the game for that so
I don't know if any of you all were in
Richard Feldman's talk about elm and
that was like his big complaint that
like JavaScript says undefined inside
function but now if you just use firefox
wouldn't find so but we've been too busy
to
to really improve how are you eyes work
how are fronting code works so I've been
thinking about are you eyes a lot one of
the main problems is that we use dual
and azula is a technology that the
Firefox ey is based on and zool is
basically htmls grandma it's just old
and it doesn't really understand what's
going on all the time I mean it's like
it's a part of the Firefox codebase that
really isn't working on anymore there's
these really weird bugs and so that's
that's a really annoying problem about
our you eyes so we're working on getting
off of that there's actually a painter
named zula soul are he makes these
paintings and I think it depicts it'll
pretty well just how i feel about this
every day so it's it's not really the
main problem though the underlying
problem is that we do a lot of mutation
in our you eyes and we we have state in
a lot of different places and it's just
really hard to figure out what's going
on now this isn't specifically zoals
problem this is I mean HTML has the
exact same model and it was okay you
know for to like maybe four to five
years ago but the landscape of you I
work is really drastically changed so
you know this is rui right now and a lot
of our tools it's pretty bad it's pretty
messy not not only do we mutate state
but like everything calls out to
everything else and it's just it's it's
kind of a it's kind of a pain and
there's there's a few tools that are
newer like a performance tool and it's a
lot more well written and the code is a
lot more straightforward but it still
mutates state and it still it still
doesn't enforce as much of a structure
at least at least as much as i would
like to see and lastly it doesn't use
react so it's it doesn't use the react
component models so i think it's harder
to share components around so i think we
can do better i wanted to treat state as
an explicit object and this means that
our UI is something that we don't mutate
this is something that we just pass her
a state into and we just generate a new
UI and this impacts a lot of the overall
architecture all of the other layers
sort of become simpler when you have
this model because your UI is just a
collection of pure functions at this
point and you know react is really key
this because react is the thing that
actually allows us to express our UI in
this way because normally normally you
you the only thing that you can work
with in the Dom if you want to make
changes on the screen is to like call a
call Adam method to mutate the value but
react kind of papers over all those
problems and give us a pure functional
interface so you know this is um this is
what a lot of current apps look like
this is the sort of familiar npc model
models sort of manage their own state
separately views kind of manage their
state as well like a selected item or
something like that so you know the
state is all kind of separated out what
if instead we combined it into a single
atom this is just a single an actual
single object and this is called a
single atom app state and just imagine
all of the state that you saw in the
previous slide sort of routed onto this
object so now there's a path to all of
the state in our object if you have a if
you have a if you have a handle to this
a single atom app see this works because
it turns out a lot of you I need needs
any access to your app state anyway you
don't know which pieces of app state
that a specific you eyepiece depends on
it can sort of query into the oh I
upstate right so all of this state is
swivel sort of global in the in the UI
world anyway and when I say global don't
think of global as in global variable
think of it more it's just a database
this is it like a database that you can
query we don't actually use an actual
you know database with a query language
but you actually could there's things
like data script or like fronted in
in-memory databases that you could
actually use as your app state if you
have more complex models so global just
means that it's just accessible in a way
if you have a handle to this app state
you can like access the access of
properties within it but we can still
restrict the actual how we passed around
this app state so that certain things
don't actually have access to it so now
we can do all sorts of cool things what
if we don't mutate this object right and
we actually return a new state every
time you want to update it and this
means that whenever we want to look at
the UI at a certain time we can just
a reference to that app state so you can
actually walk back in time and see what
the you I looked like at that exact
point in time so we can walk back and
forth not just walking back and forth
though we can also just look at the UI
at any point in time can literally just
grab this app state and throw it into
our yard are you I because our UI is
just a pure render function so once you
start doing stuff with immutability I
mean you just really don't want to go
back to me to Kody I mean it's just like
you start just like what in the world is
going on so that's the essential idea
i'm going to show you this actually
working so i've rewritten parts for our
UI to use this so this is the debugger
you I this is just just just the
debugger and you know first off I can do
some actions and I can grab that single
atom app state by calling get state so
this right here this object is the
entire representation of my UI so I set
some break points right if I click on
this break points object you can see
within the breakpoints there are three
break points that's exactly what it
shouldn't shown in the UI so I can look
in the location i can see that this is
on this source actor and it's on line
three so if i remove the breakpoint i
could look at the app state again look
into the breakpoints and see that that
breakpoint is gone I don't care about
the actual Dom anymore I just care about
this normal JavaScript object and it's
just like extremely refreshing to not
have to do weird CSS queries just to
check certain state so we've got a pole
state out of the Dom it's a terrible
place to put state additionally because
we never mutate state you know I can
actually do some reactions I can change
the source again turn off break points
because we never mutate the state I can
just keep a reference to all you have
all the past app States which I've done
I can pull up this little slider and
just scrub pass all of my app states in
my entire app so at any point in time
I'm looking at the UI and what's super
interesting about this is that you can
see a lot of things like when I disable
all of the breakpoints with
a button it i can actually see that it
disabled one at a time so i can see for
asynchronous work i can see exactly what
has changed in the app state and so
maybe i want to do it this way or maybe
I actually meant to do it all in one
single app state change but for some
reason it's doing in multiple app state
changes and it's super easy to
rationalize about the Upstate changes
now because I can just show it over the
exact amount of time that I want to so
yeah so not only that but I can show you
just just to drive this point home this
is the entire amount of code to have a
record and replay functionality so I
have record which just basically says
whenever the state changes i'm just
going to push it onto this array and
then i have a soft record function and
then i have a replay function and so the
replay is just going to asynchronously
iterate over that history so every 100
milliseconds is going to dump that app
state at that point in time into the UI
so if i run this and you know let's just
make a new instance and run this and
then i'll just say start record and you
know I can make some functions or let me
make some actions change some stuff and
then you know I can come down here and
just hit replay and this was all in user
landed just because I'm not mutating the
Upstate I can do all this and use your
land so think of any sort of debugging
that you would want and this is just
kind of all comes for free so it's
pretty cool right so house is possible
well you know it's all about avoiding
mutations and the first there's really
two pieces the first of which is react
so the problem is that using the DOM is
side affecting so you know react
obviously gives us the pure render
function as I've as I've described so
you know sometimes I like to think of
the DOM is like Mount Dom it's just this
like terrible place that you don't want
to go to but you have to and so you know
this is what you're basically doing when
you're working with the dog directly you
have to implement the state changes
yourself when it's a tune is to change
it in the
you actually have to think about the
diff of state one and say two and add an
item or remove an item so it's just
really not a great way this is really
not great a great way to think about it
so reactive is this pure functional
render function and the second so
there's a second piece and the second
piece is a library called Redux which
actually implements the single atom app
state it was started by Dan abramov and
it but it's a collection of ideas from a
bunch of other languages and you know
it's really it's a really great library
because it allows us to have this thing
laid a single atom app state and a
common method for updating it so it
takes ideas from many other places such
as the single atom app state from
closure closure script was really the
initial language that pioneered this
actions from flux to represent changes
in the app state so you fire in action
and that represents a change and then an
update function and this is this word it
comes from Elm where it the update
function takes a state and takes an
action and returns new state so you can
take whatever action you want to and
then return some new state so those are
the three parts so really you you have
this workflow you have the state object
when the state object changes the
Uwharrie renders then the UI can fire
actions throughout Cheng craters and is
the update functions can take actions
and change the state when they say
change the UI render so there's this
very very simple clear circular flow
this is actually very similar to Elm to
how elm works in general in their
front-end code so really at this point
the only thing I'll gives you is the
static typing so this is this is in
example of an action this is just a
JavaScript object and you call a
dispatch function so the dispatch
function you don't really care where it
came from I can't really explain like
where like where it comes from but you
have a way to kind of bind to a dispatch
function and you just call dispatch and
you can dispatch an object and it has a
type and it has so this is just saying
you know I want to add a breakpoint at
URL pjs and line 5
and then you have update functions which
have a couple interesting aspects so
they take a state and they take an
action so one interesting thing is we're
using this is a very this is sort of
enforced by redux but redux allows you
to like specify the initial state just
by using the JavaScript default
parameter syntax so this when you
install in when you kind of bind an
update function to the app state real ex
will fire like firing action with an
undefined state throughout your entire
update functions and so this will by
default just be bound to the initial
state and then you won't handle the
action and then you'll return the
initial state so we can always get the
initial state of the entire app just
like by running undefined throw update
functions and so this is kind of colo
kidding the initial state with the
actual state changes and the other thing
here is the probably most important part
is here we just have a switch statement
on an action type and you know some
people kind of react to a switch
statement be like oh that's I believe
like why don't you just like use multi
method dispatch and all this stuff
really turns out that these update
functions usually in the book like even
in my most complex code it's really
about a hundred lines of JavaScript it's
just not it's not worth it to me to
really break up these these update
functions because really these update
functions the whole point of them is
that they they are getting all of the
actions coming through the system so
you're supposed to be able to handle it
like any single action and that's a
super helpful property of this system
because you can react anything so if
you're supposed to show a count of
something that happened over there like
you know that you're going to get that
action too so we just switch on the
action type it works fine I mean if you
really want to you can you know create
helper methods or something too but the
other important thing to note is that we
always return new stays so here we're
creating a new array and adding the new
break point with the URL and line on to
it and you know obviously if you have
this big complex app you're not going to
want to manage everything one update
function so it's super easy just to
modular have more modular update
functions that kind of handle subtrees
of the OP state here I'm mainly doing it
where I'm mainly kind of passing off to
other update functions like the source
and break points but redox does it so
that you can actually have a
several separate update functions and
then kind of automatically combine them
into one update function that
automatically calls all the other update
functions and it just come and it just
creates this top-level app state for you
so that's pretty cool so here's a demo
of the the actions in play let's area
have this running okay so actually I
want to see so it's this architecture is
very nice for debugging because I can
just come in here and I can just say
let's log all of the actions coming
through and for reasons she'll explain I
have to build it so here we're going to
see every single action coming through
the system and because actions are the
only way to update something that means
that I'm seeing the entire transactional
log of changes of course all right so
here's my UI again now i'm logging every
single action so if i pull up the
console so there are already some
actions those are the things that happen
to initialize the UI so if i set a
breakpoint you see there's an ad break
point there's actually two is it's an
asynchronous requests and it's firing
one at the beginning and one at the end
so if i if i change the source you can
see that there's just there's a select
source option and you can see all of
their parameters here right so this
source is an object that ice this is the
source that i selected so this entire
law right here is this is everything
that has happened in my system in my
system this is just like super like nice
to see if you're trying to run tests or
you're trying to figure out something
that happened wrong then you can just
pull this up and for just another demo
this is the same replay code except this
time what I'm doing is I'm starting to
record all of the actions so here I'm
going to record in the app state at a
certain point of time and then and then
I'm going to record all of the actions
after that app state and then in my
replay I'm going to replace the state
with that with the state that I started
on
I'm going to replay every single action
so this is kind of similar to the time
travel debugging with the app state but
what's different about it is that I can
actually see the changes like see why
the app state changed alright so let's
run this and let's clear this and say
record Oh see record so now I'm going to
do some stuff smaller now if I replay
let's clear this again if I replay it
does the same replay functionality
except now I see all of the actions here
like this is the thing that replayed and
I'm actually logging I'm also logging
the actions so it's duplicating that but
if I if I were to like say be running a
test I could just have this and I could
pull that down and replay it in fact let
me just show you that I can do that I'm
just going to serialize that initial app
state and then all of his actions into
the string I'm going to just close
firefox and then I'm going to run it
again go to my debugger and i'm going to
paste that app state and so this is this
is the point of my UI that was a that I
saved all of that stuff but I can pull
up my slider again and slide it back and
see everything that happened so it
doesn't matter if it's not tied to that
instance of my debugger at all it
contains all the information for
replaying the app state so if somebody
wanted to file a bug report what my goal
is I can say hey hit this like you know
special combo keys and send me that zip
file and it's going to contain their
entire or maybe like the last 100
actions or something and you can see
exactly how the UI built up to that
point you get all this for free listing
a lot of maps eight and just don't
mutate it I mean it turns out that
that's just kind of good software anyway
and this is just kind of a side effect
of just writing better code
sorry so there's a redox dev tools that
I couldn't get working quite yet but
they actually show all the actions in
this really pretty pain and not only it
does it show the actions but it shows
the action in the state at that point of
time you can actually click on actions
to disable them and so it will replay
all the actions and skip that one so you
can kind of see what happens when you
don't play that action it's really
really cool okay so how in the world did
I go from this to that without a total
rewrite because the total rewrite it is
not an option well the first thing I did
was I looked at this update function and
so there are these state changes right
so how do I so the plot twist is that
I'm actually not using react yet I'm
just using redux and so how do i go from
these state changes how do i tell my
mutation base you I to make these state
changes right because when this update
function is done just has a whole new
state I don't know my mutation basically
why I need to know exactly what has
changed well let's let's restructure
this just a little bit let's assign the
break points to a variable so now i have
the BP variable to work with and adduce
i do something horrible like don't do
this unless you're migrating code but i
omit events that are specific to my
state changes and it makes the code a
good bit more like verbose and annoying
but I have to do this because I miui my
mutation basically y has to know what
has changed right so this violates all
of the constraints and contracts that
like Redux is trying to enforce on you
so I I can do this because you can see
that there's a third argument emit so I
like wrapped all my update functions and
added that third argument so this is not
a normal Redux emitter again don't do
this at home unless you're migrating
code and committing to migrating that
code in a couple months so yeah so we're
hoping that like in a while if we start
using react more that all this kind of
code kind of goes away so um you know
I'm really interested about migrating
existing code because a lot of us right
in this room are probably working on
code bases that were we would like to
use cool ideas but we just can't because
there's just seems like it seems
overwhelming to hell that like how do
you have you change that enough to
actually start implementing these ideas
because rewrite in reacting Redux seems
like a total rewrite but as you've seen
with you are able to violate constraints
here and there sometimes you can kind of
limp along to get a pretty good
migration path so this is kind of what
we're going for we have this single item
app state we have a UI with these views
that can fire actions through action
graders but as we saw are you why is
still our old you I systems this
mutation base UI system so we actually
have to fire events and this is just a
temporary measure so you know after the
first I kind of like to think of it as
several passes of migration so after the
first pass this is sort of what the code
base looks like we're still reusing a
lot of the old code we're using all of
the old UI system that and we're
converting controllers into like the
controllers are the thing that we're
mainly focusing right now we're
converting them into action creators and
like the state update functions they
kind of are split into two things but
we're able to reuse some of the complex
business logic that are in the
controller's you can see in the action
creators those reuse some of the really
complex business was logic to figure out
like where it at a breakpoint and like
when to do it at certain times I was
able to just copy this code over and
just kind of but like clean out all this
old other junkie asing stuff and there's
still controllers in there that haven't
been converted but this is working like
this is just kind of sitting some is
sitting side by side and so eventually
we would like to convert all the
controllers so that everything is
enacting creator everything is a state
update function and then what I would
like to do is eventually used your app
so we can just pass that state into the
react component and we don't have to
worry about any of that code so that's
the goal and so I what's interesting
about this is this not using react but
using Redux has really highlighted for
me the benefits of react because there's
things like this that we have to
implement that we wouldn't have to
implement without react these this is
like there's always up there's all these
empty functions which kind of clear out
that current UI element which but just
says like send me back to in a default
state where I had no data
if you use react you don't have to do
this at all you just render based on the
state and if we act needs to remove
things from the Dom then it will
automatically and this is important so
like the dev tools is kind of weird
because we frequently have to empty our
UI out so if you like refresh the page
or if you navigate away we empty the
whole UI out because our the dev tools
is still the same instance right so the
all of the data is empty is empty out of
the UI and then the new data from the
new page is loaded in like the new
sources and the new breakpoints and
stuff like that so we do this every
single time that you navigate so we have
to every single one of our UI we just
has to know how to empty and there's
there's some abstractions that try to
paper over this and make it a little bit
better but at the end is still mute like
mutating the DOM and we run into race
conditions all the time so another thing
that we won't have to implement if we
use react so currently i'm taking state
and i'm able to dump it in at any
arbitrary time so how does that work
with our mutation base you I like I
could see how you could go from one
point in time to the next point in time
because as you made those changes in the
update function the update function
would emit those events to change the
the state at each point of time but how
do I with our mutation basically why
hide away arbitrarily load and state at
any point in time again it's the
horrible violation of everything by
basically I empty out the entire UI I
call it all of those empty functions
which we already have and then I fire a
special action type which of which is
reload and so every single update
function has to implement this has to
implement this reload action type and it
basically has to emit events that will
build up the UI that should
theoretically represent the current
state and obviously this is like
horribly fickle and you you have to be
very aware of the internals of how your
UI works and like which things are
handling event handlers in which order
it's just super hard right but with
react we would like you don't even need
this good at all this is all the event
editor stuff so that we can empty out
stuff and then like load a new state of
course obvious obviously it's working as
I showed you my demo but it's just it's
more incidental complexity I don't
really think that we need okay so let's
let's talk about action creators a
little bit
this is an action creator you it's just
a function that returns in action and
that when you hook things up this is
bound to a dispatcher or so like when
you call it it's actually automatically
dispatched but it's really when you want
to test stuff you want to keep these
just things it's just pure functions
right you can also return a a function
which takes a dispatch and they get
state so you can manually call dispatch
yourself and this is helpful because you
can do stuff like a synchronous work so
here I'm dispatching twice I'm
dispatching first when it started which
lets me do things like optimistic
updates and then I'm calling the like
add break point function and then at the
end I'm saying okay I'm done and and
here's value so actually too that's why
you saw it to break point actions going
to the system and so you know this is
really really nice because it's it's the
the action creators are the place that
you should be doing a scene work and you
know a single rig is terrible and its
really really nice I found it super nice
that there's only one place that you can
do a sink work there's been a lot of
talks exchanges about effects and that's
basically what we're doing we're
isolating like side effects into one
place all of the other stuff on the
right side that synchronous it's like
synchronous pure render functions right
I mean that's all it is so we're very
words I mean that the action creators
tend to be somewhat bigger because
that's where some of the complex like
business logic is but the right side
still tends to be at least in my
experience like sixty percent yer could
maybe seventy percent of code so to have
the majority of your co especially your
whole UI it's just like a normal
synchronous thing that doesn't do
anything quercus I've found super super
freeing it just makes testing a whole
lot easier and I things like that in
fact oh yeah and I was going to say also
like this is I think promises and
observables and channels in any async
abstraction they belong in the action
creators you don't need any of those for
your entire application architecture a
simple pub/sub style thing which is
basically what well I mean it's not even
really pops up anymore just like a
dispatch of function that is one entry
point where things can kind of like
listen to the actions is really all you
need at least in my experience because
async obstructions
to find them just kind of just a bear to
work with like promises like promises
and an error is like what is up with
that like I mean especially in
JavaScript like you make of typos and
you forget to like add an error Hannah
to the promise and you're screwed right
or like tool should see other problem
right that's what everybody says except
what happens when the tool brakes on
your tests and when your test is failing
but you actually had no idea because the
promise was eating the air I mean this
happens all the time to people that I
would talk to you to work with promises
and it happens with us on our test two
so you know I'm definitely ranting about
promises but you know I have to do some
food like I have to do stuff like this
like I'm I'm done with my async work you
don't care about the errors in my UI I
just want to continue on with my
synchronous world so but I can't do that
in promises I literally have to do a set
time out of 0 to get out of the error
handling so I don't i mean i like i like
the AC kept records they're great for
like an error happens and you retry
something 10 times that's great but
don't force it in my whole entire UI
right so this is great because if I make
an error in my in my UI bike shows up on
my console I can break on exception it's
great you think that would be a normal
thing and so these are a lot of cool
ideas there's a lot of work already done
with this Redux is essentially just a
combination of a bunch of other stuff
and there's like um was the quitter
script framework written by David Nolan
that did like the single atom apps 8 and
I'm base everything around that there's
up there's elm effects which i talked
about which is basically elm you don't
actually ever have side effects you
actually describe what that a side
effect should be and it's passed up into
the global like run time then the
runtime actually does the side effect so
now that all of our side effects aren't
action creators maybe we can talk about
like hey maybe we shouldn't actually be
doing the effect literally in the action
crater we can like delay it into some
description of the action crater so that
we can test it right because acting
creators are the last thing there are so
kind of hard to test and and then
there's relay in Falkor which are kind
of a different beast they're more
they're more focused on like when you
have a super complex back in database
and you want to do complex glories on
the front end and you don't really want
to care the front end doesn't really
want to care about what's loaded on
the client or the server are our data
tends to be relatively simple so there's
not really much so I don't think that we
can learn from that so you know testing
this is like another side effect of
writing pun not intended of writing just
pure functions if you have pure
functions and modules just all these all
these things sort of fall out of it so
this is our this is a view into how we
do testing in Firefox it looks like
really I'm just I'm just realizing now
that I understand this but you probably
have no idea what it is it's like
looking at the matrix but so this is
this is um we call it like the the tri
server and the orange boxes are failures
and so when you make a change when it
pushed to our try server which is this
massive interprofessional this massive
infrastructure which runs it on
different platforms and different
optimization levels so you can make a
change and really legitimately see it
run on all kinds of cool stuff and so
the orange teams are failures and so
when you like when you have a bunch of
failure as we call it you know you're
burning the tree because it really looks
like everything's on flames it's really
awesome so testing is not fun on the try
sir because if there's an inter minute
test that only fails one out of every
ten times on linux debug I mean I'm
telling you it's like the worst thing to
debug everyone when we realize we have
to debug that were we all just like sigh
but if you have these these pure
functions I mean that well the first
thing is that a lot of our UI tests are
required at Dom so we essentially you
have this test called a milky test which
it fires up a whole Dom instance runs
through some stuff within fit and then
ends and doing that just tends to view
sort of race condition II I mean when
you actually have to rely rely on a real
Dom existing it just tends to be a lot
harder so if you have these on pure up
pure functions like this update function
it's just a pure function right you can
just call it and the result is something
that you can just test so i can say oh
like it the initial state of this w
function is 0 of x is 0 when i pass
increment X to this and I X is 5 in the
state X is 6 I mean that's you just it's
a very easy test
so when we end up using react there's
also a whole lot of things that we can
do with react and this is even more
powerful in my opinion I'm super excited
about this because when we have react
components react has a shallow renderer
you can create the shallow renderer you
can import your component and you can
render it with a shallow renderer with
some state and then you just call get
render output and you have this whole
description of what the you I should be
it's just this kind of sort of JSON II
description of the whole entire UI and
you can do all sorts of complex text
tests on it there's no no Dom required
so we could actually run all of these in
just a JavaScript shell test which is
just far far faster so there's minimal
async no Dom interactions and it's just
really fast and fast and easy tests so I
had this idea and this is the last thing
that I was going to talk about mainly so
we have this app state right it's just
this like single object I was playing
around with generative testing i was
like what if like we have the single app
state what if we sort of described it in
types and like a gen test i'll type
could we actually generate app states
and just do property based testing on it
so i did this so this is jen test so you
know i'm describing my apps eight and
ten types of the source ops the line is
a non-negative the source type there's
after URL it's a string such that it's
greater than 0 and then I run this so if
i run this this is just like dumping out
app states and as fast as it can just
like throwing it in the UI and it
actually is airing out in the background
i'm not going to show you the errors but
because our UI is kind of weird and part
of it is probably you know the fact that
gent us is kind of weird to you like i
have to make sure that i'm generating
valid up say it's if i generated invalid
app state of course it's going to air
out but i can pull up the slider you
know and i can run through all of the
tests that gent us through into here so
you know i don't really know if this is
actually not useful but
think it's super cool just to be like oh
cool like you I multiple UI is all the
time i know i thought it i don't know if
i'm actually going to get much from this
so i don't know if that's really going
to work out but it's anna it's a cool
idea there's school things that you
might be able to do like make sure that
this is checked when this is highlighted
if you have certain pot that's what the
property based testing is that after you
generate something that you test the
properties of the generated structure so
there's a lot of stuff we have to do
like my grading to react choosing which
immutable library I don't have time to
talk about it but right now i'm using
seamless immutable which is it doesn't
you do the structural sharing that
immutable jss but it's it integrates a
lot better with the other javascript
function and then there's hot reloading
so if pure functions are super easy to
hot reload so we should be able to get
it to work when you save a function its
immediately running in the live live at
there are a bunch of challenges to this
to like there's component local state
which i haven't talked about so so far
we have this global app state structure
which is appropriate for a lot of things
but there's a lot of things that
component local state is appropriate for
two and i don't have time to really talk
about it but essentially it doesn't
really we should be able to use local
app state the only the only problem with
local estate is basically because it's
wrapped up in the component and not
connected to the global app state that
you can't do the record and replay but
you actually you actually can that's
just a technical problem there's no
reason why you shouldn't be able to back
the local state into that global app
state Adam that's what Circle C I did if
any of you also let posts so this really
just a technical problem about where
that state is actually backed in the and
they combine it logo state there's no
reason why we shouldn't be able to have
state in the global app state that's
only scoped for a component so i don't
really i think the idea this local this
single at single app state doesn't
necessarily mean it's even global and
lastly there's a places where we need to
abstract the data queries out because we
have this now like we're passing in
state directly to like the UI so if it
says like dots or stout line if we ever
wanted to like change the data structure
that means that some of those things
will break because we're assuming a
certain data structure of the app state
right
so I actually have a bunch of functions
that are like get source and I give it
the URL and it will get the source
object and that way i can change around
the data structure but it's a little bit
weird I mean that's a that is one
downside to it is that you have to have
all it you basically have to run I'm
essentially it's just like functions as
queries like you could think of it as
like wearing a database again not sure
if that's a great about a great thing
but it's I think it works right so
that's a quick overview of where we're
where we are at so it's still a bunch of
research and but it's been a lot of fun
I think we're going to do a lot of cool
stuff with it so have a few time a few
minutes for questions yes
well the Dom like the Dom at this point
is so the question was are we capturing
the Dom sa is that is that right so the
Dom at this point is just the low-level
rendering right the state is just a
JavaScript object I mean like and we
just we just assume that react is going
to take that state make the Dom reflect
exactly what that state is there I mean
there we don't store any state in the
Dom does that make sense yeah right yeah
isn't this so not yet but um so I've
hacked it so yeah I mean so gosh this is
going to be weird let me just so that I
don't have to debug errs open that would
be weird so yeah this is the same
debugger I just I I made it so that I
could load our internal tools which are
backed by this Azul file into a URL and
if you're not loading it in the devtools
itself it will populate it with just a
mock data so that's that's what I didn't
note but you can't do that maybe after
we land this but right now you can't do
that because it you could load that Azul
file and you will see the basic debugger
interface but you see a bunch of errors
because it assumes that is running in
the dev tools yeah it's my I have a mock
thing that just is populating it with
mock state yeah but this is like real
state and you know if the actions are
still here yeah yeah so yeah that's just
I was just I just mocked it out so that
I could work with it in here and was
what's really nice about working it with
here is that I can use you know the
normal console and stuff like that where
if I work with it in the actual dev
tools we have like a browser console and
that make sense
sorry yes so this yes this is one
instance of the dev tools this is just
like a ma it has mock data in it sorry
if I should have explained that and then
this is our second so I mean we use dev
tools to debug the dev tools all the
time so I'm probably more used to that
than you guys are oh wait just wait I
think there's a third instance of dev
tools that I can open up here so there's
our browser tool box that we use to
actually debug the actual you I so
sometimes even have a third instance you
know we can come in here and inspect the
dev tools and say oh here's this button
you know and here's all the zool stuff
yeah I should have explained at the
beginning my bad I'll take one more
question maybe yeah
is there anything apart from time that
stopped me from running with react no
it's just that's like the second
migration step and this is the first one
because I'm not sure if I explained that
as well either but essentially with that
really messy architecture like we had
realized that we really had to clean up
everything first before we could use
react react integrates really nicely
with systems but it kind of also has to
your views have to be isolated and our
views were like touching everything and
so to clean up those what was touching
each other I essentially realized was
implementing kind of like a redux tile
thing but the I hope these real or we're
still talking about on the team so I'm
not really like announcing we're
rewriting everything in react because we
can't rely Cree right stuff but it's
just time to figure out where to use
react and i hope i hope we use reacting
a lot of stuff yeah do we have
volunteers or contributors yes we
absolutely do and i'm hoping that when
we use react we'll have a lot more
people in the react community contribute
to yeah we definitely have a decent
amount of country i don't have like
numbers for you but part of the goal of
this is to make things more sane so that
you can come in and just like make a
change and things won't break because
right now it just is little fickle so if
you want to contribute come talk to me
for sure so all right i think i'm at a
time thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>