<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Production Prolog&quot; by Michael Hendricks | Coder Coacher - Coaching Coders</title><meta content="&quot;Production Prolog&quot; by Michael Hendricks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Production Prolog&quot; by Michael Hendricks</b></h2><h5 class="post__date">2014-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/G_eYTctGZw8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in the first part all blades kind of
blazed through the language intro and
get to the meat of it so that's me on
all the social things this is us I
actually don't have internet right now
so I can't show you the website but we
track historic videogame prices so if
you collect old-school video games
you should check us out anyway that's
because I don't have internet I think
yeah
oh I'll narrate the pieces that you use
use your imagination instead of the
Internet so we used to do back you know
back when internet was books
okay so we're a polyglot shop we have
all these languages in production and
we've had prologue in production for
about eighteen months now so this talk
is is about some cool things that we've
learned things that we like and things
that we don't like some background on
prologue is a language it is based on
first-order logic
Prolog is probably the most popular
language in the logic programming family
and it's been around for quite a while
the first version of Prolog came out
same years the first versions of small
talk and see pretty productive year for
programming language development and
because it's been around for quite a
while there I would guess maybe half a
dozen language implementations that
would be good for production use we use
SW i SWI prologue which i'll talk about
sort of why we chose that later one of
my favorite things about logic
programming specifically is how
ridiculously simple the execution model
is you know you have basically four
pieces for hmm yeah for moving parts
like I should say you have logical and
logical or you have turn rewriting and
then you have unification which is a
fancy pattern matching mechanism and
based on combining those four
fundamental pieces you get all
computation that you care about which is
pretty neat I'll show you a quick demo
of sort of what Prolog looks like a lot
of your development happens at what we
call the top level what most other
languages would call a triple a
capitalized thing is a variable that
represents some
thing whose value you don't know yet
equal represents unification lowercase
things represent symbols we call them
atoms other languages column keywords so
here I just asked Prolog does a equal
foo and it helpfully says well if a
equals foo then a equals foo maybe not
really useful but I can ask it
so does a equal foo and is a equal bar
and Prolog says that that's not possible
that's because in Prolog values are
immutable so once the value of a has the
value foo it can't have any other value
and a previous talk talked about some of
the benefits of that probably most of
you already know Prolog also has
compound terms this is a way of bundling
pieces of data together so an atom
followed by an open parenthesis creates
a compound term with two pieces and I
can I can unify those two terms and
Prolog will say you know if I make these
assignments than what you asked for is
true now these data structures can
become arbitrarily complex so you know
you can unify two trees and the pieces
that match between them will will come
out one other important piece here in
Prolog is I might I might ask so if it
does X equal a semicolons logical
disjunction so or or maybe foo of x
equals foo of seven let's say oops so
Prolog says well if x equals a then the
thing you asked me is true and it pauses
here for a moment saying there may be
there may be more solutions but it
hasn't gone any effort to find them yet
it will lazily evaluate those as I asked
for them so if I press semicolon it'll
go ahead and find the other solution so
you can see here that Prolog is
dynamically typed X could be an atom it
could be a string it can be an integer
whatever I can tell Prolog I guess
that's gonna
wrapped a little bit but I can tell
Prolog lie on they care about the
integer solutions and it will only find
the ones that I did I asked for are the
ones that meet my full constraints so in
Prolog all of your all of your code
lives inside of the database and you can
create that database just like you would
any other database this particular
predicate listing queries the database
and then generates the code on the
screen so here I have this silly little
predicate called Baz I can run it it
gives me values 1 2 or 3 but because
it's just a database I can modify it so
I can tell Prolog well Basile 4.0 is
also true and if I run that you can see
that my code is there and if I list it
you know you can see this very last
Clause down here it's in there so I
modified my database no Mike my code is
just living in the database which is
kind of cool we'll show some more neat
tricks with that later one last intro
piece I wanted to give with Prolog is to
describe you maybe the way you think
about writing stuff in Prolog in most
functional languages you think of if I
have this value you know how do I map it
to some other value in imperative
languages you think of kind of like do
this then do this then do this in Prolog
what you ought to think about is what
are the relationships between things so
imagine I have a list of values here and
a list of values here and if I put those
two lists together you know append them
together then I get a third list well in
Prolog we think of that as simply a
relationship between three lists and any
number of lists could could sort of meet
the requirements of that relationship so
I could say if I have a list a and the
list with B and C in it now what happens
if I append them or like what is the
list L which satisfies that constraint
and it's just the one that you would
think but because this is a relationship
you can run it in every different
direction you can imagine
so I'm asking what list F stuck onto the
front of BC gives me ABC Prolog says
list of a you thought there's another
solution turns out when I asked for it
there wasn't actually one there but you
can even I won't do
all the combinations but you can do cool
stuff like I want to lists appended
together give me the list ABC and
prologue says well like all of these
ones would work I want you to think for
just a second in your favorite
programming language and what would it
take to define the full relationship
between these three lists you know how
much code did you have to write in order
to get all these different modes of
operation and after you've thought about
that this is the full listing in Prolog
two lines gives you all of those pieces
now it's okay if you don't understand
how this works you can you know do your
homework later and figure it out but
when you really understand what your
relationship is you need almost no code
at all and it lets Prolog will run those
relationships in all sorts of different
directions you know less code is better
generally as long as it's understandable
and we found you can do some really
really neat things when you're just when
you're working with less code so okay
there's the piece in there where I said
X equals a or foo of x equals foo of
seven that that logical or highlights
one of the key pieces of how Prolog
works which is backtracking so when I
when Prolog said x equals a like that
would be one solution and I said well
maybe give me some more solutions it
said okay well let me forget about a let
me jump back to before I found that
solution for you let me find a different
one if I had internet I would show you a
cool video of the video game braid have
any of you played braid platformer sweet
whole bunch of pro loggers we've played
braid that shouldn't surprise me for
those who haven't played braid and so I
can't show the demo imagine that you're
playing like Super Mario Brothers and
you're running along and you come to
this you know app it you can either jump
over the pit you can jump into the pit
well maybe if you jump into the pit
that'll be like secret coins down there
or maybe you'll just die and you don't
really know until you try it so when you
come to that pit you face a choice in
Prolog we call it a choice point in
Prolog you just try both you're like
let's jump into the pit and see what
happens so you jump into the pit and
then you die but instead of going back
to the beginning
prolog just says whoa whoa hold on pause
the machine reverse the machine to
before I made that decision undo
everything that has happened let me
stand on the edge of the cliff and let
me jump over this time like okay I
survived that time now I can proceed
forward kind of all prologue execution
is based on that basic idea and this
backtracking notion of being able to do
some stuff and then undo it if it's
wrong is really really powerful I think
most of you have encountered this in one
way or another in database transactions
you begin a database transaction you go
through you're doing a bunch of stuff
that you think is going to work and then
you find out something was wrong one of
your assumptions is wrong
well you roll back and there are no bad
consequences to that you know the
database isn't hurt there's no
inconsistency there that's a central
piece to the way that Prolog can work
and you can use it for so many tricks
that was going to be the braid video
which yeah we still can't see sir
okay for all the lispers out there
Prolog is one of only a few languages
that really is
oh my iconic a lot of languages claim
that that they are but don't quite have
the same feel as you would get in this
and Prolog you really do so in this demo
I'll just show you real quick hmm so
this is just a compound term right line
hello it's it's just data you know I can
like I can display it to the screen I
can unify against it but it's also code
you know I can execute it and this is
more powerful than just like stringy
Vallon JavaScript or something it's it's
actually taking data and saying well
like this is your abstract syntax tree
sort of and if you execute that tree you
get the results you want for for an
example there's a predicate called well
it's a predicate called plus which does
exactly what you think it does there's a
pretty good called map list mmm which is
just functional map so here I'm going to
give it I'm going to say okay add one
two one two and what's the result well
the result is 2/3 that's that's really
trivial but because you're lying because
Prolog is home iconic you sort of get
closures for free so this plus one even
though it looks like a closure it's
something you might do in Haskell or in
enclosure in any functional language
it's actually not it's really just a
data structure it's just a compound term
plus with the argument 1 and map list
the predicate takes the arguments of
each of those lists and it tax them onto
this data structure builds a bigger data
structure and then executes that data
structure as if it was code and then you
get you know it looks just like a
closure but it's sort of not in maybe
the technical sense but one of the
really cool things about this is that
because because Prolog just views all
this data as code code is data we can
get all the same like benefits that you
would expect from a relational style of
programming so here
I'm just asking prologue like what would
I add to 1 &amp;amp; 2 to get 2 &amp;amp; 3 and it says
well obviously you would add 1 this is
really powerful when you can use it well
and you define your relationships well
you can write code once and get like 3
or 4 different views on the same thing
it's really pretty slick with that I
think largely stems back to some of the
benefits you get there are because
Prolog is some iconic so enough
intro to Prolog this is actually what we
do in production so are of all the you
know half dozen different Prolog
implementations we chose to use SWI
Prolog partly because they have the best
development tools that I'm aware of some
of the commercial systems may have had
better ones but we preferred something
open-source where we can fix bugs as we
come along and they have all the things
you'd care about like a debugger and an
editor and different analysis tools and
things but I wanted to show you the
debugger because it's one of my favorite
Prolog is a language probably makes me
smile more often than like any other
language and when I first saw this
reversible debugging it was like my
dream come true so here's a little
little demo
I wrote a predicate called hi it should
be true for any atom which is 4
characters or smaller and it's obviously
broken because high is short but it it's
not saying that it is so I'm going to go
ahead and run this in the debugger and I
apologize for some of you at the very
back this is as big as I can make this
this text here so you'll have to bear
with me so I think for a minute all of
you in your favorite language in your
favorite debugger you've all sort of
been through this process where you know
something's busted and you're going
along and you say okay skip this skip
over that skip over that skip over that
now I don't think this one's busting to
skip over that and you're like ah crap
that was the busted one so now you exit
your debugger you go all the way back
you go through your whole process you
step over you try to remember or you set
a breakpoint or something all right now
this time I'm going to step into it and
you step in so I want to show you that
how that works with prologue and
backtracking so I'm going to skip over
this one that was fine skip over this I
think it's okay
okay that's actually not okay it turned
red because it failed so instead of
restarting anything I'm just going to
press the letter R and it's going to
backtrack and like pretend that I
clicked step into the first time around
and I'm gonna do the same thing here
step over it no alright I'll press R
backtrack we'll try it again okay so
here all right that one's busted
and this one really is busted so here
I'm in my debugger I can see that the
broken situation is where T is the empty
list so I'm going to press E and E is
going to put my debugger into edit mode
and as you can see I left off a base
case I'm going to save my code I'm going
to compile my code now I'm going to
press retry notice we're still in the
debugger like I still have my stack
trace I still have everything that I had
before I'm going to ask prologue to
retry and it's going to pretend that the
code I had written before was actually
there the first time I press R look it
finds the base case go all the way back
through and we can see prologues is true
now in this circumstance like this is
trivial and stupid and this demo was
maybe doesn't show the full power of it
but when you have a like big production
system and things are broken deep down
inside and you can walk all the way
through it and you can change the code
like in real time you know if you've
done stuff in like in small talk
this sort of like real-time editing is
really nice it's nice to have all the
context there while you're you're
modifying your code really powerful we
really enjoyed it now if you want to see
even smart cool debugging tricks there's
a language called from Mercury how many
of you played with Mercury a couple okay
Luca is kind of cool mercury is like
Prolog and Haskell had a baby and it's a
really beautiful baby but kind of like I
don't know moving has ever heard of this
baby but they have this really slick
trick they're bisecting debugger it's
like taking get bisect in your debugger
so you're running your code and at
various points it'll pause the system
and it'll say hey does this look right
and you say oh yeah that's that's all
fine it'll positive it later does this
look right you say no something's
something's not right there and as you
answer those questions yes and no
by sex the call tree until it finds the
point in your code where something went
wrong and you're like okay right here
this isn't and you fix it and then you
know you move on to doing other things
like spending time with your family or
something it's it's really awesome now I
don't think this exists for prologue yet
I it there's no reason it couldn't but I
don't know anybody that's ridden it if
you get a chance you should play with
Mercury's bisecting debugger it's kind
of mind-bending I'll kind of blaze
through this one but because your code
is just data living in a data database
you can write some tools pretty easily
SWI Prolog has a code navigator you know
like everybody else's language has but
it's just not that hard to write because
it's just queries on the database of
your code and then it shows it shows the
code or same thing that you've got a
really nice cross reference ER where you
can load up all of your code and then it
shows you this graph of all the code
that calls other code and the predicates
that depend on other predicates and you
can quickly get up to speed on which
modules may be intertangled too much
which modules are really highly relied
upon and all that it's fairly
straightforward just because it's just
database queries I guess one of the one
other part worth mentioning for
production stuff there's a predicate
called check you run check and it does
some simple static analysis on your code
and those static analyses are pretty
easy because you can look for look for
bad code just because it's just data you
just pattern match on that data and you
say you know if somebody calls code that
looks like this
that's like a code smell and so
recommend something else instead and you
can hook into this check predicate as a
library writer so if you write a library
for your team you can add rules to check
the code of your team members and say
you know if my team member writes this I
know this seems like it's the right
thing to do and I wish I could have made
the API like make that impossible I
couldn't so I'm going to put this into
the check rule and when they type check
it'll be as if I'm sitting there over
their shoulder saying this piece right
here that's not cool you shouldn't do
that
and I think this is all possible because
your data is just your code is just data
and you can play around if it in query
it so we'll move on to some other stuff
almost all the rest of the talk is going
to be on
libraries that we've found really useful
in our production prologue code SWI
prologue has a system of third-party
libraries called packs in order to
install a pack you just do that at the
top level and these are all ones that
we've really liked for all of you who've
written prologue before you'll know kind
of the pain of coming up with names for
stuff you have on these intermediate
values and you don't really care about
the intermediate value you care about
the final value but in order to have the
predicates know what they're talking
about you have to have these
intermediate names and they often end up
with names like you know l0 and l1 and
l3 and that's not really helpful and you
shouldn't have to spend time thinking of
those names so library function have
some simple expression syntax or some
simple function syntax in Prolog which
still generates the same stuff
underneath it looks about like function
application in in Haskell they also have
function composition now this really
isn't functions because these are still
predicates and the code that's generated
internally is just a bunch of predicate
calls which means that you could run
this code forwards and backwards if you
wanted to just like you could any other
any other Prolog code so we like that
that's that's pretty helpful library
mavis is optional type declarations for
Prolog in Prolog history even though
Prolog is dynamically typed there's sort
of a culture at least especially in the
SWI Prolog world of adding type
declarations in your comments so we have
structured comments you can generate
HTML from them and stuff like that so as
an API designer you know you often say
like well this should be this should be
a string and this should be an integer
and you add that as documentation to
those who are going to use your library
but
Prolog is dynamically typed and so
nobody's going to enforce that code so
with library mavis it is a series of
macros which takes that structure
comments it parses them into runtime
type assertions so that as you're
running your code as you're running your
test suite or whatever it'll check those
things and throw an exception if
something's wrong
thereby putting you into the debugger
where you can play around with it and
this is
we've found to be really useful even if
nothing else just to make sure that your
documentation is is good another neat
trick I don't know that I've seen this
anywhere else I'm sure other languages
have it but in prologue a type is just a
predicate specifically there's one
predicate which there is your type is a
predicate which is true for those values
that belong to your type and false for
all the other ones so any type that you
can describe with a Turing complete
language you can make it a type in your
system so you could say like you know
this this predicate only except prime
numbers is the first argument and you
can define a prime type just by doing
like I don't know some sort of Prime
detection in your in your predicate and
library mavis will then during runtime
it'll it'll run those checks and say
whoa you said you needed a prime here
but you gave us four that's not cool so
we found that that pretty helpful also
we saw reversible predicates with map
lists and the plus and have map let's
get sort of run in different directions
I won't show you this demo because it's
not very exciting but being code is the
BitTorrent encoding library and as far
as I can tell the Prolog implementation
is about half the size of the next
shortest implementation and that's
because the Prolog implementation is
just a parser so it just knows how to
parse BitTorrent encoded values and then
if you want to generate BitTorrent coded
values you just run the parser backwards
it's like it's really slick so you know
that your parser and your generator or
in the sink now you can't always do this
like BitTorrent protocol is nice because
it's isomorphic there are a few other
occasions where we've been able to do
this with our our parsers and stuff but
it's really cool like when you when you
go to your parser and you modify it and
then you know for sure that you will
always generate the right stuff that
your parser can support because it went
through the same code path it's kind of
fun we don't actually use that being
code library in production but I wanted
to share that one because if you're
looking online it's a good example of
using co-routines and laziness in Prolog
to do
some reversible parsers that things that
might not seem obvious that you might
feel like oh we can't do this this can't
be reversible it often can be if you use
Prolog co-routines so you can look at
that for fun
all right constraint logic programming
how many of you know constraint logic
programming pretty good I'm impressed
with you guys like a lot of these
audiences you go to and there's they've
they've never even heard of Prolog let
alone tried it or no constraint logic
programming constraint logic programming
is some kind of cool stuff the idea
let's say I have a variable that
represents where I live now in typically
in Prolog a variable means like nothing
I don't know anything about where I live
well all of you can tell by listening to
me talk that you know something about
where I live you know that I live
somewhere in the United States so you
can probably infer that from my accent
if you're like dialectologists or
something you can probably infer I live
in the Rocky Mountain State somewhere
you know a little bit about where I live
and so the idea is given all the little
bits of things that you know can you
solve for values that are reasonable
values that that will solve all of those
constraints and the answer and
oftentimes in lots of useful problems
you can there's a library called Julian
which is a library doing dates and times
and the whole library is based simply
upon on constraints so it knows a few
things about calendars it knows for
example like a week has seven days it
knows you know there may be I don't know
31 days in July it knows that that
February has certain patterns of days
based upon the year so it knows all
those things and then you ask it
questions about certain dates and times
and it solves the constraints to figure
out the answers so let me show you a
little demo of library Julian so the
main predicate you work with is called
form time form is like a template
representing the date you care about and
time is the internal representation of
the time so a simple a simple template a
simple form is is now that represents
the current time so the current time is
represented by that internal internal
format now let's say I
want to know the time I want to think
about times in terms of UNIX epoch times
so how does that time that I just talked
about this one up here T how does that
relate to UNIX epoch times so I simply
declare that these two things II and T
are related in this way and Prolog
solves all the constraints internally to
figure out what UNIX epoch time is
related to that particular time I could
ask questions like is today Friday like
is that time T Friday and Prolog says
nope there is no such like Friday does
not meet the constraints or T does not
meet the constraints for a Friday but I
could say well then so what constraint
doesn't mean it meets the ones for
Thursday and this all happens internally
just based on those few rules that
you've defined now imagine I guess maybe
more concrete something bigger let's
imagine you to find some constraints for
your business maybe ships on like Monday
through through Saturday and the US
Postal Service operates you know most
Monday through Saturdays but some of
them they don't because it's a holiday
and so you have these two independent
constraints that define your shipping
logic and that define the Postal Service
calendar and I want to know like on what
two days to those coincide I simply
combine those constraints I simply say
these constraints must be true and these
constraints must also be true and then
you can query it for things like is
today a shipping day what is tomorrow a
shipping day like how many shipping days
are there between now and Christmas
those same logical constraints you can
solve it all those different ways to get
some really really cool stuff so we we
enjoy that a lot
concurrency seems like everything needs
to have a concurrency story these days
and I think that's a good idea Joe
Armstrong gave us some good insights
this morning on sort of why that's a
fundamental piece about why we should
care about that
and most Prolog implementations these
days have a decent concurrency story SWI
prologue that we use has a good mapping
to native threads they give you channels
and things for communicating message
passing between your threads but I
wanted to show one
library that we've found to be
particularly useful so I have a
predicate here called slow because it
executes slowly while it's running down
here on the bottom you can look over
what it does so it queer ease some
attendee database for my name whoops
then query is a session database for
information about this session pulls out
some pieces and displays a message so
when I run that takes about four seconds
to execute and these aren't actual
database queries since I have no
internet access here they're just like
sleeping for two seconds to pretend that
they're doing something useful but it
took four seconds you can see off here
to the right that took four seconds but
that's that's ridiculous like there's no
reason why that should be because the
attendee database in the session
database are two different things
conceptually they can run concurrently
there's no reason why they should have
to run linearly here so I want you to
think in your language of choice how
would you take this code and how would
you how would you say these two pieces
are independent of each other I don't I
don't they don't have to wait one after
the other in most languages you're going
to have to spin up a couple threads
you're going to have to send some
messages over to those threads you're
going to have to you know wait for those
messages to come back you're going to
have to block and you know none of
that's hard we've all done it like a
thousand times but conceptually when you
read through this code you end up with a
whole bunch of concurrency overhead you
have to read that overhead and you have
to make sure like are they pulling from
the right channel and did they create
the right number of threads I don't
think you should have to do that and so
libraries spawn lets you do this which
is pretty slick so you just say that
thing there and that thing there those
are concurrent so if I run it now it
takes two seconds and that's because
those two things are going and
concurrently now behind the scenes like
it's doing all the same stuff it's based
on the same fundamentals it's still
spinning up threads and it's still
creating channels and still sending
messages back and forth between the
channels but you don't have to read it
you don't have to look at it you don't
have to make sure that you got it all
wired correctly it's all wired
automatically based upon the data flow
in the
variables in the in the Prolog code and
I can't tell you how fun it is when you
get like a pull requests and somebody
says like make this this web web request
make this concurrent and like all it has
is like adds spawn adds bonehead spawn
and you're done that you read that patch
like yep that's right and it's exactly
what he meant
you shouldn't have to read like a
thousand lines and concurrency overhead
to figure out that these three things
are independent there's a really cool
stuff in Prolog land for independent or
or independent and concurrency
independent or concurrency competitive
or concurrency it's really neat written
neat stuff stretch your mind if you're
interested in that sort of thing so we
like that a lot
saved States save states are fun who has
used like small talk images or dart
snapshots or okay a few people these are
like my favorite production trick from
prologue ever so this is what a safe
state does imagine you have your
prologue interpreter and you say okay
prologue I want to run this file over
here so it loads up the file it pulls in
all the modules that you've got it
parses them it compiles them it does
whatever optimizations it's going to do
to the bytecode and then right before
it's going to run your code it says well
we'll hold on pause right there it takes
a snapshot of your whole interpreter and
saves it to disk and then it you know it
can go on doing it over whatever it
wants reckon it can quit right there so
once you have that file it's this single
fully packaged version of your code and
you can run all your tests against it
and if it passes you just throw that
file up on a server somewhere and you
know that your server is running the
exact same code that you wrote because
it's bundled up in this little file and
another nice thing if you run in
environments where your code has to like
start and restart a lot all the
compilation and the loading has already
happened it's not like in some languages
where you throw some stuff up on the
server and then you hope that the
Internet is working so it can like grab
all this stuff off of like some ruby
gems or something like you don't worry
about that because you did all that
beforehand and it's all bundled up in
your little little package it's really
neat there's a
I'm playing around with a way to use
library spawn and save States to spawn
off computations on foreign servers on
remote servers you have some questions
you want to make sure that cost model is
apparent to your users
but conceptually it's no different than
forking a step a process on like a UNIX
machine you know your serf creating a
copy of yourself and then resuming
execution there's no reason you can't
create a copy of yourself by making a
saved state shipping it off to a server
in the cloud somewhere and having that
run communications via message queues or
something anyway we don't use that in
production because it's completely
hypothetical but I'm pretty sure it
would work there's no like technical
difficulties
per se because the save States largely
handle all the stuff you care about
that's how you make save States pretty
straightforward alright I'm glad I had
enough time to get to this part of the
talk in a lot of these conferences it's
it's kind of like a like religious tent
revival for filling fill in the blank of
your language I was at a NGO conference
the other day or a couple weeks ago a
couple months ago I guess now and goes
pretty like we we run a bunch of go code
but the whole time I was thinking like
don't any of you ever have any problems
at all with your go cone because I know
a lot of people who use go and they have
problems to you like every programming
language sucks it's not all riding
around on unicorns all day long and I
wish that more talks would talk about
the stuff that sucks because we need to
know what we're getting into so these
are some of the things we haven't we
don't particularly enjoy and please come
talk to me later about more of the cost
side you know you gotta have like the
carrot before the stick so this was
mostly carrot you can come to me later
and I'll hitch it with the prologue
stick but these are a few a few of them
one of them is a syntax I think I see
Joe Armstrong over there he can tell you
I'm sure way more about why this is the
way that it is if any of you have used
airline airline and prologues share a
lot of syntactic history it's not a big
thing but sometimes I just get annoyed
maybe like the anal retentive part of me
is annoyed when I have a patch from
somebody that changed the line just
because the a period needed to become a
comma
I don't know I think that's lame and
sometimes you get merge conflicts
because of it and that's even more lame
I'm not sure if there's a great way
forward to fix this maybe there isn't
maybe it's just something you have to
live with but it bothered me a little
bit a more serious problem though is
that the small ecosystem there aren't
very many Prolog programmers in here or
in the worlds like I don't know what the
number is but probably like 2% of them
are in this room right now maybe not
that bad but if that means that there
aren't a lot of really great people
writing Prolog code for you you know if
you if you run a Java shop or a Python
shop or JavaScript lots of people that
you don't pay are working hard to give
you cool stuff in the Prolog world there
aren't as many of those people working
for you for free now a lot of those that
are really smart and that's pretty cool
but it's it's still a small ecosystem
and some of the tools you may take for
granted you're like I don't think
Coverity has a static analysis flavor
for Prolog they do for a bunch of other
languages but not for Prolog not to say
that you couldn't do static analysis you
can do some really cool static analysis
with Prolog but the ecosystem isn't
there another one is the learning curve
if if you're coming from an imperative
background or if you're hiring
developers that are coming from an
imperative background they're going to
have a steep time ramping up on on
Prolog it's not because they're not good
programmers but it's just a different
way of thinking about things and and
oftentimes they'll write code it's very
imperative in flavor in Prolog and and
that's not really what you want I mean
it'll work maybe it'll get the job done
but that's it's not really you know
they're not playing to the strengths if
you're coming from a functional
background this is a lot easier and if
you're if your team already has a lot of
functional programmers on it this
transition would be more pleasant for
you but I've found so before I started
using Prolog in production the language
I've been working on a lot previously
was Haskell and I kept writing this code
that would have been pretty slick
Haskell and then I'd be like whoa what
are you doing like this is prologue use
logic variables like you mean it mister
and you know like I look at my code
later and it was just kind of shameful
and
nothing wrong with that but that
prologue isn't haskell prologue isn't ml
prologue isn't airline
all those languages are beautiful in
their own way but when you're writing
prologue you know like sit down and hold
its hand and tell it nice thing is it
like work with it like like you like it
and you're going to get fantastic
results when you do I saw the other day
this is I guess a digression from my
prepared remarks I've been thinking for
quite a while on how could you do a
really elegant declarative key-value map
and I thought of all sorts of
interesting ways you can do it and I was
reading a book called the art of
prologue by Leon Stirling and forget his
first name Shapiro anyway toward the end
of their book they have this chapter on
different structures and in the in the
heading and the indexes said difference
map and I was like well that'd be slick
I bet that's really declarative it nice
like the whole thing was three lines of
code and it was it was so beautiful i
sat there I'd be honest I was on the
toilet i sat there for like way too long
I was like wow this is fantastic like
this is beautiful
this makes me smile and it's not right
for every occasion you know that how
Heineken has this commercial about the
handlebar moustache not right for every
occasion like this data structure is not
right for every occasion but when you
want it it's just so beautiful and so
pleasant that learning curve like being
able to find that beauty is not always
easy and it's going to take some time
for your team to ramp up on it that's
kind of a downside another one is
failure so so prologue is based on logic
in logic you have true and you have
false they're equal citizens in the
world neither one is bad they're just
different one from another and so when
something fails in prologue it assumes
that when you must want the answer false
like you must want me to tell you that
this thing you thought was true is not
true well oftentimes it's far more like
I don't know asking your two-year-old
son to like clean his room and he'll
just sort of stand there and look at you
and he'll say no like what do you mean
no go clean your room No and you sit
there and you try to think like why
what'd he say no why is this so hard and
sometimes Prolog is like that sometimes
trying to convince it to do what you
want is like working with an obstinate
two-year-old you've just written 10,000
lines of prologue code and you type in
go or whatever and it just says false
and you're like god you're killing me
give me a stack trace or something you
know throw me your bone now that the
debugger makes that easier it's a little
bit nicer because you can just you know
run through it real quick look for read
do retry but it's not as nice as I would
like I wish there was a way that somehow
failure could likely little hints behind
and if that failure reached the top
level you could say well let's let's
back up I haven't figured that out
hopefully somebody will but it's it's
kind of obnoxious sometimes macros are
are hard to debug in probably almost
every language that has them but they're
super powerful and with great power
comes great responsibility so I don't
know maybe great pain wanted the other
the other one is that all this magic
doesn't come for free 98% of the time in
prologue I don't think about performance
at all but 2% of the time I do and
that's because some of this magic comes
up to the surface you know in most
languages it's like ninety nine and a
half percent of the time at least for me
I don't think about performance I think
about solving the problem in prologue
that's more often than I would like now
you can still drop down to see they're
still good profiling tools if you need
them but it's something to think about
if you're doing something that's super
high performance critical you may want
to think about that you know do some
inch parks and things and see if see if
it's what you want anyway that's the end
we're all out of time but I'd love to
talk to any of you later thank you for
coming to the talk today</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>