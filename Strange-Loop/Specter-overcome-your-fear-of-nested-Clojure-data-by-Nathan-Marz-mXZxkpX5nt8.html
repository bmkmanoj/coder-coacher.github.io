<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Specter: overcome your fear of nested Clojure data&quot; by Nathan Marz | Coder Coacher - Coaching Coders</title><meta content="&quot;Specter: overcome your fear of nested Clojure data&quot; by Nathan Marz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Specter: overcome your fear of nested Clojure data&quot; by Nathan Marz</b></h2><h5 class="post__date">2015-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mXZxkpX5nt8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I changed the title of my talk a
little bit but with the latest release
of Spectre I really believe this to be
true and I think by the end of this talk
you will all agree with me so this is
actually my last slide the rest of this
talk will be in Emacs which I think are
the the best kinds of talks so Spectre
is a library that solves a pretty
straightforward problem which is the
ability to query and manipulate nested
data structures it's a problem that
comes up constantly when programming
closure I've been programming closure
almost a hundred seven for five years
and this was always a problem that
really frustrated me so last year I
decided I would do something about it
and I made this library Spectre the cool
thing about Spectre is not only is it a
very very elegant API for doing these
manipulations it's also extremely fast
and that's been a real focus point for
Spectre so I can't want to demonstrate
what I mean by these kinds of things
being hard to do with just the
facilities that closure provides on its
own so let me give you an example so
let's say the the state of your program
or the state you're manipulating it
looks like something like this so we
have this variable called world and
vanesa data structure with has two
fields people in bank the bank contains
funds and then people is a list of
accounts where each account has a money
field and a name field associated with
it and notice that the people are
indexed let's just say their index here
in the order by which they join the bank
they're not actually indexed by their
name so if you want to get ahold of
someone's particular account you need to
do a scan and filter through that list
now let's say you want to write a
function which transfers money from a
user to the bank so let's see how you
would write this manually using closures
based facilities so here we have this
function user the bank takes in a world
and then a person's name and then the
amount to transfer and so first what to
do is make sure does that person have
enough money to transfer that amount to
the bank if they don't then we should
throw an error so what we do is we first
navigate into the world data structure
so we look at the people we filter free
only users that have that name and then
the first one of those will be the
matching use
we get the money and then we check if
they don't have enough funds we'll throw
an exception
otherwise we now need to do this
transformation on the data structure and
the transformation needs to decrement
from the person's money and then add to
the bank's funds so first and we'll do
is we'll remove the money from the
person's account so we'll update the
world data structure and we'll update
the people field and then we give it the
update function and the update function
takes in a list of users so then we map
over the list of users for every user if
the name is equal to the name that we
desire to take the money from then we
update the user by with the update
function of subtracting the amount from
them and if it wasn't the user we need
to make sure to return the user because
we need to make sure - for everything
that's not getting updated to actually
reconstruct that original data structure
in the in the outputted results and I
want to know I also want to emphasize
that this map V call the reason we use a
map V instead of a map is because the
type of the data structure here is a
vector if we used a map it would change
to a list so it's really important when
you're reconstructing the original data
structure to maintain the types that
were there before otherwise operations
you might try to do later might not work
and it's because some other operation
change some type that it wasn't supposed
to change okay but after we do all that
next thing we can do is update the
bank's funds and update in is one of the
very few functions closure has for doing
method operations so you can see this is
a lot easier
take the bank's funds and add the amount
to it this code makes sense to everyone
has everyone here written code like this
before I know so to me like I hate this
kind of code like first of all I think
it's really hard to read like it's
really nested like the actual a lot the
only logic you care about is adding to
the bank's funds and subtracting from
the user accounts funds and like the
used subtracting from the user account
is in a deeply nested function within
this overall function and also it's
complex because not only needing to
figure out how do i navigate to my data
structure
you to make sure to be very precise and
reconstruct the data structure as it was
so there anything you're not changing
remains as it was
so something really seems wrong here
first want to show what this function
does so I'll run this function on John
Smith and we'll take $25 from his
account and I have it set up here so
that it first prints the world data
structure before the transformation and
then prints the new world data structure
after the transformation so you can see
John Smith is 25 less dollars in the
bank has 25 more dollars so now I'm
going to show a function written using
Specter to do similar kinds of
transformations but this function I'm
going to show you is actually way more
general than the function you just saw
the function you just saw can only
handle transferring from a single user
to the bank the function I'm going to
show you here
it handles arbitrary many-to-many
transfers of a fixed amount between
accounts so just to kind of elaborate
what that does let's say you've decide
to transfer from three entities to two
entities and you're transferring 50
dollars that's the amount that you give
as input so each of the three entities
will end up giving a hundred dollars
total while each of the receiving
entities will end up receiving 150
dollars total
okay because it's 50 dollars is going
between every pair of givers and
receivers so let's look at how this code
works and so first so the arguments to
the function we take the world data
structure and then we take these two
arguments from path and to path and
these these are paths within the data
structure that identified the entities
that we want to manipulate and we'll see
the details of this shortly and then we
take the amount we want to transfer
between all entities so first thing we
do is we use specters select function to
select the amount of money that every
giver has from the world so we just say
select from path world so if we were
selecting let's say John Smith and
Charlie Johnson this would return us a
sequence of 128 2870
and then we do the exact same thing for
the receivers so you see how much money
they have in their accounts and then we
compute the total amount every receiver
will receive which is just the amount
multiplied by the number of givers and
then the total amount every giver will
give which is a similar computation and
then we check to make sure every giver
has at least that amount if they don't
we'll throw an exception but if they do
then we'll take the world and then we'll
do two transformations on it
first we will manipulate all the giver
accounts and subtract the total given
amount from them and then we'll
transform the receiver accounts and add
the total received to them cool so I do
want to so I think this code is really
elegant I think it's easy to follow and
every line in here matters it has to do
with the logic of what we're trying to
do and another thing I wanna another
cool thing about this function is this
function is actually completely agnostic
to the world data structure our user to
bank function is specific to this
particular world data structure whereas
this transfer function can handle any
world data structure because the details
of the structure we're manipulating are
encapsulated in these paths that we pass
in and another cool thing about this
function is that it can execute
extremely fast and we'll see that later
of course however this works depends on
whatever magic that select transform and
these paths are doing so let's take a
look at how all that stuff works so
we're gonna take a quick detour just to
explore all this stuff
cool
all right so the first example I'll show
is a pretty simple example of select so
we have a sequence of maps and the maps
all contain an a key and you can see one
of them contains a B key and what we're
going to do is get all the even values
for a keys in all the maps so the path
that will give is has are just a
sequence of navigation steps and so the
first step is to navigate to every
element of the sequence and then for
every element of the sequence we
navigate to the a key and then we only
stay navigated there if it's even so if
we run this on this data structure we
get the results two and four just as
we'd expect so the transform so
selectors for doing queries where we
want to extract values from some nested
data structure transform lets us
manipulate in a message data structure
so let's say we want to take the exact
same structure and we want to decrement
all the even values for a keys so it
looks almost exactly the same except
transform takes one additional argument
which is the update function to apply to
every navigated value and if we run this
we get well just as if you expect the
first map had eight go from two to one
and then the last map had a go from four
to three and the middle map were a was
odd does not change at all so I want to
take you through how exactly this works
like how does Spectre handle data flow
so we'll see like what happens what is
what is the the mental model you should
use for the transformations happening at
every step of navigation so in this
transform function we start with this
sequences input and then we do the all
navigation so the all navigation now
creates basically a new navigation
context for every element in the
sequence so you can see here we have
three context which is for each of the
maps in the sequence and then we run the
a keyword to navigate into the maps and
so for every map it navigates to the
value for a so we have 2 1 &amp;amp; 4 then even
is a filter so it only stays navigated
where the numbers
even so you can see now we just stop we
just stop dealing with this number one
and now we've actually reached the end
of the navigation so we applied the
update function to all the values we've
navigated to so that's the decrement
function now we have one and three and
now we work our way back to reconstruct
the original data structure but only
with these changes so on the way back
the even filter just brings back any
values that were filtered out before so
that was the number one and then the a
keyword replaces the value in the map in
the original map with the new values
that we have here so that's how we get
these maps and then all will take all of
our navigation contexts and then put
them back into a sequence and all make
sure to maintain the type of the
sequence that we were looking at so if
it was a list before it stays a list if
it was a vector it stays a vector okay
and then that's the end of it and that's
how we get our results and just to show
you that all does maintain the type of
the sequence here's the exact same
transformation except with a list of
maps instead of a vector of maps and if
I run that you can see that yep you can
see that the output is a list not a
vector as as as you want cool
anyone is everyone following me okay all
right cool awesome
all right so that's that's pretty simple
stuff code like I mean even a simple
transformation like this is pretty
tedious to write and closure so let me
show you a different different kind of
transformation into a Specter so this
one right here we have a big sequence
and we want to increment the last odd
number in the sequence so just think for
a second about writing that in closure
manually it's not not going to be fun
but inspector it's very simple we first
used the navigation step filter odd and
what this does is it navigates us to a
view of the sequence that only matches
that filter and the important thing is
that we're still navigated at a sequence
not to the individual elements of the
sequence and then to that view of the
sequence which only contains the odd
numbers we navigate to the last value
and then we increment that value but of
course when the update is applied it's
actually applied into the original data
structure so if I were to run this you
can see that we get a vector that's
exactly the same except that last nine
has now been incremented to attend okay
so let's take a look at again the data
flow of how this works so we start off
with our input which is this sequence of
numbers and then when we run filter or
odd which navigates us to a view which
only contains the odd numbers in that
sequence then we navigate to the last
value which is going to be that nine
because it's the last value here all
right we now reach the end of our
navigation so we apply the update
function so nine turns into ten now we
go back and what lasts does on the way
back is it just sets the value of the
last element of the sequence it was
looking at so that becomes ten and then
filter is really cool the way it works
actually when it does the original
filter it keeps track of the indexes
that every elements it it captured in
the filter was in the original sequence
so it remain OHS that the zeroeth index
of this view maps the 0th index of the
input the first index of this view maps
to the index number to an input and so
on and so on so then when filter
receives this sequence from last it just
sets the values in the original sequence
by mapping the indexes okay and that's
the last operation and that's how we get
the output which is what we wanted thank
you thank you thank you hero here all
weekend folks so let's see some other
transformations so S range is a trend is
a is a navigator that navigates us to a
subsequence within a sequence so here we
navigate to the sub sequence between
indexes 3 &amp;amp; 9 and then we are going to
apply closes reverse function to that
sequence and that has the effect of just
reversing all the numbers from index of
3 to 9 so they're just reversed in the
middle of the sequence of course all
navigators are composable we can compose
them arbitrary
so let's compose sstrange with with the
stuff you've seen before so let's take
all the odd numbers between indexes 1 &amp;amp;
4 and add 10 to them okay that works
fine so S range yeah you can actually
replace that sequence with whatever you
want it doesn't have to be a sequence of
the same size so here we'll take the sub
sequence from indexes 2 2 4 and the
update function will just return five
negative ones if we run that you can see
that that sub sequence has been replaced
it's a pretty common pattern actually
that sometimes the update function
doesn't actually care about the current
value of that at that point so Specter
has this function called set vowel which
is just a very thin wraparound transform
which is lets you write those kind of
transformations slightly more concisely
so this code right here is the exact
same thing as this code up here okay if
we run that we get the same result if
you want to use s range to actually take
out part of a sequence you just say set
vowel on the sub sequence and then you
give it the empty sequence and that will
nuke it from the sequence as you can see
so this one right here this is actually
one of my favorite examples to demo here
what we're going to do is we're going to
take all of the even numbers between
indexes 4 and 11 and reverse their
positions so the navigation is let's
navigate to that sub sequence let's
navigate to only the even numbers in
that sub sequence and then reverse them
and then I'll run that when you can see
they've all been reversed so this
imagines like this one especially like
imagine writing that in closure manually
like I I mean I wrote Spectre and I
can't even imagine doing this manually
encoder and this is like the power this
is the power of I mean coders
abstractions are actually very simple
but the important thing of how close are
expresses is abstractions that they're
very very composable as you've seen and
this right here is the perfect example
of the power of composable abstractions
ok so I have a few more examples so this
one right here we have a sequence of
sequences you can see two of them are
vectors and one of them is a list and
what we want to do is we want to append
the values the key words a and B to the
end of every sub sequence so what we do
this is we navigate to every subsequent
so that's using all and then end
navigates us to the empty subsequence at
the end of the sub the end of the at the
end of the sequence so we take that
empty subsequence which represents the
end and we replace it with a sequence a
B and that has the effect of doing an
append okay so if I run that you can see
a B got appended to every subsequence
and also notice again the types of the
sequences we were dealing with are
maintained no yeah
yeah talk to me afterwards I can show
you that had the implementation alright
so something that happens uh pretty
frequently is that when you get to the
value that you want to manipulate in
your data structure you need information
from elsewhere in the data structure to
do the update but since you've already
navigated so far into it you don't have
access to the rest of the data structure
yet so there's an example the
transformation what we want to do here
is we want to for every map in the
sequence we want to add the value of the
B key to the value of the a key but only
if the a key is even so obviously if
we've navigated to the value of a key we
we have no access to the value of the B
key so spectra solves this problem by
letting you collect values as you do as
you move into the data structure so the
way we do it here is we navigate to
every map and then we collect the value
for the B key and this kind of gets put
aside until we get to the update
function then we now get to the a key we
make sure it's even and then we run the
plus function and Specter will give us
arguments to your update function first
all of your collected values in the
order in which they were collected and
then the value at the point we navigated
to so this has the effect of adding the
value of the B key to the value the a
key but only if the a key is even so
I'll run this right and you can see that
in the second map and the third map
where a was even B was added to it okay
so the last example I have here so what
we want to do here is we have a sequence
of sequences of numbers and we want to
append the keyword CD to any subsequence
that has at least two even numbers in it
so if you remember when we did this
something similar before to just append
to every subsequence the navigation was
all end but now we need to make sure
that any sequence we that we want to
that we transform has at least two even
numbers so we need to add this filter
between all and ends and we can express
that filter inspector using this
function called selected and selected
creates a filter at that point and it
will only stay navigated at that point
if the path that you give it selects
anything so if it selects the empty
sequence we filter it out
if it selects anything other than the
empty sequence we keep it in and so
again we're just reusing all the same
stuff all Spectre paths and so the way
we know if if something has at least two
even numbers we call filter even to get
a sequence of all the even numbers then
we call the view function inspector
so this navigates us to a view of that
value where we apply the count function
so this will navigate us to the number
of even elements in that sequence and
then we have a filter here so we only
keep we only keep that value if it's
greater than equal to two so the end of
this if it has at least two even numbers
this will have this will select one
number if it doesn't then it will select
nothing and you can see if we run this
only the sequences with two even numbers
at least two even numbers had had the
append onto them cool all right so I
want to show you real quickly the little
bit how Spectre works
all right so spectres this is spectres
core right here it's this protocol
everything you've seen everything will
selector all keywords filter functions
filter s range all of these are
implementations of this protocol and let
me show you to actually explain how to
put a whole works I'll show you a
specific example so here's how here's
how keywords input this protocol so by
now you've probably gotten the idea that
when we're using keywords in the path
they're not used like normal functions
obviously there's more logic associated
with them so they can do transformations
and update update values and this is the
implementation how they work so the way
select works is it takes in the the data
structure that we've navigated to at
this point and then a next function
which knows how to complete the select
from any sub values that we navigate to
here so to come to complete the select
from a keyword we just get the value the
keyword from the structure and we call a
next function on it and next function
encapsulates the rest of the path
to do the selection transform the next
function knows how to do the rest of the
transform on one of whatever sub values
that we navigate to from this point so
to complete the transfer from this point
we recall next function on the value of
the key word that will transform the sub
value and then we associational
structure right to reconstruct the
structure as it should be that's it I
find this pretty intuitive although I
find some people have trouble like
grasping what that next function does
but it's just easy to think of it as
just it's the rest of the operation and
this is responsible for just applying at
this point and I think this like
perfectly captures the meaning of
navigating via a keyword into a data
structure I'm gonna show also the
invitation of all very quick ok so see
all is the same same protocol in the
Select case
so all navigates too many values to
every value in the sequence so what we
want to do is we want to finish the
selection from every value in the
sequence a member selection always
returned to sequence of results and so
the total results will be the
concatenation of all the results from
each of our sub values so to do the
Select for all we do a map cat of the
next function over the structure ok
that's because the selection from every
value returns a sequence that we need to
concatenate the transform case is
different
here we actually want to do a map
because next function knows how to
transform every sub value so we do a map
over the data structure to apply the
transformation to every value and the
result we want is going to be a sequence
because all is looking at a sequence and
you can see there's a little bit more
logic happening here and all the rest of
the logic is just to maintain the type
of the data structure closure makes this
surprisingly difficult in turns out we
actually need a special case for lists
versus versus other types but the
overall logic here is it's just doing a
map in the transform case
all right so let's go back to the bank
example all right so we have a transfer
function which we saw before so it does
fix too many too many transfer transfer
transfers so let's use that to do a
variety of interesting transformations
so here we are going to do a transfer
where every single person has to pay a
one dollar fee to the bank so where we
do this is we navigate to everyone's the
amount of money everyone has and then
the two is gonna be to the bank's funds
and the amount William transfers one and
you can see when I run this everyone has
one less dollar and the bank has five
more dollars to do the opposite where
the bank gives $1 to every person we
just reverse the pass and reverse the
order of the pass so now the bank is
transferring to every single person one
dollar if I run that you can see that
everyone has one more dollar and the
bank has five less dollars so let's do a
transformation where all the poor people
have to pay $50 to the bank this is kind
of I don't know if you guys I've seen
that louis c.k bit but he has a whole
bit bit about this so what we do this is
that it's very similar we've navigate to
every cent everyone's account except we
only stay navigated when people have
less than $3,000 all right otherwise we
transfer into the bank and you can see
now that only the people with three a
less than $3,000 have now have 50 less
dollars and I think the bank has a
hundred more dollars okay so here is a
here's a query so let's get all the rich
people so people have more than this
amount of money so we just navigate to
all the people and we only keep people
where the amount of money they have is
greater than or equal to that amount and
then we select that person's name and
usually if we run that we have Donald
Trump okay so what I have here is I have
function called a user so let's say we
want to do we specifically want to deal
with individual users so this is a
function that returns a path to a
particular user using that scan and
filtering strategy
so the path to so there's a function
that takes in a user's name and the path
to that user the account we navigate to
people then for every we will scan
through every single account and we'll
only keep accounts where the name in the
account which is this is equal to the
name that we're looking for
okay so now we can use this to do other
kinds of other kinds of transfers so to
transfer between users so we have a new
function transfer users which takes in a
from name and a to name and then the
amount so we call transfer on the world
and then our path is we get the path to
the user and then we get their money and
we get the path to the receiver or we
get their money and then we we transfer
the amount as you can see here if I call
this function to transfer $10 between
Alice and John that is exactly what
happens so you can see this how
composable we can we can construct a
path here and then and then use it in
another path here because a path defined
as a sequence of navigation steps can
itself be used as a navigation step in
another path here we have a function
called Bank loyal bonus where the bank
gives $5,000 to the earliest three users
in the list of accounts so we transfer
from the bank and then we take the
people we take the first three the
subsequence of the first three people
and then we grab their money and we
transfer $5,000 and that that
transformation works perfectly there's
the interest of time I'm gonna skip some
of these
I was with this one though so this one
has a selector which I haven't showed
yet so here what we want to do is that
we want to take our world data structure
and if if the person if for each person
if they have more than $100,000 we're
gonna add a new key to their their map
data structure with rich true so the key
is rich and the value is true if they
don't it'll be I'm going to change this
not so rich I think I've definitely been
in Silicon Valley way too long so so if
the amount of money they have is more
than hundred thousand dollars we set the
rich key otherwise we set the
not-so-rich key and the way this works
is that we have this selector called if
path where works kind of like if where
we have a condition and if that
condition matches then we're going to
use this path otherwise we're going to
use this path right here and it works
just like selected if this selection
returns anything then it's considered
true if it returns nothing that is
considered false so you can see if we
run this on the world now let me compile
runs on the world so some people have
the rich key set other people have the
not so rich key set and that's done
using that conditional navigation all
right cool
so I'm gonna talk about performance as I
mentioned before this is a major
emphasis of the project and Spectre has
pretty amazing performance so I'm going
to show it by just actually running
Specter on a variety of little micro
benchmarks so the first one I'm gonna
show is dealing with this data structure
here data which is just a nested map of
keys a b c and then all the way nested
is the value 1 so let's let's let's see
how fast it is so the first one thing i
want to show is it's just querying so
let's get that nested value from the map
and we're gonna compare Spector's
performance against the performance of
writing the code manually as well as
closures built in facilities such as get
in so I have this function here called
benchmark where it just times how long
it takes to run this function this many
iterations so let me run this with get
in absolute is okay so get in takes
about 80 milliseconds to do this so now
let's run it using select as I've been
showing you just select it in the path
and you'll see that it actually takes
quite a long time it takes four and a
half seconds so that's that's absolutely
terrible and actually it turns out that
most of the work is actually just
dealing with this path and interpreting
it and doing all the stuff spectral
needs to do to get it to work
so specular has a feature called
precompilation where you can avoid doing
all that work at runtime and just do the
work beforehand and then and then it's
reused that work so the way you do that
is you just call this comp paths
function which just takes in a path like
normal and it returns you this compiled
path so we say select on the compiled
path on the data it takes 60
milliseconds which is faster than get in
but we can actually make it even faster
because if you know that you're
receiving a compiled path there's a
function called compiled select which
strips out some of the overhead and now
it takes 50 milliseconds so this is
significant
faster than get in and I just want to
compare this against like how fast can
this possibly go by writing manual code
so let's just take the data and navigate
to the value directly and then here I
wrap it in a vector just because select
returns a sequence I want to do a direct
comparison and you can see the best we
can possibly do is you know a little
under 40 milliseconds so Specter is
pretty close to like completely in lined
handwritten code but the story gets even
better when we talk about transforms so
let's do let's take that data structure
and let's update that nested value to
increment it so update in is the other
facility closure has we're doing nests
of transformations of course only works
on nested associative data structures so
let's see how fast update in takes two
to the increment so it takes about 10 50
milliseconds so now if we do transform
without pre-comp precompilation takes
you know a little over four seconds so
that's pretty bad if we do a transform
with precompilation it takes 180
milliseconds so it's more than five
times faster than update in and again we
can make it better by doing compile
transform because we know a the compiled
path and now we're down to 170
milliseconds 170 milliseconds okay and
again let's compare this against just
doing the transform completely manually
so here I have a function which just
just does the transform via a bunch of
nested nested update functions and
manual transform takes 150 milliseconds
so Specter is super close to two totally
optimized handwritten code alright cool
so this is that's been the story
inspector for a long time for many
months couple weeks ago Specter story
got a lot better because now Specter can
do precompilation in any scenario and
the scenario where it couldn't do
precompilation before was where the path
that you are the path that you you had
depended on parameters in the function
that you were in so for example if you
had a function like this well let's say
we want just want to
that idea of reversing all all numbers
matching a predicate within a
subsequence like I showed before if we
just want to function if I that it would
look like this where we have a sequence
we have a start position and an end
position and a predicate and then we
transform that subsequence but only
elements match in that predicate and we
reverse them so it's you look at this
it's like okay how do i pre compile that
path when I need these parameters to
make the path in the first place
inspector couldn't do this before
because obviously you can't pre-compiled
something which you don't have yet
which isn't defined yet the Spector in
the zero 7l release a couple weeks ago
has a new feature where you can just pre
compile it without the parameters and
then later on will sneak in the
parameters and they will they will be
there and let me just show you really
what I mean by this and so if we take
like the simplest
so here's a key path so this just
navigates via any any key so it could be
strings or numbers it doesn't have to be
keywords and this takes in a parameter
which is the key when I can navigate by
and you can see we have the
implementations of select and transform
which is to use the key as if it's in
the lexical closure
so when Spector pre compiles it without
the parameter it actually is has these
functions and it's composing them and
the parameter is not there but by the
time this executes Spector sneaks in the
parameter when it's provided later this
was a tricky thing to to implement but
the way it actually works if we go back
to this example we want to make this
function actually run fast we so we
compile we compose the paths without the
parameters so S range it takes two
parameters which are not there and then
filter pred so pred just acts as a
filter and it takes it as a parameter of
the function to filter by so then we get
this new path here called matching range
which matching range now requires three
parameters two for the S range and then
one for the pred so before you actually
use it you just provide the parameters
at the last second so here we do
compiled transform and then we give it
the parameters at the last second an
inspector will map them to to the
correct correct selectors based on the
order in which they were defined so I've
actually just do a quick benchmark of
this without precompilation it takes you
know one point four seconds with
precompilation it takes about 600
milliseconds so quite a bit faster with
precompilation other reason we don't get
like the 10x improvements we were
getting before is because these
particular navigation operations are a
lot more expensive than what we were
benchmarking before which is just not
gonna be a keyword which is super cheap
filter and s range the work they have to
do to reconstruct the original data
structure is much greater but still
still we get over twice the or twice the
speed
cool so I have three minutes left so I
just want to show one more thing which
is just another example so this isn't I
haven't open sourced this yet although I
do stuff like this all the time my
personal work so I extended Spector to
deal with directed basically grass
something I use very heavily in my own
work making honestly making this library
is not difficult at all it's not a very
long library just for me it's kind of
tied into my own stuff so I haven't
taken the time to extract it yet but I'm
able to do very cool transformations
like this so here let's imagine we have
a directed acyclic graph which
represents ancestry so every node is a
person and it might contain fields like
the prison's name and the location and
whatever other information we have about
them and then the edges in the graph are
just parent-child relationships so let's
say we're gonna do a transform here
where we want to add a new field to
every person which is their royal name
which is just their name it's gonna look
like a their name of and then a list of
their parents names so we can do that
transformation like this where first we
do a top sort so we transform in
topological order on the graph and then
for every node in the graph we collect
the names of our parents so we navigate
to every parent and then for the node
which contains the fields we get their
names
and then we navigate to the node that
we're looking at and then we collect the
current name and then we're gonna set
the field for the royal name so then our
update function receives as input first
the parent names then this nodes current
name and then the royal name which
doesn't exist yet so we ignore it and
then we our update function just does
the concatenation and that's it after
you run this I Reno in the graph now has
that new field added which we wanted so
if you're looking to contribute to open
source I think this is a great project
that's not that hard but very powerful
and very cool I have one minute for
questions so maybe we do one question
right here
it should be about the same I mean
Spectre is not doing anything special I
mean we throughout the memory
right but if you were do that manually
you'd have to do the same thing so I
will take one more one more question
let's go right there
I haven't run into that myself so I mean
everything here is there because I
needed it in my own work and you can see
I mean you can tell how heavily I use
Spectre just based on how rich the
library is I haven't run into that I
don't know what it would look like it
probably some sort of like but is it
everything like some sort of recursive
selector yes
well I mean it does have a walk selector
which just does a walk and you could use
that to accomplish what you're you're
talking about heavy - have you tried the
walk selection yeah yeah it just it just
uses closure not walk - to do the walk
all right cool Mourad time so thank you
guys very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>