<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Let's Build a Hygienic Macro Expander&quot; by Matthew Flatt | Coder Coacher - Coaching Coders</title><meta content="&quot;Let's Build a Hygienic Macro Expander&quot; by Matthew Flatt - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Let's Build a Hygienic Macro Expander&quot; by Matthew Flatt</b></h2><h5 class="post__date">2016-09-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Or_yKiI3Ha4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay everyone let's build a hygienic
macro expander so
so if you're here I'm mostly going to
assume you know what a macro is but just
in case you don't buy macro I mean when
I want to write an abstraction for
Houston programming they can't be
written as a function so as an extreme
example I've got show results here its
job is not only to run this expression
and give me a person icon out but also
typeset the code right next to it so
it's a kind of extreme example that
can't be a function because not only do
I want the result I want almost the text
of that expression and I've written it
here in a hygienic macro and the details
of this macro are not not so important
here I've written the same thing in a
non hygienic macro system with def macro
for traditional lists macro and you see
the result is almost the same but in
this case the person is a lot smaller
that's because the height of the person
was accidentally made to be the height
of the text typeset right and that's
because the macro defined height and
that shadowed the height that I meant to
refer to right here so when we talk
about hygiene that's the kind of thing
we're talking about not mixing up the
variables making it work more like
functions even for things that can't be
written as function so racket provides
hygienic macros scheme is provided it
closure provides an approximation to
hygiene that makes certain things easier
but it doesn't work when you have it
doesn't give you full hygiene when you
have local macros or macro defining back
rows or so on and we need that full
generality in racket to do all the other
kinds of things we do with building
languages like here's a typed racket
program that will interact with with
other racket programs and that relies on
hygiene to manipulate the program or
things like our documentation system
where the bindings you know serve
multiple purposes both for actually
running the document and for typesetting
documents with hyperlinks okay so now in
case you didn't know you have some idea
what a macro is I'm also expecting that
you have some idea what hygiene is about
but we're gonna go more into that what
I'm especially expecting you not to know
coming in is about syntax objects and
this is the mysterious technique
mysterious hopefully until just today
that is used to implement hygiene and
make macros work the way we want them to
work so
let's look a little bit more at hygiene
and about simpler programs even so here
in this example I'm defining X I'm being
intentionally uncreated with the
variable name X as you will see but X I
have in mind here is some computation
that might actually not work I'm
starting at my program I'm trying to
compute X maybe it's good and then I'll
get to use it other time but if X didn't
work at the beginning then I'll have to
do some other computation and because
this pattern is going to happen a lot
then I have a premade or macro so
premade or is not a function because the
expression that I give it e I don't even
want to evaluate e FX turned out to be
available I'm just going to use X with
this short-circuiting or so you can see
I'm not really saving myself a lot of
typing but I'm introducing a new
abstraction the idea of use the pre-made
value or evaluate the expression Eve and
here's a use of pre-made or so I have an
X a different completely different X
this X is going to be bound to a
function that I haven't shown but
apparently it does a bunch of work that
I'd prefer to avoid and just use the
pre-made value if it's available so I'm
either going to use the pre-made value
or do all the work of calling the
function X that's what X in parenthesis
means so because pre-made or is defined
as a macro the macro system will
recognize it binding and it'll try to
match up the use with with that pattern
there and the X will match up with E so
it'll use X for E as we expand this
macro and then we have or X call the
function X and you can see I painted and
orange the parts that the macro
expansion introduced to help us remember
that we didn't intend for this X to have
anything to do with that X the color
orange is somehow not enough for that
we're gonna see what is enough as we go
on but you know we're just illustrating
the problem here and it's not that
orange means only look at the top level
because this could be an any nested
binding scope right so we'll have to
work out the problem in a general way
you may also know if you've seen
anything about macros before that or is
a canonical macro example so the way
that short-circuiting or is implemented
it's a macro that evaluates the first
expression binds it to a variable if
that value is true then it returns that
value otherwise it goes off and
evaluates the second expression B
so that's what makes it short-circuiting
again it can't be a function and when we
expand or into its let form then we get
more things introduced by a macro and
here painted them green and you can see
that the green X has nothing to do with
the orange X which has nothing to do
with the blue X the green colors are
maybe working out a little bit better
for us but there's still something
unexplained traditional solutions to
this involve renaming them so that
they're not called X but you have to
rename it just at the right time and it
gets complicated so we're gonna sort of
step back and think about why we have to
do that renaming what went wrong with
generalizing lexical scope here and
what's going wrong in a way is that
we're trying to take this
two-dimensional view just a text in a
box there and figure out remember and
figure out where the X is came from
right but it would help if we had more
dimensions because it's really that left
codes the green part came you know it
wasn't there originally it came in from
the side through some other dimension
and if we can think of it more like that
then we'll have better tracking
something closer to our geometric
intuition that makes simple lexical
scope work well and we'll be able to do
that with colors just not by using
individual colors on names as we'll see
so to get to that we're trying to
generalize lexical scope let's start
again with lexical scope but look at it
in a way that'll let us generalize to
these different different dimensions so
II if you're used to reading scheme or
list code or even if you just ignore the
parentheses and and look at the
indentation you'll pretty quickly figure
out the binding structure here right
this X is meant to be bound by the the
top-level X this X in contrast is going
to the shadowing binding there whereas Y
goes to the argument to the function
right lambdas a fancy way of spelling
function and this should be completely
obvious to you because in what you're
doing is in two dimensions just finding
the nearest and closing binding another
way this picture sometimes drawn is with
drawing regions so this X is bound in
its scope like everywhere that's in the
pink area here can see that particular X
right and this orange X is bound in it
scoped everywhere and the orange can
seen the X
the same for y in the blue the blue
region is the scope of wise binding now
because your brain is used to dealing in
the real three-dimensional world you
just automatically assumed that those
pains stacked right that orange was not
covered up by blue that in fact the
orange is still behind this X and that's
why it's in the scope of that X but to
make that fit in two dimensions clearly
then I'll just stack the colors all
together on top of each and identify and
let the binding contours here for a
moment but we'll just erase them because
we have all the information we need here
this X is in the pink in the orange
region and it particularly oranges it's
binding so this X is in the orange
region it's in the scope of that binding
so we'll throw away those lines and we
just have these identifiers with colors
on them that's going to be a syntax
object that's the punchline okay and how
does that help us with binding well this
X is supposed to be bound by that that
binding instance right there and we can
see that we're recasting it from a two
dimensional look at nearest nearest kind
of binding thing to a problem about
comparing these colors and it's just a
subset comparison this X is in pink
orange and blue that binding X right
there has pink and orange and pink and
orange is a subset of pink orange and
blue so binding is determined by subsets
now you may say well okay but there's
this other X up here it's in pink pink
is also a subset of pink orange and blue
and that's true it's a candidate binder
for that use X but the other one is more
specific it's a bigger subset than that
one okay so so you know just like it's
the nearest enclosing binding in 2d when
we look at it in the scope way we're
talking about finding a binding whose
colors are a subset of the use and it's
the biggest such subset the reason this
is a good way to look at binding
compared to the other way of
characterizing it is it generally
generalizes nicely to macros so now we
draw in the expansion of or we have let
X if all of those are in green reminding
us that they came from the macro if I
try to draw what the contour is the old
picture that wouldn't be quite right
because it
suggests that this screen is inside the
blue and it's not it's like on a
completely different orthogonal plane
that's very hard for us to visualize so
that's why we collapse it down into two
dimensions and just you know paint the
identifiers with all the relevant colors
right that's how we get the extra
dimensions that we need to deal with
macro scope and then let's double check
the subset rules this right here is in
pink orangey blue which clearly is not a
subset of green therefore this X will
not buy into that one it'll continue to
be bound by this other one as the macro
expander continues here you know the
reason it painted things green is
because it expanded a macro and the rule
is going to be when you expand the macro
the new things that come from the macro
get a fresh scope or a fresh color and
then it will continue in and to say oh
this is a binding lip so I need a new
scope for this XS binding and that's
where the yellow will come from as the
expander proceeds so what we're getting
to today is writing the expander writing
the the implementation of these rules at
the bottom generate a new scope on macro
expansion and when you find a binding
form you know you could run this through
our original example when it works out
you know the the premade or gets in pink
and blue and we end up with this orange
and blue X which is not bound by this X
but is bound by this X that's just blue
so that example works out and maybe
you'll take my word for it that we've
tried a whole bunch of code in it and it
does work out and does the kind of
things that you want the intuition
matches up in practice so these regions
or colors that's what I'm drawing as a
scope and when I have the stacks of
colors that I put behind identifiers
that's a scope set so this is exactly
the the things that we need to implement
in our implementation and then a syntax
object as I said it's just going to be a
symbol paired with a set of scopes and
with that we'll be able to build a
racket like macro system we're not going
to build the whole racket language so
we'll do the usual thing where you want
to understand the concept well boil it
down to the smallest language I know how
to implement with this kind of macro
system so it'll be the lambda calculus
will have functions of one argument will
have identifier x' and will that
identifier is also reader refer to
primitives like cons and list will have
function calls
okay so that three it those three parts
are just the lambda calculus will have
quote and this should not be surprising
right we were we're building up on the
list style of just quoting parenthesized
things to represent expressions so it's
gonna be handy to have quote in there
and then we have the two macro parts
proper so let syntax is going to bind
this identifier locally as a macro
implemented by this expression and quote
syntax will be a literal pieces piece of
code that we want to push around
somewhere right a generalization of
quote as we'll see so for example here's
the simplest macro and so it's going to
be a dumb macro but a simple one that we
can work with right so this lets the
macro one be a function that takes a
representation of one so here's a use
this is the binding this is a use we're
calling the macro with zero parts so
that means this use 1 is going to go in
as the argument to this function when
it's going to return is quotes index of
quote 1 so quote one will be the
expansion of this so the whole gray
cloud expands to the bottom it called
the whole thing just expands to quote 1
because we use two macro and then after
you've expanded macros the definitions
of the macros can go away so this is
what we're implementing the process that
takes this bit in the grey cloud to this
bit in the gray cloud a macro definition
in use to its expansion just as another
example to show you more why the syntax
object goes in this is going to be a
func macro that has an expression but
doesn't evaluate it it just wraps it in
an extra lambda wrapper right so this
thunk one goes in as the argument st x
and the code here it uses ii of s DX to
pull out the quote one and it puts
together puts it together with a lam
gonna quote syntax and we end up with
this expansion so that gives you a
simple there's no pattern matching here
we're getting rid of all of that
potential complexity matching patterns
and substituting in the templates and
just boiling it down to functions that
are able to manipulate syntax objects to
implement macros and you can build the
rest up in terms of macros that file
icon on the top left that's going to
fill in as we generate all the code so
that'll give you a sense of progress and
scale as we go and we start out with
just one line so it's
gonna grow very fast at first but rest
assured it will accelerate and still be
understandable as we go we're starting
off with the representation of syntax
objects and that means we need to pair a
symbol with a set of scopes we do that
in racket notation using the struct
declaration so this introduces a new
record type syntax I've made it
transparent just so that it
automatically works with equality so if
we want to represent the syntax object X
with no scope right with an empty set of
scopes we write that in code like this
right this is a syntax record that has
the symbol X in it and an empty set of
scopes if we want X with a single scope
on it
and I'm going to let sc1 be the pink
scope and all my examples this is how
we'd write that in code somewhere I have
to define sc1 and we'll do that in a few
slides right but I put sc1 in a set
combine it with a simple X and that
gives me a representation of this bit of
code right so this is a syntax object a
value that represents this piece of code
that might be in a program somewhere
some text object with two scopes just as
you might expect this struct declaration
also defines a few other things that
will be handy for us besides the syntax
constructor it makes a syntax question
mark predicate so syntax question mark
of a syntax object is true syntax
question mark on anything else like a
symbol or a number or a list is going to
be false and that that syntax question
mark name is bound by the structure
syntax declaration another thing bounds
there is syntax - e just takes these
names and stick something another with a
- that's an accessor function so it
takes a syntax object and extracts the
symbol if I use syntax e syntax scopes
is going to extract up the scope set
yeah that's almost all the racket
special stuff you need to know for for
as we keep going in this simplified
macro expansion we are just putting
scopes on identifiers on syntax objects
but I'm still going to use identifiers
as a word sometimes so that it scales up
but also intact objects here are
identifiers datum - syntax it's going to
be handy for writing tests or writing
certain kind of macros to take a
plainness
expression something in quotes and
coerce it into the syntax object world
and the coercion is straightforward you
just add the empty set of scopes to it
so datum to syntax on the symbol a gives
me a syntax object which has the symbol
a and no scopes on it if we give it a
one or some other kind of thing where we
don't keep scopes it just leaves it
alone so datum the syntax of one is
still just one if we have a list and
here I've got a list of symbols ABC data
m2 syntax is going to apply the empty
scope recursively it's going to recur
down to the list a nested lists and so
on so ABC goes to a list of syntax
objects easier than the empty set and
finally if the input already has syntax
objects so this happens when you have a
macro that's manipulating pieces and
putting them back together then it's
just gonna leave that one alone so here
I've got symbols a and C they get empty
sets but B gets left alone and preserves
its a set of scopes just the pink scope
okay and we have the opposite operation
so it'll be handy under various
circumstances including writing tests to
be able to take a syntax object and
throw away all the scopes that's the job
of syntax a road item and so if you have
ABC converted to a some text object can
read it back you just get the same thing
finally we're gonna represent scopes as
a record and this time I'm just making
them opaque in principle we need to make
up a new color every time we make a
scope but I'm just gonna let the memory
manager do that for me it'll pick a
address and memory to be the color and
so I'll use eke to distinguish those
those different colors so sc1 and sc2 by
creating separate scope records they're
separate scopes they're not equal to
each other but I see one is of course
equal to SC one and then when I write
the scope set so I'll just put these
things into a regular set set is like
lists it just makes us add instead of a
list okay so now we can take plain
syntax objects get them into sorry
take plane s expressions make them
syntax objects we can make scopes we
need to be able to add the scopes to the
syntax objects that's what this function
does
and it's you know the details if you
read it read the code it'll just say
what you expect which is if you take a
plain syntax object X add a scope like
the pink scope then you get X in a pink
scope written this way since X object X
with an empty set gets a set with the
pink scope and scope is also going to
recur for us so we can take a big
expression and add add the scope
everywhere in it right so if we have x
and y and we turn it into a syntax
object and add the scope it'll go
everywhere actually we're not going to
keep add scope because we're gonna need
a flipping operation also so what we'll
keep is a just scope which is the
generalization of this so abstracts over
the operation we do and then we'll
define add scope and flip scope in terms
of a Jessica because they're pretty much
the same thing
so add scope as just one more example if
we have X with a pink scope and we add
an orange scope it's going to have pink
and orange if we if we have a pink scope
and we add pink scope it's a set of
scopes so that doesn't change anything
we still have just the pink scope flip
scope is an XOR operation why do we need
this you'll see it's it's handy for
writing the the macro expansion expand
your part later but it's just XOR so if
we have pink and we flip orange then we
get pink and orange if we have pink and
orange and we flip orange then that just
leaves us with pink okay so I hope all
the pieces so far are pretty
straightforward if you had five extra
seconds you would actually read all the
code the next thing we need to do now we
can represent all the syntax objects and
manipulate them in all the useful ways
we need to next is to keep our table of
bindings so as the macro expander goes
through and it discovers a let form like
this it needs to record that there is
such a thing as a a with pink binding
and we're gonna represent bindings just
by we'll just use Jensen we just need to
make up some token to represent that
particular binding the other possibility
besides a gen sim is an intern symbol
like lambda icons to represent a
primitive so if I had this this example
let with the pink a the macro expander
is going to call ad binding
with a pink a and whatever token it's
made to whatever's convenient for it and
in our case a Jen's M is enough
represent that binding in this case I've
got B and a shadowing B so that's a pink
B and a pink and orange B so I'll Co
those the the alder binding and the
inter binding and I'm going to use these
examples a little bit more as we go
through so be great if I had better
names but remember a is the one by
itself B is the one with shadowing and I
would register those different bindings
in the obvious way right pink and orange
B gets the inner binding last the last
configuration here is C where I have two
non-overlapping bindings so I've got a
pink C in an orange C and so those are
two different bindings and they'll end
up with two different registrations
through ad binding so that was a lot of
examples for three lines of code but
that just sets up the kind of binding
examples that we'll need as we go
through the opposite of ad binding and
result is resolved and resolves job is
to take an identifier we won't look at
the details of the code necessarily then
we'll talk about the helper functions
but its job is to take one identifier
and find a binding that was previously
registered so in the process of
expanding this code we would have
registered a pink binding for a so if we
use resolve with a and a pink binding we
should get that representation of the
binding back the low K that I made
before if we ask about a with pink and
orange if an A actually appears here it
probably has orange as well it's
resolved job to find the a pink and give
us that original location in the case of
a with just orange resolved we'll say
there is no such binding there is no
binding that has a subset of just the
colors orange in the B case when we
registered those bindings the pink B in
the pink and orange B and then the pink
she should find the Eldar binding the
pink and orange B should be mapped to
the inter binding and just an orange B
will again not have a binding finally
there's the C case pink C should find
the first one an orange C should find
the second one a pink and RNC
something is gone strange right because
in this case see pink and orange are not
overlapping in this case there you you
get an error from the expander right
this could only happen if a macro has
done something weird and a macro could
cause this to happen and you want a good
error message in that case okay so the
way resolve actually works is kind of in
three steps
find all the good candidates find the
best of those candidates make sure
there's no ambiguities and then look up
the binding for the best candidate you
found and you know we could look at some
of these examples like when you have a
pink a there's only one possible
matching binding let's look at the B
case when you have B with pink and
orange then it's the job of find all
matching bindings to find both the pink
one and the pink and orange one okay
right if you have a pink and orange C
it's the job of finding find all
matching bindings to find both of the
the possible C bindings and it's the job
of checking in an ambiguous right that's
just finding the best binding you found
the one with the biggest set and make
sure it's consistent with all the
candidates and if not like in the C case
it just raises an error in the last
little bit on our binding representation
is that we need to put all the
primitives somewhere there are no
reserved words right you can use lambda
as a local variable name if you want
and our expander accounts for that and
the way it does that is all of the core
forms are bound in a particular scope
the chorus cope so when you start off
your program you import the core scope
and that's how you get to lambda and all
the other things so if we took lambda
and coerced it to a syntax object
without any scopes then resolve would
say false but if we put it in the score
scope by adding that scope then resolve
will give us tell us yes that's the
primitive lambda for same for cons or
list or other primitives this is a this
is an operation that we need to export
to the world so when someone's using the
macro expander they need to initially
import the core bindings so we'll just
wrap this up as an introduce function I
don't make some of our examples a little
shorter right all it does is add the
core scope okay so congratulations or a
third of the way there
right that was all the hard parts the
representation of syntax objects and
binding and doing the resolution and the
rest is just traversing through red
structure traversing through an
expression to expand it right so the
part we have left is to write expand
which actually does this expansion we
know now how the bindings are going to
match up how this one is going to be
resolved to that one
we know how syntax objects can be
manipulated to get the quote one else if
we write this example as a test case now
we can write it like this
take that expression converted to a
syntax object introduce all the
primitives and then expand we haven't
written that part yet but whatever you
get back it's gonna be a syntax object
so that's the expanded form if you throw
away the Scopes it'll be just quote one
if you don't throw away the Scopes it'll
be a syntax object which will have the
word quote in it with the course code to
confirm that it really is the primitive
core form a primitive quote form and the
one will be by itself and because expand
produces a syntax object that means you
can expand and re expand and rearrange
the code and re expand it again and so
on the job of expand for lambda then is
for macro uses is as before expand on an
application so this is a function call
to list with two arguments
it just recurs through and expands
recursively which means the the one call
turns into quit one right if we're in a
suitable context expands job on lambda
is a little bit more than that lambda X
you know the identity function expands
to itself but in the process we
recognize that this is a binding and
that that X refers to the argument there
so expand is going to take syntax
objects and give us backs in typed
object with more scope on it and with
binding registrations so that we can
match things up so that example right
there looks like this if we introduce
the primitives to lambda X X we're going
to get out a lambda X X where they'll
have a scope on it so that's how the
binding table that we just did how
that's going to help the macro expander
it's not quite enough information for
the macro expander the macro expander
will use when it encounters an
identifier
it'll use resolve to find out it was a
particular argument and it'll know just
to leave it alone but this kind of
situation could happen again we could
encounter an ex with a pink scope on it
outside the binding region of lambda
again this is something that a broken
macro might do and that the expander
will have to deal with that case and so
it'll have to know which of the bindings
are actually available when this kind of
reference happens so a similar thing can
happen with macros or we need to find
the macro so that's why there's one more
piece for expand it needs that global
binding table but it also needs an
expansion time environment or a compile
time environment to map each binding to
its meaning it's a variable it's a macro
that's implemented by this function or
it's not available and you have a
variable out of context so that means
the divine environment maps of binding
to one of those things binding table
takes an identifier maps it to a binding
environment takes a binding Maps it to
its meaning in context of expansion will
represent a compile-time environment
just with the persistent persistent map
so nothing special here if you try to
look up something that's not available
you'll get a false if you try to look up
something that is available and it
refers to a variable then we'll have
this constant variable that it returns
if you look up something that is bound
currently as a local macro and that you
can use as a macro then environment
lookup will return a function or in an
actual function that we can apply to
implement the macro which brings us to
expand finally so expand has an argument
s and an optional argument for the
environment it's optional just so we can
start it out as empty the cases that
expand has to deal with in we just look
at all possible cases in our grammar it
can deal with an identifier by itself
which is probably just a variable with
some scopes expand has to deal with all
right
the possibilities are variable we're now
a variable in parentheses that can be a
function call that can be a use of a
macro that can also be a primitive form
like a lambda form so it'll be the job
of expand ID application for him to deal
with those it can be a list that doesn't
start with an identifier and in that
case it must be some sort of curried
function or a macro that expands to a
function or something like that
so it's always an expansion always a
function call form and anything else in
this language there's no self quoting
because it's as simple as possible so
one by itself would just be a syntax
error
okay so we've reduced the problem to
expand identifiers expand ID application
anding an expand general application an
identifier by itself just walk through
the cases again so expand identifier is
going to be used on something like X if
instead of X it's like cons which is
probably a typo right it might be some
variable that doesn't even have a
binding that's going to be a free
variable so we'll raise an error if it's
cons spelled correctly right then it's
binding will be the symbol quote cons
and in that case we want to leave it
alone right Collins expands to itself if
it is bound to quote lambda that means
it's a primitive syntactic form and we
used lambda without an open print
otherwise we'd go to the other case so
that's also a syntax error so it's if
it's not false or a symbol it must be
one of these Jensen's so then we need to
look in the environment to see if it's
actually available if it is available
and it's a variable like we get to this
X under that lambda we leave it alone if
it's not available that means something
has gone wrong and we give an
out-of-context error and the only
remaining possibility is that it's a
function and that means it's a macro
implementation and we called the macro
without an open paren so in this
expander we'll just raise an error in
that case okay so expand identify we've
only got a couple of functions left and
half the file to go so they must be
interesting functions expand ID
application this is the one remember
that could be a function call could be a
macro call could be a primitive
syntactic form if it's a primitive
syntactic form those
the only four cases so we'll just cover
them directly well we'll defer to expand
lambda expand that syntax that's more
than fun but we can take care of the
other two quote unquote syntax because
nothing happens when you expand a quote
form it's left alone there's no sub
expressions when you expand a quote
syntax form it's also left alone it's
meant to be a literal piece of code you
don't use it now it may be the result of
a macro expansion later this begs the
question of what's the difference
between quote and quote syntax and from
the macro expanders perspective they're
actually not different it's when you
evaluate them that the difference will
show up so we'll see that later right so
that's a key thing to understand quotes
in text and quote the difference is
evaluation not expansion so if it's not
one of those primitive bindings again it
must be a local binding if it's a
procedure that means it's a macro
invocation like one so we will well I'm
gonna defer that to apply transformer so
that's another bit of code we still have
to work out anything else must be a
function call so actually it could have
been a primitive use in which case it's
not in the environment in any case it's
not a macro use it's not a primitive
syntactic form so we'll defer to the
application form so I don't know if
you're keeping track but it's about four
functions that we still need to fill out
that we've assumed exist that takes care
of expand ID application and the most
recent of those was applying the macro
apply transformer so apply transformer
in our one example that means we've
gotten down to the one in open print in
parentheses so that's what's coming in
as the macro application we want to
expand T we looked up in the environment
and that was a function that returns one
quote one so you know I'll just rewrite
quote one the long way open paren quote
one the the key step inside the
transformer apply transformers two just
to call that function on one and get the
quote one out but we don't actually
return quote one remember that when we
apply a macro we need to paint and a
fresh scope everything that was
introduced by the macro so what's going
to get it but has
to come out of here is a quote one where
the quote is in blue and that's because
we made up a new scope right there and
and that's where the blue comes from
except you see I don't use add scope I
use flip scope and that brings us to our
traditional macro trick how do we know
what this function introduced we know
because actually we paint the original
form this thunk X we paint it with the
new scope we made up so we do it
backwards we paint in blue everything
that's not introduced by the macro
because we know what all those things
are we call the macro it rearranges
things and gives us a result back and we
can see the blue which is the part that
was originally there everything else
wasn't originally there then we just
flip it all around well we flip it all
around and the things that we're blue
were not blue and the things that were
not blue or light blue so that's how we
just detect what a macro introduces and
that's applying a transformer which
brings us you know if you've able to
keep a track all we have left is
function calls functions and local
bindings local macro bindings function
calls are easy you've got a sequence of
expressions you just map expansion over
them function calls are a little more
interesting so this is where we have
something like lambda X F applied to X
we do some pattern matching to pull out
the X and the f of X we make up a new
scope for the binding X we add it to
that X so that we got a pink X now we
register a new binding a new
representation of that particular X
that's bound by lambda and then we say
in our environment as we expand the body
yes the binding for pink X is available
and in particular it's a variable we've
got the body which originally as f of X
but we need to add the pinkness to it so
that X the pink X is visible we take
that pink f of X expand it nothing
happens it's still because f expands to
itself an X expands to itself it's still
pink X and then we put it all together
again so that's la lambda Jo's that's
how lambda does its job of introducing
the binding registrations and
matching up the body with those with
those arguments and then let syntax this
is where we're finally actually
evaluating macros so we have a let's
index form like this one we do some
pattern matching to pull out the warrant
as the binding but also the right-hand
side here is a quote syntax as a lambda
of quote syntax so at this point we need
to somehow turn that into a function
that implements the macro and we'll come
back to that so now we've made our stack
a little deeper we have to implement a
valve for syntax binding it's going to
be easy it turns out so somehow we take
this bit of syntax and we get an actual
procedure that takes an argument and
returns quotes index 1 so we make up a
new orange scope for the one itself and
this is very much like the lambda part
you know we bind one with orange and
then we map it in the environment and
then we expand the body expression the
body expression is starts out as just
open paren 1 close paren we paint it
Orange that way this orange one is going
to be the one that we mapped in the
environment so it expands it eventually
calls apply transformer that we already
introduced apply transformer make sure
it's a light blue quote and that's
exactly the answer we wanted right this
form expands to quote 1 evaluating the
syntax binding so we have this
expression on the right hand side of a
macro we can expand it that's easy we
expand the right hand side now we need
to evaluate that one option is to create
an evaluator just a little bit make a
little interpreter right the other
option is while we're in racket so we've
already got an interpreter right so we
compile our s expression our syntax
objects into plain s expressions use the
racket evaluator right you could use
JavaScript or so on the key thing is it
doesn't matter that this evaluator knows
anything about macros because we've done
all of that work we've we've expanded
away all the macros right a particular
our compiler just takes the core forms
and translates them to core forms as
plainness expressions as it does so
anything that used to be an argument
variable it gets it uses this Jensen
that we made up so there's no shadowing
either right when we hand something off
to the court evaluator there's no macros
there's no shadowing we've taken care of
all the binding issues and the expansion
issues the other thing you see here is
that for quote we just throw away all
the scopes but for quote syntax we
compile it down to a primitive quote
form where all of our scopes are still
attached to it right so we have this
live object that we're embedding in the
middle of an S expression which is just
fine for most list of interpreters and
that's that's the difference between
quoting quotes index just keep all those
scopes around so that they're late
evaluate they're alive and still
available for later well we're almost
done so this is in fact just boring it's
just the boilerplate to use the record
evaluator the key thing is it gets a
plainness expression where lambda X X
has turned into lambda with some gen
Simms and it evaluates it and no we're
all done so if you take the code we've
built it's something on this scale if I
can write it's about 250 lines of code I
know it felt a lot longer than that if
you're really into this you might need a
few more minutes to look at the code so
there's the URL right and that URL the
repo has multiple branches so the Pico
one is the one we just built if you had
implicit quoting that's only a little
bit more if you organized the code so
it's not just one big to 300 line file
then it you know we can start using
better abstractions then it grows to
that if you start adding module systems
it grows to that if you do the full
record expander with all the bells and
whistles then it's a lot more okay but
that's because we build our whole life
that's on this right typed racket and
and slide presentation systems and so on
but it's all there and you can sort of
use these as a guide to grow up to the
massive implementation there at the end
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>