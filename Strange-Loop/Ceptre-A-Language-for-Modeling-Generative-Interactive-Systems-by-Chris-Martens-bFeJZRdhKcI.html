<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Ceptre: A Language for Modeling Generative Interactive Systems&quot; by Chris Martens | Coder Coacher - Coaching Coders</title><meta content="&quot;Ceptre: A Language for Modeling Generative Interactive Systems&quot; by Chris Martens - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Strange-Loop/">Strange Loop</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Ceptre: A Language for Modeling Generative Interactive Systems&quot; by Chris Martens</b></h2><h5 class="post__date">2015-09-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bFeJZRdhKcI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm Chris and I do research on
programming languages and also game
design I recently finished up my PhD at
Carnegie Mellon and I'm really excited
to tell you a little bit about this
language that I worked on from my thesis
it seems like some common themes have
been emerging from this workshop I am
NOT going to tell you anything about
tables or spreadsheets but there is
going to be some relational programming
involved here so that's fun and the
first thing that I want to do is have my
volunteers come up and play a game so
can you guys come on stage for just a
minute
and ideally stand somewhere where people
can see you and hold up your cards so my
volunteers all have these cards that are
blue or yellow which indicates what team
they're on and this is gonna be a little
bit of an experiment let the last time I
did this for my defense which is why
it's called defense defense I had
everyone in the audience play and I
thought there might be too many people
to make that work so we'll see if this
can happen so each round of the game is
going to consist of everybody on the
yellow team taking a turn followed by
everybody on the blue team taking a turn
and they have each player has this
attack value indicated by the number of
lightning bolts on their cards on their
card and then a health value indicated
by the number of hearts on their cards
and those values will change in
particular your health can go down and
if you run out of health then you're out
of the game so the idea is you can we
can iterate this for a certain number of
times and then tally up the number of
survivors at the end so the interesting
bits are what can you do on a turn the
first thing that you could do is buff
which means you add once your attack
value which I'm gonna have them do by
drawing lightning bolts on their cards
and attacking is subtracting your attack
value from some enemies health value and
you do that by crossing out the hearts
in in a in corresponding to the attack
you okay so can I have the yellow team
go first and make some decision about
what you're going to do and then do it
yeah try to make sure I try to make
decisions quickly it's it's like I
realize we're a little short on time I'm
sorry yeah okay just a couple more
seconds guys go ahead and decide what
you're going to do and do it yep so X
out the heart I don't know this is gonna
be visible all right yes yes many
scribbles yeah when you when you buff
you have that attack value forever okay
all set great so now the blue team is
gonna go except that you get one more
power your extra power is that you can
buff another team member alternatively
instead of buffing yourself but
otherwise your pot your options are the
same so go ahead and make your decision
yeah okay we're gonna kill bridge Oh
to like all three of us are going to
attack that okay can we ourselves -
no that's an orator yeah you can you can
but only you have to spend your turn on
either buffing yourself or buffing the
other person alright and if you're it if
you die please turn your card around so
everyone can see in your shame
no all right so you can imagine
iterating this process a few times we
won't really have time but I wanted to
show you this process and especially get
a few people thinking about it when
there's some actual pretend stakes
happening so thanks volunteers I
appreciate it
let's give a round of buzz
so humans have been playing games
together mostly since before the dawn of
history and we never needed digital
computers to play them after all nothing
a digital computer can do can't be done
very slowly and tediously by hand but
board games pencil and paper
role-playing games and choose your own
adventure books are all examples of
things that of algorithmic
rule-following that we use to play games
and tell stories today even in the
presence of digital computers however
sometimes the rules get really
complicated and tedious to carry out by
hand so if you're trying if you're
trying to perform if you're trying to to
act out some story with a group of
people when you're like playing D&amp;amp;D and
it's supposed to be a fast-paced action
scene then somehow crunching numbers on
your character stats die rolls and table
values kind of takes away from the
experience so this is kind of what video
games are for right when algorithms
disrupt to the fun due to their come
play due to their complexity then game
authors can provide narrative and
aesthetic voice providing structured
experiences video games are also still
about allowing the player to collaborate
with computational processes in order to
produce stories and imaginary worlds and
there's a lot of complexity involved in
characterizing the sets of stories and
worlds that we can produce when we're
authoring a video game so I I see an
video game as well as many other
computational crafts and design
activities a big discrepancy between
something like the design of the core
roll system and mechanics for a game and
its development communicating it to a
computer we want to build prototypes to
get to get some kind of feel for rules
emergent consequences and the
overarching goal that motivates my
research is basically narrowing this gap
and my start to a solution is a formal
language for game sketching with a few
criteria
first I would like to be executable
because I want play testable prototypes
that we can run on computers I want to
think about rules first rather than
things like rendering an input something
like defense defense could be if we just
stated in terms of its rules could be
manifested as a card game sort of like
what you saw or it could be a network
browser game and I don't really want my
specification to depend on which one
that is
relatedly I don't want to depend on
whatever Hardware currently exists for
input or rendering because those
technologies are changing in new and
interesting ways and we don't want our
game description technologies to fail to
adapt to them and finally I don't want
to depend on ephemeral genre trends for
games in the industry so the art of game
design is growing massively in scope in
really interesting ways and we want to
be open to types of games that haven't
been invented yet there are lots of sort
of games sketching tools out there that
sort of constrain themselves by by genre
like platformer or you know link based
interactive fiction or what have you and
I would rather have something more
general than that but nonetheless we
need to narrow our scope somehow so let
me start by giving a few examples of
what I mean what kinds of games I want
to be able to describe so this is a
couple of the Sims games Dwarf Fortress
and minecraft all of which can be
described as simulators that give rise
to so-called open worlds meaning the
game designer didn't explicitly state
goals or embed stories in these games
but they give the player kind of a
playground in which to build or
superimpose goals and narratives if they
choose to these games are very system
driven which is often placed in
opposition to narrative driven but I'm
also talking about games like
interactive fiction which are largely
driven by story by carefully crafted
narratives and in these games by typing
commands or clicking links you change
some kind of underlying world model
and that's rendered back to as new text
and I actually find that narrative
driven games like this contain some of
the richest systems and world models
precisely because they don't demand a
lot of attention toward rendering and
timing and things like that so I choose
the term interactive world to unify the
concepts in both narrative and system
driven games that I'm interested in
modeling and an interactive world is
just an initial configuration that can
be made up of things of the authors
choosing one example is all of the
defense defense players stats their
hearts and lightning bolts at the
beginning of the game together with
rules for evolving their configurations
for example the rule that says buffing
increases your attack value and some of
those rules can be mediated by human
interaction randomness and other
computational processes so the rest of
my talk is organized into three pieces
most of which will be spent talking
about the language itself scepter and
these are color-coded so they'll be the
background of the slide will be green
orange or purple depending on the
section just to help you keep track of
where we are and then although I'll get
on into the payoff section which is sort
of what this buys you versus other stuff
that exists out there and then discuss
with some some takeaway points at the
end so there are two basic parts to the
language one of which is the technology
that I use on one of which is the
technology that I built
so I'm basing scepter on something
called linear logic programming which I
talked about it's strange loop a couple
of years ago a couple of you may have
seen and then stages and interaction are
the pieces that I built into the
language for my thesis so at the core of
my approach is formal logic and in logic
we represent facts about the world as
propositions propositions or things like
the players in the foyer Juliet loves
Romeo or Roger has two health points and
all of these come from very disparate
domains they're not really related to in
each to each other in any way
they're just from some fictional
universe of of the author's decision and
that's kind of the point of of logical
propositions is that they can be there
are a very general notion and we can
make the syntax a little bit more formal
so typically in logic we would write
these as predicates like in loves and a
health applied to some terms or values
such as the foyer Juliet and Roger and
also program data like the number two so
the fundamental thing that we need to do
is specify how facts about the world can
change over time for instance through
some player action so let's say we want
to write a rule that enables the player
to move from the foyer to the kitchen
and we need some kind of basically a
state transition to say that you know if
the players in the foyer then they can
transition to being in the kitchen this
isn't quite a formal notation yet
because the sort of informal if-then
statement that I that I said aloud
doesn't really make sense in terms of
its logical content which is where we
reach for linear logic which is a type
of logic originally due to Gerard and it
gives us a form of logical implication
whose meaning just does exactly what we
want it to in this scenario it allows us
to replace the fact on top which is the
premise with the fact on the bottom
which is the conclusion and this rule
doesn't assume that the player location
is the only part of the state so we
might have some big pile of facts like
the cat's in the kitchen the players and
the foyer the player is also wearing a
coat and there are jewels and a cavern
somewhere and none of that is relevant
to the rule except for the player being
in the foyer so we can swap that out
with the player being in the kitchen and
the rest of the world stays this stays
the same so I'm going to introduce
another connective in the logic this
blue circle with a cross in it
pronounced tensor and this just allows
us to conjoin two propositions in either
a premise or conclusion
and there's another construct that I'm
introducing in this role which is
quantification of logic variables which
I'm by convention for this talk writing
in purple and by convention from logic
programming languages like Prolog
writing with capital letters so this is
a rule that says that's a little bit
more general for player movement which
says for all rooms named room and room
Prime if the player is in room and room
is adjacent to room Prime then the
player can move into room Prime okay but
there is a small issue with this rule
remember what I said the semantics of
this this lolly symbol this linear
implication was I said that we take
whatever the premises are that that
exists in our state and replace them
with the conclusion so this means if
we've got the players in the foyer and
the foyer is adjacent to the kitchen we
would replace both of them with the
player being in the kitchen so we need
one more linear logic connective of the
exclamation point or bang connective
which allows us to access a proposition
arbitrarily many times this is
effectively a way of accessing the
standard notion of logical truth of
something that that's always true once
we learn it back into this kind of
stateful linear logic and now that we've
written a rule where we we have some
kind of general way of moving from one
room to another well we might think
we'll we'd like to use that rule more
than once so we can use the bang
connective in another place in our
specification okay so now we've got this
big kind of compound proposition that's
a maybe a partial specification of some
kind of game and it's getting a little
unwieldy so let's use a more programming
programmer like syntax for writing it
down
so Alenia logic program at its core is a
list of declarations like this which are
logic program rules and a rule by
default is assumed to be persistent so
now we give rule we can optionally give
rules names like move and adjacent for
your kitchen and then you put a colon
and then what's after the colon is the
proposition itself
that is that is the rule that that's the
name of and yeah so these purple
variables are implicitly quantified at
the beginning of the rule and each rule
is assumed persistent so what I've shown
you so far is basically author defined
terms and predicates quantified logic
variables and three linear logic
connectives tensor bang and moly and
these are basically all that we need to
specify action and change on a logical
logical level I will use one more piece
of syntax here the color is a little bit
washed out I'm realizing but I will use
one more piece of syntax in my examples
which is dollar sign basically to to do
this idiom this common idiom of
repeating something as a premise and a
conclusion in effect just accessing it
without removing it from the state so a
tensor dollar sign BOAC
would just expand to a tensor be LEC
tensor be alright and I claimed that
this is a programming language but so
far I've basically just shown you some
kind of logic notation so how do we take
these abstract specifications and
actually run them as programs and this
is where the idea of linear logic
programming comes in which is the
observation that we can effectively take
a manner of proof construction feeding
these things in as logical formulas to
approve construction engine and view it
as something called multi set rewriting
where we take our initial configuration
and our jumble of facts about the world
and we treat it as as a multi set so we
say the order that things are listed in
it doesn't matter I can reach anywhere
inside the state to pull something out
but more than one copy of something is
different from just one of it and so
using this multi set together with all
of the rules as well as your term and
predicate declarations in some signature
Sigma you can give stepping semantics
for the program where anytime there is
some rule alali be in Sigma you can take
a step from any context Delta that has a
in it to the same context with being it
instead
okay so now we're finally ready to look
at our defense defense example in this
linear logic programming notation so the
buffer rule is pretty simple
it says if we've got some player capital
P player so any player that player has a
turn and their attack value is ATT then
we can replace that attack value with
ATT plus 1 and that consumes a turn we
can modify this to the expanded buffing
rule where you can you can buff any
player including yourself but I simply
changing the logic variable to player
Prime the attack rule is a little bit
more complex it involves this dollar
sign notation where we refer to player's
attack a so we say if players attack is
a and then the health of some enemy is H
and we can replace the health of the
enemy with H minus a although the attack
stays there so and then finally there's
a rule that says if your health over
reaches zero then you're out of the game
and what a configuration looks like is
just to basically write out you can
write out multi sets using this notation
for declaring contexts on a separated
list of things that have information
like the team that the players are on
their health values and their attack
values notably these are multi sets of
ground propositions meaning that they
don't have any logic variables in them
they have to refer to specific concrete
terms and with all of our all the rules
in our program as Sigma and all of our
in our context as Delta naught then we
can invoke you know running this program
as I described with this hash trace
directive and when we do that we hate we
can expand kind of this single step
notation into a full evaluation
semantics for the for the program where
we say our initial contact steps along
any rule that can apply in Sigma until
no more rules
in fact do apply at which point we say
we've reached quiescence and note that
because we could transition on any rule
that applies we have some fundamental
non determinism in our program semantics
so suppose we want to make this program
interactive so we can actually play test
it one idea is just to take that non
determinism and pass it off to the
player and say okay anytime there's more
than one transition that can apply you
decide what to do if we did that for
this program we would get a whole bunch
of you know just as a as a sort of the
simplest possible inter interface that
you can imagine some of this notation is
not necessary but if so you can get a
printout of all of the transitions that
apply to the initial context and then
you know enter a number to pick one or
something like that and this isn't quite
what we want however because remember
the way I explained the game I said all
the people in the yellow team go and
then all of the people on the blue team
go and we've currently got the ability
to take a turn for Gwen or take a turn
for Chris and one of those people is on
the yellow team or others on the blue
team so all of these are mixed together
right now so in order to express that
kind of idea of everything happening
until there's nothing else that can't
happen and then moving to some other
collection of rules in the program we
need to introduce the idea of stages and
I'm gonna move to a simpler example for
this because well just - it's a to avoid
crowding the slides too much so this is
another little example where you can
imagine your context is a bunch of
instances of heads and tails and you
have two rules you can either pit heads
and tails against each other and decide
heads wins or you can put them against
each other and decide tails wins and
then after that happens you want to deem
an overall winner so eventually you'll
reduce it down to either one heads or
one tails and
depending on which ones that is you'll
declare heads overall or tails overall
but of course this doesn't have this
program doesn't have that those
semantics because you can apply the
overall heads and overall tails rule at
any point in the program so as a first
pass we can imagine adding an additional
premise to each of these rules which is
a predicate that we decide to call stage
indexed by some other term indicating
where we are in the program so if we put
the first two rules if we give the first
two rules an extra premise so that's a
stage tournament and the second two
rules premise that's a stage tally then
they can only fire when you know when
each of those stage facts is actually
true now the question is how do we
transition from one stage to another
well we could imagine putting in another
rule that just allows us to pass from
stage tournament to stage tally however
now we can a fire that rule at any point
when we're in the tournament stage
including when we're not done yet
so there's one tiny thing that we need
to add to the language in order to get
this to work
which is a special predicate Q UI that
indicates quiescence and you can think
of this as kind of something that comes
from the outside of the program and is
introduced at runtime that when
quiescence is detected so now given this
the program has the sense that we want
so in addition to that in scepter i also
introduced a just syntactic sugar
basically for stages so that you don't
have to write that premise next to every
rule you can write them as blocks and
finally now that we have these this
program separated out into stages when
we want to introduce interactivity we
can do so on a by stage basis we can say
the bit that I want interactive is the
tournament stage and then afterwards the
automatic process for tallying will
occur okay so returning to defense
defense I'm not going to show you the
code for this but you can imagine
I just wanted to gesture at the idea of
you know my volunteer standing on stage
you know I say take a turn okay then
everybody kind of shuffles around for a
while and I
continue asking them are you done yet
and then once they're done yet that's
quite essence and then I can pass over
to the next team and effectively you
know a lot them invisible turn tokens
that they have to take okay so in
summary scepter is a bunch of is you
know a few features user-defined terms
and predicates these multi set rewriting
rules that are really the core of the
language there are also prologue style
rules if you're used to that kind of
logic programming that can be used to
define arbitrary computations such as
addition and subtraction which work a
little bit differently from how I
presented them on the slide and and then
there's this idea of stages and
quiescence that you can use for
interactivity and I'll put this github
link up again at the end but it is
available for tinkering with okay so you
might be thinking there is not an awful
lot in this language surely I need the
ability to do like negation I want to be
able to test whether something's not
there in as a premise to one of my rules
I want to do some kind of comprehension
or aggregation like say you know for
every term that has this predicate true
of it you know generate some other token
and there's no ordering to these rules
and sometimes rule ordering is actually
kind of useful and it turns out that all
of these things can actually be codified
using stages using quiescence which is
described in Chapter four of my thesis
if you want to check that out but but
basically the idea is you can you can
get away with quite a lot with just this
simple idea of quiescence there are
other linear logic programming languages
including I think Ligon was one of the
first ones self is really the direct
predecessor to scepter it's a basically
a linear logic programming language
without stages and then what I added was
the interactivity in stages okay
so know a little bit about the payoff
I'll briefly mention a couple of the
case studies that I did with this for my
thesis and then talk about some kind of
more more more more recent and a little
bit like more speculative experiments
that I've carried out so one of the
things that I've done with this is used
linear logic as a narrative generation
engine where I wrote a bunch of
basically social interaction rules for
characters and you know through a bunch
of characters in a pot and said do a
social interaction that is possible for
you right now until you've produced some
kind of story so that's an example of
something that actually didn't use
interactivity at all was just kind of
making use of these linear logic ideas
and then I modified that to into a multi
agent social simulation game kind of
thing with a sort of dual action and
reaction stage set up I've worked on a
sort of roguelike example where with
some combat mechanics and monster
generation and I've codified a sort of
simplified version of Settlers of Catan
and so I found that this is you know the
the fundamental idea to this kind of
thing to me is having like a little
chemistry lab where I can just tinker
with mechanics and invent things and
play with things and one of the most
fruitful things from that is this idea
of fuzzing player input so if you
imagine taking a program that you intend
to be interactive and then just saying
okay make random decisions for me then
you get a bunch of play traces out of
this that you can analyze and this is
not too useful if you're just doing
strictly random selection of rules but
if you augment just a little bit with
some kind of like lightweight AI
strategies you can make a little bit of
headway so this can like barely be
called AI so much is just like doing not
directly harmful things to your to your
team but one example is we can modify
the buffer rule so that were
only buffing our own team members and
the attack rule so that we're only
attacking opposing team members and then
if you do something like that you can
make some graphs about you know you can
do like 200 random runs of your program
to do something like kind of evaluate
the game for balance and I actually did
that did this with sort of so I did 200
random trials on teams of 25 people
where I started out with a different
number of yellow team members and blue
team members and the the question here
that I was kind of asking was well okay
so if I don't introduce that that but
the ability to buff your teammates only
on the second turn like if I introduce
that at the beginning then it's
massively over balanced toward the the
team who goes first and I wanted to find
out how over balanced it was so one way
of viewing that is you know how many
starting team members do you have to
make B on the blue team before things
work out and it's 11 out of 25 it turns
out so this thing's like this have some
interest for the game synthesis
community which is actually like people
who are writing programs that try to
come up with games
Cameron Browns Ludi system is one more
famous example of this and it actually
uses kind of an iterative process like
evolutionary programming that uses this
idea of balance pretty much as a fitness
function for coming up with good games
okay so finally I want to discuss a
little bit of what I presented starting
with the idea that there are I think
some significant problems with
programming this way in particular for
any given rule you have to kind of look
at it and think about it in the context
of what else you expect to be happening
in the game this is something that Chris
Granger mentioned a little bit you have
to kind of have the rest of the game
rules in your mind and one way of
characterizing that is that you've got
invariance to your game so you have this
idea of
any players should only ever have one
turn active that they can use at a time
a character should not both be dead and
on a team that wouldn't make any sense
the and a character should always have
if the character is alive they should
always have an attack value and a health
value um and then you can look at a role
and kind of reason to yourself well does
this rule preserve those facts and I
would really like to automate that
process in order to give programmers
tools to keep their keep and keep their
program set a kind of sanitary and what
the the formal tool that I've reached
here reached for here is program
invariance which are things that can
basically be checked of the initial
contacts so you establish some property
and the invariant checker would say ok
it holds up your initial context and
each program role in turn it can check
in isolation which is nice whether it
preserves that invariant then your whole
program should obey the invariant it
turns out that there's actually a nice
way of writing program invariance which
just reuses the machinery of linear
logic programming where you give a
signature characterizing the set of
contexts that you want so this is a
signature where that just is the you
know a player has your one turns idea
and so you give a signature and an
initial configuration so Delta not gen
done here which kind of is like a almost
like a grammar describing the set of all
permissible configurations that you want
your program to maintain and there's a
decidability result in my thesis that
you know that we can actually check
these things but it's not tractable at
all it reduces to Pressburger arithmetic
which is doubly exponential and it's sad
so so in future work I really want to
figure out you know automation and ways
that we can practically integrate this
into the programming language the other
big area of future work that I see is
accessible game design frameworks and I
know
you know most of the people in this room
I hadn't really realized before saying
all of your beautiful talks that you
know you're very interested in this
programmer experience and I haven't
really addressed that at all with this
programming language but I have
envisioned it as kind of a kernel where
you can have a sort of extensible system
where you know you have a front-end
that's maybe maybe partially implemented
as part of the compiler and then augment
'add by the game author and then that
can output something related to that
domain so for instance I mentioned there
are these there are these other game
scripting engines out there which are
very dependent on the kind of game
you're making like a text adventure or a
platformer or in puzzle scriptcase
2d puzzle grid games so I can imagine
implementing some front ends for scepter
so that it can actually output to those
formats as well and I think that's going
to be really important for the future ok
so finally I just wanted to conclude
with a few high-level points that are
effectively things that I'm happy with
in this language design and things that
I want to see in the future of
programming so some lessons for
programming language design and I'm kind
of talking about domain-specific
languages here although that term is so
fuzzy and nobody really knows what it
means so and and in particular I don't
really think scepter is a
domain-specific language because it's
intentionally so flexible with respect
to having author defined terms and
predicates and you know and has in fact
been used in many other application
domains so we give the authors the
ability to define that domain so you
know this isn't quite the right term but
I have been focused on game design as as
my target and I've and a lot of the
decisions I've made in the programming
language have been driven by that so
maybe I could call it domain oriented PL
design or something like that
and the first thing that I think I
clearly benefited from was the basis and
logic for the programming language and
you know logic doesn't really directly
map onto the way that humans think and
as I think one of the first speaker is
mentioned it doesn't really messy nosov
the world
but when it happens to map onto the kind
of system we're interested in describing
it's a really nice intermediate language
between human thought and machines and I
also think that it provides a you know
kind of a nice basis for understanding
how our domain connects and compares to
other domains which I think you know
kind of games in particular has this way
of being really myopic and like only
like thinking there this this whole you
know really unique medium that has
nothing to do with any other media and
giving things a logical basis has
leads the way forward to comparison with
other creative media another principle
that I advocate in language design at
least for something you kind of intend
to serve as an internal or intermediate
language is minimalism so not adding a
feature if it can be derived and the
smallness of a language I argue makes it
both easier to learn to implement and to
communicate you can you know provide a
specification and this can you know a
very small language can be communicated
outside of its narrow academic research
context and someone else could go out
and implement an engine for this kind of
language and it also forces us to boil
our domain down to its essentials and
the final recommendation I have is to
think of our modeling tools in kind of a
revisionist way which is to say that we
shouldn't let the historical accidents
of a domain constrain the way we build
tools for expressing it instead we
should embrace the way that languages
and tools force us to reconsider and
reframe our designs and you know we can
free our languages and tools from all of
these contingent constraints then these
languages can drive new understanding
thank you so much you can find more
information at these various links</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>