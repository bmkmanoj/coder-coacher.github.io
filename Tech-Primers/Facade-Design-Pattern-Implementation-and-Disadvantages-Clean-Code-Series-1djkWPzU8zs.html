<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Facade Design Pattern | Implementation and Disadvantages | Clean Code Series | Coder Coacher - Coaching Coders</title><meta content="Facade Design Pattern | Implementation and Disadvantages | Clean Code Series - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Tech-Primers/">Tech Primers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Facade Design Pattern | Implementation and Disadvantages | Clean Code Series</b></h2><h5 class="post__date">2018-02-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1djkWPzU8zs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">press the bell icon on the YouTube app
and never miss any update from tech
primers let's take a look at the facade
design pattern facade design patterns
are useful when we want to make our API
easy to use easy to use in the sense if
there is an existing API we can create a
facade class which will abstract out the
underlying implementation of an existing
class generally facade is used to hide
the implementation and hide some unclear
code or unclean code so that the client
doesn't know what's happening underneath
it reduces the dependencies of the
outside code so the client will not be
able to see any other dependencies of
how to create a composition because
facade internally uses composition
facade doesn't even require any
interface it is usually useful when we
want to refactor any existing class
since we use it as a part of refactoring
it hides the complex or in fact a bad
code which is written let's try Cree
getting a facade design pattern I'll
create a new package called facade
similar to how we use the phone examples
in the previous patterns we will be
following the similar pattern here I'll
create a phone interface and this
interface is going to have a method
called build
let's try returning that and I'll just
create a facade demo which will have a
public static void main for us to run we
need to create interfaces implementation
let's imagine these are the bad codes
I'll create a I phone and the build is
going to return saying built using iOS
let's say 11 I will create a 1 +
built using Android let's say 4.0 we can
even add one more Nokia for even
Microsoft's phone so we have different
implementations here now let's imagine
the client is present here so the fiqar
demo is a client and this particular
clients needs to access a phone we can
create a phone facade we can create one
more class called facade phone and as a
part of the car
struktur we can create the different
classes we can create all the
implementations here iPhone
so now we have created or created a
composition of these objects now we need
to expose these API specific to the
clients implementation we can expose a
facade phone which says build iPhone
which will build an iPhone the return
type won't be string so I'll just call
iPhone dot build so this is just going
to call the iPhone specific method let's
do a return here similar to that we will
be creating build Microsoft phone or we
can name it as build Apple for
internally it's just going to call the
iPhone here we will be calling the Nokia
phone the next turn the final one would
be build Android phone and that is
returning oneplus build imagine that
these implementations or these classes
are not written in the right way in this
particular example I just had an
interface and I have directly
implemented these interfaces so which
looks neater imagine that there are
different interfaces and different
pluggers which have different design
patterns existing already and they look
clumsy however we want to expose these
to a client so that he can directly use
it that is when we can enclose
everything in the facade class imagine
we have a facade class here and we have
abstracted out some complex code or even
the bad code which we have written in
different implementation using the
facade phone we are going to build the
Apple phone Microsoft phone or the
Android phone let's try using it here
let's create a new implementation of the
facade demo or in fact the facade phone
right let's try creating a variable now
using the facade phone since the facade
demo is declined we can directly call
methods like these you can directly say
Android phone
Apple phone and the Microsoft phone as
well so the clients code looks much
neater and simple we have not created
any instance of each of these phones
however facade has created that for us
as a part of the constructor and we are
directly calling these build methods
whenever we require them if I run this
program this will just print the build
of each phone nothing else but imagine a
complex scenario where you have lots of
complex code under different packages
and you want to expose that to a client
and that is when you will be using I
think this has a return type so we need
to use I'll just say notice out so
imagine that in the real-time example
you have a complex use case where there
are different packages and different
implementations which are very complex
and you don't want to touch them however
you want to have a client that client
needs to use these implementation we can
abstract that out from the client by
creating a facade and the facade acts as
a interface for the client that is when
we can go for facade see that the values
are just getting printed so what are the
disadvantages of using facade
since facade is very simple to implement
we don't even need an interface people
tend to overuse it and if there are too
many facades in the project that shows
up the code smells and there are lots of
legacy or complex code which are lying
underneath which is not exposed
generally as I said earlier it is used
as a cleanup or design pattern where you
can use facade when you want to abstract
out and you don't want to change much in
the complex logic you just create a
facade and then you abstract things from
the client generally it is used when you
want to clean up code I hope you guys
understood what is facade design pattern
and way we can use it meet you again in
the next design pattern video thank you
very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>