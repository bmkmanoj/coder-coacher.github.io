<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Build LifeCycles in Maven | Tech Primers | Coder Coacher - Coaching Coders</title><meta content="Build LifeCycles in Maven | Tech Primers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Tech-Primers/">Tech Primers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Build LifeCycles in Maven | Tech Primers</b></h2><h5 class="post__date">2017-10-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Cv52aJ-w7eY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in the previous video we saw what is
maven and how you can use maven to solve
your bill problems in this particular
video we are going to see what are the
different life cycles of the maven
project if you create a maven project
these are the different life cycles
which you will be getting along with the
project let's see what are the different
life cycles and how we can use them in
your project let's get started
so there are more than 20 men lifecycles
provided by Malin out-of-the-box and you
can use these different life cycles for
different types of Processing's
right so what I'm going to do is I'm
going to go through each and every life
cycle and I will just give you example
if suppose it has complex to understand
right so the first turn the foremost
life cycle is the claim so any any
project if you consider you will do a
claim so claim is going to clean up your
target folder so if you had noticed that
maven creates all the class files under
the folder called target and if you are
on the maven clean it is going to remove
the target folder so basically it is
just going to wash out all the class
files resources all the necessary files
which was created in the previous build
in as a part of the clean life cycle the
clean is not a part of the lifecycle as
such but still clean is a process which
should be follow most of the time to
make sure our abilities clean every time
we build our project so that is clean so
apart from the clean what else do we
have right so that is something called
validate so validate what it does it
checks your project it goes through or
your pom dot XML so as you guys saw
maven uses the power of XML it goes
through the palm dot XML it goes through
different XML tags and identifies is if
there are any problems in the current
project okay so it also checks what are
the different profiles it also checks
whether the dependencies are currently
mentioned and it also checks if the
necessary processes or the life cycles
are mentioned to complete the build
process so that is what validate does so
if you want to make sure if you are
formed or XML entries are perfect then
you can use the validate option so you
can do a maven validate so the command
for that is M p.m. space validate if you
give that particular task maven is going
to run with a validate lifecycle okay
the next one is initialized so maven
initializes nothing but it initializes
the states for the particular
project so for example if you want to
load the properties okay so you can put
them in the initialize phase so when you
are writing in the palm taut XML I'll
show you how to create profiles and how
to use these life cycles in the next
video
but just understand that initialize is
where you want to initialize all your
property files for usage in the
different phases of your build lifecycle
so you can use initialize for that so
that is the initialized stage so in
general people use or they plugin
developers use initialize for
initializing some properties for usage
down the length right the next one is
the generate sources generate sources
are nothing but creation of source code
which are included into your compilation
phase itself right so this generates the
package which can be used for seeing the
source code so for example if you are
having a spring right you have spring
documentation or the spring source code
along with the spring project so that
you can use it for referencing right so
when you download your maven
dependencies you can package - sources
for your library and that will be
shipped along with your jar right so
that is where generate sources help it
generates the source files as well along
with the package which you are
generating for example if there is a
Java project you can create a jar and
along with that you create a - sources
jar which will be useful for decoding
your code when you want to debug stuff
so that is generate sources process
sources when is when you want to do
something based on some value inside the
processing right inside the source code
right so then you can use those process
sources so you can use the process
sources lifecycle to do any filtering
based on this particular file names or
something like that so let's say if you
want to filter out some specific files
which you don't want to package along
with the product you can use that in
--see process sources so that is the
process sources you can process the
source files
you can filter out stuff if you don't
want generate resources is where you can
generate the you can push the property
files or SQL files or something which
you require in the run time and you need
it to be packaged so let's say you have
some XML files to be loaded for example
spring xml's or you want to load the
application properties so those needs to
be taken care as a part of generate
resources so you can generate these
resources and then push that to the
package alright so that is when generate
resources help so these can be included
along with the package so our package
here I mean is the final metadata or the
zip or the jar or the war which we
finally created process resources same
way if you want to process some specific
property files you can filter them out
so let's say if you want to copy only
files of a particular pattern you can do
that similar to how we do the process
sources you can do the processes sources
the next major step is the maven compile
so compile is a stage where all our
source codes are compiled right so
basically all your source codes get
converted into the binary code or class
files or whatever format from which we
need to ship it it so all these gets
moved to the target folder as a part of
the compile stage process classes so
process classes is a step where you can
generate the files from the compilation
stage okay for example if you want to
optimize some code as a part of the
company on stage rate you want to
optimize some class files let's say the
class is so huge you want to optimize
that you can do that as a part of the
process classes the next one is generate
test sources as the name suggests you
can generate test source code for the
test classes if you want to have
documentation for the test classes as
well process test resources same way for
filtering of the test sources which we
created s compile is for compiling all
your tests as a part of the test
compositing
right so that is test compiled the next
one is a process test classes so I
similar to how we compile we do the test
compilation using the test lifecycle so
as a part of the test lifecycle all the
tests will be run so after that you can
process those classes using the process
test classes so you can generate files
from those code which we compiled
alright so that is the process test
classes the next one is the repair
package so as a part of the prepare
package let's say you want to copy some
files or you want to generate some files
before the package is ready you can do
those as a part of the prepare package
so let's say you want to create some
JSON files right you want to create JSON
files out of the schema you can do that
as a part of the prepare package or
something with it and these are
absolutely mandatory for the package so
that is why they are there as a
pre-prepared package right the next one
is the package package is where all the
compiled codes are now zipped or
compressed into a format which you'll be
able to distribute to other people right
for example jars or wires or enterprise
years or zips etcetera right so those
are the packages so package step is the
final step which is going to compress
everything which we need pre integration
tests so pre integration test is where
you want to do some initialization or
for example if you are running an
integration test and you need your
Tomcat ok you need to start the Tomcat
you can do that as a part of free
integration step right so that is one
example of usage of pre integration step
or loading the data into your in-memory
database you can do that as a part of
real integration test integration test
as the name suggests you can run all
your integration tests as a part of the
integration test phase it can have all
these environment variables and you can
process and deploy them
part of the integration test so if you
want to reply the application into a
remote machine you can do that as a part
of integration test and run the tests
over them post integration step is the
opposite of pre integration whatever we
started there we can do a cleanup in the
post integration test right so next step
is the verify so verify is to check if
the packages are all perfectly packaged
and if they meet the exact standards in
which station these shipping so if we do
the verify it will automatically check
the jars whether the quality of the jars
are perfect whether people will be able
to unzip the jars in the right format so
that is what verified us install install
is also similar to the package the only
thing is install will move that package
to the local repository so this will
move the package to the local repository
so that other projects can be taking
other projects can be referring to these
local repositories can be accessible so
if there if let's say I have two
different projects I create a all these
are local and if I do a clean install
this is going to ship my package onto
the local repository the other project
is going to take the latest version from
the local repository automatically so
install is going to do that for you the
final thing is the deploy so deploy copy
is the package whatever we build right
so it copies the package from the local
to the remote repository from local to
local repository deploy is going to copy
from local to remote repository so
remote repository is required when you
want to share your code with others so
that is when the remote repository is
liquid so if you are in a firm if you
are an enterprise firm you will be using
your own instance where you will be
deploying all your applications onto
that particular maven repository or
artifactory or something like that you
have a central place where you can push
all your artifacts and from there you
can distribute to different themes or
different consumers right so those are
the different life cycles which may have
an provides so
I hope you guys understood each one of
them in the next video we are going to
see how we can use these and how
profiles tie up with these and how we
can use maven profiles as a part of our
build lifecycle okay hope you all liked
the video if you liked the video go
ahead and like it if you haven't
subscribed to the channel go ahead and
subscribe to it meet you again in the
next video thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>