<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Identifying another exploit mitigation and find bypass. stack0: part 2 - bin 0x22 | Coder Coacher - Coaching Coders</title><meta content="Identifying another exploit mitigation and find bypass. stack0: part 2 - bin 0x22 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Identifying another exploit mitigation and find bypass. stack0: part 2 - bin 0x22</b></h2><h5 class="post__date">2017-07-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MMm0I2Dj51A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">you should now be familiar with stack
level zero from protostar and especially
our quick look at what happens when you
compile this code on a modern system
specifically with the stack cookies in
this video I want to develop a working
exploit for it and believe me there are
a few mountains we have to overcome
let's get everybody quickly on track we
have a simple buffer overflow
vulnerability originally the goal was to
overflow into another variable to change
the outcome of an if case but this is
not possible anymore because the buffer
is now placed after the variable not
before so to execute this case we want
we could maybe overflow the return point
on the stick and simply redirect the
code execution there but an issue that
we face is this deck cookie which
contains three random bytes that are
checked before the function returns so
in order to overflow the return pointer
you would have to get the cookie this
means we have to write an exploit which
executes the target over and over again
millions of times always guessing a
stack cookie and eventually we should
get lucky but before we write that code
let's first develop the exploit as if we
know the cookie value this input really
must be correct in order for it to work
once we get the correct cookie value so
we have to debug this heavily let's
start by opening the binary in gdb with
peda extension which makes it look nicer
and let's just enter a lot of characters
in order to observe what happens
oops stack smashing detected we
obviously want to ignore that for now so
let's set a breakpoint just before it
would continue to stack check fail and
then set EAP to where it would have
jumped to if the cookie was correct with
a simple commands directive we can
automate this every time this breakpoint
is hit and then continue
segmentation fault that's what we would
expect awesome
Oh segmentation fault at the return not
a sect fault because we redirected code
execution to faulty memory look at the
stack register ESP points to invalid
memory so when the return instruction
wants to look up the return point on the
stick it tries to follow where is P
points do and then it's obviously
accessing invalid memory damn how did we
overwrite and modify the stack pointer
let's look again at the disassembly down
here just before the return so value
referenced by the base pointer so value
on the stack is moved into ECX and then
ECX man falls calculated and that
becomes the new stack pointer and when
we look at the beginning of this
function we can see that the stack
pointer minus four is stored in ECX and
pushed onto the stick so the stack
pointer is also saved on a stick I think
that's another mitigation attempt
because before we are able to control
the return pointer we first had to
control the stack pointer at first this
doesn't seem to be an issue because this
just means we have to write a valid
stack pointer and point it into the
buffer we control and then the return
will take the return pointer we control
in the buffer use P points to when we
win but the issue is this modern system
also has no a SLR we can see that if we
re-enable a SLR in the debugger and run
it a few times
observe the ESP value it's always
different
I admit it on fully random but it's more
bytes we would have to guess and to hit
the cookie and the well stack address is
starting to look really bad let's say we
would know the base memory of the stick
would that help us there's even more
here let's rerun the program again and
this time let's see where ESP points to
and compare it to where the stick
actually starts in memory and when you
do this a few times you can quickly see
that ESP varies quite a lot from where
Tech really starts in fact there's a
huge gap with the random size of just
zeros between the start of the stick we
use in the code where it is P points to
and the environment variables that are
actually the beginning of the stick
memory area I think this is another way
to randomize values because a DSLR would
only randomize the upper parts of an
address in this way also the lower bytes
become unpredictable the game of
exploitation has clearly changed there
are more hurdles so that does mean now
it's game over it's not exploitable
anymore we can't do it with a single
input
overflow well there is a way but we have
to get creative it's not as easy anymore
okay so we know there is a cookie on the
stick and we believe it's fruit
forceable so let's assume we found the
correct cookie how do we go from there
we know that a valid stack pointer is
stored after the cookie right the value
of e SP was saved at the beginning and
restored here at the end again which
means we can be used it we don't have to
overwrite the whole pointer what if we
just corrupt the first byte so the
lowest part of the address which means
that the stack pointer stays valid and
suddenly point into slightly different
stack memory and maybe we can make it
slightly point into the buffer we
control which is just a bit lower than
the sword is p-value here so then we
restore this slightly off value return
can now follow the address as it points
into valid stick memory and take the
address there to return into and if it
points into our buffer now we can
control where we wanna return to and we
could return into the if case that
prints our goal we can achieve that by
writing enough data to the buffer so
that we fill up just short of the stored
stack pointer and because strings end
with the zero byte in C and null by it
will be written to the lowest part of
the store this p value does make it a
bit smaller and when we are lucky it
points into our buffer let's check out
the length so when you run it with the
long input we see that ESP got
overwritten with
SSSs one bite is for lower than the
others thus became an O which was caused
by the EC X minus four so this means we
want to stop right before that and then
we run it now we see that espn's now in
FC so it worked because we predicted the
lowest part in a stick is all written
with zero and because of EC X minus 4 so
0 minus 4 we end up with FC but as you
can see we didn't get lucky
ESP points not into our buffer so let's
rerun it a few times and do the same and
at some point we will get lucky and now
ESP points to our buffer and we now
return we actually return into 40 40 40
40 which is mmm mmm it worked
actually the randomization of the zero
padding on the stick makes this work
because at some point the lowest
randomized value of the address will be
just right so that the zero is the right
amount of change so ESP points into our
buffer but you also see it's not 100%
reliable we have to guess the cookie
correct and then hope that the ESP
randomization is also nice to us but
that's fairly common so I hope that it's
common enough to still make it feasible
so now all that we have to do is put it
together let's write a quick Python
script we import struck to convert the
address whoo a 4 byte string will lump
the help our function for that and then
we simply make our exploit string fill
the buffer with mostly the address we
want to return to and we hope we can
make is P point 2 into death area and
then comes the cookie value which we
later have to write some brute-forcing
logic for after that comes the four more
bytes and that's it then we print it
looks good you see the raw bytes are
output with hex dump so we write it to a
file now let's set a breakpoint at the
cookie check to make sure that the
cookie is in the right place and then we
can use the file as input in gdb first
breakpoint wants a cookie check and we
can see we all wrote the cookie with
cook now when I press continue the other
breakpoint from way before will hit and
skip the
to check and reach your return oh and
look at that we got lucky with ESP and
ESP actually points into our buffer when
we now continue we return into the if
case that prints the modified string and
there it is amazing
so the exploit theoretically works all
that is left is the cookie brute-forcing
unfortunately that deserves its own
episode again it's just programming but
doing it you can learn a lot about Linux
I don't want to squeeze it in here again
try to do that part yourself you could
really learn a lot
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>