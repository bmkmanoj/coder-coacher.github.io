<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Format String Exploit and overwrite the Global Offset Table - bin 0x13 | Coder Coacher - Coaching Coders</title><meta content="Format String Exploit and overwrite the Global Offset Table - bin 0x13 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Format String Exploit and overwrite the Global Offset Table - bin 0x13</b></h2><h5 class="post__date">2016-08-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t1LH9D5cuK4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">two episodes ago we did our first format
string exploit and in the last video we
had a look at how dynamically linking
libraries to binaries work basically how
can a program call functions from Lipsy
and we also had an idea how to abuse
this when we want to redirect code
execution in this video we will use this
technique to exploit format level 4 from
exploit exercises protostar first let's
have a look at the code the main
function cause bone bone reads up to 512
characters from standard input into the
buffer and then uses printf to print the
buffer we also see immediately that the
buffer is placed as the first parameter
of printf and that is the format
parameter after the printf there's a
call to exit this means that this
function form will never return it will
perform the source call exit to the
kernel which will quit this process so
if it would overwrite the return pointer
of this function we will never return
and we could not exploit this so we use
the technique from the last video where
we overwrite the global offset table
entry for exit with the address fro
hello that instead of exit we execute
hello at the end let's get everything
ready I use again VMware to run the
protostar image and connect to it via
SSH with putty
open one window for the binary and
another video where we can write the
exploit we also might want to import the
struct module right away because we need
that to convert integers to binary
strings let's start by first verifying
that we have a format string
vulnerability we can just specify some
format characters and see if they are
turned into numbers yep it works so to
make this exploit work we have to figure
out a few addresses let's get the
addresses of the hello function with
examine hello here it is
let's copy that into our exploit script
we can do that easily by simply
highlighting the area you want to copy
and then perform a mouse right click
into the other window
next let's try to find the global offset
table we want to write this hello
address - this is a symbol main okay
right I forgot we call one so
disassemble one and at the bottom you
can see the call to exit at the
procedure linkage table PL thing
disassemble that address and we can now
see the address that is referenced in
the first instruction with the jump that
tries to reference the address of exit
from G loop see from that location so
examine that address and yep let's see
global off the table now we also store
the table address in our script and
let's set two break points in Vaughn one
before the print death and one after we
print F next let's simulate by hand
overriding the G ot entry run we enter
some random stuff first breakpoint now
we are before the printf now let's
override the G ot entry let's check G ot
again now write set and in curly braces
int the address we want to write to and
then the value we want to write and now
the entry for exit in the G ot has
changed continue once now we are after
the printf just one instruction away
from the call to exit let's continue and
see if we execute exit or hello Boop
okay we executed hello
that worked now we just have to achieve
this ride with a format string and
percentage n okay set one let's exit the
debugger and let's find this string we
enter on a stick by playing around with
the format specifier we use our script
to do those tests so first we know the
buffer is 512 bytes long so let's write
a function that pads our string to that
length so we simply append a certain
number of characters to our string where
the number is 512 minus the length of
the current string then we create a
variable exploit and print that variable
hedid and when we execute it we can see
our exploit string and edit spatter to
those 512 characters so this should
print the first four values from the
stack if we type it into the input of
the format for binary yep
seems to work now let's prepare some
recognizable characters to a string and
then try to see how far away our string
is on the stack
okay our string already starts with the
fourth value now we can use the number
dollar notation in the format string to
specifically reference that offset so
for dollar after the percentage sign
that would attempt to reference the
fourth parameter of printf instead of
going through the parameters one after
another so now all values are for one
for one for one for one I hope you
remember that percentage n can be used
to write the number of printed
characters to an address on the stack so
we could replace our characters with the
address of the global offset table
address to write to that value let's try
it we use struck to convert the integer
address to a binary string struct pack I
exit PLT let's replace the percentage X
with percentage N and see what does what
it does in gdb but first write the
output of this script to a file so we
can use it in gdb as input
don't forget to set the breakpoints
again run and pipe in the exploit string
we hit the breakpoint so now we are
about to execute the printf let's check
the global offset table entry now let's
execute the printf and let's check again
ha we've all written G ot with a fairly
small number if we now continue we will
segfault and exit because at this
address is no function so percentage n
has successfully written the number of
characters printed into the global
offset table now all we got to do is
print enough characters so that we reach
the number that is the address of hello
hmm hex 8 0 4 8 4 B 4 then that's a big
number we have to print like over 134
million characters each characters abide
so we have to print like 128 megabytes
of text will that work well first of all
we only have space for 512 characters in
the buffer so we can simply write them
all but we can abuse printf format
string again to pad an output string to
any size which allow us to write many
more characters
let's trial it let's also change the
number of ends down to only 1 in fact
let's change it back to X so we don't
smash the table all the time and we can
make sure we always hit the address so
let's put this to like 30 characters to
see if there works
run it against the format for binary
and yes see all those spaces text got
padded to 30 characters now let's try
that with 134 million oh and we must not
forget to add another percentage n
okay it does something it seems to work
it's printing and printing and printing
all those millions of carats of spaces
this takes ages printing those hundred
megabytes is just crazy ah done let's
see if something changed but it did
change the global offset table pretty
close to hello you just would have to
fiddle around a bit and adjust it just
exactly but you know what this sucks to
print so many characters let's use a
little trick let's use two shorter
writes to achieve the same the idea is
that we could first write the lower two
bytes with a much smaller value and then
perform another write at address plus
two to write another small value to the
higher bytes
that's constructing the hole for byte
through to writes so let's try to write
the lower two bytes first let's start
with a penning with 30 write the output
again into the file and run gdb with it
as input okay
so with the padding of 30 we are able to
write hex to e
which is 46 our goal is to write the two
lower bytes so we want eight four before
which is thirty 3972 because we had a
petting of 30 but we ended up with 46 we
have to compensate for those 16
characters so we subtract 16 from it so
we want to put 33,000 956 into it as
padding and when we run it it's fast and
look at the G ot Henry we can confirm
that the two lower bytes are now 8 for
b4 now to address the to higher bytes we
move our address by 2 forward and
perform another right so let's add this
entry as well so except plus 2 this
means that for the second write we want
to address the fifth element on the
stack and now we just have to figure out
how many we need to write here let's try
with 30 again
okay the lower bytes now stay it for
before perfect and the higher bytes are
842 but we want to get only 8:04 so how
do we get a lower number if we can only
increase the amount of characters well
in reality we don't only write two bytes
we always write four bytes this means
also that currently we screw up data
that I store behind our exit G ot entry
now guess what happens if we write
enough to increase the number such that
the third byte is one it doesn't matter
for the GRT because it will only see the
other four bytes so basically we
overflow those two upper bytes so we can
get there a low value now currently we
have 842 and we want 8:04 I mean we
actually want one zero eight zero four
and if you subtract now the eight 4d2
from this we know how much we should
write to get to one zero eight zero four
so eight three three two but that's hex
so that's thirty 3586 characters and it
already includes the story padding so we
must not forget that now we might be
done let's check let's modify that and
then we write the output file we run gdb
we break before the printf this how the
table entry looks before now continue
and examine the address again
whoo we changed it and that's the
address of hello
so now continue and let the program run
and boom code execution redirected we
win it's crazy how a harmless-looking
function like printf can be used to
control the instruction pointer
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>