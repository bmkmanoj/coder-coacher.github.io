<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Don't trust time | Coder Coacher - Coaching Coders</title><meta content="Don't trust time - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Don't trust time</b></h2><h5 class="post__date">2017-08-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ylfyezRhA5s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">fundamental principle of building secure
systems is to never trust user
controlled input every data coming into
your application that an attacker can
fully or partially or maybe potentially
control has to stand up to the utmost
scrutiny and one data source is often
trusted even though it should not be and
that is the system time
so I was playing this awesome game magic
harp jump which is this cool Pokemon
mobile game but unfortunately once you
depleted all your actions you have to
wait for a while a problem I have is
with anything I do I always imagine how
something could have been implemented
and maybe even play around with it to
see if my theories were right obviously
there are many different ways one
couldn't implement such time off for
example when you launch the game you
load the current state of any action and
when you want to do an action a request
is performed through the server asking
to do something and the server would
respond to it yep you can do that and
here is your timeout the UI will be
locked until the time ran out but even
if you would do the same request again
trying to cheese the cell would say nope
a time are still running so in this case
the concept of time for this game is
located on the server whatever the
client says the server knows it better
and that's what you want but if you have
to wait for every response from the
server to see if you are allowed to do
something the game will feel slow and
sluggish and also some games don't want
to require always an online connection
because that is annoying so obviously to
solve the speed issue you could do a
synchronous requests and have some logic
in the game that predicts the outcome of
the server so the you I can feel fast
and in case there's mismatch between
what the game expected and what the
server at some time responds for example
when the player tried to cheat then the
game backs out and says nope we start
got a sync the state again but sometimes
requests fail and then the user would
constantly see those out of sync errors
and that's really annoying so you can
invest a lot of time in optimizing this
to make the user experience good and
keep any critical logic on the server
but you will quickly notice that it's
not a trivial engineering task and and
you have to think of so many edge cases
and how you want to handle them that
your deadlines or your laziness probably
makes the decision on how you implement
this for you not to mention that time
zones and people who travel and all this
crap makes program
with time really annoying and the
simplest solutions that will feel fast
in the skirt for games are the most
cheater friendly implementations you do
any validation on the client and once in
a while you push the curtain stay to the
server just to save it so if the
application crashes or is deleted the
user can simply restore the latest safe
from the server a lot of this
communication can be protected you can
use encryption and signing to prevent a
man-in-the-middle attack so a cheater
can't easily modify the traffic to
manipulate your safe game and when
running on a non jailbroken phone the
user also doesn't have a lot of options
to modify values in memory obviously
there's a bit different on a desktop
machine but the bar to cheat becomes
higher and if your game has no big
monetary incentive for cheaters like
selling valuable digital goods or
accounts you can be fine but there's one
data source
everybody can easily control on the
phone and it's also trusted by these
simple games and that is the time so
what happens in magical jump is you can
simply forward your clog or date go back
into the game and the time off or reset
you can again perform any action and
suddenly cheating is super simple and
didn't even require any intrusive
actions that would be considered hacking
and this is true for so many mobile
games but it's not only a threat for
games software licenses often have
limited time periods they allow you to
use it where's the time information
coming from that the software require
always online so you can query your own
trusted sign time sent from your server
or the users complain about needing an
internet connection to use your tool so
you use the local system time here's an
example look at the software some of you
may know jb2 is an awesome Android
decompiler I love it but it only works
without an internet connection when you
pay the higher price and my speculation
is that you're compensating or lowering
the risk of piracy related to very easy
license restriction bypasses this way I
don't really know that's just my
suspicion but it's obvious that when you
have an offline machine how do you
verify that
something expired how would the software
know the only source of time is a system
time which can be controlled by the user
so many demo version restrictions that
run out after 30 days can be bypassed
like this but this goes even further
where's the system time information even
coming from why is the clock accurate
why does it know the correct time when
your PC didn't have power for a week and
I mean you probably know that's what NTP
the network time protocol is for NTP is
a network protocol for clock
synchronization between computer systems
or packets which variable latency data
networks in operation since before 1985
NTP is one of the oldest internet
protocols in current use and what do we
think when we hear about old protocols
they are generally from a time where
transport security was not really a
concern it's read a short summary I
found about this in a paper
authenticated Network time
synchronization early versions of NTP so
original NTP NTP version 1 and version 2
had no standardized authentication
method NTP version 3 added an
authentication method using pre shared
key for symmetric authentication and the
negotiation of keys and algorithms must
be done out-of-band
that term comes from radio frequency
bands so an out-of-band as an activity
outsider defined to the communication
frequency band because you suspect the
enemy as eavesdropping on the one you
use and that's why I missed offers a
secure time server and symmetric keys
which are transported from server to
client by postal mail that sounds crazy
but of course if you cannot trust your
network that's why you want crypto to
protect your NTP packets
you can't send the keys over this same
network upon a request this will reply
with the key number and a key value the
reply will be by u.s. mail only unless
the requesting organization or
individual specifies that they reply by
fax as acceptable a reply by email will
never be used that's so interesting
anyway establishing a pre-shot
symmetric-key with billions of clients
PCs and other ntp synchronization
devices seem impractical
that's why NTP version 4 introduced a
public key authentication mechanism
called Auto key which has not seen
widespread adoption and unfortunately
Auto key uses a small 32-bit seed that
can be easily proved forced to forge
packets a more recent proposal is the
network time security protocol mts and
just as an example when I look at my ntp
packets on my Mac I see there are no
authentication or crypto fields used you
could run your own ntp server and deploy
auto key or pre shut authentication keys
with your client but then how does your
server get the time it's the server
located in a trusted Network you see it
gets very complicated very fast and this
is a problem because think about SSL
certificates they generally have a time
when they start to become valid and when
they expire and I mean how do you
determine that an SSL certificate
expired where do you get the time from
think about it what if you get a hold of
an old expired certificate and you want
to perform a man-in-the-middle attack
the browser would still flag this
connection as insecure because it
expired but what if the attacker now
also controls NTP and changes the system
time quietly
so the browser starts to trust it again
now the user doesn't modify the local
time but an attacker through a network
protocol but the good thing is browsers
are very aware of that and for example
chrome has a trusted time source from
Google and they try to determine whether
your system clock is off and in that
case refused to do SSL until the time is
in sync again but other systems that are
not as complicated as browsers other
protocols that use certificates might
not have this kind of logic so overall
it's a mess
time is complicated and a lot of issues
can happen because of it so if you
develop an application that requires a
sense of time keep these things in mind
however general mistrust in the system's
time and try to work around them to find
other clever solutions that lower the
risk of manipulated time information</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>