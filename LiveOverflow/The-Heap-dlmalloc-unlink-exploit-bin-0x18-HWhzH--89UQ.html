<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Heap: dlmalloc unlink() exploit - bin 0x18 | Coder Coacher - Coaching Coders</title><meta content="The Heap: dlmalloc unlink() exploit - bin 0x18 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Heap: dlmalloc unlink() exploit - bin 0x18</b></h2><h5 class="post__date">2016-11-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HWhzH--89UQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">last video we had a look at the DL Malek
implementation of free we discovered the
unlink macro that can be used to write
almost arbitrary data to another address
we constructed a proof-of-concept heap
with gdb and observed a successful write
to the global offset table but
eventually we realized that our plan
would not work because it contains too
many null bytes and we can't write those
with a Serra copy let's quickly recap
and summarize what we know about the
heap and the free algorithm to refine
our exploitation plan the last video was
more explorative taking you along how
you could discover the exploit yourself
but this video will be more of a
presentation this way we have two
different styles of videos about the
same topic which I hope increases the
amount of people who understand how it
works
so let's look again how a heap chunk
looks like when you allocate a chunk of
a certain size the size of the chunk
will be written to the second word and
melech will return the address here this
means you have this area for user data
the last bits of the chunk size have
special meaning most importantly the
last bit is the previous in use bit so
that is information about the chunk
before so that's a little bit weird to
wrap your head around at the beginning
this means if this block here is
allocated the block afterwards would
have the last bit set because the chunk
in front of it is news now a free chunk
could contain more information so once
we free this chunk we obviously can set
the last bit of the chunk afterwards to
0 to indicate that the previous chunk is
not in use anymore
now imagine there is a third chunk a
chunk after the second one which has its
previous use bit not set this means the
second chunk is free now the algorithm
would like to merge consolidate those
two blocks this is where the two words
after the size start to become important
they are the forward and backward
pointer just as a side note this only
applies to chunks that are bigger than
the fast bin size because fast bins are
very small chunks and they don't use a
double linked list so our chunks are
bigger let's consider this heap set up
we have a chunk we want to free which is
followed by an already free chunk and
that free chunk has two pointers forward
and backwards pointing to some other
free chunks so they are in this double
linked list now what will happen is the
free algorithm will merge these two
blocks together it will do that by first
unlinking the free block from the list
by using the unlink macro and we learned
what that does it takes you forward
pointer address and writes it at the
forward pointer of the previous chunk
and it will take the backward pointing
address and write it to the backward
pointer of the next chunk and when we
obviously control the pointers of a free
chunk that will be unlinked we can point
into the global offset table and right
there the forward address in the last
video we stopped here and didn't check
out what happens next but let me tell
you now so next we will increase the
size of the chunk we are freeing with
the size of the already free block and
then we will insert this block into the
double linked list which means we take
one chunk and look up its forward chunk
and then we update the pointers
accordingly to now include our chunk
this is the whole magic of the heap now
let's get back to the famous frac
article Once Upon a free and voodoo
Melek tricks to see what they tell us
about the unlink exploit both articles
contain a cool little trick to overcome
the limitations of the null byte so when
we want to construct a fake chunk that
we can unlink we want to make sure that
no field has to contain a null byte this
means we have to use very very large
values for the size but it doesn't seem
useful because the heap is not that big
hmm but the clever idea showed in the
frac articles make use of how computers
handle negative values so let's quickly
explore what happens with the 32-bit
integer value when we add a very very
large number for example ffffff see that
would be over 4 billion now what happens
when you add 64 which is decimal 100 to
that 4 billion it doesn't fit in 32-bit
and the carry of the addition will be
lost now you have a very small value
again in fact it's hex 6-0
which is for less than the 64 this means
by adding four billion the FFC to one
hundred we actually subtract four and
that's a really useful behavior for our
case because this value that doesn't
contain any null bytes behaves like a
very small subtraction so when we skim
over the source code again we can now
make a plan first of all we again have
to overflow the size of our chunk with a
bigger value than eighty so let's do the
100 like last video but then we could
also not care about the first
consolidation attempt of the previous
block this way we don't have to set up
another fake chunk so you make sure that
the last bit of the block we are going
to free is set to one so it's still in
use but we could do the consolidate
forward part there we take the next
chunk and check from its next chunked up
revenues bit and if that is not set we
attempt to unlik consolidated black this
means we need to fake blocks one that
contains the forward and backward
pointer we want to use to overwrite the
G ot with an address from the heap and
the second chunk has type of size with
the lowest bit set to zero but we can't
use small size values but if you look in
the code house size is used it's just
used as an offset which is added to an
address the code doesn't check that it's
a ridiculously huge chunk it just adds
the value and here where the trick comes
into play we could use ffff C as the
size of the chunk which results in a
minus four now think what will happen it
will take the size of the chunk adds it
to the current address to find the next
chunk which fools free into thinking the
next chunk is at minus four from here
now it will read the size of the chunk
which we could also set to FF C which
doesn't have the last bit set and
concludes yep the block before was not
in use
let's unlink it and boom it's very
beautiful and clever and doesn't contain
any nor bytes so let's see if we can
fill the heap in a way that we can do
that
String copies so shrink copies stop at
null byte this means we have to use one
of them to overflow the size of the
chunk we want to free with 100 hex 6-4
obviously we want to press in use bit
sets so we need to outflow it with 65
this works because we don't want to
override more than that
it ends in a little bite and keeps the
size clean the other string copy could
be used to fill up the hundred byte
until the weird conjoined fake junks
with FFC and afterwards the two
addresses we want to write now like in
the previous video we will set the one
address to the global offset table so
that we override puts and the other one
will be pointing in into the heap the
scenes we will redirect code execution
to the sea bed rest and we can use the
first string copy to play some shell
code here keep in mind that the unlink
will also write some data from the
global of the table to this heap area so
we have to either keep the shellcode
short or jump over the smash data and
continue shellcode afterwards but we
just want to call winner
so let's construct the exploit you could
do it in one line but let me break it up
to make it easier to follow in each of
these windows we will construct one
parameter one string for each string
copy so maybe let's first take care of
the string copy of the middle chunk
because that should be the one to
overwrite the chunk size with 101 of the
third chunk I use echo for that and I
counted the amount of characters
necessary to hit the size of the chunk
where we then write 101 hex 65 I
redirected the output into a file B
anyone can use it with backticks and cut
as a parameter in gdb we can then run it
and investigate the heap looks perfect
the size of the third chunk is now x6 5
next let's take care of the third chunk
which is after the overflow so it's a
hundred byte big so we want to write
like a hundred characters to fill the
trunk and then eventually we arrive at
the next chunk where we want to write
the FFF C's for the trick from earlier
followed by the global offset table
address enter he bed rest here I get the
to address four puts and subtract -12
from it because the heap address will be
written at plus 12 and then comes the
last string copy the first chunk what we
want to include our short code to call
winner
I quickly googled for an online
assembler to create the shell code we
want to call an absolute address to do
this we have to go via a register so we
could move the address of winner into
EAX and then call EAX we can simply copy
the string representation of the
shellcode and write it into the file a
cool now that we have all three
parameters we can rerun the program
let's execute the free and single step
into puts call oh great we follow into
the heat but somehow our shell code is
wrong you can see that it's completely
garbage instead of our shell code we
have some addresses here oh of course we
perform multiple freeze not just the one
we obviously write metadata over these
values but you can simply fix that by
pointing to a different area of the heap
how about here at one for now we change
the address and prepend some characters
to our shell code and try it again we
run it single step into puts and arrive
at winner ha ha let's try it without gdb
it worked gosh I love this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>