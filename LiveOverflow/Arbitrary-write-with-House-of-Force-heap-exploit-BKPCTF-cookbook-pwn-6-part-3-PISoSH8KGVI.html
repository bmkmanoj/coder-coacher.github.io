<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Arbitrary write with House of Force (heap exploit) - BKPCTF cookbook (pwn 6) part 3 | Coder Coacher - Coaching Coders</title><meta content="Arbitrary write with House of Force (heap exploit) - BKPCTF cookbook (pwn 6) part 3 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Arbitrary write with House of Force (heap exploit) - BKPCTF cookbook (pwn 6) part 3</b></h2><h5 class="post__date">2016-03-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PISoSH8KGVI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in the third part of the cookbooks
challenge from the Boston Tea Party CTF
2016 we will wrap up the exploit but
let's do a first quick recap on what we
achieved in the last video
okay so cool the exploit so far leaked a
heap address and then proceeded to use a
slightly different bug but similar to
leak the global offset table entry for
printf which we can use to calculate the
ellipse eBay's address which will be
important later the next step of the
exploit is titled use Lipsy address to
get the free hook pointer what the free
hook pointer is are generally what free
hook is we will find out in a second
let's start another cookbook instance
create a name or anything just something
as now locked attached gdb to it set a
breakpoint to free and trigger a free
from the menu now start stepping through
the free call the first thing that is
happening is a very small function that
is called which simply moves the value
on top of the stack into EBX if you
haven't seen this before
this is just a neat trick to get the
current instruction pointer because when
you call a function the return pointer
will be stored on the top of the stack
so if you call a certain function that
moves the top of the stack into an
register you get access to the value of
the instruction pointer after the
function returns and obviously the
return pointer is pointing to free at
offset plus 6 because that is the next
instruction after this call this is
useful because as you know Lipsy will be
loaded anywhere because of a SLR so if
flipsie needs to calculate some offsets
inside itself it needs the often the
absolute address so it uses this trick
to get an address which Lipsy then can
use to calculate certain offsets to
certain places where it wants to so now
that we have the instruction pointer
basically in EBX the next instruction
will add a constant 1 3 3 3 3 9 a 2 EBX
now we can take a look at the memory
mappings and we can see well the
calculated value in EBX is pointing to
which is another memory area belonging
to a Lib C and not hundred percent sure
but probably like the data segment or
something like that from Lib C when we
step a little bit further we can see
that there's another value
subtracted from EBX hex a zero and that
is taken as a pointer and wherever this
address is pointing to has a value
stored there which is then moved into
EAX
either's address now in EAX which has a
symbol free hook and if you look at what
the next instruction will do it will
take the value that is stored at this
address and moves that one into EAX in
this case you can see that at this
address is stored nothing it's simply
zero and again we can look in the memory
mappings where this particular address
is coming from and it seems to come from
this area that is directly after let's
see F to make clear that I have not that
much experience and that I'm a bit
unsure what this is but I can just guess
but I think it's just a memory mapped
area that Lipsy did when the program got
initialized which is used for certain
variables like the free hook variable so
let's simulate what would happen if a
value would have been written there
let's assume we just had an arbitrary
write somewhere and we were able to go
write this so this value get loaded into
EAX
and then there will be tests e^x so this
tests if there was a value set or not
and because we set it now with gdb two
for one for one this check is passed and
when we step a little bit further we can
see that eventually we reach a call EAX
so it tries to jump two for one for one
for one for one words which obviously
doesn't exist as a function so this
means that theoretically you could hook
free which means that your function will
be executed before free this is great
for debugging purposes but maybe we can
abuse this if we are able to write any
address to this location
we can redirect code execution when we
execute free and the next step of the
exploit tries to leak this free hook
pointer so that we know where we want to
write to in order to hook free and you
can see that I have defined this free
hook offset based on the assembler code
at the top of my exploit code for this
free hope offset our three values we
find remember that this should be the
offset from where Lipsy is loaded
this means that first of all we
obviously have the value that is used in
the assembler code the 133 9a the second
value is obviously the offset of free
itself as you remember the assembler
code got the current instruction pointer
which was at free plus 6 so that is
basically this value which you can see
if you look again at the offset from
free in Lipsy the address 7 6 C 6 6 and
obviously we still have to subtract hex
a 0 from that value to get the to get
the pointer where the free hope pointer
is stored the same thing obviously has
to be also defined for the Lib C that
was provided with the challenge so to
show that off we can just load the
ellipse II that was given with the
challenge and we can look up free there
we can see that this has a different
offset so obviously we have to add a
different value there the other value
that we have to know is the value that
gets added to EB X which is also
different and then also whatever is
subset from EB X and then loaded into ax
has also a different offset so our first
step is to leak this free hope address
so that we can write our own values
there and that's redirect code execution
so just to make sure that you understand
this part let's do this calculation
quickly by hand so we leak the Lib C
address obviously so from that we can
calculate the offset to free the
assembler code we'll get the address of
3 plus 6
based on how this call trick works so we
can add plus 6 to it and then we
basically have exactly the value that
will be gotten from this call trick and
then we add this magic value on top of
it like the assembler code also did and
subtract the hex a 0 from it so this
results in a certain address an T value
at this address is the address where we
can define a free hook the address where
we want to jump to when we want to hook
free let me know how the free hook
offset is calculated we can also
understand the next step
exactly the same bargain code that we
use to get the value from the global
offset table for printf just in this
case we calculate a new address based on
lip see that we have leaked in a
previous step and when we run the code
we can see that this works nicely after
we leak the address from Lib C we can
calculate the freehub address as you can
see here and then it will add it to this
fake ingredient list and we get another
address that we can leak so now we know
where the freehub address will be and
this works nicely
we are defeating a SLR and every time we
get the different address the next step
of the exploit is called overwriting the
wilderness we want to overwrite the last
value on the heap which says how much
space is left in the CP arena and we
want to set this value to ffff if you
would not set this to a high value and
we would try to allocate a very big
chunk of data Melek will try to request
a new memory area with M map from the
operating system to have more space
available but if we set it to ffff
malloc will never think that the heap is
low on memory and basically when it can
allocate enough values to push the heap
forward to two addresses where we then
can arbitrarily write data to this
technique is often referred to as house
of force the name for this technique was
introduced by a paper called malloc
Maleficarum from I think over ten years
ago there's an updated paper called des
Malik Maleficarum which explains some of
the techniques and correct some of the
assumptions made and stuff like that and
here it's explaining the house of force
which is a technique regarding this top
chunk which is the wilderness the last
remaining free heap space the wilderness
is the last chunk and we don't want to
accidentally malach objects that are in
the middle of the heap so we use fill
heap function to fill in all the gaps
and defragment the heap so we know that
the new object we create will be at the
end of the heap so now let's do what the
exploit code is doing we start a new
cookbook instance and we attach gdb to
it and the first thing as we go into the
crate recipe menu then we create a new
recipe with N and we discard it
let's have a look how the heap looks
right now this is the address of the
recipe that we just created so now we
can investigate the heap of course the
recipe is empty that's why everything is
just zero but when you look at the 4
bytes before this block you see the 1f D
in v 9 which is the remaining size that
is free on the heap
this means that the recipe we deleted
was the last allocated block on the heap
that we just freed and if we search the
process memory for the address of this
free heap space we find that there seems
to be a pointer to that address in
memory belonging to a lip scene so Lipsy
is keeping track on where the end of the
heap is where the wilderness begins the
allocation of a new block on the heap
can be fairly complex finding free spots
and stuff but if the heap is filled up
like this and you have this pointer into
the wilderness then malloc will simply
use this address here to allocate a new
block there because it knows this is the
wilderness this is just free heap so it
can use it and this pointer obviously
has to be updated because right now it's
pointing at this address of the heap if
you would allocate a new block let's say
with thousand bytes then this address
this pointer stored in the memory from
Lipsy has to be updated and pushed a
thousand bytes ahead as well obviously
Milaap will not allow you to allocate
more than one FD 5 9 bytes but what if
you overwrite this with ffff then you
could allocate an arbitrarily big memory
chunk which effectively would update and
set this address in Lib C to something
different
so if we could allocate an arbitrary
large chunk we could push the heap into
the f75 area of the Lib C where the free
hook is stored so that's the idea of
house of force before we continue with
the exploit let's check one other
functionality out which we have actually
used before and that is giving the
recipe a name so in this case we gave
the recipe a AAA and if we look at the
heap we can see that the A's are written
inside of the receipt block and again we
have a use of the free loaner ability
here because we actually freed this
recipe before but the pointer to it was
not
skaars as well so let's continue with
the exploit we go into the add
ingredient submenu and then we allocate
a new ingredient with n when we now look
at the heap we can see that in the area
where we previously had the a is written
to there is a different value so this
means that we can overwrite those well
use with the giving the recipe and name
functionality at this moment I also
realized that it was completely
unnecessary to create two new
ingredients delete one is completely
sufficient to only create one because
what we want is we want to have the
wilderness area starting in the area
that we can overwrite with giving the
recipe a name so let's overwrite the
size of the last chunk we should be able
to do this with eight bytes and then we
can set the size so we go into the
create recipe menu give it a name and
then write eight zeros and then the F of
F's to it so let's run the exploit code
again and look at this on the heap okay
so apparently now we should have
overwritten this size with ffffff
so we attach gdb and we look on the heap
get the address of the last recipe we
edited and then look at this heap area
and we can see that indeed we have
written this ffffff and that it should
be the start of the free heap area and
we can verify this by searching for the
address and we can find that there is
this pointer to this heap area there
let's move on to the next step of the
exploit now we want to overwrite this Av
top pointer that is the pointer from lip
C to point to an interesting area where
we want to write to specifically we want
to overwrite the free hook pointer so we
want to point this pointer this a B top
pointer into the free hope area because
when we allocate a new chunk it will be
allocated at the address pointed to by
this AV top pointer here and if you
point this at free hook we should be
able to create a new object like an
ingredient or recipe and then write to
this location so first of all we need
the address of the current wilderness
and we have leaked a heap address before
and because the heap is deterministic
when allocating your stuff we know that
at the offset four four five eight which
is the start of the wilderness this is
important because we have to Mel log
especi
big size to push this AV top value
pointer further ahead to the area that
we want to so we have to carefully
calculate that one okay so let's verify
that we get the heap wilderness address
correctly we can run the exploit and
then look at it in gdb okay now we
should have over it in the wilderness
with ffffff and we can take the
calculated offset and check it out in
gdb and we can see that we have
successfully calculated the location of
the wilderness and also changed it to
all FS next we have to calculate a magic
malloc value that will push the AV top
pointer to the free hook area so let's
get the current wilderness pointer and
luckily the cookbook has the
functionality to malloc a block with the
size that we specify this is the give
the cookbook a name feature way to ask
us how long the name should be and that
will simply male lock this size so
that's perfect so at this address we can
find the wilderness so how much should
we allocate that we can move this
forward to the area of free hook so
obviously we have to calculate the
offset between the current heap
wilderness location and where we want to
write to or a little bit before the area
where we want to write to so just take
the location you want to reach and
subtract from this value the current
heap wilderness address so we can run
the exploit and take the magic malloc
value that was calculated by the expert
and verify this by hand we can see that
this new block that was allocated has
the size of a easier or something if we
add to this now the address from the
previous wilderness function we should
reach the area where we have the free
hook tag we're free hope is again we can
simply take the output from the exploit
and we can see that it's at 8 D 8 and
the area that we have calculated is at 8
Z zero so we are just a little bit
before the free hook area which is great
because the new area that we malloc
would be exactly in this area but
thinking about it again I have decided
to move the new free area a little bit
closer to the actual free hope which
makes it easier with the functions that
we can
I've decided I want to overwrite this
free hope with the address of system
because that can easily execute a shell
and we can easily do this by just giving
the cookbook a name which will allocate
a new chunk and then we can simply write
the address which we can calculate from
the Lipsy base address plus the offset
from system depending on which Lipsy you
are using so when we run the exploit to
the step we overwrite the free hook with
system we can check this fact in gdb so
this is the free hope address and then
we can verify that this address here is
indeed system and again the address of
system can be calculated because we know
the ellipses base address and we know
the offset of system inside of Lipsy so
now we are almost at the end of the
exploit we have all Brittany free whole
point of a system so every time when we
free an object we will call system and
there's a cool trick how we can utilize
this in this case for the cookbook
basically we can give our cookbook a
name and luckily everything will just
fall perfectly into place with reading
the cookbook name like this because the
stack and everything will be perfectly
prepared for the system call so the idea
is that we give the cookbook a name we
write in this command we want and then
we free the cookbook name again which
will trigger system and we'll execute
the command that we have specified to
visualize this better let's quickly
change the export and put this cool
trick in there so we can get control
over the menu again so we run through
the exploit and now we can write our own
commands again so let's try this let's
give the cookbook a name which is a
command we want to execute so G and just
an arbitrary length doesn't matter and
then for example ID and now when you
free it we will call system boom there
it is we executed ID and we can see the
output of the command so why does this
work what why does this work when we if
I type in a command like this and then
we would free it with our so let's have
a look again at the remove cookbook name
function in Ida so we can see that it
takes the pointer where we have written
the name - and stores it in EAX and then
calls free because free takes the
pointer to the buffer that was allocated
as a parameter and system also takes one
parameter in EAX with should be an
address pointing to the string that
should be executed that's pretty
convenient
so we're impressed are we will execute
you name - a and obviously we can wrap
this in a nice loop we always ask the
user for some input which we then create
a new cookbook name for it and then we
remove this cookbook name - trigger
system and execute this command and it
looks pretty neat very proud of it and
again down here here is the output of
the actual server during the CTF
challenge so before we end this
three-part adventure into heap
exploitation thank you very much for
watching I hope you have learned
something I have definitely learned a
lot from this challenge as I mentioned
in the very beginning this was a little
bit over my skill level and during those
hours and hours I have spent on this I
have learned a lot and I'm deeply deeply
sorry if I accidentally use the wrong
terminology first stuff and still not a
hundred percent sure if I have
understood what exactly the wildernesses
and stuff like this so just keep that in
mind but anyway what matters is the
technical details what matters is how
it's actually done and how the exploit
works there is the proof of concept the
actual name doesn't really matter it's
just semantics so see you next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>