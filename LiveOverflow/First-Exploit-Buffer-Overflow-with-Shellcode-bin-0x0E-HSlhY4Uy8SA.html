<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>First Exploit! Buffer Overflow with Shellcode - bin 0x0E | Coder Coacher - Coaching Coders</title><meta content="First Exploit! Buffer Overflow with Shellcode - bin 0x0E - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>First Exploit! Buffer Overflow with Shellcode - bin 0x0E</b></h2><h5 class="post__date">2016-02-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HSlhY4Uy8SA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's move on to exploit exercise tech
level five you should have watched the
previous videos to understand how we got
here the challenge description says
stack five is a standard buffer overflow
this time introducing shellcode and the
hints are that it might be easier to use
someone else's shellcode and that is
also what we will do and if debugging
the shellcode use the end 3 instruction
with the opcode hex cc to stop the
program executing and return to the
debugger and that is very helpful ok
let's have a look at this code it's
surprisingly small there's just one
function call to gets which we know
allows us to all right data on the stack
so how do we get from no functionality
of the program to a root shell so put on
your Wizards head because we will do
some magic so put on your results head
because we will do some magic let's open
this program in gdb and let's just throw
a long string against it to do that
let's already prepare our exploit script
so first we want to find the offset that
allows us to control the instruction
pointer I like to use a simple pattern
like the alphabet so I create this
exploit and then print that now redirect
the output of the script into a file
which we then can use as input for gdb
before we execute the program let's
create a breakpoint at the return of
main and let's define a hook like we
have done in previous videos define hook
stop and we want to display the current
instruction that will be executed next
so examine one instruction at the
location of the instruction pointer and
then examine eight words as hex from the
stick and end then execute it and we hit
the breakpoint at the return the next
line shows us how the stack looks like
right now and when we execute the read
we will jump to that address that was on
a stack before so now execute it again
with the alphabet we have to return
again and we can see that we have all
written stuff on the stack so now we try
to return to the address hex five four
five four five four four
which obviously is invalid so we get a
segmentation fault and with examine s
string we can see that we have over
written the return pointer with T's
so let's update our exploit script this
will be our petting and we create the
variable e IP which we can use to
control the instruction pointer and jump
anywhere we want and I use struct to
create a binary string from the address
again so struck pack but where do we
want to jump to we don't really have any
wind function like in the previous
levels do you have any idea where we
could jump to I think I will give you a
second to think about this
right we can just jump to the Steg where
we control data so obviously we could
play some assembler code there now let's
find a good address we could just jump
right up to the instruction pointer we
control to do that just run it again
execute the read and have a look at the
stack pointer so that is the address we
want to jump to and now we have to
append code that we want to execute
after return pointer so why not use the
opcode CC the end three they were
suggested in a chance description let's
also quickly have a look at the Intel
instruction reference let's search for
in three okay call interrupt procedure
what else do we find this table about
general exceptions it calls this
instruction breakpoint huh that's
interesting
okay here's the description of it
interrupt number three trips to debugger
and down here it reads the in three
instructions is a special one by top
codes you see that is intended for
calling the debug exception handler this
one by it form is valuable because it
can be used to replace the first byte of
an instruction with the breakpoint
including other one byte instructions
without overwriting other code well what
does that mean well how do you think gdb
works or any other debugger for that
matter how can you just stop the CPU
from executing something or just step
one instruction actually a debugger can
just use the in three instruction let's
make an example we just created a
breakpoint at the thread what we
actually did was we replace this
instruction in memory within three and
when you CPU reach this instruction an
exception was raised on hardware terms
an interrupt got triggered which stopped
the CPU from continuing executing this
and called an interrupt handler similar
to how the syscall cost and interrupt
and the exception continued somewhere
else and we can now decide how we want
to handle this exception and if we are
the debugger we could now replace this
in three instruction again with the
original value the return instruction
that can also be used as an anti river
technique because a regular application
will not use the CC instruction so a
malware might constantly scan itself for
the CC opcode and if it finds it it
knows that somebody attached a debugger
and try to set a breakpoint and now we
will use ECC in our payload don't forget
to write the output off the script into
the exploit file and then test this in
gdb okay run again and we see that we
stopped at the red and we see the
address where we would return to and we
continue now we pop the instruction
pointer value from the stack that's
continuing executing on the stack where
we have our in three instructions and as
you can see gdb stopped because it
received a signal SiC trap trace
breakpoint trap cool this way we know
that we have code execution because we
successfully injected an assembler
instruction now this is work without gdb
- let's try it
we get an illegal instruction that's not
what we should see we should get a
breakpoint message let's open it in gdb
here and try it again still illegal
instruction let's set the hooks and
breakpoint like in the other gdb session
okay run hmm the address on the stick
are not the same why are they different
let's do something crazy print the whole
stick I just print a thousand strings or
something and let's see what we get okay
first we have some gibberish let's go
further ah see now we get some
interesting stuff it's do the same thing
in the other gdb session this looks like
the environment variables for example
here is the user environment variable
that we used in a previous programming
video hmm when you look at these
addresses they are still different so
let's look a bit further down hmm
down here they are the same so between
here and the environment variables above
there must be something different when
you look closely you can see that the
PWD environment variable the current
working directory is different they have
different lengths so obviously the one
execution environment needs more space
on the stack to store this path and
that's pushing the stick further up no
wonder that the stack addresses are not
the same anymore so how can we cope with
that there are a couple of techniques
that you can use to get a bit more
control over this deck for example by
removing all environment variables
before executing a binary but there's
another way a very effective easy trick
and here's a hint no write an op slide
let's just add a lot of knob
instructions enough instruction performs
no operation and it has the opcode hex
90 instead of picking a very specific
address let's just pick one that we hope
hits our knobs so run again and now we
can see we have a lot of knobs on the
stack and the address we will jump to
just point somewhere else further down
and if you look at more of the stack we
can see that it points almost right in
the middle of the knobs
so let's just single step forward and we
happily slide down in up slide until we
reach the bottom with our traps
boom cool and it also works now outside
of gdb now instead of CC we want to
execute something useful so let's look
for some shellcode as you jump
description said it's best to reuse
shell code from other people I really
like the collection of shell code from
shell storm shell storm has a lot of
different kind of shell code for a lot
of different systems so we are looking
for Linux until 32-bit shell code
freebsd linux on arm 64-bit and here we
have 32-bit they all have a short
description and do different stuff but
we are looking for a simple exit via
that will just execute a shell so why
not take this one if you look at the
assembler code what it does is just
basically pushing some values on the
stick which are in fact just the string
that is the path bin it's H and then cos
x ik ve copy the bytes into the pipe
next Blood script as payload and we can
throw it against the program
hmm nothing happens does it not work
that is you see at the start of the
payload if if we still hit it it should
work remove this you see again and try
it in gdb let's signal step we are
sliding down the knob slide all seems
fine and out comes the shellcode and it
says execute a new program pin - this
first sounds weird but it's correct
Ben Sh just points to pin - so why the
hell does this not work also a side note
the gdb session is not broken because
exit ve replaces the current program
with another one so stick v got replaced
by bin - and you can see that when you
try to execute it again so you would
have to load stack v again with file ok
so what's the issue then this is one of
the things I got nuts when I first got
stuck like this I spent hours trying to
figure out what is happening as much as
I want to see anybody else suffer like
me I tell you what the problem is a
shell you execute want some input right
from Center input but we used a program
and redirected its standard output into
the standard input of this program and
when the program was done it closed that
pipe so now the shell is executed but
doesn't have any input because it's
closed so it will just exit and there's
a neat trick to get basically around
that when you use CAD without parameters
it simply redirects its standard input
to the standard output see like here you
type something in and it gets reflected
out now you can chain programs together
on one line for example with semicolon
so we can just first print the output of
the exploit and afterwards cat is
executed so we can enter a new input and
if we group that now with some brackets
and redirect their combined output into
this tech level the Xbox will first run
and execute the shell and then cat will
take over and we can simply relay input
via the cat to the shell and bam it
works we have an ugly cell and we can
verify our identity with who am i or ID
so now we have escalated privileges to
route
damn that feels so good it's just so
beautiful
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>