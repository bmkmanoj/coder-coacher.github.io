<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Explaining Dirty COW local root exploit - CVE-2016-5195 | Coder Coacher - Coaching Coders</title><meta content="Explaining Dirty COW local root exploit - CVE-2016-5195 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Explaining Dirty COW local root exploit - CVE-2016-5195</b></h2><h5 class="post__date">2016-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kEsshExn7aE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the public disclosure of dirty cow or
CVE 2016 5195 just happened this
vulnerability is ancient and allows a
regular user on a system to perform a
local privilege escalation and become
rude I want to show it to you explore
how it works and generally talk about it
let's cut right to the chase and start
by looking at the provided proof of
concept exploit I've here a wool neural
a bundle system where I can download and
compile the exploit then I create a file
owned by root 2 that I as a normal user
can't write to I can read it but not
right this is true for many files on the
file system like for example the ping
binary ping belongs to root and has the
set UID bit set this means anybody can
execute it and it will run as root but
ping doesn't do much except sending out
some network traffic so our root file
which is created resembles a file or a
binary like ping it's owned by root and
we can write to it now when we execute
dirty cow and pass it the root file and
specify a string we want to write we can
observe that the string got written to
the file we as a regular user of the
system have written to a root file that
we don't have write access to this is
insane now imagine we could have written
a backdoor into the ping binary we could
become root anytime without knowing the
password of root now let's try to
understand the exploit code let's check
out main first where the code starts so
first it opens the file we want to write
to as read-only
next comes a call to M map MF is used to
create a new mapped memory segments in
the current process one of these
parameters can be a file descriptor and
in this case it's the read-only file
owned by root this means it Maps the
file into a new memory area also the
permission flags show that this memory
area is read-only so far so good
the other important flag is the map
private flag the comment here is copied
from the main page of MF and it states
that this creates a private copy and
right mapping or
short Co W cow this is where one part of
the name for this vulnerability is from
M map doesn't copy the whole content of
the file into memory and map maps the
file into your memory this is awesome
because you don't need huge amounts of
RAM to load a copy of the file you just
directly read from the file on disk or
relatively directly we will learn about
memory in a second and copy-on-write
means that if you were to write to this
memory segment you would then create a
copy of it so even though the firewalls
map is read-only because of the private
mapping we can write to a copy of it so
the important takeaway here is that ml
will map the route file directly into
your memory and you can read the content
of the file or write to a copy of it the
changes to your copies should not be
propagated to the real underlying file
it's just for you
next we start to threads that will run
in parallel dirty cow is a race
condition vulnerability this means
certain events have to occur in a
special order that are fairly unlikely
to happen under normal circumstances so
you try to raise against the probability
of it not happening and you simply try
it over and over again and maybe you get
lucky so let's see what the two threads
are doing the first thread is the EM
advice thread this thread uses the
syscall m advice which probably doesn't
send for memory advice but for med
advice i think the marketing department
failed here naming this vulnerability
not met cow am i right okay done with
the dead jokes so this cyst goal can be
used for optimization reasons you can
provide the kernel some information on
how you intend to use a memory mapped
area because there are different
techniques how you handle caching look
ahead and so forth and the one advice we
give the kernel is that the memory area
we mapped the file to or at least the
first 100 by it is probably not needed
soon we say that with the med we don't
need flag which stands for do not expect
access in the near future
for other time being the application is
finished with the given race so the
kernel can free resources associated
with it subsequent acts
of pages in this range will succeed but
will result in reloading of the memory
content from the underlying mapped file
the last sentence is key to the exploit
otherwise not much else happening here
the other thread proc self mem thread
opens the file proc self mem which is a
special file and I try to explain really
quick so proc is the so-called pseudo
file system in fact most resources on
Linux are managed as files so you should
always see files in quotation marks when
talking about them imagine a file just
to be something you can read from or
write to so this could be a printer and
writing to the printer file could result
in an actual physical printer printing
the string on a piece of paper so proc
does not really contain files in the
common sense they refer to something
more general
most importantly for our case something
you can read and write to so in this
case proc self refers to a special file
provided for the current process so
every process will have its own proc
self and in there is a file called mem
which is a representation of the current
process memory so you could
theoretically read your own processes
memory by reading from this file now in
this case the exploit writes to this
file in a loop so first it performs a
seek which moves the current cursor to
the start of the file that we mapped
into memory and then it writes the
string we pass via the program arguments
to it so this will trigger a copy of the
memory so that we can write to it and
see these changes but remember will not
write to the real underlying file so if
you would do these things once or just
isolated from each other
probably nothing what happened because
that would be the expected result but
because there is a race condition issue
somewhere trying this over and over
again will create a weird edge case that
usually doesn't occur but in this case
it tricks the comb into actually writing
to the underlying file now let's have a
look at the patch because I think it's
very interesting and not very big so in
the comment message the author states
that this is an ancient back that was
actually attempted to be fixed once
badly by me eleven years ago but was
then undone due to problems on s/390 so
I'm a little bit disappointed here at my
IBM friends because they almost have
partial guilt here s/390 is the
architecture used by IBM mainframe
systems said anyhow let's have a quick
look the file that is paged belongs to
the Linux memory manager
hence the MM directory and the file
itself is called GOP which stands for
get user pages VM stands for virtual
memory and Pte for page table entry I
think that should help you a little bit
to understand the code so when you want
to write to this map memory the kernel
has to copy it because you are not
allowed to write to the underlying file
but a copy takes time now usually you do
the copy once and you are fine but in
this case we call m advice with don't
need over and over again
let's look this up in the code so if
this flag is used this function is
executed and the kernel source code
explains that the application no longer
needs these pages if the pages are dirty
it's okay to just throw them away
the app will be more careful about the
data it wants to keep I guess I quickly
explained dirty when you read and write
to this you never do this directly that
would be way too slow so you cash or
buffer them this means you hold this
data somewhere and at some point in time
you write it to disk
okay so if you read the data from disk
into memory you can just leave it there
in in the cache for further reads but if
you want to write to disk you write it
into this cache buffer but now you have
to tell the system that this buffer got
touched and it's dirty now it's not
clean fresh memory anymore in this case
the system has to make sure that the
change is properly propagated to the
underlying physical memory that it be a
file on a disk or flash memory so in
this case if you wrote to the copied and
mapped memory the memory page got
flagged dirty and because you tell the
colonel now that the page is not needed
anymore this means you don't care that
the dirty page has not been written yet
you just toss it so the EM advice call
causes the throwing away of this memory
this mean it's not in any of the memory
caches anymore
this is important for the exploit
because this means every time when we
try to write to it again the copy of the
memory might have been tossed so we have
to reload a new copy from memory so we
can write to it and creating this copy
takes time and this is the race
condition if the copying right cycle is
not complete yet the patch edit this
function that checks if the copying
right is complete and only then allows
writing to it to be honest I don't
understand this code really to tell you
why the snippet make sure that the copy
and write is complete but it added some
additional check so I assume it's final
so there is the mental picture of our
race condition we constantly use em
advice to drop any cached copy of the
mapped file and at the same time we try
to write to it which causes a copy of
that memory now in some rare condition
that can be hit very reliably by trying
over and over again we perform the write
to the memory before the page tables
updated to point us to our copied
version and we write to the real file
instead of the copied memory so the
crazy thing about this vulnerability is
that it has been in the kernel for a
very long time and it was even a known
issue according to the patch author that
had been attempted to patch it before so
over time this apparently theoretically
raised condition got viable because our
system got faster and faster and PHR
module SiC also states that this was an
all day exploit used in the wild so
there was a real threat now a bit of
controversy and this goes into the
unresolved debate that has been going on
for decades about how to do
vulnerability disclosure if you were the
person who found this exploit in the
wild what would you do
the obviously obvious arguments are full
disclosure because it was actively
exploited fully disclosing it right away
would have not given advanced attackers
anything new but the knowledge would
have allowed system administrators to
immediately pitch their systems but in
the other hand it's such an easy and
widespread vulnerability that a full
disclosure would have allowed armies of
less skilled hackers to take advantage
of it until less professional admins or
private people could patch it on the
other side we have the respond
visible disclosure where you first
contact the developers create a fix try
to roll it out and then tell people
afterwards the obvious arguments here
are you stopped professional suicide
mints fall from hot patching their
systems quickly and leave them exposed
for the ongoing a text now I don't know
what is the best way both ways have
advantages and disadvantages and it
entirely depends on your threat model in
general I lean slightly more towards
full disclosure because I like
information to be free though I myself
to responsible disclosure because I'm a
hypocrite I hope you'll like this kind
of exploit walkthrough video and that I
could show you something new and
interesting if I said something wrong or
you have additional info on why this
exploit has to be triggered through a
right to prop mem and not directly
writing to the address please correct me
or post additional info in the comments
below so that other attentive viewers
can benefit from it thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>