<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Stack grooming and 100% reliable exploit for format0 - bin 0x25 | Coder Coacher - Coaching Coders</title><meta content="Stack grooming and 100% reliable exploit for format0 - bin 0x25 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Stack grooming and 100% reliable exploit for format0 - bin 0x25</b></h2><h5 class="post__date">2017-11-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AahpiYxKR2c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">last week's video was about revisiting
format level 0 from exploit exercises
protostar on a modern ubuntu system and
we played around with it to see if we
can figure out a way to exploit it but
in the end I wasn't able to solve it but
lucky for me a user with the name WC
bowling on reddit thought it was fun too
and actually had a method to exploit it
so let's have a look at it
so here is WC Bolling's post I love
going back to all challenges like this
managed to get a fairly reliable exploit
normally under 500 iterations and there
is a high-level description how it works
I will write the G ot entry force tech
check fail with an address so we can
jump there instead the address can be
passed in via arc we we can't use nulls
but we can use blank strings instead as
the app-v location is semi random it
takes around 500 iterations which is
pretty reasonable for 64-bit so
obviously I didn't manage to figure that
out which means I didn't know something
and here is a learning opportunity for
me so I'm not going to pretend I knew
this for whatever reason I never noticed
that stack check fail is in the global
offset table and the reason for that
might be that I never encountered a
challenge with these constraints we have
a a format string exploit that generally
allows us to write anything anywhere be
know Lipsy function after the format
string bond that we could override in a
global off the table and see where we
also have a buffer overflow with a stack
cookie so I really like this challenge
now because the solution is so clever so
the function that is being called when a
stack could be got over it and through a
buffer overflow it's also on the global
offset table which means our goal is to
redirect code execution to our winning
message by overriding the G ot entry
fostex check fail and then do a buffer
overflow to trigger that function to
write to the global offset table entry
we have to get the address somewhere
onto the stack so that we can use
percentage n with the format string
vulnerability and the issue is that it
contains null bytes which we can't pass
in via the arguments I think the
arguments are string copied onto the
stack so we can't enter arbitrary nor
bytes but WC bowling had a cool trick
with empty strings as arguments because
a string ends with a null byte so an
empty string is
just know I think I had a super early
video to talk about environment and
arguments on the stack but quick recap
you have the Arg V char pointer Airy so
it's a list with addresses that point to
the strings and then you just have
memory with all the strings so this way
you can get the address with no bytes on
to the stick
pretty clever I never thought about this
before now you basically just have to
put everything together
WC bowling uses spawn loop to implement
the expert it's a very useful Python
library check it out and so here the
magic format string is built with a
large offset into the stick that
hopefully hits the addresses passed in
via the arguments and so there are two
single byte rights why are there only
two byte rights well the g OT already
contains an address that is almost the
target address except the last two bytes
so you can just reuse most of it then
this is being executed in a loop until
the winning message is shown the stick
has some randomized offsets thus you
have to try it a few times here's an
ASCII cinema recording by AWC bowling by
the way if you have a problem with a
challenge and you write me an email you
could use that to record a screencast so
I can actually see how you debug it and
what the problem is so while I
understand or the basic idea I still
wanted to implement it myself there are
a few challenges that you have to solve
like what is a good offset into the
stack to hit the arguments and the
alignment of the address through the
arguments and while I was doing that and
struggling with exactly those details I
had an epiphany and I'm so grateful that
WC bowling shared this exploit because
it pushed me into discovering this so I
actually found a 100% reliable exploit
for this challenge and you can't believe
how excited that makes me though I have
to admit that it might only work on my
compiled binary and for somebody else's
might not work you will see in a second
why so here it is that's all and we
execute it you can see it gets into
an execution loop of the winning message
and while it looks like a simple format
string vulnerability with the padding to
increase the amount of printed
characters an address and a percentage
NR present such HN to ride to an address
there are quite a few beautiful puzzle
pieces here so the basic idea came when
I was playing around with overwriting
the G ot entry fostex check fail WC
bowling had to rights and placed the
address in the arguments which made it
so unreliable I thought maybe we get
lucky if we place the address into our
string like is it in last video but
there's one problem the string that is
printed is coming from the arguments
which has an unpredictable position but
the string is formatted with s printf
into a buffer which will have a fixed
relative position on our stick so
basically the format string will be
evaluated so first it handles the
percentage D with the 1006 on 40
character padding and places it into the
buffer then comes the raw bytes of the
address and places it and then comes the
formant modifier to ride to an address
on the stick so now the position of this
address that was just written onto the
buffer is at a fixed offset location and
we always get it with 214 though the
problem is we can't have an arbitrary
amount of bytes padding because the
address has to be 8 byte aligned so we
can only increase or decrease the
padding and 8 byte steps which affects
the amount of bytes we can write with
percentage n it's always in these eight
steps so we don't have an write anything
condition but we can write something
close to the winning address now there
are two challenges first the stick is
fairly small and the formal result is
written into buffer on the stick so if
we use too much padding to write a large
number with percentage n we run out of
stack memory and get a sec fall but WC
Bowlings trick has made me realize that
we can in fact increase the size of the
stick but
using more arguments it will add entries
to the RV area and increase it the
second problem is that the address is
only written with three bytes so if the
location on the stack had other values
in it it won't work we need to write our
address onto this deck where there was a
zero or generally a small number before
and here's also where the arguments help
us again because we can groom the stick
by adding or removing entries into the
arc vieira so that the stack is large
enough and we have a zero at the correct
spot I love it so now we know how to
groom the stack to write to the Geo tnv
but we still have the issue that we are
not sure what to write because of our
multiples of eight restrictions I wrote
a simple Python function that generates
me valid exploit arguments with
different headings and adjusts the
amount of arguments and the right offset
accordingly and I started looking around
the printing of the winning message so
ideally we would like to write hex six
seven zero that's 1648 but because of
our alignment restriction that doesn't
work anyway I was then just trying them
to see if anything interesting would
come from it and luckily this one worked
let me debug this with gdb I set a break
point after the s printf before we check
the stack cookie let's look at the stick
so this is the percentage deep heading
with spaces to print the amount of
characters we want to write to and then
here at the end is the target address we
want to write to the g OT address we can
also look now what value has been
written there so we will jump to hex
four zero zero six six B let's look at
the disassembly and see where that would
be 6 6 B mmm wait that is not a valid
address this is not right it's in
between the compare and the jump not
equal let's use X to print three
instructions instead of the disassemble
command do you see that what the
fact there are now moves another compare
what the heck welcome to intro assembler
and more advanced drop this kind of
property was called the geometry of
Intel assembler in the famous rock paper
but never heard anybody using that term
anyway we jump in between the bytes of
the intended instruction and the cpu is
dumb it will just read those bytes and
interpret them as assembler and so in
this case the compare are part of the
compare and the jump not equal turned
into two simple moves which means now
there is no check for that beef and we
run into the printf to print the winning
message when we sing a step forward now
we get into the procedure linkage table
for stack check fail we jump to the G ot
entry which is our weird address into
one we execute the mouth and then we
call puts to print the message
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>