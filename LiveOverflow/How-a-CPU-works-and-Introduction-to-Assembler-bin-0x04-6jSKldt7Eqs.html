<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How a CPU works and Introduction to Assembler - bin 0x04 | Coder Coacher - Coaching Coders</title><meta content="How a CPU works and Introduction to Assembler - bin 0x04 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How a CPU works and Introduction to Assembler - bin 0x04</b></h2><h5 class="post__date">2015-12-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6jSKldt7Eqs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now I want to introduce how a CPU works
I hope I can take away any fear of
assembler you might have because it's
actually pretty simple in the next video
you will be able to use this to correct
your first small program first I had a
very long script where I basically tried
to develop the concepts of a CPU step by
step but I realize it's just too long
and I didn't get the point across but
then I came across this hacking game by
starfighters dot IO at the time of
creating this video stuff far as IO was
not available yet when you see this here
it should be up and running so go and
check that out and the creators of that
side have uploaded an article as a
preview of the game that preview is a
fictional report of reversing a handheld
device used for financial trading and
even though it's fictional it's not far
away from how it would look in reality
that's why I strongly recommend you to
read it but I will now take just the
part where they introduce programming
and sembly and talk a little bit more
around it and then I hope you will
understand how a CPU works as EPU has
amazingly simple concepts that can be
used to solve very complex tasks it's
really crazy and I hope you realize that
by the end of the video so imagine just
a sheet of paper or you write
instructions from the top to the bottom
this your memory like the RAM in your
computer and each line on that paper has
a number assigned just like a location
in memory has an address so instead of
line 5 on a paper in memory you would be
something like address hex 4 0 0 5 dB so
that paper or you know your memory
contains the assembly code by what kin
assembly code do so first of all you are
given a 232 global variables or fixed
size to work with and they are called
registers so you CPU depending on your
architecture has a number of those
registers they call those registers
global variables and that's what they
are just like in your C or Python
programming you can use them like
variables start
and perform some arithmetic on them like
adding or multiplying the next keyword
here is fixed size in a 32-bit machine
they are 32-bit wide and in a 64-bit
machine they have 64 bits so this is the
biggest number you can store in one of
those registers and if you want to deal
with bigger numbers you obviously have
to write code to split up the number
over multiple registers in some of those
registers are special registers the most
important is the program counter which
tells the CPU which instructions we are
executing next every time we execute an
instruction we advance the program
counter this register is often called PC
meaning program counter but on our Intel
x86 architecture it's referred to as the
instruction pointer IP or VIP or ARP
depending on 60 bit 32-bit or 64-bit
mode so when you look at the paper with
instruction in each line the instruction
pointer register will have the number of
the line that will be executed next we
often also refer to this as pointing to
so the instruction pointer points to
line 5 in minute has executed that
instruction it will increase by 1 to
move it to the next line
virtually all computation is expressed
in terms of simple operations on
registers let's do an example an x86
assembler you can move a number into a
register like move a x5 this means that
e ax will now have the value 5 and then
you can add a number like 3 to it add EI
X 3 now let's set another register to
evaluate so move e be x8 and then you
can subtract those with sub e ax e bx
this means that eb x is subtracted from
e ax and the result is stored in EAX but
real programs need many more than 32-bit
one byte variables to work with in our
case of x86 architecture that would be
more than 16 registers with 64-bit which
is 8 byte imagine to write a game like
Super Mario and assembly
would have to store Mario's X&amp;amp;Y position
the lives in the enemies the coins you
just seen more than 16 variables when
you want to collect more than 32-bit
worth of coins you need more space next
point is what doesn't fit in registers
lives in memory you can just use other
parts of the paper where there is no
simply code to store more values make
sense right memory is accessed either
with loads and stores at addresses as if
it were a big array or through push and
pop operations on a stack so the load
and store instructions are called move
in x86 assembler so we can move values
from a memory address into a register
and we can move value from a register
into memory
I like Intel assembler syntax and most
so in this case the breaks are like
records from an array or list so for
example in Python to access a certain
value in a list you would write my list
and in brackets 5 to get the element at
index 5 so we just do basically the same
just with a very big number because our
Ram is very big also they talk about
push and pop operations on a stack the
stack is nothing else in just an area at
the bottom of your memory so like at the
bottom of our paper and then you have
special registers that always point at
the top of the stack the stack pointer
SP or ESP or our SP it's special like
the instruction pointer when you push a
new value on top of the stack for
example push 5 the stack pointer will be
incremented pointing to the next address
and the value will be placed there and
when you do pop EAX the value at the
address of the stack pointer will be
saved in the EAX register and the stack
pointer will be decremented this is used
in programs all the time I have to
correct myself the stack is usually
upside-down so the stack grows downwards
meaning it starts from the highest
addresses and when we push a value we
don't increment the stack point or
decrement it and with pop vice-versa but
it doesn't really matter just imagine
literally a stick where you put
something on top or take something away
memories to an assembly program what the
this is 2a Ruby or Python program you
pull things out of memory in two
variables two things with them and
eventually put them back into memory now
when we talk about efficiency and speed
the calculations on registers are super
super fast and ideally your whole
program should only use registers but
because that's unlikely you have to put
value sometimes into memory because you
need those register for more complex
stuff but if you would optimize your
code you would always want to make sure
to access memory as little as possible
well this is also only half true because
we have something like caches near your
CPU actually multiple levels of caches
so if you repeatedly use the short
memory address it will be cached in a
special super super fast memory near the
CPU and not in RAM which is not too bad
but but you get the idea
control flow is done via go two's jumps
branches or calls the effect of these
instructions is to alternate the program
counter directly control flow means that
a CPU would be less useful if it would
just execute your program line by line
without being able to jump somewhere
else so for example to repeat a task you
want to constantly jump back in
assembler you have different
instructions to do that they are
referred to as jumps branches or calls
and they all basically change the
instruction pointer to a different value
so when you read jump to you would
simply set the instruction pointer to
tool and continue with that line kind of
like move to a jump that's just an
unconditional go-to so when you
encounter a jump you will always follow
it but much more interesting for complex
tasks is to make decisions were to
calculate next and most operations on
registers like addition and subtraction
have the side effect of altering status
flags like the last value computers
resulted in zero they are just a few
status flags and they usually live in a
special register so for example when we
earlier added 3 to 5 with a Dax 3 the
result was bigger than 0 so the zero
flag would have been not set or simply 0
when when we subtract 8 from that with
sub EAX 8
the result will be zero and that's
enabling the zero flick setting it to
one and branches I'll just go tools that
are predicated on status flex like go to
this address only if the last arithmetic
operation resulted in zero in x86
assembler that would be the je
instruction jump equal sounds weird but
how would you test if two values are
equal
you can simply subtract them and when
the result is zero they were equal and
that's set a zero flick so it makes
sense to call the branches zero flag a
set simply jump if equal a caller is
just an unconditional go to that pushes
the next address on the stack so a ret
instruction can later pop it off and
keep going where the call left off so
earlier I explained how the push and pop
instruction works so a very clever usage
of this deck is this call instruction
let's say and see you want to call a
function how would you do that in
assembler especially because a function
might be used in multiple places so you
always want to jump back where you came
from if you would just use the jump
instruction you would have to specify
the exact address so what you can do is
use the call instruction instead this
will push the instruction pointer of the
next instruction on the stack and when
the function you jump to finishes it
will execute the read instruction and
read will pop the current value on top
of the stick into the instruction
pointer again so like papi IP so we can
continue executing where we originally
came from and before we finish this
video I just want to make clear that
assembly instructions are actually just
numbers as you know a computer can only
store ones and zeros and we generally
represent those as numbers so simpler
code doesn't actually say movie x5 it
will actually say b8 0 5 0 0 0 0 and hex
b8 refers to move EAX and the remaining
numbers are available for the number you
want to move into a X so when the
hardware reads this number it knows that
it has to move the following number in
its EAX register
so an ad in assembler is a software that
takes this number b8 and makes readable
text out of it for us to easier read
assembler if you want to try this out in
practice you can go to micro corruption
comm you have to use a debugger to solve
different challenges they also have a
nice tutorial introduction to that
debugger and even though it's not x86
gdb it has exactly the same concept and
understanding concept is way more
valuable than mastering the technique in
my opinion in the next video we will use
this knowledge to do a practical example
that we will crack a small license check
program
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>