<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Playing around with a Format String vulnerability and ASLR. format0 - bin 0x24 | Coder Coacher - Coaching Coders</title><meta content="Playing around with a Format String vulnerability and ASLR. format0 - bin 0x24 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Playing around with a Format String vulnerability and ASLR. format0 - bin 0x24</b></h2><h5 class="post__date">2017-11-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CyazDp-Kkr0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">exploit exercises protostar offers a
Linux image with several challenges to
learn binary exploitation but a lot has
changed over the years and if you
compile this challenges yourself on a
modern system it's not as easy anymore
I already showed you that in previous
videos about the stack challenge I had
to make a three part video series to
explain how we can still do it and it
also only on 32-bit so if you are just
starting out make sure that you use the
linux image that you can download here
and don't compile the stuff yourself
otherwise all the tutorials about it
won't work and now for this video let's
continue with some other challenge we
compile them on a current Ubuntu version
without any compiler flags and see what
we get
obviously the rules of the game that is
hacking are that maybe there are
techniques I just don't know about I
don't really know the edge case is an
exploitation I mostly know the general
techniques and I think I have some
reasonable amount of creativity but I
don't know everything so it's likely
that there are people out there that
could exploit it in that case I'd love
to see a POC for that that being said
let's continue with Foreman zero so what
is this challenge about the attacker can
pass in an argument that argument is
then being passed as a string variable
to the former parameter of s print F so
we can inject stuff like percentage D or
percentage s it's also vulnerable to a
buffer overflow because s printf does
not print to the console to a CD out
like regular printf but prints or stores
the formatted string in buffer and the
buffer is only 64 bytes long now when
you attack this on the VM that you can
download here that has these challenges
pre-compiled the target variable would
be placed after the buffer so that you
can overflow the buffer and right into
target and then you have target modified
and when you make it so that it's
overflown with hex dead beef you pass
this check so enter 64 characters and
dead beef and you won but the challenge
he also said try it with less than 10
bytes and you would do that by abusing
format string modifiers that would
stretch the formatted output to for
example 64 characters and then you can
simply enter hex dead beef
afterwards so for example percentage 6
for D would output a number with up to
64 character padding and so 64
characters plus hex dead beef are
written into the buffer and you win well
is that still possible first we have to
install GCC and gdb on this fresh
machine
and I'm also going ahead to install peda
a gdb extension that makes things look
nicer so let's start with a simple
buffer overflow example but first let's
set a breakpoint in Vaughn before we
compare that beef then let's start the
binary and pass in an input that is much
larger than 64 bytes okay
so we hit the breakpoint and it compares
EAX with dead beef but EA x is 0 how can
that be
then we overflow the stack well we
certainly did the issue is that the
target variable doesn't come after the
buffer in this before so we can write as
much data as we want
we won't overwrite target you can also
see this here yeah X is loaded from base
point 2 - hex 5 4 while the address for
the string is loaded from base point on
- hex 5 0 so it's located after target
well does this mean it's not exploitable
hmm so if you are familiar with format
string exploits you also know that you
can write data with it by abusing the
percentage end modifier which writes the
amount of already printed characters to
an address on the stick and we can
overflow the stick so we could place an
address there and then carefully
construct the number of characters
printed before such that it writes dead
beef to an address and so we could write
to target and win that way right but a
SLR is our problem let me add a printf
to the code to print the address of
target ampersand target returns the
reference of a variable so that's the
address and we compile it and run it in
a nice while true loop you see how crazy
the address of target changes target is
a local variable so it's located on the
stack so this is also a stack address
but how much does it change it always
starts with hex 7ff and ends in a C and
this one nibble here only appears to be
C D E or F
that's a huge number it's over 1 billion
but maybe in this case actually doable
just take some time maybe a day or so I
just like to refer to the previous
three-part video where we brute force a
three bytes dead cookie that was roughly
16 million possible options and so here
is in reach I would say at least for a
very small binary like this the
execution speed is quite fast
let's see how it looks like on 32-bit we
have to install GCC multi Lib to do that
and then we can compile it with - M 32
when we execute it a few times you can
see that it obviously has less
randomness than on 64-bit it's only two
full bytes and then again a nibble
that's about 1 million attempts to hit
it so definitely even more in reach but
of course it's only feasible if you can
do millions of attempts reasonably fast
for example locally if this were an
application that takes longer to start
or a remote servers and that would
probably mean you couldn't really do it
how to create a format string exploit
and how that exactly works with
percentage and you can watch in multiple
other videos that I've done but there is
one additional trick that comes to mind
we could look out for so to write with
percentage n we expect the target
address to be on the stick in a classic
format string exploit you would use your
input that is maybe also placed on the
stack and reference itself but nobody
says it has to be an address you place
there the stick is full of values maybe
you get lucky if we look on a stick when
we are at the dead beef compare in the
execution flow you can see a lot of
stack addresses and so this would always
be valid stick addresses even with a SLR
now if one of those would magically
point to target you could just reuse it
we could just reference that address but
if we check the address we know of
target we can see that it doesn't show
up oh well but you see how creative you
can get with the exploitation we could
have been lucky
let's actually continue this train of
thought okay we don't have the for
target address on a stick but we do have
a lot of other stack addresses and we
have an overflow so we can overflow into
the addresses and just overwrite some
low bytes and keep the whole front let's
add another printf to print the target
value and print the resulting formatted
buffer and then let's play with it you
can see the S printf formatted result
let's try to find a a b b b on a stick
by consuming values from the stack with
some format modifiers
i want to find the offset where in a
stack this value is placed and we can
explore that with for example percentage
LX and the dollar notation so at stack
offset one it's not head of the two it's
not at all so three it's not and so
forth but at offset nine we now printed
the hex value of our input now let's
look at the stack layout for a nice
stack address we could partially
overwrite okay so down here is one let's
see what offset it has let's keep going
there it is add offset 19 which also
means from the start at offset nine to
offset 19 we have ten groups of eight
bytes so 80 bytes to fill and reach this
value we can achieve that with a format
string that pads a number to 80 bytes
and then some input to prove that we
overflow and when we now execute it we
see that the end of our address that got
printed by our 19 LX got all written
with ace if you paid attention you saw
that target is always at an offset with
this C so we can choose some input that
ends with a C as well to override it
for example L that is hex for C let's
execute that now you can compare what
address we got now through the override
with L and what target really was you
see that often it's not the same but
eventually it will match and so if we
replace the percentage LX to
and eight byte hex value to percentage n
then we will write to that address so
now we are writing the amount of printed
characters 81 because 80 plus the single
L to this address and maybe at some
point we hit target let's keep trying
boom there we hit target we wrote hex
5-1 to it which is 81 in decimal and
that works fairly reliably we can try
those few attempts by hand and I think
that's awesome unfortunately it's not
quite the solution because target has to
be dead beef and that's three billion
and decimal so with this technique we
would have to first print three billion
characters before we can do percentage
and and and that's not possible
anyway I think you can see how much
exploitation can become puzzle that you
slowly try to piece together in the end
I didn't manage to solve it but
exploring this was really fun I really
wonder if somebody is able to make a
semi reliable exploit for this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>