<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RTMP Heap Overflow CVE-2016-10191 - Exploiting FFmpeg ft. Paul Cher | Coder Coacher - Coaching Coders</title><meta content="RTMP Heap Overflow CVE-2016-10191 - Exploiting FFmpeg ft. Paul Cher - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RTMP Heap Overflow CVE-2016-10191 - Exploiting FFmpeg ft. Paul Cher</b></h2><h5 class="post__date">2017-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hRei9xXRAGE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's have a look at another ffmpeg
vulnerability again Paul will walk us
through the vulnerability that he found
together with email and I try to
understand it and add some comments
hopefully to make it a bit easier to
understand in the previous issue we
achieved code execution quite easily
this time we'll have to be much more
accurate in exploitation this crash was
found during fuzzing the LCP protocol
this protocol is binary so let's open it
up in my favorite hex editor called
radar - I like it to use when viewing
the binary files because it has a very
shiny UI nothing too special here just
some binary data so let me tell you
something about this protocol 13 P
stands for real-time messaging protocol
actually it was developed by a DAP for
real-time streaming of audio and video
the protocol has actually a lot of stuff
inside it and I had spent some time
learning with the specs before getting
into the exploitation all you need to
know about the simple protocol so far is
that a dozen handshake first and then it
starts to transfer data in small chunks
and maximum size of each chunk is 128
bytes now let's dig up into the source
code once again so after passing the
version check and doing some handshake
we end up in the packet read function in
13 P packing dot C this function simply
reads one byte of the header and then
calls the most important function in a
loop and this is the function which does
all the parsing got the protocol there
are a lot of structures functions and
allocations and all of them are
important as you can see each chunk has
the channel ID it is basically
identifier of the rtmp packet in the
array which corresponds to its own
buffer one channel may be filled by
multiple chunks because maximum size of
each chunk is hundred and twenty eight
bytes and packing data might be in my
life much larger each chunk has fields
like size type header timestamp and some
extra data
so if the current channel doesn't exist
yet or simply packet structure is filled
in the array and the buffer is created
for it so the AV rogue function with a
null point and means simply do the
allocation of the corresponding size
otherwise data is just filled in the
existing structure and the buffer so if
you will pay enough attention you may
notice you the issue there when the
structure is filled for the second time
there is no check that the buffer size
is best for the second time is actually
the same that the size of the allocation
made the first time and this is how we
will manage to get the heap overflow ah
yeah this makes sense so the packet
contains a channel ID read from the
header and if this packet was not seen
before
it will allocate it with the size but if
an attacker sends the packet with the
same packet ID again with a different
size it will not be reallocated let's
visualize that if we send a packet with
ID and size hex a zero it will get
allocated and then we can send another
packet with a d2 and the size hex ad and
will get allocated after the first one
now we send again a packet with ID one
in a much larger size like hex 200 now
we overflow stuff on the heap awesome so
how we are going to get the code
execution all the following another data
chunk does not give us too much let's
try to gather some primitives from the
source code so we could allocate data
chunk by sending new channel ID we could
overflow the chunk next to it by
changing the size and we could also
trigger the reallocation inside the LTP
check a lock array function it would
send channel ID large enough we will
trigger their relocation of the control
structure it will be positioned right
after our buffer we can overflow by
doing this little heap magyk
we overflow the pointer to the data and
get arbitrary right that's a super easy
plan we just forced the reallocation of
the area that contains the pointers to
the data chunks and thus the area will
be allocated now after the one data
packet we
and then we sent again a packet with
this channel ID to overflow into this
area and let's control the address of
those data chunks and can point it
anywhere we want and that's also right
there
so I already did some preparation before
and wrote the little proof of concept
because most of the work here was
counting offsets so there are the
functions I wrote these are lambdas for
packing our integers using little endian
great payload function helps me to pack
data into the RTMP protocol and create
our team the packet function will help
me to create fake rtmp structure on the
heap now let's take a look at the main
code so here's the handshake happens
after the handshake I sent first payload
with size just a bit bigger than 18
bytes in hex in some phase and the
channel ID number for I do this to
create control structure on the heap
next I send some data with larger
channel ID to trigger the reallocation
of the control structure next I overflow
the next hip chunk which happens to be
control structure and fix its size so I
will have no problem with the heap when
I will be allocating more data i
position the bike shank on the place of
the RTP packet with second channel ID as
you can see there a position the real
lock got PLT instead of the data pointer
so I will be able to write to it this is
my last steps I write a got PLT with
some data and after I use big channel ID
once again to trigger the real lock
function all these should give us
control of their IP register let's see
super straightforward exploit right if
you can override an address in the
control structure in this array you can
point it anywhere and write data to it
so here's FM pick in gdb with the
triggered seg fault we are jumping
directly to the our C's we now have the
control of the error IP register ok
successfully overwritten the got peyote
section achieving code execution should
be easy from now on I hope that the CD
motivated you a little bit and shown
that real-life exploitation may be
rather simple and this will encourage
you to make your own research good luck
this is a really great example thank you
so much Paul for sharing
with us and all the work you have put
into the recording make sure to follow
him on Twitter and check the description
for some links and don't forget to check
out the podcast episode with Paul if you
haven't listened to it yet
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>