<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>First look at a simple PoC crash - Exploiting FFmpeg ft. Paul Cher | Coder Coacher - Coaching Coders</title><meta content="First look at a simple PoC crash - Exploiting FFmpeg ft. Paul Cher - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>First look at a simple PoC crash - Exploiting FFmpeg ft. Paul Cher</b></h2><h5 class="post__date">2017-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/drPyKgt1MMg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Paul share is a researcher who together
with his colleague Emil phone phone
abilities in ffmpeg he then wrote me an
email asking if I would like to make a
video with him and this led to the very
first life overflow podcast episodes
which you should listen to to get a bit
more context for this video so Paul will
now walk us through some of his exploit
process and I will add some comments
here and there to hopefully make it a
bit easier to understand hello everyone
my name is Paul and today I will be
presenting you guys the research about
ethic security made by me and my
colleague Amy Lerner
we have already presented it in our
Tolkien page days conference which took
place in Moscow earlier this year I
believe you can still watch it in the
recording we didn't cover binary
exploitation too much in our talk so
today we're gonna focus on binary
exploitation and go is much in depth as
possible but before diving into the
binary exploitation let's take a quick
look what is ffmpeg and how it really
works at the front back is powerful open
source software which allows you to
easily record convert in stream order
and video thus it is used by many
platforms and services that provide file
storage conversion and editing
functionality this really means that
ffmpeg is used almost everywhere
starting from your favorite messenger
finishing up with your lovely meme
storage when you upload a short video as
a gif or so on some image sharing
platform it's very likely that the video
is handled by ffmpeg it's really a very
popular and big tool
course such system would be a good tug
because it has very large attack surface
there are some really cool researches
already for example research presented
at blackhat 2016 by Maxim engrave and
Nicola Anushka or research by Jin Valken
gold and metallurgy from Google I
managed to fix thousands of bugs in
ffmpeg
and many other researches knowing this
me and my colleague and Mills still
tried to take this challenge and find
some new bugs first let's take a quick
look at the ffmpeg functionality ffmpeg
has really cool features and all of them
are described in the documentation on
their official website seems like there
is a feature that allows you to collect
files not only from the local file
system but also from the remote systems
by using networking protocols so as you
can see you can provide a link as an
option to ffmpeg and it will go for the
remote file and take it and processes
them let's download the source code from
the github and see how the process is
implemented and now I'm going to clone
the rap out to my Ubuntu virtual machine
and this actually might take a while so
now have downloaded the ffmpeg source
code the follow my next steps you will
need to be sure that you have downgraded
your ffmpeg to the vulnerable version
you can do it by resetting your impact
correct version by using the commit
number or by returning from the git log
as I do it right now so I'm using git
reset hard to pull the head directly to
the exact commit number that's a funny
little advice look through the get
commit lock with his name in it to find
the latest version before it was fixed
now let's take a quick look at the HTTP
protocol implementation I'm using
Veeam to do this so as you can see the
ffmpeg that doesn't use the lip curl or
any other library and it has the custom
implementation of the HTTP protocol and
also many others so it is really
surface to search for the
vulnerabilities and this is a very
important observation lip curl has been
audited in this around for a long time
it's a very very safe library and also
used a lot but instead of relying on
some other library ffmpeg implements its
own HTTP handling ensure you will think
that HTTP is very simple but there are
weird protocol features that can break
your neck when you actually have to
implement it and see so for now I have
two versions of the compact compiled the
first one is compiled with address room
Taizo we talked about this one in the
our podcast and the second one is the
original compact binary but it has the
Box symbols and it is compared without
code optimization options so I can
easily debug it you can do it as well by
configuring project with the following
options I just want to quickly explain
the basic idea behind address sanitizer
and why it's great for debugging but
also for finding he prone abilities for
example one feature is that eizan will
automatically fill certain memory areas
with a recognizable pattern and when
then some code uses bad memory for
example in a heap overflow case it will
likely crash because of those values you
can easily recognize that it crashed
because it read data from dead memory
and there are a few more ideas and
tricks like that so it's very convenient
so well that's quickly recap how we'd
actually do the fuzzing at some point we
thought that there might be a small
chance that nobody has been fuzzing the
network protocols in ffmpeg and torus so
we might find here some vulnerabilities
and yeah this was exactly the case
I want explain too much about the
fuzzing process because we used secret
complex dark magic related technique
called launching I fell and the process
of fuzzing was already described in the
podcast so let's jump directly to the
part where we already have a crash so
here I got my crashes I have already
simplified them a bit to be more
readable for you so let's take a quick
look at them first so the first one is
ASCII text basically
like somebody I mean with my favorite
theme so this is HTTP protocol it has a
lot of really interesting features like
transfer encoding chunked for example
which was used here basically what it
does is instead of setting the content
length header and length of data and the
whole bunch of data afterwards it allows
you to send the data to server in little
chunks first you send the size of the
chunk in hex and then the next line in
the chunk itself finished with this zero
and there minus one was used as a size
as you can see maybe this was causing an
issue so let's move on so here wrote a
simple X are basically what it does is
it is binding on the port listens for
everyone and it basically is reading
their rv1 file name it reads it and
basically echoes to the output so
nothing too much special
let's now launch both binaries with this
output and see what happens so let's
launch the original binary first
segmentation fault confirmed so he wrote
a small server that just responds with
the test case that causes a crash and
pointed ffmpeg to load the file from
there and then it caused a segmentation
fault but how do you figure out now
where and why it happened and that's why
he compiled a second version of ffmpeg
with address sanitizer instrumentation
included so for a more detailed report
we're now are launching the address
entire binary
how let's see so the heat buffer
overflow in function HTTP Bluff read
this is nice you can see here the output
of address sanitizer and it recognized a
heat buffer overflow and it shows you
here how the heap looked like and FA
means heap redzone so that's a bad
address and because it was also compared
with debug symbols you can easily see
the trace of functions so let's launch
at the fan Peck using gdb and take a
closer look at what happens and then we
will start outing into the source code
so as you can see the server is all our
Zilla launched let's connect to it using
ffmpeg in gdb so as you can see the
crash is actually caused by man copy
because it reached the end of a map
virtual memory region let's look at at
the back trace so in these functions it
seems that the size equals to minus 1
integer so being able to pass in the
negative chunk size is clearly a
programming mistake that apparently
leads to an exploitable condition these
two functions are very interesting let's
look at them once again I will be using
the beam as my ID with support of C tags
this will allow me to navigate for the
source code quite quickly so keep up
just FYI
C text is a tool that will sift through
your code indexing methods classes
variables and other identifiers and will
store them and them can then use it to
quickly jump around in the C source code
so Paul now investigates a bit around
the line that caused the crash so this
is the HTTP buff read function and
inside the man copy the length is
actually minus 1 over here so this is
actually not exploitable but let's look
at what caused the corruption of the
size parameter this was already
corrupted in the previous function which
coded so let's look at it this is HTTP
restream function it is actually in the
same file so let's scroll up to the
top of the function okay as you can see
there is the piece of code which
corresponds for the reading HTTP type
Chang data so there is the line reading
there is the Estoril function which also
accepts the negative numbers so the
chunk size could have been negative and
later the minimum was taken at least two
and of course the negative number was
less than any positive so that's
probably how our sizing the chip was
corrupted which caused the crash of a
fan handbag so str2 long long integer is
a function that converts a string to an
integer and interest can be negative and
we know that the HTTP chunk size was set
to minus one so this function will
return minus one and a mem copy with
minus one is nonsensical and later there
is the HTTP above stream function which
was called with the negative argument so
as you can see this is actually not
quite exploitable let's jump back to it
and but still if we will be able to make
four through this branch meaning that
each buff end will be equal to the both
Petare we will be able to call call F F
or L read function which is different
from the mem copy hmm let's look inside
it and this is basically calling their
returns for upper with the callback
which is called URL read so here it is
code and by rail read is basically a
function which accepts an parameters
it feels this parameter to the read
function and caused it so that's it
maybe we will be able to translate minus
one to the read function and this issue
will be actually exploitable oh stop oh
boy now I'm completely lost
I didn't understand that last part but
that's because we don't know enough yet
about the heap and some other structures
as you can see this video is getting a
bit long it's a lot to process all
let's continue this very technical part
in the next video and see if we can
understand it then
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>