<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Developing an intuition for binary exploitation - bin 0x20 | Coder Coacher - Coaching Coders</title><meta content="Developing an intuition for binary exploitation - bin 0x20 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Developing an intuition for binary exploitation - bin 0x20</b></h2><h5 class="post__date">2017-02-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/akCce7vSSfw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we have already come a long way in
trying to understand how we can exploit
programs through memory corruption we
have covered a wide variety of examples
including buffer overflows for mastering
exploit and even heap exploit and a lot
of you might already find it quite
complex but if you put it into the
context of history we are still like
sixteen years behind the last examples
we have explored from exploiting
successor come introduce techniques that
were state of the art in like 2001 but
it still directly applicable to shitty
cheap embedded devices like some IT
stuff it's very important to lay a
foundation but before we start talking
about all these modern exploit
mitigations and how we can bypass them I
think it would be a good idea to try
putting what we have learned in more
abstract terms and try to get a feeling
or an intuition about exploiting
binaries
let's try to create a mental model of
exploitation but let's first introduce
some constraints otherwise it will be
too abstract let's focus on program
likely to exit before this means intro
architecture and unwilling ok let's
start at the beginning we want programs
to execute on our CPU that's why a
program contains assembler code machine
code a machine code is just like any
other data in our computers it's
basically just bits zeros and ones a lot
of times we have combined them into
bytes and the CPU can interpret a bite
as an instruction or multiple bytes can
be interpreted as instructions and some
crazy digital hardware magic in the CPU
knows that this particular value stands
for add the value stored into registers
and put the result in the first register
and registers are just like small memory
cells in the CPU which will fulfill
different purposes in different
architectures might have different
registers for different purposes but an
Intel we have for example the
general-purpose registers like EAX and
EBX that the programmer is free to use
however he wants to but there are also
special registers like a IP the
instruction pointer that one simply
contains the address which points to
memory where the next instruction will
be there's also the stick pointer ESP
which points to the top of the stick and
the base pointer EBP which together with
the stack pointer defines a stack frame
in for beginners this might already feel
complicated there's code there's data
there's stake there's a heap there's a
function you can call functions can
return somehow there's a like a return
point on the stack you can override with
a buffer overflow there are a lot of
different terms that we use but it's a
lot less complex as it may sound
because essentially there are just two
parts that are important we have memory
which is just a huge space of bits that
can be 0 1
usually we group them in bytes or words
and there is a CPU which has a
well-defined deterministic behavior that
operates on this memory it's really that
simple
well the devil's in the practical
details but essentially when
CPU is turned on it will start at some
defined address this could be zero but
could also be defined to be something
else it requested memory content from
some Ram it looks at the value stored at
that address and performs the action
according to whatever that value
represents now when we want to execute a
program you can't just write your code
directly into RAM and restart the CPU at
address zero because if your program
would cause entrance to the whole system
would stop working but when you program
an Arduino a little microcontroller it's
basically what you do but that's why
some people develop something like the
Linux kernel which abstracts away the
direct Hardware for you and make sure
that if your program sucks you don't
kill the whole system that's why a
program is not just plain assembler code
but it's a fairly complex file format an
elf file which does contain your raw
code but also a lot of other information
and when you execute this program the
Linux system will actually open the elf
file read and interpret all the
necessary metadata and set at the
execution environment for you and then
jumps to the start of your actual code
so how does the execution environment
look like that's important to a picture
because in that environment you try to
explore the program you need to
understand it and in some way it's
actually very simple
again the devil's in the practical
details but it will make sense let's say
the CPU is just about to execute your
first instruction this means the kernel
and the hardware magic has already set
up everything and this is how it will
look like you have a big blob of memory
it ranges from zero to SMF so a huge
number but in reality you don't really
have that much memory that's why we call
it virtual memory it looks like you own
all this memory but how the magic only
makes you think you have it but in any
way the CPU now execute your program
which is somewhere in that huge memory
let's have a look at how this memory is
divided up in a real program so for
example here we see that from this
starting address to this end address
your program is mapped we say map
because it's not really physically at
this address
it's there if you would read the value
from the dead rest in your assembler
code so ignore the underlying physical
reality and just accept that there's
this huge range of memory you can work
with and in fact the stack is also just
here it's just defined as starting from
this address and ends at this address so
the stack is not really growing or
shrinking let's just see computer
theoretical model of a stack but how is
a stick actually defined well the CPU
has the stack register ESP and it would
contain an address pointing into this
area here so could you just point the
stack pointer somewhere else like into
your code yeah you absolutely could the
stack pointer is nothing really special
it's just a register that contains an
address and it could contain any address
what makes ESP actually special is just
that it does some fancy stuff based on
instructions so for example a pop
X instruction would look up what value
is stored at the location where ESP
points to usually that's a stack but
doesn't have to and then writes the
value from that location into the EAX
register and you can absolutely abuse
that in an export for example if you
find a bug that allows you to set the
stack pointer to a different value you
can create a fake stick on the heap and
just point ESP there oftentimes referred
to as a stick pivot so lose the mental
image of a stack that grows and shrinks
that you learned in computer science and
just think of what it really is it's
just a memory where the ESP register
points to and instructions cause
interesting effects based on that
register and in the same sense the
instruction pointer is not special
usually it points into your code but it
doesn't have to if you manage to control
a IP somehow you can just point it into
other memory for example the stick which
we have used in previous exploits
because he placed data that is actually
valid assembler code onto the stack you
know it as shellcode the CPU doesn't
care the EIP register points into some
memory in the cpu just happily does what
those where you say and well that's just
half true
because as you may know or motor system
Dec is not executable anymore so the CPU
does kind of care but it just means that
certain areas in this memory can have
different permissions certain areas have
the executable flag which means P CPU
allows EAP to point there is happy to
interpret the values as instructions but
other areas like to stick don't have it
and then the CPU will refuse to
interpret it as instructions now when we
look a bit closer to what kind of data
is included in all these different
memory areas we can try to come up with
creative ways how to abuse them one
example is the typical stack structure
when the CPU executes a call instruction
it places the current instruction point
of value at the edges where the stack
pointer points to some places is on top
of the stack if you will and when the
function returns it takes the value
where this deck 20 points to and sets
the instruction pointer to it so if you
somehow manage to modify this value on
the stick you can control what EAP will
be set to when the function returns and
that you can decide what will be
executed next it's a classical buffer
overflow another interesting data
structure is the global off the table
which is basically just an area and
memory containing pointers to functions
if you overwrite an entry there you can
also control what will be executed if a
function is called the reference an
address from this table
I mean oftentimes you cannot directly
overwrite this works but it just means
you have to become creative for example
think of two object on the heap a user
object in a name object and the user
object is appointed to the name object
when you want to change the name of this
user the code would follow this pointer
and write the name to that location
which means if you can somehow overwrite
that pointer you can control where it
would write the name tool so we could
override the name pointer with an
address on the stack and when we write
the new name for the user we will
actually override this stored
instruction pointer on the stack see
what I try to get it this memory that
contains data some restrictions apply
like certain memory areas are not
writable others are not executable and
there is a city where that is very dumb
and just execute whatever EAP points to
and there is a program in memory which
the CPU executes and this code uses the
memory to do whatever it's supposed to
do and it trusts in a certain integrity
of the data in memory but if there is a
bug that allows you to change a value in
memory which a program did not intend to
be modified amazing things could happen
and what can happen that's limited by
your creativity and imagination
one change spied here in memory might
cause a certain piece of code to write
an unintended location which overrides a
function point of an object which
another part of the code wanted to use
and suddenly executes something very
different and all these techniques we
assign names to like stick buffer
overflow keeping Shoei Rob use after
free are all just creative ways to screw
with data and memory and how the program
executed by the CPU reacts to it I
understand that this episode might not
have contained extra useful information
to you but I kind of wanted to get it
out there because maybe somebody didn't
quite picture programs and exploits in
this way but I hope you can see the
value in this way of thinking about it I
think it takes away some of the fear
that it is all too complicated I'm
really interested to hear your critical
opinion about this so comment here on
youtube or on reddit thread linked below
but never mind if you like this or not
we will continue soon our path to learn
about more advanced memory corruption
techniques so stay curious and see you
next time
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>