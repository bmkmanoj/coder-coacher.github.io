<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Heap: How to exploit a Heap Overflow - bin 0x15 | Coder Coacher - Coaching Coders</title><meta content="The Heap: How to exploit a Heap Overflow - bin 0x15 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Heap: How to exploit a Heap Overflow - bin 0x15</b></h2><h5 class="post__date">2016-09-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TfJrU95q1J4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in the last video we learned some basics
about how the heap works and now we want
to apply this to heap level one from
exploit exercises protostar to solve it
actually I want to try something we do
some role-playing
let's first be the security researcher
who wants to find a bug to exploit in
this binary afterwards we play developer
trying to understand the exploit to fix
the issue so we put on our black hoodie
and get started first we open the binary
heap 1 in gdb and execute it we get a
segfault and it also shows us that the
seg fault was caused by string copy
because it tried to copy a string from
the address 0 to this other address here
and 0 is obviously not valid memory so
it crashes
we know how Linux binaries work so we
make an educated guess that this
application might require some input and
we try the arguments run with aaaa again
another sick fold but the attentive
viewer will notice that the address is
no different so this is a different
string copy which again can't copy from
address 0 so we guess that it requires
another argument and this time the
program runs through without errors now
we try to find a bug so the simplest
thing to do is we just throw some long
inputs at the program and see something
happens so for the first argument I
choose to do a pattern with letters and
for the second argument I do numbers
just so I could identify them if
something would occur we run that and we
get a different seg fault again because
of string copy but this time the
destination address looks in Welland not
the source address it tried to copy the
string with the numbers which we know is
the second argument to the address 4 6 4
6 4 6 which is the hex code for ffff so
whatever happened we somehow overrode an
address that is used as the destination
of string copy and this means we can now
use the first argument to fully control
where we want to write and we can fully
choose what to write with this
second argument now we have a lot of
freedom what we can overwrite for
example we can own right the return
pointer on a stack to redirect code
execution or we can override an entry of
the global offset table which I
explained in a previous video to achieve
the same let's do the latter one it's
usually more reliable than the stick
which likes to move around all that so
let's check what kind of function is
called after the evil string copy we can
peek into the source code and see that
there is a printf and we could assume
that we want to override printf on the
global officer table but that is
deceiving that's not the case let's
better stick to the assembly first of
all we have to find the location from
where we were calling the string copy we
can use Dec trace for that which we'll
look at the stack and the story table
pointers to figure out where we are at
the side note if you found a back that
smashes the stack then the back trace
cannot make much sense of it anymore so
it doesn't always work and here we can
see that currently we are in string copy
but we were coming from this address so
let's set the disassembly flavor to same
Intel syntax and disassemble this
address this will not disassemble the
whole function this address belongs to
our address ended in 5a so we are here
after the string copy and as you can see
there is a call to puts next which is by
the way not printf like in the source
code that's because the compiler
replaced the printer with puts for
optimization reasons okay
so let's all write the global offset
table entry for puts as shown in the Geo
T video we can figure out the address of
puts by first disassembling the fashion
trampoline in the procedure linkage
table which would now jump to an address
stored at this address so this means
this is the address of the puts global
offset table entry so this is the target
we want to write to thus we place it in
the first argument GB run but we use
backticks in the first argument to
execute bin echo as you know echo simply
outputs whatever you pass through this
arguments and we can use that to get
characters with hex values we can type
for example the hex value 8 so echo - n
E - n because we don't want that echo
place a new line at the end of the
output and - II because we want echo to
convert hex escaped numbers into raw
characters just to make sure everything
works we echo the whole test string up
to the FS again now echo inside the back
ticks will execute and the output of
that will be placed inside of the quotes
as the first argument and when you run
this we get the same seg fault as before
so all is fine next step is obviously to
replace these FS with the address of the
puts global officer table entry
and we will now run it we get a second
fold somewhere else this time because of
30 30 30 30 which is a ski for zero zero
zero and when we look at the registers
with info registers we can see that we
successfully got control of a IP which
means we can now redirect code anywhere
we want in this case we want to call
winner-winner has this address here so
we place that into the second argument
instead of Ag we - but using echo and
backticks we execute it and we get
winner
which also works great outside of gdb
in summary we can say this we identify
the bug by guessing and playing around
with it through gdb we learned that
somewhere we can control the destination
of a string copy and we learned we even
control what we want to copy and we
abuse that to overwrite the function
address of puts to redirect code
execution to the winner function all
without knowing why this even happened
and not even knowing that the heap was
involved at all
being a good security researcher we
create a write-up and advisory for this
providing our proof-of-concept exploit
as well as some additional information
that might help the developer
now let's change sides and become the
developer we take off our black hoodie
and we put on our grey hoodie because
that's what developers wear so we just
got this email from the stood who found
a back in our program he even provided a
proof of concept explode with it now we
want to figure out why and how this
happened so we can fix it in the
advisory it says that it has to do
something with string copy so we read
the manual about string copy and have
this oh moment when we realize we
didn't even read the documentation that
will have told us what a bad idea that
was so now we could fix that for example
using string and copy or use a char line
to check the length before we copy it
and then exit but because we are a good
developer we try to learn from this
advisory and try to understand how the
exploit exactly works in the last video
the heat Malaga introduction video we
already thought about how the heat
should look like from this program so
let's see how it looks in reality to do
this let's set a breakpoint after each
Mello and string copy we disassemble
main and look for all those calls and
set breakpoints afterwards
then we run it with the proof-of-concept
exploit arguments and we hit the first
breakpoint so now the first melech
happened and the result of Melek is an
ax so ax contains the address on the
heap where we have enough space for the
internet struct I won and we can look at
this address and we can see it's simply
0 with info prop mappings we can see the
memory segments and there's also the
heap we can have a look at that
oh maybe it's a good idea to add this
heap output as a gdb hook as well so we
see it automatically at each breakpoint
so define hook stop x64 word and hex the
address end so if we now continue we
should set the priority of I 1 to 1 and
then my log for the name let's have a
closer look at the heap so as you learnt
the I 1 variable points here so this is
where the struct starts and you can see
the first attribute which is the
priority set to 1 and before that we
have the heap metadata the chunk header
which contains your length of this chunk
including the last bit set to 1 which
means that the previous block is not
free it's news and what we see is what
we expected we see here to allocate
chunks for 8 bytes
including the headers they are 16 bytes
another cool thing we can do is define a
variable I won and gdb and set it to the
address of this object and we can even
at the type of this viral with struck
Internet and now we can print this
variable I 1 and gdb can display us the
attributes priority and name and we can
see that priority is 1 and name is still
0 because we have allocated memory for
the name but not yet assigned to the I 1
attribute name if we continue to the
next breakpoint the address of the name
got assigned and the I 2 object got
allocated and the result of my log is
again in EAX nets the address of the I 2
object so we can also define the
variable I to and gdb and we print that
we can see that it's still empty now if
we continue the priority of I tool
should be set to 2
which you can verify by looking at the
heap memory as well when we print the I
to object and also all of our Maalox are
done now
and if we compare that what we expected
in the earlier video we can see that it
fits perfectly
there's only one thing we didn't talk
about yet and that's this big value
after all the chunks at the end well
this area down here is all free memory
and in exploitation terms this is often
referred to as the wilderness this
number is the remaining size of the heap
this whole thing is basically a huge
heap junk and that number is the length
and while ago I made a three part video
about the cookbook challenge from a CTF
and then exploit abuses this number to
redirect code execution it's super
awesome you should watch it anyway right
now the name of i1 is still empty string
but this is about to change with the
next breakpoint because we are about to
execute the first string copy which
copies this super long first argument
continue the first thing we notice is
here in the heap memory those ASCII
characters appear and it looks like they
have all written a lot of stuff on the
heap
what earlier was supposed to be the
chunk header metadata like the size is
now four four four four now let's have a
look at the objects I 1 and I 2 so I 1
looks fine
I want a still priority 1 in the name
with a string that was passed to it
how about I - ah that looks
priority is now a super huge number
in fact that's just four five four five
four five in decimal that's the East and
D address where the name is stored is
not pointing somewhere completely else
and now the next string copy will take I
to name which is pointing to some bad
memory and try to copy there the second
argument really freaking awesome so this
challenge showed one aspect of he
exploits it doesn't attack the Heep
algorithm itself it attacks the
application which uses objects on the
heap that we can modify because we have
all written stuff in those modified
objects then bent the execution flow
cool huh
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>