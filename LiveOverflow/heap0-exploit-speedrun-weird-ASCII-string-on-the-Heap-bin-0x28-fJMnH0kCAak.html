<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>heap0 exploit speedrun &amp; weird ASCII string on the Heap - bin 0x28 | Coder Coacher - Coaching Coders</title><meta content="heap0 exploit speedrun &amp; weird ASCII string on the Heap - bin 0x28 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>heap0 exploit speedrun &amp; weird ASCII string on the Heap - bin 0x28</b></h2><h5 class="post__date">2018-02-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fJMnH0kCAak" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this video we will cover heap level 0
from exploit exercises comp protostar
it's the heap exploitation introductory
challenge and is very easy we again
compile this on an ubuntu 16.04 LTS
version so basically a modern system to
see if or how it's still exploitable and
spoiler alert nothing changed for this
challenge it's super straightforward but
I have a special idea for this video and
even if it's a bit easy for you you
might want to check out what else we'll
learn at the end
in the previous videos of the series I
usually create the exploit and then
think of a way how to explain and show
it to you but this is so simple that I
thought it would be cool if I would
instead record myself solving it kind of
like a blind soul for a speedrun but I
didn't try to be super fast but it was
quite straightforward and I include all
the mistakes and pauses I made and now
we will step through the video and
explain to you what I have been thinking
in different moments and point out some
other things in the top right corner you
can also see a timer that will keep
track of how long it took me in real
time but before we start doing the
exploit let's have a look at the code
again there are two functions winner and
no winner and obviously we have to
somehow call winner we can also see
there are two structs that get space
allocated for them on the heap and this
FP construct here looks complex but you
can ignore that weirdness because when
you look in the code it's clear what it
does we said FP - winner notice how no
winner has no parentheses this means
it's not being called this is literally
the function pointer and adding
parentheses would cause a call and then
later we have those parentheses for FP
and if P has been set to point - no
winner
so no winner is executed and our goal is
to somehow use the string copy which
will overflow the name buffer which is
only 64 byte large and overwrite the
function pointer so sounds easy I start
by opening up the binary in gdb and do a
first test execution but I run into a
segfault which startled me for a few
seconds but then I realized I forgot the
argument parameter again the string copy
uses the first argument to copy into
name okay
now we had a clean execution now I want
to set a breakpoint so I disassembled
main and quickly scanning the assembler
code here mainly looking for the
different function calls to figure out
what corresponds to what in the C code
and at first I was thinking about
setting a breakpoint before or after the
string copy to catch the before and
after of
the overflow but in the last moment then
I figured that I probably don't need to
look at this at this closely and I can
simply go to the magic position right
away the call RDX this is calling the
function pointer that contains no winner
okay so I execute it again and we hit
the breakpoint now this challenge is
about a heap overflow so I first checked
the virtual memory map of the process
with vmm here you can see in which
memory regions we have the binary itself
with the code and data segments and we
can also see where the stack is and
where the shared library is like Lipsy
are loaded too and we also have the heap
here so obviously I want to check out
how the heap looks like examine 32
64-bit hex values from the start of the
heap
I immediately look for the name we
entered as an argument which was a AAA
so here they are
and I also immediately look for the
function pointer this looks like an
address quick sanity check with the
disassemble command here is a puts call
using this address as a parameter and
that is our no winner string so yep
that's no winner so now we want to write
that with winner so we need the address
here this next I need to figure out how
much we have to overflow to do that and
I simply look at the addresses to the
left address of the start of the name
ends in hex 1 0 in the function pointer
is at hex 6 0 so we have an offset of
hex 5 0 so now I'm feeling confident and
actually drop out of gdb and hope to
have a working exploit right away so I
start by writing a short Python inline
script to print the exploit string
essentially we need a couple of
characters as padding to reach the
function pointer and so I print a few
A's quick check again how many that was
hex 6 0 - hex 1 0 so we need hex 5 0
after that we need the address of winner
so 4 0
oops I almost made a mistake this still
happens to me some time we obviously
have to start with F 6 0 5 and then for
0 because of the Indian Asst now for
sanity and debugging step I piped the
output into heck
to see if it is what I expect but then I
notice a hex 0a at the end and that's a
new line Python print will add a new
line at the end which we don't want so
now I change the script to use the SIS
model instead in order to directly write
a string to STD out so we don't have a
new line and I verify that again with
hex dump
and then I'm basically done and I try it
on the target binary
so the input is passed as an argument so
you spec tix to execute the inner Python
command and the output is then basically
replaced by it and then placed here as
the arguments level past awesome I
executed the winner's function you see
this was super simple so when I was
writing the script with the commentary
of my recording I noticed a small detail
that I didn't think about and I actually
never thought about it before so here's
the he bought put again do you see this
data down here that is clearly ASCII and
that's weird now a program we did not
allocate any string like this on the
heap so how did this happen when you
look at this ASCII text then you will
realize it's in fact the printf output
but why is that on the heap let's
investigate first I thought we could
check out Bell grind well grind is an
instrumentation framework for building
dynamic analysis tools they are valgrind
tools that can automatically detect many
memory management and threading bugs and
profile your program in detail
I really should use valgrind more often
I use it wait a little
but there's for example the well-tried
output with tracing Malick's enabled and
then we run our heap zero level and we
can indeed see here our two meh locks of
the structs we do but also a malloc we
didn't do of 1024 that's also the only
memory that is freed again the Malick's
we do have no free so why is this
happening
another interesting output is estrus s
race
traces su scores and while we don't see
mail logs here because malloc is just
some algorithm and memory management
implemented in Lib C we can see the PR
cases call which gets the memory from
the operating system in the first place
so this is where we get the memory that
will then be used by Lipsy for the heap
so if Mel oak is a Lib C function we can
also check out L trace which traces link
dynamic library function calls but oddly
enough we only see two Mel ox for the
two structs nothing about the mysterious
third malloc it might not be immediately
obvious but this is actually already a
really good hint that the mysterious
malloc did know
happen from a dynamically linked library
call which means the smell up must have
been executed for example by Lipsy
itself and valgrind is a bit smarter and
also traces these internal Malik's for
the third test I create a simple program
that calls puts so it prints a string
because we know the heap did contain the
printf output so it must have to do
something with that and then we can
debug the program and set a breakpoint
on BRK remember be our case assist call
that is called when a program requests
additional virtual memory and so this is
called when the heap is set up and the
heap is not always set up only if it is
required so if we assume printf or puts
cause malloc it would have to set up the
heap first now that's also why I created
the small test program because the
original heaps 0 has obviously regular
Maalox before the printf which makes it
a bit annoying so this is a clean
example on a second note when you set a
breakpoint with a symbol name like BRK
there has to be the symbol name for it
and a syscall doesn't have a symbol name
a syscall isness assembler interrupt
instruction with a number as parameter
to indicate which syscall you want but
there is a BRK symbol but it's not
initially font you first have to execute
the program in order to load the dynamic
library Lipsy which does contain a bier
a case symbol and in fact that is a
regular function as a wrapper around the
BR cases call so anything inside of
Lipsy would not directly do this is call
interrupts it would call the internal
Bjerke function so that's why we can
easily set a breakpoint like this long
story short we can now continue and hit
the breakpoint and then examine the
function back trace which tells us which
functions have been caught that led to
this BRK call i cleaned it up a bit so
here we go you can see it starts with IO
puts you can also look at the Lipsy code
for that stuff I just pulled up some
mirror or flipsie on github and you can
read the code there the reason why the
function is not called puts but I
outputs
though we only use puts when we call it
has to do with a lot of C macros and
Lipsy I find it really difficult to read
that code for example we know the next
function has a symbol named IO new file
X s put n but that doesn't show up in
the C code but there is this
similarly called IO s put n which when
you look that up leads to a macro that
says it's actually io X s put n which
itself is another macro that is jumped
to with underscore under store excess
put and as a first argument and jump to
is obviously another macro and it just
keeps going like that feel free to do
that on your own but if we trust our
trace we can see that at some point it
calls to a log buffer and there's also a
comment saying allocate a buffer if
needed
so this 1,024 bite my log has to do with
the standard output buffer a printf
doesn't immediately resolved in a siscon
right
but Lipsy implements a lot of stuff like
this in order to achieve higher
performances by buffering output instead
of waiting for files or writing a few
bigger chunks instead of a lot of small
pieces yeah I would consider this a soft
mystery just a little excursion into the
inner workings of programs I hope you
liked it see you next week</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>