<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Analysis of CVE-2016-10190 - Exploiting FFmpeg ft. Paul Cher | Coder Coacher - Coaching Coders</title><meta content="Analysis of CVE-2016-10190 - Exploiting FFmpeg ft. Paul Cher - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Analysis of CVE-2016-10190 - Exploiting FFmpeg ft. Paul Cher</b></h2><h5 class="post__date">2017-11-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Lpt7WIqXOgM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome back let me quickly recap what
we learned from Paul last video we first
downloaded and compiled the vulnerable
ffmpeg version from github and used
address sanitizer to look at the first
crash example the crash was caused
because of a minus 1 as the HTTP chunk
size in the code we see that ffmpeg
simply reads this chunk size as a string
and converts it to an integer without
checking if it's negative and in the end
this negative size ends up su length in
a mem copy now that doesn't really help
us and just causes mem copy to write
data until it rides into bed and seg
faults however Paul already raised the
question at the end of last episode what
if we can somehow get into the else case
of this if because here maybe the
negative size can lead to an actual
exploitable condition and here it gets a
bit fuzzy what exactly happens at least
I'm not a hostel insurer and for Paul it
has also been a while since he looked
into it
so the screed function reads bytes into
a buffer at least as long there's data
available and so if the end of the
buffer is reach indicated by this
calculation if the pointer into the
buffer reaches the end then we get into
the other case and then we execute FF
URL read which calls retry transfer of
wrapper so I think this is basically
called when not all data has been
received yet by ffmpeg and it basically
retries to read more data and apparently
in that other condition you trigger then
he Bobo flow so this Oscar picture over
here this should give you an idea on how
we're going to avoid calling me and copy
with minus 1 as a size argument if there
is nothing to read the buff page here
will be equal to both N and so we will
fall through another branch in HTTP both
read function and so what Paul did to
not fall into the sec faulting mem copy
condition he delays sending the response
so that the following data is handled by
a different function because ffmpeg
consumes the data first and then reaches
the end andrey tries to read more so
this one ability has even a timing
component to it
you can't send the data all at once so
let's write out a response server bit
with all the things we know for now and
see how it all works out I will try to
add a sleep function after sending chunk
size 4/4 and back to copy the context
into the buffer fix the buffer here so
it will be equal to the buff and pointer
so on the next attempt to call HTTP both
read function we will fall through that
another branch to trigger the read
function trying to retrieve more data
let's set a breakpoint in the retry
function to see what kind of function is
called here so let's rerun ffmpeg
continue a bit now it is waiting for the
five-second sleep we have in the server
waiting to receive more data and boom we
get the crash and when we look back up
at the retry function we were calling
TCP read so that was called before we
were waiting for more data of the server
anticipate read is called also with
minus 1 as a size and TCP read is very
simple it simply calls receive so it
calls receive with the huge
number so you can read a huge amount of
data into a buffer that already looks
bad and I think Paul told me that this
is not quite where the exploitable heap
overflow happens because there's another
function that trusts this buffer and
copies from it into another buffer and
this is then where we overflow by
analyzing a lot of source code I was
able to reckon that the buffer was
allocated along with his context in the
Leibovich format aviable
that c file yeah clearly paul had to
read a lot to figure this out I was not
able to get it in a short time but you
see that all these functions operate on
this context and that's a structure that
just holds a lot of relevant data for
this data processing and apparently it's
allocated close to the buffer that is
holding that data will receive so the
buffer was allocated in this function so
here it is this is the buffer we write
into and here is our context is
allocated which means the context is
allocated after we have an allocated
buffer and if we get a bit lucky the
buffer might be before the context
structure so if we have indeed a heap
overflow we could maybe overwrite the
context structure so if we get lucky
enough they will be allocated on the
heap in the right order and we actually
will be overflowing the contact
structure itself let's look inside it so
here is a v-mail logs E is called and it
is actually a wrapper to the actual
malloc function let's look inside ivy a
context see what which members it has
let's check some other members of this
structure so we actually have some
function pointers over here so if we
overflow with pointers we will get
immediately the control of the air IP
register which is very nice so a
function pointer is just a variable that
contains an address of a function and if
you overwrite that value and the
function is called it will call our over
at nedra's so Paul figured out that
there is a heap overflow happening with
the other code path the buffer is 32
byte kilobytes big so we could just send
more than that and see what happens I
will be sending about 32 kilobytes of
data which will be exactly the size of
the buffer and a little bit more to
check if we manage to overflow the
context structure
let's launch our server in the black
background and launch the gdb to check
what happens so instead of the expected
reaction we have an uncertain aurora
over here let's scroll up a bit a little
bit
well that's open actually this file and
see why this one was triggered so this a
certain was actually triggered by
assuming that the length is more than
original length so we probably have
overflowed the a via context structure
but we didn't overflow the right fields
so maybe if we form it somehow in a
better way for example if we send news
first and then overflow the pointers
with some AIDS
then we will pass this a certain check
and hopefully we will get our IP control
so let's check it out let's launch gdb
once again and there it goes
we have control of our X and we're
currently on the instruction called
error X also we have control the first
argument and once you have control of
our IP and EDI registers it is only a
matter of time until you find proper
gadgets to get stable wrap chain and
achieve code execution
unfortunately this exploit is quite
unstable because of the property called
MTU which stands for memory transmission
unit it is made for optimizing data
transferring process from the network it
breaks latch pieces of data into the
small packets and because of that our
read function is not able to receive the
whole input which is more than 32 than
32 kilobytes in one take to trigger the
overflow you can actually get your exact
MTU value by typing if config command
for example I have 1500 so that means
that all packets will be splitted by
1500 byte and the explored will not work
remotely as it is this issue is solvable
in general case and you can practice
solving it all on your own there we have
it
POC exploit where we get control of the
instruction pointer awesome but Paul has
another vulnerability which we will look
at next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>