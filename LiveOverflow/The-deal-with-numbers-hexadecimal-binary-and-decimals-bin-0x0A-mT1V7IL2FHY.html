<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The deal with numbers: hexadecimal, binary and decimals - bin 0x0A | Coder Coacher - Coaching Coders</title><meta content="The deal with numbers: hexadecimal, binary and decimals - bin 0x0A - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The deal with numbers: hexadecimal, binary and decimals - bin 0x0A</b></h2><h5 class="post__date">2016-01-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mT1V7IL2FHY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is the tenth episode and as you can
see in the title I'm counting the
episodes in hexadecimal I'm wondering if
the Google algorithm will screw this up
within the next suggested video anyway I
want to explain in this video why
hexadecimal is cool and why you should
use it when it comes to computers I will
also show you how I convert values back
and forth and how I often work with them
okay so all computers work in binary
zeros and ones because it is a
representation of the physical behavior
of our circuits that we have transistors
that are like switches and they are
either turned on or off
a single value that is either 0 or 1 is
called a bit you may know that a byte is
8 bit but maybe you won't know why that
is well this wasn't always the case all
the computers might have had six bits
provide that we use 8 bits for a byte
notice is just how history turned out it
was IBM's fault with the system/360 that
heavily pushed for an 8-bit byte
although some people say that octet
instead of byte to make clear that they
mean 8-bit an interesting example is
ASCII because you will notice that it
actually only uses 7 bit but because we
now generally use 8-bit bytes we can
always the first bit we humans grew up
with the decimal system we are used to
counting with symbols from 0 to 9 but
that is rather arbitrary sure we have 10
fingers but we could also count in 12
because we have 12 finger bones and we
can use the thumb to point which number
we are at this is the duo decimal system
and we actually use it on our clock so
if you would have grown up with counting
and hexa binary it would feel as natural
to you instead of thinking of numbers as
something fixed think of it as a tool
and you can use whichever number system
makes sense
for a particular problem so our
computers work with bits and for our
modern computers we have defined that we
generally work with bytes of 8 bits and
16-bit 32-bit or 64-bit architectures
are just playing with the value to keep
it nicely dividable by 8 when we look at
the data
as raw bits zero zero zero zero zero
zero we quickly see that a bite takes a
lot of space if we display it in that
way maybe decimal would be a cool
representation it certainly would take
less space to display them I will use
pies now to show you how we can convert
binary to decimal numbers we simply say
that the string represents a number in
base two let's do it for a couple of
examples with a simple for loop
okay well takes less space though it
kind of bothers me that the biggest
value with a bit is a weird number in
decimal a number without any interesting
properties or meanings let's have a look
at those numbers in hex hex numbers are
symbols from 0 to 9 and a to F to
describe a number we can extend our loop
and tighten
now you can see how pretty hexadecimal
numbers are to represent eight bits the
biggest 8-bit value is also the biggest
value in hex that can be represented by
two digits if you would add one more bit
so we have nine bits we would also have
to add another digit and not only that
if you look closely it also nicely
represents the two individual nibbles
that means the four bits so an eight bit
number in hex can be represented by two
symbols and each symbol refers to one
nibble so this makes it very very clear
and easy to read and now you can
understand why the decimal
representation is not very fitting for
this kind of stuff for example can you
tell me what is the maximum number that
an unsigned 32-bit integer can represent
well I don't know in decimal I just know
that 32-bit is four times 8-bit and thus
max and is ffff ffff now let me quickly
show you some cool tricks with Python to
convert stuff back and forth pet nets
are built-in function to convert numbers
so for example hex and bin and also to
parse a binary or hex number with the in
function and specifying which base it is
if you have a binary string this means
that maybe not every value in the string
is a nice sk printable character you can
use encode and decode on the string to
get the hex representation of the
characters so hex for one is capital a
and asking a much more powerful and
important functionality is offered by
python structs which I use all the time
when I deal with binary data first
import struct and then we can use struck
unpicked on our data in this case I
define that the data is an unsigned
integer you can see I can convert this
binary data now to an integer number if
you look closely you may wonder why the
capital A seems to be at the end of the
number the reason for that is that we
have a little onion system bits can be
interpreted in two ways either the first
or the last bit can refer to the least
significant bit I think
the picture on the Kapadia makes this
very clear this can be very important
when you receive data from a big-endian
system because then you have to be
careful how are you interpret this data
but with python structs it's easy and we
can define as which engine system we
want to interpret this data if you watch
some of my CTF exploitation challenge
videos you will see me using Python
structs a lot because it's great to
convert addresses and other data back
and forth for example if I we want to
overwrite an address we have to supply
the data as a string so we can use
struct Peck and pick a number as a
binary string so the hexadecimal system
makes working with computers much more
simple and you should get used to it but
we just talked about positive numbers
from 0 to FF but how can we represent
negative numbers maybe you have heard of
the signed bit that the first bit tells
you if this is a negative number or not
no it's not as simple as reading the
remaining 7 bit and deciding if it's
positive or negative based on the first
one minus one is actually FF well does
have the first bit set but it's not
minus 127 this will maybe makes it a bit
more clear how the negative numbers are
actually interpreted to convert a number
to its negative value you simply invert
the bits and add one it's called the
two's complement and the system has the
advantage that fundamental arithmetic
operations like editions of structure
and multiplication are identical to
those for unsigned binary numbers you
should read the Wikipedia article about
it that should make it clear many
functions return minus one on arrow at
first it sounds weird but now you know
that this is just all FS and when you
read data and you get only once or FS in
hex you might read an error
what about numbers with fractions well
don't get me started on that it gets
really ugly but you can guess that
representing a value with many digits
behind the comma can get very creative
if you have only ones and zeros now
before we end let's get a summary of the
terminology we start with a bit 0 or 1 4
bits are nibble eight bits are a byte
hexadecimal we can represent a byte with
two digits on 32-bit architectures a
word refers to 32-bit or four bytes but
on 64-bit architecture a word is 64 bit
or 8 bytes and a double word is
obviously the double amount of that as
you can see a computer only has bits and
how we deal with those bits is up to our
interpretation I know this was a bit
shorter in last technical video but I
thought it fits and next time we will
dive deep and exploit our first buffer
over</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>