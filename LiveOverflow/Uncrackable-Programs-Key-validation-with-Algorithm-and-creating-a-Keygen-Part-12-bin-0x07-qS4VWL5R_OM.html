<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Uncrackable Programs? Key validation with Algorithm and creating a Keygen - Part 1/2 - bin 0x07 | Coder Coacher - Coaching Coders</title><meta content="Uncrackable Programs? Key validation with Algorithm and creating a Keygen - Part 1/2 - bin 0x07 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LiveOverflow/">LiveOverflow</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Uncrackable Programs? Key validation with Algorithm and creating a Keygen - Part 1/2 - bin 0x07</b></h2><h5 class="post__date">2016-01-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qS4VWL5R_OM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's say you work for a company and
your manager is mad that there are
pirated versions of your product out
there he tells you to secure their
intellectual property and make the
program uncrackable is that even
possible last video I climbed that every
program is correctable but that was old
me maybe I learned more in the meantime
so let's try it out first problem is
that the license key was inside the
binary the simple technique we had was
to extract all strings and we found the
key our first attempt to make it secure
would be not to F the key inside we can
do this by writing an algorithm that
scrambles the key you can come up with
very creative ideas and then you can
give the secure binary to your friend
and ask them to crack it alright a
keygen that can be really fun the first
idea I have is to simply sum up the
ascii values of the key and compare it
to a magic value so let's modify the
original program
first we have to define a new integer
value that will store our calculated
some so in sum and set it to zero then
we will add a for loop with the counter
variable I which starts at zero with the
loop condition that it continues to
repeat this loop as long as I is smaller
than the string length of the key that
we can supply with arc v1 and in each
repetition we will increment I by one
now we want to sum up the value of each
character so sum plus equal are we 1 and
then the index I as you know a computer
understands only numbers so each
character as you know from the ASCII
table is a number but the compiler knows
that our cui is defined as a character
sequence so to not get any complaints we
cast this value to an integer like that
now we want to find out what the sum of
our original key is so let's add a print
F with percentage T in the format string
and the sum as the parameter now we can
compile it
and executed with the original key
so here is the sum of all character
values for this key let's go through the
code again and change the key check
remove the string compare and replace it
with the check that the sum has to be
that number remove the debug print def
and try it so here it says that it's a
rum key and here it says that it is a
correct key now try strings and you will
not find this key anymore but how can we
correct this now let's open it with
radar to analyze all seek to the main
function and print the disassembly so
let's look for the success or fail
message here it is and then we can check
where the branches are coming from to
find the check if the license was
correct or not okay so this compare and
jump decides if you print X is granted
or if we follow it wrong you can also
see this hex value that is used for the
compare I like to use Python to convert
between hex and decimals so that's
exactly what we have in our C code so
open the file again in debug mode and
add a wrong license key if you start the
program
it says it's wrong great now let's set a
breakpoint with dB at this one compare
and reopen the file and debug mode now
DC to continue now we hit the breakpoint
with dr you can see that our IP is at
the jump with d our our IP equals to we
can set the our IP address we want to
execute next and obviously we want to
print a success so we have corrected
again okay so we have found our dead if
you can find this one compare where it
decides if you have a valid license or
not you can simply bypass it but we are
hackers we love challenges and patching
a jump is just boring so let's write a
keygen so first we have to reverse the
algorithm I will open the source code
next to it so we can compare a little
bit I seek to the main function and
enter visual mode okay so we already
know a little bit about this program
from the other video so here we can see
the compare or free supply the license
key then comes the printf like an our C
code
after this printf we said sum to zero
and also the for loop is initialized
with the index counter I to zero and you
can see that in the assembler code to
the left two addresses are set to zero
with a move and the address is
calculated with the base pointer address
that's just another fancy register and
then the first variable is at offset -
hex 18 and the other one well right now
replace the number with the name and
calls it local - for variable but behind
this name is just another number
now when we look closely we find the
branch it loops back up so those blocks
here are our for loop and at the end of
the for loop is an add instruction that
adds one to this local variable that was
set to zero earlier so that is the
increment of I and this local variable
that radare
identified is I we can rename this
variable with a FV n the previous name
locally to four and I in this block we
have a string line call and afterwards
we compare two registers and it either
continues with this main block or it
leaves so this is the follow condition
here
now comes an ugly part if you have never
seen this before but if you practiced it
it's easy to see don't worry if you get
lost for the next minute let's just
require some practice so first it loads
a value from an address where it's red
re assigned to name to this name came up
before near the string Glen and if you
compare these two assembler blocks they
are a bit similar you can see that it
adds a to the loaded value so usually
that means the value that was loaded is
an address because we have 64 bit and we
often divide memory and 8 byte chunks
imagine an array in memory it might use
multiple 8 byte chunks the first chunk
which is the first value in the area is
simply there where the address points
tool this means that if you want to get
a second value in the array you have to
add 8 to the address now it points to
the second error entry so this arc v1
remember we start counting at 0 so our Q
0 would be the first array entry arc V
is basically a variable that contains
the address with points to an array in
memory and this address is loaded into
our ax and then we add a to it to move
it to the second entry in that area now
the second entry is another advert which
points to a string in our sample code we
can see that the address of the string
is loaded from the location ri X is
pointing to remember that the brackets
around the register means that the
register contains an address and we
access the value that is stored at this
address
ok so already X down here now has the
address where our string begins now we
know that the next line loads the index
counter I into EAX each SK character is
1 by big so similar how we can move an
address to point to the next array entry
by adding 8 we can move the string point
to the next character by adding 1 so
when we take the counter I which might
for example have we value 3 and add it
to the address that points to the start
of the string it will then point to the
third character now next we
one bite from the current address in our
ix this is the value of this particular
character and we add this value in year
X to a local variable at offset - hex 18
which we earlier set to 0 so this is our
sum well I know it seems tedious and
confusing and a bit crazy but if you do
this a couple of times and also debug
this step-by-step with gdb and look at
your registers in each step and inspect
the memory addresses it becomes clear so
now we know that this is a loop and that
goes over each character of the string
and adds the character value to a
variable now when the string line
compare branch goes the other way we
leave the loop and the sum is compared
to hex 394 cool if your brain turned off
during the previous part turn it on
again let's do this again but this time
you can ignore most of the stuff and
work backwards with educated guesses so
you see that this address gets compared
with a certain value so look where this
value came from ah so it has to do
something with this add now you can
reload this binary in debug mode with
ood I will use ABCD as an example key
press P to display the addresses and
place a breakpoint here then use the
exclamation mark to switch to a more
fancier mode and then execute it now
always continue with : DZ and look at
the register ri X that gets added so in
the first loop is hex for one if you
know your ASCII table you know that this
is a capital A you can also use python
as a handy tool to convert back and
forth and next time it's hex for 2 that
is a capital b and then it's hex 43 so
clearly it just iterates over the
supplied string C now you know what
happens without having to read assembler
line-by-line
let's recreate this in Python let's
write a function called check key it
takes a key as a parameter now we define
a character sum and set it to zero then
we loop over all characters with for C
and key and then
we add the SQ value to the sum with ORD
of C then we print the current key and
its sum and we return the sum now let's
do some example keys with YY you can
copy a line and with P you can paste it
again
I deliberately use ABCD because there
are numerical values always increases by
one cool you can see how the sum is
always one bigger than the previous one
now let's use a very naive randomized
keygen to try two different keys until
we find one this can be obviously made
much more intelligently because of the
linear behavior of this function but it
will still look cool so import Brandon
module and create an endless loop our
key starts with an empty string then we
select a random character from an
alphabet with random choice and append
it to the key now we check this key
if this key sum is already too big we
reset the key and start fresh and if we
hit the correct value we print that key
I will modify the print and check key
function to make it a bit more cooler
now save it and run oops something is
wrong I hate to compare the wrong way we
obviously have to reset the key when
it's already too big okay
now damn that's fast even though it's
very bad algorithm we quickly find many
many keys let's see if they work oh yes
they work that's cool huh
so we have learned now that we can hide
licensed keys by using an algorithm to
verify if a key is valid this whole
algorithm becomes useless when we find
the assembler code that decides if it
was valid or not in our case it's a
simple compare jump that we can patch
obviously you can make that a bit more
complex for example doing a license
check in different places but generally
this is how you can defeat it
now if we like a challenge or we don't
want to patch a binary because whatever
there are many reasons why you might
want to valid key we can use static
analysis and reverse engineer the
license check out ger ISM and write a
key again to generate valid keys
obviously this algorithm also can become
very complex but generally if you put a
lot of work in it you can figure it out
now you tell that your manager but he's
the smartest and tells you then you
should stop people from being able to
reverse-engineer the binary then you
direct yourself back to the disk and you
come up with a new creative way how to
stop somebody from debugging and
reversing it
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>