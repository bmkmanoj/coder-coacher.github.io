<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Long Road to Async/Await in JavaScript | Coder Coacher - Coaching Coders</title><meta content="The Long Road to Async/Await in JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Long Road to Async/Await in JavaScript</b></h2><h5 class="post__date">2018-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IZIcWl-jq_0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Thomas honor of course the
stock is the long road to a sinking
weight in JavaScript if you here for the
quick and easy path to sink in a weight
that one's next month throughout the
stock I'm going to talk about the SI
called the evolution of asynchronous
control flow as it exists in JavaScript
so we sort of have these four phases
that we can consider so the first phase
is callbacks I raise your hand if you
use if you have used callbacks come on
there's a few of you in the back you've
we've all used callbacks this is not--
all right so everybody uses callbacks
raise your hand if you've used promises
face to cool awesome a little less but
definitely people are using it raise
your hand if you use generators Oh sad
trombone
everybody out raise your hand if you
confidently understand them yeah so yeah
really not money and then a sinking away
is face four or raise your hand if you
use that cool where's your hand of use
the what the rest yeah you know you used
to anybody using observables not even
you go on cool but another question
Monday is singing away who uses it in
production cool cool this is the fun
companies to work for I'm sure sure
they're all hiring cool alright so
actually actually I fooled you we're
actually gonna look at phase zero first
and so this is a synchronous cones of
course not any synchronous you're
probably wondering why I'm talking about
it but hopefully you will soon
understand why so of course synchronous
code exists in a single strap and a
single stack in JavaScript the code that
we have here represents in my humble
opinion the simplest and perhaps most
elegant way to execute functions get the
return values you know pass data in get
data out and then you know execute an
application certainly there's people
that don't agree with that but you know
this code is pretty terse and so this
will actually be the shortest code
example we will look at in this
presentation so it's one of the the
different faces I'm going to show you is
basically going to follow the same
pattern cool all right let's step
through this code that's pretty simple
so what we want to do is we want to
execute this function called send
message and so send message accepts two
arguments the first is the user ID that
we want to send a message to and the
second is the message that we want to
send to that user and so once we send
the message we want to find the result
of the operation did the message send
was it successful or not
louder Oh perfect there we go
cool did I oh it's got this really help
oh it's red it's reading it on oh wow
sorry about that
cool all right so within this function
once we get the user ID and the message
we are going to pass the user already
into this get user function we're going
to receive information about the user
out of it so this represents you know a
more complete user object we then passed
the user object into the can send method
it'll determine whether or not we can
send message to that user and then it'll
send a message back or it'll send back
the variable able so able is simply a
true/false value if we're not able to
send a message we're going to return
from the function we're gonna return to
false you know no message was sent
otherwise we're gonna call the send
message or the sorry the right message
function so that's gonna actually write
the message passing in the user the
complete user object in the original
message variable and then we're going to
return the result of that operation and
so the right message function is going
to tell us if the message was sent
successfully or not so this code this
all eggs executes and a single stack
that's what that means is that if any
one of these functions were to you know
stop your application from running I
would mean the entire application would
stop running
and so in a browser you know that's
pretty bad you get some jittery scroll
button node you know it's killer it
means your entire server is no longer
not able to serve other requests cool
and then error handling of course with
this pattern we have the try caches and
so what you do is you you wrap your call
to send message in a try and then you
catch an error if they occur so in this
case we're gonna you know try to call
the send message function however inside
a send message we're going to throw an
error instead of actually doing any work
and so that'll get caught in our catch
and then we're gonna print the error
message to standard error otherwise if
it were to succeed it would have called
the console log below cool all right now
that's out of the way let's look at
callbacks so here you have callbacks
fortunate with my fonts normally works
but you know it's Linux the kernel
updated and now the emojis are black and
white so if you look closely you can see
that and this laser isn't working if you
look here you can see these little clock
icons and so normally that would be you
know like a syntax here and JavaScript
OOP
Wow I just went all the way to the end
I'm sorry did you say something like
there all right so within the code every
time you seem in these little clock
icons what it means is this is point in
the application where we're done doing
work in the current stack and we're able
to process other work within our
application or to represent places
within the code we'll come back into the
execution so it's like a symbol that
shows you how you come in and out of the
code that is executing all right so cool
with this callback pattern of course
this looked pretty familiar to us node
engineers in this case the syntax has
changed a little bit so this time when
we call our send message function we're
still passing in the user the username
and the message however we have this
third argument now and that is our
callback callback and so the callback of
course this is pattern I think it's
called the air back so the first
argument is an error and the second
argument is what would normally be the
return value it is the the result of the
operation and so we we actually passed
this function
it is kept for a while and then once
it's finally needed that the function is
executed I'm blinking what's naming this
pattern his name for the continuation
pattern cool alright so within our send
message function again we see the
callback is the third argument and so
what we're doing within our send message
function is we're gonna execute this
call to get user we're gonna pass in
user ID and this callback and then so
the get user function perhaps it's you
know talking to a database it's gonna
send some message over the network once
that's done this function is just gonna
it's gonna stop it's gonna not continue
doing work other functions within the
application are going to be able to call
for example the request handlers coming
in to express their gonna build a fire
and do their own thing however once the
database operation is complete its then
gonna call our callback and our code
will continue and so that's you know the
clock is where we continue it's in this
case we take the user object we then
pass it into sent can stand along with
another callback once that's done we get
the able variable if we're not able to
send the message we're gonna execute the
callback where the first circuit is an
error in this case there's no there's
technically no error it's just that
we're not able to send a message and
then the second argument is the result
of the operation which is the false and
then we're going to return otherwise
we're gonna continue on we're going to
call our send message function passing
the user message like before as well as
the callback as the third argument and
so this is the pattern we all sort of
know and love in node however one thing
to keep in mind with this pattern is
that where any time we call a function
and we pass in a a callback we're sort
of we're just throwing away the return
value so we think of a function in
JavaScript as having sort of two
important details one being arguments
being fed into it and the second being
the return value
you know I guess sort of the syntax that
the language gives us we're now only
using I suppose half the features right
so kind of maybe it feels a little dirty
it's like you know we're not you
and everything we could be using here so
the syntax for the Suns of being a bit
heavier you know certainly there's a lot
more you know characters going on here
than there was in our previous example
and then with error handling we don't
throw errors you never want to throw an
error in one of these functions which
expects a callback you know you're gonna
confuse the calling environment you know
engineers aren't expecting to call a
function and then I have to wrap it in a
try-catch so you never wanna throw an
error within a callback within this
callback pattern so what you want to do
with these errors is when you do
encounter an error you want to call that
callback that was passed in now where
the first argument is an error value so
in this case you can see that we're
calling send message we're passing in
our variables or passing in our callback
and now unlike before where we just drop
the errors on the floor this time were
actually gonna check them and then do
something with them once they occur and
then within our send message you can see
that we want to simulate an error and so
we're executing this function we're
passing the error object to callback one
thing I'm doing here those I'm actually
wrapping that call
I'm not immediately executing callback
in the current stack instead I'm
wrapping it in a set immediate if you
were to call that callback immediately
the the calling environment is going to
see things occur out of order so for
example if after the send message line
let's see so if we look at like right
here if the if if you had a line here
that said like you know print a message
to the screen if you were to execute
this callback immediately within this
function you would see the the result of
this operation occur like you would see
this console error would occur before
the log message down here occurs so you
want to add the set timeout to ensure
that the callbacks are executed in a
different stack this is lovingly
referred to as introducing Zell go into
your API by the node community cool has
anybody ever been bitten by Zell go as
this she ever happens okay a few people
we've caused it right cool
all right and so with error propagation
you know as we
these errors every time we have an error
well we want to be able to handle it so
in this case for example within our get
user if an error happened we we fail the
callback within the get or the can send
methods method if there's an error we
call the callback so this is a pretty
pretty common pattern this is about the
simplest way you can handle errors of
course you could have more complex
errors depending on your failure cases
maybe a failure isn't too bad at some
point yeah this is the simplest way to
do error handling all right say it face
two we have something called promises so
each from these phases essentially
happens at a future point in time than
one before it's not that necessarily any
phase is better or worse than any face
before it in every single phase as their
as their pros and cons however they're
just introduced later in time so for
example promises these were introduced
in es2015 so promises they represent
they do not represent a new syntax in
the language they instead represent a a
cool state machine for executing
callbacks essentially and so you don't
actually need the language itself you
don't need Java Script to support these
promises you could actually use a
polyfill for example Bluebird who's used
Bluebird cool bunch of us sweet
alright so promises the code looks like
this again so in this case we are using
return values so the thing with promises
is that a promise function actually
returns an object and this object that
it returns is a promise and so we do use
the return values however you know we
still use these callbacks I suppose we
don't necessarily call call them
callbacks in this case this this
function that were passing in where we
we handle the result you know it's not
maybe technically a callback because it
doesn't use the you know their first
notation but certainly it's a function
which will execute in the future and so
the syntax for this doesn't look
necessarily too different
from the callback pattern we've used
before us in this case what we're gonna
do is we're gonna execute the send
message function we're gonna pass in the
user ID and the message immediately
within the send message function we're
going to return a call to send user and
so that send user function is itself a
function which returns the promises us I
had mentioned so again maybe that send
user message or function is you know
communicating with a database to get the
data that we need
however it's not until once we call the
the the get user method we do some
method chaining on it that's why we're
able to do the dot then and then so we
we tell this promise that hey you know
once you're done call this function here
and then so we're able to serve requests
and do whatever within our application
and shortly in the future hopefully you
know a few milliseconds later our
execute our function executes and we're
able to continue and so you know we get
the we get the user object that way we
pass it to can send can send is another
function which returns a promise
so can send goes to the database of the
user once that operation is complete we
call the dot then that follows it and
then we pass in this function so in the
future once that code has been executed
our functions then called we get this
able value and then from within this
promise here we return a false value
so of course false is in the promise
it's just a simple boolean variable and
so what that means is the the entire
promise here when resolving into that
promise I'm sorry the entire promise
here will end up resolving into the
false value and so what it means is when
the promise resolves is that you know
whatever that dot then up there that
function is actually gonna finally fire
and then the result variable is gonna be
that false variable that false value
that we returned from a promise however
if we are able to send the message we're
going to return on another call to the
right message we're passing the user
message as you can probably guess that
itself as a promise which will resolve
into the true false value of whether or
not the message was successfully sent
and so we're with the phase zero the
synchronous code sort of the
pattern we get is that you have this
flatline you know on the left side of
the code you see your codes going it's
pretty straight when you have nested
callbacks you're getting into the Flying
V of death
the Pyramid of doom that's what it is
into the pyramid of Doom situation so
that's why everybody loves prop with
loves promises that it fixes the pyramid
of doom but then you get what I like to
call the zigzag of maybe not so much
doom but certainly you get this exact
pattern so you know as you get a lot of
promises going on you're just doing a
lot of these exacts I'm not a not a big
fan of myself but you know a lot of
people do like it so each time within
one of these promises you call a dot
then and you return another promise we
can refer to that as building a promise
chain and so you know over time you can
have you know several different promises
within your promise chain or actually on
a previous employer we had an infinite
loop and a promise chain that was pretty
pretty fun we'd have a memory leak that
would take months but you'd slowly
increase maybe hundreds of megabytes
over that time span very very subtle it
was like it's long polling code really
need any problem anyway so
however we of course have to look at the
bad situations and so with promises you
know we don't call them throwing we
don't call them exceptions we call them
rejections and so well so in this case
what we do is within a promise we can
return a rejected promise in this case
our set message function this can return
turn promise not reject and then what we
do is we pass the reason for the
rejection in there in this case we're
going to pass this error object however
so once our send message calls is called
we also do this dot then to chain the
result of that operation however in this
case our then is not going to call
instead the catch operation is going to
call and then so our catch is going to
have the result of that error
cool all right phase three generators
and yield this is a new syntax this is
uh introducing es2015
you can transpile to it for example
babble anybody transpiling with babble
right now few people is what pack is
that the new thing or people doing this
stuff with what pack now okay so is
anybody even this with what pack then
okay alright I guess I'm kind of behind
the times I'm sorry yeah so you can you
can transpile and cannot be polyfilled
so was first introduced in iOS version
1.0 cool alright so this is the syntax
this is the this is really the ugliest
generator you can get and so you know I
kind of made it look ugly on purpose
just to sort of step through it and show
you how it works
so don't don't be too afraid I'm gonna
show you an easier example in a moment
alright so the sun message function
below is our generator that asterisk is
the syntax we use to denote that it is a
generator so the cool thing about these
generator functions is they're able to
halt halfway through and then you're
able to do stuff you know elsewhere
within the application and then return
to the generator from once you exited it
so in this case the first thing we do is
we execute send message we're passing
our arguments and then the result of
that function being executed is our
generator and so what we're gonna do is
are going to take generator we're gonna
call next let's see I get a little bit
confused I'm not sure if we've executed
the first line of code yet or not but at
any point at any rate we're gonna go
into our send message function we're
gonna take the arguments that are passed
into it we're gonna take user ID we're
gonna pass it to get user and then we're
gonna yield the result of that operation
so normally generators I suppose they
were built with the intent of perhaps
forever generating a list of numbers so
like the hello world of generators is
to yield a never incrementing number for
example you know you call your generator
you get a one you call it again you get
it to so with a new generator you could
have like a four loop we're in this case
we're sort of hijacking these generators
and were using them for control flow so
in this case our get user function is
actually returning a promise again and
then we're gonna yield the result of
that promise so what we do is we yield
the result of that promise and you see
the little clock which means we're able
to you know do other work in the
application this yielded value is the
promise value itself is what's returned
from the generator so when we call
generator next that's going to be it's
going to return us the value and I think
some metadata about the generator from
it so we're able to call this dot value
and so dot value is the value which was
yielded from the generator in this case
our get usually promised we then call
dot then on that promise where we pass
in this function to execute in the
future so once our database call is
complete or whatever our function will
end up calling so from there we take the
user object we then call the generator
and again we call generator next and we
pass the value back in so the user value
which is passed back in is now the
return from that yield and it is now
assigned to the user variable so we then
go to the next line we take the user we
pass it in the can send you know it's
going to do its database thing it's a
promise we're going to yield that
variable we're gonna take that yielded
promise we're gonna call that and we're
gonna pass in this object and you sort
of get the picture and so what we're
doing is we're we're yielding these
promises from our generator we're
waiting for them to resolve once the
promise is complete we take the data
when we pass it back into the generator
so feels kind of weird you taking data
outputting data and taking data output
nits in weather for example instead of
putting the the user back into the
generator once my promise was yielded
what if I instead put the number seven
back in you know if it seems kind of
weird but you certainly you could do it
so that yield get user or do return at
seven I mean it just feels kind of weird
and so this syntax here is very powerful
very verbose
and just just a total nightmare so for
example can you imagine like within your
set not that this is bad about
generators in general just my particular
implementation so for example you could
imagine adding one or two or three more
yield statements within your sent
message and then so in this case we
would actually need one or two or three
more nested levels in our calling
environment so this just requires very
intimate knowledge about the insides of
our function from within this situation
in which we call it so those are ears
again just the the most horrible way to
represent this luckily for us there's a
nice way to represent this since since
the pattern are doing is pretty simple
take a variable out wait for it to wait
for the promise to give us the value and
then put it back in of course that could
be automated and so we can use a library
for example Co is a library that can do
this for us Co I believe stands for Co
routine and so what you can do is with
you you wrap a generator function in
this Co call that Co call ends up
returning a promise and then everything
within that generator Co is basically
gonna keep getting these these uh these
promises sticking it back into the
generator if it ever gets a promise that
is rejected it's then going to return a
promise that rejects so it's pretty nice
tool to make this working with
generators and promises much easier so
in this case you can see at the top of
the screen our send message call we're
passing the user ID and the message and
then call our then with our function to
execute in the future that's it the
exact same code that we had with the
promises so the only thing that has
changed in this case is that our
generator function is now wrapped in
this code routine so in this case Co has
introduced a new function scope but
otherwise isn't too too dissimilar from
the from the phase zero the synchronous
code that we looked at before so we're
getting closer to our sort of ideal
ah syntax oh yeah that I mentioned
rejection let's actually look at the
rejection so if within our Co call or
we're recalling this wrapping this
generator if wielded promise which is
rejected then we will catch that within
our original promise call
so our send message or then is not
called what our catch is cool all right
this is the part you've all been waiting
for
I hope unless you're excited about
generators so this is uh async functions
which use the st. keyword in the await
keyword again this is a new syntax
you can't transpile you can polyfill it
is introduced in ES 2017 pretty pretty
new stuff so this is the syntax for that
one thing you you're probably
immediately noticing is that that's a
little bit ugly immediately invoked
function execution if he if he I don't
know how to pronounce it anyway it's
when you wrap a function in a
parenthesis and you you follow with the
parentheses parentheses and that's what
it immediately execute that function
used to be an old hack you could do to
you know get gets Coppage and you know
back when we didn't have constant what
over in this case we're able to use it
with an async function and wrap our code
in this async yeah if you wanted to be
able to do in a wait it needs to be with
an async function and so that's the
reason we need this this function
wrapping it so for example if you wanted
to take this code and paste it into your
repple at home you know either the the
node repple or even even like a chrome
rebel if you were to using a wait at the
top level you would get a syntax error
and so you would need to wrap it in this
this a sinkhole so that's a little bit
of an ugly part but as far as an actual
application goes it's not a big deal
because perhaps if you wanted to have
like an express request handling for
example be an async function
you're already plugged and giving it a
function to call when a request executes
and so that function is the function
that you would then give the async
keyword to so so this this async if he
only really matters with revell type
all right so now that that's all the way
on let's actually look at the code so we
have this send message function same
arguments as we're used to however this
time it's preceded with the async
keyword within our function we have
these a weight keywords which are you
know pretty similar looking to the
yields that we looked at generators when
we call the code so within our async
function we want to get the result so
you know we say let result equals and
then we await the execution of that
function and so what that means is you
know we're gonna call send message we're
gonna pass in the arguments we're gonna
receive those arguments we're then going
to call this get user method which is
also an async function and we're gonna
await the results and so at this point
in time the our code is basically done
we're able to serve you know requests
elsewhere in the application once that's
complete we're then able to continue
where we left off so we get the value
from get user of course we sign it to
our user variable we then pass user and
a can't send and then we're able to wait
again and then so so we go through this
operation if we ever return a non async
function from with an async function
that is what the async function is going
to return so in this case when we return
are false false will be the result of
the design to the result variable and
then of course we call the final write
message function and then the result of
that function is what this send message
will return
and of course we have to handle errors
so we're sort of back to the the
try-catch of yesterday raise your hand
if you hate try-catch okay a few of us I
kind of like them I think they're okay I
do hear a lot of people do dislike try
catches however so in this case what we
do is we wrap our call to send message
and a try-catch within our try catch
we're able to use the throw error throw
new error syntax that we can do with
synchronous code and then that error
will actually get caught by our try
catch in our async code of course you
can't throw an error within a callback
and expect the error backed the callback
to be called with air however with this
async await code we are able to do that
cool thing on a-singin wait is there it
just promises you know they do some cool
stuff on hood but at the end of the day
they're they're basically just promises
so early I want to showed you that code
and I was like you know we're awaiting
that get user call and that get users an
async await can send and that's an async
function well though those get user and
can't send those can actually just be
promises and so async functions and
promises are 100% interoperable so in
this case here we have the send message
call this is the exact same promise code
that we showed earlier on and so we call
it and passing the arguments we do are
then you get the result and then our
send message is now a async function and
so this means you can refactor your
application pretty easily from the
bottom up and so for example send
message that could be your controller
that could be your Express handler the
send message that could be your model
that's actually interacting with the
database and so maybe you want to change
all the models in your database first to
make that many sink functions you want
to leave your controllers the same
because you don't want to do all this
work at the exact same time and so you
can definitely do it from the bottom up
errors of course are also completely
interoperable so in this case we throw
an error from async function that is
going to trigger the catch with our
promise code and as you might have been
able to expect you can also reflect from
the top down so perhaps you want to
change your Express can't code first and
make that async and then you want to
change your database later
in that case we're now you know awaiting
a call to send message and our send
message is just a good old promise it's
pretty sweet cuz for example say that
you build a library and you want this
library you want to release it out in
the wild and so you can create this
library using async functions and then
within the calling environment you know
they perhaps they just want to use your
library as a normal promise they can
totally do that assuming the version no
they have is compatible with the async
keywords so totally totally
interoperable and then of course when
you refactor from the top down if you
return a rejected promise from within
your model code you're able to wrap it
and try-catch will execute the way you
would expect the Noda API of course uses
callbacks and so there's these lovely
tools to promise a PHY them one of them
is built in to the latest version of
node so you can use util dot promise if
I were you pass in a function and then
it's going to take that function it's
going to count the number of arguments
so for example reading file s3 arguments
where the first one is the file path the
second one is some options like encoding
information and third one is the
callback and so it's able to look at
that and it's able to create a promise
for you which will invoke that function
and you know do the right thing under
the hood it's gonna you know call the
callback and in the callback of read
file is gonna trigger the promise cetera
so there's this cool library written by
my my buddy Brian a friend of ours and
so it's called PI fall promise by all
and so this is useful library it's much
like Bluebird has a method called
promise of hi all and so this is a tool
which uses util dot promise if I and
what its gonna do is it's gonna wrap
every single method of a object with
async methods so in this case let's see
how the code looks so within our async
function what we're able to do is we're
able to await a call to read file where
you pass in the first argument is the
file that we want to open on the second
argument here we're able to call FS dot
read file async and so FS now that we've
passed an async has all these sibling
methods and so normally there'd be a
read file but now there's read finally
sync
so that's useful for for example your
risk oh and I noticed that using
promises with that and so you know are
you using Bluebird dot promise if I all
yeah awesome cool yeah so it's really
useful to be able to use async and wait
with you know for example Redis so I use
this for my side projects it works
pretty cool and then we're able to yeah
with minimal boilerplate we don't have
to set these promises of ourselves were
able to await these native calls to the
API can anybody spot the anti pattern
that I've introduced here yep
that's true yep so he's saying is where
we're reading stuff we're waiting for it
to be done once it's done we're reading
data waiting for it to be done and then
once that's done we're we're outputting
the result of course we could have done
them in parallel and so it's kind of
easy to do this kind of stuff
I think I'd kind of have the feeling
that I you know with with the callback
patterns with the promises we kind of it
was maybe more obvious when to do stuff
in parallel this syntax make it does
make it a little easy to start writing
more procedural code so it's one thing
to keep an eye on of course that can be
fixed you know pretty easily and said
you could do you could perform an away
time promise at all as was mentioned we
provide an array of promises once the
array of promises completes or once the
first call throws sorry to rejects you
know once that happens whatever happens
first we're then able to get the data so
we're able to do this work in parallel
using promise that whole cool that's the
talk</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>