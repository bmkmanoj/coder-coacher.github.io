<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The State of C#: What Have I Missed? | Coder Coacher - Coaching Coders</title><meta content="The State of C#: What Have I Missed? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The State of C#: What Have I Missed?</b></h2><h5 class="post__date">2018-04-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LYfsGgj59y4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I want to talk about what's changed
in c-sharp as a language I'm gonna talk
about how its progressed over the years
so we'll just talk briefly about c-sharp
two three four five and a little bit
about six and then we'll talk about the
future of c-sharp and what Microsoft is
currently working on so c-sharp c-sharp
is pretty much the best language out
there but honestly it takes everything
from declarative functional imperative
programming languages that most of the
developers love in those languages we
have influences from sequel from C++
from C from Scala from Ruby from f-sharp
and from all of these different types of
languages and we'll see that when
c-sharp changed over these years they
added a lot of cool things from all
these different types of languages I
don't know if you knew this but generics
for instance came from a project on the
f-sharp language so they started doing
research about f-sharp and building
f-sharp and they introduced generics and
then they pull that into to c-sharp so
that's pretty great addition I
originally did Java development and I
still believe there's no generics in
Java so looking at Java as well as
c-sharp and comparing these to how they
kind of progressed over the years
c-sharp is just rapidly adding features
to the language to make it easier for us
as developers to build software so if
we'd lost look back through history and
talk about c-sharp 2 which was the first
iteration of the language after we got
if statements and while loops and
functions and all that you know the
basic things you want to use in a
programming language we've got things
like generics which changed the way that
we build software we got partial types
which allowed us to do wind forms and
WPF and all of these other crazy things
that you can do with partial types we've
got anonymous methods and iterators and
nullable types so we knew no longer have
to say we could use nullable integers
and all these value types could now be
used as knowable like reference types
we've got getters and setters with
separate accessibility study classes and
a lot more so in c-sharp - that
introduced things that made it easier
for us to just build software that's a
little bit more readable when the next
version was released they introduced a
lot of things one of them being the
implicitly tired
local variables which is a mouthful to
say easier is to say they introduced the
VAR keyword and I remember having this
discussion so many times with coworkers
at the time I don't work with them
anymore they thought that using the VAR
keyword was a way for you to write
dynamic code in c-sharp does anyone
recognize that well it's not because
dynamic was added in the next version of
c-sharp so using the VAR keyword is just
a way for us to don't we don't have to
be so explicit anymore so that's pretty
nice
we've got objects in collection
initialize search we've got the auto
properties so coming from a Java
background that was really nice too I
don't have to be so verbose anymore I
don't have to specify the field and then
do a function for a getter and then for
a setter and so forth so it's a lot
easier and then we got a heap of more
features like anonymous types extension
methods query expressions lambda
expressions expression trees and much
more you know if you group those
together they introduce one big thing in
c-sharp 3 which allowed us to do link
link allowed us to do things like link
to sequel work a lot easy a lot more
easier with collections of data so if
c-sharp 2.0 introduced things that makes
it easier for us to just write readable
code c2 3 introduced helpers for us to
write code that work more easily with
larger collections of data now if we
look at C sharp 4 we don't have so many
features added here they did add the
dynamic language runtime and with that
they added dynamic bindings which means
that we could do things like ironpython
and ironruby and introduce all these
different dynamic programming languages
into c-sharp not saying that's a good
idea but they did add that to the
language to make it possible for us to
more easily write extensions and write
scripting inside our applications now
c-sharp 5 only introduced two things and
you might see a pattern here that they
add smaller and smaller and smaller
features with it each iteration of the
language now I'm not saying that
asynchronous methods is a small thing
it kept me employed for the past few
years because it's a hard thing to
master and a lot of people tend to do
deadlocks I have a course on plural
sight on how to do a sync respond
properly let's check
but they did add that in c-sharp 5 but
we see here that they didn't add too
many features in c-sharp 4 and 5 and the
fact is that most of us now how hard it
is to add things to a project that's
lived for a few years now I don't know
how long C sharps been around let's say
10 years imagine going back 10 years and
add things to a codebase and introduce
something like asynchronous methods in
the compiler that's probably written in
C++ now that's not a trivial project to
do so at that time Microsoft decided to
introduce a project called rustling
who's not heard of Roslin so Roslin also
known as the dotnet compilation platform
it's it's a project that Microsoft
introduced to make it easier to add
language features but how do you do that
well you throw away the old compiler and
write a new one in c-sharp and VB so
they started reworking the compiler to
be able to add more language features
but that meant that they had to look at
the old compiler and make sure that the
new compiler generates the same code and
that means that the older box from the
old compiler needs to be introduced in
the new one as well which is an
interesting thing right so we don't want
to introduce bugs that we've had in the
past but they had to do that with a
compiler and what's even more
interesting is that they wrote the
compiler in c-sharp and VB which means
that they used the old compiler to
compile the new compiler and I do
believe that they use the new compiler
to compile even newer compiler so it's a
mouthful but they did introduce that and
what's even more cool with this is that
it's open source so Microsoft is not
only pushing the code to github but they
do a lot of commits they do a lot of a
releases so that 82 releases of Rosling
which is the c-sharp and VB compilers
there's not 82 releases official studio
this is independent from the IDE and
they have a lot of issues so that means
that we as developers can go ahead and
say well I want to add this language
feature to the programming language
maybe I want to increase tuples maybe I
want to introduce pattern matching well
if you if you want that you just go in
here and you create an issue to
Microsoft and they keep track of
everything they add the design notes
from their language design meetings and
they talk about all these things in the
open
and then of course you can submit your
pool requests so actually submitted a
pull request to the Rosslyn Project I
change the spelling mistake in the
documentation but I still contributed
contributed to the compiler put that on
my CV all joking aside what they do do
is add the design notes from these
meetings so here we can see from 2016
they started talking about language
features for c-sharp 7 they started
talking about tuples and pattern
matching and they even added all the
information about why do we want this
they do proper documentation right so
they this is what every developer dreams
off we want why do we want to build this
how do we do it
how does it impact current developers
how can it change the behavior of how we
build software in the future and this is
one of the things they actually did add
to the language but introducing rosslyn
and making it easier to add language
features means that they might want to
focus on the language that most
developers use does anyone do VB in here
one so sorry but there's no more
language parody which means that they if
they add a language feature to c-sharp
they might not add it at the same time
to VB unless it's really easy but the
same goes on the other way around so
they might add something to VB that's
not coming to C sharp like xml literals
for instance now this here means that we
have a lot of potential with this new
compiler so now Microsoft can just shoot
up new features how many of you are
using Visual Studio 2017 almost all of
you that's great
so that means that most of you have
probably used the C sharp 6 features
they've been around since Visual Studio
27 2015 that's when they first released
the Rosslyn compiler as a part of Visual
Studio I'll just go through this quickly
and I will look at some code they
introduced something called using
statements for static members auto
property initializers which is a way for
us to introduce proper read-only auto
properties awaits inside catch and
finally blocks little conditional
operators which is also known as the LVS
operator string interpolation dictionary
dictionary initializers expression body
members exception filters a name on my
name of operators so let's have a look
at some code
so I have a few of them here have a few
projects inside Visual Studio
I'll just and my stud here so we'll see
here that I've created these different
console applications they're just here
to illustrate these different language
features so the first one is using
statements for static members so we'll
see here that what we can do here is
that on the top we're saying using
static system console that means that
everything inside system console that
static is now part of work and look for
methods so instead of me having to write
console dot write line I can now say
just write line because it's going to
look that up automatically so that's
pretty neat and if I introduce a method
in here that's called write line as well
with the same signature it would of
course take the one that's closest to it
so it's doing the same resolution as
it's doing when it's looking for methods
in other cases as well it takes the one
with the best match and then we see some
other things in here which is also new
we have something called string
interpolation string interpolation means
that we add this dollar sign here in the
start which is the same way that we do
when we have the add symbol when we are
the add symbol in in front of a string
it means that it's not going to escape
back slashes for instance but with a
string interpolation it means that
whenever we find curly braces like we
have here to the left it's going to
evaluate the expression inside that it's
really just going to convert this into a
string dot format so what happens is
that instead of us having to write
string format and then have a placement
and then have the parameter after this
is just a nicer way to do that and then
we also have the name of operator and
the reason that you say name of program
and not have the hard-coded string
program is because you would have a
really hard time changing the name of
program when you do refactoring so you'd
find the reference to that which makes
it easier when you logging and so forth
all right so the next one they added is
auto property initializers
this is a proper way for us to introduce
read-only auto properties so I can say
here that I have this property called
name and the initial value is going to
be Phillip
and if I try to change this it's just
not gonna work it I'm gonna get a
compilation error saying well you can't
really do that right now and of course I
can print that out to the console as
well and it could change this in a
static constructor or in a normal
constructor it's just static here
because it's it's the program that's yes
so that's just gonna make it easier for
us to initialize values for our auto
properties and of course we can have a
private set here as well if you want
that so this worked with all the
different variations of auto properties
now if you're doing a lot of
asynchronous programming you'll probably
be happy about the addition of awaits
inside the catch and finally blocks this
is a way for us to use the asynchronous
principles inside catch and finally so
let's say that we do some asynchronous
operation we go ahead and talk to the
web here at the first line here we've
grabbed some data something didn't
really work out as it should we might
want to clean up to add something to the
database and afterwards we might want to
just dispatch a message on to a queue
and do that a synchronously as well so
previously this wasn't possible but now
they've added this feature in c-sharp
six now one of my favorite features is
the null conditional operator also known
as the Elvis operator so if you look at
one of these methods down here it's
called process people takes a list of
people now what I'm doing is that I'm
iterating over all these people and I'm
saying well I want to get the person
unless the person is null if it's not I
want to evaluate that entire expression
as being a null expression so I'm saying
well give me the person if it's not no
and if it's not now give me the name of
that person and the same goes for this
one here so I'm saying well give me the
person unless it's null
give me the address unless the address
is null and then give me the street name
so this here allows us to write code
that's less prone for null reference
exceptions and of course you can be
crazy and you can do the same thing for
instance for arrays or collections so
here I'm just declaring know as an array
so it's not initialized I'm saying well
give me the the array unless the array
is no give me the first index unless
it's no and then give me the name if
that's available if one of these here is
no it's going to evaluate the entire
expression as being null which is
we can do this here at the end so we can
say well if any of these are null just
use this default value and if I run that
of course it's gonna say Philip slaves
has no idea unknown lives that no idea
because if you look at the top here we
can see that it says well create a new
person the person doesn't have an
address then we have a person that's not
initialized and it handles that properly
and then we got something called
expression bodied members now expression
body members is for people like me who
are lazy that don't like to write method
bodies so what I do here is that instead
of declaring this entire method bollocks
a return name I can simply use an
expression and say well fat arrow and
the name here and it's gonna know how to
return that properly so you see your
most of the things they add to c-sharp
six or at this point it's things that
makes it easier for us to just write
code write less code that handles more
things in the background to get rid of
all this boilerplate code that we have
to write it's really the same with
c-sharp five when they introduce a sink
rinse opposed we've been able to use the
TPL to do we're synchro's programming
for a long time but it's been kind of
tedious to do that and you had to
rewrite a lot of boilerplate code to
make it properly now finally in c-sharp
six they added exception filters now
imagine that I'm doing this this web
call here I'm saying go ahead and grab
the data from google.com and then I
catch an exception down here and say
well catch this exception which is the
web exception when this status is a
timeout then we might want to do a retry
and in the second case I'm saying well
if there's a name resolution failure
which means that the DNS is probably
down we can do something else we can
indicate that the application is in
flight mode or the other the computer
doesn't have Wi-Fi or something like
that
so this is me you no longer have to
catch the entire web exception and then
do one if it's this if it's that if it's
something else because what happens if
it's not cat caught here it's being
thrown back to the caller so for all
different for all the other web
exceptions that doesn't match these two
here it's going to be thrown back to the
caller
so just handling that
the box right so c-sharp 7 which is the
current version of c-sharp or well
actually released a new version just a
few days ago I don't know if you've
noticed but c-sharp 7.1 is out as well
and I'll cover the changes in that as
well so c-sharp 7 was released with
Visual Studio 2017 and they introduced a
few interesting concepts one of them
being tuples and deconstruction so
tuples is simply put a way for us to
return multiple values from one method
which you could say that well you can
just create a type for that but
sometimes it's just nicer to use tuples
they also introduce pattern matching
which is which is a really nice feature
it allows us to match a an object to
another object and then do a switch case
on on the type of object that is I'll
show you an example of that and then
they added something just to make people
happy that work with large numbers so
digit separators and binary literals
it's just a way for us to split up our
larger numbers and hexadecimal numbers
and binary numbers a little bit nicer in
our apps and they also added local
functions I haven't really found a good
use case for that yet but sometimes he
wants to just add a function that's in
your current scope but I'd argue that
you probably should refactor your code
if you need a local function then they
add riff returns which means that I can
say well I want to return a reference to
this object so you have you have been
able before to pass in a reference to an
object but now we can return our
reference to an object as well and
they've done some improvements to the
out keyword as well so let's have a look
at that
so in c-sharp 7 we've got tuples so up
here at the top we have a function
called get point which has two values
being returned from it now what's
interesting here is that I can say well
I also want to return a string and I can
just append more parameters that I'm
returning from this here but let's not
do that this is called get point so this
here makes it a little bit easier for us
to just simply return two values from
this here without introducing a struct
or a new class and when we use this here
we can use
different types of methods of
deconstruction the construction means
how do we grab these two values how do
we get the X&amp;amp;Y into local properties or
local parameters the first one is to say
well Colgate point get point is going to
be the result of that is going to be in
this local variable here and this local
variable is going to have two properties
or two fields so what happens here is
that I can say well point X or point on
Y consumed in a little bit and this here
allows us to to use those two values rid
of this and then the other type of
deconstruction we can do is to say well
I want you to map the result of get
point which is two parameters I want you
to map that into the local variable x1
and y1 so now I don't have to write
anything else but x1 because that's now
an integer which it has mapped those two
values to the last one is to say well I
don't really want to specify the type so
I'm gonna say get point returns two
variables these two variables are going
to be mapped into x2 and y2 and of
course that's going to be two integers
so if you run this here it should say
the same for all of these different
types so X is 100 all the different
places and Y is 200 on all of them so
that's super simple it allows us to
easily return multiple values from a
method and we can have different types
of deconstruction based on how we want
to use that right so next up is pattern
matching now pattern matching has been
available in other programming languages
for a long time but it was recently
added in c-sharp so what it means is
that in this case here I have a shape it
could be a rectangle it could be a
triangle it could be a circle it could
be an ellipse it could be whatever type
of shape you want to to use and then I'm
saying well I want to do a switch case
switch on this shape and if it's a
triangle I want you to map that to this
local variable called T which means that
I can use all the properties that are
available on my triangle so a triangle
has multiple sides so we have slide
B&amp;amp;C but in case the shape is a rectangle
I don't have ABC right so we have
rectangle has a x and y in width in
height so we just automatically converts
this into that or cast it to that object
so this means here if I run this it's
gonna say well since this is a rectangle
we have X Y height and width but if I go
up to the top here and say well the type
is in our triangle run it again
it's gonna map that to the correct type
so this here is going to remove a lot of
you know type get type is equal to type
off my rectangle if it's a rectangle do
a conversion to that particular type
this is a lot nicer so it'll just reduce
our boilerplate code next up is local
functions so I've introduced a local
function down here at the bottom it's
simply a method I call calculate which
then introduces a local function called
fib which calculates Fibonacci and
returns the Fibonacci of X which is
passed into this local file which is
passed into this function all right
and that's only available in the scope
of this method down here at the bottom
and then we see here at the top we have
the digit separators and binary literals
we have a binary number here
representing the value of 16 which you
can now do and then we can have these
separators if you want a really large
number we can just add these separators
but that's gonna take a long time to
calculate Fibonacci 4 so let's just run
this here and we'll see here that it
doesn't print it out with the underscore
it's still an integer and this calculate
method here used that local function now
for ref returns which is the the fourth
language feature that I want to talk
about I'm actually using a local
function as well so I'm saying here this
function returns a reference to an
integer I'm going to pass an array of
integers and I'm gonna give it a
position of the integers that I want the
integer that I want the reference for
and then it's simply returning a
reference to that particular value now
this is where it gets a bit crazy so
first I'm
printing out the value on the first
position or index one which is two and
then I'm getting the reference to that
element and then I'm reassigning it to
the value 10 and I'm printing it out
again so this one here at the left words
its element at is equal to 10 it's the
equivalent of doing source 1 is equal to
10 all right so if I run this here it's
going to give me the two different
values because I've now changed that
because I got a reference to that
particular type so I can change the
value now this different these changes
here is it's probably more common if you
work with really high performance
applications where it's a lot more
cost-effective to pass a reference
rather than doing a copy and so forth so
the last one is out improvements I
actually found myself doing this just a
few days ago when working on a project
where we are interacting with legacy
code that requires us to specify out
parameters now previously what you've
had to do is to say well I want an int
called int called X and then you say
well out X right but now what you can do
instead is that you say get rid of that
and then in place say when there's an
out variable I want you to I want you to
declare the X if it said right so if I
run this here of course it's gonna say
100 and 200 because it introduces though
to those two new local variables so we
of course have X available here x and y
so these are the changes that they've
recently done in c-sharp 7 they've added
more features in c-sharp 7.1 but we can
kind of see a pattern here that they try
to allow us to reduce the amount of code
that we were whether we write so they
introduced tuples so we don't have to
create a new class they introduced
pattern matching so we can get rid of
all these if-else statements when
checking types so if we talked a little
bit about what's coming next the fact
that they're doing a lot of work on the
language by no means are they adding
less features in the upcoming versions
and honestly it feels like they're just
adding like they're doing 7.1 now and
then they my 27.2 and then 7.3 and then
who knows what they're doing after that
but they're all
also talking about major features being
added in c-sharp eight so if one's
interested in what's coming in the
upcoming versions they do have a track
of what's happening what's being added
to these languages or to c-sharp so on
github they have this language features
status where they talk about how are we
progressing with this proposal so
internally on Microsoft they have a
champion for each language feature that
they want to add and they're they're in
charge of talking about that in the
language to design meetings and they
talk about how do we introduce this and
what kind of side effects does this
feature have for instance they removed
record types from c-sharp 7 which they
really wanted to add but it was just too
much of a hassle to get the IDE support
in place in time so hopefully they'll
get that into c-sharp 8 but when they
talk about new features like it's not
only about adding that to the compiler
they need to add support in Visual
Studio that need to have documentation
this is a big big process so c-sharp 7.1
introduced something that I find pretty
cool it's async main so I don't know if
you write console apps but most of my
demos or console app so I'm really happy
about the fact that I can now do
asynchronous main methods in console
applications they made the default
expression a little bit more simple and
they introduced something called
infer topple names pattern matching with
generics and ref assemblies reference
embolus is a way for us to work with
metadata out of assemblies so I
mentioned that c-sharp 7.0 came out with
Visual Studio 2017 and actually recently
released c-sharp 7.1 and I have of
course I have demos for that as well and
the way that you say that you want to
use these features is that you go into
the properties of your project this is a
per project setting you go down to the
bottom and you choose advanced in the
build tab click advanced here and then
we can say which language version do we
want to use so we can say well we want
to use if I say 1 to C sharp 3 and so
forth and I'm gonna say I want to use
the latest minor version which means
that it's now going to use C sharp 7.1
and it's going to use the latest version
of the compiler as long as it's
installed so
which means that as soon as c-sharp 7.2
is out it's going to use that as well
this means that I can now go ahead and
go into my project and I can say that I
have an asynchronous main method which
returns a task so I no longer have to do
tasks run wait in my console app because
that's a bad pattern we want to avoid
doing that in our applications and we
can see here that I'm using this new
default expression so the default of the
default expression before was that we
wrote something like this
but you know it's too many characters so
why not make it a little bit more simple
it's almost like someone has too much
time coming up with these features I
don't know it's not like it bothered me
before alright so the next one is that
they've changed the way that topples
work or they've improved the way that
topples works so if we change back to
c-sharp 7.0 which is now deprecated I'm
just joking it's already old now it's
not so what I'm doing here is that I'm
creating a new object called point point
has an x and y property and then I'm
saying well I want to create a new
topple and the way that you can do that
now is by it simply having two two
parameters parentheses like this here
and just specifying the ones that you
want in there previously in 7.0 which is
now old for you guys because we know all
about that it's that you had to do this
here to explicitly say that well this
one is going to be called X and this one
is going to be called Y but now what
they do is that they infer that instead
which means that I can say well tap o
dot X and that's now available on my
topple what's interesting as well here
is that previously in c-sharp seven you
had two 7.17 getting confused you could
write item one right so you can write
toppled on item one that's like the
basics of the topple you can still do
that but it's not available in the
intellisense here because they remove
that because they want you to use the
better version of
of it instead so it could still do
tupple at item one and item two so there
are a few less features added to this
minor version of c-sharp but kind of
make sense that you don't add breaking
changes or adding large sets of features
to a minor version unless we talk about
c-sharp 7.2 which is the next version of
c-sharp they are adding a few extra
features that will make it easier for us
to work with references again if you
work with high performance applications
we're doing game programming which I
don't know if you do that in c-sharp but
if you do and use mono game you're
probably going to be very happy about
this here so they're gonna allow us to
do ref read-only which means that I can
have a reference that you cannot change
which is a little bit odd because I'm
not sure how they're gonna implement
this here but it'll certainly be a nice
feature to have so the second line here
says vector add and then you can specify
this is only an imprimatur so it's not
something that can change so they add
this keyword called in here and this
allows you to pass the reference but no
one inside this method can change it now
this is not set in stone so this might
change the one could say it's not
read-only so they're also going to add
non trailing named arguments which means
that if we have a lot of overloads for a
method we can specify we want to choose
this one by specifying the first name of
that parameter and then we don't have to
do it for the rest of them they were
going to add something called private
protected so you can now say that your
classes or functions or private
protected which is totally confusing but
it's good for people that write API so
when you get packages so in the CLR
which is the common language runtime
we've always been able to do protected
and internal which is probably a better
name I think because it indicates that
well it's protected inside my assembly
so I can inherit from this type or I can
override this inside my type but no one
outside my assembly can do that which is
pretty much what private protected means
unless I'm totally confused by that
naming so don't blame me they're gonna
add conditional ref operators so we can
say that well if this can this
condition is evaluated to true or false
give me this reference or give me this
reference previously you had to do this
on two or three lines of code with a few
if statements but doing an in line like
that it's pretty nice it's all about
cutting the characters because as I
think Scott Hanselman said you need to
value each keystroke on your keyboard
because you only have so many keystrokes
in your life and then they're gonna
improve the digit separators again I
don't know who comes up with this but
someone likes hexadecimal numbers so
that's all for c-sharp 7-point x that we
know now so now we can talk about even
more features that might be added or
might not be at it we can talk about
c-sharp eight so there's a language
candidate or a 8.0 candidate with 1819
open issues on the c-sharp lang repo on
github so they want to add everything to
c-sharp eight just like they wanted with
c-sharp c-sharp seven they want a heap
of features added to the language but
with only so much time some of these
might be scratched from the language so
c-sharp aid is going to hopefully now
introduce record types it's going to
introduce default interface methods and
I'll show you a few examples of these in
just a moment they're gonna introduce
notable reference types know policing
assignments recursive patterns for and
pattern matching improvements negated
conditions negated condition if
statements know conditional await and
hopefully a lot more so a pattern that
you might see here is that they want you
to stop writing in all reference
exceptions they want to improve the ways
that we work with knowable types it's
almost like someone on the design team
regretted adding node in the first place
alright so record types if we have this
triangle here which is a base type of
shape we want to make sure that well
when you create this write with this
triangle you have to specify a B and C
in the way that we do this with record
types is by simply saying well this
triangle here requires a B and C so
instead of having to write all these
other properties we can just simply add
that to the when we declared the class
like I think this is pretty cool but you
know that's my subjective opinion
everyone might not like it and there's a
lot of edge cases which makes this a bit
interesting it's probably why they
didn't add it to the language yet next
one is default interface methods that
sounds dangerous so imagine being able
to just add methods that are implemented
to your interfaces that's great
is it I don't know so this this way here
the way that were what the reason they
want to add this to the language is
because imagine I implement an interface
that I got off from you get and I up you
update this nougat package and the
author of the nougat package introduced
a new method on the interface but I
don't care about that method yet so I
have to go in and say well I'm going to
implement this method thrown you not
implemented exception they could just do
that in here instead so there's a way
for them to say well this is a breaking
change it's going to be adding the next
version so you have time to upgrade your
solution so in this case here I can
simply say well point here implements
the I point interface which means that I
could say well I have an idea called a
new pointer than I can call get point
without actually having this implemented
in my class what the proposal talks
about as well is that well if we simply
remove the I point here and we know that
it's a point this won't work because it
doesn't know that you were talking to
the interface so they have a lot to
figure out to make this understandable
but if you think about this even further
I talked to a co-worker and he said well
this is a way for us to introduce
multiple inheritance in c-sharp which
can be dangerous all right
so noble reference types imagine us
being able to say well this object can
never be null we can add this question
mark here to say well a point this point
can never be no and if we do that with
parameters if we pass a null something
null into that method no one would be
able to call it and hopefully the
compiler notices and tells you at
compile time so if we do this here it
should blow up now remember these are
all features that they want to add
they're not implemented which is why I
can show them
your studio and I didn't have time to
implement them myself so next up is null
coalescing assignment so we've always
been able to do something like this here
we can say well I want to set X to a
value I want to set it to Y if X is no
now they want to make this even easier
to write less characters so what we can
do here is to say well only assign X to
Y if it's really no it's I don't think
they've agreed on the notation yet but I
think it's great it's gonna be so
confusing it's gonna end up looking like
one of those really hard understandable
languages like Lisp adana don't add
negated conditions in if statements
which means that we no longer have to
write this here so this here is also a
mouthful
well if shape is triangle not do this
how about we say well if triangle is not
a triangle or if shape is now a triangle
or if it's not shape is triangle again
they haven't really decided on this one
but the last one is my favorite
unless shape is a triangle I don't know
I vote for the last one because adding
more keywords in the language is great
keeps me employed all right so no
conditional weights sometimes we say
well I want to weight the task unless
the task is no because maybe you've
changed the task from somewhere else how
about we say only run the task if it's
not no and we do that by introducing
another notation or saying I don't know
if it's screaming at the task of what
it's doing but yeah that's gonna be
great so to wrap this up they are doing
a lot of changes in c-sharp and
hopefully some of the features in
c-sharp six seven seven point one and
seven point two and eight are new to you
and I think that some of these features
are going to make our applications
hopefully faster to build easier to
maintain and for those of us that go
into project and fix things that other
people break it's gonna keep us employed
because adding things like async and a
weight and making it easier for us to
write code that's just generating a lot
of code in the background it's great
because it means that we need to
understand what's really happening we
need to understand the problem
they're trying to solve right
pattern-matching is great but we really
need to understand how it affects our
applications so with that I want to
thank you all for coming here to
listening to me
ping me on Twitter if you have any
questions if you want my book press the
green button on your way out
and thank you saying thank you so much
for having me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>