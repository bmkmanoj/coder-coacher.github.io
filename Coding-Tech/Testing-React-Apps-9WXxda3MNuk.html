<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing React Apps | Coder Coacher - Coaching Coders</title><meta content="Testing React Apps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Testing React Apps</b></h2><h5 class="post__date">2017-12-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9WXxda3MNuk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so yeah the topic I want to cover today
is testing there's kind of been a theme
that's been mentioned throughout a few
of the talks around confidence when
writing code and how react really helps
with that and testing kind of takes that
to another level some of the things that
that testing gives us as confidence in
our code if we're backed by this suite
of tests that confirm that things are
working as we expect if you have a bug
that you want to fix and you can write a
test first that shows that bug in action
you can then fix the test fix the bug
and then know that bug can never come
back again
it also if you've got lots of developers
working on different bits of a really
large application you can have
confidence that developer a over here
doesn't break someone's code all the way
over here and it's really nice for it
for refactoring as well so I hope I
don't have to convince too many people
the testing is a good thing I'm gonna
focus more say on on testing react one
question I get a lot and I think
Shakespeare asked at first was TDD or
not TDD it was something along those
lines I can't really exact quote
so this is the practice of writing your
test first so you write the test knowing
that it's not going to work and then you
write the code to parse it I think this
is more just a preference thing I'll
often write tests first sometimes and
not others so I don't think it's a big
deal I don't think you're doing testing
wrong if you don't write tests first
it's entirely up to you how you how you
tackle that cool so before we get into
react specifically just to quickly cover
there are so many different options for
testing JavaScript out there I've picked
one called tape for this for this
presentation but there's marker there's
Jasmine there's jest which is worked on
by a team at Facebook but more
importantly that this talk is test
framework agnostic all the tools and
kind of things I'll talk about aren't
specific to this testing framework so if
you don't like tape and you think Marco
or Jasmine will be way better that's
fine everything here is just you know
all that libraries providing is the
little wrap around the actual testing
itself so please don't hate me if I pick
tape and you don't like tape there's
lots of options out there
everything in the store can be used with
any of the frameworks
I put this slide in I don't think I need
it really because we've seen a lot of
es2015 on screen so far but I try to use
a lot of es2015 particularly when
testing I find it tidy sings up so
you'll see a lot of area functions which
make things easier and a lot of imports
as well rather than requires the colors
on that on fantastic but we should be
okay so just to give you a quick example
of how tape works this is kind of boring
old testing tape so we first import it
and we test my laser yeah we can nest
using collect functions and we give them
an argument T then we have to tell test
how many assertions we're going to make
so here I tell test tape that we're
expecting one in this block the reason
behind that is if you tell tape how many
you're expecting it knows to hold off if
there's an asynchronous one waiting so
tape has really good support for async
tests out of the box and we can also you
like use like deep equal to assert that
an object is equal to another object I
really like tape it's pretty
straightforward it's pretty minimal it
doesn't give you as much compared to
some other frameworks and I personally
like that a lot and it's got good
support for being trans power through
Babel as well which is what we're going
to do so to do that just very quickly we
use Babel register install that and then
we can figure our test script to just
require Babel register before running
our actual tests that ensures that Babel
is running all our code is converted if
you run a suite of tests through tape
though the output is pretty dull like
this is it you should get rewarded a lot
more for getting passing tests than some
black text we'd like okay at the bottom
but I don't want okay you did an okay
job tape outputs a single tap which is
the test anywhere protocol which is
basically designed for computers to read
but not humans the idea behind tape is
that you out you get this output you can
pass that into lots of other things that
will make it prettier and this isn't
really designed for it for human eyes so
one I prefer is called four six which so
we just pipe our output through there
and hopefully this plays so that's
that's what it looks like with four set
which is much nicer and a bit cleaner
there are lots of these available one in
particular if you were really feeling
keen you could do this
if you wanted we do have a nyan cat
reporter for tape available yeah and
that's kind of cool
I would never like to work in a team
that used it though anyway so basically
you can take this output and do whatever
you want with it there's lots of options
there are tape reporters that kind of
mimic like r-spec and Ruby or Jasmine on
rock or whatever so so you really can
take the app and do it or what you'd
like okay and I should also know quickly
I've got a link at the end to all the
code that's on github the into all the
tests I've got in this presentation and
the application will test is all on
github so I'll have a link to that at
the end I'll put the slides on Twitter
once I'm finished okay so moving on to
react to start testing I needs to make
an app to test on so I went away I
fought for about 30 seconds and came up
with this idea you might have come
across one of these on the inset before
just in case you haven't I've got a
video of it so yeah we can delete them
we can tick them and we can add new ones
I think it's the next unicorn but anyway
so this is a little to-do app we're
going to use to test today just giving
away what the structure of it looks like
we have this - duze component up here
which kind of wraps everything then we
have a list of to do components they get
each individual to do and a couple of
callback functions as props which we'll
look at in a minute and then we have
this add to do component which is just
responsible for the form as well so
there's not much going on there there's
not too many components but it's a nice
kind of size application to it to start
writing some tests with all the state is
held in the - duze component and other
components notify the deduced component
when data has changed the - duze
component is where all their state lives
in here so I said we were going on to
react testing but just before we do that
I wanted to go on a point which actually
Jamis this morning set me up for
brilliantly we didn't even plan it I
genuinely had this in my slide deck
before the talks this morning
embrace plain old JavaScript objects
this one the reasons I love working with
react is because it's so easy to pull
stuff out and just work with with
libraries or just work with plain
JavaScript as well and what I found here
is that most of your logic the kind of
complicated logic around your state and
your application or your your business
logic you might call it should exist
outside of your react component once
they do that these
the testing frameworks doesn't become an
issue because a lot of your core logic
is just in playing JavaScript functions
and if you can make those functions pure
and make them very easy to work with
they'll be very easy to test as well so
you'll see if you look on the github
repo the example application that I've
got pulls out these functions which I
use to manipulate the state so have one
called toggle done it takes the existing
state and the idea that to do that
should be toggled between done or not
done have to do which takes a state and
then new to do and gives me about the
new state and delete to do which does
exactly what you might expect it's
basically a very poor man's redux but
you know I didn't need Redux in this
application but still by pulling these
out if they become really easy to test
suddenly my core business logic doesn't
even need any react stuff to be tested
at all I can just write a regular old
test for these no sign of react anywhere
so see here I plan a test I create my
initial state which is to do so an array
of one to do I've got some milk I bought
some milk I compute a new state by
calling this add to do function which is
a functional testing with the initial
state and my new to do and I I assert
that the second object in my to do array
is now this need to do that's being
created and that way all your core logic
can be written entirely independently in
their own tests when you can test stuff
like this without having to load up a
framework or boot up whatever react
they're also much quicker to so just by
doing it this way it's just winds around
but I sped the reason the real reason
you're listening to this talk is
probably to hear a bit about testing
react components so I should probably
start to cover that at some point so
what we're gonna do is look at testing a
bit of our application we're going to
start with their to do component which
is responsible for one of these bullet
points here so if in this component as a
few things you can do the component
looks somewhat like this it's a react
component unsurprisingly the prop types
it takes is to do which is an object
representing their to do that will be
rendered a done change which is the
function it should call when to do has
been toggled between done or not done
and then delete to do which is a
function it should call when it's to do
has been the delete button has been
clicked I've put the code up here it
doesn't really matter this this has been
more useful if you're looking through
the slides later but it's you know it's
pretty straightforward we just render
that as a dreadful color blue sorry
about that
we just have a couple a paragraph that
has the to do text a button to click
delete and we can click on this
paragraph to toggle it as well and
here's the toggle done just calls done
change with the ID delete seduce calls
the prop with the ID as well so the call
kind of bits of logic in this component
which is how I always start when I'm
trying to think of how to test it by
kind of writing down the logic the div
that we render this one here which is
quite tricky to make out gets a
conditional class name of done - to do
if the to do is marked as done so we can
style it as such the Leasing clicking
that delete button to delete it to do
should call that this dr. Otten e to do
method with the right ID and clicking it
to do calls the toggle done method also
with the right ID so those are kind of
the the bits of functionality I want to
test so thankfully we've react the
testing story is actually really good
these use come built-in they now come as
a separate install react ships with the
test utils add-on which we distance all
through M p.m. and this basically does
my job for me as a presenter I could
probably walk off now and be done with
it but the test utils provide most of
the kind of functionality we need to
test our react components so to start
with we don't even need a Dom to start
testing react components a kind of semi
experimental feature but it's been in
react for a while now is called shallow
rendering this is the idea that we
render a component in tests but whatever
rather than rendering it as an actual
Dom element we just render we we return
an object that would represent what
would be rendered so to save the
overhead of actually rendering the the
component into a Dom and like going
through a big Dom to search for whatever
we need we can just get back this object
which represents what it would be like
if it were rendered into the Dom and
this is just another way we can keep
tests quick if we don't have to bother
setting up a Dom and tearing it down and
rendering into it and checking it and
searching it the test will be a little
bit quicker there might only be quicker
by a few milliseconds but if you add
that up over a big react application
that'll probably save you a good amount
of time in the long run particularly if
you're running these every time you know
every few minutes whatever
so if I wanted to start testing my to do
component I'd do a bit of setup first so
we import react the component the test
utils then I set up this shallow render
to do function this will take a and
return to do component that's being
shallow rendered so basically we call
crate renderer I have this dummy
function because the to do component
expects to be given a couple of
functions but at this point time it
every care about them we call render a
render and then we return render a get
render output to get this object back
now what this object looks like just to
give you an idea is so yeah the object
that the shadow renderer gets back looks
somewhat like this there are a few extra
properties but I've removed them to save
space they're kind of non important for
now so this isn't quite accurate I've
removed a couple of bits but this will
give you a rough idea so we get back an
object you see it would have rendered a
div this div would have had these
properties so there's the class name it
would have been given it has two
children it would have a paragraph with
these properties I don't have an anchor
with these properties so if you need to
make tests on what's being rendered you
can do it this way and save the the need
for a Dom so if I want to test say that
the the text of the to do so in this
case for this to do and if we want to
check that this text so this is the my
latest not led by milk if I wanted to
test that my component renders that I
can do it by kind of digging through
this this object so my first test might
look somewhat like this by the way if
you're thinking this is really verbose
it is and later on in the slideshow I'll
kind of blow your mind to something
makes it way better but for now stick
with me and we're going we're going bit
by bit so we're gonna make it to do its
name is by milk
I shall render to do which is the
function I showed you a couple of slides
back and then I just say it renders the
text in there to do and we say results
or props up children 0 don't props or
children is buy milk it really rolls off
the tongue but that does assert that are
our tests are um that our component is
rendering the text by milk so we have
noting that I wouldn't necessarily
always write tests like this and assert
every bit of text my component is going
to render but it's quite a good
demonstration then if I wanted to assert
say that the the component gets the
right class if that to do is done or not
I can do a similar kind of thing so I'm
they my to do done and then I just
checked result that pops up class name
and the index I've done to do is greater
than minus one
so if you're testing basic things like
custom classes or dynamic classes that
change based on some state or properties
doing it through shallow rendering is a
really nice way to do it without needing
a Dom but at some point you probably
wanna start testing user interactions I
think we've all been through the the
hellhole that is like end to end or
integration test we have to fire up a
browser and actually pretend the users
actually clicked and the way they break
about 50% of the time
but react does is really nicely because
react has its own synthetic layer on top
of events we never have to do that
you'll find your integration test if you
like or your high level test functional
test and 20s whatever you like to call
them and tend to be much more reliable
when you can write them more as is unit
tests really and need less of those
tests are actually firing for physical
browser one thing that's very important
though it's really tempting when you're
testing these components to reach into
react components like set a bit of state
or to reach into it to see what some
state is you should always try to avoid
that whenever possible because I I tend
to think of that as breaking the
abstraction the the input should be your
user action so that's clicking filling
in a form whatever it might be and your
output should be the rendered result you
should never you should try and always
avoid reaching into components to look
at their internal details try and write
your test as if you were a user if you
like so as I said we need a DOM and we
could run these tests in a browser and
just refresh the browser lots because
the browser has a Dom but that'd be kind
of boring I also really like have my
test in a terminal I like having a bit
quicker so instead we're going to write
we're going to use JSON which is a Dom
written in node and because of course so
so what Jess Dom does is it it basically
is a full Dom implementation that you
can run in node and we'll make react to
think it has a Dom so we install it
through NPM we do a small amount of set
up so you bases say if we don't have a
document create one this is jazz don't
watch Jess DOM and I'll just use like
some boring HTML set up a few things and
then we call this this function so now
any test that needs a Dom to be created
just has to import this module first and
one will exist if you like so the top of
my test file we import that setup file
and then we abort react when when react
first runs it does a bunch of checks to
see if it's in a Dom environment or not
so it's important that your JS Dom setup
is pulled in before reactors else react
will will
ten bill think that it doesn't have a
job so if we take the user interaction
of takling err to do look at how we
might do that we now actually need to
render a component into the Dom we can't
make do with shallow rendering anymore
in the future shallow rendering may work
with interactions but right now it's
much better to actually just render to
the Dom so we have test utils dot render
into document this is part of the react
test utils a Dom which does exactly what
you might think we give it some
component and it renders it one really
nice thing about this is it renders it
into a detached Dom node so no longer we
have to clean up the Dom in between your
tests which again saves you time and
effort and makes it less like the test
will will break so if I want to test
that when we click on when we click on
us to do that toggle it is called this
is how I might start doing it so if we
look down here first we have the to do
component which takes us to do and now I
actually need to pass in the done change
function because that's the the prop
that this to do component should call
with the right ID when I click on that
to do so I pass in this dong callback
this dong callback is way up here and
this is where the actual assertion
happens so it's going to take an ID and
I'm going to assert that ID is equal to
one because my to do has an ID of one as
well
and I've told tape at the top the we're
expecting once do so now we need to do
is make the click test utils makes this
pretty easy with the longest method
names known to man
so we call test utils dot find rendered
on component with tag we give it the
rent result which is this result here so
the result of calling render into
document so we give it that and then we
give it the tag into the paragraph yeah
and then we simulate a click on it which
thankfully is much more common sense so
we called test utils dot simulate da
click with the text and with that that's
it I wish I was doing more exciting to
show you but I think it's actually good
that it's not that incredible and react
makes it really easy so we have our
session all the way up here we render
our component here we search for
something here and we simulate the click
on it here and then when when this is
clicked this done change function will
be called and this assertion will run if
that thing is never clicked tape will
actually timeout because we told at the
top we're expecting an assertion if this
never runs it will never get an
assertion it'll error at us however this
is a bit weird this kind of approach and
some people don't like the way that we
have actually the assertion right at the
top and all the set up down below it the
ideal test should look more like this we
we set it up we interact all we we do
some invocation on the function and then
we assert on the results we've actually
got it backwards we've got an assert on
the result right at the top then we've
got a set up then we've got our own
invocation or in our taste clicking if
you don't mind this that's fine but I've
been kind of playing with a different
way of doing it which is using test
doubles and I'm a bit biased here I've
actually written my own little test
double library which I tend to use shock
horror but there are loads of them out
there like sin on test double J s etc
again what what library used to you
through your doubles doesn't matter at
all and a double kind of and stubs that
can all get a bit confusing but a double
is basically just a function that keeps
track of its calls so if I import double
from my doubler library and I create one
this function X using double dot
function I can call it once we've react
and call it again with amps of them and
then I can call I can ask X what it's
call count is and it will tell me -
because I pull it twice and I can also
get an array of an array of all the
arguments that it has ever been called
with so if you just if you only care
that a function was call
with the right arguments using a double
library is a really nice way to do it so
now I can swap my test round so my dunk
callback becomes a double so so fake
function and my assertion has become
that it was called once and the first
time it was called its first argument
was one so it was called with the ID of
one this makes my entire test at someone
like that and now we're in the right way
around we're set up interaction and
assertion so we got setup interaction
and assertion I actually like to
separate them with a blank line as well
in my test but that's time entirely up
to you
okay just to give you an idea of how we
might do form submissions if we look now
into the app to do component it's pretty
similar in kind of style it's it's a
react component and we have on you to do
which should be cooled with the right
thing the component looks somewhat like
this so we have this input it's got a
ref so I can get the value at it really
I should like have a controlled input
input excuse me but I cheated and used a
ref so I grabbed the value of it if we
have one I'll call on you to do passing
object with a name set to that input and
then I'll clear the value out again so
first we'll render add to do this test
is probably going to be pretty similar
to last which hopefully shouldn't
surprise you too much and I'll create a
double as well so we can track its call
count then we use the slappy method
names to find our input and set the
value to buy milk and then I'll find the
button and click the button again
straights before and finally we can make
basically the exact same assertions it
was called and that the arguments the
first time it was called the first one
of those was the object name buying milk
and that was like that and you'll find
as you as you write react tests a lot of
your tests will look like this and I
think this is a really good thing that
the rear tests they're not boring but
they're just pretty straightforward the
testing story for react is really nice
you often just do exactly what you think
that you don't have to like fake clicks
or do anything you just kind of trust
react test utils to do all that stuff
for you
so so far we've we've tested the
lower-level component so we tested the
to do component we've tested the absolu
component but you probably want some
like high level test that your entire to
do the application is rendering some to
dues when you add a new one it adds
that's a list when you delete one it
deletes it and so on and you'll often
have a few components like this in your
application which kind of encapsulate a
bunch of states in our case it's that
siddhu's component so these tests
although they're they're kind of a cross
between unit and integration tester
they're a bit high level we have those
lower level tests that cert that the
right functions are being called so we
have high level tests that assert that
the right things get rendered or not and
I mean that's it it doesn't really
matter what it is that is the component
that's pretty small to read so if we
test adding it to do from the point of
view of this high-level component it's
gonna be pretty similar we render now
this whole - duze component I find the
form input I fill it in I find the
button and I click it again and now what
assertion do we actually want to make
all we did when we tested the app need
to do component was tested it would call
that that property function with the
right value with the right value from
the the user input so we actually what
to do in this test really is test that
it will render the new and the new item
to the screen so you ready for another
snuggly name method yeah you are we've
got scry rendered Dom component with
class I didn't even know what this meant
when I found this I've no idea what's
crimen and I I'll tell you what it does
in a minute because I tweeted in someone
told me and then all I'll do is I'll
assert their afford them shown because
I've actually can't coded the state of -
dues to have three in so the result of
of clicking this should be that there's
now a fourth one rendered so I search
for all the items in here with this
specific class and I saw that there
afford them scry rendered Dom components
with class which rolls off the tongue
although I guess they were at least for
those so scrying is like the the
practice of looking into a translucent
balls like a crystal ball so I believe
that's where the name comes from I just
called it search or something but they
go
yeah that's just me then again I'm not
the one clever enough to work at
Facebook so there's probably a very good
reason and I'm being a horrible person
okay so yeah our full test ends up
looking somewhat like that anyway as you
might have noticed and I kind of hinted
at it a bit I'm not sure if you picked
up on the subtle jokes but test utils is
is pretty verbose right it is good is
really good but it is very verbose but
thankfully I'm not the only one who
thinks it it's verbose the people at
Airbnb also think it's verbose and they
wrote a library called enzyme enzyme is
a JavaScript testing intensity for react
which makes it way easier to find and
assert and manipulate react components
as you need to it kind of takes a lot of
inspiration from jQuery and the way you
lets you find elements and it's just
it's just so much nicer it's like an let
you can think of it as a layer on top of
test utils effectively but it's worth
noting as well just for the record
enzyme is entirely under pinyin aces
about which testing framework to use it
with so again I'm using a tape marker
Jess Jasmine and so on will all work out
so you find with enzyme to install it
like so and what you'll find of enzyme
is it doesn't really all it does it just
make things much nicer and cleaner and
give you nice and methods to cool so if
we start with shallow rendering if you
remember earlier I had to create a
renderer and called like render a dot
render and then render or get output to
get that object I can swap that all out
for just shallow from enzyme which makes
that much much cleaner
enzyme also provides so for shallow
rendering enzyme also provides an API
for searching through that big object
that was representing what would be
renders their Dom so if I take my test
from earlier check out this line here
now so instead of doing results up flops
doc children's square bracket 0 dot
props whatever that was I can staring
call result dot fine P text which I
think does make a little bit more sense
there are tons of methods enzyme gives
you to search through in a sir on the
output there's a link there to the the
documentation enzyme also makes it much
easier to test user interactions to it
provides this mount function which is
the equivalent of test utils render into
document if you like so we can import
mount and this is a bit small but you
can see up here we're calling Mount with
that component I can then call form dot
find input get 0 to get the the Dom
element set the value again to buy milk
I can call form dot fine button dot
simulate click so again that's just it
reads much nicer it's much clearer what
it's what it's doing and the tests
aren't so long in line lengths as well
so you can work on them on a small
laptop there's full documentation there
as well for enzyme and just as a final
bonus I've run all these tests so far in
node so as I'm working on these tests
I'm running them in the command line I'm
a nerd I use vim I've got so many short
cut they're running lots in a terminal
time that's great but at some point you
probably do want to run them in a
browser just to be safe or probably in
browsers thankfully it's it's pretty
straightforward to do this is the only
bit of the the talk that's specific to
tape but solutions very similar to this
exists for other libraries so you should
be able to use the kind of same ideas so
the first thing we're just going to
bundle up all our test code so I use
browserify this would work just fine web
pack or whatever else there'll be five
more ones first time I've sat down so we
bundle up all our tests into a big
client-side file and we use a thing
called tape run to run them in a browser
this will take our test fire them up in
a browser of our choice run the test and
send the output it straight back to our
terminal it's all I do is I take my
browser if I thing and then I pipe it
through to take run and I tell it to run
them in Chrome just as a demo you can
run it in Firefox ie if it's on your
machine Safari operates
etc and hopefully just a final bonus
video I think so I run them here it
fires up chrome finds up chrome and it
runs them and I forgot to format them
nicely but we get more back as well so
you could swap out chrome here for
Firefox Opera etc there's my backup
screenshot and went in case it all went
wrong okay so I'm on like 28 minutes
just give you a few links I am most a
lot the content from this talk comes
from a blog post I wrote at Christmas
for the 12 devs of Xmas code at UK
there's a link there I wrote this repo
with all the tests and I've since by the
way this this blog post is a little bit
outdated so I've this this repo is
actually up to date as of this
presentation I pushed a bunch of stuff
today
once I've kind of sat down and taking a
deep breath I will upload the slides to
speak a deck and I'm speaker concise
Jack Franklin I don't I don't know if I
have time questions now maybe I'll
squeeze in one but I'm around for the
rest of the day and at the after party
as well so please please come and grab
me I've got pusher stickers that's
that's it I've got fish stickers Jack
Jack underscore Franklin on Twitter Josh
go calm but thank you very much for
listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>