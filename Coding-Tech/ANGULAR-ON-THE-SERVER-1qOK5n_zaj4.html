<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ANGULAR ON THE SERVER | Coder Coacher - Coaching Coders</title><meta content="ANGULAR ON THE SERVER - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ANGULAR ON THE SERVER</b></h2><h5 class="post__date">2018-03-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1qOK5n_zaj4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's talk a little bit about what
we're gonna see today we're really here
to use node to take full advantage of
the power that exists in angular so to
make sure they're all on the same page
and your as a platform that makes it
easy to build applications with the web
so it's a front-end framework it's one
of the most popular if you look at
things like Stack Overflow or github and
we're really focused on empowering
developers in a number of different ways
and one of the ways is by bringing the
power of angular closer to the server to
solve a few different use cases so
today's talk we're really gonna go
through things in three sections first
we'll talk a little bit about a project
that we have called angular Universal
then we'll talk a little bit the state
of the technology as it exists today and
finally we'll get into some of the
future what's coming down the pipeline
what are the things that we're working
on to make this technology even better
so let's start off talking about angular
Universal this is a project that we've
got going on that's really designed to
enable server-side rendering of angular
but why do we want to do this why do we
care about server-side rendering because
anywhere applications are really
intended in some ways to be run entirely
on the client side
they run offline if you're using a PWA
or shipping it via something like
Cordova they build these really rich
engaging user experiences we have router
we have HP calls we have all these
really cool things that are designed to
make the client-side experience better
why why do we care about the server side
when it comes to angular or a
client-side framework I like to think
about this in the way that the
applications we're developing are being
consumed there's actually two groups I
think about as computers and I think
about it as users and so when we think
about computers browsing the web we
don't tend to think about their
experience and their feelings of using
our applications but computer
experiences are actually very important
a huge percentage of web browsing that
happens on the Internet today
is actually done by computers and not
just humans and so we really have to
worry about the things that a computer
is seeing when they download our
application when they run it and so
there's a number of different use cases
that we have to think about when it
comes to computers the first is search
engines if you look at a search engine
like Google search we see that the
search engine is capable
running our application and so if I'm
shipping a single-page application down
to the browser that application is able
to run we can look at the title changes
that happen we can look at the metadata
descriptions that happen and then the
search engine is smart enough and
capable enough to actually index and
render that fully rendered application
and use that data that you've actually
fetched client side when it's updating
its index but there are other search
engines today that are not capable of
that and so by rendering your
application on the server ahead of time
we can ensure that even search engines
that aren't capable of running
JavaScript are able to index and see all
that content for search engine
optimization purposes another really
important group of computers that are
accessing our applications or what I
like to call scrapers so these are
systems that are not designed to
necessarily index but they actually want
to have a peek at your application so if
you're ever sharing content on a network
like Facebook or Twitter often you'll
see that very very nice preview of your
application right you'll get that
thumbnail it's based on the HTML
rendering of your application but these
scrapers often are not capable of
running JavaScript and so shipping down
to the browser fully rendered HTML can
be very helpful in order to enable these
things to do this sort of thumbnailing
another really interesting use case that
we've looked at and seen kind of take
off in many ways is the use of amp or
accelerated mobile pages and so this is
both a new index that exists on the
Internet as well as a set of results in
Google search that's really based on a
new standard called amp and what amp
does is allows us to build web
applications that are designed to load
extremely quickly and with very very low
overhead and so what amp does is
actually restricts you to a subset of
HTML and JavaScript and you can't really
do a lot of very rich things on the
client side in order to be in the amp
indexer to be cache as an amp
application but the nice thing is
because we have projects like angular
Universal and because we're able to do
server-side rendering of our single page
applications we can actually ship a
client-side rich application as a static
set of HTML and then as soon as the user
hits a navigation link then we can
actually fill in that rich client-side
experience and you can take this one
step further if you come
this with technologies like progressive
web applications or pwace because in
that amp page while it for the most part
has to be static HTML we can also
preload a serviceworker in the
background that can actually go and
download the rest of our application so
the moment that the user hits the next
button we already have all of that
content all of our entire application
available on the client side ready to
run but we talked a little about
computers but I like to acknowledge that
humans matter too a little bit
so while we have these really rich tools
by angular for building client-side
experiences there can be some benefits
for users as well doing server-side
rendering so if we do server-side
rendering and we're able to ship down
completed HTML and then bootstrap a
client-side application on top of that
we're actually going to get a perceived
load time benefit and so what this means
is the user thinks that the application
is working
sooner than actually is and so while
from a technology a pure text and point
the application actually takes longer to
load because first we have to have the
browser parse all of this pre-rendered
HTML and then we have to run the
application on top of it you can manage
that and you can actually get a
perceived increase or a decrease in load
time so let's talk a little bit about
angular Universal in the technology as
it exists today and is usable there's
actually two related projects that I'm
going to talk about so the first is the
angular Universal project which is the
kind of global way that we think about
that and we group the work that we're
doing to enable server-side rendering
with it angular and then a lot of the
work is actually happening within the
core mono repo of angular stored on
github at angular slash angular and what
I mean by that is that we've built now
angular into several different platforms
and so you're gonna see things like
platform browser platform browser
dynamic and then with the 4.0 release
back in March we actually did a major
update to our platform server and so now
platform server is the module within
angular that's capable of doing all this
server-side rendering and has a lot of
the intelligence that makes this
possible so the way we do this is a
single kind of method that gets
everything started from the standpoint
of platform server and that's render
module Factory this method is really
important because it takes all of the
things that we wanted
and gives us back a string so let's take
a look at the signature for this method
so the first thing I'm gonna hand it is
a module factory so this is basically
the reference to my application this is
the very old it's gonna contain all of
the compiled modules all the different
pieces and chunks that exist my
application and then I have a number of
different options that I can pass it so
the first is document so what I can do
is I can pass it basically what equates
to an index.html file so I can either
make one up on the fly that's gonna get
rendered or I can load that from disk
which will see it in a little bit second
I can pass it the URL that the user is
requesting so we do this because we want
to actually render the application in
the right state and for the web a lot of
our application state is stored in the
URL and we want to ensure that the
router is going to be loading the right
sort of content and rendering it to the
user last because we're using angular
because we have this very nice
dependency injection system you can
actually supply additional providers and
what these providers can do is they can
override functionality or change
behavior within your application because
you know that you're running on the
server and what you get back from this
is a string so this gives you a promise
of a string and then that string is
really your fully rendered application
that went through all of the
bootstrapping it went through all of the
rendering your routes resolved any HTTP
calls resolved and then once the
application is stable once there's no
more changes being run and there's no
more pending asynchronous events then
we're gonna give you back that string of
your application so if you look at this
in a real application we're gonna see at
the top or importing render module
factory and platform server I'm gonna
then load in my bundle so this is my
compiled angular application then I'm
gonna render that module factory pass in
a couple of parameters instead of
pulling in an index that HTML here I'm
actually pulling in just a very simple
string with the necessary selector to
get things started and then I'm
constable logging out that application
in order to see what it rendered and see
how it works so this is really possible
because of the architecture that
underlies angular so we think about
ourselves as being not Dom dependent
whether that's virtual Dom or otherwise
because what happens is everything that
happens in angular happens in more pure
methods so when you have a component
when you have a service these
are actually just pure es2015 classes
that are we're operating on that we're
decorating that we're passing back and
forth and because they're pure we don't
actually need to spin up any sort of
fake browser and most of the processing
that happens in angular happens in that
pure JavaScript world and then at some
point we hit the renderer and then we're
actually gonna render out and say hey
how do we turn the state of this
application now into HTML that can be
consumed
there's even very cool projects like
native script that allow you to build
angular applications that render
natively to mobile platforms using
native UI widgets in a very little bit
of a different way so we also have very
powerful tools that we're working on in
order to build better integration with
node and so one example of that is a 10g
universal / express engine which is a
basic minimal Express implementation for
middleware that allows you to
automatically take in requests from the
user pass that into angular Universal
figure out the URL figure out the
document we should be loading render
that out and then return that to the
user and so if I was using this
middleware I would just basically you
need to import it run app done engine
app dot set set everything up so that we
know how to use angular Universal and
then I'm going to respond to any
requests with a corresponding Universal
request and with that all of my users
are you gonna automatically get this
fully rendered HTML that will then
bootstrap on top with the real
application so the remaining hurdle for
doing this compared to how you might
have been doing angular even a few weeks
ago is that whenever you do an angular
build you're actually getting out a UMD
but no js' in order to do the
appropriate require on the server we
actually need commonjs so if you ever
want to look into your dist folder and
actually see what these things look like
so on the top there you have the common
j/s there's the the first little snippet
and they're on the second you have the
UMD so you can tell immediately that
it's not trivial to turn a UMD into a
common J's bundle which means if you
wanted to ship a common j/s bundle even
a few weeks ago you just need to eject
from the CLI whippet and configure a
fresh web pack config and so on but
we're really trying to make this a lot
easier than that as you guys know and it
was really focused on owning the
developer experience and trying to
each of the pain points and then
eventually eliminate them to make a very
easy developer workflow that empowers
you with all the kind of magic and all
the tools that exist within angular and
so here the CLI is to the rescue so the
angular CLI is again focused on
automating all of the kind of tedious
parts of building an angular application
as well as making developers more
powerful and so the tools that I'm about
to talk about are available today they
are in RC 0 so at angular CLI at next I
think the specific version number is 1 3
0 which is gonna be coming out very very
soon here in the next few weeks probably
and I want to give a big shout out at
this point to a gentleman Jason Jean who
is one of the big open source
contributors to the angular Universal
project and to angular and the CLI that
made some of these things happen so he
actually works and leads the use of
Universal at Forbes so when we think
about our angular CLI application
typically we just have a single build
target right we're shipping UMD is we're
shipping a bunch of JavaScript bundles
to the browser that then are gonna be
run and interpreted by the browser in
order to give the users their
application and so what we do now with
the CLI because of two very important
capabilities is we wrap that platform
browser application with a platform
server application and we're able to do
this because the CLI has multi app
support which means if you look in the
angular CLI configuration file the
angular CLI JSON file we can actually
see that the apps configuration
parameter is actually an array I can now
set up a bunch of different angular
applications they're gonna share
configuration they're gonna share files
and allow me to quickly switch between
different builds pulling in different
files having different build targets and
so on and then the second part that is
what we just shipped in the latest RC is
the ability to actually have platform
server as part of our build
configuration so if I wanted to take
advantage of the CLI support for
rendering universal applications I would
first create a new application so to say
so I'm making app server module TS and
this is just a very simple angular
application it's basically going to have
just a blank module and then it's gonna
pull in my angular app so I normally in
you have an app module and I'm just
gonna import that into a new module and
then I'm also gonna inject the platform
server by an import then I need to
actually set up the bootstrapping so in
angular when it's running on the client
side we have an entire bootstrap process
but on the server all we need to do is
export our module that we just defined
and then we want to set up RTS
configuration so our typescript
configuration in order to instead of be
rendering to es2015 module syntax we
actually want to render now to commonjs
then we need to set up our application
in the CLI so we're gonna copy and paste
that existing CLI configuration for the
existing app and we're gonna swap out a
couple things so such as saying platform
server and then point to the main file
that we created and then you're gonna do
a build so first you will build your
existing application as it exists today
so that will give you the UM D that you
run in the browser as you always have
and then on top of that we're going to
build again the server application and
the reason we do that is because when
you ship a angular universal app to the
browser
you're gonna ship static HTML and then
you're gonna want to build on top of
that and replace your app root with the
actual live application and so by having
both of those we have the version we're
gonna ship to the user and we have the
version that we're gonna run on the
server so then the last step is up to
you a little bit which is however you
want to configure note or Express in
order to actually serve that application
actually called the render module
factory method so we actually have this
full step-by-step process on the web
I'll repeat this link a little bit later
so a couple points of guidance if you're
building angular applications on the
server you really want to think about
your application as not being fully
dependent on the browser so there are a
lot of browser things you can do such as
set timeout native element accessing
window well some of these things work
and we're working to improve the support
for some of these things don't
necessarily assume they're gonna exist
the more pure you can be with your
application the more isolated from the
browser you can be the more assured you
can be it's going to work automatically
on the server out of the box another
cool thing you can do and way to think
about it is do feature detection so
we've added in platform server a is
platform server method where you can
actually just call that method to check
if you're running on the server if
you're running on the client if you
wanted to write some custom code
or you could possibly just use window so
I actually recommend this a little bit
more so use feature detection and just
look is there a window option there is
there a window object that is available
if there is then I am in a certain
context if there's not I'm in in
different context and I can make my own
choices about how I want to run my
application
another community project that we've
added to the angular github repository
is called pre-boot so there's a bit of
an uncanny valley that can happen
between the time that you send a fully
rendered version of your application to
the user in the time that the
application actually bootstraps and
renders to the screen and so in order to
avoid this uncanny valley where for
example if a user selects an option
after bootstrapping maybe that option is
going to be revoked what you can do is
something called pre boot and what pre
boot does is it very quickly and early
in the process listens and sets of all
the event hooks that you were going to
need later in order for us to be able to
replay those events after the
application is bootstrapped so let's say
the user is on a very slow connection
they receive the fully rendered version
of the application they click a button
they tight or they click on an input
field and type in something you want
that event to replay and so the after
the fully rendered client-side
application is there you want that input
to be filled and all the variables to be
set using angular using the framework
just as you normally would and pre-boot
accomplishes that so let's turn last
here a little bit to the future in terms
of where angular Universal and angular
on the server are headed so I talked
about 1.3 of the CLI being the version
that now has this available we're in our
sea right now very soon we want this to
be the standard release of the CLI and
so we'll be releasing that we're very
excited for people to give it a try
log bugs let us know what they think
about it but really we want to take this
further and find other ways to use the
CLI and enhance that support so if you
recall I talked about kind of a three or
four step process of setting up your
application to use Universal but what if
we could make that automated what if we
could further say hey here are the best
practices let's just bake this in so
that when you create a new project you
could have a example a flag that says I
want to use Universal or maybe you want
to upgrade an existing application and
add a you
reversal shell on top of that those are
things that we can probably do for you
and so definitely look for those coming
in the CLI in the future material design
is the angular component library that we
work on and that we recommend so on the
angular repo or on the angular github
user we actually have this material
project which is a collection of
components that implement the material
design philosophy from Google and so if
we look at the current status of that
project today it's in beta headed for
final in the future but a couple of the
components are still dependent on
browser interactions but that's
something we're working on and we expect
and it said that before final all of our
components should work on the server
using angular Universal additionally one
thing that we're really thinking a lot
about is hydration so I'll talk about
hydration from a couple different
perspectives the first is using
hydration or what we're considering a
generic state transfer API what if I
know the state of my application before
it actually bootstraps and I want to
pass that in so a case of this might be
I ran an HP call on the server and I
want to pass the results of that he
should be call down to the client-side
application so that that HP call is not
made again and so we want to enable that
the other type of hydration that we find
is really important is that you're
shipping down a fully assembled HTML
page and so the browser is rendering all
these Dom nodes iframes are rendering
and loading content etc and when the
client-side application bootstraps we're
actually replacing all of those and so
we're looking at ways how could we
instead of replacing all of those kind
of commandeer all those components set
up all the event listeners and all the
hooks appropriately so that things
continue to work this is a really big
deal for companies that have a lot of
things like advertising for example
because you don't want to advertising
impressions for one user visit and then
lastly we're really looking at other
ways of exposing more Dom on the server
and so there's a lot of different use
cases for having a little bit more Dom
so we don't want to become Dom dependent
but if we could give you a few more
features we feel like that would be very
powerful one of the places that we're
looking at this is for example using
electron or what if I want to have more
of my application run inside a web
worker on a separate thread if you could
have more access to the Dom as part of
your angular application that would be a
very powerful thing for you
there's also a couple other cool
projects that exist on the internet that
I want to give you a preview of and so
firebase is a product from Google that
has a lot of really really nice tools so
they've got a real-time database they've
got storage they've got hosting they've
got bug tracking and things like that
one of the features that they recently
announced and recently shipped is called
cloud functions and so this allows you
to say hey when this event happens run
this on my server and so this is all
using node under the hood and what
they've done is they've connected this
cloud functions feature with their
hosting feature and so now what you can
do is you can actually say when a user
requests this URL run this JavaScript in
order to figure out what I want to send
down to the user and so we we have a
couple examples online of where now you
can build an angular application with
the common J's bundle render it on the
server using firebase cloud functions
and then host it so you don't need to
set up a server at all everything is
running in firebase another thing we
really care about is making progressive
web applications better and more
powerful and so all of the work that
we've done on angular Universal is being
used here for things like rendering an
app shell figuring out which routes
exists in the application and so this is
all available today under ng pw8 tools
and the last thing that I really just
recommend you do to leave you with here
is just go ahead and take a look at the
angular Universal project we've got
excellent steps for getting started here
at bit ly slash universal dash CLI and
hopefully that will give everyone a big
kickstart thank you so much for having
me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>