<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CHARACTER CODES EXPLAINED | Coder Coacher - Coaching Coders</title><meta content="CHARACTER CODES EXPLAINED - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CHARACTER CODES EXPLAINED</b></h2><h5 class="post__date">2018-01-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1AjfZuryQtI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so character codes don't start with
computer systems they start first with
data communications or communications in
general just human communication and
then data processing and eventually
communication and data processing come
together in computing so we're gonna
start at the very beginning the first
character set the morse code designed by
Samuel Morris an American portrait
painter he also had a hobby in
electricity and he worked with some
partners to develop a telegraph and
Morse put together the code that
transmitted words across their Telegraph
and it's a very very simple code because
they're telegraph all I could do was
transmitted to States it was either on
or it was off so Morris figured out a
way to turn that into a communication
channel so he has a language that's made
up of two symbols dot and dash and we
can represent these in binary so a dot
is a single one and a dash is three ones
and then in order to tell the difference
between the dots and the dashes you need
to put some zeros in between them so
he's got zero for the particle space
that's the small separator between a 0
and 1 and then there's a letter space
which will be the space between the
letters and then a word space which goes
between the words if you're a musician
it's easier to think about this
musically so you can think of a dot as
an eighth note and a dash is a dotted
quarter note and then an eighth rest is
the particle space a dotted quarter rest
is a letter space and approximately a
whole rest is the word space so here's
an example of four letters represented
in the Morse code so the letter T is a -
what
two dots letter M is two dashes and an E
is a dot
so horse took a look at the frequency of
letters in English and chose the most
popular letters to have the shortest
codes so this is not only a
communication code it's also a data
compression code it's the first data
compression code and it's a code that
works in time most of our codes work in
space you know you can think of a word
containing some number of bits or even a
packet containing some number bits but
this is a because it's musical it's all
happening in time so remembering the
word time will help you to remember
these symbols that the consonants are
dashes the vowels are dots and the most
frequent frequent things like the e will
get the shortest code okay so you now
know four of the letters in the Morse
code in fact I'm going to teach you all
26 letters of the Morse code because you
might need it someday you might be
trapped in a mine or on a disabled
submarine and you're gonna need to be
able to get a message out and all you're
gonna be able to do is tap on the hole
with a rock or something but you'll be
able to do it because you're going to
know the Morse code
okay the fifth symbol is the V which we
can get from the V for victory
Beethoven's fifth so you all remember
Beethoven's fifth symphony begins
da-da-da-dah dot dot dot dash okay
that's the letter V okay v4 five you all
know the SOS of the International
distress signal it's dot dot dot dot dot
dot if we break it down into letters the
S is three dots and the O is three
dashes this is the opposite of the
dashes being consonants but you know we
got a couple exceptions so you can
remember that right so dot dot dot is s
dash dash dash is o H is a little tricky
to remember
it's four dots so I recommend you think
of the 4-h club and and the advisor to
the 4-h club mr. 4-h himself Harry
Herbert Hoover Hever okay for the rest
of the letters okay so you now know six
letters right for the for the next
twenty
we're gonna have some mnemonics and this
is L the mnemonics are going to work so
I'll give you a letter and I'll show you
the the Morse code for that letter and
then I'll have an English word which
contains that letter in which the dot
corresponds to a vowel and the -
corresponds to a continent consonant so
a is for M everybody got that
and everybody understanding a okay let's
move on B is for buh B my bow it's it's
beautiful isn't it not my friend
c is for Coco everybody loves Coco right
you love Coco that's why you can
remember that C is for Coco this next
one is going to be really shocking and
upsetting
D is for die but because it's so
shocking you're gonna remember this one
the D is for die e you've already seen
he is one of the time things it's one
dot and F is for Fe that's right Luffy
everybody say you fee
okay so AM Boko code ie Luffy
everybody with me so far we're learning
the Morse code G is for ganoub for
programmers that should be a really easy
one having G canoe G canoe is that
outfit that gave us a failed UNIX clone
and a software license in which free is
not free right everybody knows that one
we've already seen H the 4-h club Harry
Herbert Hoover Heber
I we've already seen i-i-i write two
dots and I J hey J what do you say hi
JJJ you what i JJJ
k is for a kit right that's easy kit
okay kit up maybe yeah K and L is for
soothing aloe you can't forget that L 4
L oh of course
so canoe 4-h III by JJJ kit and aloe
everybody still with me let's learn some
more M we already saw is one of the time
letters it and it's good
mmm good that's the letter M is mmm good
and oh no got it okay we already saw Oh
from the SOS P is for Expo you might
imagine next year there's going to be a
big Expo in which they're going to
announce a better mnemonic for the
letter P so we're all looking forward to
that Q is a bit tricky cuz it's hard to
make words out of Q so whenever you have
a Q if you're likely to have a you after
it so we got that pair and we're gonna
wrap it in quotes but we don't have
quotes so we'll use the letter Q for the
quotes because Q is for quote and so we
get Q qu q okay got it
r is for era this is the era of Morse
code are ya okay yes we already saw in
the SOS and the distress signal
we already saw T in the time letters you
out o UT out okay
we already saw a V Beethoven's fifth but
uh W is for the wise old owl that's easy
to remember W and the owl because he's
so wise X X is another hard one but
fortunately X rarely happens in English
so we're safe but you know it's XO o X
you're not gonna remember that but
you'll probably be okay
then why yuck
so you know if there any little kids
here I don't see any little kids if
there were any little kids the two
symbols they're gonna remember tonight
are goofy and yuck that's for sure and
then finally at the end of everything is
Z of course so what comes after zu z zu
right that's the end right z zu is the
last so you now know Morse code you're
not good enough to get an operator's
license but you could probably recall
this and make a list and then you can
tap it out you know you might be on that
disabled spaceship and you need to alert
the fleet you're gonna be able to do it
someone's gonna say my god that's Morse
code and we'll be saved
okay so moving on the next
communications code was the Bedok code
which was invented by emil Bedok who was
a french calligrapher he wanted to
improve on the telegraph so instead of
the operators having to be entering a
stream of bits that instead you would
have a keyboard that would look like a
musical keyboard with five keys on it
and you would chord in the letters that
you want so you would have to memorize
the letters in order to get them in and
this keyboard would be attached to a
paper tape punch which would produce a
string of paper tape with the holes in
it and then that could be transmitted
there was another guy who came out and
so if ever heard of baud rate
which is yeah the couple the old-timers
going on I remember moderates
badas usually bit yeah well it actually
means bits per second but yeah it's slow
is also another meaning
so was named after this guy so Donald
Murray who is a news New Zealander
improved on Bedok system he came up with
a much better keyboard so it had a
button for each of the letters and so
the operator didn't have to memorize the
binary code so you just go punch punch
punch punch and he could have picked any
keyboard and unfortunately he picked the
QWERTY typewriter keyboard the QWERTY
typewriter a keyboard is terrible by
design in order to try to prevent the
jamming of the mechanical keys and it
wasn't completely successful in doing
that but that's why it's got that
bizarre layout and Murray could have
said well we don't need to do that
because you know when you push a button
we're closing a circuit which is gonna
drive some pins through some paper tape
so it doesn't matter what order we put
the keys in he could have done something
rational but he didn't and so we're
still stuck with the QWERTY keyboard
everywhere this is the first time QWERTY
is used in electronic communication and
and it's still being used in electronic
communication so this is a refinement of
the code that those two guys worked on
and it became a standard one of the
first telegraphy standards this is
International Telegraph alphabet number
two it was a 5-bit code which allows
them to encode all of the letters Murray
scrambled the codes around in order to
reduce wear on the machinery so that
instead of optimizing for time he was
optimizing for bits where each bit would
cause a needle to drive a hole into a
piece of paper and those pins would wear
out and so in order to reduce wear on
the machinery he had the most common
codes have
the smallest number of bits so for
example e is a very popular letter it
only has one bit and T is also a very
popular letter it only has one bit and
since the operators didn't see the codes
it didn't matter that they were kind of
random then there's a code for space
carriage return and line feed two
separate codes because that's how his
printer worked the most interesting
thing that bodo did was he added a
couple of shift keys so there's the
figure shift and the letter shift so
when you're in letter mode you get these
codes and when you're in Figure mode you
get these codes so that gets you the
digits and the special characters which
was a really clever idea so they managed
to get you know 60 or so characters in
just 5 bits and they decided to have 2
codes instead of 1 they could have just
had a toggle shift but there was a
concern that the telegraph lines were
very noisy and if there was a line hit
then a shift code get get garbled and
that means everything after that is
going to look wildly wrong so to make
the system a little bit more resilient
they have two independent shift codes so
the next step happens a bit later the
Hollerith code so Herman Hollerith
developed a data processing system using
punch cards for the 19 or for the 1890
census the US Constitution requires that
every 10 years we have a count of
everybody so we can figure out how to
staff the House of Representatives and
it was taking too long to do with pen
and paper so Hollerith figured out a way
to do a lot of that work mechanically
and that turned out to be a big business
a number of companies were formed and
after a series of acquisitions and
mergers in event holler Asst company
eventually becomes International
Business Machines or IBM
and in 1928 IBM wanted to figure out a
way to get more information onto the
cards because with Hollerith little
circular punches they can only get so
many characters and they wanted to get
more so they came up with a system in
which they could get 80 columns on a
card each card had 80 columns and 12
rows in which you could punch holes and
at the top there was a blank space where
you could print stuff with ink so that
humans looking at the card could figure
out what it said although people who
were skilled with this code could
actually look at the punches and tell
you what it said so they came up with a
very straightforward way of encoding the
characters so first if in the top line
it's called the 12 row or the 12 punch
or the X punch or the plus so if there's
a punch there then you get a plus sign
the next row you get a minus sign and
then 0 1 2 3 4 and so on to 9 ok pretty
straightforward and they wanted to be
able to do letters too so letters are
slightly more complicated each letter
requires two punches because we've used
up all the one punch codes so we use the
the plus Rho and the digits 1 through 9
and that gets us the letters a through I
and then we do a similar thing with the
minus row and the digits 1 through 9 and
that gets us J through R and we do a
similar thing with the zero row but this
time going to 2 9 to get S through Z
this pattern should give you 27 letters
but we only need 26 so they needed to
drop one of the codes and the code they
decided to drop was 0 1 and the reason
was that you had two holes with just a
tiny little piece of paper between them
and there was a concern that given
though crude machines of the time that
they were using metal wire brushes to
sense the holes in the cards that it
could rip the card which could cause the
machine to jam or cause bits of little
pieces of paper to accumulator in the
machine and eventually catch fire so to
avoid that hazard they skipped that code
then you could have three-letter codes
or different combinations of two whole
codes to do the special characters and
unfortunately that never got
standardized very well so different
machines would have different codes so
taking a deck of cards and moving it
from one system to another could get
really complicated because all the
special characters could get
misinterpreted so now we finally move
into computing when computing starts in
the late 40s the first computers have
six bit character sets these machines
were mostly concerned with computation
mathematical computation and so six bit
character sets were were fine so this is
one that was used at IBM their character
set was based on a praetor that they
were using with their punch card
equipment which they modified in order
to work with some of their early
computers and so their printer only
could print 48 different characters and
so they left a lot of these codes blank
and they had a few weird characters like
like that so what is that I don't I
don't know what it is oh it's called a
square lozenge I don't know what it
means but it was on their punch card
equipment and so people would use it
because there weren't very many
characters available so that meant
whatever you really wanted it to be you
would use that because that's that's all
it is you know they didn't put a plus
sign in it which was like I don't
understand as so the next step forward
is Fortran Fortran is the first really
successful programming language kind of
changes the world it was
also developed at IBM and it gets ported
to all of the IBM machines and then
everybody else makes their own Fortran
systems as well it's the first big
programming language and the guys were
designing Fortran couldn't figure out a
way to make a programming language out
of that so they said we need these
additional characters and so they just
said if you're going to have Fortran
you're gonna have to meet have to get
these characters somehow and so IBM said
okay we'll try to figure out how in our
next printer we can we can add those so
in a later version of there be CDI
C code they've added more characters so
something that's weird about this you
look at the arrangements of a you know
Jas what they did was they just took the
Hollerith code and pushed it into the
characters head okay so we have an
expectation that each letter is going to
be one away from the next one but that's
not the case here you know I plus one is
question mark not J okay so it's gonna
be a little challenging you know write a
sort routine for this character set okay
and they got some weird characters like
these guys so they they created a
magnetic tape system to work with this
computer and they reserved these four
codes has special marks on the tape and
they recommended that you never use
these codes in your programs because if
you try to write those codes to the tape
it's going to screw everything up so
they picked characters that they thought
no one would ever want to use then they
had a problem they started selling stuff
in Europe and found that this isn't
enough letters that you know like in
Scandinavia they need three more letters
and so they decided well you can take
those letters and/or those characters
and replace them with letters in
whatever country you're in so this kind
of begins the
i 18n problem that this is where it
starts and it took a long long time to
fix it now turned out every company had
their own character set so for example
control data started with the IBM set
but kind of changed a little bit because
they were more into scientific computing
and so they added some characters that
they thought people who are programming
about numbers we care about things like
not equal less than or greater than
angle brackets or less than or greater
than that's good stuff
right another company that was doing
brilliant work the Burroughs 5000 series
is maybe one of the most interesting
architectures ever designed and they're
still doing the IBM thing except that
kind of straightened it out a little bit
at least a comes before s now so that's
good and I really like that they put
zeroes at the top row that means the
character code for 0 is 0 does that make
sense that absolutely makes sense that's
brilliant as a programmer I love burrows
I that makes so much sense to me and a
pretty good nice set oh and they got an
arrow which is what we should have had
for the assignment operator Fortran
didn't have this because they just
didn't air dare to ask for another
character and so they were forced to use
the equal sign for assignment because
they had no other options and we're
still doing it it just doesn't make any
sense we should be using that already
that that makes sense so the US Army is
buying lots of computers and you know
each of its computers comes from a
different company and they all have
different character sets and trying to
exchange information between all these
machines was really really hard so they
decided to fix the problem being the
government so they created a character
set of their own called field data and
field data was a seven bit character set
which was intended to run on all army
computers and that would let them
communicate
but because it was a and there's some
pretty reasonable stuff so they finally
fix the alphabet right so it it's all
continuous so I like that a lot and it
still got some of these weird IBM
characters in it but you know that's
okay and some of these could be replaced
by other characters for and for some
reason they they moved all of these
characters up to the top half of the
seven bit character set and they leaved
the left the bottom half of the seven
bit character set undefined so there
were a number of projects in the army
that started working with this character
set and they liked it it worked well and
they hadn't need for lots of extra
characters and there was all this you
know 64 characters that weren't being
used so they just started using them
which was fine for them until the army
wanted to make all of these programs
work together and they didn't because
everybody saw that there was a hard
lesson there that you really have to
nail stuff down in a standard if you
leave too much stuff free then
programmers will abuse it as a result
you'll lose interoperability or quality
or whatever it is you're trying to get
so the next big step forward is ASCII
anyone heard of ASCII yeah ASCII is a
big deal the American Standard Code for
information interchange work started in
1963 and ASCII was a joint project
between AT&amp;amp;T and IBM and a whole bunch
of other parties it was not intended to
be a computer character set it was
intended to be a network character set
or a communication character set thought
will not only have teletypes on the line
but will also have computers on the line
using the same code so this is a big
step forward
initially ascii was going to be a six
bit character code basically they're
going to take the bardo idea but add one
more bit to double its capacity and they
wanted to be able to represent uppercase
and lowercase
and the way they were gonna do it which
i think was completely reasonable was
they were gonna borrow the shift idea
that was in the Bedok code so they would
have shift uppercase and shift lowercase
and that would have been brilliant
because the way we would deal with case
today would be exactly the way we deal
with color or underlined or italics or
anything else small caps it'd just be
you know you have a code which
represents a letter and will have some
other means of saying what glyph we want
for that letter but they didn't do that
and the reason they didn't do that was
again the line noise problem in the
telegraph lines that the lines were
really noisy we didn't have the error
correcting codes that we have now our
air correction systems are so good we're
not even aware of them anymore but when
this was designed line errors were a
really big problem and their concern was
that if one of these shift characters
gets mangled in transmission then the
rest of the document is going to look
stupid when it's printed out and to deal
with that they decided let's change it
into a seven bit character set and give
each of the letters a separate code
which I think was a terrible decision
that the reason they did that stopped
being necessary a long long time ago but
we are still stucked with the
consequences so this is the code that
they came up with 32 transmission
control codes at the top anybody have
any idea what those are you might
recognize one or two of them most of
them are a complete mystery to you but
there is still in the code then we've
got the digits are lined out pretty
nicely it's actually a pretty nice thing
they considered interleaving the upper
and lowercase characters so you'd have
uppercase a lowercase a up case B
lowercase B so that most things would
kind of sort right but they decided it
doesn't sort perfectly and rather than
try to figure out how you might fix that
where you might fix it would be to go
back to the 6 bit code they decided
let's make it really wrong
you know we'll separate them by 32 so so
you're probably curious about what those
control codes are tonight for the first
time I'm going to tell you what those
control codes mean so AT&amp;amp;T insisted on
two codes null and del delete so these
were for punch paper taped applications
so on the punch paper tape
zero means there's nothing punched on
the tape and one one means there is a
punch on the tape so they wanted blank
tape to be to have a code that you could
recognize and reject so you'd have a
liter of blank tape and you'd run that
through your tape reader and you'd send
it to the other side and the other side
would see oh that's just a zero I'm
going to ignore it which sounds bizarre
in our modern system you know the
internet doesn't work that way but
that's the world that this code was
designed for and then so offline you're
editing a paper tape and you make a
mistake and you go oops so what you do
is you back up the tape and hit the
delete button which goes junk and
punches out all of the holes and then
you can punch the character after it so
punching out all the holes means this is
a non character ignore this non
character so it means the same thing as
null but it just happens to have a
different code because that's how paper
tape works so then there was also a
backspace code the BS code but it did
not mean erase the previous character it
was not designed for user experience
because there were no users there was no
experience this was just designed for
machines talking to each other so
backspace meant moved the print head
back one space with
meet that's a completely different
meaning later programmers said no look
there's a backspace key oh there's a
delete key let's figure out what to do
with those and the things we do with
those now are completely different than
what they were intended to be
yeah we're in complete violation of the
ASCII code in the way we use backspace
and delete there are some codes added
for operators for teletype operators
there was the enquire code which when
you sent it to another terminal would
cause that terminal to send back a
string which would identify the
terminals so you know here connected to
which sounds bizarre today how can you
connect to something without an
expectation of who you're talking to
and then there's the Bell code which
will ring the bell so you go ctrl-g and
on the other terminal go ding you know
so you know emitting now wake up think
there was space and there was tab space
was necessary because you need the inter
word gap a tab was borrowed from manual
typewriters manual typewriters had a tab
key you press it and it would release
the carriage until it was stopped by the
next mechanical tab stop unfortunately
they didn't indicate any way of
specifying how to set a tab stop and
they didn't specify what the default tab
stops are it just said if you're going
to tab this is the code and and they
never anticipated what we're doing with
this stuff and unfortunately this is a
source of conflict we're still arguing
should we use tabs should we use spaces
it's a colossal waste of time and the
debate goes on it will never stop
because there is not a clear answer
neither side can prove that they're more
right than the other side and lacking
any way of resolving the conflict it
just goes on and the cost continues to
grow and grow and grow the value of
having these two characters zero we get
no
value from having two ways of doing this
thing at least compared to the the cost
that it causes so I recommend a
different way of resolving this problem
which one can we get rid of we can get
rid of that one yeah so we should get
rid of tab it's not a question of which
one is better it's which one can we get
rid of that the tab character is an
anachronism that should have died with
the typewriter all right we finally
settled that okay we have carriage
return in line feed again these are
because of the way that the teleprinters
worked carriage return would move the
printhead back to the margin and line
feed would roll the paper up one line
and they liked having the two codes
because the carriage return function was
kind of slow because it you have to move
a thing down and having the line feed
happened just after it gave it a little
bit more time to have that because if
you then have to print another character
before the carriage return gets back you
can be printing ghost characters in the
middle of the page and that looks stupid
so we don't care about that anymore
that's not how printers work now but we
still have these two codes and there's
still an argument about which one should
you use people who think about this in
terms of user experience will usually
say it should be the carriage return
because the Enter key used to say return
and so you know that's how users think
of this the hardware oriented people say
line feed is really the way printers
want to work they want to advance to the
next thing and so you know how do you
decide which one to do well there was a
committee in the early days of the
internet trying to decide which one
should we use and they couldn't decide
so they came up with the mutually
disagreeable compromise which is we'll
use both of them which doesn't make any
sense that using both of them went out
with mechanical teletypes but we're
still doing that if you look at the
internet standards look at HTTP it still
says you have to use
both of them it doesn't both at the same
time it just doesn't make any sense we
also have form feed which told the
printer to eject the current page and
and put the next page into the printer
so you can start printing and a
companion vertical tab which is the
vertical version of the horizontal tab
but again they didn't specify any way of
setting a vertical tab stop so it today
it doesn't make any sense
javascript still lets you say backslash
of e representing this it doesn't mean
anything and just it's pointless there
were four device codes in ASCII so that
you can control devices and generally
that meant controlling the paper tape
reader and the paper tape punch so your
tele type might have a paper tape reader
on it and if the computer wants to start
reading it it can send it can turn the
reader on and then it'll start
automatically sending characters to the
computer and if the computer starts
getting overwhelmed oh there's too much
input it can then tell it to stop and
the computer could also turn on the
punch so you can start punching your
paper tape those codes are still in
ASCII then there are codes for dealing
with protocols because they imagine that
instead of just sending streams that we
might actually be sending higher-level
stuff and so this was really new stuff
that they were kind of inventing so they
imagined that we'd have protocols in
which we'll have a start of header and a
start of text code and an end of text
and an end of block and we'll use those
to make packets
packets were still a really new idea and
then in support of that we have AK the
acknowledged code so if you successfully
read a packet you'll send it back ACK
there for some reason you couldn't read
the whole packet you'll send back nak
and there's also the synchronous idle
they anticipated asynchronous mode in
which well in a circuit of Snoke mode
there's a start bit and a stop bit on
each character
and that's so you've got an empty stream
and then you see a stark bit and you go
Oh wake up there's a character and you
keep getting bits until you get to stop
and then you can go back to sleep
there's also a synchronous mode in which
the characters go one after another no
start no stop it and the problem is how
do you know where the character
boundaries are because it's just ones
and zeros and so they have a synchronous
Idol so when there's nothing being sent
you send this code and on the other side
they'll be looking for a pattern of
those zeros and ones when they see them
they go off that's a character and then
they can deal with the rest of it so a
packet might look like this you might
have a start of text and then the body
of the message and then the end of text
or you could put a header on it the
header might contain an address or some
other information which helps you to
deal with the packet and using the end
of text block you could have really long
things and you can get an ACK after each
one because it might be too dangerous to
try to send something really long
because it's guaranteed you're gonna get
an ACK so if you send it in smaller
chunks then you might get stuff through
there are two end codes one was end of
transmission so at the end of a session
you'd go control D yeah that's the end
then we can hang up and and we're
finished and there is also end of medium
this is something you might put on a
tape so you write a tape and at the end
you'll write and then to medium code and
that means that's the end of the tape
then there are a couple of oops codes
there's the substitute code that means
that if you have a character and you
don't know what it is you send the
substitute code instead again today the
way we think about data communications
that doesn't make any sense how can you
not know what a character is and still
want to send it but you could do that
also there's a cancel code if something
is coming or if you're sending something
and you decide I'll never mind I'm not
gonna send the rest of it you can just
send the cancel code and and you're done
there's escape escape was not what we
use it for now
escape was for extending the character
set they anticipated that the hundred
twenty-eight characters and a scheme
might not be enough so escape would
allow some way of extending the
character set so when you see the escape
code that means the stuff that comes
after it is going to be interpreted
differently one interpretation that was
popular for a while was add an eighth
bit to the character so that would get
you up into the Latin one set but so
there was an escape key on the teletypes
for that purpose but very quickly people
realized we're in a program and we want
to make the program stop how do we do
that you know I've got this escape key
let's let's hook that up and we're still
using it right escape gets us out of a
mode or cancels the dialog or something
like that it was never intended for that
is intended for enhancing the ASCII set
we have data linked escape which does a
similar thing sometimes it's used for
making a control code literal so if
you've got some binary data and you want
to be sending an end of transmission
mark but you don't want to hang up you
want it to be treated as data you might
put it DLE in front of it but it could
also be used to introduce new control
codes because they were concerned that
32 control codes were not enough they
thought they might want a lot lot more
then I told you about the shift codes
for uppercase and lowercase they decided
not to use them for that but they still
put them in the code and so you could
shift out meaning it can shift into
another character set and then shift
back into ASCII another way of growing
the code they provided information
separators so there's the file separator
the group separator the record separator
and the unit separator so they did not
intend
for or I've heard people say that
tab-separated data is the way asking
intended us to format data and it's not
this is how ASCII intended us to format
data you have files made up of records
made up of groups made up of units of
data unfortunately this isn't really how
data ended up that sometimes you have
records that really want to contain
other records you know so this this
doesn't work so I should have told them
about Jason right because that's what
they really should have been doing but I
didn't and my excuse is that I was eight
at the time and I was doing other things
it's just too busy
ah yeah so so that's the ASCII set so
again they did not intend this to be a
computer character set this is just
something that computers would use to
communicate with each other but a number
of manufacturers thought well it's just
try to use this as is because then we
don't have to translate from our set
into their set for one very common use
was something that I called half ASCII
[Laughter]
where you just take 64 characters of it
you subtract ODEs and the lower case you
just subtract 32 from everything and
that gets you a nice little six bit
character set and there are a number of
manufacturers that we're doing stuff
like this it it all changed with the
microprocessors but we'll get to that in
a bit so the next step forward is
Unicode Unicode starts in 1991 some very
very smart people from Xerox and Apple
and other places who have been really
struggling trying to make products that
worked all over the world and realize we
need to figure out what figure out a way
to unify the character set so we can
just have one product that goes
everywhere and so their goal was to make
a
a character set that would serve all of
the living languages in the world in
16bits and it came really close to
pulling it off but in order to do that
they had to do something called Han
unification which meant taking or
observing that Chinese was the route
also of Korean writing and Japanese
writing and taking all of all three of
those languages putting them into one
character said it's too big doesn't fit
in 16-bit character sets but if you look
at how common those languages still are
at least in their orthography then we
can squeeze it down into 16 bits and
they tried really hard to do that
unfortunately they really pissed off the
Japanese but they we're not happy about
the way that happened so that brings us
five years later team code two and
Unicode 2 now has a much more expansive
mission they have grown the character
set to 21 bits and they now want to
encode all languages even dead languages
you know so Egyptian hieroglyph
hieroglyphics become part of Unicode
which is something I like a lot so I
like that
unfortunately in 2010 we get unicode 6
and emoji for a while there was a hope
that someday we could finish unicode
right we'll find all of the languages
that have ever existed we'll write them
all down and we'll give all the
characters codes and we'll be done
unicode will never be done there's no
way for ever get in front out of emojis
so ASCII lives on in unicode the first
hundred twenty-eight characters of the
unicode set are at the ASCII set
even though ASCII was not intended to be
a character set in unicode was intended
to be a character set in computers ASCII
is in there including the 32 control
codes which you now know are mostly
meaningless and completely ridiculous
right they
they don't serve us anymore
and the way this stuff works is really
important for example in the C language
we use the null character to represent
the end of string which is not what
ASCII said but that's what C says which
means that C would have broken on any of
the earlier 6 bit character sense
because they did not have a null code
they all used 0 for a real code so ASCII
changed the way we think about
programming of letters and words but
there was an even bigger influence than
that under the influence of 6 bit
character sets there are lots of
different hardware architectures with
lots of different word sizes but they
all seem to have a factor of 3 in them
so I saw and worked on carat on machines
that had 12 bit characters 18 bit
characters 24 I'm sorry 12 bit words 18
bit words 24 bit words 36 bit words 48
bit words 60 bit words the thing all of
these machines had in common was 6 bit
characters and the reason that worked
was because that's what the character
sets were and so you could pack some
number of characters into a word and it
all fit and it was really good and these
were great machines and and then it all
changed so 7-bit ascii caused the
ascendance of computer architecture
based on 8 so IBM took ASCII and weirdly
mutated it they combined it with their
terrible BCD IC code and came up with
something a really awful thing called
ipsa dick and use that as the character
set for the 360 series so that system is
based on 8 16 32 and all of our machines
pretty much since then are based on that
the big change I think happened because
of Intel so Intel built a machine called
the 8008 which was the design was
brought to them by a company in San
Antonio called data point they made
intelligent terminals and they were
making them out of discrete logic and
they were difficult to build and they
came up with a design for a simple CPU
which would have greatly simplified
their terminals and they asked Intel if
they would build that chip for them
which they did so the initial design of
that chip was an 8-bit machine and the
reason it was a bit was so that it could
process ASCII that was the intended
purpose of the 8008 but that 8008 grows
into the 8080 and the 8086 and the
pentium and all the crap that comes
after and so it's all 64 bits now so if
the ascii committee had successfully
completed as a 6-bit character set 36
bit architecture would have survived and
so I think the first microprocessors
would have been 12 bit machines not
8-bit machines and that would have
completely changed the evolution of
stuff that the next step up would have
been 24 and so a lot of the memory
limitation issues that we felt on PCs we
could have avoided those four years and
then taking the next step up to 32 and
today we would be running in 72 bit
architecture which I think would be
brilliant you know it would have
completely changed the way we do
internationalization Europe would have
moved immediately to 12 bit character
sets because six didn't work in exactly
the same way that Asia moved immediately
to 16-bit character sets because 8
didn't work and by doing that we would
have avoided all of those
internationalization problems and
then ultimately the world would adopt an
18-bit character set which would be the
unicode set which would serve everybody
and seventy two-bit CPUs would be the
standard today so that's the end</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>