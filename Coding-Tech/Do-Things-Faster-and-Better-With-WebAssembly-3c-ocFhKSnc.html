<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Do Things Faster and Better With WebAssembly | Coder Coacher - Coaching Coders</title><meta content="Do Things Faster and Better With WebAssembly - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Do Things Faster and Better With WebAssembly</b></h2><h5 class="post__date">2018-04-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3c-ocFhKSnc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm a full-stack developer it's a Bell
Labs I'm a coach of team member of Jay
hipster how many of you here are about
Jay obscure here cool yeah we have quite
for your hand yeah I'm a team member of
the pack I'm also part of rust Bassam
working group very decide the future of
rust and Bassam integration and I'm a
big open source lover you can see me
contributing to a wide range of projects
in github and I'm also promoting open
source everywhere I go so how many of
you here or full-stack developers cool
yep we have a lot of full-stack
developers how many of you do lose that
quality in JavaScript quite few okay how
many of you love that doing okay we have
quite a few hands now great okay how
many of your C and C++ developers here
who we have three four great rust
developers one awesome great so what
these things offer like C++ rust they
definitely offer types what are they
offering speed yeah portability here
yeah of course they offer those kind of
things it over safety especially in case
of rust it offers a lot of safety it
gives you more control to what you write
things like that and it's very closer to
mission which means it runs at faster
speed on the other hand I'm in a Java
Script meter I'm not going to ask how
many of your JavaScript developers but
let me ask you this question how many of
you are not JavaScript developers who we
have 103 great so for all of us what do
you do doing increase the performance of
your application more service yay okay
anything else cache of course yeah lazy
loading yeah so yeah we do some sort of
things some sort of Magic's to make that
happen we obviously make use a pipe
system in case of JavaScript to make it
faster
we reduce the amount of Dom manipulation
via JavaScript we do code splitting it's
kind of lazy loading and we do a sync
and differ using script modules the
minify stuffs in order to increase the
performance of your application we do
have something called service workers
that help you do - caching and all those
stuffs and we do have immutability and
some other things like j/s engine based
optimization and profiling how many of
you have done this thing like optimize
your functions one - oh we have quite a
few 10 people are on yeah break so these
are the things that we do in order to
make sure that our applications are
running faster and better let us go for
a performance question what do you think
they'll have a higher performance we
have option a over there and option B
over here the only difference is the
second line yeah how many of you say
option e ok how many of you say option B
ooh
a lot of person saying option B great
but answer is option E you guys know why
yeah okay allocation is part of the
answer that you're talking about it's
because of packed and holy airing any of
you hear about packed in holy array here
so when you create an array with new
array of 3 your JavaScript engine
doesn't know what to do it creates three
are a size of three foot undefined
elements inside it and that is a holy
array but when you define an empty
braces it's all script in your nose okay
guys it's something is gonna be there
but I don't know now so I'm not going to
put in an extra effort in defining that
stuff then you can have a much faster if
you want to know more information about
this you can follow the link below there
it gives you much more detail about it
and this is the data sticks that is
taken the path array will have higher
operations per second but under the case
the holy array have much more less a
operations per second
these are the things that we are talking
about here so you have lot of
uncertainties in the languages and all
of us believe that newarray will give a
better performance but it's not going to
happen because there is uncertainty
there and how do you solve these
uncertainties
what are kind of things that you do for
the Sun Saturn it is anybody what is
this yes it's an internals of engine and
in order to fix the uncertainties you
have to understand how the engines work
internals of engine how it is
implemented
how what you have to do in order to
increase those performance on the other
hand what are the things that we usually
used to do in order to get out get
maximum performance out of the
JavaScript for example applications
using the geo obligation using games
applications doing all those high end
stuff and also for the smaller steps
what kind of things that you are doing
like you do certain stuff based on
engine base tunings like there are
multiple JavaScript engines available
certain operations are faster in one
type of engine and certain operations
are slower in another type of engine so
you do engine based tunings there and
there are some shortcomings in the
engines itself so all your engines have
shortcomings Mon Amour physician anybody
hear of this word before one person yeah
so so why do we go to type script
basically
we go to type script because it gives
you types which ensures when the
JavaScript is actually in running in
your engine it gives a monomorphic code
that is some code but only one type
which means engine doesn't have to do a
lot of optimizations in order to take
care of polymorph that is different
types how many of you know adding an
optional argument inside your code will
reduce the performance of your
application here one two yeah so and
it's so time consuming because you will
have some functions that is rendered
much more slower and you have to spend a
lot of effort in order to drive the
performance out of it which is time
consuming at one hand and you do have to
do micro benchmarking here you have to
go through all the functions that you
have written one by one and then make
sure all are running at the high
performance of course
of course you have to know the concept
packed in holy Airy when you are working
with a race on the other hand what is it
Alfred like you have done all the
optimizations that we have seen at the
previous slide but what what we end up
in us a quote that is kind of messed up
you cannot maintain that core so far
because people were coming outside who
who are coming newly into the
application will not know anything about
the code why I've done in this way why
it has been done in this way but on the
go
sometimes our script engine itself
changes like v8 is getting released
every now and then and every now and
then they are attacking a particular
part of the performance and then they're
increasing the performance which means
whatever I've done whatever the Messier
thing that I have done doing in order to
increase the performance will be
outdated and people has to change that
stuff and you have a problem of
maintainability here so there is a
trade-off between uncertainity and
performance and most of us will stick
with uncertainity
and don't care about the performance
because already javascript gives you
more higher performance when it's
running
but drying driving the entire
performance out of the application
nobody's gonna care because it gives you
unsanitary and also the maintainability
in the code so how better it'll be to
run the consistency and speed of the
application using the native of the
native port in the process it would be
nice right to run your native code in
the browser where you don't need to
worry about all those things that we
have just stopped so introducing you
guys that are family how many of you
done webassembly how many of you hear
about that assembly worked on it how
many of you worked on it nobody okay so
ever simile is nothing but binary
encoded stack machine so it's a set of
instructions that you give to your inst
computer and it runs those instructions
that's it and it runs on your browser
which makes it much more simpler so you
can compile your native code for a
browser environment and run it in the
browser so that's what webassembly is
all about
and of course it's supported by all the
major languages or all the major
browsers that we have it's fast and
efficient it's pretty safe because web
assembly itself runs and a safe
execution environment which makes
pretty safe it's binary encoded it's
debuggable so we can debug the web our
family stuffs and it's developed as a
part of open web platforms which means
it's available in all the browsers
openly and one cool thing just Before we
jump into web assembly and see what kind
of things are the software you have to
know webassembly it's not a replacement
of JavaScript it's not going to replace
your JavaScript at any point of time it
helps you to integrate well and create a
maintainable code and it's it always
focuses webassembly always focuses as a
working group member we always focus on
symbiotic relationship between web
assembly and the JavaScript so how many
of you here know how a JavaScript works
inside a JavaScript engine sorry they're
not completely at least the idea of how
it works
yep so let's go ahead crash goes into it
so immediately when you over javascript
file is getting downloaded on the
machine on the browser it starts to pass
it tries to convert into ást ást is what
is ast yeah
abstract syntax tree and once it is
parsed it tries to interpret the
JavaScript and star goes straight away
into execution mode but on the other
hand there is a profiler which comes
into picture which looks on the things
that are executing and then it's 6 ok
this function is getting gold a lot of
times okay
let's mark this function as a hot
function and once it is marked as a hot
function it tries to compile them and it
tries to optimize the function such that
it works bursts so once this
optimization is happening javascript
instead of using the interpreter way of
way of interpreted in to execute the
stuffs it goes via the optimized way
which means it works much faster but
when it's goes really hot like the
function is getting called like millions
of times again and again javascript
takes some assumption the engine takes
some assumption and then reoptimize 90s
stuff which means it's much more faster
but definitely when you compile optimize
and then reoptimize there are some nano
seconds or milliseconds or microseconds
of time lack that is happening because
the engine has to take this code it has
to compile it it has to optimize the
thing it has to generate a code and then
put a reference to it
which means you're using a lot of time
there you're missing a lot of time there
and finally they execute that stuff at
the end of the day you've got bitch
collect everything and sometimes your
application may pass at this point but
only at the hand how that assembly works
so steps are smaller it starts to decode
so it'll binary encoding the data as
soon as the browser finds of Assam file
is downloaded it tries to decode the
entire data once it is okay once it is
decoded it tries to compile it so the
code is already compiled and optimized
so you need to be not worried about
optimization but this compilation part
is much more smaller it compiles into
browser inside the JavaScript engine and
finally it executes it which makes it
much more simpler and faster to get
started and running let's see how how do
you build a simple example interest I'll
be focusing mainly on rust here so this
is a simple function you don't have
anything here it's just a simple
function that says add one and it just
takes an integer and adds one to it and
then returns it as simple as that just
before we go there how many of you okay
what is the numerical format the
JavaScript is using sorry sorry okay
it's using F 64 so all the numbers that
you define in JavaScript land is F 64
but on this case you see rust is using a
32 which is much more efficient than F
64 correct yes or no
okay it is fine let's go ahead so you
run this command so this webassembly
compiler is part of russ compiler now so
you can run this command it's in the
part of frankly bill so just run this
command it converts your russ code into
our friendly code and what do you get a
raw binary format so that assembly is
nothing but a raw binary format it is a
assembly code how many of you are from
electronics background here every ten
assembly for your eight to eight zero
eight six cool great finally so once it
is generated that assembly just generate
a module since these modules are small
entity file inside the modules you have
setup instructions there which helps you
to run your code so you have like things
like input which helps you to add all
the input inputs that assembly module
can have followed by the export so
export will have list of things that is
exported from that particular module so
for example you have seen add one
function there this add one function is
exported out of the module so you can
specify the export here followed by
function and Co the actual function end
code and here it's defined by the yvette
function so it has actual function on
the other hand you have a start the
start is weird this start is a starting
point of execution if you happen to find
one it will be till you call the
function there if you have defined one
the moment the assembly module is loaded
it starts to run the start function and
then you have global there you can
specify the global parameters there like
the global variables followed by the
memory so memory is where you specify
the memory the memory that have that
trust and JavaScript shares so this is
one thing that you have to make sure
like everything operates on basis of
memory here so you should tell them
whether some Lea module that this is a
kind of memory that you have to use then
it sticks to that memory and works on
top of that memory added to that you
have element you have table and you have
data so these are the extra informations
that you can add inside element add
inside the web ascend memorial factors
shared between the application the
JavaScript and Bassem so this is really
helpful when you do the bomb
crossing because JavaScript literally
knows which memory to attack and vasa
module literally knows from which memory
it has to load stuffs but that raw
binary format is not readable to make it
readable we have vast vast is nothing
but Weber family text format it's really
helpful in debugging so we have seen the
verb assembly module so debuggable which
means it's debuggable with the help of
ass so vast is a literally translation
of the assembly binary code let's go
through it one by one
yeah for module so everything is wrapped
inside this module followed by that you
have type so this type stores an
information the type information of what
you have currently we have types like a
32 funk funk is for function type and
this function has a param which takes an
i-32 type and then it has a result and
how many of you know Lisp here great
this brackets look like that right and
then the actual function itself so it's
defined by function keyword and whatever
that is denoted with the dollar notation
and that thing is a variable inside here
so you can call this stuff here and here
you can see it's exporting add one and
then it has a type it defines as a
dollar zero which is a variable again in
terms of graphing module and you have a
parameter result and if you see the
three lines from the bottom those are
the actual code that is what you have
written like you get the local value of
dollar p0 and this dollar p0 is defined
in the param there and then you do add
constant one I 32 of Const 1 and then
you do I 32 dot at the side that you do
dot the ad is nothing but your plain
assembly instruction which should be
converted in there or binary format
there and then you have stable so
currently table takes any func as a type
and it's the only thing that is
available now but you can add in like in
future there will be a lot of things
that will be added to it and then you
specify the amount of memory that your
application has to use so this really
helped the Bassem module to understand
the amount of memory it has to used and
the memory from which it has to use so
say if we have a memory you have to
export this particular memory and
this is the initial size of the memory
like 17 bytes of information that we are
exporting out on the other hand you
specify the actual data and this is
really helpful then you want to share
some data between Bassem modules or
between JavaScript and Bassem so when
this boundary crossing is happening if
you want to share some data in between
them you can use this data any question
so far am i talking from an alien
assembly language
actually this is assembly code that is
generated and this is a textual format
of that code so you can call an assembly
language from a JavaScript as well this
you can call the same NASA module
between matha modules and you can also
call your native application if it is
running alongside you can also call them
too native application you can do those
stuff great ok moving forward yeah fine
we have Assam we have that that was
generated by the compiler what is there
how do you load them how do you add them
into your application I hope the text
size is bigger enough for people here
right so here I have 2 options like just
written in two ways first is like you
just take a fish the Bassem file and
then you convert that into an array
buffer and then you feed it to the
assembly dot instantiate webassembly the
window object global object it's
available in all the browsers now all
the major process now and yeah you can
instantiate the object and from the
result the result that is in the third
line you can export that particular
stuff that you can have a list of object
here so this result dot instance will
give you objects like memory all the
things that we have seen memory exports
imports and all the stuffs that we have
seen in the previous section will be
listed here so this is the object that
you have to work on top of it and when
you say add 112 you end up in giving a
result of 30 there okay and then you
have using compiled streaming so here
it's like you don't worry about fetching
the stuff and then converting that into
an array buffer
browsers will give you a compiled
streaming method which helps you to fish
the stuff compile it and then give the
compiled version of the module and use
the compiled version of module to
instantiate stuff so it's much more
simpler and even you go one step deeper
it tries to instantiate the compiled
module so you just have to fetch it and
then instantiate the particular stuff
but this is currently supported in for
your process not all browsers support
instantiate streaming also compiled
streaming and instantiate streaming or
extensively supported under HTTP for
security finally the streaming
compilation actually speeds up the verse
and performance hub does it speed up
anybody because you are compiling on fly
like this is just a binary code binary
data raw data that is coming from the
server that is coming from the browser
you just compile it on the go which
means you have much more higher
performance in JavaScript it's there is
no way of doing some streaming
compilation now the main reason is it
has to generate an ast first but in case
of that assembly since we are dealing
with binary code you need not worry
about a SDS here which means you have 10
to 15 times faster on doing streaming
compilation but worry not streaming
compilation will be coming to JavaScript
sooner and there is also an atmospheric
module specification for Bassem this
enables are still note the Bassem files
as an x ma ACMA script sorry es modules
and it's still in very early stages
talks are going on and I guess yesterday
there was an awesome article from Lin
Clark for this particular stuff you
should check that out ok let's go to the
demo time enough of boring talk ok I'll
be doing two demos here the first demo
is I'll be using Bassem by engine which
is a tool that helps you to include your
vasa modules in your browser it has a
lot of cool functionality is added to it
and in the second demo I'll be using the
pack and then I'll show you the
performance difference that it is giving
you ok so there is only one person has
worked on brassed I'll just go through
this file let's just zoom in a bit
okay so fine so this is a file that has
been generated so this is cargo tamil is
something like your package JSON for
your node modules and stuffs so here
define a package and you give the all
the necessary information that you want
and then you define a library and this
specifies this is this library this rust
library is capable of running in a
different embedded environment on the
other hand you specify dependency which
is nothing but Freight in rust well it's
called a straight while comparing in NPM
world is called a package so you specify
the vasimr engine and the version of it
that's that so this is a rust file that
we had generated like that we are going
to work on it does nothing it just gives
you another hello world that's it
so let's change it hello yeah change in
the JavaScript file on the other hand
you do have a package JSON so if you're
going to run this in your hash tml file
so this package isn't it's nothing it
has we're back we're back CLI so we're
back has Bassem we're back for comes
with Bassem so you can load assam the
dot and followed by that you have that
back config file which helps you do this
is a configuration of file which has
nothing just an entry and output how do
you do it and the mode so the back for
has more in it so just have the mode
great and this is just an index.html
which shows stuffs here and then the
index to JavaScript which actually helps
you to load the vasa module so let's go
ahead to a prominent aunt okay
so let's type in so in order to generate
or build your application you have to
Skype cargo build target dozen 32 oh no
no no so this is a command that helps
you to build Bassem file out of the rust
file that that we have so that's quicker
so it tries to compile it and then it
generates a Rasim file so let's see
where it is
so if you see here it generates a Rasim
file for you
so this Vashem file is just the name of
your application and the Backson file is
generated let's go back it's a binary
format I cannot I don't have to so it's
it's kind of not exactly in 0 1 0 1 hex
it's kind of like it has some words in
it too but I'm not sure I can open this
and throw it here but probably I can try
sure so this is the one that has been
generated
ok so now what I'm going to do is I'm
going to use VASIMR engine to convert
this plasm file that has been generated
and I'm going to convert that particular
Bassem into and optimize to Assam such
that it can be used along the process so
what I'm going to try a spasm and - by
engine I take that particular file and
then create an output in the same
location that I have so this will
generate an output for me and if you see
this would have generated BG underscore
demo to jf + BG underscore underscore BG
dot class and fat so let's go ahead and
see what it has inside okay first we'll
see the demo JavaScript file so now
whatever generator is kind of very huge
here because it has to take into account
of all the memory path memory pointers
and also it has to use strings here
because Bassem in general suppose I 32
and F i-64 F 32 f 64 but it doesn't have
a string support inside so what we are
doing currently is like we are
manipulating this entire memory into a
form of an array buffer and we keep the
raw memory location via a JavaScript
file call it as a binding file and with
the help of the Grasim works along with
it so that's how we are passing strings
and everything from Bassem to JavaScript
as well as Java
to Vassar so you're just loading the
Bassem here so you can see it here it's
loaded as of as if it isn't yes yes yes
module but the back actually tries to
convert into sink stuff and it works
with help of that back and then it has
lot of all the memory that you're
slicing a memory they use the memory you
have a memory location with the help of
the memory location it helps and gets
all the information so what you're going
to do is we're just going to have an
endogenous which actually imports the
particular demo application and then
once the demo application is important
it tries to get this it rise to greet
the greet is a function that is inside
your rust v so this function it goes to
goes and calls this function inside the
res file great and one thing to note
here is that PAC doesn't allow
synchronous import in the basic chunk so
how many of you know about chunks here
yeah so many of you know so you have lot
of you can define your application and
have lot of chunks in there and your
main chain cannot have synchronous
module input and which for Rasim for
particularly in terms of assam your main
chunk cannot have any synchronous input
so you have to load it as synchronously
that's why you're using imported braces
so input with braces will do it in a
synchronous and then this is gives you a
promise and then you get put the promise
and then get and then run the code let's
go ahead and do yan
so so this should start application in
1300 so let's copy this and open up
firefox so yeah so you have hello dot
world that is calling inside a function
in there Russ so you're calling from
JavaScript inside the rest and you're
passing in the string let's go back and
see
yes for fun Amsterdam and you see it
comes here so yeah so it goes and calls
a rust and then it gives the value from
it gets a value from the rest the raw
memory pointers will help you to get the
values from there and then it shows
cases here but this is pretty simple
right let's go into much more complex
stuff so yep so this is entirely this
entire application is available in web
pack examples it's kind of something
I've just added few other stuffs few
fancy stuffs on top of it but this
entire thing is available in we're back
so what we are going to try and do here
is like this definitely has a package
tour JSON which has a web pack stuffs
and the config JSON which loads of a
Bassem so you can lower your Bassem with
the help of this rule stuffs and
everything and finally when you go you
have a set of Grasim files that has been
used and a function that has a factorial
in javascript as well as epifaño key in
javascript so this is a simple one and
you have the similar functions in your
rust or C++ and you have it in Rasim
code so let's go ahead and run this
particular file let's close this one
okay so it tries to run your entire
stuff and you can see the difference of
performance here a JavaScript one is
having higher time under the time on the
other side you've asked someone has a
lower time which means a performance
it's much more higher in terms of
loading it with simple application but
what you're doing actually here is we're
trying to call it's too slow for me
we're trying to call the same function
like 5,000 time we're trying to first
warm it up so in order to play good
you're just trying to warm it up here
and once it is warmed that is once a
profile at peaks in and says okay this
function is getting called a lot of
times let's mark it as and let's
optimize this particular function and
once it is optimized we're just trying
to run it for more number of times and
at the end of the time we're just
calling those functions and look what it
has happened here so it has that like
the Vasanth factorial gets called and
it's like four five thousand time it
just took 224 millisecond so you have a
lot of differences between the
performance here but one thing to notice
like you can always go ahead and do like
increase the performance of your
JavaScript using a lot of techniques
that we have like we have seen many
techniques and there are a lot of other
techniques you can go ahead and remove
the difficulty function and then replace
it with normal function since we are
using a recursive function here so since
we are using a recursive function in
JavaScript recursive function is much
more slower so it can go ahead and use a
normal function here instead of
recursive in the normal one and increase
but the performance you will get like 10
to 15 positive performance much more
higher in terms of web assembly on
comparing to the JavaScript counterpart
which is much more easier and simpler
simply you're just writing the same
stuff but you are getting much more
higher performance
okay so the future of assembly like very
we are going if you don't have complete
garbage collection in webassembly which
means the languages that has garbage
collections will not work properly with
webassembly that means you cannot
convert them into the awesome stuff so
that's the main reason why we have C++ C
and rust which has garbage collection
which means that you're storing all the
memory and all those stuffs inside as
something here and without this garbage
collection you cannot have no
manipulation to and the bulk memory
operations are not possible and we have
a hard limit of 4 gigabytes here on the
memory stuffs but you don't have any
bulk memory operation such that you
cannot specify a huge amount of memory
in a Bassem file which obviously makes
your file into huge file on the other
hand the treads are coming to Gotham
which means you can run it in
multi-threaded application and you also
have an air you don't have an exception
handling now but community is moving
towards and adding an exception handling
which means like nicer error messages
that are not handled now you just
application stopped working thanks like
that but you can have a good exception
handling in future</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>