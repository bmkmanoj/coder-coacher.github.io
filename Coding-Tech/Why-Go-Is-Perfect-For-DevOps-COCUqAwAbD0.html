<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why Go Is Perfect For DevOps | Coder Coacher - Coaching Coders</title><meta content="Why Go Is Perfect For DevOps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why Go Is Perfect For DevOps</b></h2><h5 class="post__date">2018-04-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/COCUqAwAbD0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so here is the ubiquitous example that
shows how you write what a go program
looks like this is hello world and go
it's simple straightforward there are
tons of resources to help you learn go
and practice go you can even in a
browser just go to there's a website
where you go and you literally type in
the go right there and it compiles and
runs it and shows you what comes out so
this is what hello world looks like it's
simply you have a function that you a
library that provides string formatting
that also provides the print line
function and you simply say well here's
a string print it out for me and you're
good to go when it comes to building
this program you simply say go build and
main go-to get is a program a file
called main and as this file uplet's
shows I've got an elf 64-bit executable
it's statically linked and not stripped
okay and that's the really important
thing when it comes to to DevOps is it's
statically linked this binary if I put
it on any system that's capable of
executing an elf 64-bit program that has
the version 1 sis v ABI on it this
program will run ok I don't need any
external runtime environment I don't
need the right data so is I don't need
anything to be there other than maybe
LDS Oh to gain the linking to glib C to
run this program and that's a beautiful
thing and this is what makes going
perfect for DevOps very few people have
the luxury of having a purely
homogeneous environment whether whether
it's even just different versions and
releases of Linux if you're Linux shop
there's always going to be a blend of
things even most people I know who
manage majority of Linux environments
they prefer Mac OS on their on their
laptop right but while there are mostly
similar systems they are different when
you write a go program and deploy it you
don't need to get any dependencies when
you go and put it on to the target
system there's no
sigue and comprehensive go archive
network which has its own package
manager that's orthogonal the operating
systems package manager because making
that consistent from operating system
operating system operating system is
such a difficult problem you basically
just get one file
it's an exe or an elf program or whatnot
and you just put it on the system and
you
run it you just if you can get the
binary to the machine you can run the
binary so we live an explosion of
platforms now while it is true that with
bash and with Python you can kind of get
some cross-platform stuff but I've
worked in environments where they try
and make portable Python programs where
there's one program that does some
really useful administrative tasks and
they try and keep the same kind of
runtime in all difference but then you
end up with python 2.2 point x + 1 on
some of the systems and two point x - 1
or even you know python 3 on some of
them and now you've got to deal with all
these cross-platform compatibility
issues as well as it's just simply
deploying the program requires you to
deploy all the right packages that
depend on it and you basically end up
with a separate management function just
to manage the tool that if you were if
your assists of that tool is trying to
manage something which is the actual job
yet you're now having to manage your
tool like your actual job and all this
is extra effort so I love the fact that
with golang you don't have any of those
externalities so thinking back to our
hello world example let's say that a
coworker comes along and says oh wow you
know they see me running my hello world
program and like wow that's an awesome
hello world program except my system it
runs on Windows
I'd really like a Windows version of
that hello world utility cuz let's you
know it's the best hello world they
could imagine well if I want to take
that exact same program and build it for
Windows I only have to set one
environment variable now this is on my
Linux build environment I set the go oh
s environment variable or goos
environment variable to simply say
windows go build mangoat exact same
build commit all I've done is change an
environment variable and I now get
instead of a main I get a main dot exe
and sure enough it's a PE 32 console
executable for ms windows I say here's
your exe and they say oh what what dll's
do I need to run this none you don't
have a runtime don't need dotnet this
don't need whatever you don't need monos
runtime you just say here's your exe go
run it and you gonna be hello world in
like a boss ok now that's great and all
and we're all high-fiving yeah yeah
hello world everywhere we're doing great
the windows guys are in the Linux eyes
are in and then some Mac OS guy comes
along just wait I want hello world too
well guess what it's quite easy
Goo's equals darwin
now file me now this will overwrite your
your Linux one but hopefully you get
your build environment figured out you
know just delivering your Darwin
binaries to your Linux boxes but and now
you get a mock executable again 64-bit
we're ready to run and now you're
deploying onto Mac OS so literally just
by changing environment verily the exact
same program is now running on Linux
64-bit Windows and Mac OS and all I to
do is set environment vault now the
beauty of this I didn't have to go and
install cross-platform compatibility
runtimes or anything just simply
installing the go compiler you get out
of the box all of these platforms okay
now the great thing is it's not just
those you also get net BSD look at that
net BSD all we do is say net BSD and now
we're running on net BSD the exact same
awesome hello world program net BSD OS
10 and so on
and this goes on and on open BSD again
for free out of the box you're ready to
create open BSD XP tools same source
code same everything all you're doing is
building it and one file you copy down
to the target system and you're ready to
go FreeBSD course gotta have FreeBSD via
veneto BSD um Solaris you know Solaris
right there
easy now all the stuffs great but
someone who notice a bit of a theme with
all these different versions of
operating systems these are all current
more or less current operating system
now let's say Alice comes to you alright
now we already have a Windows 64-bit
executable and Alice comes to you and
she's the person that everybody feels
really bad for in incest ops because
she's the one stuck dealing with that
third-party app that somebody in
marketing bought that they deployed on
to a desktop workstation but it somehow
became mission-critical as part of their
workflow they bypassed procurement and
they now built an irreplaceable process
around it and it was done back in 2010
and it's running on Windows 7 and they
can't get the app to virtualized
successfully for some reason because
it's Windows 7 and it's a weird app and
the vendor who sold them that product
went bankrupt in 2014 so there's no
support no nothing but you can't get rid
of this app now this happens all the
time in business where you got and
essentially it impossibly to support
system and you're trying to keep it
alive with with with chewing gum and
whatnot but you know what look at that
take ghosts go of us windows and I'd go
arch 386 and
you'll get a PE 32-bit 386 compatible
executable and all sudden you're now
running hello world on Windows 7 exact
same code right this makes life so much
easier if you're trying to bring these
archaic legacy systems into a common set
of management tools so I'm about to say
something really controversial goes
better than either bash or Python
all right now the reason why I say this
is everyone here identifies as a system
administrator most of us who here writes
bash I write a lot bash who here writes
Python a lot of Python write Python and
bash are the go-to languages pun
intended
unattended I don't know of system
administrators but the fact is we are no
longer Justice admins we are dealing
with services our management tools are
now becoming part of workflows part of
critic workflows business processes that
need to be supported and maintained a
going-forward basis that means we need
to begin in our day-to-day work applying
rigorous software engineering discipline
to how we manage our stuff I mean 15
years ago it was kind of a novel idea
wait you mean I should check my bash
scripts into revision control nowadays
if you find someone who isn't checking
into to get or to some other virtual
system their management tools you're
like why aren't you doing that why is
everything on your laptop and if you're
not here we can't run the tools that we
do to manage our business right we are
becoming whether we like it or not
software engineers who happen to run
systems that's just part of what we're
dealing so we want to use languages and
tools that support that paradigm bash
and Python were not designed as software
engineering languages they were designed
as scripting languages but our scripts
are no longer this long they're not
along I mean this long there are now
thousands and thousands of lines long
with multiple modules and multiple
contingencies so you need release
management you and all those other
things now
I'm a big believer there's no such thing
as just a shell scripting systems ops
tools are not this second-class citizen
when it comes to how our software in our
systems are managed they need to be
treated first-order citizens and we need
to use languages that have things like
type safety classes packages and a sane
release management model so that we can
apply the correct rigor to how we're
doing our work okay now
so congratulations you all go and say oh
yeah I'm a software engineer and assists
up so that's what DevOps kind of comes
down to is applying software engineering
discipline to the SIS op business
business function if you're still the
sort of cysts op who believes your job
is to push buttons and run scripts
you're in a dying career no longer is
that enough to run the systems at scale
that we need because if you have a
button to push for a business process
and now there's a thousand buttons you
have a thousand times more work if you
automate the pushing of that button you
know have the same amount of work
whether you have a thousand or ten
thousand or a hundred thousand systems
and I think this is a good thing because
humans are really valuable resources you
are all smart intelligent capable
lateral thinking things and when you
have a ticket whose workflow is oh go
look up this procedure run these fifteen
different commands copy and paste this
here in here and then hit enter you're
being treated like a machine and that
shouldn't be our default state humans
should not be treated like machines
machines should do the machine stuff
humans should do the stuff that requires
the intelligence and the creativity of a
human being so let's get backed into the
golang stuff because hello world's a
very simple program and it actually
doesn't do anything useful for for
coding most of what our scripts do is
run other tools right and so going has
an ability to run sub programs right and
it's a little bit more its syntactically
different than Python but it's really
not much different than using the Python
sub process module or any of the other
wrappers around it to try and solve all
the other problems around it and so here
I've got something that just runs the
date command okay excuse me
captures the output and then prints it
out right but that basic pattern of I
want to run a program capture the output
and maybe do something to see what the
output was is endemic in many many
management scripts and utilities and
it's no harder to do and go than it is
doing Python the difference is remember
across darwin OS 10
i'm sorry OS 10 and darwin Windows Linux
BSD Solaris you can write one script and
it runs on all those platforms without
you having to maintain compatible
runtime environments on all those
platforms so when it comes to running a
subprocess
we very end up we were often end up
dealing with platform-specific code in
this case I'm just trying to get you
know the the dump of the status of all
the network adapters now this is
obviously a Linux solution and if I was
trying to write a tool that captured
this and then maybe uploaded into a
config database or something I would
need to do something different for
different operating systems so what
we'll do is we'll refactor this a tiny
bit and instead of just directly
executing a command we're gonna use a
little bit of syntactic sugar and say I
want to call a function that says give
me the appropriate command to run for
the environment I'm in because even
though it is cross-platform and all that
there is still operating specific
operating system specific code that you
have to work with but the good news is
the language itself has built in support
of how to interface and deal with this
is the code path or operating system a
this is the code path wrapping system B
so we take the actual finding of that
command and we turn into a function that
gets us the command and then that
syntactic sugar exec command CMD zero
and basically says call the exact thing
with the first thing in the array
followed by everything else in there a
basically a very otic function expansion
so if you've got three elements in the
array it'll call exec propria if you got
50 elements in the array to call it with
a 50 element call all right so our get
command function simply returns an array
which contains ifconfig and - a and this
is how we have extracted out the
operating system specific elements of
that command line so we then take that
function though and we take it out of
that main go file and we put it in a
file called main underscore Linux go now
the the go compiler is smart enough that
if it sees underscore and something that
could be a go OS environment variable it
will only include that code if you're
compiling for that target so this here
is the exact same bit of code as the
very first example and all does is
gather the ifconfig output but we can
now add main underscore windows dot go
and look at that we have ipconfig /all
instead of ifconfig - a we now have the
exact same functionality for gathering
IP configuration information and we only
have to maintain ones tiny slice of code
that's different per platform all right
but what about these bsd guys
are we gonna leave them out of the fold
no we're not because go laying actually
has even more capability to find
platform-specific code so you could
obviously do this now given the example
they give you the one I've described
this will be a valid solution right
we now have main underscore FreeBSD we
have main underscore Linux we have main
underscore Windows and we then have our
actual program and that's where all the
logic of you know the database
connection to the configuration
management system and whatever you're
gonna do with that data to upload it to
your auditing environment or or so on
all that's hidden in main and it's the
exact same code on every single platform
because of course the net HTTP and all
those libraries are provided identical
cross-platform it's only the actual
command line to get that dump of bytes
that tell us all about it that varies
and of course you can also have a
function that parses it and returns you
know IP addresses and interface names if
you wanted there's platform-specific but
that's all exercise for you guys to go
to but of course from a software
engineering perspective this is not a
good solution this is where you would
end up if you were using Python or even
a bash script that was trying to you
know if you name - whatever was this
then I'd have this and you know up with
this duplication of code one of
important the principles of software
engineering is that don't repeat
yourself principle and here we have the
exact same ifconfig - a in two four and
platforms that's not a good thing so
instead you just say I want main
underscore unix-like now unix-like
doesn't mean anything it's not magic to
the go compiler but instead I've added a
magic comment at the top of the file
where I say plus build linux darwin
NetBSD OpenBSD FreeBSD that means if I'm
compiling for any of those targets use
main underscore units like if I'm
compiling for me an underscore windows
use the other file so now simply by
eliminating another file I know I'm
targeting one two three four five six
platforms with the exact same tool that
will gather data and that could extend
to any other of the supported platforms
all right so there are two mechanisms as
I said that allowed go to make it very
easy to write code for different
platforms the first is you create a file
named after the go S variable that is
for the target you're trying to compile
for the second is use a build directive
at the top of the file these are
completely interchangeable they do the
same thing the only reason there's two
is for software engineering so you don't
have I have config - a repeated in nine
different files for nine different
platforms all right now in the case of
that plus build I have Linux comma 386
and Darwin
things separated by a comma mean and
this file should be included if you're
targeting Linux with a 386 architecture
or if it's Darwin and you can mix and
match these things to create custom
combinations so you specify your target
operating system with a go s variable
and you specify your target arc triggers
go large or you specify both now this is
the current set as of the end of last
year I haven't looked at the latest set
of all the different architectures you
can sport you'd write one script and you
could do ARM based Android you can do
bsd bsd on arm right you know all those
embedded devices are out there you can
do plan 9 all right all this stuff is
out of the box supported Linux on PPC
who here has PPC 64 systems that are
part of their environment anyone yeah
yeah wouldn't it be great if you could
use the exact same tool on it as you use
on everything else and make it no longer
that snowflake that you have to go and
deal with all right I mean the key about
scalable system administration this key
about DevOps is eliminating snowflakes
and going allows us to eliminate
snowflakes left right and center and
that I think is a very very good thing
so yeah
so in conclusion you're now writing
scripts I'm sorry writing services not
scripts services need the full software
lifecycle lifecycle and going has really
really powerful features that make doing
software engineering good software
engineering easy deployment easy
management right into the language and
there it's all for free right out of the
box so I think go lying is the perfect
language for DevOps development</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>