<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why Functional Programming Matters | Coder Coacher - Coaching Coders</title><meta content="Why Functional Programming Matters - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why Functional Programming Matters</b></h2><h5 class="post__date">2017-11-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oB8jN68KGcU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">one of the things when we start talking
about functional programming and by the
way the title of this particular talk
actually comes it's the same title as a
memo and a lot of people consider it be
sort of the the root of the discussions
around functional programming why
functional programming matters was a
memo by gentleman by name of John Hughes
and it goes back quite a ways I don't
think it was published before I was born
but it was pretty close somewhere in the
70s if I'm not mistaken and then it he
talks about why functional programming
is important why it matters and so it
seemed like a good way to sort of reuse
the talk but you know whenever we start
talking about some of this stuff it
helps to begin from base definitions so
okay what's programming language formal
language as opposed to an informal
language like most spoken language
formal language designed to translate
ideas into machine instructions which
then begs the question what exactly do
they do for us and to be very blunt what
most languages end up doing is they
choose a certain number of concepts that
they want to capture what we call a
first class concept and expose that to
programmers as a way to create things
that we don't have to constantly
reinvent the wheels the whole don't
repeat yourself principal the DRI
principle which many people attribute to
the primes actually has a long history
long before them Pearce is author of an
extremely dense book on types and type
theory types and programming languages
each significant piece of functionality
in a program should be implemented in
just one place in the source code go
further back in introduction to
programming with s Algol any Algol
programmers in the house come on show of
hands yeah no no alcohol program turns
out that that was a significant concern
for Algol which in many cases predates
all of us as programmers basic dictum
that aims to reduce duplication of
information in a pro
usually with an emphasis on code
duplication whenever practical by making
use of abstractions provided by the
programming language of software
libraries and then scheme same thing
structure and function should be
independent in short most of these
languages regardless of the type of
language you choose whether it's
object-oriented dynamic functional
procedural line oriented line numbered
whatever all of these languages their
goal is to provide some abstractions
that you can use to represent things
what's the abstraction principle now for
most of us that has been objects right
is there anyone in this room who is not
did not grow up cut your teeth on object
oriented programming show fans there are
a few of us old-timers who may have done
some procedural programming before
objects became the fad but for most
people in the industry today
objects and we were taught a number of
things about objects this is the way
that the world is modeled this is the
way that God thinks when I hold up a
thing it is an object and it has
properties like color and and soft foamy
nesting and it and we got the color here
it's got a number a label we can
attribute things to this but this is an
object and we can debate as to whether
this should be a singleton object or
whether there's multiples of its kind we
happen to have another one over there
but these are objects and it's very
clear that these objects have both state
and behavior
it has a state color it has a behavior I
talked into it and everybody here's what
I say or perhaps that behavior is not
actually a behavior of this object but
this object's behavior is to transmit
that data to another object whose job is
to then transmit that data to other
objects scattered around the room which
will then transmit that data to your
ears even your ears are an object
because that's what captures that data
and then transmits to your brain which
is another object it is a world
filled with objects until it's not
because one of the things that we
frequently run into is places where
objects seem to fail us for example how
many of you have ever physically laid
hands on a tax rate I don't mean on the
money used to pay the tax I mean
physically laid your hands on a tax rate
objects should be real right they should
be a thing they should be something we
can all agree on how many of you ever
physically laid hand on a business rule
or a validation as a matter of fact if
you go looking through the Gang of Four
book you'll discover that there are a
lot of objects in the world that don't
really seem to correspond to objects for
example how many of you have ever held a
strategy in your hands or maybe you
happen to have wandered across a visitor
I don't mean the kind of person that
comes to your house and stays there for
too long I mean an actual visitor object
or a decorator or a composite or a
command there's a lot of these objects
don't seem to fit with the traditional
object paradigm and as a result in some
cases traditional object solutions kind
of seem to get away from us for example
when we start talking about
transactional processing well okay yeah
that doesn't really fit the traditional
object modeling paradigm as evidenced by
everybody's favorite whipping boy
enterprise javabeans because you know
EJB just sucks but when is the last time
you ever laid your hands on a
transaction can I inherit a transaction
from something else what is the
transactions logical semantics parent
that doesn't even make sense to ask this
question functional programming
fundamentally if you want to if you want
to get up and walk out right now
functional programming is a different
way of thinking about how we apply the
abstraction principle that's it the end
give me good evals there's the door now
what that really
means that's an exercise in walking
through some of those definitions etc
but the key thing to understand one of
the one of the things I hear one of the
reasons I hear people routinely citing
uh functional programming it's so hard
for all those people who went to
university and got computer science
degrees and the for data scientists and
all that stuff that just give me objects
objects are intuitive and I understand
them yes because that's what you were
trained on funny thing most of the
people in this room polish is intuitive
alas I am NOT one of them my polish is
limited to junk weeow that's it that's
all I know it's not an intuitive
language for me because it's not the
language that I was born under it's not
my native tongue for most of us objects
are your native tongue so yes learning a
new way of thinking about abstractions
is going to be hard and so this is an
attempt to try to give you some of these
basic grounding principles so that when
you walk out of here and suddenly run
into a guy who does cut scala or closure
or even does java because it turns out
functional programming has nothing
really to do with the language you're
using as much as it does the concepts
the language should make some of those
concepts easier to use but just like you
could do objects in C you can do
functions in Java so some basic
functional concepts and we'll go over
all of these immutable values functions
as first-class currying and partial
application expressions as opposed to
statements laziness typically although
not required we will see that most
functional languages will be strongly
typed and type inference meaning the
compiler is actually better than you as
to figuring out exactly what a given
things should be recursion we typically
have tuples and we prefer lists over
arrays which we'll get to in a little
bit and there's also typically a concept
of pattern matching and what do I mean
by all of these well first of all the
immutability how many of you have heard
that immutability is a good thing and we
should all strive for mutability yeah
and there's a couple of people like ya
and the rest of your like I'm too tired
don't hurt me
how could you yeah yeah stop hurting me
with this immutability the world changes
man how can you possibly think about
work writing programs when I can't cheat
they're called variables for a reason
they very dull well it kind of turns out
that first of all they don't vary as
much as you think they do if you start
looking at your average Java program
written even before the functional thing
really started to take shape a lot of
times we use a variable we let it hold
some value but we don't often change it
probably 50 to 75 percent of your code
is already intrinsically immutable if
only you'll let it the problem in Java
very bluntly is that to enforce
immutability requires more work on your
part you have to actually type F I n al
oh my god that's so hard to have to type
final int instead of int ah and so
typically a functional language will
choose immutability by default so for
example when I say let X equal 0 this is
just one of many different this is not
any particular language this is sort of
a functional pseudo code but when I say
let X equal 0 the language assumes that
X will not change it is assumed to be
immutable it's the inverse of the way
Java makes its assumptions the default
is immutable and if you want to make it
mutable you typically have to add a
keyword this is actually a good thing it
forces you as a developer to fall
naturally into immutability unless you
deliberately choose to make it mutable
which also serves by the way as a signal
to the rest of the other programmers who
will be looking at your code to say yes
this value will change over time now the
other thing you notice of course is that
x y&amp;amp;z don't have any types associated
with them yet the compiler in a strongly
typed language will know exactly what
those are they're integers how do we
know because that's what's
right hand side of the equal sign doh
what else could it be
now most languages will give you the
opportunity to explicitly specify what x
and y should be if it should be some
kind of you know if you want it to be
along even though that's an integer
constant sure they'll let you do that a
type descriptor typically it'll be X
colon long or something similar not
always depends on the language but the
other thing then is our terminology
changes up here a little bit x and y and
z are no longer variables because yeah
they don't vary they don't change they
are values and this is a value binding
to say that we are binding the value 0
to the value X and we continue now
probably the most important aspect of
any functional language is the idea that
functions are first-class values what
that means is functions are things that
we can use just like anything else in
the language you pass around integers
all day long well why can't you pass
around functions as well that makes
total sense it is a first-class value it
is something that the compiler
understands intrinsically and is able to
use manipulate etc and what this will
allow us to do is to capture some of
these common operations and reuse them
but more importantly allow us to pass
logic around as easily as we would any
particular datum so for example here I
have a list of numbers I know it looks
like an array because it's square
brackets but we prefer lists because
again we prefer immutability and lists
are actually better for immutable values
than arrays are so here I have a
collection a list of numbers 1 2 3 4 5
and now what I want to do is I want to
transform that list into a list of
squares meaning those numbers times
themselves each time so 1 times 1 2
times 2 3 times 3 etc so here what I do
is I take a function which I've
expressed right there directly in the
code and I apply it that's the term to
each of those elements in the list thus
transforming each element in the list
then collecting them into a list and
handing it
and you say dude I could do that with a
for-loop why is this any better than
what I do every day and I will tell you
this what happens if that becomes a list
of five million elements as opposed to
five how's your for loop look and then
because funny thing that function all
that we really know that map function
that transformer all that we know it's
doing is it guarantees it will apply
this passed in function to each element
in the list it does not guarantee that
it will do so serially as a matter of
fact depending upon how the packaging
system works that could easily be a
parallel version of map that spins up
say fifty to five hundred to five
thousand threads breaks the list up
evenly across all those threads applies
the map across each part of that list
and then reassembles it it's classic Map
Reduce except without the reduce hence
the name Map Reduce and your code over
here in order to take advantage of that
highly concurrent behavior what do you
have to change nothing because what I'm
doing is effectively and the inversion
of control don't I bet you didn't think
you were going to hear that phrase and a
functional programming talk because
typically inversion of control is meant
dependency injection right all that
spring goodness garbage whatever we go
to constructor injection property
injection blah go talk to Josh long
he'll talk your ear off about that stuff
this is why Martin Fowler never liked
the term inversion of control to
describe dependency injection because
the inversion of control can actually
happen in a variety of ways here we're
inverting the control as to who exactly
is responsible for doing the squaring in
the list when you write a for loop you
have to do it here we're letting the
library do it based on logic
you've given it it allows the code that
you write to be executed in a different
context there's also this concept of
partial application and currying which
is going to be very very difficult for
many Java C++ c-sharp developers because
we normally think hey if I have a
function that takes two arguments and I
only give it one argument what do I get
a compile error of course duh the
function takes 2 arguments strongly
typed language you have to provide two
arguments to it right not necessarily
not if you're using a language that
understands that functions being
first-class values can actually be
partially applied remember the use of a
function we call it applying a function
so it can be partially applied by
providing less than the full number of
parameters and the return from doing so
is a function so here for example I have
a function add that takes two parameters
X and Y and now if I say I want to
invoke add but I only want to give it
one parameter the literal value to what
I get back is a function that is
expecting one parameter as it turns out
if you take this to its logical extreme
everything is a function that takes one
parameter because if I have a function
that takes three parameters I give it
one parameter and then it becomes a
function that takes two parameters I
give it one parameter then it becomes a
function that takes one parameter and
actually if I take these functions that
are all expecting one parameter and
chained them what we call currying we
get this really nice pipeline effect but
the end result of all of that
composition is we call it is a function
it's the same kind of composition we do
with objects but we're doing it with
logic and we're not inheriting and we're
not owning and yeah okay so it's not
really at all like composition from the
object world except in the name which is
important
we tend to think of these languages as
strongly-typed largely because quite
frankly it's a lot easier for them to
operate it's a lot easier for them to
work we want them to be able to make
inferences about our code all of the
examples I've shown you are strongly
typed functional language because the
compiler can figure out in each case
what the type of the things should be
and as a result the compiler doesn't
need you to tell it what those types
should be compiler can do it on its own
hence type inference if anybody's ever
played around it all with c-sharp we've
seen a limited form of type inference in
c-sharp using the VAR keyword for local
variables that's as far as they can go
if anybody's ever played around with
scala you've seen type inference if
you've played around with closure you've
actually worked with one of the
dynamically typed functional languages
lisps intrinsically are dynamically
typed as opposed to strongly typed we
also have a tendency to like recursion
this largely has to do again with this
notion of immutability if you are
somehow iterating across a loop and if
you're keeping track of some sort of
state by definition you're making local
changes this can create some problems if
however we recurse
we're actually keeping state on the
thread stack itself rather than in some
variable which could potentially escape
the thread and therefore be clobbered by
some other thread and so as a result
functional languages have a tendency to
be very highly recursive now normally in
languages like Java C sharp C++ etc we
dislike recursion because it tends to be
more expensive than if we just do a for
loop most of the virtual machines that
we deal with today are actually
implementing tail recursion
optimizations so that they can see where
what's called a tail call is taking
place where i recurse back into the same
function and they can actually unroll
that they can unate instead of a call to
another stack frame on down they can
actually keep it all inside of one stack
frame making it just as fast as using a
for loop if not in some cases faster one
of the things that we also prefer
some of these functional languages as we
prefer expressions as opposed to
statements now for a number of you this
is going to be kind of a weight of what
instead of a one when we think about
programming languages as I said this is
a formal language we need to define the
terms of the language so when we talk
about an expression an expression yields
a value so when I say five that is an
expression that yields the value five
we prefer expressions we prefer things
that yield values there's a kind of a
long and rich history as to why they
prefer that but functional languages are
actually pretty unified in this idea so
for example when you look at Java there
are actually two forms of if one is an
expression in the other is a statement
the statement is the one that most of
you familiar with if a curly brace do
something else curly brace do something
else that is a statement it yields no
particular value if however you move
over to Scala for example then if-else
is designed specifically to yield a
value I can say Val result equals if
very similar to Javas question mark
colon operator the ternary operator
which says give me expression some
boolean value question mark expression
value : other expression value semicolon
one of those two will be returned as the
result of this particular expression we
like expressions largely because
expressions very much stem from the
field of mathematics where it's just
where a lot of these concepts basically
came from and expressions actually help
in many respects because it gives us
values to work with we can chain them
etc we also like tuples and lists I've
already talked about lists we like them
because they tend to be immutable more
easily particularly singly linked lists
I can peel off the head of a list the
remainder of it remains unchanged
therefore by definition I haven't
actually tried this list I'm just
pointing to a new head but tuples this
is a concept you may not have run across
before a tupple is a very simple idea
it's an object with fields no methods
and no names
if you've ever built a data transfer
object to DTO you have built a tuple and
it turns out that tuples would be
fantastically useful in a variety of
places for example the jdbc resultset is
fundamentally a tuple actually to be
really really technical about it it's a
list of tuples with some metadata
describing the columns that the tupple
fields each correspond to we see tuples
all the time in these functional
languages and in many cases if you
combine tuples with the idea that
functions are first class objects
meaning we can pass them around like
data and therefore I can put a function
as a value inside of a tuple we get
dangerously close to objects without
ever inventing any sort of explicit
object-oriented paradigm this is what
Lisp has done for many years this is
what closure uses in a number of places
and so on and so on
now there's also which is a little bit
more beyond where I want to go today
there's this concept of pattern matching
think of it as a switch but it's a
switch on steroids but it's good
steroids you won't actually like beat
anybody up if you use it because I can
use pattern matching not only to
evaluate the value but the type of the
thing I can put guard clauses on it etc
etc etc there's also this concept of
laziness that I don't actually evaluate
anything until I absolutely have to
which again is something that some
functional languages choose to pass by
the more traditional languages Haskell
for example really embrace laziness is
an important concept but most of the
other languages f-sharp Scala closure
they'll give you as much laziness as you
want but we've actually kind of don't
need a lot of it because one of the
things that we do have are these notions
of sequences streams is what Java 8
calls them and we can do various things
with these sequences so for one of the
classic examples in any functional
programming language is that of a
Fibonacci series where you add the
previous two numbers
get the current number it's all the rage
if you do anything in the functional
space you will write a Fibonacci it's
just it's like the hello world it's like
the C++ developers we all had to write
our own strain class and Java developers
we all had to write our own servlets
well functional programmers you all have
to write your own Fibonacci it's just a
thing okay and these sequences they look
and feel a lot like collections in a lot
of ways and you know and you know what
screw this screw this
forget slides slides are boring who
prefers slides over code yeah if your
hand is up you are an architect you just
haven't admitted it yet all right so
let's do this I'm going to get stuff out
of the way here
all right so first of all I have a
classic person class is there any
questions here you sure because there's
a JavaScript talk going on somewhere if
you don't get this you probably want to
go catch that okay and then we have a
collection of persons here right now
what I'm doing here is I'm just using
the standard arrays as list to get them
into a list of persons and as a matter
of fact let me just make sure that it
will yep yeah it all compiles and again
one of the things that I would like to
do because I'm a very generous kind of
person right person P in people system
dot out dot print 'ln here have a beer
right compile that run it
hey everybody gets a beer don't you wish
you are on this list except there's a
problem now none of you know this but
that's my youngest son Matthew I don't
want him to have beer for the very basic
reason that at one point when I was
asking Matthew to clean up some stuff in
the kitchen he ran across a bottle of
scotch this was probably about three
years ago or so and he said hey Dad
what's this and I said that's scotch
whiskey and he said oh can I try some
he's 13 and I thought wait a minute
parenting moment parenting moment right
because when I was a little bit younger
than him my dad came back from a trip to
Europe with a bottle of Chivas Regal and
said hey dude would you like to try some
and I tried some and it burned all the
way down and it totally cured me of any
desire to drink any hard alcohol until I
met Neil Ford so I thought parenting
moment I said Matthew would you like to
try something he said sure so I took out
a glass normally you pour like a finger
for scotch they give him like a
fingernail just a splash here you go he
tries it he goes oh that's good
damnit I did learn something important
that day that if you're going to do this
with your children do not use 25
year-old McKellen
prefer Shiva Sri --gel so I don't want
him to get beer I think it's fairly
self-explanatory why so now what I can
do is of course I can say hey if P dot
get age is greater than 17 or weight
drinking age is 20 in the United States
okay so now compile run yay now we could
go through and do this exercise couple
more times but fundamentally I'm gonna
stand up here and tell you that this
code is intrinsically on reusable I
can't reuse this code if there is
another place elsewhere in the code
where I want to give everybody a beer or
if I want to test to see if everybody's
capable of driving or if I want to see
if people are old enough to get
retirement benefits or if I want to find
all of the newer Zin this collection of
people or or or every time I do a for
loop I am intrinsically writing non
reusable code I am intrinsically
violating dry and so you say to yourself
self I'm a smart programmer I want to
figure out how I can reuse some of that
code and so you will say I'm going to
create in this case I'm going to copy
just because I'm a little concerned of
time you will create let's see there we
go you will create a class called lists
and this will be basically just a static
utility class and I'm gonna grab this
right here so I don't have to type it
and this function here this filter is
going to say give me a list
that's what this first parameter is here
and then give me a function that knows
how to take a particular type a person
and return a boolean and I will walk
through the list and see if that
function returns true and if it does add
it to the resulting list and then return
the set now again I just accidentally
bumped into I want these results to be
immutable right so here
whoops when I go back to app now I can
say alright fine list person drinkers
equals list dot filter and now I need to
pass in a predicate and actually I think
I have a predicate yeah I do but I've
done that in terms of function one if
I'm not mistaken
yes function 1 this is frequently and
matter-of-fact in Java 8 this will be
referred to as a predicate anything that
returns a boolean instead of an
arbitrary value okay so we can look at
that later if we need to all right
so now function 1 this is a very simple
interface and again something exactly
like this appears in Java 8 now so I
don't have to use this if I don't want
but this way I can show you that there's
nothing of my sleeves
there's nothing magical here this
interface consists simply of a function
and again I use the name apply because
that's sort of the standard terminology
that everybody uses and it takes a
parameter and it returns the results
this is pretty straightforward stuff
yeah so that now when I come back here
and I say all right I want to use this
filter when I go into my app I will say
fine I want to this will return a
boolean and it will take a person like
so you swipe this out a little bit so we
got a bit more room to work with awesome
and then
if Pete get age actually I don't even
need to do the F I can simply say return
P get age greater than 20
oops
Oh lists haha see this is why pair
programming works guys and oh yes thank
you still cannot find the symbol lists
dot filter this dot filter let's see
here I don't think I need to do this do
I maybe I do know that gave me more
errors
more errors bad
nope
what symbol can it not fine what Dubai
oh did I not save that that would be
silly
yeah but none of you guessed it either
so hey look at that
now one of the other things we can often
do with these things as they've said is
we can do some transformation to these
guys in fact let me just uncomment all
of these right so that I can transform
this thing from one thing into another
we've already seen map we saw that
earlier when we talked about how we were
going to square the elements inside of a
list but we can also transform this
thing from one thing to another so for
example I can come back to app here and
I can say alright you know what what I'd
really like to do is I'd like to get a
list of everybody's names and in this
particular case I'm going to create a
function that returns a string it takes
a person like so so actually what I'll
do instead just to keep it a little bit
easier we'll do this with ages just to
extract the age out of it this is
actually what happens whenever you do is
select and sequel so I can simply say
return
like so and then
thank you I knew there was something
about that what bothered me like so hope
turns out I need one other thing from my
templates
but
what happened to my temples couple to
Java oops
helps if you actually save it off there
we go
cannot be applied because it wants list
of our Oh
hey just as a tip by the way don't do
this don't put the list in the front and
then in the back on everything else
that's just silly
so we'll transform like so you know
having all these templates in a
different directory seemed like such a
good idea okay so there we see
everybody's age and again one of the
things we can do with this is we can
also do a reduction operation on this
which we call a fold we start with some
seed value we can take a list and then
we have an operation that takes a return
value takes the seed takes the parameter
and what I return for this particular
operation in other words I take a list
and I start folding the two values
together in various ways so for example
if I want a summation of all of the ages
so that for example I could divide by
the number and get an average age or
what's not this is actually one of the
reduction style operations so that now I
can say integer total ages equals lists
dot fold we're going to start with the
seed of zero because that's where I want
to begin whenever I'm adding something
up together and let's see I'm going to
pass in the people and then I'm going to
need another one of these functions
whose job it will be
to essentially add these up over time
out print line total ages and there we
see the total ages of everybody is 212
yeah what an amazing demo except you're
all bored no no it's okay I totally get
it you're all bored you're like dude I
do more interesting things than adding
up people's ages
I do important work I do important work
like take a collection of person objects
and transform them into XML that's what
I do I'm important well shoot screw you
I can do the same thing
oops you can actually start here
in this case I'm going to do a stray a
string take a person and I'm not going
to need this because the seed is
actually going to be sufficient and then
public string apply string current
person P return current plus person how
about we do this
I'm sure I'm missing a couple somewhere
let's see up there it is there we go oh
yes I must have a close prints close off
the fold operation and look at that no
soap no Jax be just simple functions
because it turns out when we stop and we
start to think about processes behavior
functions as first class concepts and
yes I know one of you is sitting in the
audience going he forgot the quote marks
on his attributes that's not a that's
not a compiling demo fine fine
tell ya
polish attendees man oops
don't
just kidding
you happy now
shut up
that's where my bad evils gonna come
from because look guys fundamentally all
this functional programming stuff it's
just a different way of thinking about
the world it's just a different way of
thinking about how we approach these
problems it's just about taking these
these these things that we've used to
call methods and extracting them on
their own and this is what makes it hard
for the traditional object-oriented
developer is that we are accustomed to
looking at the world to say here we have
state and here we have behavior and of
course we combine them together to
create this concept of an object an
object is not complete somehow unless it
has both state and behavior but when
presented with all of these issues with
all of these problems look at the Gang
of Four book and you realize that none
of those with very well I shouldn't say
none very few of those are actually
dealing with what we would consider to
be domain objects most of the time
they're dealing with these ephemeral
things these rules these strategies ways
in which to do double dispatch etc and
so on how to construct objects I mean
the idea of using an object to construct
an object kind of it's weird when you
start phrasing it that way so the
functional programming paradigm simply
says look man take the blinders off not
everything has to be cast in terms of
objects yes objects are a useful
property they are a useful thing it
makes sense to model significant part of
the world using objects but there is
also this other concept the notion of
functional programming the notice of the
the concept of the promise of
transformations of capturing these
operations and using them in somewhat
composing them now my little pseudo
functional library peer it lacks a bunch
of stuff including the idea of partial
application it would be great for
example to take that function that
transforms a single person and capture
that as a function and I can do it I can
certainly capture it off because
Java's always had the ability to capture
off these interface once I have an
anonymous implementation like this I can
capture it off and store it as of
reference to something I would probably
stick it on the person class since that
has everything to do with persons and
then use it in various context it's more
work to do that because the java
language didn't support functions
naturally now today we actually can make
a lot of this code go away through the
use of the java eight syntax but because
that's not common yet I chose not to use
it but what an interesting exercise
would of course be to transform this
into something that's Java eight
specific and use the Java util function
package make use of the function type
make use of the composed method that's
present on the function type make use of
the predicate type that's present within
that package instead of building it
yourself because quite frankly just like
with a lot of the object libraries that
are out there it's far better to let
somebody else build it debug it test it
etc oh and by the way since we're
talking about testing let's look at this
code here and let's look at all the
places that I really should be thinking
about testing so for example this idea
of filtering out well assuming that
filter works for any arbitrary list it's
already tested for every possible list
and how many of you would sit down and
write a series of test cases for get age
greater than 20 I'm sure somewhere in
the back somebody's saying well TDD says
because you know the greater than sign
might be broken and if that's the case
folks you have bigger problems
just saying a functional approach
because it tends to prefer small atomic
functions like this is actually
ridiculously easy to test ok I want to
capture off this this drinking age
filter great I capture it off I'll store
it as an instance of a function one
somewhere and then I'll test it with
like maybe three cases if you want to
get really really crazy about it I'll do
like 19 20 and 21 because the funny
thing about integer math is all the
other cases would more or less be taken
care of at that point down here P get
age just as a reminder get age consists
of return age where's my TDD guy who's
gonna argue with that I mean at the end
of the day how much can you really test
some of this stuff it is built off of
some of the basic primitives within the
language so you're testing bird and all
of a sudden becomes negligible and yet
we're building up these little tiny
atoms into larger molecules we're
composing functions into larger
functions to the point where by the end
of this we have successfully transformed
a collection of persons into an XML
stream suitable for shipment as part of
a soap envelope you could do the exact
same thing with JSON a matter of fact
you know exactly where you would do it
right there in that apply method just
simply put some JSON syntax around it
and voila
you now have the ability to transform to
both xml and json via the use of only
one function for each without violating
encapsulation put that in your pipe and
smoke it
so where does this take us where does
this leave us
well the concurrency thing is a big deal
we have lots and lots of cores that want
to operate in parallel and if for
whatever reason this serial fold that
I've got here doesn't work for you you
could always create a
key fold which does it in parallel which
makes use of all of that powerful Java
threaded executor stuff and run this
over a series of different threads and
again because this is this does not
affect the original member I'm returning
a new list that means that you get a new
copy back which means that the original
is not modified which means people could
still be using the original there's no
lock that needs to be had here unless
you really want to make sure that nobody
can be modifying the low weight if
they're immutable they can't be
modifying them which means you're
locking a burden your synchronization
burden has now dropped to basically nil
whenever we start talking about
functional programming concurrency is
typically the first place people go oh
yeah concurrency man that's why you want
to do functions look guys the
concurrency thing is big I won't shirk
away from it but at the end of the day a
lot of you do a lot more with
collections than you do with concurrency
collections are the gateway drug to
becoming functional programmers so even
if you're not in a position where you
can adopt Scala or you can just take up
closure or you really want to play
around with Friese which is a Haskell
variant that runs on top of the JVM you
don't want to take up a new language and
learn new syntax fine Java eight has you
covered do this in Java aids get your
feet wet with this functional stuff and
I guarantee you you will never program
the same way again
peace
by</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>