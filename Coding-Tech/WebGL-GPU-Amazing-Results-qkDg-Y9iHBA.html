<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>WebGL + GPU = Amazing Results! | Coder Coacher - Coaching Coders</title><meta content="WebGL + GPU = Amazing Results! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>WebGL + GPU = Amazing Results!</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qkDg-Y9iHBA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so first what's WebGL well WebGL is a
JavaScript API that lets you run GPU
code from within the browser so it's
based on OpenGL which is the open
graphics library I think oh there we go
time ran its course and what it lets you
do is write JavaScript that runs in the
browser and then you can call out
through WebGL to the operating system
which will then run your graphics code
directly on the GPU which will then
paint a picture back on to an html5
canvas that's just like any other HTML
canvas in the browser and what this
means is you can run GPU code which is
really really fast this is the closest
you can get to the metal in the browser
until web assembly becomes a thing
someday so the general shape of a WebGL
program is this you put in data it
passes through a vertex shader then it
passes through a fragment shader and
then you get graphics so what are shades
or just programs they're just little
pieces or big pieces of code that takes
some input from earlier in the chain and
pass off data to later in the chain so
the vertex shader takes your data and
turns it into points in
three-dimensional space that's it
so your data could just be points in
three-dimensional space in which case
the vertex shader is just the identity
it passes it right through or maybe
you're gonna give it some more raw data
like a audio file that you want to make
a visualizer for so you give it the
audio sound and it figures out where the
3d space visualization of that audio is
and then the fragment shader colors in
the fragments that are created by those
vertices so that that one's name
actually sort of makes sense and so it
shades the fragments into different
colors and then OpenGL or WebGL just
flatten it down into a rasterized
graphic which gets shipped back to the
browser so what does it look like
so yeah anybody can see that cool this
is just a simple gradient so because
WebGL is sort of see like the way you
return a value is by setting a global
variable it's it's very good programming
practice and so the this is a fragment
shader which will draw a simple gradient
s and T are our coordinates along the
the two-dimensional plane that we're
drawing on
we're just gonna set it equal to red to
s green to T blues going to be 0 and
alpha is always 1 it's just an RGB a
tuple just like you'd use in CSS and to
get this so this is live this is an
actual iframe showing WebGL code and you
can see up at the top left it's all
black possess in tears 0 and where it's
all red it's in the top right green
simple easy and the cool thing here is
all of those colors you can see that
gradients really smooth if you've ever
worked with CSS gradients you often get
these banding and you can have problems
and that gradient good it is smooth up
on that big screen that grading is super
smooth and the reason is that WebGL is
actually calculating every single pixel
of that 1024 by 1024 image and it's
doing it really fast because it's
calculating the colors for every pixel
at the same time so we can use this for
things like graphics analysis so an edge
finder is if you have an image but we
had to talk earlier everybody knows one
edge finder is cool I can do it really
fast edge finder finds edges in images
by looking at pixels and looking at
either side and seeing how different
those pixels are and if they're very
different you found an edge so here
we're just going to for every single
pixel look at the distance between the
color distance between it and the pixel
to the left if it's bigger than some
threshold that we're going to set then
we're going to draw it as pink and then
if not we're gonna draw it as black all
right here is a small child attempting
to eat an entire block of cheese it's a
reasonable thing to do with a block of
cheese and you can see we found all the
edges in the image and with this little
slider over here I can change that
threshold so we can either look for
every tiny little thing that looks like
it might be an image or sorry an edge or
we can be really strict and say we only
found want to find the strongest edges
in the image and we can do this in real
time so this is another 1024 by 1024
image if you try to do this in
JavaScript on smaller images you can get
away with it but on bigger images it's
just going to choke the browser because
it has to go through every single pixel
in the image and look left and right to
see if it's very different so if I can
bring the threshold all the way down we
just find the really strong ones we came
up here basically everything looks like
an edge with a threshold of nearly zero
and that's cool and it happens really
fast and particles it's not a WebGL talk
without
particles demo they have nothing to do
well they have a little bit to do with
the talk but mostly you need particles
in or deal them oh so this here is a
vertex shader and we're going to set the
GL position which is like the fried
colors just where that data becomes a
point in 3d space and we're gonna set it
to sine of some math and cosine of some
math for those who object sine and
cosine are also math but they're swirly
math which is where the swirly Ness of
the particles come from and there's one
particle and it's add a few more there
we go there's some more particles more
particles more particles it's a hundred
thousand two hundred thousand three
hundred we got three hundred thirteen
particles there and there Pearl's still
pretty smooth and because we can animate
three hundred thousand particles at once
that pretty close to 60 frames a second
because every single one of them is
being worked on separately alright so
why why can we do these things that we
can't do in JavaScript the main
difference is because you have two main
computing engines within your computer
you have a CPU and a GPU your CPU is
your general-purpose
despite the acronym processing unit
which is really good at doing lots of
things pretty well I mean pretty well
here meaning that the amount of power in
this computer is more than the entire
world you know a decade or two ago but
still it's good at lots of things the
GPU is good at a very small number of
things but it's really really good at
them and what those things are is doing
lots of little math operations at once
so suppose you wanted to do thousands of
kindergarteners math homework at the
same time that's what a GPU is great for
you can do lots of little pieces of math
not very complex but you can do them all
at the same time and it turns out that's
how you do graphics and so we've created
these very specialized pieces of
computing to be able to generate
graphics and three-dimensional graphics
very quickly so someone came along and
said wait a second there's things beyond
graphics that it would be great to be
able to use this parallel processing
power for and so what they did is WebGL
is based on OpenGL
and so they created OpenCL which is the
open computing library and what it does
is sort of take away the more graphic
see parts of the library unless you
access that raw processing power without
having to pretend you're doing graphics
and it's great and you can do all sorts
of cool things with it
so if OpenGL is made available to us as
web developers by WebGL what about open
CL well there's web CL it's coming soon
it's it's never coming it's been it's
been in committee for a very long time
it's pretty out of date at this point
and probably will never arrive in the
browsers there's compute shaders
which are like vertex shaders and
fragment shaders which now make no sense
because I don't for what we're shading
in with the compute here but they're
also coming soon they might actually
show up but at this point even OpenGL is
kind of a little outdated people have
moved on to other graphics architectures
so we might just get open Volker web
Vulcan or something like that before we
get compute shaders and so what if we
just did it ourselves right we're
developers we're good at coding things
yes and so what do we do we can pass
data in we can do all the math so how do
we get the data out of WebGL if you
remember that little flow chart earlier
all we get back is graphics onto an HTML
canvas we don't get to call out to the
the graphics card directly and say hey
can you tell me what the raw result of
these calculations were pixels
all we got is pixels so we're gonna use
pixels and if you think about it a pixel
is just a 32-bit in right it's in RGB a
to bulb which is 255 255 0 255 so that's
8 bits 8 bits that's 32 bits that's a
big number you can get a decent amount
of data out with that and we have canvas
that given image data so we can actually
just ask the HTML canvas hey give me
every pixel that is in you right now so
what we're going to do is we're going to
let the graphics card do its thing and
we're going to return the data output of
our calculation as pixels no problem
there's a couple implementation problem
challenges the this is the biggest one
so it turns out to be fairly expensive
to send data to the graphics card and
really expensive to do that get image
data call it's really slow in the terms
of computing and so what we
is something where we can ship a lot of
data to the graphics card have it do a
lot of stuff and then get it all back
because if we're pinging back and forth
constantly we're gonna lose all the
benefits of the GPU matrix
multiplication this is cool
matrix multiplication is lots of math
it's really simple and we can bundle it
all up into a giant calculation that we
pass to the graphics card and get back
so it has small matrix multiplications
two by twos three by threes 4 24 is all
Milt in but if you want to do bigger
matrices we're gonna have to do a little
bit of magic
alright so quick brush up on matrix
multiplication those who have not done
it since school those who did not pay
attention in school like some of us and
those who've never done it all don't
worry it's really simple so the cool so
this top left cell so we're going to
multiply just like you multiply two
numbers you can multiply two matrices
matrices and a matrix is nothing more
than a table of numbers so if we're
going to multiply these two up here then
the way we do that is for this top left
cell here we take the first row of the
left one and the first column of the
right one we sort of do a little doink
and then we multiply each of the cells
and add them together so 5 times 9 plus
6 times 7 is 87 I got a really hard one
this time that's there we go that's
easier math so 5 times 0 plus 6 times 9
is 54 and you can see that there's sort
of a geometry to it here we're moving
across different cells moves you through
different rows and columns in the in the
the origins so this is the 2 by 2 case
and you just extend this out 2 3 4 5 a
million so speaking of a million all
right
so on the in the WebGL code we're just
going to do this which is just a loop so
for every single pixel which we're now
going to think of as a matrix cell in
our output we're going to iterate
through the correct row and column of
the inputs add them together or multiply
them add them to the total sum and then
set the color equal to that sum all
right so demo time yay this is a 3x3
example so we can do this on the CPU
it's pretty fast it's only doing a lot
not too much
math let's do on the GPU so it's
actually slower and that's because of
that serialization the cost of actually
taking this small amount of data of
shipping it to the GPU getting it back
is more expensive than what we're saving
by doing it in parallel so that's
alright that's closer the numbers are
still the same that's good it wouldn't
be very good if we did it fast but wrong
well some applications all right cool so
about six so these are actually 64 by 64
but I don't have that big screen so you
can see we've got lots of numbers and
now the GPU is starting to pull ahead
there's a little noise and the
benchmarks here yeah let's just turn it
all the way up to 11 okay so we got a
little bit of time now this is the part
of talk where I get to talk about
whatever I want cuz my slides are stuck
and you can't stop me so first thing
you'll notice is there's a spinner there
and that's kind of cool because I'm not
gonna open up the Activity Monitor for
fear of breaking this and having to
start from scratch but we're using 100%
of the CPU right now this is running in
JavaScript it is iterating across a
million elements doing lots and lots and
lots of math and the browser is locked
up if I try to click on another button
or move that slider at the top it it
just won't happen but the spinners
merrily spinning along and that's
because it's using CSS animation on the
GPU yeah you can actually use the GPU
for graphics if you want to be boring so
it's just a little you know it's like a
little did with a width and a height and
a CSS transform so the interesting thing
here is that if I started that spinner
instantly it won't actually animate
because so the way it starts is there's
a CSS class that gets added that turns
all in the appropriate CSS attributes to
show it and to also do the spin and that
CSS class change requires a Dom recalc
and a draw on a paint and all those
things and all those things happen on
the CPU so if I try and start the
spinner the very second I they're the
very instant I hit go CPU it won't
actually spin because it won't have time
to ship off to do that
calc ship it off to the GPU to then be
animated on the GPU so there's a little
delay in here and if you're paying
really close attention earlier you might
have noticed that the spinner unlike the
3x3 case which only the the CP only took
two milliseconds but the spinner showed
for about a hundred to three hundred
milliseconds I forget what the timeout
is right now and the reason there is
because I just left it in all the time
but that's actually good UX because your
user if they just see a little flash of
a spinner they're like what just
happened so even if your spinner is
slower than your event it can be nice to
let them sort of process the fact that
there's a spinner there it's just nice
so I haven't gotten the pop of a doom
yet it's it's actually kind of
terrifying how random it is during this
demo whether it gives you the this
script is taking abnormally long would
you like to kill it pop up just
sometimes it does sometimes it doesn't
when it doesn't I get really scared that
it's not actually working we'll find out
in a little while and one thing I found
out about that spin the the little
pop-up of doom is it doesn't actually
pause or cancel JavaScript execution at
all while that pop-up comes up the
execution is still running so you can't
really rely on that as a way to sort of
save you from really horrible websites
that are just killing you on the CPU you
have to hit the kill button or if you're
working on a demo like this you don't
have to hit the kill button you can just
let it run in the background which is
nice I will admit to a tiny bit of
cheating here the the CPU demo there we
go
I won't have to admit to the cheating
yes all right so that's what run in this
time oh this computer's a lot faster
than my old air-cool that's why I didn't
get to tell the third story all right
it's a hundred seventy thousand
milliseconds so yeah when you start
having to put commas in your benchmarks
to be able to read the numbers or
decimals when we're in Europe whichever
you use to make that number readable
it's a bad sign about your benchmarks
you probably should no longer be
benchmarking you should be rethinking
what you're doing all right so that's
170,000 milliseconds that's 170 seconds
that's just under three minutes all
right
GPU all right that's faster
sure yeah that's pretty cool yeah that's
what a star so that's awesome that's
this really really fast if you want to
multiply two matrices together in the
browser so why because we can do all
that math at once because rather than in
the CPU case where we have to iterate
through every cell in every column and
every row we can do every single cell at
once and what that boils down to Big O
notation not great for whiteboard
interviews very useful for telling why
this is so much faster so Big O notation
basically means about how fast does this
take or about how does this grow with
input size so the CPU version is n cubed
which basically means we have to so if n
is the width of this square matrix we
have to go through n times n for every
single cell and for each of those we
have to go through n inputs times a
constant it's fine for the GPU version
we just have to go through n which is
really really good because we're doing
every single one of the outputs at once
the edge finder that we saw is N squared
in CPU and just n again in the GPU which
is why it's a lot more responsive to do
so you know these are sort of mathy
things what does this look like when we
graph it so here from 0 to 5 so you know
we're basically at that first initial
input you can see n is that bottom line
n squared is the middle one and n cubed
is the one that's shooting off towards
the ceiling and we're at 0 to 5 here and
we just did 1024 so that kind of shows
you where things are go and here's 0 to
10 hundred so at a hundred 100 by 100
and it's disappeared completely N
squared looks a lot like n did before
and n cube is just just still growing
and so there's our 1024 case you can't
even see how you can't even see the end
of the squared compared to just how big
n cubed gets and that's why as this bat
matrix size grows we get so much benefit
from running it in parallel and keeping
to the N case rather than the N cubed
all right cool
so we've got a proof of concept it works
really well what can we actually do with
this if we want to be practical
all right potential application so hash
collision if you are a white hat hacker
you want to make sure that your password
database is secure if you're a black hat
hacker you want to see if someone else's
database is not secure
Bitcoin mining all Bitcoin mining that's
for real happens on GPUs it's it's just
hashing and it's done on GPUs media
encoding if you want to make encode
video encode images do anything like
this it's all it's very parallelizable
cuz it's all done blocks machine
learning like we saw earlier it's
basically just a bunch of addition and
multiplication happening all at once
which is great for signal analysis and
processing a signal analysis is
basically just graphics but with sound
but it counts as something separate
because we have a different name for it
protein folding if some of these are
sounding familiar if you ran a lot of
screen savers back in the day it's
because the exact same properties we're
looking for here have large amounts of
data doing lots of work with an easily
expressible result is exactly what you
want if you want to have a screensaver
that you send out to people to do work
for you actual applications nope nope
nope yes there are a couple libraries
where you can do machine learning using
your GPU in the browser right now Carris
is one of them and there's a couple
others and it's cool it's fast signals
maybe I haven't seen that library but it
should just work and protein folding is
outside my domain but if anybody here is
an excellent biochemist and wants to put
together a library please do alright so
why is it that we can't actually do
those earlier things that's not my cat
but my cat would totally get into that
situation says she's a little derpy
alright here's the big one
there's no bid operations in the WebGL
spec so bid operations things like bit
shifts and bit shifts the other way and
XOR is and all these things basically
all modern algorithms are built around
bit operators because for the last 50 or
60 years very smart people have thought
well we're running computers they work
with bits why don't we build algorithms
that work really well with bits and it's
true it's a great idea except the
version of WebGL that came out a few
years ago was based on an older
version of GLSL which is what the the
language that runs on the GPU is called
and it didn't have bid operations and
they've never bothered to actually
update WebGL to use them and it's really
hard to do a lot of these cool
applications without bit operation so
basically anything hashey
so Bitcoin mining password or just
general like hashes anything like that
is all media encoding is all based on
bit operations and you just can't do it
right now
unresponsive window if you if you look
the the spin are actually chunked really
hard because it turns out animating on
the the GPU and you're also using the
GPU for a bunch of math doesn't work so
well you only get so much GPU per
application given to you by the OS and
so if you're doing this your window like
if you thought doing a lot of stuff on
the CPU major window or unresponsive
make it so that you can't actually draw
graphics to the computer anymore and see
how much work you can actually get done
so this this is a major problem if you
want to run long running tasks and OS
level timeouts this is a fun little
gotcha it turns out different OS drivers
have different just hard-coded timeouts
when they'll just stop running shaders
they'll be like no that shaders run too
long I'm afraid you're hijacking my
graphics card and I'm just gonna return
something it might be black might be the
last value to sit there might be
something and so this is a major problem
for long-running things so what can we
do to make it work for these other
applications newer GLSL version would be
awesome 1.3 has bit operations which
means that we could do all that cool
hashing stuff we might get that probably
not we'll probably get wet Vulcan first
canvas WebGL and worker this is I
believe in Firefox I would have even the
flag now if not it's coming very very
soon so this is gonna be cool if you're
doing service workers and web workers
you can actually do GPU work in them and
that will help avoid some of that window
lock-up problem you can actually try it
out right now is the author of turbojets
in the audience now so someone put
together this very cool library a few
weeks ago which wraps up everything I
just did in all those demos in a nice
little package and didn't take
attribution for it and I was hoping I
get really lucky and they'd be here
right now but they're not go try it out
if you do a nice simple JavaScript
interface where you can write your
shader code and give it the data as an
Raye and it'll give you back the return
is Andray and save you all the
boilerplate which you can see if you're
curious about what that boilerplate is
either go check out turbojet or check
out these slides you'll be able to see
how it works you basically take your
data you turn it into an image because
and then you do some math on it and then
you get an image out all right so sum up
web view WebGL is awesome
graphics are awesome we can do WebGL
from more than graphics and you can
actually do some real applications with
this in your browser right now if you're
doing stuff that takes a lot a lot of
processing power and it's parallelizable
which some stuff is thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>