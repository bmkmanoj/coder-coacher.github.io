<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced RxJS: State Management and Animations | Coder Coacher - Coaching Coders</title><meta content="Advanced RxJS: State Management and Animations - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced RxJS: State Management and Animations</b></h2><h5 class="post__date">2017-12-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jKqWMvdTuE8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is a talk again about advanced
RCS I'm gonna just gloss over what RCS
is here I've done a lot of talks on very
beginner based stuff in in rx and I'm
excited about this talk because I'm
gonna talk about doing some more
advanced things I don't expect everyone
here to be able to follow along it's
fine you can you can catch me afterwards
and I'm happy to answer any questions
this this talks a little bit more for
people that might have used rxjs a
little bit but just to gloss over what
arcs jeaious is as Brian stated in his
talk RCS is low - for events it's it's a
set of operations in whatever that you
can do - to control events as sets of
things so arcs Jess is about observables
and operators you can find in for more
information at a few of these sponsors
there's arcs gs5 on github that's where
the repo is is at this spot it reactive
x /o rxjs the docs herd the reactive
exile web website and then you can
actually look up the tc39 observable
proposal at the bottom like there and
github as as brian had mentioned it says
it's stage 1 I think they're pushing for
stage 2 very very very soon but rxjs 5
is a reference implementation of this
proposal there's there's some minor
differences but it's it's made to match
the observable that might land in the
browser someday so ideally you know I
would have I would get to stop
supporting you know writing the
observable part I could just let the
browser handle them so unobservable what
an observable is just a really quick
version is it sets of values over time
so you you subscribe to an observable
and when you subscribe to it it takes
the observer that you've given it or
takes a bunch of functions that you've
given it makes it wraps it in an
observer and which is just an object and
then ties that observer to something
that's producing data whatever that is
it could be a for loop over an array it
could be a WebSocket could be anything
and then on completion or when someone
says I want to unsubscribe from this
thing because it gives you a
subscription back or when it completes
it's able to tear that down so you can
use kind of expensive things like
WebSockets and close them when you're
done or in this case we're going to be
talking about animations you can do
things like a
roughly stopped an animation or
something like that the most important
part about this is that observables are
sets this is why they're powerful so you
know this is I don't know how many folks
here have ever like looked into things
like category theory if sometimes you
hear people get up to talk about
observables and I've sworn that I would
never say these words in a talk but
they'll say things like monad my annoyed
these sorts of things these are just
names of sets that have certain
properties that's it there's like for
example a mono it is is just a set that
you can concatenate and has an identity
property so an array falls under this
category you can concatenate arrays
together an empty array concatenated to
an array you come back with the same
array so that's an identity that when
you hear those sorts of words it's it's
just someone trying to sound smart I'm
not going to do that anymore
but the thing about is they're sets and
because they're sets and because
brilliant mathematicians have come up
with all these wonderful things you can
do with sets we have all sorts of great
things you can do with sets you can
transform them this was what operators
are so operators are just functions
really that transform one observable one
set into another observable a different
set so you can map and filter and
flatten and do some of these other
wonderful things join them so really to
think reactively when people think about
reactive programming usually that's
explained as let's let's sum some event
fires and then I react to that event and
then I fire another event and something
else reacts to that event when you're
when you're talking about it with rxjs
you're really what you want to do is
think about transforming sets you start
with some one set of events and you try
to transform it into the set of events
that you actually want but this talk is
actually about animations I'm excited
about this because I I do talk a lot
about our exes is like all I talk about
when I come to these conferences and and
the the thing is I'm always up here and
I'm like you know animations they're
like what are the major sources of sets
of events in your apps there's Ajax
there's user interactions there's
animations there's WebSockets and so on
and then I go on to show example
of user interactions WebSockets Ajax all
these other things and I've rarely
rarely ever touched on animations and
you know animations are sometimes viewed
in the development community is a little
bit of fluff like it's not the important
part of your app it's not the functional
part of your app there's talks about why
it is important there's some wonderful
talks about that but I think Sara drast
and some other folks but it's it's it's
also technically interesting and we're
going to get into the technical side of
doing these with arcs yes so there's
different methods of creating animations
in an application the first one a lot of
people go for nowadays is CSS you can do
some cool stuff with like CSS
transitions and keyframes and other
great things and then also there's a lot
of ways to do this with JavaScript
there's raw JavaScript just like go in
and I'm gonna use you know animation
frame or set interval back when I first
started people that use set interval or
set timeout and and you know physically
move the Dom element there's the web the
web animation API I think this is really
only available in Firefox right now I
don't think it's actually made it
through its entire proposal process for
was the what WG is the the standards
body for that there's jQuery a lot of
people have used jQuery to anime that
was one of the things that made jQuery
really popular I think is like wow look
at this I can make stuff move and it's
one line of code right
d3 used it for a lot of data
visualizations green sock and just so
many more there's tons and tons of
libraries most of these these other
JavaScript methods and also the CSS
methods you can just use them like
normal and kind of wrap them in an
observable and that's just wrapping an
API in observable that's the same thing
you do with a WebSocket or anything I'm
not really going to focus on that so
much but I'm going to focus on in this
talk is using raw JavaScript in just
rxjs
to create these animations so it's what
is an animation animation if you look up
the different the definition is the the
technique of this is the actual
definition the technique of
photographing successive drawings or
positions of puppets or models to create
an illustrator to create an illusion of
movement when the movie is shown as a
sequence so it's pretty clear we want to
deal with set so I keep
about sets of things so I can see by
this definition that we've got a set
we've got a set of puppets over time
right no maybe not puppets physicians
over time is really what we're concerned
with in web development so what this
actually looks like if you're to kind of
just take snapshots of an animation is
this really primitive here you would see
I find moving some an object I'm moving
this little ball it's going to move it
starts at position zero and then goes to
position one and so on you can represent
this as an observable I've got this
completely synchronous observable of
zero one two three at the bottom same
thing for rotation you're just changing
degrees over time so you can say have an
observable of those degrees and scale it
gets a little bit more interesting when
you do more than more than one right so
you can you can scale it in two
directions that basically since every
one of these the the width and height
this is exactly the same I could you
know kind of narrow that down to the
same sort of observable but you get the
idea moving to two directions same
things just you've got values over time
and that's precisely what observables
are we need values over time but every
all the observables I just showed you at
the bottom when you say observable of
and some values and then you were to
subscribe to that it would just plate
them all like that like you're looping
over an array it's it's that doesn't
have that temporal element doesn't have
the element of time in it and we need
that for animations and that's where it
gets tricky so there's there's really
two elements of time that I want to talk
about when it comes to animations and
these are not formal definitions I
didn't go out and look up some
collegiate version of a definition of
animations and the types of time
involved this is just my breakdown of
this there's one type of time that you
want to deal with which is your frame
rate and the other the other thing you
want to deal with is some sort of
duration or velocity so let's talk about
frame rate really quick or what a frame
is so a frame is just a moment in time
at which to just adjust the position of
something before you rerender it so it's
it's they you have many many many frames
to make up a movie is I'm sure you've
seen a filmstrip before and there's
multiple frames in a filmstrip
that's all frame is and to get a frame
an appropriate frame in a modern web
browser
you use requestanimationframe this is
the API for requestanimationframe you
call it you give it some sort of
callback that will actually be fired
when the browser says basically when you
call this it's telling the browser I
want to do some sort of animation
browser when you're when you're ready
when you're not too busy and you're
about to do a about to do a render cycle
right before that let me run some code
so I can make some updates so I can I
can schedule this to be rendered in an
updated makeup movement so you call
requestanimationframe it can give you
back an ID you can cancel it later if
you if you choose so it's kind of like a
set timeout sort of uh rxjs 5 actually
has a scheduler that wraps this that
actually handles this for you I'll get
to what schedules are in just a second
but it's you can find out an R X dot
scheduler dot animation frame and it's
it's just this really simple API it's
got a schedule method and a next method
when you call schedule you've provided a
function that you want to fire on the
animation frame and it returns back an
rxjs subscription that you can call
unsubscribe on later if you want to
cancel the animation frame for some
reason it's it's actually really rare
that you'll end up using schedulers raw
like this and and and rx but I just want
to show kind of what the API is so what
a scheduler is in our exes scheduler is
just control the timing of when your
observable events fire so an observable
again when you subscribe to it you give
it some callbacks in it and it it'll
fire your next call back every time it
has a new value or if it gets an error
it'll it'll fire your air callback and
so on so this actually controls when
those things are allowed to fire so if
your observable says hey I've got a new
value for you I'm gonna next this at you
and it's and it's being controlled by a
scheduler it will wait for the scheduler
to to allow that value to come through
to the air handler so it's schedulers
are kind of a gating mechanism because
you won't you don't want to just play it
right now what we want to do ideally in
this situation is oh wait until there's
an animation frame now give me the value
because I'm ready to make some changes
to my view so using schedulers nrcs is
it's pretty straightforward it's it's
available in most observable creation
Syd's as the last argument now skill
schedulers are not something that's part
of the tc39 proposal at all I wish it
was because then I wouldn't have had to
write the scheduler at some point I
could stop maintaining it there just be
one natively but it's always it's always
the last argument to these creation
methods and basically it just says you
know this this observable whenever
whenever you subscribe to it wait until
the scheduler says it's okay to
subscribe and then execute the
subscription whenever whenever this
observable fires evaluate me wait until
the scheduler says it's okay and let the
value through again a gating mechanism
there's also some operators available in
our x5 to use scheduling so you can take
any arbitrary observable and say I want
you to observe on this schedule which is
you know fire your events on this
particular schedule I want you to
subscribe on this particular scheduler
not really important for this this talk
but just so you know that that's another
way you can use schedulers if you want
to try them out there's a few different
schedulers these are these the ones that
currently exist animation frames the one
we will be dealing with today there's a
queue scheduler which is like a
breadth-first sort of thing to keep you
from getting stack overflows ASAP is the
next job or microtesla that's the same
as like a promise so that's always gonna
beat set timeout zero if you do if you
use the ASAP scheduler at zero and then
async which is just the same as set
timeline so if you were to say async
schedule zero it's gonna it's gonna do
like a set timeout zero basically
but again animation frame wraps
requestanimationframe that's the one we
want to use so back to frames so what we
want to do is we want to create like an
observable of frames because that's when
you're doing reactive programming you
start with a set of things we started
with a set of frames then maybe we can
somehow transform that into a set of
transformations we want to make to the
view because it's they're all going to
happen as soon as as soon as this
whatever is at the head of this fires
it's going to go all the way through
synchronously and you know you're going
to try to manipulate this into a
different set of values that you're
going to use to update the Dom so this
is one way to do it so there's there's
an observable creation method called
observable range and you provide a start
and an end so if I wanted to create a
value an observable
zero through nine I could say you know
range zero to ten so it's give me ten
values after zero in it and you you get
this instantaneous observable range of
zero now if I was to just say observable
range zero to number positive infinity
and I've subscribed to this without
scheduling it's just gonna lock the
browser it's basically a for loop that's
the upper bound of is infinity I don't
have time to wait to see if that's going
to complete so we use we use an
animation for an animation frame is then
gonna say yeah I want an infinite number
of these sure but each one of them I
want you to wait for the next animation
frame so there's going to be a pause
between between there it's not going to
lock up your browser and it's it's going
to wait for the next animation frame so
this is going to give you an observable
of 0 1 2 and so on frame numbers that
happen at on animation frame another way
to do the same thing this is my
preferred method is to use observable
interval so you say observable interval
0 and then you run animation frame and
it's identical it's the same thing it's
going to give you frames of 0 1 2 and so
on when animation frame fires so we can
we can actually take this and we can
actually take this and just run it we
could just say well every time the frame
changes let's just change the position
of something so it's gonna move one
pixel every time in animation frame
fires so it looks like yeah not very
exciting but at least we got the ball to
move right and this this isn't this
isn't great this is great because I did
this on kind of an old MacBook Air so
the ball moved at that speed if I was to
go grab you know say Brian's brand new
MacBook and run the same thing that
MacBook Pro it's gonna go and fly right
off of there because he's got a much
faster processor this this the problem
with requestanimationframe is it's
non-deterministic you're waiting for the
browser to say I'm not busy so if your
app is a really busy thing what's going
to end up happening is it's gonna wait a
long time between request animation
frames you might get 4 frames in a
second maybe you get 60 frames in a
second so you don't want to animate by a
frame number that's that's not great I
have to do something better than that
at least now we've got that temporal
side of things handled we've got an
observable of frames so let's let's talk
about doing something with this that
makes it a little bit more usable let's
talk about the other side of the time
equation here which is velocity or
duration so both of these things are
related and they're related through a
very very simple very simple algorithm I
think everybody is probably seen in
grade school which is velocity is
distance divided by time right so time
being the the duration here technically
so if you if you know any two of these
things you can figure out the other one
right but when we were talking about
animating by velocity of de-rate or
duration we're kind of taking different
angles on this so the simplest one that
I'll start with is just animating by
velocity and what I mean by this is I
want you to move by V units over T
amount of times so moved by so many
pixels per second or so many pixels but
per millisecond or so many inches per
per minute or whatever and it's it's
it's just you're giving it like here's
the speed at which I want this this ball
to move or this thing to rotate or this
whatever to fade out and you don't know
you're not giving it a time for how long
it's gonna take you're saying this could
last forever so this is really good for
never ending animations like games that
are running or loading spinners that
sort of thing
the other one is just just to contrast
it animated by duration that's that's to
move you know X by it by you want to
move some X distance over T amount of
time so you know how far you want to go
and you know what how long you want it
to take and then you have to figure out
the velocity right and that's better for
more that's more useful for what I think
most of us work on as far as apps go
because then you're talking about I want
to move this thing from here to here
it's like it's great for transitions for
data visualizations that sort of thing
so we need to build a more useful frames
observable so we've got this frames
observable this gives us frame numbers
but you already know we don't really
want to animate by frame number it might
be useful for some sort of logging or
something but it's other than that
it's not it's not that useful so what we
can do is we can actually get an
observable of time paths for each frame
so we take
the exact same exact same observable we
had before so this is our and our
observable of animation frames or frame
numbers and what we can do is we can say
well let's let's get this I got the
friends the frames out of verse we get
we get a start for like right now it
will just take a timestamp for whenever
we're gonna start this observable and
then we're going to just do some really
simple math and figure what the
difference is at each at each animation
frame like how many milliseconds has it
been since I've started this observable
now but there's there's a little problem
with this which is this this thing here
is all going to run it's going to get
that timestamp before you're actually
subscribed to your observable so here's
a little trick with observable defer I
don't see people use this a whole lot
but it's it's a very very powerful
method in in rxjs which is just saying
I'm going to create an observable that
where I'm going to execute the body of
this function here and I'm gonna return
to you this observable on the bottom so
when I subscribe to the resulting
observable from this observable defer
it's going to actually get that
timestamp or start and then it's going
to return this other observable that is
using that that timestamp internally uh
I can make this slightly more useful by
by creating a higher-order function of
it so if you if you're not familiar with
a higher-order function really it's it's
a function that makes a new function so
it's a it's a way to to get some more
reusability out of out of useful
functions you're gonna see that a lot in
this talk so this is just saying you
know what maybe I don't maybe I want to
test this later with a test schedule or
something so I'm gonna actually provide
the scheduler but I'm gonna default it
to the animation frame scheduler so most
of the time I'm not actually gonna pass
a schedule in but just in case I want to
test this later I'm gonna provide it in
this manner so now I have this
milliseconds elapsed function that will
give me an observable of time that's as
it's passed since I've subscribed so if
I want to if I want to actually move
something by a velocity I can set some
velocity in this case I've got this
velocity named pixels per second and
what I can do is just some simple math I
can I can take
the milliseconds of time passed and then
I know it's milliseconds but I have
pixels per second so I'm gonna divide
those milliseconds by a thousand and
then multiply it by my pickles pixels
per second now I've got an observable of
how far should I move this object right
I can make that into a higher-order
function to make it more useful again I
told you if you're gonna see a lot of
this so now I have a pixels per second
function instead of just a constant
value where you can provide the velocity
you want and it's going to return to you
a function that you can use inside that
map so this is doing exactly the same
thing we're saying over the time elapsed
I want to move by 50 pixels per second
so the just a demo this is the exact
same code now it's moving at 56 50
pixels per second it's a more controlled
rate if I was to run this on Brian's
brand-new laptop it would still move at
the same pace if I was to run this on a
really janky old laptop as long as it
supported the browser supported all the
features that I'm using it's it's going
to run but you might see it jump but
it's still moving at roughly 50 pixels
per second so it's always going to be
where you where you would expect it to
be at that velocity so just a quick
recap on velocity based animations
because that's all there is to it
they're very very simple it's a set of
time do you get it you get a set of set
of time differences on animation frame
and then you want to map those time
differences in tube into position
differences based off of some simple
math around velocity these are easily
the the simplest way to play with
animations is just let's see if I can
move this by so much over so over a
certain amount of time but that brings
us to the more useful version of
animations which is duration based
animations so we we could just take what
we did with velocity and just add a take
Wow right this is gonna do this the same
basic thing it's it's saying move by
this velocity but just take take all of
the take all of the the milliseconds
elapsed while they're less than two
seconds let's say and then do your
movement so you remove it this velocity
for this long so this this is going to
this is one way to do it but I'm gonna
go ahead and say that I don't think this
is necessarily the best solution it's a
solution it's a very simple solution if
it works for you great but I think we
can do a little bit better so what if
what if all the duration based
animations were that were the same we
know you know that durations obviously
always have a start they always have an
end because it's just a segment of time
and it's they're all all we have is
numbers right so we've we can say you
know one seconds past two seconds past
and so on or however many milliseconds
have passed like we have sets of numbers
and numbers can be easily transformed
and scaled so I think we should try to
treat them as percentages and what I
mean by percentages are decimal values
between zero and one so now I know if
you give me a duration of 10 seconds or
you give me a duration of 5 milliseconds
if I'm if I'm getting a whole bunch of
animation frames what I want is I want
to know that it's always going to be
values between zero and one because that
that gives me some flexibility and what
I can do with this observable I always
know that it sets its range of values is
going to be between a certain certain
range so let's build this duration
observable and what we're going to do
here is we're going to take our
milliseconds to lapse function the same
one we made when we were working on
velocity and we're just going to map it
by saying we have this duration function
where we provide this this m/s variable
this is the duration this is how we long
we want our animation to last and we're
just going to take the the the amount of
time that's elapsed and divide it by the
the milliseconds we want the duration to
be all right very simple math and then
we just say take it while it's less than
or equal to one so now we can still pass
the scheduler through just in case we
want to provide that's the same thing
just in case you want to test it later
very simple but what we end what we end
up with is this range of value so you
see along the bottom here it starts at
zero and then you get some kind of
arbitrary decimal amount says animations
frames fire again non-deterministically
and then eventually you you get a one at
the end so
moving over a distance then becomes very
very simple multiplication if I'm saying
that my duration is is is done when you
get the value one then if the distance I
want you to travel over that duration is
300 or whatever you just multiply one by
300 right it's it's you can just
multiply that the the percentage it's
gone by the distance so if right now the
the the frame I'm at is say 0.5 we're
halfway through our duration then point
five times our distance of 300 is going
to be 150 it'll be at 150 pixel mark
it's exactly where we want to be so a
very very simple math just some
multiplication again we can do a higher
order function with this so instead of
having a distance constant that's set to
a specific distance we could actually
make this into a function that takes a
distance and then returns the the the
function that we want that multiplies
that distance x times the the time
that's elapsed or the percentage of time
that's elapsed and we provide that to
our mapping function so down at the
bottom we're saying over the duration of
two seconds I want you to give me a
range of values between zero and and 300
so if we go ahead and we use this and
this is again we're just going to move
our ball again it's exactly the same
observable it moves a certain amount and
then stops so that that moves 300 pixels
over two seconds or 200 or 2000
milliseconds here's why I wanted to make
this percentage based so moving things
in just a kind of plain boring line is
it's great and all but it's it doesn't
have the pizzazz that a lot of people
like to see in their apps most the time
people see these nice animations where
things will kind of bounce into place or
they'll they'll slowly come in and like
and like cruise to a stop or they'll
speed up and accelerate in or whatever
these these things are called easing
this is this is so you're you're saying
I've got this animation I want to ease
it in a certain way or like an elastic
one or something like that
so if our duration observables are
always 0 to 1 no matter how long the
duration is
then another thing to think about is you
can also represent distance traveled if
you've got a specific distance you want
to go you can represent that by a
percentage right if you want to go
I almost said five miles because I'm
American but you want to go five
kilometers right youyou could say I when
I'm starting I'm at zero when I get to
five kilometers I'm at one if I'm at you
know two and a half kilometers I'm at
0.5 and so on then you can you can scale
because it's just numbers you can scale
any number in this manner so we can
represent distance in the same way and
that's really what an easing function
does so now that the values might if you
have say an elastic an elastic easing
function it might go over one a little
bit because it's going to go past the
point it's supposed to go and then
eventually come back right so this is
this is what we're gonna do we're going
to transform our duration of time into a
kind of percentage of distance traveled
over that time and we're gonna do this
again with easing functions the easing
functions that you're going to see come
from this github repository at the
bottom bi mÃ¡t des L I like these
they're they're also based on Rob
Penner's easing functions you can follow
Rob Penner on Twitter like every easing
function you've ever probably seen used
was kind of pioneered by this guy he's
really really an interesting guy to fall
on Twitter very nice guy too but this or
this elastic out method again came from
that that that eases repo and I've I've
modified a little bit to be an arrow
function but all it does is it just
takes a value and transforms it to
another value it takes the value between
1 and 0 and transforms it to another
value that's roughly between 1 and 0 and
this is an elastic out so that means
it's going to go and kind of wiggle to a
stop and we can use this by simply using
a map and in in in our X you just map
that duration to this this distance
travel but it's really important that
you do that before you do the distance
because again it's expecting values
between 0 and 1 right if you do it after
the distance you're gonna get these out
values in this case between zero and
three hundred and that's it's not going
to work out quite right so just to show
what this does is now this is a little
bit
more exciting right and all we did is
just to just add one simple function
it's composed in there you could comment
it out we could do a different mapping
function whatever you like so you can
make animations more reusable you can
make even more reusable than what I'm
showing here with this higher-order
function type methodology that I keep I
keep illustrating but we can do things
for example like you can move the
rendering side effects to a do block and
that's going to make your animation more
reusable because that means you've got
this observable with it now it actually
is controlling the side effects when you
subscribe to it you could allow passing
the duration right to the entire
animation make a higher-order function
that wrapped the whole animation that
you built but again the idea is you you
want to use higher-order functions to
get more reusability out of it so if we
want to make this particular animation
this is the one we just did slightly
more reusable we could do something like
this well now we have this this move
ball function that takes it takes a a
duration observable so now I could I
could give it any duration I want I
could say you know give me a duration of
10 seconds an observable a duration
observable of 10 seconds for a duration
observable of half a second or whatever
and I can pass it into this function and
it's going to return to me and observe
like and subscribe to to perform the
animation and then you see it used at
the bottom I'm saying move ball and I'm
passing in that observable so here's a
here's an example of this this seems
scaled way off I don't know if this is
gonna animate yeah so it's exactly the
same thing it still it still works but
see Oh am i going backwards what
happened
uh-oh I have duplicates I think I'm
going the wrong direction anyways sorry
for that that's exactly the same even
more reusable here we go
so we can make this even more reusable
by using another higher-level function
that says well what if I what if I don't
always wanted to animate that same ball
what if I want to tell it which ball
want to animate well you can just make
that an even a another higher-order
function where now I call it by saying
move move down I give it the ball that I
want to animate with which was a just
like in this case it's a div a div
element and then you pass a duration to
it then you subscribe to the result of
that but we can make that a little bit
better with rxjs so this is exactly the
same code but down at the bottom I want
you to notice that and now I'm using
let's instead of calling things this way
what let is is let allows you to give it
a function that takes an observable and
returns a new observable so Alette is an
operator arcs yes that kind of lets you
compose things more and a left to right
or top to bottom sort of way so this
this is going to sit this basically says
over the duration of two seconds let's
let's move down what we want to move
down this this ball and then we
subscribe to it and it should work so
let's run that and now we can now we can
run more than one animation at the same
time these are all different divs that
we're moving with the exact same
animation and I'm using a merge map with
this in order to coordinate them to all
run at the same time now without
changing very much you can you can now
use the power of rx to sequence
animation so I didn't change much here
all I did was change the merge map to a
concatenate a concatenates it's mapped
to a new observable and play that one
and not not do the next one until that
one's done so it's gonna it's gonna run
them in sequence so if I if I run this
this one even though I changed about oh
six characters it's gonna run them in
order and I did I did another little
thing here which is I'm using the index
to kind of augment that duration every
time like which you see down and line 43
at the very bottom so again as they as
they play they get a little slower each
time and I'm just from but I'm still
reusing the same animations that I built
earlier
so that's duration based animation so a
quick recap on that is that you you want
to create a duration observable that
that takes your duration and represent
it as a percentage so the value is
between 0 and 1 and
what you want to do then is you want to
you want to map that to a distance you
can use easing functions to do this but
a percentage distance if you're using
easing functions if you don't want to
change the distance traveled over time
it was easing then you just skip that
map step and you run it directly but
then it's just simple multiplication to
calculate the difference the the
distance and then again to make these
things more reusable you want to use
higher-order functions in order to you
know just be able to change or tweak
little bits and pieces of it so you can
kind of functionally compose these these
interesting things but duration
animations are all well and good
duration animations like mostly what
you'd see for a duration animation is
things like in d3 you might see you know
some elements are changing over time and
every time they change you want to
instead of just having it jump you want
it to smoothly move to the next value
that it's supposed to be set up so you
know in honor of being in Switzerland I
made this really primitive clock and
this is this has no animations this is
just I used Rx to use Rx to just have
this this timer and the timer is
changing values over time it's saying 0
1 2 and so on and I'm mapping it to
degrees to kind of divide it by 60 and
just have it tick around in a circle I'm
rotating it so this is just this isn't
any of the animation stuff I showed you
before it has maybe the illusion of
animation because you see it moving but
it's not really moving it's actually
just kind of jumping to the next spot
right as it goes around it would be a
lot cooler if we could make this kind of
smoothly go to the next thing so what we
can take is we can use what we've
already built and we can make some
toilet wean function so in order to make
a tween function back I've kind of
busted this into two functions the top
one is that is called pre even current
so this is gonna this is going to take
an observable stream of values and make
it into an observable stream of arrays
that the first argument is the previous
value the next argument is the current
value and the reason we need that is we
need to know how far to move our
whatever our second hand in this case we
need to know how far
are to move that thing and in order to
know that we have to know where it was
at and where it's going so this that's
just a simple a very simple
transformation there I'm saying start
with some initial value and then I use a
buffer count with two and one and that's
going to give us these these arrays of
two values again an observable of arrays
that previous value current I and then
after that down here I've got this tween
function tween is going to say give me
some milliseconds of how long I want
this to last
give me an easing function which is our
little elastic thing that we like to do
and then we say give us some some source
some source observable and our source
observable is expected to be you know a
duration and we're gonna say let pre
even current so we're saying give us the
previous and current values of the I'm
sorry the source the source observable
is actually the source of values that
you want to change between we get the
previous and the current values from
that so now we have a set of previous
and current values and then I'm gonna
use switch map and switch map is gonna
say create this animation down down in
here in the bottom you see duration map
map map that that part is our animations
like just what I showed you in the
previous example
we're gonna use that inside the switch
map and it's basically gonna say you
know over this over this duration we
want to map with this with this easing
and then we want to move by this
distance the distance as you can see is
calculated by subtracting the the next
or the current value from the previous
value and then we we also want to add
the the previous value to the value that
came out of that as well because you
want it to start from where it was
before it moves to the next spot
otherwise it's gonna jump back and then
go and jump back and then go that's not
what we want and then to use it we use
our let operator again and we just call
tween and we provide it a the
milliseconds and what easing function we
want to use and this is exactly the same
now like this this tween functions
reusable you'd only write rewrite that
or you'd only write that one time I've I
think I've got repositories out that
have this exact same tween function that
you could use if you like but it's it's
you never have to write that again now
and
where you want to add this tweening
behavior and some observable stream of
values you would just use let you give
it a duration of how long you want the
tweening behavior to last and you'd give
it some easing function that you want it
to use and then other than that it's
exactly the same as the previous
observable we just kind of declaratively
added it in there so to see what this
looks like now it's gonna be a little
bit smoother so it's still gonna tick
along but you notice it has a little
movement and it kind of rocks back and
forth like a like a real crappie not
Swiss watch might write it's my Timex
but yeah it's it looks a lot nicer it
actually has the illusion of movement
and but you can apply this to any sort
of value like if you have a graph that
changes over time or a bar that moves or
a progress bar or something you could
use the same methodology to tween the
values that between updates of what
you're doing so just so just to recap on
animations the arcs yes the animations
are done with with observables in this
case obviously because using rxjs
observables again are just sets of
values over time and animations are sets
of values over time that's why this is a
good fit you need to deal with two forms
of time again you have to deal with
frames that which is the instant at
which you want to update a position
before you render and you also need to
deal with some math around duration and
velocity so you can kind of control
those things you use the animation frame
schedule and rfcs 5 it's it's in order
to get that frame that that's observable
of frames you use animation frame
scheduler with interval is my favorite
interval 0 or you can use range from 0
to infinity if you like because some
people just you know they get a kick out
of using the infinity constant oh when
do you when you get to do that right so
and then the other thing is you want to
use a lot of higher-order functions to
keep these things reusable so it keeps
you from kind of hard-coding things it's
it's not that much more code it's
sometimes even less code to do things
that way so that way you can kind of
reuse animations in between different
things like the ball example I showed
you with where we moved each one in
sequence
and most of this though again it's just
really really elementary math it's
mostly just a little bit of division a
little bit of addition a little bit of
multiplication so it's all I've got on
animations thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>