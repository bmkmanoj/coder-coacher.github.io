<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>WebGL In Action! | Coder Coacher - Coaching Coders</title><meta content="WebGL In Action! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>WebGL In Action!</b></h2><h5 class="post__date">2017-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/l2z3UvzXTf4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome I'm doing my talk about make
pad which is my next idea project five
years ago I was working on cloud nine
IDE and we're building new eyes with
HTML and CSS but we were building new
eyes that I don't think HTML was
designed for its application
you know I des designed tools that kind
of stuff
so as WebGL was very early in that stage
it just barely worked on some places I
saw an opportunity to explore how to do
you eyes on the web without HTML and CSS
and it took me six generations of
file/new literally and five years to
even get to the point that things are
acceptable that the way you write things
is not that much more complicated than
HTML or actually a more simple but still
being very fast so this whole thing that
you see on the screen is make bat it's
my new IDE
it's a code editor life running program
and every single thing is in written in
WebGL so every pixel on screen is drawn
using WebGL and I'm gonna give you a
tour of how that works and why I did
that so why would you want to use WebGL
because WebGL is actually if you look at
the API and I you know I challenge you
to go look it up and see what it looks
like it's incredibly low level it's very
very low level it's it's so low level
that it's you you can't actually work
with it without layering a framework on
top like 3GS or some other library that
sits on top of the API because it's very
verbose even simple things like drawing
a rectangle are a page of code and but
what they what WebGL exposes why is
WebGL cool it exposes the
programmability of the GPU right so
everybody here has a phone and a laptop
and these things comes with CPUs which
have one to eight cores and GPUs which
have ten to a thousand core
right a lot of Moore's law over the last
ten years has been pushed into the GPU
but if you don't use the GPU for
anything else then I don't know
compositing some textures you're missing
out on essentially the last decade of
Moore's law and so what I saw was that
if you could expose the programmability
of the GPU in a way that JavaScript
developers can just do it without going
insane you know maybe there's something
there so I want to show you what that
means so here for instance is a little
demo I have a slider these are you know
for simple sliders they also work
multi-touch with multi fingers which is
really nice but you know just show the
speed of spawn up so now we have 40
sliders let's give them some random
position make them a bit smaller 400
sliders not still still fast you can
they're still sliders every single thing
is still a widget okay let's do let's do
4,000 sliders okay it's you know still
very snappy no problem let's make it a
bit smaller so it's 40,000 sliders no
still doing all right so this is the
domain if you try that with the Dom API
or something like that it doesn't matter
if you do react to react go and help you
it'll it will be unusable slow so one of
the things that I was focused on coming
out of cloud 9 was how to do a code
editor right how do you do a
high-performance code editor in a
browser and the answer is to make the
API simpler and just have JavaScript
essentially write a race that you just
passed to the GPU entirely so another
thing is so one of my focus is to make
programming more fun and one of the ways
to make programming more fun is to
expose that that compute to for creative
coding for instance here's a little a
little fractal tree let's make it stop
dropping the leaves
so here's a little fractal tree that
actually warps its leaves with the mouse
the nice thing about why this is fast
and this runs on your phone is you can
do this on your iPhone it's because it's
executed in parallel entirely on the GPU
and the way you do that is you write a
little bit of JavaScript instead of your
writing GLSL which is what the GPU with
WebGL executes which is a C like
language I try to make it programmable
entirely from JavaScript so you've write
a pixel function or a vertex function
those are the little methods that are
called on the GPU the pixel function is
called for every pixel on the screen and
the vertex function is called for the
geometry that you pass to the GPUs or
triangles or rectangles or stuff like
that so the the vertex stuff is used for
rotations and transformations of the
matrices the pixel stuff is used to give
things color and the nice thing about it
is if you can write those functions in
JavaScript and compose them in
JavaScript and by composing I mean have
different methods that call that you can
override and call other methods you can
start to program the GPU using
JavaScript I'll go into that a little
bit more in a bit with this little demo
somebody asked me on Twitter or somebody
who asked on a question on Twitter like
hey how can I make 50,000 circles it's
like okay that sounds like a job for
make pad let's see how much work it is
so here you draw 50,000 circles here you
can see the the code so you pass in an
index X Y a color the color is set to
random right now and within a height and
this drawcircle primitive this this if
you look at canvas API you get circle
ellipse rect that kind of stuff with
programmable GPU those API is become
pluggable so you can define your own
code that is your own drawing primitive
and and include it on another class so
you have to think of it as a
programmable canvas so you define a
shader that draws things it could
anything circles Rex lines and you
included on a class and then it adds
methods to that class so draw circle is
the method that my circle shader plugged
on to the class so it's sort of like a
class in you you've nest a class in an
outer class and the nested class exposes
methods on the inner class anyway it's a
construct that I came up with to make
this really fast and actually composable
because these methods these drawing
methods are now no longer fixed
primitives that are somewhere you know
stuck behind the big C++ engine but can
be pulled all the way to the front here
for instance I compute the distance to
your finger in the vertex shader to size
a circle right that means that I can do
50,000 of them if I have to make a for
loop in Java Script to do this no way
ever that you could get this at 60
frames a second so that's the power the
power is to pass data through JavaScript
to the GPU in an easy way so I can say
hey radius right I just define radius
here and I should be able to set radius
here right so now I'm passing it in from
JavaScript but that means that I can
also you know randomly modify it here
so essentially what most a decent chunk
of my framework does is it Maps data
from JavaScript to the GPU automatically
if you had to do this in WebGL
essentially you're counting offsets in
arrays and then you're trying to match
that to a shader
it's like essentially what compilers are
designed to do you don't get you just
have to count offsets so if you add a
variable all of a sudden all your data
structures change that you pass the GPU
and you have to do all the work all over
again unless you automate it so why
WebGL because otherwise I don't know how
to build this UI I don't know how to
build this code editor and I don't know
how to get to new areas in terms of data
visualization because HTML to me is kind
of sort of
end of the road I cannot move forward
with with with it in terms of building
applications so it runs all in a web
browser and on your mobile if you google
this make pad you should be able to open
it on a decent III OS device because
actually iOS devices like a nine or a
ten are the chip are very close to where
Intel and NVIDIA are very very close in
terms of clock per click clocks per
pixel that means like how much power do
I have per pixel and iPhone beats an
NVIDIA laptop you just don't see it
because nobody ever uses it that way but
I notice it very very clearly and in
terms of CPU these things are so fast I
mean I think the new iPad pro is faster
than the new MacBook the the 12-inch
right so low-power mobile chips are
outperforming desktop chips and you only
start noticing it when you actually put
pressure on on the GPU and another
really cool thing and I needed that from
make baddest make pad is entirely
multi-threaded so every you know
JavaScript is single threaded yes but if
you have workers you can use multiple
threads the problem is you don't get any
of the api's right you're in a worker
you can only send messages to the main
thread you don't get any of the API so
make that is not just you know a library
with a compiler that compiles JavaScript
to the GPU it's also sort of like a
thread architecture in which the main
thread processes matches messages from
the worker but I'll talked about talk
about that in a bit this is just the
overview type inferencing javascript the
shaders so the shaders are fully typed
so that means that you don't have var X
you have float X or vector X you have to
know the type the cool thing about it if
you look at code you can often so here
you say let P is pause if you know the
type of pause you know the type of P
right you can have right hand side
propagate all the types and the cool
thing about it is that if you do that
then you can write shaders in JavaScript
without too many hang-ups it's you have
to get to know a little bit
the intricacies of it so this code
editor as well so why do you want to
write a code editor in WebGL because
it's an ASD code editor and esti code
editors are really cool I'll show you
here for instance I unfold and unfold an
object I don't know if any edit you can
do that or you can write align your
object keys I've no idea I have not seen
an editor that does that and the reason
it can do this is because it cycles
through the ast and cycling through the
ast is it's really cool show you that in
a bit
class composition I talked about that a
little bit of course it has a complete
layout engine but it's a new kind of
layout engine and not sure how much how
much detail can go and then there's the
the main user interface so this whole
thing is written on its own framework so
the reason I can say this doesn't
sarcosuchus
it does that you know so it's my own
sanity check
so multi-threading the main browser
thread right where everybody is doing
their JavaScript because I don't how
many people here have a run javascript
in a worker that does anything useful
one person okay - alright so in in make
pad the worker is the is the main thing
it runs everything and one of the
reasons I need that is because how can
you else life code a JavaScript in its
own browser frame right this is a web
browser so if you make an infinite loop
your whole IDE crashes and burns if you
don't have it running in a worker right
so for having a live programming sandbox
using running it in a worker is actually
the only architecture that I know of
outside of out of process iframes but
Google has informed me that my use case
was not a use case for out of process
iframes so I kind of gave up on that so
so yes so essentially you have to
reinvent all the web api is in a worker
message-based so that's been a large
chunk of the five years has been
figuring out how to make those api's
that live in a worker be nice and
one of the cool things I can show you is
so here you see my 40,000 sliders that
are happily scrolling I'm gonna resize
this window and here you see my worker
resizing happily it's like one worker is
now doing a hundred percent CPU but the
rest of my UI has no problem at all
right if you do this in in a browser and
your your program is busy then your
whole UI will come crashing down so it
actually has a lot of benefits and the
way I do this is I build command buffer
trees so the drawing API this is like
there's a WebGL light running in the
worker that is constructed out of trees
of commands which are typed arrays we
just say draw this draw that draw that
and I hand them over without copying
them from the worker to the main thread
so you can very very quickly update draw
commands it's one of the ways that react
was also thinking about doing
multi-threading by essentially just
dipping to the main thread this is not
different because I don't have to but it
just transfers command buffers and the
nice thing about it is that it's
actually really really fast it's fast
enough for for a code editor so type
inferencing javascript that's another
really really neat challenge because if
you want to make shaders programmable in
a way that you can read like here like
here's the slider I think so now live
coding the presentation slide and so
this is this is the shader API so if
you've looked at shaders essentially
it's a program that's executed in
parallel for you pixels and it processes
for vectors okay now make a circle in
that right okay I can do a length right
dual length
okay now anti-alias the edge okay you
know it gets harder and harder
okay now composite it with something
else before you know it you're doing a
lot of math and math is not easy often
especially not if you're trying to scale
so this is an attempt to make
a shader API that looks like canvas but
it's running in parallel so it's a it's
a functional version of a canvas so for
every pixel I execute a full set of
compositing operations and calculate the
distance to different shapes so it also
means it doesn't really scale very well
to a lot of shapes it scales very well
too you know maybe 10 shapes but you can
then draw a hundred thousand of those 10
shapes parameterised by data so you
can't draw a hundred thousand shapes in
a shader you pass data that draws a
hundred thousand shapes but every single
one of those shapes can be composed out
of ten other shapes which is actually
kind of neat for data visualization
that's exactly what you need you know
you maybe want some odd-looking a little
pie chart or something you can do all of
that you can do hundreds of thousands of
those things so ya type inferring so
this is if anybody has written a GLSL
I'm sorry that it didn't syntax
highlight that thing on the right but I
was lazy but on the left you see the
JavaScript and on the right you see the
GLSL so if anybody knows what C++ looks
like after it see if I'd by the compiler
it essentially annotates types on
functions for methods for instance right
so here you can see this dot viewport
type and this is the argument type
vector so it essentially expands the
types for all the arguments so it
annotates the function names and then
you can generate GLSL the nice thing
about it is that they're they're very
similar you can read both it doesn't
really help darker shaders or undi
buggah Bulai or ER shows but at least
you know there is a lot of similarity
between the shader and the JavaScript so
if you know how to write shaders you can
learn this very quickly and if you don't
know you have to learn a little bit
about vectors and a little bit about
math but hopefully this API fixes a lot
of that so yeah so the ast code editor
has been R&amp;amp;D project for a very long
time the nice thing I want to show you
about the ast editor is that it allows
you to so this is actually JavaScript
live reloading in a worker right I'm not
doing some kind of special only updated
color I'm essentially sending it
completely new source that I modified in
the editor so this is how fast
JavaScript engines can hot reload code
so now you know this one and one of the
reasons that I hate compile to compile
stacks for JavaScript because I think
it's completely the wrong direction for
it for the web and for developers here
we have this hot reloading awesome super
fast language and what do you do and you
build a compiler for it no you should
just leave it as is because if you
compile it from typescript I'm going to
challenge anybody who can at 30 Hertz
reload the typescript through a compiler
so this is what what an ast editor
allows you it can do a symbolic editing
of your ast and in this case I just only
have a very stupid example which is
changing the color but you can also have
a visual layout editor design tools that
operate on the ast of the code and the
cool thing about it is that it it's
stuck to the code editor so it doesn't
break your formatting it's like you know
the prettier the thing that everybody is
starting starting to use to format its
JavaScript this is fully integrated in
the edit cycle so the editor has its own
live formatting prettier this actually
if somebody says oh your editor feels
like a normal editor that's like the
biggest compliment ever to me because
making this thing not make you scream
and throw your computer out the window
was definitely a year of work or
something so the editor has things like
if you make a typo this is a parse error
that shows up but if you do something
like this is a runtime error that's
coming from the worker and it's mapped
into the editor you know so those little
things that are really really hard to do
in Safari I don't get proper call stacks
unfortunately at last check but at least
in chrome this works
so we were at class composition yeah so
okay you let go of a CH TM l you let go
CSS you know it's a brave new world
because everything you can come up with
to do it you can technically do but is
it easy right is it composable so for
make Beth I've kind of invented
something which is called a nested class
so because the primitives that you use
to draw things or shaders which are
JavaScript classes es6 classes in this
case they compose on to other classes to
expose draw commands but how do you the
reason they compose on to it as well is
because then I can take that that
component and include it in somewhere
else and then I can subclass the nested
classes right so if you take a class you
know a module and you require Class B at
the top the reference to that class is
hidden in the closure of that module so
you can never reach in and change Class
B that is used by class a so you're
essentially you wrapping that component
makes it completely inaccessible to
modify it from the outside so if you
compose classes on to each other you can
also do nested sub classing so you can
take a class and then subclass its inner
classes just by essentially using a
JavaScript object that sits in that sits
as a child of the class and that turns
out to be really useful because if you
don't have CSS how are you gonna style
things right we don't want to make
Winamp in the 90s because that's really
really easy you're like oh we're
still in 90s if you didn't actually
think about how to compose these things
so yeah I'm really looking forward to if
anybody understands that part so layout
is actually another one of the things
that I took a long time to do like
here's some buttons that are left
aligned here's a button that's right
aligned and this all of the buttons are
size so they push push down the text
editor there's no fixed layout it's
completely float later layout so so
things push each other to decide based
on
sighs and that kind of stuff I don't
really want to go into too much detail
there cuz um yeah it's gonna be too
technical so yeah so it's a replacement
for CSS the instead of using sort of
like an external property application
system I use class composition and a
nice thing about it is that it moves
everything into the prototype chain so
hot reloading what you've been seeing as
I type only really works if I don't do
all the things that you should do whilst
building up the the class structure for
the application I'll show you in a bit
what that means so yeah I made a little
fake shop that has like you know a
little texture that shows you Mouse
activity for me it's you know this is a
heat map and you can add stuff to the
cart and you can remove it and so this
is all using the float layout and
hopefully it's actually very simple
so we'll see about it if people
understand it and the reason that it's
so fast is that it's inside the draw
flow so everybody who's doing layout
engines generally spawns up a structure
in memory and then crunches it into a
layout with this it's executed as you a
draw with look behind and the reason
that isn't that that is nice is I can do
this kind of stuff like oh this is this
is a tree graph but it's gigantic right
and I think
I hope you can see it but the text is
pushing the lines right if you try to do
this in a Dom you have to synchronously
ask the Dom engine like where's my text
because it doesn't know that because
it's running in another threat that's
why you get like all these reflow things
but if you layout as you draw I can just
draw and then I know where to put the
line because I already know that because
it's in the draw flow so it sort of D
complex your your layout engine but you
know if you want to talk to me about
that I can talk to it for talk about a
very long time yeah so the main UI
because of course the the only real use
case I have right now is this thing
itself and I want to show you some
features of the thing so this is a
little thing I did for a friend of mine
at the U UVA for its class it's a it's
essentially it's a little parser and I
was like okay how can you use make pad
to okay what do we get we get a console
that actually is not like a browser
console I can actually log tens of
thousands of lines to it per frame and
it doesn't die you know it doesn't you
know how you're debugging and you're an
infinite loop in your browser console
dies that's when I really start yelling
at it so this this actually is a
multi-threaded console a lock that you
know it's actually very fast and can
take an enormous amount of data it so
much that I can write a parser and show
every token that gets pulled through the
parser and just dump the whole string in
the log so here you see a Peck parser
that you can see the parse flow in the
editor this is really just the this the
call stack of a console dot log
visualized in the editor so I thought
that was kind of neat because all of a
sudden you know printf debugging can be
used from far larger data sets than then
you're used to see I also made an audio
editor
here it is it's a sample and it has
selection and I can cut things this was
just a really a little test of okay so
you built a code editor can you now also
do other media types in a way that it's
that it actually works so this is a
virtual viewport wave that as i zoom in
it only draws like this area with a
little bit around it the scrolling runs
in one thread and the update windows to
the side just make sure that there's
always enough data this is actually a
really difficult problem like oh let's
make a multi-threaded data view most
people just go no but if it's like the
natural way to write things that's kind
of nice right so I try to make that that
natural flow easy another is that I made
a little package here so this is
actually a compressor I was trying to
get it in 64k don't blame me so you you
package it and now you get a bare HTML
file that is just the application that
you have so I've made a little package
here I also made a trace package er
trace packages are a really bad idea
exceptionally bad idea actually because
what happens is it traces the call flow
of everything in the worker and uses
that an index to throw everything that
it hasn't been executed out it's kind of
nice if you're trying to get a very
small file but you have to make sure you
click every button if you do that
because if you don't trigger a code path
it'll not end up in the executable then
again if you're trying to bjs one K or J
s 64 K or whatever then you know you
don't care about that thing
and of course how do I check that I'm
not an idiot while I force myself to use
it myself and hold on Oh
that's why it's not working my fake HTTP
decided to timeout so here's the thing
in its in itself right it's the IDE in
itself and how do you modify things like
that so here's the tree widget right a
tree widget and you can now live code
the tree widget in the ID itself so that
is my test like can I use it for the
thing it's off because that's the most
complicated thing I've made so far and
yes I can I just don't have find/replace
yet alright so yeah that's pretty much
all I wanted to show you I'm finishing
the UI kit I want that you know cool
Gaussian blur behind dialogs that's up
next because you can do that with this
render stack you can do all those kinds
of cool tricks I'm going for more visual
editors in the AST because the color
picker is cute but you know you want to
have UI designers and all that kind of
stuff and one of the big challenges is
that how do you make an ast modifying a
UI designer in a way nice because
modifying AST is actually kind of crappy
code so I'm also investigating how to
make AST API Snyder and it's going to be
an online service on make pad io
whenever I feel like it's ready so right
now I publish everything to get up make
bet you can google it you can open it
right now you can take any code you want
I do Apache 2 or MIT I really don't care
but I don't want to support you so take
that as a you know because I have to do
this I'm alone making this and there's
there's a lot of you know little things
that are going on but my goal is to make
quick basic for the web you know this
thing where you go and play with code
and easily share it and and focus on the
fun of programming like I'm currently
working on the audio api actually maybe
people can start to collaborate one
makes this synthesizer the other makes
this drum kit and then all of a sudden
it puts together into something that
works together so if you want to follow
me
I rant a lot about you know positive and
negative sides of the web on Twitter
that's my my handle so yeah I think I am
right about on the mark I'm at minus two
minutes it's nice if you program your
own presentation and you can just make a
little timer</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>