<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Image Optimization: Beyond The Basics | Coder Coacher - Coaching Coders</title><meta content="Image Optimization: Beyond The Basics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Image Optimization: Beyond The Basics</b></h2><h5 class="post__date">2018-03-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hQZ7Xg7q7zw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you so much for introducing us yes
hi my name is Martin
I am a Google developer experts and the
mozillian and I work with w3c every now
and then I'm very involved with the
community
I am also with my team together we are
building this wonderful platform through
the i/o that makes it a little easier to
build VR and eight are things and as my
avatar kind of suggests there's another
commonality between the two of us
this evidence done by my coworker David
Tran thank you very much David for this
wonderful avatar
I am also every now and then spotted in
a unicorn onesie on stage and that leads
me to my wonderful call speaker Yuna
hello everyone so I like to use a
unicorn as a way to help people
pronounce my name because you know like
unicorn so you can find me on Twitter on
github on code pen all the things I was
just at uni where I write about topics
like this I write about other CSS
experiments other performance related
things also I do work at bustled digital
group now which is a subsidy that runs a
couple of media properties like bustled
Romford elite daily so that's been a
really fun journey that I've just began
a month ago so I really really love this
quote as well that I saw on the internet
from Tobin Titus you can't be a web
performance expert without being an
image expert that's because images and
media take up so much of the web today
it's a majority of what we're sending to
our users and while they're not render
blocking they do cause a lot of cruft
over sending to our users is something
that is a common common issue but this
being a performance conference we didn't
really want to spend time on getting
into why it's important to optimize your
images or the basic understandings of
image optimization and how media works
in the web we just kind of wanted to go
right into some creative image
optimization and things that you might
not know so so not to spend too much
time on this a very very quick you know
run through the basics let's start with
formats so say you were taking a picture
and you want to put that picture yes
thank you very much like I kind of
warned me that's not my good side so you
want to take that picture onto your
website then you have a bunch of
variations of formats that you can pick
from and this is just an example so
let's say we have the same picture they
definitely vary in size Bay
on the format that you are picking this
is basically a little bit of a warning
there that you have to be aware that
this is a photo if you have a screenshot
or a logo you might actually want to go
for something completely different for
logos for instance maybe SVG for
screenshots may be PNG or maybe even
gift for nose
the sizes are not like absolute so it's
not that JPEG is always smaller but
there's a huge difference but is there
any drawbacks to one of them yeah well
if we have transparency which in photos
admittedly you would not have
transparency I guess I don't know how
that would work like a transparent fold
maybe who knows but basically unless you
have transparency it doesn't make a
difference transparency also in gif is
not quite real transparent it's like the
green screen kind of thing where you
just take out a color also PNG just
stores all the information it compresses
them but in a way that we can
reconstruct all of them whereas JPEG
tries to be clever and using the way
that humans perceive colors to basically
throw away information that is kinda not
needed until a certain point so that's
kind of nice gif is kind of lossless but
only supports 256 colors ish so
basically your mileage might vary on
some of these things but that's more or
less what we have been objected to for
the last couple of years actually JPEGs
like from 1992 so you know gift is from
90 so that's like super old stuff but
there's there's problems with some of
these formats you might have noticed
that some of the JPEGs don't look quite
nice and so someone thought well JPEG is
super old so how about we have a look at
like revisiting image formats so to the
old contestants PNG and JPEG we now have
web P and we have height which is the
high efficiency image format so when we
look at sizes starting from the PNG of
1.3 megabyte that's quite hefty right
1.3 megabyte is nearly the size of a
floppy disk and you know back in my day
that was a lot I think I'm dating myself
yeah yeah is that not long ago I'm 20 um
so JPEG is a little smaller here but you
see like WebP is like super much so much
smaller and high Fizz kind of like in
the middle somewhere and when it comes
to encoding so basically where P gives
us full flexibility because we get to
choose which kind of
we throw information away do we keep it
high JPEG a lossy pngs said was lossless
they also poor transparency except for
JPEG we covered that one and they are
basically going for different trade-offs
so well ping and - Utley go for quality
so they try not to squeeze too much out
of the image but basically make it look
good
JPEG and WebP II try to optimize for the
size which is also good because we kind
of have to get it over the network right
so here we have an example let's see how
well we can see that yeah you see if you
does not have laser pointer you see like
in there in the sky you see sort of like
horizontal bands and then you see and I
haven't seen a sky like that until like
1995 and some games maybe and then you
have like the little fragments that we
had color problems around the line of
the mountains but if we look at hi you
see the bounds you see look at the sky
you see the difference right and it's
it's smaller the image is smaller so
that's kind of cool
unfortunately hi she's using x265
technology so it's like riddled with
patterns so it's really hard to get an
example of a high image go yeah iPhones
take high photos but and when you try to
get them off out of iPhoto they just
convert into JPEGs which kinda is
reasonable because you have to you know
interoperate with other things so with
that out of the way let's talk about
something that is more practical in the
last couple of years so we know that
responsible design is a very prevalent
responsive usage of devices something
that we all deal with we all use
desktops and mobile devices and iPad etc
so the way that we can send users images
has been improving over time but the
picture element picture is really
magical picture allows us to send
multiple sources of images to your users
so that you can send various sizes so
you're not setting a massive red an
image to your users are in smaller
devices this is something that I still
see all the time I still see people
sending the same image that's high
quality to every single device and that
is really really harmful for your users
memory data you a disk set people right
you're literally throwing them so don't
do that and make sure that you
use one of these techniques another
thing you can do is use store sentence
sizes there's a little bit newer than
pictures so you can within a single
image tag send multiple sources and
specify those sizes and you can also
send different types of images so you
can send web P along with your JPEGs to
have a fallback for browsers that don't
support web P but then still have the
benefits of web P which is about a 30%
image savings in a lot of cases for your
images so you get all the nice things
based on the browser's on what they can
do that's awesome yeah so leverage the
browser another thing you can do is use
media queries so in event a part is an
example of a website that does this they
took it into their own hands to create
this design and send different image
sizes based on media queries there are
times when you want to have a image in
different parts of your site so the
sidebar or the main navigation area or
just your content section so media
queries aren't gonna help you with that
you need element queries which are still
sort of being worked out but media
queries allow you to start that process
of okay if I'm sending a image to a
smaller device size it's probably a good
idea to send a smaller image at a
smaller quality you can do this
server-side as well when you're letting
a browser render a website when you're
sending your request you can let the
server decide what image is something
that the browser can render this is
something that has a very popular option
so people can use this to send web P for
example and there are a lot of services
that do this for you you can also write
this in the server itself and nginx
whatever else you're using but there's
two great services I really like and
have used and recommends image X and
cloud and areare both awesome so they
can do that for you where they send
optimized image format types and they
can also do things where they send
different sizes of images to your user
so what cloud anarion listen o does is
they slice up the images for you so you
can say I want 12 slices of images from
one range to another and they'll make
those slices for you so you don't have
to do it by hand which is really really
awesome image X and cloud Neri allow you
to do a lot of different transformations
size transforms you can apply filters to
your images beforehand
so they're just super useful if you
don't want to manually do some of these
things that can improve the experience
for users dramatically normally that
takes a lot of time out of your
development process which is what you
want
except you know I come from Switzerland
we have cheese chocolates and banks so
if you work in a bank
it actually takes more time to use
something external so you might want to
have a look at the optimizers that you
have available as part of your tool
chain so one of them is Moss JPEG so as
I said the JPEG standard comes from 1992
so Mozilla at some point said you know
what maybe we are not exploiting what
this algorithm could potentially do so
they basically started to tweak what the
algorithm can do within the bounds of
what is compatible so basically they get
10 to 16 ish percent smaller JPEG images
with more or less the same quality out
of JPEG as an automated tool you can
install that via NPM and then just run
it on the command line as part of your
build process and gulp or grunt or
broccoli or whatever is on vogue these
days the same exists for ping images so
you can basically tweak the settings of
how it compresses the images and how it
sets itself up and by removing all the
cruft you know that for SVG oh as well
right like there's a lot of stuff in
there that can kind of be squashed
together or even thrown out opti ping
does that and gets around like 18 to 20
percent smaller image is smaller less
the same story you can install it by NPM
and then run it if you happen to use
webpack as part of your build process
all this is conveniently wrapped
together in a loader called the image
loader you can just load it for all the
images that you have in your in your
application or website and then hey you
already get these benefits for basically
doing nothing which is nice right once
then automatic yeah optimization yeah
okay so with that being over taking a
deep breath because now we are gonna
basically opening the curtain of what
happens when the browser gets an image
and draws an image out so let's do that
together what did I just press all right
all right okay right okay that's off we
good we practice we got this so what's
the lifecycle of an image so let's say
we find an
image somewhere in the HTML sources or
even in JavaScript whatever you prefer
in your CSS well the first thing the
browser has to do is it has to get the
image from wherever it lives so unless
it's a data URL we have to download this
thing over the network hmm and then
what's cool is we can basically have a
look at the structure of image files and
maybe we don't have to wait until the
entire image is there maybe like HTML
and CSS we can start parsing it as it
comes in maybe who knows we'll find out
in a second and then basically we have
to like configure the the algorithms
with all the parameters they need to
actually decode now what does decoding
mean decoding means we have all these
squashed informations and we have to
kind of get them back to red green and
blue right if it's a 500 by 500 pixel
image we have to get three values times
500 times 500 to get that on the screen
and that's called decoding we're gonna
have a look at that in a second as well
and then we're gonna do something we're
gonna put whatever pixel data we've got
and put it into where the graphics car
can access it to actually render it out
to the screen which is called video
memory of VRAM so this happens as well
it takes a tiny little while doesn't
take too long normally and then once we
have that and we have all the other bits
and pieces that go in front or behind it
let's say you have an au-pair opaque
image or transparent image 50%
transparency you have another image that
goes behind it some parts of it at least
and then maybe you have like some filter
or something on top of it
we kind of have to squash all this
information together so we have a bunch
of layers and that's where these layers
come in we have a bunch of different red
green and blue values and we have to
somehow combine them to get the final
red green and blue value for the screen
and then sparkle sparkles it is in the
browser it appears on the screen we are
happy
so let's have a look at PNG so this is
the beginning of a PNG file so if you
happen to have your ASCII tables ready
like I totally always have you might
notice these three numbers there that
are really really hard to read now that
it's read great so let me undo it
fleshie fleshie so these three numbers
actually are ascii for PNG fun fact
so basically starting with a four-fight
the browser goes ah wait I know this
this is the ping ha so I
basically star to actually take the rest
of the data and start actually making
this happen making it decode and then
upload to the vram and then actually
also display it later on so you know we
don't have to download the entire image
we can start right here and when it
comes to decoding what I said is we try
to squash information together we don't
want 500 times 500 times 3 bytes of data
right so this lovely illustration do you
do that I think you did that right yeah
really really cool stuff so let's say we
have three purple pixels we have two
blue pixels and then a few others what
we can do here is we can say well you
know we can instead of saying AAA we can
say Triple A so we're saving one already
with BB it's not that much of a gain but
it is shorter than the original one but
what we can also do is we can say look
it's a pixel it is tiny so you know what
we're just gonna throw some of them away
like one of the A's and one of the B's
and then something here you know one of
the arrows and we're good so it looks to
the eye it might actually look the same
and it is shorter than the lossless
version but there's a difference so from
the a a bj KWL i can't go back to the
original string because i lost
information that's what JPEG does or web
P if you configure it that way or hi
PNG on the other hand just you know
keeps it reconstructed and this also
demonstrates how for some items like
logos and areas images that you have
large areas of similar colors lossless
formats are actually gonna be better
they're gonna compress much better than
lossy if you have two colors just blue
next to white you're gonna have a very
short string compared to trying to
decipher every single bit of that image
when you're doing the lossy reductions
that the problem being photographs as we
saw in the very very first example they
are kind of noisy so I'm not exactly the
same colors images try to actually gloss
over that fact by blurring them but
we're gonna see more about that in a bit
all right so now we come to composite so
we have a bunch of images that go in the
same place or more or less the same
place on the screen but we have to work
out from these two layers of red green
and blue we have to work out what's
going to be the final color so howhow do
we do this well we have to decide
basically there's no right or wrong way
in this case I could say well you know
I'll take the maximum of each of these
columns so basically I end up with red
being 255 being bring 255 and blue both
are the same values so I'll just take
any of them and Hays so we have a color
this process is called compositing but
how do we decide that this actually
happens and the answer to that is the
super simple easy answer the compositing
set is basically running the shaders
with all the layers as input and the
position obviously right well you know
maybe not so let's have a look so here
we have a four by four screen and we
have a few GPU cores GPU of course our
tiny processors that are in the computer
on the graphics card on the GPU now here
there's conveniently one for each of the
pixels that is not true in real world we
have like a few thousand of them but we
have more than a thousand pixels on most
screens these days however what we do is
we tell all of them at once because they
are not depending on each other's
results we tell all of them at once
here's your position and calculate the
color from this maybe also we could give
like all the layers we are not having
any layers here so what I'm saying is
take your x position so each of you is a
it's basically responsible for one of
these colors therefore one of these
pixels you take your x position which is
the first number in all of these and you
take your Y position which is the second
number of all of these and you multiply
them as with 64 as the red and green
position and they go sure about there we
go boom colors on the screen and the way
that we do this this function down here
that's the shader
nothing else it's not that complicated
well it kinda is because you know it
turns out that the syntax is a little
different I'll just want to quickly
introduce you to the syntax here so
pixel color is gonna be the color that
we're gonna put on the screen at the end
of our shader function and the values
are not from 0 to 255 as you might be
used to but basically all we do is we
take the value that you are used to and
divide them by 255 which gives us a
value between 0 and 1 so here we have
red green and blue what happens if I say
I don't want green well what happens
then is I get pink all right what
happens if I remove blue well
surprisingly again you know that is
supposed to be red I swear to God
it looks right on this screen it really
does it's absolutely fine here come talk
to us if you don't believe us surprises
but what we can also do is so you know
what I'm not gonna use that color
because you know it's gonna screw with
us so we now we have a black screen and
I can take the position that we are at
for instance the x coordinates and use
that as our green and then we get a
gradient and then I can do the same
thing for the Y polar coordinate as our
blue Channel and hey you look at that we
have a gradient this is how gradients
can be done it's not that complicated
and I couldn't do all sorts of things I
can say like 1.0 - oh no that's the
wrong keyboard layouts hi so here we go
like it's in Crittenden verts the color
and stuff like that and also there's a
few helpers in this language which is
actually called GL slang or GLSL so for
instance I can just say 1.0 and it
basically uses that for everything and
position being - values x and y I can
also do this I can say okay let's set
red to 1 and then just use the position
here which automatically figures out how
that's 2 values so I can make this red
green red green blue array out of these
values and what I can also do is I can
take an image that I have so it's a fun
glitter on the screen that is not on
that one
Wow yeah oh yeah high projector yeah GL
tends to you know school projectors as I
just learned now right now yeah so let's
say we have one layer which is an image
that we got from the internet and hey
look at that it automatically takes
right color at the right position but I
can then also do things like I can
multiply all of these the red green and
blue individually so basically what I
could what I can do is I can say I want
the red green and blues again and I can
say I want layer one point red
multiplied by 0.25 and I want to do the
same thing with oops a layer 1 dot green
multiplied by 0.25 and so on and so
forth that's a bit boring to actually
speak it out loud but hey here we are
and then if I run the shader it is
darker because I just multiply it this
on every single channel I can
theoretically also do that not on every
single channel so I can say like no you
know what I take the blue but I can also
write this as a shorthand so I don't
have to do this all the time what I can
do is I can say layer 1 times 0.25 which
automatically figures out ok I have to
do this individually so if you're gonna
see that later in the code that's what
it means it takes the red green and blue
channel individually multiplying or
dividing them with this particular
number we can also make it brighter we
can also ramp up the contrast actually
not brightness it's gonna contrast so
this is high contrast of this so you
know this is what shaders do in the
background and whenever we do something
on the browser that has a shader
back-end that actually renders things
using shaders rather than native to our
functions this is what's gonna happen
and we're gonna explore that for
performance yeah so now that we know a
little bit about how shaders work what's
happening under the hood let's see what
we can all do to kind of incorporate
this idea of changing how images look in
our browsers to have better image
performance to create smaller sizes of
images that were saying to our users so
the first thing that we can do is
something that can make a massive impact
but probably won't even be able to see
the difference does anyone see the
difference between these two images on
the Beamer like the Beamer is not to
blame here you can see the difference if
you know what you're looking for yeah so
they're the same size they're the same
dimensions what I mean but one has a
slight difference and it's not just
image size yeah so the bottom area is
blurry
so just by blurring half of this image
by blurring some unimportant areas of it
we can really help with image
compression and make that image much
smaller and that's because of how JPEG
compresses it looks at these 8 by 8
pixel blocks of data and looks for the
differences between them so if there are
fewer differences between those pixel
blocks just by blurring those out we can
really compress the image size almost
half the original image size so this the
thing that we probably see medium doing
so what they do is they have images load
in as blurry and then they progressively
enhance they they show up as
they're full downloaded image self but
we're already taking up space on the
page the user kind of knows what to
expect you're not rearranging this
layout and it also gives us the right
feel of the post because the color
basics are already there we can do this
pretty quickly ourselves so if we start
with this image for engine kilobytes we
can decrease it to be like 30 pixels big
now we're saying less than a kilobyte
we're saving 480 kilobytes an initial
load time for our users and just scale
it up into his pair container use
something like a filter like the blur
filter and we're still saving 400
kilobytes in the initial load so user
can start reading the content and have
the feel of the image and then the image
will load in facebook does this too for
their cover photos on mobile and the way
that Facebook's graphic ul database
works is if they send less than 200
bytes they can actually trick the
database into thinking that it's sending
just content like text content and not
an image so it loads pre fast pretty
initially and then the image will load
in once that is ready to be shown to
your users so it's pretty clever it's
called the blur up technique and if you
just google blur up there's a few
different ways to do this few different
articles about it but it's definitely
effective and it also provides for a
nice user experience some of the other
things that we can do is do some like
manipulation manually of our images and
manipulate their histograms by
manipulating the histogram of an image
you're saving the size of that image one
example is grayscale so you don't need
these fancy image editing programs like
Photoshop you can just open your preview
tool on Mac or get a free program off
the web that will do things like this
you can even just use webpages that will
automate automate this for you but just
save this image down from color you just
have to slide saturation all the way
down if you look at that histogram we're
reducing a lot of data there that you'd
be sending to your users so the size of
the image is much smaller and here we're
saving around 21 percent this one is
around 23% that we're saving our users
and image size and just another example
so the bigger the image the bigger the
size that you're saving but the
percentage remains the same I've seen it
be anywhere between 90
24% of the image that you're saving by
not sending color to your users the
black and white doesn't have to be
boring we can do so much with our images
by applying things like filters and
blend modes so let's let's take a look
at that CSS blend modes are really
really powerful and there are a few
different types that we can use on the
web today and so I'm just gonna go over
a few very very quickly and the first
one is multiply this is probably the
most common blend mode that you'll see
what we're doing is we're taking two
layers and we're just multiplying them
so a times B to luminosity values of
those layers are being multiplied and we
can do the exact opposite of this induce
screen and what we're doing here is
taking the inverse and multiplying the
inverse and inverting that so there's an
algorithm for all of these things this
would be 1 minus a times 1 minus B and
then 1 minus all of that it's it's how
it kind of is working man the scene so
if I move this back to multiply one that
is similar but different to this is
darken so you could see the differences
between these two and what the
difference is that with darken you're
kind of creating these new tones so
instead of multiplying to luminosity
which we kind of saw Martin do when he
multiplied by 0.25 and it got darker
here we're looking at every single value
on the RGB spectrum and we're comparing
which of these is darker when you darken
so the RGB color that's the darkest is
RGB 0 0 0 when we compare 10 and 150
which is darker here it's it's 10 so
that's the couple of color value that
would get 200 and 100 it's 100 between
50 and 150 it's 50 this is how we're
darkening the image or cream these new
tones from these two layers you can see
here that I have this hot pink layer
darkening it
so with lighten sort of the same thing
it really knocks out this image because
we're looking for that higher value
color and with the pink hot pink it's
pretty bright but yeah so just kind of
how those two blend modes work and the
thing here is that instead of
multiplying them all individually what
you're doing is you're basically looking
at the minimum or maximum of each of the
three values you're not like smashing
them together or something and so let's
go back through the shaders how does
that work another hood
in shaders so here we have our layer 1
which is the image of me and vitelli
then we have the layer 2 which is a hot
pink rectangle it's not very exciting is
it but what we can then do is we can say
so actually you know what that's not
quite fair enough let's multiply because
that's an easy one so I showed you that
if I multiply something what we get is
that it multiplies each of the channels
right so if I do this I get that exactly
without the one that's da da da
individual examples look exactly the
same
well I can do is I can also take the
minimum and this does exactly what
multiply or you know all the other
functions do they go value by value I
just don't have to type it all out which
is very nice so I can say I want the
minimum for red versus red like red 1
versus red to green 1 versus green 2 and
blue 1 versus blue 2 and then what we
get is this the darken mean exactly if I
look for the bright up values for the
larger values for the brighter colors
that's when I do lighten we get this and
exactly the same so that's what's
happening behind the curtain we can do
more complex things and blend modes
conveniently make that short I would
have to write a lot of code to make that
work in shaders so we're gonna just
discuss the black notes for this one and
I do want to talk about this next set of
blood mils because they demonstrate how
you can use blend modes and are very
progressively enhanced way in your sites
so to understand this next set we have
hue saturation luminosity color it's
best to sort of think about the color
wheel and really color sphere if you
will so this is the Munsell color system
you can think of it as the lightest
colors in the top light dark that's the
brightness value which is the luminosity
around the color wheel you have the hue
and then if you think about the distance
from the center that's the saturation so
at the very core of this color ball we
have a 50% gray so the most brightly
saturated colors would be in the very
center of this color sphere at the very
edges so when we're blending these
things if we want to blend with a hue
blend mode where
just looking at the area around the
color wheel where that color exists so
we have a hot pink with this bright
color here but it's still looking very
dull and dim we change it to yellow
we're still getting a pretty dull color
because we're just looking at the hue
however if you use a mixed blend mode of
saturation it starts to get very bright
so you see this bright image sorry for
doing this video but if you change this
like a darker color like a dark green
you'll won't have as much saturation on
the screen so we're still remaining all
the colors of the image behind it that
blue the yellow sand background the
peachy skin tones but just affecting a
saturation so with luminosity this is
gonna look crazy we are just taking the
brightness and darkness value of that
layer so since our layer is just a
single shade of dark green the
luminosity value is not much to play
with it's just that single shade so
we're taking away all of the dark and
light valleys that much behind it this
is very flat looking image of just weird
colors and then finally there's the
color blend mode which is interesting
because it's a blend of two different
blend modes it's a blend of the
saturation and the hue so all we're
keeping is the luminosity the brightness
and darkness values of the image behind
it that image could be color it could
black and white it doesn't matter it's
going to look the same when you use a
color blend mode on top of it so things
that I like to do with blend modes are
use gradients along with blend modes
since you can apply multiple shades of
color on a single plane when you use
gradients and you can also just
demonstrate this with a mixed blend mode
of color now if your browser doesn't
support blend modes edge and ie then
it'll look like this on your browser
screen so we want to make sure that
every user no matter what browser
they're using can see the content that
we're trying to send so we want we want
this we want them to still see an image
what we can do then is use the blend
mode behind the image so we can use this
color behind the image use a mixed blend
mode of luminosity on the photograph
itself and we still get the same effect
from the image so your user will see an
image regardless users that have a
browser that it has a blend modes
working will allow you to see this color
as
lair a thing to note also is if you're
sharing this on social media you won't
see the effects that you're applying
with either filters or blend modes
you'll just see that image unless you
specify a specific image for sharing
which is something interesting more
common publishers do so I'm just to
demonstrate also how powerful these
things are I built a library called CSS
Graham where I recreated a bunch of the
Instagram filters by just using filters
and blend modes in CSS and so really if
you have an idea like a thought of I
want an image to look a certain way you
can write a single class in CSS that
cascades throughout the rest of your
product and you can get a really nice
look and feel for your image and pretty
much we create anything so when we're
talking about recreating things
something that I'm seeing a lot of these
days is duotone it's like super trendy
ever since like Spotify is 2015 music
campaign and I'm seeing it everywhere so
you can recreate the same effect with
blend modes sort of so what I'm doing
here is i'm using the highlight color
and i'm using the darken blend mode on
the highlight color to say that this is
the brightest color you'll see any
bright values are gonna have this color
take over them and then i'm using the
light and blend mode on the shadow which
means that the darkest value that you
will see is that blue so if I show this
layers again if you look at the shady
parts here you're getting rid of a lot
of your detail in the shadows because
you're saying that there cannot be a
color darker than this blue so that's
kind of how it works it works with some
colors not all colors Martin will talk
more about that in a second about why
but it also works with grayscale images
so here's an example of just applying
this same effect to images that are
grayscale so we get that same benefit of
saving our users 20% of the image size
the same visual effect is applied to
your images and then you can use you
know CSS variables any color here to
reapply this duotone effect and because
it's so dynamically since variables
awesome you can just on the screen start
playing with color and propagating it
throughout all of your images because
the Cascade is a beautiful thing love
the Cascade embrace the Cascade so
yeah the question is then how does that
actually look like in the background how
does this actually get carried out so um
ignore this for a second that's
basically oh Jesus how do I know and now
we have a shader error which is obvious
okay so how do I get precious F and then
nope I love that I love people so J yes
everyone it's cool it's nice shiny it's
just it has a lot of shortcuts which for
life coding are not necessarily helping
so okay I will at some point yes thank
you very much at some point learn what
shortcut is actually pressing but it's
different keyboard layouts cool aha okay
if I do shift if I do what on the German
keyboard would presume oh yeah that's
cool no that's fine
we can do this so we basically have yeah
no keep laughing you go up here and do
that on the keyboard a oh that's not I'm
proud of you my um so let's go let's
let's take the highlight color that you
now pick early on which is kind of hot
pink and let's take the shadow color as
well which is like this not very
exciting but what happens if we pick the
darkest we've got from let's say so like
we're looking for the darkest values
between our highlights so the highlight
being very bright and the image being
something between dark and brights you
know we're probably gonna get the
highlight color for only where the image
is kind of like dark actually that's yes
that's right no if we if you remember
how dark and works and lighten works
we're taking the minimum value between
those RGB color layers right so we get
the first iteration of the duo tone and
now we can now we can wrap these in each
other so what I can say is I can look
for the brightest colors which normally
would be the image when I have a very
dark shadow so I can look for the
brightest colors versus our shadow from
shadow versus our image instead so if I
now do that I get the exact same effect
that I had beforehand but if we're
looking at this it becomes clear that
this does not work for all the colors
because what happens so I'm taking the
maximum value of our shadow and our
image but what happened
of our shadows actually really bright
let's say 1.0 1.0 1.0 so it's white so
well guess what
the only thing that's left is the
highlight color because the other step
where our shadow which is now white and
the image have been compared to each
other the shadow always one so that's
why we are not seeing anything here one
is the highest value that we can get so
this one is a really really bad shadow
color we can use a darker one again
let's actually make it a little more
dark and then we see more pixels are
winning the comparison from the image so
the image now comes through again
and the same goes for our highlight
color we are looking at the minimum
value of what we did before all the
image what happens if this is this is a
really really low value well what
happens there you know is that not many
pixels go through it could be a look but
it's not look we want it yeah it's
certainly Wow okay okay you know that is
dark yeah now it's bluish and it's not
any better so what you want to make sure
is you always want to pick something
that is a dark highlight which might not
obvious not be necessarily obvious
because it's called highlight so you're
like yeah this is bright and nice no no
no no this one has to be a little under
you know
sorry no actually this has to be on the
brighter edge the shadow has to be on
the darker after its name for that
reason yes no whatever and yeah you get
the same effect so that's what happens
behind the back of you and you are
having you know to deal with shaders
rather than dent nodes and it's really
nice it gets nice effects and you can do
that on grayscale images so you save
data and you still get a nice effect but
here in the shader I think man you can
see why certain colors don't work
together as they are losing against each
other so another thing that we can do is
use CSS filters CSS filters are pretty
well supported so they're pretty safe to
use across all browsers now maybe not
Internet Explorer but essentially what
you can do is apply a shortcut to some
of these shader effects to your
images and we have a variety here so you
can do blur grayscale saturate
brightness you can also darken with
brightness you can increase contrast
which we saw in that first shader
example and we can you rotate we can
invert our image we can do anything here
sepia is another option so something
that I've been seeing kind of floating
around lately
is people having trouble with SVG and
that's because if you sim put an SVG in
your website you're going to be doing
some great things you're gonna be
sending a smaller image you're going to
have a nice raster effect but if it's a
background you can't access the fill you
can't change any of the properties from
the SVG dynamically so what we can do
here instead is use filters so if we
want to use filters and CSS we can kind
of go around this so because we can
affect the brightness we can set this
like 0.7 and make it darker we can start
increasing the contrast so we can have
the contrast like 1.2 and if we want to
change the color now that's also
possible even though this is grayscale
it seems like how do you do that we can
just kind of hack this give it a sepia
color and then from there we can use hue
rotate and do any kind of degree of
rotation that we want so we did like 120
degrees we could bump the contrast up to
1.8 and now we have a happy little SVG
that has multiple colors has multiple
layers and we can still edit that by
using CSS filters and filters are
animatable because they're interoperable
because of all the properties that you
can input here you can calculate the
guys between them something to know that
is blend modes are not interoperable
it's just an on-off switch they're
binary but with filters we can have
animations transitions just a fun fact
to know the reason for that by the way
is that filters are pretty much the same
thing as blend modes except they are the
last step of the process so with blend
modes we kind of we can't really combine
them that easily because not all of
these equations work right in the right
order and then it's like becomes really
really unobvious how it actually has to
be like chained so but once we have them
all together in one single layer which
is here the case we can basically run
last equation before we produce the
final colors what we're doing here is we
take the red green and blue values
average them and then put them out as
red green and blue values again which
gives us the grayscale filter so that's
what the grayscale filter does the code
for the blur filter is long so we're not
going to do that but you can do all
sorts of things with the filters by you
know just chaining them together in the
right order and due to the availability
of you rotate and contrast brightness
and stuff you can basically get any
color you desire so we can also do a few
histogram optimizing things with CSS
filters and something that I think is an
interesting idea that came across lately
is this contrast swap technique idea so
essentially you first start with your
image and then you want to remove the
image contrast in a linear way so that's
the important keyword here this must be
a linear transformation because once we
do that we can reapply it using CSS
filters so if you remove half of the
contrast and then you up the contrast
your filter by two you get a sum 0 so
you get a contrast of 1 in the end but
what we're doing in the meantime is
reducing the Instagram the histogram can
also reduce the Instagram so that when
we send our users the image it's not as
big and this is exactly what JPEG is to
do when they compress images
automatically they go through a series
of transformations like this but this is
us manually doing an additional
transformation of our image that were
saying to our users so I did sort of
test this and I did a little tester with
a couple different types of images so
here we're seeing a pretty big savings
point nine megabytes the images are
pretty big but they're the standard
photo size that you take on an iPhone
here we're getting 20 megabytes savings
and so you do get a savings of around
23%
average when I was doing a bunch of
tests like this on your images just by
reducing that contrast you can also do
this with saturation you can do it with
a few different things but I found this
to be the best one and just to show you
exactly what's going on here this is the
filtered I'm applying to all the images
and add contrast to the page so again
note that if you are sharing this on
Twitter on face
but you will get that decreased contrast
image unless you can set a meta property
for what image you're sharing the reason
this oh sorry yeah yeah so just to like
no you might be saying like what about
paint like wouldn't that be making your
browser slow so I decided to profile
this to see exactly that to answer that
question and I found that the longest
paint for any of these individual images
was point zero zero zero six seconds per
paint so it's really not like so much
frame you're probably fine and Martin
told me a fun fact recently so yeah I
figured out that at least in Chrome and
Safari it seems either the dev tools are
lying or what happens is that once you
apply a filter it basically starts to
modify the way that the shaders are
working so whenever you're changing
shaders it only changes the composite
equation rather than repainting it
mileage might vary it's an
implementation detail do not rely on it
but basically measure measure measure
and it actually has a good performance
footprint fun fact test it someone read
an article please Thanks yeah the
conscience trick works because if we are
linearly reducing the contrast spectrum
then we can basically just do the same
thing so while we're doing this we're
dividing by a certain factor what we can
then do to and undo that is to basically
just multiply with the with the
corresponding thing to get to exactly
one back so if we are doing like 0.5 and
we multiply by 2 then we get back to 1
so that's why this kind of technique
works really nicely so another thing
that you can do is play with a mix of
media so you apply blend modes and
filters to anything I frames videos
images and here we have an example of
just doing exactly that if you ever seen
the cinema graphs it's where you have an
image and one part of the image is
moving and the rest is still I think
that's a really interesting effect you
can get a different sort of effect by
using some of these blend modes and
filters so we have a snowy day we have
this image of this girl okay it's
tweaking out on the screen I blame the
projector yeah this was this is smooth
here yeah it is seriously I swear to god
it worked five minutes ago when we hit
Green you can see that the the images
now are being screened together so maybe
just that video was massive and then we
apply some filters you can see it this
is something that's interactive with
your user so I bring this up because
when we compare that to a gift it's like
a really janky experience you can see
the lines of this not cool and then if
you look at the image size it's just
like so this is pretty big because the
image is big in the video is pretty long
it's like a high quality image as I'm
presenting in this setting but then you
can pair that a gif and the size is just
like you can't compare let's not talk
about floppy discs yeah you're gonna
throw all of the floppy disk boxes at it
yeah bucks so TLDR I'd say never use
gifts like ever ever a 410 ever the
reason why is because you can send gifts
as video you can server-side render and
send WebM which is like half the size of
mp4 and really optimize the experience
for users we do this at bustled we don't
send gifts anymore we just send people
video because you can have Auto playing
video on your mobile device if it's
silent which is awesome so like TLDR
never use gifts always send video
preferably sign WebM for a much better
experience thank you other thing if you
don't want a server-side render you can
use the video element because video
doesn't need a polyfill to do this it's
just how it came you can always send web
them after mp4 and then your browser
will decide what they can support for a
user so again there's nothing stopping
you from never using a gif again so
quickly wrapping up as we're going home
for her time slot so the image process
or the process of getting an image to
render in the browser has these four
steps now we can't do that much about
the download time it just takes a little
time we can't do much about the vram
upload that just takes a while to
actually get it onto the graphics card
but we can definitely trick our way
through decoding if we have less data it
also reduces the download but mostly it
reduces decoding if we have less colors
to work with and composite is our friend
wrapped up in shade and blend modes and
filters so definitely make use of these
things and can we use it today mostly
yes filters no not to you know the the
edge people are lovely people and
they're really really working you know
super awesome we want to get this all
into the web including the edge team
however they need data to actually make
that happen so one thing that you
definitely have to do is use plant modes
you now show you how to do this in a
progressive nice way right so that it
also works for edge users and Internet
Explorer users but the more you use it
the more inclined they have to be to
actually make it happen
made more priority also there's this
thing called user voice and it has a few
votes already and maybe so I think I
don't know but I have a feeling that if
we would like space this out over the
next couple of days and everyone like in
the next couple of days has like a
little reminder on slack or your
calendar it goes like remind me to
upload this then it looks like this just
generally an uptick in interest you know
it's not it's not us it's not our
conference talk it's just like it
happens to be that over time you know
tell your friends and co-workers neck up
yeah we're now it's up to you make it
happen just only all now like take out
all your devices and start actually
uploading it might actually not work
like that so with that that's good thank
you well</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>