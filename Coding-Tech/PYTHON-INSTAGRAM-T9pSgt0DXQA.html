<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>PYTHON @ INSTAGRAM | Coder Coacher - Coaching Coders</title><meta content="PYTHON @ INSTAGRAM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>PYTHON @ INSTAGRAM</b></h2><h5 class="post__date">2017-10-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/T9pSgt0DXQA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is Hui I lead infrastructure
engineering at Instagram I'm here today
with my colleague Lisa Gua to talk to
you about how we've been running
Instagram on a Django and Python stack
Instagram started coming to PyCon since
2012 when our first infrastructure
engineer talks about building pop
subsystems in python we're excited to be
part of this community and we're honored
to have an opportunity to speak here
with you all today but first of all you
might wonder what is Instagram to many
people Instagram is this brunch sharing
app which is just what we should use
right now on a regular Saturday morning
it started back in 2010 and has quickly
grown worldwide to become one of the
largest social platforms today over 700
million monthly active users use
Instagram on a regular basis so a few
weeks ago Instagram was actually down
because we were trying to deploy a
Python optimization into production I
know and this is what happened on the
news
but in all seriousness Instagram is a
social media platform and our mission is
to help strengthen relationships through
shared experiences for people today you
can tell a story of your life on
Instagram you can communicate visually
with your friends and family on
Instagram you can go live on Instagram
and more than just brunch photos you can
explore about anything
from animals to nature from beauty to
shopping from f1 racing to paint mixing
which is something I knew I learned new
recently whatever your interest is I
guarantee you you would be able to find
something on Instagram so let's go back
to 2012 oh sorry 2015 when I first came
to PyCon in Montreal and we had a
beautiful booth and many nice wax and by
the way we still have a beautiful boot
in Nice wax today and you're welcome to
stop by so many people came over and
asked us the same question Instagram
what the hell are you doing at PyCon and
at first I thought they don't know what
Engstrom is so I started repeating
myself and told them that we're a brunch
sharing app and I got interrupted really
quickly no no I know what Instagram is
my friends and family talked about it
all the time my question is what are you
doing at a Python conference so once
they learn we're a complete Python shop
the immediate follow-up question usually
is Wow how do you run Django and Python
at that scale right
or maybe you're more debate provoking
question would be why haven't you
written everything in nodejs yet and if
you will replace nodejs with rust or you
know language of your preference so why
did Instagram choose Python in the first
place to answer this question we have to
go back to 2010 and dig the two
co-founders Kevin and Mike now these are
two product guys with no real back-end
experiences back then so naturally when
they started they looked around for the
last available framework to help them
support the product they wanted to build
and here's what they found out it turns
out the Django and Python framework is
one of the most popular framework that
the co founders have knowledge of so
after watching a bunch of tutorials and
documentation they set off on their way
to seven hundred million users now what
does instagram love about python today
first of all python is famous for being
a developer friendly language that is
really easy to become productive with in
fact both Lisa and I had only C and C++
background and we started serious Python
development after we joined Instagram a
few years ago being a popular language
also means that it's really easy to tap
into the large pool of talented
engineers who wants to work in Python so
after many reasons we heard that people
want to join Instagram one of the
frequent ones being I want to build
stuff using Python even though we were
on a very Asian version of Django for a
long time we were nonetheless able to
leverage the maturity of the framework
and focus ourselves on the business
logic and shipping product so as an
example for over five years
we used the Django workflow to manage
all of instagrams user information that
is we run out of 32-bit user IDs way
before we ran out of the capacity the
capability provided by the Django
framework and in fact we've taken Django
and Python stack quite far by now so
very early in the days we've added
sharding support to the ORM layer of
Django in order to scale out the storage
needs for our social graph data counter
intuitively we have disabled garbage
collection in Python to improve memory
utilization in our memory utilization
efficiency
and you can follow the details of this
on our Instagram engineering block we've
also expanded Instagram to run across
multiple graphically distributed data
centers and we're comfortable to scale
Instagram to as many users that are
interested in using it as we could find
and this is our very own Cara Meier
talking about scaling jungle at the
annual jungle under-the-hood conference
but it's more than that
in fact picking jank picking Python as
the programming language helps to
influence and shape the engineering
culture here at Instagram we prefer to
use proven technologies our co-founder
Mike Krieger famously said once that our
users do not care what database
instruments are they certainly don't
care what language Instagram is
developed in the simple and pragmatic
nature of Python allows our our
engineers our developers to focus on
scoping and solving the real problems
for our users in our products rather
than getting stuck on some language
details but you might wonder Python it's
still slow right well if you were here
yesterday you know that Python is not
slow for processing hundreds of
petabytes of astronomy data it might be
slow if you're doing high-frequency
trading or low-level bit operations but
we believe at Instagram our bigger
bottleneck is developer velocity not so
much on computer code velocity
so our conclusion for which we're
certainly biased is that you can get to
a few hundred million users with your
product using Python before worrying
about the performance of your framework
and language now that's not to say we
don't care about scaling Python at some
point we realized that as we continue to
scale our team and our product our
server growth is far outpacing our user
growth and things would only get worse
as we continue to add more engineers to
the team and ship more product to to
production so here's our strategy to
address Python efficiency we started by
building extensive tools to profile and
understand our performance bottleneck we
proactively push critical but stable
components into native language
implementations such as C and C++ a
prime example being the memcache access
library we've also exploited using
saitama's ation as a weapon to
dramatically improve our performance one
of our engineers Eric's Olaf will be
talking about this later in the
afternoon and finally as we start to
look for the next 700 million users
we're going to entertain some of the
bigger ideas maybe making the whole
jungle stack completely async or perhaps
running a new writing a new Python
runtime so we realized that we have a
lot of challenges and opportunities
ahead of us and we're committed to
continue to push the boundaries of
running Python at Instagram but there is
one small problem for a very long time
like everyone else we run on Python 2.7
and Django 1.3 yes and we have a
even our recruiter back in 2015 knows
how just how to say that to potential
people and we have a list of small but
dirty patches sprinkled across our code
base so we thought to ourselves we're
going to be stuck on this setup forever
as if we didn't have enough challenges
after rounds of investigations and
discussions we actually decided to
upgrade our entire code base to Python 3
which to some people is a whole new
programming language and after a little
bit of work today I'm happy to announce
that Instagram has been running its
entire jungle web service fleet and the
salary worker fleet on Python 3.6 for a
few months now so what happened and how
do we get here with that I'm going to
hand over to my colleague Lisa to tell
you about our road to Python 3
thank you we and yes you heard it right
Instagram has been running fully on
Python 3 for a few months for the rest
of the talk I'm gonna rewind and go back
to you over a year ago
and share with you why we move to Python
3 some of the steps we took to get here
specific challenges we fixed and finally
where we are today so he was just saying
python is running well for us
why rock the boat in last year's pike on
guido announced by python to support
will end in 2020 and this time it looks
like it's going to stick fortunately we
were already moving in that direction
before that as instagrams infrastructure
team our mission is to keep Instagram
alive today and tomorrow's so we're
always looking for potential scaling
bottlenecks that comes our way down the
road six month one year and beyond so
here are some of our motivations first
is the velocity take a look at this very
typical Python method with an ambiguous
argument max ID it's an integer string
couple or look our developers have
actually been very nice to put a doc
string in there this doesn't really
scale its best effort there's no
standard tool to enforce the typing the
comment can also easily get out of sync
with the code itself worse than no
comment an Instagram many developers
work with multiple programming languages
C++ Java even PHP init modern from of
hack supports typing so that has been
one of the most important feature
requests from our product engineers and
it was great to see it standardized in
Python 3 the second motivation is for
scaling our server performance let's
first take a high-level look at
instagrams building blocks the user
requests coming to the web server which
accesses various back-end
services to retrieve information it
might also dispatch some tasks to the
async tier to execute for example
notification etc by far the largest
tiers that we have is the web and async
tier where we run Python now let's zoom
in on one server on each web server we
run and process these um CPU cores each
process can only process one request at
a time when the process is waiting for
external services to respond with
various user information it cannot
execute CPU locally so we would
configure em to be a lot more than em to
avoid CPU starvation but the more
processes we have also means less memory
budget for process and more frequent
process restarts which in turn will
cause more CPU consumption during the
process warm up the optimal number of M
will depend on the CPU architecture the
current user workload and the
ever-changing codebase and in his
continuous tuning to achieve maximum
server capacity what if we can have
fewer processes where n is equal to M
perhaps but each process can process
multiple user requests concurrently
while some requests are waiting for
external Network responses we can
execute other we can serve other
requests from the Django async i/o is
very promising in this respect to help
us move forward and we were very happy
to see it natively supported in Python 3
as opposed to the more scattered effort
an incompatible solution that existed in
Python 2 cert motivation extends beyond
Instagram Jan Python has a very active
development community that continues to
push the programming language forward in
all aspects thanks to all of you who are
doing great work here but it will only
continue
Python three and we want to be part of
it as we was also saying over the years
we have made various patches to the
older versions of Django and Python but
that wasn't very hard to upstream so we
want to change that by keeping up with
the latest releases of this software so
that we can contribute back to the
community more easily so those were
great motivations and we got a green
light to move forward with the project
let's just drop everything and work on
Python 3 well that's not gonna happen
right so we have two mandates that we
need to follow one there shall be no
user impact no service downtime for the
upgrade two there shall be no slowdown
of product launches so our product
engineers will continue to ship richer
user experience while we move the stack
to Python 3 under the hood how do we
make that happen well before we look at
several options that we considered let's
take a look at how Instagram ships code
to production Instagram develops code
our master with no branches our
development philosophy is to make small
and focused ifs even for large features
and reef actors during the development
phase changes are checked into master
typically within an hour it is pushed
the production at this point the feature
may not be a visible to the user
hiding behind a gated configuration when
the feature is fully developed and
tested it done goes live commits like
this happens on them on the master tens
of times a day and deployment continues
to happen throughout the day with that
in mind let's take a look at some
options that we consider for migration
first option may be pretty obvious for a
lot of companies to take when you
develop a new feature cut the branch
develop on it and merge it back it
doesn't really work well for us as you
saw in the previous slides we have tons
of commits on the master every day
and Python three changes really overlaps
with the whole codebase so there will be
great branch synchronization overhead
that is error-prone also if we have run
this French divert diverts this branch
from master for a long time and haven't
run it in production merging back would
be a huge risk if only a handful of
developers work on the branch then we
lose the opportunity to educate other
engineers were more than happy to help
with the migration so this option was
out the next observation is that we run
the same code on all of our web servers
any of the web servers can serve any
requests what if we convert one endpoint
at a time and create a separate pool
that runs Python 3 and run those
endpoints that have been converted but
might work well for some applications
that get Facebook each team owns a
different binary and they can migrate at
their own pace it doesn't really work
well for us with one binary many of our
endpoints share common modules that
continue to evolve many our developers
work on multiple endpoints so they all
have contacts switch between the
different Python versions and there's
overhead in managing different pools and
they keep on shrinking and growing so
that option is out as well or just
mentioned common modules what if we
extract those common modules out and
make them like micro service so instead
of local function call when ours when we
need to access these services we just go
out make a remote procedure call to the
micro services well that would require
massive code restructuring and incur
much higher user latency because each
two requests will now have to make a
multihull
multiple hubs to access these micro
services and the deployment is also much
more complex than what we have now so
that option is out as well all scenes
were so very good at delivering large
changes via small steps we decided that
we're gonna follow the same practice and
just make my
are compatible so that it can run under
both pythons um Python 3 virtual
environments so we'll make small changes
on master that are both that are version
compatible when production is still
running Python 2 and when all the code
is ready we switch the virtual to Python
3 and pray actually we did better than
that we managed not to make headline
news during the Python 3 migration via
these carefully staged faces so the
first two major pieces of work were done
in parallel where we handle the
third-party packages and made massive
compatible changes in our source code
during this stage the coaching is we
make we don't know whether it works for
Python 3 because we're not running it
but we know that it works for Python 2
because the code is already running in
production then we have an intensive
very productive 2 month of unit test
fixes followed by a slow and careful
rollout in production
I'll cover each of these stages in more
detail next Instagram has been run using
open source packages where we can since
day one and we continue to do so so the
first rule that we put in place is when
you add a new dependency to our source
code
it must be Python version compatible so
so that we stop the bleeding of more
python 2 only packages in the in our
repository over the years we have
accumulated a number of packages that we
no longer use so it's time to clean them
up also some Python 2 packages are no
longer needed in Python 3 because
they're natively supported so the victim
as well we then make a number of upgrade
to the packages motifs bigger one is
Django from 1.3 to 1.8 it was necessary
because Django 1.3 did not support
Python 3
but also it was a long overdue upgrade
as we mentioned but because we had
sprinkled diffs around the codebase that
was hard to entangle there had not been
enough incentive to move it forward
forward until now with this upgrade we
try to we managed to make the Django
codebase completely intact
with minimum changes in our code base
for customizations so that future
upgrades of Django will not be as
prohibitive at the same time we use
modernize utility to make massive
modifications to our source code we
would do one fix it at a time across
many different files as opposed to take
one file at a time and make all the
fixes on that file it makes the code
review process much easier when you're
the code reviewer is only looking at one
fix at a time and here are the changes
we made during the modification but as
you can imagine during this process
we're basically racing with our brother
product engineers which continue to
check in shiny new features but continue
to break Python 3 compatibility and
there was no really good way to capture
these errors and prevent from prevent
that from happening until we get unit
tests in place I don't have to accept
the many merits of unit tests but I want
to say that it has been especially
helpful in our Python 3 migration with
unit tests we don't have to go out and
look for problems with Python 3 they're
right there staring back at us all we
need to do is to fix them that's easy
for developers and unit tests are easy
to reproduce they're easy to iterate on
with the fixes so any engineers who
don't even own the code would be able to
jump in and help with the fix so for the
next two months we were basically
hunkering down and had our most
productive two months in the whole
Python 3 migration
well I did mention that our commits will
go out of production within an hour of
it being in master I did not mention
that each of these commits have to go
through many thousands of unit errs
before they can actually land in master
well at the beginning of Python 3
project only a handful of those tests
would pass for Python 3 but we don't
want them to regress so we added a
inclusion list where we put in the known
passing tests and add that to the
lending process so now each diff that
comes into the master has to pass for
both python to you as well as the python
3 tests that should pass as we fix the
unit test the list grew longer and
longer until it made sense to put a
switch to an exclusion list where we put
in the known failed tests at this point
any new tests that people are adding for
their new feature or further existing
feature have to be Python 3 compatible
by default with decent test coverages I
was very happy to bring up my Instagram
feed on my sandbox that runs Python 3
and get my daily dose of cat videos but
this is just a very small step to work
projection there are limitations to unit
tests we're not a hundred percent
covered that's one of my dreams many
external services have mocks in tests
and data compatibility issues typically
don't show up in unit tests where the
read and writes are happening with the
same software version so now it's time
to put Python 3 in the real world by
switching developers sandbox to Python 3
this is a much more slow slower and an
painful process than the unit test faces
because in it's a bit like a peeling
onions until you fix the outer layers of
issues you're not gonna see the issues
at the next layer but we kept on finding
issues fixing them and adding unit tests
back where they should have been makes
in the first place and repeat the
process by switching the sandbox to
Python 3 we also make sure that anybody
who's developing new features would have
the feature be Python 3 compatible from
the get-go when developers stopped
reporting issues on their send boxes we
then exposed Python 3 to Facebook
employees who use a much wider range of
Instagram features than just the
developers and then slow rollout to an
increasing percentage of our users oh
this doesn't actually represent the time
we're spending on each of these circles
in fact where we spent increasingly less
time in the outer circles because we
found and fixed majority of the issues
during the developer and employee
testing phase and focused more on the
performance tuning during the user
rollout phase so what are the specific
changes that we made during unit tests
and developer testing they're too many
to enumerate and most of this is pretty
boring to everybody so I'm just gonna
list a few examples that captures the
major categories of problems that we hit
first I'm loosely using Unicode to refer
to unicode string by string related
problems at the beginning of the Python
3 migration project most people would
basically add those four lines of code
at the top of each of your source file
well we decided that we would skip the
last two lines because they would cause
subtle behavior differences for Python 2
and in accordance with our mandate we
need to keep Python to complete a sing
and save and error on making explicit
changes for Python 3 so unicode is the
most prolific issues that were existing
in our code base and this is just a one
typical example we're creating a made H
mark new objects with a string that
should have been byte string
creates a Python 3 exception the fix is
just a convert to string 2 by string
before you create the object well it's a
little bit verbose but more importantly
the developer has to think I'm a running
Python you should ID code in code my
pace in doing Python 3 decode in code
after a while you get brain damage so
instead we created a number of valper
functions with the purpose of the
function in this name so it's easier to
understand what is trying to do and not
the mechanism for us to get there with
that the fix looks like this it's more
succinct and it's much easier to
understand last time I checked we had
over 500 uses of these helper functions
so they were very helpful in improving
the product productivity in the Python 3
project the next big challenge is data
compatibility issue especially with
pickle we use pickle too one of the use
cases for pickle is to store data in
memcache and we use highest protocol to
encapsulate the data so when I converted
my own sandbox to Python 3 and try to
reach in my whole feed home feed my
fellow co-workers started to complain
about exception that's happening on
their sandbox it turns out the highest
protocol is for in Python 3 &amp;amp; 2 in
Python 2
oh no problem easy fix that's hard-coded
to Python to - least common denominator
coming from networking background if
you're speaking ipv4 I'm speaking ipv4
we can communicate or surprise strikes
if I write with Python 2 with the simple
dictionary with a unicode value I get
interception in Python 3 decoding
vice-versa if i encode the same data in
python 3 the decoded result in python 2
is different than the original data well
that's bad news for us because we use
quite a few places
Pikul for exchanging information between
different entities so we looked at
several different options thrift is used
in facebook extensively for
serialization deserialization between
different entities and has great
backward compatibility support it does
incur higher schema definition overhead
as well as encoding/decoding cost
message pack on the other hand is
comfortable performance wise to pickle
with low with you know a very simple to
use API but it lacks universal support
for all kinds of data types so we had to
custom decode and decode a few of the
data types that we need to support in
the end we looked at each of the Pico
use cases and had to come up with
different solutions with each of them
with memcache what we decided to do is
to cut the key space into two so python
2 and python 3 never communicate with
each other in that case next up is
iterators in python 3 some of the
methods that you still return lists have
now become iterators such as these oh
it's great performance wise because when
you don't have to compose a new list
it's better performing but it creates
subtle behavior differences when you
walk through an iterator and consume
those elements in the iterator it
disappears from it so you can really
only use the iterator once here in the
example that bit us as you know we use
Python to optimize our runtime
performance and but sites and files need
to be precompiled so this is part of the
script that does that line 1 has a list
of sytem files to compile line 2 maps
them to a particular class instance that
helps us in this process line 3 checks
if any of these files is still to be
compiled
mindful creates a pending list of them
to work on while it works well for
Python too when we converted to Python
three we found that the first file is
never compiled why is that it's because
line choose map function has now become
an iterator so when we're checking if
any of the file is not compiled in line
three it consumes at least the first
file from the iterator and line force
build never has a dot P Y X in it so the
fix is pretty easy you just convert map
back to a list ok bugs like this it can
be very hard to spot if the picture that
should have been on the top of my feet
doesn't show up at all it's gonna take a
while to to find out but it can be more
serious for other problems so when
you're converting your Python 3 projects
always always run future eyes or
modernize utility and convert all of
your iterators back to Python 3 list and
then you can walk through the diff and
see where you can optimize if you're not
using the iterator more than once last
one is not really Python 3 specific but
you will most likely hit the problem
when you're converting to Python 3 so
it's a simple dictionary with keys ABC
what do you think the JSON dump outlet
is well it varies based on the Python
version as well as different runs for
the same Python version so if your
application really depends on the order
of the JSON output then you need to make
it explicit we got bitten by this in the
form of a severe performance regression
when we determine if a configuration has
changed based on the JSON output it took
us a while to find the problem so keep
that in mind when you're debugging some
tough issues
well with those fixes and a whole number
of others we are ready to roll but
something is too bugging us performance
at Instagram we use two metric to
measure web efficiency
the first is CPU instructions per second
a per request the less the better and
the second is maximum requests per
second that a server can support the
more the better
typically the two bentrik correlates so
when we solve very happily that the
first metric had a 12% increase a
decrease which is an improvement in our
case we expected to see a 12 percent
improvement in the second metric but we
didn't what happened we know that memory
configuration can have an impact on the
second metric so did we have a different
memory configuration not that we know of
we use you whiskey dot image to
configure it and this is the code that
checks the configuration so why did the
condition not meet for Python 3 Unicode
Bettis till the end so this is the
single most significant significant
letter in our whole codebase making a 12
percent capacity difference finally in
February 2017 we dropped Python through
to traffic to 0 and move to Python 3.5
within the next couple of month we moved
forward with Python 3.6 what do we get
from it we had
we had a cpu win of 12 percent on our
Jango tier and a saving of 30% on the
salary tier my memory what about the
mandates we had in the beginning no
service down no slowdown of product
launches during this Python migration
process we had an accelerated rate of
monthly active users we also have seen
an unprecedented number of feature
launches including live story and a
number of safety features coming back to
our original motivation to move to
Python 3 our early adopters have moved
over 2% of our functions with type-ins
we're developing tools to collect data
in production to help bootstrap the
typing process we have also made some
contributions to my PI and PI type shed
on the async i/o friend
we have accelerated async i/o adoption
across our endpoints reducing the user
request latency latency up to 30 40 %
we're also developing tools to help us
understand and debug async I'll issues
easier we have yet to support multiple
requests during it within a process
that's something we're looking forward
to explore very soon on the community
friends were working with the Intel to
benchmark a web workload so that the
site Python performance engineers can
use that as a metric reference we're
also looking into all kinds of runtime
optimization opportunities as well as
memory profiling a effort to sum it up
the Python 3 effort gave us better than
expected performance boost improved out
of developer productivity and set us on
a solid foundation for growing in the
next few years it can be done it's worth
it make it happen
and make it Python 3 better
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>