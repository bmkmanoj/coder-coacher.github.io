<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>WebAssembly and the Future of the Web | Coder Coacher - Coaching Coders</title><meta content="WebAssembly and the Future of the Web - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>WebAssembly and the Future of the Web</b></h2><h5 class="post__date">2018-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JWCr9vcpl3w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's go ahead and get started
so good morning welcome to this talk on
web assembly in the future of the web so
by way of introduction my name is anthon
rains and the project that I work on
just so you know a little about my
background as a standard Lib which is a
standard library for for JavaScript and
ojs with an emphasis on numeric
computing and that grows everything from
basic trigonometric functions that are
accurate and robust to machine learning
statistics cluster II and natural
language processing etc the whole gamut
and how it's related to web assembly is
that a lot of the work that I do in
order to make sure that we can do
performant numerical computations and
web browsers is to use web assembly to
try to get in your native speed so
throughout this talk I'll try to at
least impart some of the learnings that
I've kind of taken in as I've as I've
worked with web assembly I'm kind of
where we're at in terms of performance
and the roadmap and its implementation
so the overview of the talk is as false
I'll first talk a little bit about
history motivate the story of web
assembly oh those that don't know all
introduced web assembly I'll talk about
the tool chain I'll then go through some
examples and then finally I'll discuss
the future so by way of history the
first prior art the web assembly really
goes back to Java applets now Java
applets were small vacations written in
Java or another language which could be
compiled to Java bytecode when a user
launched a Java applet that Apple was
executed within the Java Virtual Machine
and a process separate from the browser
itself now for much of their life Java
applets were significantly faster than
JavaScript and we're especially useful
for compute intensive applications now
as browsers have improved and their
engines and the runtime performance and
has gotten like things like hardware
accelerated graphics that performance
boost has significantly diminished to
the point now where Java applets are
effectively deprecated the next bit of
prior art was ActiveX and this was an
alternative Java applets created by
Microsoft and in theory it was supposed
to be like OS independent but in reality
it was strongly tied to the
operating system the next bit of prior
art was Native Client by Google this is
also another way of running a native
code in a sandbox environment the only
problem with it was that wide get in
your native speed it was specific to a
select few processors notably Intel x86
and arm that was followed by portable
Native Client which was an architecture
independent version of Native Client but
Google has since deprecated portable
Native Client in favor of web assembly
and then the last bit of prior art was
Azam's AAS and SMGs started off as a
research project at Mozilla and the goal
was determined whether JavaScript could
be reduced to a language subset that was
amenable to ahead of time optimizations
and other performance improvements
similar to what you get with statically
compiled languages now the team working
on SMGs was able to show that by
reducing javascript or language subset
they were able to get near native
performance 1.5 to 2x of native code and
this is great and the nice thing about
as in Jas is in comparison to the other
prior efforts was that because it was
just JavaScript it was backwards
compatible at the web it can be run in
older browsers so building on the
collective efforts of the past 20 years
browser vendors came together to achieve
consensus on a binary format for the web
and in short web assembly is a portable
compilation target for the web and where
it allows is it allows running languages
other than JavaScript within browser
environments and in particular it allows
taking languages and compiled into a
format that can be run on the web and
the current target for web assembly is
statically compiled languages such as C
C++ and rust so as I mentioned web
assembly is a compilation target so
before going further I want to make a
brief interlude Nicky into compilers so
a simple compiler would take source
files directly and compile them to
machine code specific to a target CPU
the issue here is that for every input
language right you needed to find how to
translate that input into machine code
so if the number of languages is
and the number of target CP uses em you
need to do in by M or its multiplicative
now modern compilers such as LLVM and
GCC are now split into two components
there's a front-end compiler and a
backing compiler now the front and
compiler is responsible for taking a
high-level language like C and C++ and
compiling to an optimized intermediate
representation or IR and that IR is a
low-level language similar to assembly
the back end compiler is responsible for
taking that intermediate representation
and compiling down to instruction sets
or machine code by doing this the
translation problem is no longer in by M
by M plus M or additive right so for
example to support compiling a higher
level and additional higher-level
language all I need to do is write a
single funding compiler which can take
that higher-level language and compute
and translate to intermediate
representation and then once I have that
it can automatically be translated to
you all the existing target CPU
architectures and then in a similar vein
if I want to add a new instruction set
for a particular CPU architecture I just
need to figure out how to take that
intermediate representation and
translate that to my relevant
instruction sets so where webassembly
fits in this compiler chain is right
after that intermediate representation
here whether somebody's abbreviated wasm
and what we do is we take input source
files and see your c++ we translate them
to that optimized intermediate
representation or IR and then there's a
backing compiler which takes that
intermediate representation and and
generates web assembly that web assembly
is then sent to a browser engine which
translates that web assembly and to
machine instructions specific to that
target architecture of the host
architecture so just as web assembly is
a low-level programming programming
language which is specific to a
particular computer architecture and has
a strong correspondence between the
language and architectures machine code
instructions web assembly is assembly
for the web
as the name might suggest and webbot
simply has two formats it has a binary
encoding and a text format so let's
begin with this text format
now webassembly will and I say will
because there's no formal specification
yet for web assembly and I'll talk more
on that later it will define a
standardized text format that encodes a
web assembly module with all the contain
definitions in a way that is equivalent
to the binary format so as an example
I'll show the canonical example that's
shown like in every single web is some
way to talk which is how to add two
numbers now in this text format it's
this s ik s expression so similar to
Lisp that's commonly referred to as West
and these xyx s expressions represent
this program tree and what you'll see is
that after that module keyword you'll
have type which includes various
function definitions you'll have an
export section which says what I'm going
to expose to the external environment
and then finally you have the body
section which in this case takes two
numbers uses an operator I 32 add those
two operands and then returns a result
so in web is simply there are currently
four value types and only four value
types and those are 32-bit integers
single precision floating point numbers
64-bit integers and double precision
floating point numbers for everything
else everything else must be constructed
by manipulating raw memory which means
copying data to the module heap and
using pointers so moving along now we
have a simple working example let's turn
our attention to the binary format now
the binary format is a dense
representation of a web assembly module
so as an example using the same example
we saw in the text format here's the
binary format now if we convert that hex
to a string which is shown on the right
side we can see that the module is
comprised of six sections in this case
there's a NASM which is the preamble
section that you might see there there's
the type section which is defined by
that type keyword the function section
memory export the code section and
finally a name section at the very end
and each section begins with the section
name followed by the number of bytes
that comprises that section so every web
assembly module the first eight
bytes or the preamble now the first four
bytes of that preamble are the magic
number which is a way for file loaders
to determine whether a file is
webassembly or not and then after the
magic number there's the version and
here that version is one so after the
module preamble then you have a sequence
of other optional sections where each
section begins with a section code
followed by the number of bytes and
there are 11 sections okay the first
actually you have is the type section
which has all the functions signature
definitions you have the import section
which has import declarations this
includes like functions from the
external environment including
JavaScript after that you have the
function declarations which defines what
functions are used within the the module
you have a table section which has a
table for indirect C C++ function calls
after that you have memory this defines
like both the memory used internally
within a module and that memory can be
imported from the external environment
you could then have the global section
which has all your global variable
declarations you have an export section
which says like which exports are gonna
be exposed to the external environment
you have a start section which is
basically a function that can be called
after modules initialized before you
export to an external environment you
then have an element section which it's
for table elements you have a code
section which pink is all your function
bodies ie the actual implementations for
your web assembly module and then
finally you have a data section which is
for initializing your memory so linear
memory access is accomplished with
explicit store and load operators as
shown here
now web assembly also offers basic flow
control constructs such as if loops and
blocks and then the specification also
defines many operators and functions for
data manipulation truncation
reinterpretation promotion and demotion
here I'm just listening all the
operators for 32-bit integers if you
want to see the full list just look it
up in the specification so web assembly
has several purported advantages the
first is that the binary format is
compact which means that fewer bytes
must be sent over the wire and that also
means that there's faster load times
next because the binary format
is structured having a define layout
module loaders only need to perform a
single pass and that means that you can
instantiate a web assembly module much
faster than something that's written an
equivalent vanilla JavaScript and then
because web assembly is strongly typed
there's more efficient serialization and
of course if you have more efficient
serialization that means you're gonna
send fewer bytes over the wire and
faster load times next because what but
something is strongly typed whether
somebody's are able to before web
assembly compilers are able to form
ahead of time optimizations and this
stands in contrast to JavaScript where a
function must first be run and monitored
and once it's monitored if a functions
identified as hot it gets sent off to an
optimizing compiler where the compiler
starts making optimistic assumptions
about input value types and then if you
give it an unexpected value type that
gets sent off it gets D optimized and it
kind of rinse and repeats the same cycle
until inevitably if you keep on doing
this it gets put into a quote unquote
deoptimization help but with web
assembly because you already know the
types you can do all that optimizing
beforehand before ever before even ever
run in a JavaScript runtime so also
because webassembly a stormy type as
already mentioned you can avoid this
optimization d optimization cycle write
input and output value types are already
defined ahead of time and not something
I can Pilar must empirically discover
now because web assembly is lower-level
it also means that web assembly can be
more efficiently translated into machine
instructions which hopefully translates
to facts faster execution the next
advantage is that there's there's
currently no GC there's no garbage
collection and web assembly it's on the
future roadmap but right now you have to
manually manage memory that means
allocating memory on the heap and then
freeing that memory okay and this is
advantageous because it allows you to
control when garbage collection happens
and that can happen when your
application is running an idle rather
than currently when you have no control
over it but but of course on the flip
side of this is that any language which
depends on GC like Python that all
cannot be ported to webassembly
currently or at least not very easily
now if you combine all these after
mentioned advantages webassembly
promises for certain applications better
performance over javascript so that
pretty much finishes my high-level
overview of web assembly and next one i
talked about is a bit about the tool
chain now the main tool is inscripted
which is an LLVM to javascript compiler
now what in script and does is it takes
LLVM bit code which it can be generated
from c++ using like LLVM GCC or clang or
from any other language which can be
compiled to LLVM bit code and compiles
that into JavaScript that's when the
scripting does and in practice and
script and serves as like a drop-in
replacement for a compiler like GCC
which instead of binary outputs
JavaScript now there are a couple other
tools that are associated with this tool
chain
the first is binary n' by Marion is a
set of tools for use as a back-end for
compilers targeting web assembly as an
output format and and in particular
binary is used as for supporting the
LLVM compiler generation of web assembly
the next tool is the web assembly binary
toolkit also known as a wabbit yeah
right it is a set of tools for
converting between the web assembly
binary format and the web is simply text
format now most of the most of the web
of some a tool chain necessary for
compiling web assembly can be installed
via standalone and script an SDK which
includes and scripting binary n' and
clang now one thing I should warn you is
that the installed SDK is huge on my
local machine right now the entire set
of tools consumes over ting gigabytes
and space right and that's mainly due to
clang now at this time we can go to some
examples so here what I have is they
have AC function which computes they
have potenuse otherwise known as the
Euclidean distance all does is it takes
two input numbers squares each of them
individually and then takes the
hypotenuse but it's a little bit more
sophisticated and that avoids underflow
and overflow so if i want to compile
this to web assembly what I'll use is
I'll use in scripting I'll set some
command line flags such as a c standard
and then
the optimization level of talent
inscription that I want to Azzam module
and I also say that I want a side module
now what a side module flag does then
instructs inscripted to only output the
webassembly binary because by default
when compiling webassembly
in script and generates a whole bunch of
glueck how much of blue code that makes
working with the module heap a lot
easier but I don't really want that
because all I'm doing is adding all I'm
doing is working with numbers once you
run that you'll output a nice compact
binary file and if we convert that to
our text format we see those sections
that we saw earlier we have the type
declaration section we have the table
which has all those indirect c c++
function calls we have our memory
section our export sections which says
what we're gonna expose the external
environment here we're exposing the
memory as well as that the the function
that I want to compile and then I have
the the code body section which includes
the actual implementation using all
those operators that I showed earlier
now similar to require well let me take
a step back so what I want to do here is
I want to I'm going to take this
webassembly module in order to use it
I'm gonna load it similar to require
right now like a common GS module which
means I want to load it synchronously so
I'm gonna do is I'm going to read this
file off of disk and I'm gonna load it
into a buffer and that buffer ceiling
can be passed into a constructor which
is going to return a module instance at
this point the module is not executable
what I need to do first is I need to
define the module environment I mean I
need to say like what the memory is I'm
going to find the external memory the
linear memory that I want I'm also going
to find the table that has all this
indirect function calls and I'm going to
bundle those all up into an object
called imports that's going to be
imported into my module instance that my
module can then use so once I've defined
those imports I'm gonna create a new
executable instance and now that
executable executable instance will
expose that method that I can that I
want to use in my implementation so
let's go on to a bit more complex
example
this example what it's going to do is I
want to compute the sum of a civic
number of numbers right and that those
numbers are stored in an array and I
don't want to just compute the sum over
all values in this array I want to kind
of like skip around so I'm going to find
a stri that says like how I want to
index into this array and then I'm going
to define a constant end which says how
many of these elements that I want to
sum the implementations not super
interesting all you need to know is that
this is a routine from blass which
stands for basic linear algebra
subroutines which is a set of Fortran
libraries which can also be ported to C
but let's say you wanted to hook into
these these native libraries like these
is existing code bases for doing
high-performance in American computing
how would you do that here's an example
function so once you have this you want
to compile it so we're going to use in
script and again we're going to just
define some command line flags we're
gonna say we want wisdom this time we
don't want to use we don't want to
create a side module ie the only the web
would simply binary output what we want
to do is we want to get that glue code
that in scripted outputs by default to
make working with the module heap a bit
easier and also include some loading
logic just to kind of move us on that
boilerplate that we had to use before
and then I'm also going to set a modular
eyes flag which instructs and script in
to wrap that glue code and a common GS
wrapper so I can use it just like a
would require now when I compile this
kind of generating a much bigger binary
and there are several reasons for why
this binary is considerably bigger one
of them is that the module must operate
on vectors so must have like various
logic for loading and storing values on
the heap and it's also do the need for
including various standard library
functions that inscription automatically
inserts into this module so once you've
got that that binary now that we have
this blue code our our ways of using
this web assembly module or a bit
different
instead what I'll do is I'll define some
options I'll say like how much memory I
want and then also say the location in
the binary file now there's one thing
note about this this equates to about 16
megabytes and this is the default
minimum linear memory allocation for
every single web assembly module that
comes out of inscripted okay so you need
to think about that if I have a hundred
different web assembly modules each
allocating 16 megabytes of memory your
applications can consume considerable
memory right you need be aware of that
the current focus on web assembly is
really for large applications like or
game engines that where you have some
large code base that can all share
memory not for small modules right there
are plans to allow you to have smaller
memory footprints but right now if you
want to use web assembly it's 16
megabytes per module and that's from
each module instance right
I can Alec I can re instantiate a new
module multiple times each will be
allocated with a new typed array of 16
megabytes keep that in mind now because
I'm using the glue code I use this
create module function I then have a C
wrapper which defines the the signature
web assembly modules can only take
numeric inputs recall that so instead of
a pointer to the array that I want to
provide in this function what I'll do is
I'll provide a numeric integer offset
that says where in the module heap my
array starts and this is the array that
I want to operate over to compute the
sum if we go down there we go what
you'll know finding is that you want to
write a whole bunch of convenience
wrappers that make working with web
personally modules this is a bit nicer
here we need to so what I want to do is
I want provide the actual array and then
I'll convert that into a pointer that
numeric offset and then I'll also
provide some convenience functions for
allocating and deallocating memory on
that on that heap and you'll often want
to do this because these are just nice
things like maybe you want to do checks
in terms of whether memory has already
been freed or not right so the first
example of actually using this I want to
show is what happens if you have
externally defined data right I have
some data that I've already allocated
somewhere else it's a typed array and I
want to compute the sum over that type
of right so what I need to do is I need
to determine the number of bytes within
that array I need to allocate space on
the heap and then once I've allocated I
need to copy
data to the heat once that data is on
the heap I can then actually compute the
sum and then I can free that memory now
the important takeaway here is that if
you use web assembly modules like this
where you're taking a rays of data and
you're trying to copy in and then you're
trying to unmarshal data out of it
you're gonna get really bad performance
as webassembly
straight up really bad performance
you're gonna hit perf cliffs if you're
trying to constantly marshal data to and
from this heap
what you really need to focus on is how
to reuse that memory as much as possible
so in this example what I'm going to do
is I'm going to allocate space on the
heap I'm going to create a view on that
typed array that's that linear memory of
the of the web sum of a module and then
what I'm going to do is I'm going to set
values directly on the heap and I'm
going to reuse that memory to compute
multiple different sums if you can do
this if you can always keep your memory
inside the module and reuse it as much
as possible you can get really good
performance I eat near native
performance but you really need to think
about how you can reuse and share memory
especially across modules so in terms of
benchmarks is whatever one wants to see
here what I'm showing this I'm showing
benchmarks that compare a vanilla
JavaScript implementation a webassembly
implementation and a node.js native
add-on okay and this node.js native
add-on is actually hooking into a
hardware optimized blas and that's
important because i'll get back to that
in a second but first what we notice is
that for a very short arrays of length
10 vanilla javascript is faster than
using a web assembly module and it's
faster than using an odious native atom
however once we get to length 100 of
array elements what we see is that
javascript is no longer the winner
instead web is simply and node.js native
add-ons are pretty much neck and neck
they're equivalent performance and as I
increase my array length JavaScript
performance degrades especially compared
to web assembly and node.js native
add-ons and by the time we get to 1
million elements native add-ons this
hardware optimized blas is about 2x of
webassembly modules this is important if
you can leverage hardware optimized
libraries with node.js native add-ons
you should do it web assembly is not a
replacement
for nodejs native add-ons which i've
seen out there in the Twitter the
Twittersphere right where people say oh
now I can use web as simply instead of
nodejs native add-ons and I'll get like
I'll finally have a portable binary that
I can send around no like if you care
about performance you should care about
Hardware optimized libraries and you
should take advantage of them wherever
somebody is not a replacement for
node.js native add-ons now there are a
few notes that I need to make about or a
few comments I want to make about web
assembly the first is that is about glue
code now this blue code isn't small it's
quite large it's all JavaScript provides
a home and convenience wrappers for
helping you manage memory in these web
assembly modules and if you have
multiple different modules each with
their own glue code you might as well
just be writing everything in JavaScript
because the size of your bundle that
you're going to send down to your client
is gonna be enormous okay this is why as
I said web assembly is really geared
toward large code bases like game
engines it's not geared to small modules
is not the case that you're gonna go oh
I really want to compute the sum over an
array but I want it to be faster so I'm
gonna write it and web it simply instead
of JavaScript I'm it automatically you
get performance benefits no that's not
how it works right there's considerable
glue code that goes associated with
making web assembly modules nice to work
with there's also a considerable
boilerplate that you need to use there's
kind of like a little bit of ceremony
they have to go through to use web
assembly modules it's not as simple as a
require or an import statement in fact
the loader spec for web assembly modules
isn't finalized yet so if you wanted to
do like bundling or whatever to try to
bring these things into your web
application right now you need to write
a whole bunch of JavaScript logic to
make that happen that's the reality and
there's no like bundling solutions right
now to do this web pack has only
recently got funding to try to
investigate this if you're using browser
fine good luck you're not gonna be able
to do it you have to actually call these
files individually to load them the next
point I want to make is that web
assembly is a complementary technology
it is not a replacement for JavaScript
or for no J's native add-ons period it
is simply another tool in the tool chain
that you can use for those particular
use cases where it makes sense for a lot
of cases it does
make sense and you need to be aware of
that the next point I want to make is
that if you can reuse memory do it if
you don't reuse memory you're not gonna
get a good performance period next is
that if you care about scripting you're
not gonna write this web assembly like
you could but it's not you're gonna be
much more efficient and faster than
using JavaScript itself if you need
scripting languages use JavaScript you
already have the compiler ship down in
your in your web browser or in nodejs
you don't need to have any kind of
runtime environments take Python and
then compile to web it somebody so you
can actually run it or not write just
use JavaScript and then finally as I
said this is worth mentioning if you can
use node.js native add-ons I can tap
into hardware optimize libraries like
blast as I showed you earlier which
comes on many system that you systems
that you put on deploy on now like Mac
OS I have the accelerated graphics or
the American pew library on my Mac or
you need to get blast or law pack
installations use them just don't think
that you're just gonna take webOS
somewhere it's gonna replace everything
that you need so the roadmap for web
assembly so currently where we are we're
on we have cross browser consensus which
is good we're a version 1.0 which means
that we're no longer MVP which means
that browser vendors are shipping
webassembly enabled by default so you
can was use web assembly to day in the
latest cutting-edge browsers the
specification however is under active
development in fact prior to version 1.0
there was no formal w3c working group
only now our browser vendors working on
a formal specification in terms of LLVM
right now that entire tool chain is very
experimental there are plans to graduate
that tool chain from experimental to
stable but currently what you need to do
is you always need to make sure that you
have like all the latest tools and
script in binary and webassembly binary
tool kit etc and because these things
are entire always in flux and you can
always break in terms of developer tools
that are plans by the browser vendors to
and include better developer tools for
web assembly within these browser
context but it's not yet they're right
they're working on these things there
are new features in the pipeline
including threads SM ID
garbage collection exception handling
full I Triple E 754 support etc and you
can start experimenting webassembly now
in fact if you using nodejs
and no jess version 8 which will soon be
LTS you can use web assembly and i
encourage you to do so so you can learn
more about the technology and its
limitations and strengths so with that
I'd like to thank you then concludes
this talk if you're interested in how we
think about web assembly especially for
high performance and American pooting
definitely check out the project is
github comm slash standard Lib - Jaya
slash standard Lib if you want to help
support the project there's a pattern on
link and that's it thank you very much
I'll be around for questions throughout
the conference so definitely come up and
ask me questions thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>