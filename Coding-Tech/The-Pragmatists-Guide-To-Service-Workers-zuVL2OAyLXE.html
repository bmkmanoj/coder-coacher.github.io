<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Pragmatist’s Guide To Service Workers | Coder Coacher - Coaching Coders</title><meta content="The Pragmatist’s Guide To Service Workers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The Pragmatist’s Guide To Service Workers</b></h2><h5 class="post__date">2018-04-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zuVL2OAyLXE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody I'm really glad to be here
I love smashing conferences and this is
another great one and I do work for
beaucoup my name is Liza gardener I work
for beaucoup but I actually live in the
force at Vermont so I work entirely
remotely you can find me at liza danger
on twitter or at my own site at liza
calm which definitely has a
serviceworker so let's not dilly-dally
because i'm claiming about 63 and a half
minutes worth of content into 48 minutes
I can do that because I talk really fast
so beware so what is serviceworker let's
not waste any time
besides the silly creature I've drawn to
represent it for us today well I'd love
to be able to say that a serviceworker
is a script because that's easy right a
JavaScript file that would be a concise
and easy thing to understand
it's a rough approximation but it's not
quite right it's not quite accurate it'd
be or more accurate to say that a
serviceworker consists of a script and
the logic in that script can allow the
serviceworker to behave as a proxy and
proxy is one of those vague terms that
kind of drives me crazy so what am I
talking about here well let's look at
the model of a traditional setup without
all that newfangled serviceworker stuff
a browser in the network a browser needs
to get ahold of the things that it needs
to show you a web page that's the HTML
document itself but also the sub
resources like images CSS scripts so
every time the browser needs a piece of
that it sends out a request and that
request by default will go to the
network and if everything goes right the
network is available and it returns a
response and things proceed along
merrily
of course this predictably breaks down
in a world where connectivity is never
guaranteed and when the connection
between client and network is no longer
extant a service worker can help out and
here's the proxy part it can act as a
proxy by insinuating itself between the
client the browser and the network it
can intercept requests and respond to
them in ways that it sees appropriate
not necessarily involving the network at
all if it so desires
so to rehash a serviceworker consists of
a script and it can act as a proxy
between the client and the network and
by doing this it can define what happens
when the browser is offline and improve
online performance by strategically
avoiding certain network round-trips
it could also do a lot more Oh
okay so let's level set for a minute who
is this presentation actually for we're
talking about an API that is absolutely
expressed in JavaScript so I can't
escape showing you JavaScript I can't
show you serviceworker without showing
you some JavaScript on the other hand
I'm hoping that my examples which are
fairly constrained and simplistic and my
heart felt if terribly drawn
characterizations of the pieces involved
will at least make some of this make
sense to a broad audience so I hope I
can give you each and every one of you
at least a tiny bit of nugget of
information so like I said I talk really
fast things go by really fast fret not I
have a lot of slides but hey every
single thing I talk about today all the
source for all the examples all the
supporting assets for them resources
documentation links can be found in a
repo that the link the URL here's now
don't panic this URL will also be on the
last slide I will post it in slack and
on Twitter and anywhere else I need to
do to get that information to you so
what I want to say to you as I'm giving
this presentation don't worry about
caching absolutely every last bit of
syntax and stuff because there's pretty
extensive notes here in links and every
time you see this particular icon up in
the corner and a slide that's an extra
reminder that I promise that there is
coverage of this particular topic or
links to more resources in that repo
that I mentioned and you can peruse that
at your leisure any time so today we
will be looking at how a serviceworker
can handle offline experiences and
improve online web performance but the
world made available to you in the
general sphere of web of serviceworker
is quite a bit bigger so we won't have
time to look at that but before we dive
into what we're looking at let's see how
it does fit in let's let's give it some
context and see how serviceworker fits
into a bigger world before we get truly
started there are several ABI is
associated with serviceworker or for
which serviceworker acts as a gateway
these let you do even fancier stuff then
we're going to talk about today like
push notifications and background sync
these in the serviceworker api are
generally roughly connected together by
the notion of web workers and a
serviceworker is a kind of web worker
and web workers allow you to run logic
in the background without getting in the
way of the main execution thread of the
browser they allow the higher
performance needs
the fancier api's to not like get in the
way of the main things going on
and web workers have some things in
common in the first place something has
to create in start a web worker web
workers are created or instantiated from
code running in one given context but
they tend to execute in another web
workers and remember that service
workers a web worker consists of a
JavaScript file the code in that
javascript file is run in a worker
thread again not getting the way in the
main execution in the browser and a web
worker has a different global context
okay wait this is super vague I'm
talking about an object created from a
context what and like global different
global who so a context is like a
container or a bubble a browsing context
for example is an environment in which a
browser displays a document roughly
speaking every open window or tab in
your browser represents a separate
browser in context there's more nuance
to it but let's leave it at that for
today every open window or tab browsing
context within the browsing context you
have access to things that make the web
work like manipulating the DOM and stuff
in a web work but a web worker for
example a service worker executes within
a different context it's inside of a
different bubble than the context that
created it and browsing context again
executes on a different thread than web
workers a context is represented by a
scope in an HTML document in a browsing
contest this may feel familiar the
global scope object is a window in a
service worker the global scope object
is something called a service worker
global scope and there are ways to
interact between these two bubbles these
contexts for example using the channel
messaging API to communicate between
these but it's important to remember
that they are separate bubbles and you
couldn't for example use a service
worker to modify the Dom of a client
page that's controlling hey so this is
starting to see if it complicated like
with context and scope already just out
of the gate and it's it's about to get
more complicated because we're gonna
meet more features and things about
service worker lifecycle and event
handling and interactions with fetch and
cache api's so why does service worker
feel so complex one reason is pretty
self-evident it does a hell of a lot
have that kind of flexibility and power
you're gonna naturally have a bit of
complexity it's sophisticated but
another reason I think is more
interesting to think about older
approaches to doing some of the things
you can do with serviceworker have an
absolutely terrifying drawback up
sometimes getting yourself you into
situations you can't get out of like
it's very scary
wretched times so a serviceworker I find
to be much more forgiving it's it's
actually rather chill I've yet to find a
way to get myself into unredeemable
trouble with serviceworker and there are
just a couple of hard and fast rules you
do have to follow when working with
serviceworker you are going to have to
use a GPS that's a requirement you can
develop you locally using local host
that's fine that's an exception but
you're going to need to use HTS the
other consistent rule is that everything
you do in a serviceworker needs to be
asynchronous you cannot use blocking API
is a pretty classic example would be
local storage that's a blocking API you
can't use it within service workers in
terms of browser support we're in a much
happier place than even the last time I
gave a serviceworker related talk
serviceworker is definitely shipping in
Chrome and Firefox Opera and Microsoft
is quite committed now to shipping a
serviceworker now when it comes to
Safari that's always a mystery like
really who knows but the momentum is
certainly in favor of serviceworker it
isn't moving along I feel much more
confident than I did eight months ago
giving a talk like this so let's start
by doing something really basic let's
make a serviceworker that accomplishes
nothing we'll create a javascript file
for a serviceworker that will listen for
fetch events and do absolutely nothing
about it so listening for fetch events
let's talk about this what does this
mean well when a browser requests a
resource if that resource falls within a
serviceworker scope and we will talk
about what that means in a minute if
fetch event is dispatched at that
serviceworker can if it chooses listen
for and handle the serviceworker can
elect to respond to that fetch for that
resource in its own way or it can stay
out of the way and let the default
behavior happen the request will go out
to the network and try to try to resolve
that way in our case here we will listen
for fetch events but do nothing with
them which will allow that
fault network-based behavior to happen
so this requires just a tiny bit of code
which you might imagine for doing
something for creating something does
nothing it's just about right instead of
a new file will pretend to create called
serviceworker j/s will just add an event
listener listening for fetch events and
registering a callback function here but
the function does absolutely nothing and
that's it for the moment that's our
first service order but now we need to
register our useless serviceworker
so you see we have this javascript file
but it's pretty lonely it's not really
doing anything and a web work or any
kind of web work has to be instantiated
by something it has to be kicked off in
serviceworker case this is a process of
registration you can register a
serviceworker by adding some JavaScript
to a web page and when you register a
serviceworker you're registering it
against a scope here we are the scope
thing the scope a scope is a path or a
pattern it is relative to where the
script file is located it could be the
current directory or a subdirectory now
a thing to note is that the highest
allowed scope for a serviceworker is its
own location or below it can't have a
scope for things above it unless you use
a special header called serviceworker
allowed again notes on that repository
if you want more information so if an
HTML file at the top level of your site
registers a serviceworker
also located the top-level your site
against the scope dot slash blog the
resulting scope for that Service Worker
will be everything under blog in its sub
directories but you that serviceworker
will not be able to handle anything that
happens any fetch things that happen for
things above its scope those things are
outside of its scope
all right registration of serviceworkers
happens inside of web pages so let's
work with an apocryphal oversimplified
HTML file here and within a script
element we will go ahead and register
our useless serviceworker now let's zoom
and enhance get that bigger on my screen
and the first thing we'll do is a little
bit of simple feature detection to
assure the existence of navigator dot
serviceworker and that's a good sign
that the browser supports serviceworker
and this is kind of extra credit
information detailed information but
natus navigator dot serviceworker is a
reference to a serviceworker container
object
which provides utilities for managing
service workers for including the
ability to register them so we will take
advantage of that we will use the
available register method on the on the
service worker container here navigator
adopt service worker giving it a URL to
the script and maybe some options so
back to our code once were certain of
support for service worker from our
featured section we'll use the register
method to go ahead and register service
worker jjs but if you're watching
closely you might be like well you know
what just happened to scope you're just
talking about scope and there's no
mention to that how does it know what
its scope is well you can optionally
pass a string as a second argument to
register and that that is the scope so
you you could do something like this
where you are passing a scope and saying
current directory or Bloedel flash but
it turns out that's actually the default
behavior so if you don't define scope
the default scope will be the the
location of the Service Worker file and
everything below it so at this point our
useless Service Worker is moving along
we have it being registered by our index
page here and it listens for fetch
events and does absolutely nothing with
them okay let's enhance this uselessness
let's make it even more useless but
don't worry it is all leading somewhere
so we have our registered fetch handler
here that does nothing and fetch event
handlers are invoked with an argument
and that argument is a fetch event and
the fetch event represents a fetch
action there's stuff inside this fetch
event that we will make much use of
shortly and that includes a request
object which is chock-full of
information about the thing being
requested and a method respond with that
will allow our service worker if it so
chooses to respond to that fetch with
something that it decides instead of
going to the network so we can respond
with something here inside of our fetch
handler but what do we respond with how
do we know what to respond with and what
does it mean to respond and to
understand that a little better we need
to chat a little bit about fetch fetch
gives us an interface for fetching
resources from the network it's somewhat
similar to XML HTTP requests
but more sophisticated and complete the
two key types of objects with fetch are
request and response objects and you
work with those so the idea is that you
can fetch a request and it will if
everything goes right in the network is
available eventually resolve to a
response object and that is what the
browser is after so if we want to
respond to a fetch event in our
serviceworker we need to respond with
something that is or will ultimately be
a response that the browser can use so
in our event handler we've got it we
we'd get a fetch event and that's the
argument event here and we're responding
to it and we need to respond with
something that will become a response
object and we looked at a minute ago if
you fetch a request and the network's
available it will resolve to a response
so we can very much if we wanted to do
this respond to the fetch event by
fetching the request which is of course
completely useless because that's what
the browser would do anyway so we have
this serviceworker intercepting and
handling fetch events but sure sure but
it's use it just mimics what would
happen anyway so it goes out to the
network so it's it's almost time to make
our serviceworker less useless and
actually do something but let me prepare
here first we need a whirlwind tour of
JavaScript promises a JavaScript promise
is an object that may produce a value at
some time in the future like a cocoon or
chrysalis we do hope that it will be
fulfilled and resolved to the type of
value we expect when we invoke fetch it
does not actually return a response
object directly but it returns a promise
and we hope that that pending promise
will resolve to a response but promises
don't always become the things we wish
them to become and when something
doesn't work out with obtaining the
result we're looking for a promise may
be rejected and so you see a pending
promise may be settled by being either
fulfilled or rejected and understanding
this is is relevant because
serviceworker api is heavily promise
based and in practicing this talk the
section only took fifty five seconds to
this point so here's an extra sentence
that i added we can use promises to our
advantage to make a serviceworker that
actually does something
now we can extend our serviceworker so
that it shows a custom offline message
to a user when they are offline that
means in a happy state if you navigate
to the landing page of our site and the
network is available they will see a
message that says if you see this you
are in line and that is entirely because
there's a paragraph in the index.html
page that says if you see this you are
online alright so but what we want to do
also is if the user is offline we want
to display a custom message that looks
like a webpage in this case it will be
the completely useless message Odia so
let's see where we are here we have our
fetch Handler and when there is access
to the network this fetch the promise
returned by this fetch will resolve we
know that we get that because we're
we're in happy times we have the network
access hurray
however when the network is not
available the promise will not fulfill
but instead it will reject a response
cannot be obtained so the original
promise rejects now what we can do is
handle that we can catch that and do
something about it and handle the
offline situation we can chain a catch
on to this fetch and the function here
will only get invoked if that promise
rejects our you know things are there's
an error thrown so inside of this
function we should handle the offline
situation to get something that looks
like a webpage that says oh dear in it
the browser is going to need a response
that it thinks looks like a webpage and
good news we can actually create one of
those in code we can create our own
response object there's a constructor
for the response object available in our
scope so we can handle this it offline
case by returning a newly created
response object that has a body that is
a an HTML snippet of paragraph saying oh
dear and then to get the browser to
understand that this is supposed to be a
web page we can set a content type
header to text slash HTML and that means
like hey I'm a web page
act like a Moeller page please so
there's a problem with this I mean we're
kind of close but the approaches is not
without problems our service worker at
present will handle a rejected fetch for
any resource within its scope by
returning a janky web page that says oh
dear that means that when offline if you
there's an image request it will respond
to that image request with a janky that
a webpage it says oh dear or a script
request with a janky little web page it
says oh dear
this is not ideal instead what we can do
is look at the fetch events request
object which has a property called mode
and when requests stop mode is equal to
navigate that means that the request at
hand here pertains to navigating to a
new web page it's a request for an HTML
document request stop mode is a little
bit recent I mean it's got pretty decent
support but in some places it's not
supported so you can get the same effect
by looking at request stop method making
sure it's a get request and looking at
the accept header to see if it's looking
for a web page text slash HTML but for
simplicity all stick with request stop
mode surround the entire respond with
with it conditional so we're only
responding here to fetch events that
pertain to navigation all right we've
done it we now have a situation where if
you if you get the index.html page on
the top level of our site hooray
you're online but if you request any
HTML page on the site and you are
offline oh dear so now we have an
offline message but I think we could do
quite a bit better so let's use our
service worker to serve an offline page
whereas before we were creating a lame
hand rolled response here it would be
lovely if we could actually have a full
customized offline page an HTML page we
could use to say to show the user when
they're offline and the interest of
keeping things simple this is still a
really lame page but it is legitimately
an HTML page it's not you know something
we're rolling in code and it served up
as offline dot HTML on our proverbial
web site here so what we're going to do
is we're going to extend our service
workers so that it provides a custom
offline page when navigation requests
are made and the network is unavailable
we have a desired offline page at
offline data HTML but we're going to
need to somehow stash a copy of that
page so that we're confident the browser
has it available to it when it needs it
later right got a stick it somewhere and
to get the job done here we're going to
need to understand a little about a
service workers lifecycle
a service worker has a seat when a
browser downloads a new Service Worker
it starts out in a par state and then
automatically moves into an installing
state and it has been installed now this
install phase that happens gives the
developer a chance to set up the service
worker like purposely stashing resources
in cache there's an assign and there's
an Associated life cycle event with
install unsurprisingly called install so
we can just like with fetch add an event
listener for the install event and
register a callback okay so this install
event is fired and we have an event
handler that needs to take care of some
business so it's some asynchronous
business but we really need the install
event the whole phase to hang on until
we're done because we can't really say
that the install phase is complete until
we actually have that offline page
stuffed into cash like successfully so
we need the install face to somehow hang
on or stretch out until we're done well
fortunately an install event is a kind
of extendable event an extendable events
give us this method wait until which
will make the event live on until the
promise given to it resolves so we can
use wait until inside our event handler
for extendable event here making the
install event wait around dragged out
until we're done but done doing what
like to store the offline and page in a
cache we're gonna have to understand
what a cache is in the first place so
let's look at the cache API a cache is a
place that you can store response
objects in their associated requests put
another way it's a map of request
response pairs a cache any given cache
has a name any name would you give to
and use to identify it you the developer
have complete control over these caches
an origin may have any number of caches
you can create as many as you like and
name than what you want but do note that
they are not the same as the browser's
built-in caching mechanism they're
completely separate and completely
controlled by you and all of these
available caches are organized into and
managed by cache storage the cache
storage interface serves as a directory
of all available caches and it's through
cache storage that you access
work with that you access and obtain an
individual cash that you want to work
with and cash storage exists in the
global scope a service worker as a cat
as a property called caches it's just in
the same way that fetch is available in
the global scope
so is caches right then now that we've
met the pieces involved we need to do
the actual caching of the offline page
during the install phase of our
serviceworker
so we access individual caches through
the cache storage interface caches so we
need to first open a cache by using
cached open and giving it a name of the
cache we want to open if that cache does
not exist it will create it for us and
that returns a promise that resolves to
the cache we are asking for and then
once we have this promise in hand we can
go ahead and put the offline page into
it so it would be available for later
now remember a cache object stores
requests in response pairs so in what
we're doing in this case we will want to
have both a request in a response object
to stick into that cache we can create a
request object for the URL of the
offline page that's a perfectly
appropriate request object that
represents the request but for the
response that's a little bit more
challenging because in the previous
example we were creating our own
response within code but that's
absolutely what we don't want to do we
want this response to be the offline
page but how do we do that we have to
get a hold of it so before we can cache
the offline page we have to go get it we
can do that using good old fetch so
let's look at this in code so you know
we have an offline URL here offline dot
HTML keep it in a variable for
convenience and we tell the install
event to hang on to wait until we
successfully fetch that offline page so
we go out and we fetch it and we're
online so that's going to respond to
result to a response and then that's the
response object we'll need then we ask
cache doors open that offline cache
we're calling our cache offline we can
call it whatever but we're calling it
offline and I'll put you down the rabbit
hole here of promises when the cache is
open and available we can use the method
cached output to stuff the request it
responds
into it so here we are we're doing it
using cached output we're using the
request for that offline page and the
response that we got back for it which
contains the offline page so we are now
getting that into cache and if you
aren't a Kodi person and prefer to see
this graphically here's what we just did
we went ahead and we fetched the offline
page offline dead HTML that resolves to
response because we're online hang on to
that response because we'll need it
we open the offline cache we get ahold
of it once we've got it we use cached
output to put the request and the
response into it so now the browser has
a copy of that offline page for later
and we know it does so the last step in
getting our offline page to work is to
update the fetch handler to serve the
offline page when navigation fetches
fail when the browser is offline in our
current or serviceworkers fetch handler
when a navigation fetch redirects we're
responding right now with a home-brewed
response object we made this ourselves
but now we're gonna replace it we're
gonna respond with that offline page so
to find things that we previously put in
a cache we can use the cache match
method and give it a request for which
we'd like to find a matching response
but first we need to get a hold of the
cache that we need as we've seen before
we asked cache storage to open the
offline cache and then we use cache not
match and say hey go find me a response
for offline dot HTML now you'll notice
that this particular example here I'm
using a URL a string instead of a
request option object proper and that's
perfectly kosher this shorthand here is
is just as good is actually creating a
request from that URL that will happen
for you automatically alright so there
we have it when you're online you go to
the top level or site you'll see a web
page says if you see this you are online
and if you were on that offline and you
request any page on the site you will
see the full offline HTML page so we
have succeeded there and now for our
next trick we're gonna talk about
network strategies it's a bit of a right
turn because service workers can be used
improve online performance as well as
further define offline behavior through
implementation of networks
oh geez so let's say our site has a lot
of often changing HTML content when the
browser wants to navigate to an HTML
page on our site we want to get the
freshest content possible so we
purposely want to make sure that we go
out to the network and try to get the
freshest copy of that HTML document but
if that fails wouldn't it be nice if we
can look in our caches and see if we
have a previously stored copy of that
page this going to the network first
approach is called a network first
strategy and it's got the freshest
content possible when the network is
available but it has the nice side
effect of being able to provide cache
content potentially when the user is
offline our site might also have some
assets let's say images that are
particularly static they change rarely
and for those those fetches we can
implement a cache for strategy in which
we first check to see if we have a
previously cached copy in our caches -
and this has a network performance boost
in that it avoids unnecessary Network
round-trips and if we don't have a cache
copy then go get one from the network if
it's available
so cache content is used by default here
but network is used if the asset is not
in cache yet so implementing network
strategies presents us with a couple of
new challenges first we need to
determine what kind of request request a
given fetch represents so we know how to
treat it and second we need to somehow
get stuff into caches so it is there for
our use later potentially and for
problem number one figuring out what
kind of requests we're dealing with
we've already handled part of this in a
previous example where we look at the
request mode and if it's navigate that's
probably that represents a fetch that's
for an entire HTML document we can
expand this to determine what fetches
are for images by one option here at
least is looking at the the headers of
the request and see if there's an accept
header that has a string match for image
like image flash JPEG or in image / PNG
and that could represent an image
request okay that's that's challenge
number one but we need to somehow get
stuff into caches for those network
strategies to be successful in the
future so to understand challenge 2
better let's take a deeper dive into the
implementation of a net
work for strategy which is what we would
use for navigation requests for entire
HTML pages and within the network for
strategy itself there are two possible
paths an online behavior in an offline
behavior we'll start with the happy path
which is what happens when the network
is available and we're online so what's
the plan
first we will attempt to fetch the HTML
document being requested which will
resolve to a response because this is
the happy path and we're online then
we'll want to deliberately cache a copy
of that request for potential use later
on to do that we open the cache as we've
seen before calling we're gonna call
this particular task assets because hey
why not
and put the request response pair into
there the tactic of putting things into
cache as we see them for possible later
use is a technique called read-through
caching when the navigation fetch here
is successful we want to go ahead and
take this response object and stuff it
into cache for later but first we need
to make sure that this response is in
good shape it'd be ashamed to cache a
response representing say a 4/4 error
there's a boolean okay property on
response objects that we can check the
that make sure that the response code is
in the 200s and that it was an
acceptable response that's the first
step and the last bit of housekeeping
before we can stick it into cache we got
to open that cache but we also need to
clone the that response and the reason
is that a responses body can only be
used once and we're about to retake this
response and give it to the browser
because the browser wants it right away
but we also want to stick it in cache so
if we use response that clone we can
make it copy that and stick it into
cache and everything's good and is the
last step we just want to make sure that
we return that response so the browser
can use it and that's the happy path of
a network strategy at first strategy so
the analog piece to this is the offline
behavior of a network first strategy
which is what happens when we are
offline so in this path the fetch for
the HTML document rejects because
there's no network available we don't
get a response object so what we can do
then is check inside of caches to see if
we have a match for that request from an
earlier time if if we have a store copy
from earlier and if we do we can just
go ahead and return that response and
this has the effect of letting the user
review this webpage when they are
offline so we're using caches dot match
here in the earlier example I did it's
it's a slight it seems like slightly
subtle difference but we use cache not
match match method on an individual
cache object and when you use it the
match method on the cache storage
interface caches don't match it's gonna
search across all of this caches to see
if it finds a match whereas cache don't
match on an individual cache object will
only look within that cache now that
there's good reasons to use both in
different situations but the thing I
want to point out here is that they both
have an interesting behavior that can
trip you up if you're not paying
attention if they do not find a match if
there's not a match for that request in
in the caches they will not reject the
promise they return will not reject it
will resolve to undefined and this is
something we'll need to account for in
code we need because we need a usable
response object so this is the state of
our fetch handling for navigate requests
after we built the happy path so let's
fold up that happy path and give
ourselves room to implement the slightly
sadder path for when we're offline so
the this catch will get invoked from the
original factory rejects because we're
not online and in it we can look for
response across all of the caches and
when that promise resolves we this is a
slightly brute-force way of doing this
but looking at the response object if
it's falsely in any way we it's not a
response object we're gonna want to use
and so what I'm doing here is I'm
actually explicitly throwing an error
and this will allow me to change to this
promise chain which we'll see in a
minute but if the response is okay
looking if it's if it's true they go
ahead and return that response object
that's because we found what we were
looking for in the cache so the last the
fall back fall back fall back for this
is if what if we're online but we don't
have a match or offline excuse me but we
don't have a match for that request in
the cache well we can implement a third
another fallback behavior because we've
got this initial fetch that's failing
and we try to look in caches to see if
we can find a match for that but say
we don't find a usable response object
here so we can reuse the logic from our
offline page handling to go ahead open
the offline cache grab the offline page
out of that and return that instead so
you can give the user an offline page
like sorry I don't have I don't have a
copy of this in cache so you're just
you're just actually offline so in this
first cache here we were checking the
truthiness of the response in through an
error if it's not so good and that
allows us to then count and chain the
second catch on and handle the the the
reality that we don't have any in cache
so we go ahead and return that offline
page sweet so that's a network first
strategy attempting to get a fresh
network copy and trying to return a
response from cache if that doesn't work
out for a cache for strategy you might
use for a static asset like an image
things flip around on their head of it
first we'll check for the resources in
cache and if that doesn't work out then
fetch a fresh fresh copy from the
network using fetch and go ahead and use
read through caching to make sure that
you do go ahead and cache copy of that
asset so it is available for the next
go-around right I'm not gonna walk
through that implementation it is
available in that repo to this point to
get stuff into cache we've used the
cached output method this method takes a
request and a response object however
there are other ways there's also the
add method which just takes a request or
URL and fetches that resource from the
network for you and caches the resulting
requests response pair corollary to that
there's also an add all method which
takes an entire array of urls quests all
of them and caches all of the response
results this is a handy convenience for
another serviceworker recipe that's
pretty standard called application shell
you can use a serviceworker to manage
the asset on your site or app shell that
is let's say your website or app has a
bunch of static assets images and
scripts and CSS and stuff they get used
on absolutely every page or pretty much
every page and they're like you want
them always available they're part of
the applications
she´ll and managing applications shall
within a serviceworker gives us a couple
of new challenges we have to put assets
into cash during install in the first
place we have to make sure those assets
have been cashed and later we need to
respond to fetch is for those static
assets with a cash for strategy we'd
like to avoid going to network we want
to use the locally cache copy so you
want to put all of our application shell
resources into cash during the install
phase so we need to identify our
application shell resources at the top
level of serviceworker you can just sort
of corral them into URL I'm sorry into
an array in this particular site for
some reason has the need to show a lot
of clouds on every page but you know
whatever and within an install event
handler will do something not too
dissimilar from when we pre cached off
an offline HTML page in a previous
experience will open a cache ask the
cache storage to open this cache will
call static and we'll go ahead and we
will use at all to stuff all of the
things in our cache files array into the
cache so now we have all of the
application shell resources in a cache
rock on now step two involves handling
fetch requests for those assets so to
tell whether the fetch represents one of
those assets we can look at its URL and
see if there's like a match of the
current of the request URL to one of the
URLs in our array and if so we can go
ahead and use a cache for strategy here
we'll try to see if we can find a copy
of that resourcing cache first and using
the same general strategy as we use
there our network strategy here you know
make sure that the response that comes
back from the cache is something usable
and if it's not go ahead and go out to
the network and get a copy of that asset
that application shell asset so cool
we've now managed to pre cache and serve
up our applications shell resources
without having to hit the network so
we've seen how a service worker goes
through an install phase and have
created infant handlers for the install
event we've used that phase as an
opportunity to pre cache things for
later use but serviceworker also has a
subsequent lifestyle it likes a
lifecycle phase act
vation it will go ahead and move through
the states of activating and it will
become activated but what causes the
serviceworker to move through these site
lifecycle phases well I started touched
on this earlier but whenever a browser
downloads a new serviceworker and that
is whether it's a serviceworker that's
been updated or server sort of this just
entirely new for that scope it will
parse it and it will always
automatically move into the install
phase it will become installed it will
become installed but what happens after
that service workers install depends on
whether there is a pre-existing
serviceworker for that scope yet if
there's already an active serviceworker
for that scope i'm sorry if there isn't
already an active serviceworker for that
scope if this is a brand-new
serviceworker hey the serviceworker will
then continue right into that activation
phase automatically but if there is
already an existing service worker in
the scope the serviceworker the new
serviceworker file will not go through
into activation right away instead it
has to wait until all of the clients
that are currently controlled by the
previous serviceworker
have closed but we can short-circuit
that by adding a little detail to our
install handler that just uses the
method skip waiting and as it sounds
like this makes it so it skips waiting
it finishes installation and then pushes
itself right into the activation phase
and like some of the other things
methods and properties we've looked at
today
skip waiting is available in the global
scope the serviceworker so you can just
use it just skip waiting an applied
usage of the activation phase is a task
of versioning your serviceworker and why
is this something you would want to do
well when you make changes to your
serviceworker you're often changing the
logic of what's getting cached and how
things get into caches at cetera it can
get a little messy in many cases the
simplest or safest thing is to wipe out
all of your pre-existing old caches and
start over with a fresh set that are
populated with things that you know are
the case at the outset plus you might
want to undo something that you screwed
up
so like the installation phase
activation has Anastasia
Shadid lifecycle event unsurprisingly
called activate and like it's all event
it is an extendable event so we can add
a handler for it and tell it to wait
until we've performed our cleanup before
it moves on let's back up a minute
before we go any further and see that we
could how are we gonna do this
versioning thing well we can define an
arbitrary and lame version string like
this and you'd want to update this
string every time you update your
serviceworker it just represents that
this is a new version of the
serviceworker and then every time you
reference a cache by name like opening
it you just you you involve the prefix
or the string in some way and this
uniquely marks the caches that are
associated with a given version of your
serviceworker it's identifiable so when
we have a new serviceworker how do we
clean up and the idea is that we want to
wipe out all these old caches which can
be identified by examining their names
and deleting with the ones whose names
don't match the current newest version
prefix the caches dot keys method will
return a promise for you that will
resolve to an array of the strings for
all of the caches that are currently
defined and available to you so now we
know all the names all the keys of the
caches and inside of our activate
handler we've asked the event to wait
until we've obtained all the current
cache keys and now we're going to do a
little bit of this is extra JavaScript e
this is the most JavaScript example so
to remove crafty caches we'll start by
using array prototype filter here to
filter these cache keys down to the ones
that do not match the current version
prefix these are the old cache keys
these are the ones that we want to
delete and then we want to then want to
take those keys and we want to map them
onto the caches dot delete method which
will delete a cache with the key that
you give it the result of this is you
will ultimately end up with an array of
promises that one for each delete
operation and finally because we do want
this activate event to hang on until all
of this is done we can use promise start
all to return an array of promises and
I'm sorry to return I which will return
a promise that will resolve only when
all of the promises in the rape provided
to it resolved so that will make it
wait until we're done now one more
goodie and we're almost done and this is
like but wafer-thin because recently we
use skip waiting to force a service
worker to move ahead from the install
face the activate phase and there's one
more thing at the global scope there's
also a reference to clients which is a
the clients interface is a container for
a list of client objects that is roughly
representing current open documents and
browsing contacts that are controlled by
the active workers and it has this claim
method that you can use in a sort of
boilerplate way and this allows the
current service worker going through
activation to become the actual active
worker taking control of those clients
without having to wait for a reload so
it also just zooms ahead for you and
adding this to the end of activate
handlers will speed things along for you
and my goodness thank you for enduring
with me and that is it for today in
terms of examples but that isn't
actually all as I mentioned toward the
beginning of the talk there is that repo
and that repository contains all sorts
of everything here today as well as a
whole bunch more stuff including some
additional recipes for creating say an
offline image or maybe you can use an
external JSON file for managing your
application shell asset lists and tons
of lists of resources and documentation
and again there is the URL to that
repository and I hope you get a chance
to look at it and I will find some way
to also provide my slides thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>