<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Let’s Code Real World App Using Purely Functional Techniques (in Scala) | Coder Coacher - Coaching Coders</title><meta content="Let’s Code Real World App Using Purely Functional Techniques (in Scala) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Let’s Code Real World App Using Purely Functional Techniques (in Scala)</b></h2><h5 class="post__date">2018-04-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/m40YOZr1nxQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today's goal is what we're going to do
is we're going to build a really simple
yet fairly real-world application using
purely functional techniques and the
idea is to compare some of the things
that we might do or be stuck with in an
object-oriented or imperative language
and then how that might look in a
functional way and I'm also curious kind
of throughout this to get feedback from
you guys as well so if you see something
that you'd like to give input to feel
free to call it out or or say it that's
fine
we're going to I'm gonna try to keep it
fairly intro friendly but we'll kind of
move into some more intermediate stuff
as we get through and we'll just kind of
see what time allows here in particular
what we're going to focus on is control
flow and error States because that is a
very compelling reason to get into
functional programming for starts
because functional programming really
helps you reduce a lot of noise in your
code and then also is a very concise
like provable way of writing an
application very clean and so this is
some of the things that I think are a
really good intro into why you would
want to go there now I have most of my
experience in Scala I really like Scala
as a language but at the same time I
didn't want what I show today to be too
biased towards that language so
everything I'm going to show today even
though it's in Scala as a language it is
available in all of the primary or say
but most popular functional languages
out there so F sharp
Haskell Elm and and others all of these
concepts are directly transferable to
those and more or less the names are the
same - okay so don't let the fact that
this is in Scala
you know discourage you now if you are
in c-sharp Java JavaScript and you are
not far off from having a functional
language that's an equivalent to those
in place and that's one thing I really
want to call out so if you work with a
team that's in dotnet and let's say you
guys are very heavily invested in
c-sharp but you've always been curious
about F sharp
I this is one thing that would be kind
of nice is to say this is why it might
be compelling to give it a shot same
thing with Java there's a lot of options
and Java there's Scala closure a newer
one EDA at I don't know what they how
they say that there's also a Kotlin so a
lot of interesting options there ETA or
EDA that one for those of you are
curious is like Haskell on the JVM so
that's pretty sweet it's a new one also
if you're in JavaScript you know some
people say well JavaScript supports some
functional stuff but there's more pure
languages out there such as pure script
and Allen so anyway I encourage you to
look at those and if you got a team that
is heavily invested in one of the
imperative languages you might want to
take a look at the functional equivalent
to kind of see the benefits that you
might get and it still will work with
all of your other codes you'll have to
throw everything out rewrite
okay so first things first when we start
talking about functional programming one
of the things that immediately comes up
are these words and these terms and I
believe that these are kind of the high
level words that you should start
getting comfortable with when you get
into functional programming now you know
if you understand what a mono it is a
functor a monad that will go a long way
into improving your ability to write
successful functional code very pure
functional code now the flip side to
this is that they're kind of
intimidating words because they're brand
new they're very mathematical in nature
they come from category theory and a lot
of times when you start throwing that
around it immediately becomes less
attractive or intimidating and I totally
get that
there are blog post out there I know
certain websites if I there's a guy I'm
going to quote today who writes a lot
about FP but on his website he makes the
point he goes I don't want to see
anybody use the M word we're not gonna
talk about monads we're not gonna talk
about applicatives those aren't friendly
words so we're gonna stay away from them
anybody that even uses them are gonna be
banned from my site I do not think
that's the right approach and the reason
is that you should call things for what
they are if we're gonna talk about a
monad that brings along very important
context and you should understand what
that means so I can talk to anybody else
that does FP about I'm using a monad
here and that carries certain meaning
along with it and Zach did our
presentation last month I thought one of
the greatest things ax said was I was
trying to Google around for this
technique and I was having a really hard
time and part of it is is just knowing
the words to Google with and if you know
what a monad is and you're trying to
look up stuff then you're gonna find it
by that not by some other derivative
name that is kind of fluffed and made up
by a particular blog author so I
encourage you not to be intimidated by
these words if you're coming from like
let's say that you first learn
procedural programming and you move into
object-oriented programming you've got
to go through the same thing you got to
suddenly know what encapsulation means
what does polymorphism mean
what's a singleton you're not worried
about that when you're writing C code
same thing when you're in JavaScript you
understand what a prototype language is
and what prototypes are you understand a
lot about like hash tables and how
JavaScript works you move into another
paradigm you got to understand what the
words are there so same thing when we
get into functional programming there's
a lot of terminology and you shouldn't
just turn it away because it's
intimidating or it comes to too much
like a mathematical background in fact
as you get deeper into it you realize
these are really cool things and they're
really great so I just want to kind of
throw that out there before we dive in I
am going to try to use those terms but
I'm going to try to demonstrate how they
work with with code okay
okay so before we dive in the code I
want to talk about one pattern which I
think is a very compelling pattern and
that is what Ascot lashley and I'm not
gonna say that name right coined as the
railway pattern okay and this is a very
interesting pattern for handling control
flow so in this example we have three
operations that we're going to perform
on data so we have let's say we've got a
source on the far left there and a
source is going to produce some sort of
collection or sequence of data items all
right and we're going to do three things
to those we're going to do a parse to
transform and then we're going to send
it somewhere else maybe we send it to a
database or a message queue and there
are two clear paths they're going to
happen there's a success path and
there's a failure path now we do this no
matter what paradigm you're in this is a
very common thing that you need to do
but let's for a minute step back and try
to abstract out that concept all right
so you know instead of looking at it in
terms of how we implement it let's just
think about what each function has each
function has two potential outputs
there's the success and then there's a
failure okay some people call it the
happy path or the sad path and we want
to chain these operations together so we
want to do this first and then go over
here and do this maybe the second thing
uses the result from the first thing now
if there's a successful if it's
successful from the first function you
want that to carry straight into the
second function but if there is an error
in the first function you want to bypass
the second function okay so this is just
very basic control flow and same thing
if there is in the second function going
to the third an error and we want to be
able to transition at that point to the
failure path so this is why they call it
a railway you can think about it in
terms of two railways one that is kind
of representing the successful default
railway path and then you can have a
transition or a switch at any point of
time going down to the failure path
you
and so what we'd like to be able to do
is in the case of a failure switch to or
bypass all subsequent operations while
still being able to compose them into a
single chain it's that last bit I really
want to focus on here if we can come up
with an abstraction that lets us compose
functions together in a very nice terse
package but then in the case of an error
carry that along without kind of
muddying up my code that would be the
ideal thing to do now in an imperative
language we have all kinds of ways we
can do that you know we can look at
using if conditionals so if this then do
this if this then do this
but we know that those aren't really
tight because you can make a mistake in
an if conditional you can have an else
statement that you forgot it's not
really tightly bound to the context of
the problem and there's all kinds of
mistakes you can make you could throw an
exception but if you throw an exception
you've now left the default call stack
and you're reaching out somewhere else
now and so that's really still not
controlling the flow of movement through
a clean path to your code so we'll talk
about how we're going to address this
all right so I'm going to try to live
code a lot of this I am not good at live
coding I'm a little nervous actually so
I have a cheat sheet and some backups so
we're gonna we're gonna kind of see how
this goes I also do not type very well
when people watch me so this is um this
is gonna be awesome
alright but here we go we're gonna give
this a pretty good shot here okay so
here's my Scala code and I have a lot of
stuff stubbed out and I'm gonna kind of
walk through this real quick the very
first thing that I want to look at is
this over here
okay so focus on this what we have is
we've got a raw data object with one
function it's going to generate a lot of
these raw user types all right so a raw
user is just going to represent some
sort of user that we might have in our
system there's going to be a full name
so it's gonna be first name space last
name it's going to be all in one string
variable we're gonna have like an email
address and a phone number okay and so
all we're going to do is when we call
this generate raw users we're gonna
return a sequence of these things all
right so that's kind of the input into
this logic here all right so I'm gonna
shelve that over here and now let's look
at our let's look at our raw user type
okay so as I said we have a case class
so this is how we're going to define a
type in scala and it's going to have
full name and email phone and some other
information all right now what we want
to do ultimately is transform this raw
user into a domain type so this raw user
has very like kind of just raw dirty
code that we might get from somewhere
and we want to transform that and to a
really nice like domain rich type so
that's going to be domain user
oops
down here okay so if we look at domain
user we have a person type and a phone
number for the sake of simplicity we're
just going to worry about extracting
those two things okay because I didn't
want to have a lot of other code but
let's just take we're gonna pull out a
person type which is going to be first
name and last name separated out and
then we're going to have a phone number
and a phone number if you look at its
definition is rich in that it's got a
County code area code a prefix and a
line number separated out okay so what
we want to do is produce a rich phone
number object from that string okay so
if we go to the top of our main function
this is kind of the unit of work here
we're going to call go which is going to
emit a sequence of these raw users we're
going to transform a raw user to a
domain user and then we're going to have
some way of calculating the result of
that so what we're gonna do is we're
going to count the number of times that
this is done successfully and we're also
going to tally up the number of times
that this failed and didn't go well
alright any questions about just the
boilerplate part here look good okay so
let's go down to the first part with the
phone number so let's look at this
function first a phone number we're
gonna have a function that can take a
raw string and break out the interesting
bits so I'm going to use a red X to do
this and it's going to be a very simple
regular expression it's going to be one
digit - three digits - three digits -
four digits that's all we're going to
capture so first things first string to
a phone number what are some possible
problems that might happen here
sorry it may not be a string okay may
not be formatted the way I want so I'm
applying a regular expression the string
that I get might not match that
expression so I might have a problem
okay now my function signature does not
account for that right now
right so I'm expecting a string I'm
returning a phone number but I got to do
something if that does not work well
okay so let's go over here I just want
to talk Scala for a minute and I say
Scala what I really mean is I want to
talk about functional objects for a
minute so one type that we have at our
disposal is called the option type and
some languages is called maybe and this
is a pretty simple type the idea of the
option type is that you have a box and
there is either some value in there or
not it's empty okay and so there are
usually subtypes to this so you have
some and none so the some subtype means
you've got something some value that's
in the option and the non subtype is if
it's empty okay so very very basic so
let's create a couple of these we're
gonna say this is going to be an option
of an integer and we're gonna say nope
okay well not get any helps you okay
I'll try to bump that up so let's put a
100 in there option and so we're going
to put none in here
okay so the first oh one I've created a
sum of a hundred so that means that
inside of my box there is a value of 100
and then in my option two I'm going to
assign none so essentially there's
nothing in there so I can do some
interesting things with this I can say
oh one dot get which technically you
should never do and I'll show you why so
I can actually get the value out of that
if I do Oh two dot gets I'm gonna get an
exception because there's nothing in
there and I try to fetch it so I could
do something like get or else and I
provide maybe like another number all
right now what's interesting about these
is I can do some cool checks on this so
one thing I can do is pattern match so I
can say alright if oh one contains some
value X then we're going to add a
hundred to it
and if it doesn't contain a value then
we're going to like return zero and what
that does is is that there's a hundred
in there the pattern match found it and
then it said okay I'm going to add a
hundred pattern matching and functional
languages and it's incredibly rich
because I can match on a lot more than
just a predicate I can actually match on
types which makes them incredibly
powerful I can say oh to match I do the
same thing
zero and in this case I'm going to get
zero because it matched the nun case now
let's say I want to do something
interesting with the contents of this
but still maintain the optional nature
of my value I can say oh one map now one
of the laws that an option allows is a
functor law and a functor is just a term
of applying a transformation to a value
so I'm going from an a to a B and I can
get into more detail at the end of this
if we have time but essentially an in
category theory if functor matches one
category to another and endo functor
matches from one category to the same
category and programming languages were
in the category of types so what I'm
doing is that I'm going to have a map
which says okay if there's a value
inside this box we're going to apply
this function to that value and I'm
gonna get something out of it all right
so I can say a 1 map and if there's an
for the value X that's in there I'm
gonna add 100 and close my parentheses
alright so there we go we have 200 that
came out of that now let's say there's
not anything in the option so my Oh 2
which is none if I apply a map to that
it still returns none there's nothing in
there to apply the value for but I
didn't get like an exception I didn't
get any kind of error I just got back
the same none that I applied the
function to and I could chain these
things I could say okay map and once
again for X we're going to subtract 100
and nothing happens because there's
nothing in there so I've now applied two
functions in a chain and it still worked
with the option and if I were to do the
same thing to a 1 then it's going to
actually apply the logic in sequence to
that all right I can do things like oh
one filter where X is greater than 50
and then I can map on it
so I can apply all kinds of really cool
operations on these things
let's look at something else that's name
now some people might say well how is
this different than just using like an
OL because you know Nowell represents
like nothing well it's because that this
option type uses a lot of laws from
category theory so we just talked about
how it represents the functor law it
also can represent a mano a law which
means I can add things together so let's
say I have another option
sigh ok we're gonna put a value in there
so we have oh one which represents
something and what I can do is use this
operator on you can't see that okay
I'm gonna use that operator on my two
options and what it's done is it's taken
two options and it said okay if both of
those have something in them then it's
going to append them together in this
case the append operation for an integer
is an ad so it's going to create a brand
new option that has the added value of
that inside of it but if in the mix I
add a none then I'm going to get the
leftmost side that has something so I've
done a one I've appended a nun to its so
I'm going to get the O one but if I were
to flip that around
thing I can't remember okay I'm gonna
get the same thing all right so doesn't
matter what side it's on but yes yes if
for any Scala people in here I'm
leveraging a scholar Z operator and
skylersays a library that gives me more
category theory type tools very similar
to Haskell okay so pretty cool and I can
chain these together so I can also do an
additional stuff where I add a three and
then I get all of those combined
together all right okay so going back to
our code one way to get here one option
I could do is return an option of a
phone number
now that gets us a little bit better
because now I cannot throw an exception
I don't want to throw an exception I
don't like those and I don't have to
return null you should never do that but
what am I losing in this particular case
because it's still not like really great
so what happens if I get none out of
this function
correct I don't have any context into
knowing what happened now I could
conventionally say well if you get a
nine then that would mean this function
couldn't parse it out you could say that
just use that as a convention but it
would be kind of nice if I needed to get
richer information from that so there's
another tool we can use called a
disjunction so let's go back to our code
here a disjunction
is a way to represent two different
states in the same type and it's
traditionally used to handle an error
case or a success case and there's a
there's a category theory law that
actually explains how that all works I'm
not going to get into into that right
now but typically you'll see this in
Scala it's either an either type so I
might have the type like well I got this
screen problem here
I might have either an error on what's
called the left or a success that's on
the right and so a lot of these
functions on it will be dot left or dot
right and that kind of conventionally
means air or success in Scala Z you can
use this operator back slash forward
slash which represents the state now the
cool thing about a disjunction is that
it follows the same laws as a monoid and
a monad that means all of the cool
chaining I can do with a mono monad I
can do to a disjunction which means I
can compose multiple operators together
that yield a disjunction to kind of
maintain this chain remember we're
trying to build a railway of success and
error so let's say I've got a valve e1
I'm gonna say that is a success let's do
this
the way I denote a success case is I put
a dash on either the right or the left
so a success would be a dash on the far
right so on the far right I'm saying if
it's a success I'm gonna return an
integer but if it's a failure I'm going
to return a string on the left okay so
there we have a write disjunction and if
I go b2
okay so here I have the one's a success
that's right b2 is a failure it's a left
so I can say v1 I can do the same thing
I can append these guys if there's a
failure in this case in any position
it's going to return the failure I can
also do things where I say v1 map and if
it was a success it's a right it'll
apply it but if it's a left
it won't okay so then if we do a v2 dot
map
it's so going to return a fail so a
little bit better because now we can
encode error information into my call so
let's do that with this so let's change
this to B let's go with a transform
error you can see the definition of that
on the top or a phone number so what
this type is saying is on the left if
it's an error we're going to return that
type and if it success are going to
return that type phone number which is
what we want
okay all right yes you can use either as
well so if you're familiar with Scala
there's another type called the either
type it's built into the standard
library and yeah the question there is
if you're using a library like Scala Z
Scala Z comes with a lot of type classes
that handle the mono a own add laws and
so a disjunction provides that type
class for that type and so you get all
of the rich API stuff from that so it's
mainly if you're a scholar developer
using Scala Z you can benefit from all
those type class stuff that they provide
that isn't just with the standard either
type so that's the big difference if
you're just doing straight up Scala
standard library then stick with an
either and you're good
the other thing is a disjunction is
right biased so if you're using a for
comprehension you don't have to say dot
right at the end of everything it just
defaults to that
okay so let's see here okay so what
we're going to do is we're going to run
this red X on the pattern so we're gonna
say phone string match and then we can
say pattern case pattern and then the
really cool thing about pattern matching
is I can just do a case statement on the
Reg X itself and then break it out so
we're gonna have area prefix and what's
called the line code so if my pattern
match is successful those variables will
be the grouped values from the Reg X
it'll be the captured groups which is
pretty sweet and I don't have to do any
kind of funky API stuff to extract my
groups out if that fails all right let's
handle that case first so if if there's
anything other than a match what we're
going to do is we're going to return a
left disjunction with a transform error
and we're going to say
the phone string didn't parse and if I
was doing this for reals I would give
why it didn't parse okay so now we have
our error states and we'll return a
disjunction from this now this brings us
to the next question okay so we want to
parse out the pieces of that phone
number now each of those are going to be
strings but my phone number type has
them as integers so I need to convert
from a string to an injured well this is
also an opportunity for a problem all
right so if I were to say okay let's do
phone number and I were to do code dot
two int okay so if you're familiar with
Java you can do two in on a string all
right so I could do co2 in its area dot
two ants prefixed
I'm sorry
oh okay look I had that wrong then
all right so if I were to do something
like this this would compile it would
run but what's the problem I'm gonna hit
potentially assuming my reg ex was off
yeah I got a string maybe there was an
alphanumeric and it's gonna bomb so if I
had my reg ex wrong that would be a
possibility right my reg ex is good but
that's not standard with me so so yeah
we could do this and this would be valid
code but it has the potential of
throwing an exception and we don't like
exceptions so let's see if we can come
up with some way to address this okay so
let's write a function called two
integer that's going to take in a string
and once again we're going to return a
disjunction of the parsing results so
we're gonna say transform err or an
integer okay now I'm gonna drop some
Scala that I really really care to talk
about real quick so I'm just going to
type this out and kind of bear with me
so I'm gonna do a try s - ants -
disjunction
left map
transform air
okay so real quick what this is going to
do is try as a Scala type that's also a
monad that will catch an exception but
keep it into a monad state we're going
to convert that to a disjunction that's
just a built in function and then we're
going to say if there if this thing is a
left then apply this map to it so in
other words if we get a left out of that
conversion we're going to transform it
into a transform error don't really
worry about that but that's kind of
what's happening here so what this
allows us to do is say to int code and
now I get my disjunction well now I got
another problem my phone number
constructor does not take disjunctions
it takes integers I really don't want to
rewrite that thing to take disjunctions
as its types okay because now I'm kind
of mudding my datatypes with the
functional constructs and it just
doesn't really feel very clean so I
don't want it to go down that path so
there's something else I would like to
be able to do here this brings us to a
concept called applicatives
which are pretty awesome and how an
applicative works is if you have
something that follows applicative law
and what that means is that you have a
valid apply function and oh I'm missing
the other one it's applying something
else I think it's just identity then I
can apply a series of options to create
construct an object so let's just take
two options first let's say I have a
class called foo case class foo and that
has two integers
so you can't
is it pure is that it okay thank you
okay so let's say I have a class foo and
Foos constructor takes two integers but
let's say all I have are options of
integer now with an option any of those
might be none so I don't really want to
construct a foo if one of them are none
so it would be really nice is to try to
construct the foo using the values
inside of those options but if any of
them are none then the whole
construction also returns a none okay
kind of see where we're going here so if
I had my o1 o2 do I have a no three I'll
create that I did okay so I got my three
options let's say and I have a couple of
ways I can do this I'm using standard
Scala I can use a for comprehension to
build this so I don't really want to
show that right now what I want to do is
show you the applicable form so for the
sake of time so what that looks like is
if I say oh one and then I'm going to
use this operator in Scala z3 and then
I'm going to use foo okay look what
happened here what I said was is oh one
apply o3 and then what it's going to do
is if that yields something then we're
going to have a sum of foo with the
internal values applied to the
constructor all right if I do the same
thing with one of those that was the
none case so to
I'm gonna get a nun out of that so
that's pretty cool so now I can work
purely with these options and I can
construct objects and it either worked
or didn't but that keeps me in my option
context so when I'm chaining stuff
together
nothing's bringing me out of that
context which is really cool the same
thing works for disjunctions I can use
applicatives with disjunctions and the
neat thing is is that for all of them
that failed I'm going to maintain that
left side that has my specific error
message which is pretty neat so I can
say V 1 that's the applicative I created
earlier V 2 yeah that was the same types
so because V 2 is a fail then I still
get the left disjunction with the fail
and then if I use V 3 which I think I
created with a successful value no I
didn't
let's do that real quick
there we go okay then we get a right
with the constructor to successfully so
going back to my code here what I could
do is just use a blicket of so I can say
two int code this is sometimes called
the macaulay culkin operator or the
screen operator for those of you who are
interested
then that's going to map to phone number
Boop thank you
alright see we've done there so now what
we've done is we've each of those have
the potential of returning a left so
we're just going to chain all that
together and then we're going to run the
applicable and so if anything's left
it's going to return a left in general
and then if they're all right then it
will construct the phone number
successfully so pretty cool any
questions about that makes sense okay so
let's go down to this case so let's look
at this person if you look over it our
raw data sets one of the problems that
we had was that the first name last name
was just in one string and has a space
in between and let's say that parsed
those out into first name last name
separately and we'll assume for the case
of this example they're all in the same
format we're not using like non American
names or middle names or anything so
what we can do here is we can say
oh wait I got this wrong I want to do it
down here there we go
this guy
so we can say okay person again we want
to capture the case so this doesn't work
so let's do our transform air as a
disjunction of person and then we will
say full name that splits we'll split it
on the space and again we can use
pattern matching to pop these out so we
can say a case burst last nil and then
if that's the case we'll return a right
disjunction of a person with first and
last and in the case where that didn't
work so well will return a left
disjunction with our transform error
oops okay so what this is using is
pattern matching and pattern matching
also lets me extract the head of a list
of a sequence of things so I can keep
dropping items using this cons operator
and as long as I keep going until I've
hit nil it will try to extract out those
values so if my pattern matched truly
two things with the space in between
this first case will work in which case
I'll return the right destruction if for
any reason that patter didn't match and
it went somewhere else like let's say I
had three things in the list or there
wasn't a space then we're going to get
the left side alright so again another
kind of cool way of keeping this all
disjunctions alright which brings us to
our transform function so let's kind of
pluck this guy out up here I'm just now
realizing we are not going to finish
this that's okay
let's get a few interesting things
okay so now I have enough to convert a
raw user to a domain user so what that's
going to look like is first of all I
don't want to return a plain domain user
we're going to go ahead and keep the
disjunction going all the way up all
right and then we're going to say
maybe person is going to be either a
transform heir or a person
and then maybe phone it's going to be
the same thing
and then we're going to just go back to
our plic ative here because those are
cool
oops
it's hype for people-watching all right
that's all I need to do so now I have
parsed out multiple things all of them
could throw a number of different
problems and the code is incredibly
tight I all I can do is just say I'm
either gonna have an error or it's gonna
be this thing and I just say look here's
the expression try to build it if it can
build it then it will and it's going to
return I'm a disjunction coming out and
then if there's a failure then it's just
going to take the left route but I can
nest that code you know all kinds of
deep and it's going to percolate that
air up without having to throw
exceptions and get off of the default
call stack so very nice and easy to read
let's see what else would be neat here
this let's go ah
yes okay I think I have time for one
other thing that I want to show before
we ran out of time here and that is the
concept of kering which it's pretty
helpful so taking this function one of
the things that I want to do is create
actually let's go up here in my main
which I haven't been able to build yet
one of the things that I want to do is
have this go function and go is going to
take a function as its input it's called
a higher-order function it's going to
take a function as its input and that
function when I call it means that I
have no inputs but it is going to yield
a sequence of these raw users now what
I'd like to do is hook it up to this guy
right so I can call generator all users
which doesn't take any inputs and it
yields a sequin of raw user but let's
say that in order to do that I might
want to read some values from a config
file a very common thing to do you might
have some sort of conditionals in your
config file that will contribute to how
it reads it let's say that you're going
to connect to a database and the
database connection string is in the
config file and then that thing's going
to run a query and pull data out well
those details I really don't want in my
main code here so if you're coming from
an object-oriented world you go oh
that's easy you can use dependency
and then you bring in spring and then
your whole life is maintaining spring
code because that's what it requires all
right functional languages are nice
because we're going to take that whole
concept of dependency injection down to
the most simplistic case at the function
level so we don't do dependency
injection we can with types but you can
also do it using a technique called
curring now kering doesn't exist for the
case of dependency injection purely like
there's there's actually a reason you
Currie like in languages like Haskell
the only thing you do is curry but but
it's a really nice benefit with it so
what curring allows us to do is
partially apply parameters to a function
so let's say I have a function and will
call it foo bar and that's going to take
and into the way you do this in Scala is
different than high school for instance
and Scala you have a parameter list with
multiple multiple parameter lists a
function of multiple parameters that's I
was going for so let's say that we're
going to take two integers and I'm going
to say return X plus y what I can do in
Scala is I can say
let's just do let's just do it applying
one if I call fubar and I pass in one
integer then what I get back is a
function that's still expecting one more
integer all right because I've only
applied one of the inputs and then I'm
going to get back a really a function
that I can call to pass in the other
inputs that'll give me the final result
so if I want to fully apply it I can say
fubar 10 20 all right that gives me 30
but what's really nice is I can do this
in a lazy manner so it might make sense
that I have one part of my code where I
want to apply the partially applied
function but then later in my code I
want to invoke the rest of the
parameters this is where the real
benefit of curring comes in so I can say
f1 is fubar 10 and what I've done is an
in the value of f1 I have placed the
partially applied function and so what I
essentially have applied is a function
into Val f1 and then later I can do some
stuff and I can call f1 with the other
value all right pretty cool so I can do
this in the case where I have a config
so let's say I have this source object
and what I'd like to do is say okay I
need to take in a config value and then
I'm going to partially apply this I'm
going to curry here and this is going to
return a function that takes no inputs
and it's going to yield a raw user so
what I could do is well I didn't really
provide it but I could say do something
cool with config maybe I'm going to
pluck out some values some database
connection strings whatever and then I
can call raw data that generates Brawl
users so up here in my main
do
you
you
okay so the way I could start this whole
thing out is I can say at the very
beginning where I have access to my
config class I can pass that into source
and this is going to partially apply the
config to that function and then it's
going to return me the remainder of that
function which is just a function that
takes no inputs and yields a sequence
for all user so that can be the thing
that I passed downstream where I don't
want my downstream code to know that
config is I don't really care about that
at that context okay okay well those are
the things I had some other stuff on the
show but I'm kind of running short on
time so I think I'm going to call it
there I think I'm gonna do some of the
more category theory stuff for a part -
are there any questions about what you
saw there anybody have any questions
ah right that's a good question so the
question was why did I use an
applicative instead of a for
comprehension and that is a good
question I did not show for
comprehensions in this but what I could
have done in my code would say I still
have okay so I still got my options here
right what you could do is use what's
called a for comprehension this might
look different in some of the languages
but in Scala this is the way it looks I
could say the value one being a 1 and I
could say the value of 2 is 3 I could
say yield a foo which is V 1 V 2 okay
they achieved the same thing as the
applicable and so what happens in a for
comprehension is every item here
essentially strips away the Monad and
gives me the inner value so what I've
done is in v1 if there is something in
the monad some value that will get
assigned to v1 and then as long as that
chain is all of the same type of monad
then I can keep stripping away those
layers and then I have a yield where I
can yield some sort of expression and
that could even be a code block right
there so yes that's a totally valid way
of representing that I would maybe use a
for comprehension if I had a little bit
more complex logic to construct it but
the applicable a of doing the same thing
and so that's why I chose applicatives
because it's very small and terse and I
didn't eat a lot of custom logic in the
yield expression
oh yes okay so the question was what
happens in the nun case so let's do the
same thing using my nun so remember oh
one had some and then I think it was Oh
two had none in it so what this is going
to do
is healed a nun so it's any point along
that chain I get a nun then it's going
to soon it's going to fail so this is
the exact same thing as writing Oh 102
to
for comprehensions I should say I can't
do some we didn't get into monad law
which I would have liked to but monads
have the ability to flatten and so if I
have monads or mono EADS that are to
have mono ease with inside of them and
so you can kind of get like these deeply
nested mono weights and then you can do
a flat map which allows you to do the
same logic but flattens at all see the
final top case and so a for
comprehension gives you a few more tools
to work with more monadic types and I
might I probably save that for another
talk and in terms of what that looks
like
okay any other questions
all right cool thanks guys so moving on
from that just a few announcements don't
forget about the ok 200 if you're
interested in going to that conference
next month is lightning talks I don't
have any speakers for lightning talks
yet so if you're interested in giving a
more abbreviated talk on a functional
subject or technology or whatever please
come and find me you can either find me
on Twitter here or I'm on slack as well
or you can go to the ok CFP meetup page
and there's a discussion board that you
can drop your interest there I might do
part 2 and you want to hear me again if
nobody speaks up so just keep that in
mind alright well thanks for coming I'm
glad to pizza made at this time you guys
have a good one</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>