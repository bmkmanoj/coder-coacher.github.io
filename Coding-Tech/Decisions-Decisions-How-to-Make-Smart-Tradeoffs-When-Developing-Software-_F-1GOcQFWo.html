<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Decisions, Decisions: How to Make Smart Tradeoffs When Developing Software | Coder Coacher - Coaching Coders</title><meta content="Decisions, Decisions: How to Make Smart Tradeoffs When Developing Software - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Decisions, Decisions: How to Make Smart Tradeoffs When Developing Software</b></h2><h5 class="post__date">2018-02-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_F-1GOcQFWo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we're gonna look at number of things
we're gonna look at some things about
development some choices and decisions
you make while we're building software
we're going to take a look at some
decisions we make and some trade-offs we
make in you know architecture and we're
going to look at deployment and getting
things into production because there's
no point writing stuff unless we can
deploy it I love these balloons
wonderful right so then let's take a
look at deployment I'm sorry development
so what kinds of things are we trading
off when we when we when we do
development we write software so
automated or manual build which one of
those is better who thinks that
automated build is better almost every
hand went up any think some manual build
is better pull stack no nobody okay one
person one person is figured out where
this is going okay what are we trading
off when we automate the build what are
we painting what do we gain the realtor
that build it basically doesn't depend
what what do we mostly in the general
case game when the Automator built what
are we go sanity predictability we gain
feedback from an automated build I guess
it depends how you Automator that
depends what else we gain repeatability
said two people simultaneously which I
think there's an irony in there saw it
okay repeatability and what else there's
another more subtle things we get a
level of documentation I can look at the
build automation I can look at the build
script and it tells me what things
happen which is quite nice so I gain
quite a lot I gain speed I probably gain
time back in my day because I'm as a
human being I don't need to do this work
so that's kind of cool what am i leaving
sorry flexibility my build only does one
thing it does the thing I told it to do
its programming okay so I might leave
some flexibility what else do I lose
sorry
money I lose money by automating a build
this man should not be automating builds
okay what else - what else I lose by
automating a build I lose excuses to go
get coffee this is absolutely true I
lose what I lose a lot of the time what
I lose is a knowledge of that build okay
I lose my up with these big complicated
builds that have more and more stuff
shoved into them and I don't know why
it's there and so eventually what
happens is I had one little thing - the
build and another little thing - the
build and eventually the build to take
in ten minutes twenty minutes an hour
and I look at this and it just takes an
hour but I still know that if I did I
have this fear if I did all these things
manually well it takes a lot it takes a
machine an hour it'll take me days and
days and I'll probably mess it up right
so I'll lose knowledge about what's in
that build I lose flexibility so with a
manual build here's what I do I get to
go and revisit all of those assumptions
that are currently in the built at the
moment you automate anything you lock it
in the stone okay you set it and what
you're doing is you're setting Eric
Evans has a lovely phrase he says you
bake in your ignorance at the point when
you want to make anything at a point
when you design anything you're baking
in your ignorance and so my automated
build is what I thought was a good idea
when I alternated it and based on the
knowledge I had of the build when I
automated it which may have been great
but the world moves on okay and so I
think it's really healthy to every now
and then delete your build or at least
every now and then go back to from a
command line and sources get something
into an environment and bow through all
of the stages of doing that because you
get to challenge it so what you lose
with an automated build is the ability
to apply a human mind to a problem and
ask if you still have if the premise is
still the same are the assumptions still
the same is the context still the same
has the world moved on to an extent
where this build is pointless
there's an interesting phenomenon that
happens and I've only seen it once I
suspect it might happen elsewhere but I
was one of my first Java gigs or so yeah
yeah Java gigs at ThoughtWorks I was it
thought works for that 2002 to about
2009 really good times and early on
there for about 2003 I was working at a
insurance firm and they wanted someone
to come in as a Java guy to help them
with their with their Java rat and I
went into the cadet Java rep and it was
a it was a great little app really
simple there were really simple by j2ee
standards it was a very vanilla j2ee
thing so it had JSP and servlets and
enterprise javabeans well no but
basically it couldn't have been more of
a vanilla application you compiled it up
you had a wire file some beans and you
put them into an ear file and it
deployed and that was the whole story
and they were getting into all sorts of
problems because it took them really
really complicated deployment so I
looked at their really really
complicated deployment and I'm not
making this up
there was a a bash bash bash batch
script whereas a bash script that was
wrapping acorn shell script that was
wrapping a make file that was wrapping
an ant build script which was shelling
out to acorn shell script which was
calling a makefile that's how they built
their software okay that's not how sane
people do anything and what that tells
me that that's that's not that's not
even archeology that's anthropology I
can tell you the exact sequence of
events that happened and it goes like
this
once upon a time there was a consultant
that new ant and the consultant came in
and the consultant left next day another
consultant came in that didn't know ant
but new shell scripting so they wrapped
the ant thing in a shell script so they
felt safer right repeat for make file
Korn shell script basket so there's like
seven layers of madness and so I just
removed the seven layers of madness and
were a very small ant build that said
build me a jar or me a nail file deploy
it and suddenly they could build right
so the job wasn't a job
job the job the job was a build job
because on my first build monkey gigs it
was really good fun
so automated build we can hide our
ignorant in an automated build and the
more layers of indirection we have the
more ignorance is hiding we don't know
what we don't know so we assume that you
know of course you want to make the
build literally nearly everybody's hand
went up and I said isn't automated build
better an automated build is different
okay an automated build gives you quite
a lot but you trade off quite a lot and
if you're not regularly challenging the
premise of that build and even seen oh
man I'll tell you what 10 years ago 11
years ago 2005-2006 I was working in a
build team at ThoughtWorks it was I
think is the best build team maybe one
of the best foot teams there has ever
been
let alone that I ever worked in it was
so much fun we had just humble there we
had Chris Reid there we had Julian
Simpson there at the build doctor I was
leading the team so I hired Jess humble
mm-hmm I've made worse decisions than
that and we were having a blast and we
were having to make all this stuff up
right we were having to kind of figure
out all these things and put them
together with gaffer tape
and now you know how she caught has
these incredible tools and everything's
written in go and I've got cloud and
I've got I know terraforming I've got
just cool stuff that makes all of that
so much easier I would love to have
those problems again now because they
just they just go away so yeah so don't
assume that the world isn't leaving as
particularly in the world of build and
deployment the world is moving so
quickly that the build that you had
working fine a month ago is probably
redundant now okay so we make these
assumptions what else automated or
manual testing he thinks automated
testing is better oh we're getting a
little bit more nervous now right so who
thinks manual testing is better few
hands I don't really know how to answer
the question okay they serve a different
purpose what I find interesting is this
and I had a rant about this recently at
a bdd event in London um almost all of
the agile literature about testing isn't
from the lens of a tester it's from the
lens of programmers thinking about
testing so if you're a programmer
thinking about
thing what you're thinking is I wonder
how much of this I can automate right if
you're a tester thinking about testing
you're thinking this will be a disaster
if I don't get involved okay they have
come from very different worldviews and
so like to a tester the axis of
automated versus manual is probably one
of the least interesting yeah I think
about risk I think about impact and
likelihood and I think about different
stakeholders and I think about security
and compliance and availability and
support ability and operations and all
of those things and you are thinking can
automate that right it's just we have
this very one-dimensional view of the
world of testing so there's a there's a
kind of testing you know we used to say
always say said I will in any any tester
who's working off a script okay we
should probably automate that but here's
the thing I run a script and the script
tells me of the if the test passes okay
if I have a programmer tester working
the way through a script I think of it
like a like a security guard will come
out of building at night he's like
walking around and they walk around and
they do the same circuit every night and
why are they doing that circuit are they
doing that circuit because the carpet
needs of walking on now if we don't walk
on the carpet it just gets up and went
off we've got to keep it got to keep it
walked on now why am i what am i doing
what am i doing as a security person I'm
looking for unusual things okay I'm
looking for things that aren't none of
those balloons weren't a yesterday I'm
pretty sure those balloons at you so how
do I know if something is unusual I know
what usual looks like okay if I know
what usual looks like I can be primed to
say unusual tests aren't very good at
that tests will tell you what you expect
to see because you as the programmer
with your confirmation bias and your
attribution bias and all those other
cognitive biases you tell it what to see
yet doesn't a test won't say to you hmm
you know since you change the layout
it's all looking a bit crunched together
now and it's really difficult to read
because a test won't go
difficult to read the test will go yes
you have value 17 on line 3 then we're
okay and so automated test will tell you
stuff you already know manual tests
might tell you things you don't know
okay so for instance I might have a
validation test automated test it tells
me that a password field is is invalid
because it allows us more than 30
characters and the limits 30 characters
real story one of my favorite testers a
lady called gitanjali and she she
entered a password into a password field
and it was more than 30 characters and
she went how much more copy paste copy
paste copy paste boom the dog she
submitted was this if you enter more
than 30 thousand characters in the
password field the application crashes
right I want her testing my stuff she
what looks like to a programmer looks
like a validation error she's made it a
security exploit okay she's just downed
my server because of a password field
right that's testing yeah so what about
test driven or test after he writes
tests before they write code here we go
you're all going to test heaven yeah
TDD heaven who writes their tests after
I come and check I like in 30% of you
actually write tests I reckon the rest
of you go my boss might see this and the
playback right but that's not the only
story right because it could be test
first test first is different from
test-driven test first is this is I'm
gonna write all of the tests ahead of
doing any of the programming so it's
like I'm going to write the whole
specification as tests test-driven is an
emergent process
I write the example for the next piece
of code then I'll write the code then
the next example and it's generative
it's emergent whereas test first is and
then write all of the tests which
essentially let me help my journey and
then I'm gonna or test whatever right a
lot of people are do you know what
actually we can get a bit obsessive
about this yeah we can get a little bit
kind of you know testing as gods right
so test whenever test
when you believe it's appropriate to do
testing test automation and I love one
of my favorite dynamics is when you pair
programmers up with testers on it that's
a really powerful model because they
think differently so the program is
thinking about what they're going to
build and the tester is being everybody
else the tester is being everybody who
isn't there and they're going well okay
from a functional correctness
perspective have we thought about this
from a security perspective from an
availability perspective from a and so
on they're going through all of the
different stakeholders and they're going
what would so-and-so think who isn't
here yes they're looking out for us
which is very good so okay so I want to
describe a pattern to you briefly and
development pattern I use called spiked
and stabilized so the idea was for ICANN
stabilizes this does anyone know who
knows what a spike is but your hands are
you know want to spike it so that's
about either about 20% of you not as
many as not as many as used to it's
almost fallen out of date so it's a term
from extreme programming and the IDE the
metaphor is this is you've got a I want
to sort of maybe get through a lump of
wood okay and I'm gonna try and make it
joint through some wood and so what I do
just initially to figure out how hard
the wood is and how deep the wood is I
just get a spike and I slam it through a
hammer it through and it's all splinters
coming off every way it's not pretty but
it's gonna tell me stuff about the wood
okay so that's a spike so the idea with
a spike is it's an experiment in code
there's designed to teach me something
so what are the rules with a spike
someone tell me what do I have to do in
a spike like an Ikea I need to maybe
check all the different liners yep
that's true what else I can hard code
anything I like right I have to throw it
away the rules say you throw these throw
it away
okay if you in otherwise they throw you
out the agile yeah so so that's a spike
now so the rules for writing a spike
because I'm never gonna release it
they're different from the rules for
writing a real code and so like with
production code I have to say I have
enough tests and I have test coverage
and I'm pair programming and code
reviews spike do you like that sounds to
me like an option that sounds to me like
a decision I made before I started doing
any development I said this will be
production code or this will be a spike
that's a better decision so typically
with options or decisions what I want to
do is defer that decision until I've got
good information well right now I've got
no code I haven't started and I'm about
to make that decision that seems to me
like we're missing an opportunity so
what I do is this is all of my code I
treat all of my code like a spike okay
so um so why are we doing TDD
what's the point of TDD quick feedback
okay so it means that I get feedback and
yet that's true well now the thing is I
can sketch out code I can spike code
probably I can spike half a dozen ideas
in the time it would take me to TDD one
of them right so TDD is going to give me
a really nice design at least localized
really nice design and a lot of
confidence and spiking is just sketching
in code yeah so what's the opportunity
cost of TDD so opportunity cost is one
of the other things I could be doing
everything else I could have been doing
while I were writing those tests for
that code so what I could have been
doing is sketching out several different
versions of this thing so spike and
stabilizes this it says write code and
get it in production as quickly as you
can because that is going to give you
real feedback okay now obviously don't
be irresponsible kids right this isn't
hack and slash and put it into
production there's a minimum bar for
staff but that minimum bar is way lower
than something that's going to be
long-lived and robust and all of those
things okay so I can get something into
productions that I have reasonable
confidence in it doesn't need to be
pretty and shiny yet okay so what I'm
trading off here is feedback from defect
feedback from assumptions in my test
versus feedback from real people
okay so TDD is a good way to get to a
design that the feedback from the tests
tells me is a suitable solution what it
doesn't do is tell me if anyone cares
yet because you don't have released it
I'm still TV being it
right getting it in front of people
tells me whether this code is going to
be useful and so what I then do is I
then make a pixie promise I promise
promise promise that I will go back and
harden the code I will go back and make
it robust but I decide to do that based
on whether anyone cares and the code but
people don't use our instrument the
coding if no one's using it guess what I
kill it
I delete it okay and what ends up and
then if it's if it's if it turns out
people are using it then I start writing
I do I go back and pay my dues I go back
up write my tests and I go back and do
my documentation and here's a dirty
secret so luckily there's only about 800
people in this room and a camera so she
tell no one okay
is this if you take code and you start
writing tests for it what happens is
this is we're going that horrible ugly
thing that we had with the F and the
while and the nested whatever and we
want to write a test for that we're now
we're going to pull them out probably
into its own method and actually now
we've done that before we want to put it
into its own class and give it a decent
name and now we can write as you start
making code the right shape to write
tests for it it starts looking a lot
like you test-drive it in the first
place you end up with small classes and
small methods and good names and
consistent things I call this
test-driven testing okay so what we're
doing is is it looks a lot like you keep
on accidentally getting bull's-eyes but
what you're really doing is you're
firing the arrow and then you're going
to paint in the target around it okay so
do you know what you know that Dan he
only ever seems to write tests for the
code that ends up lasting I did know
he's just maybe lucky but maybe he's not
maybe he's measuring and maybe he's
deciding that only the code that
warrants it only the code that is
valuable ends up becoming robust so we
have this and we're investing code based
on evidence that's the choice we make we
say rather than saying all code of
production quality is some massive high
bar we say getting goudi enough to get
out there to get some feedback on it if
it's any good then we will go back and
we'll pay the piper now getting this
past management can be difficult tricky
okay some people get really nervous
about putting air quotes
I'll code into production so we need to
think about the risks around that and a
lot of people don't like the idea of you
going back and doing tidying up when
there's this big pile of features to
deliver yeah and so part of the way I
communicate that is I say look it would
have taken us longer to do it correctly
the first time for all of the features
okay so what we're doing is we're
getting only access to a feature but the
cost of that the payoff of that is that
we're going to have to harden it later
and so that then becomes a long going so
the trust relationship there's no magic
cure for this but something to bear in
mind okay so let's take a look at
trade-offs is architecture then so here
is a fun one monoliths or components
right microservices he thinks that
components are better or we're was a bit
nervous now who thinks monoliths are
better three hands went up here's a fun
thing right so people talk about
component architecture I go and Greg
young came over this morning I'm going
to say it again now Simon Browns there's
a lovely quote actually has a slightly
different quite I'm going to use he says
if you can't build a single monolith
what makes you think you can build a
whole load of tiny little monoliths
right I think Simon Brown gets misquoted
a lot because he has some lovely lovely
quotes about this it Martin Thompson he
does a lot of low latency stuff in Java
and he says once you've learned to use
one thread properly you can have some
more which is one of my favorite
comments about concurrency I think that
is gorgeous right once you've learned to
use one thread properly you're allowed
to have some more morning there's four
components again there's trade-offs
where they monolith there is a single
deplorable item there's a single
deployable artifact it's easy to run
it's easy to monitor it's easy to see
what's going on as soon as I've got
components I have distributed systems
the first rule of distributed systems is
don't you should hear a lot of
repetition at a conference like this
because there are I would say there's
probably a limited number of really good
ideas for building software and as long
as a bunch of people keep repeating them
some of them all land right
try not to distribute systems unless you
need a distributed system
and certainly even if you're going to go
to component-based system my advice
certainly the thing I do start with one
thing start with a single thing and
build that single thing until it no
longer fits in your head okay once it no
longer fits in your head now you're in a
situation where you can start thinking
right I need to make it into several
pieces now the point then is to have a
story have a vision that what your
architecture is going to grow into so if
I know that I'm going to build a system
of components I'm already thinking about
how are they gonna heart be and how
they're gonna monitor and how they're
gonna phone home and all those kind of
things I'm already thinking about those
things and so my single model if it
starts off and it goes I've only got one
heartbeat in here I am but I already
have an idea about how I'm going to grow
into a distributed system that shouldn't
be a surprise but it shouldn't be where
I start either and I've seen teams that
start with like how we're going to model
our event they wrote model their events
and and our event sources and their
weave model our components now we've got
and they start with maybe a dozen
different little pieces and they haven't
deployed anything yet and I'm thinking
you guys are in for a world of fun right
you have so many moving parts and so
little idea of how any of this works
yeah start with a really simple even if
you're going to have multiple components
start with them in the same binary all
right start with them in the same code
so you know 0 and Q allows me to have a
really really simple message passing
actor based thing or vertex in Java or
you know echo or any of these like
simple messaging type things activates
things they allow me to model components
but I don't necessarily need to be
distributed so think about what we're
trading off when the monolith emerges
components I'm getting enormous enormous
amounts of complexity so those
components have better down well be
worth it yeah now the flip side of that
is this in within a single component if
I have worked with in a single monolith
rather if I have one rogue piece of code
that has a memory leak that has the
potential to take down the entire
process because that's how memory leaks
work right and so that means that you've
now got this weakest link problem which
is that the entire process is at the
mercy of the weakest part of that whole
application if I design something with
components I can start to reason about
resilience and I can reason about scale
but until you have that problem I
promise you it's a really hard thing to
reason about serverless is fun survey
list doesn't mean serverless kids
it means it's running on someone else's
server okay
server list so that I love this idea of
lambdas because now so what we used to
do we used to buy it in and then you buy
a server and put in a data center and
let me put stuff on it and we're paying
it's called capex and then we decided
well let's rent someone else's service
so now we had virtual machines and then
we said well now let's rent a slice of
someone else's service so now we had
containers and hypervisors and now we're
saying well now let's rent her function
cool okay what we're forgetting is the
thing that happened before we used to
buy servers and put them in data centers
which is called a mainframe and on a
mainframe but really on a mainframe is
per CPU second okay what we now have is
the mainframe okay there's a wonderful
quote from I believe it's the other late
50s or early 60s where the chief
executive of IBM said the world will
never need more than five or six
computers has anyone ever seen that
quote and ever went there we have
billions of connected devices right in
the world and they're connected to
Amazon Google Asia IBM oh wait there's
probably only about five or six
computers maybe he was just half a
century ahead of his time
right what's old is new yeah okay well
we've got the cloud and I'm just going
that's client-server that's a mainframe
and so what I have in my pocket is I
have a quad-core supercomputer with more
physical memory on it than the first
server farm I ever ran in my twenties
and I use it as a very shiny screen to a
bunch of other people's supercomputers
it's a dumb terminal it just needs PF
keys and I'm feel like I'm back in
Kansas right
so yeah so what are we trading off there
objects are functions let's start the
religious wars our objects better who
think objects are better there's now a
two brave hands over that he thinks
functions are better okay here's a fun
fact or a fun observation at least the
vast majority of code I've read in 25
years I'm going to guess the vast
majority of code you guys will ever
write does this get some data transforms
it emits some data and that's for all
the bugs up okay and what's fun is this
in a functional language the way you
code that is you go get some data
transform it in its and data and an
object-oriented language you say hang on
a sec allocate some memory set up a
vtable call in an initializer function
for my from waive reading object which
have course is an object hierarchy so
now it has to also call recursively
memory allocations and set up the tables
that call initializer functions all the
way down until it's ready - okay -
thanks but I can't just process the data
because now I need to allocate some
memory set up of a table and then
coalitional eyes a function for my value
objects recursively that are then okay
now I can get my data into a value
object right so now I'm ready to wait a
minute
transform a new Transformer allocate
some memory you see where this is going
right and we make this unbelievably hard
for ourselves though object-oriented
languages yeah functional guys are like
get some data transform it in with some
data I'm off to the pub they finished
hours ago if anyone has written any
closure my experience of writing closure
is this you write I write closure and
then I realize that there's something in
the core libraries that goes good and I
realize there's something else in the
core libraries that goes couldn't I do
that about seven or eight times I don't
up with like the one line I should have
written right that's my entire
experience of writing closure again and
again is I I find it hard to think
simple enough to do functional
programming functional programming is
far far simpler than object-oriented
programming there's less stuff and as a
career
a person I find it incredibly hard to
think that simple right so we've created
this enormous complexity around
ourselves there are some cases in which
designing modeling with objects is a
good idea as Greg said this morning Alan
Kay's description of objects is little
computers passing messages okay which is
what we call micro services now
amazingly these little computers policy
messages we stuff that up completely
yeah so we've some objects equals
entities and then we get all that rot
that's a whole nother talk synchronous
or asynchronous which is better doing
synchronous is better for hands who work
in banks right he thinks ie synchronous
is better
lots of several more hands and again it
depends yeah
in most cases though here's the thing I
can build asynchronous I can build an
asynchronous no wait let me get it right
I can build a synchronous API on top of
an asynchronous API easily okay
the converse is not true all right so
we're gonna a synchronous API you call
my synchronous API can buy a layer over
that that says right thanks on a block
you I'm gonna add waiting for this guy
to come back there we go now you can
carry on so that's a really easy bit of
code to write the other stuff bit harder
okay so synchronous or asynchronous
asynchronous means that I can carry on
doing other things
okay synchronous means that if anywhere
in that pipe is blocked all of us are
blocked okay
this is generally poor if you have this
in a distributed context it is
absolutely dreadful
right so and in fact HTTP has response
codes that are designed for asynchronous
processing so as well as 200 okay you
have a accepted accept it says you can
carry on doing what you want I'll let
you know when we're done yeah so oh okay
threads were single event loops any
JavaScript people yeah ask someone else
what our thread is okay
so threads threads or event loops then
so what do we think do you think threads
are better as a probe as a concurrency
programming model or single event loop
turn-based processing does anyone not
know what I mean by an event loop I just
don't want to ask
okay so event loop is like this is so
you ever saw heroes that the TV show
heroes and there was is one hero called
hero little Japanese guy and he could
freeze time was his superpower and so
what happened is here the bad is real
fighty mm and it's freeze time and it
runs through all the bad guys they take
all the buns off them and all that and
then it's start time again okay that's
single event loop processing so the idea
is that you can have mutable state and
you know that when it's your turn no one
else is running well no one logically is
running so you can mute a state and muck
around with things and it's really easy
to reason about but the idea is then you
hand the console back you say well I'm
done and it's the next functions turn
that's turn based processing threads is
where you have threads and locks and and
joins and semaphores and all kinds of
crazy low-level concurrency semantics
okay
is anyone in the room Doug Lee no is
anyone in the room Brian gets no then
don't use threads okay because you don't
understand them because there are only
two people on the planet who do
understand them and I just named them
both okay and it's no coincidence that
all of their concurrency stuff in dotnet
came directly from the concurrency stuff
in Java because they're very small
people try to event loops or oh hang on
a minute because there's loads of other
concurrency models okay who knows the
difference between X's and CSP shame on
you there's a roomful of programmers and
no one put their hands up that is
shocking you should all have half a
dozen concurrency models in your back
pocket because it means that when you
look at a situation you have a number of
options to choose from and as you know I
mean I can be a little bit but this is
serious this is serious stuff if you're
even contemplating distributed computing
which most computing is now if you're
even contemplating concurrency which you
get for unfortunately for free
with any distributed system you
absolutely need to understand Tony
whores concurrent sequential processes
actors threads event libs very briefly
in the actor model you name the
receivers and in CSP you name the pipes
so in other words I connect things up
with CSP I connect things up at the
beginning I connect things up with
channels and they're passing messages
along channels and then I say go okay so
it tends to be like if I know what the
shapes gonna be I use I use pipes and
channels so anyways using go-go routines
and channels in go they are CSP actors
are I don't know where the other end
point is but I know how to get there
some actors have names so you have a
named mailbox and I send a message or an
event to a mailbox and it gets delivered
to them at the infrastructure delivers
it to a mailbox which is great if I have
dynamic systems so systems where I have
maybe actors appearing disappearing
being replaced that kind of thing then
actor model is a better programming
model in general actor model is harder
to reason about because of that Dynamis
'ti i think i just made up a word let
dynamic this CSP is easier to reason
about but is a bit less flexible don't
learn this stuff this is important
nothing everything old is new right was
this what are we saying the old new
things they're actors and CSP are some
of the oldest new things so another
quick pattern then sure software
half-life so the idea of this is this is
about deleting code okay so I want to be
able to delete code fearlessly the
reason I wanna be able to delete code is
this most most of our lives are spent
maintaining code most of the code we're
maintaining is older code most of that
code got older by accident it got older
because time passes in that direction
okay it got older because no one was
looking
yeah and so I'm fine with new code
because someone in the room wrote it and
so we can find out what it does
I'm fine with old code that is very
stable well documented maybe has
tutorials baby has wiki pages
is easy to navigate is well architected
all that stuff what terrifies me is the
thing in the middle right the code no
one knows about
and unfortunately that most code so I I
suggested this term a few years ago sure
that software half-life which is how
long imagine is how long would you have
to walk away for so that when you came
back half the code you're working on has
changed okay half the code you're
working on has been deleted rewritten
changed in some way that it's different
from it was before and so for many
organizations in one of my classes
someone came into their class of that
morning he'd been working on some code
in a bank that was written in 1967
here's his idea he reckoned that the
half-life for that code is probably
millennia and he was fairly confident
his grandchildren would be working on
the same code base I suspect what will
they happen will be there will be some
COBOL AI bots that will be maintaining
that code in about two generations time
okay so software half-life so try and
keep the software half-life short and
the way to keep the software half-life
short is to ruthlessly delete code where
you can replace it with simpler code and
we usually we think of code as an asset
and a valuable thing that we shouldn't
delete code is a liability all code is
cost all code is a liability so I want
to be able to delete code I won't go
with a short software half-life there
was a lovely article recently about the
history of automated testing at Google
and there was one it was just a
throwaway comment in there what is the
half-life of Google's code in other
words if you think of the entire Google
estate so search which is one of the
largest C++ code bases in the world ads
which is one of the largest Java code
bases in the world that Gmail all of the
Google estate write is in one massive is
called a mono repo one massive
repository with all of Google's code in
it how often does half of that code get
changed every month every month half the
code in Google changes exploded that's
insane this is tens of thousands of
people crawling away
some of the most complicated code ever
written and half of it changes every
month that is a heck of a lot of code
governance and code guardianship and
custodianship and automated testing and
tooling and stuff to make that possible
that's insane
that of the whole article that one
statistic left out of me so shorts off
for half-life then in order to make this
true I need small separate components
okay I need to be able to because if I
can't reason at a component level I
can't possibly think about what it means
to replace code each component does
exactly one thing okay it may and this
is like single responsibility it's more
than it fits in my head okay so it has a
hard shell on a soft center like a good
chocolate so well that means it has a
clearly defined API and the messages
then the API define the protocol for
that component and I can replace it with
another component that does the same
thing lovely quote this is I got this
from that price he's one of the
co-authors of growing object-oriented
software I don't believe it's his
originally but I think it's a wonderful
quote the message is the API or in
domain driven design circles I guess the
event is the API so in other words if we
think about the messages or the events
flowing through the system and the
protocols for those events and you know
I'm a component I receive this event and
I amid these events under these
conditions that entirely defines the
behavior of the system so I can entirely
replace a component with another
component that has the same messages
through the same API under the same
situations and I'm good and now I have
an enormous amount of replace ability
options remember I'm trying to create
options for myself and particularly what
I want now is it allows me to experiment
safely okay so I have identified
boundaries for experimentation and
that's really important because once
I've got a safe boundary for
experimentation it means I could start a
reason about impacts and impacts
analysis and we through impact analysis
away as a practice when we started
running all of our tests all at the time
which sounds great except when it isn't
so ahaha yeah
if overbill architecture little sidebar
here so who thinks DRI is a good thing
don't repeat yourself don't repeat
yourself so I did that right who tries a
good thing okay what are we trading
quite a few hands went up there
what are we trading off what are we
trading off with dry you don't repeat
itself thank you
lots of people shouted coupling one
person shouted simplicity okay
the trade off we don't repeat yourself
is this I can be dry or I can be
decoupled but I can't be both yeah so
what I mean by that is this I've got two
components and they do a similar thing
and so i factor that similar thing into
a library because that's what I do
because DRI says don't repeat yourself
refactor mercilessly and I do that and
now suddenly these two things are
coupled
I can't they're not in they're no longer
independently deployable independently
evolvable yeah so dry or decoupled mmm
suddenly it's no longer such an obvious
trade-off dry is good what decoupled is
good I heard that right a low coupling
high cohesion I don't actually know what
those words mean but I've heard them so
many times they must be true right and
so if I want a proper decoupled
component-based architecture I need to
think about separating out components I
need to think about being okay with some
duplication funny enough evolution when
we talk about an overall architecture
evolution is anything but dry how does
how do creatures evolve copy paste copy
paste copy paste copy paste copy all
mutation copy paste couple rooms I can
fly oh my god right so we the whole of
the human race all life on Earth has
been a insanely successful experiment in
copying and pasting where people talk
about list being God's true language I
reckon Birds true language of probably
vb6
right because basically it's just masses
of copy and pasting and and you look
inside DNA's huge amounts of redundant
staff and a little slash slash don't
know what this tells but leave it and
slash slash works on my living entity
you know deploy into production I'll be
fine where DNA doesn't refactor DNA
doesn't go those two things look similar
I'll pull those out and put them on the
arm yeah we'll have a little arm know
the code to build our armies in there
twice because look cuz what on each side
yeah so so that's what we do at DNA
doesn't reflect it if we're talking
about evolvable architectures then dry
is we can obey we can get obsessive
about these things so just be aware of
this here's a pattern and this is this
is kind of how I think about dry it so
ginger cake is the pan and the story is
starts like this it says some and this
is a story that I heard and I can't find
out who told me this story and it's
wonderful but it's absolutely true so if
someone's I think it's their
mother-in-law is a baker she bakes cakes
as well she's a fantastic cook but among
other things that she cooks she baked
cakes and she has a box with little
index cards in with recipes in and so
she has oh she has a this is a chocolate
cake recipe and I actually brought this
recipe off the internet so do go ahead
and make it and let me know if it's any
good so you know she looks quite nice no
it's not all the right things in it and
it's oh it's not here's your ingredients
and then is your is your method to build
out a chocolate cake and anyway so a
little bit further on in the Box there
is another card and it's got the recipe
for a ginger cake in it like chocolate
cake but with ginger there's anyone here
baked so they'll have baked cakes a few
hands went up yeah right chocolate is
almost entirely unlike ginger chocolate
is hard at room temperature it then
melts event caramelizes and then it
burns
ginger
gingerly at room temperature and squishy
and a bit sticky when you heat it it's
still gingerly and a bit sticky you
could put it in a furnace ginger will
survive a nuclear blast there ginger and
cockroaches so that's a nice salad right
there a ginger cockroach supreme right
ginger is weird and so you can't just
swap in ginger what this recipe requires
is this it requires that you are
intimate with the chocolate cake recipe
you know it really deeply you also
really understand the nature of
chocolate as a cooking ingredient you
also know the same about ginger so you
know how to substitute ginger for
chocolate in a recipe there's a huge
amount of information hidden in this
okay so ginger cake is a pattern is this
I'm sitting there pairing with someone
and this history story and we're going
to write another web component and it's
similar to a previous web component and
so I said alright it's similar to this
component he said so it is and so then
what should happen is this what should
happen is we say well yes let's take
these bits out that are in common factor
them into a shared piece and no he
didn't do that he just went copy paste
and I was like that's illegal they may
throw you out the agile for that that's
that's not allowed and then what he did
was this he just sort of furiously
deleting it just to excite the skeleton
and then he just started and we had
something up and running in no time
how high actually that was pretty cool I
shouldn't say this I shouldn't feel like
this it feels dirty but I like it right
and and so and so now we had this and
then what I've realized since is
essentially there are two kinds of
ginger cakes well there's two there's
two there's two models of ginger cake
there's a what I call a structural
ginger cake and a behavioral ginger cake
so a structural ginger cake is where you
steel the shape of something and then
rip out the guts and put your new stuff
in and behavioral change a cake is the
opposite it's where you take some
behavior from somewhere but put it in a
different context
and so what I found with these is that's
ok it's ok to have duplication that's
thing where they go or if you have
duplication it's gonna be really bad
well then they say things like if you
have a bug in one place you'll have a
bug in the other yeah who thinks that's
true all of its scared of Dan now we
live in a hands-off anymore so here's a
real example say oK we've got this this
thing and it renders some stuff on a
screen and look if you render it in
Danish it doesn't fit on the screen
because well the Danish words of
different lengths and blah and so that's
a bug and that's true because we're been
doing this screen in Denmark the same
code exists somewhere else that will
never ever be rendered in Denmark is it
a bug is it a bug in the other place
it's like what are those n in koenz
isn't it if a bug occurs in some code
it's a it's a proto bug it's a potential
defect right but it's not actually wrong
there's nothing actually wrong with it
yeah so I had this I was I just had to
eat my own dog food or ginger cake in
this case and I was building a little
Python it was a ripoff of Heroku back in
the day and so I wanted to have a little
thing where I could deploy applications
into like agents and there was a master
node that you talk to and they both had
some files stuff they needed to do and I
was about to factor out the faster all
right node you know I'm gonna duplicate
it and see what happens and it turned
out that the agent pieces their file
access had to be really fast and didn't
have to be that reliable because if you
know the agent dies you just start up
another one right whereas and the others
and the master node the the the file
access had to be very reliable and
atomic and secure and and it didn't
matter if it was a bit of slower and so
they evolved in completely different
like different ecological niches right
and I know I looked at the code I was
thinking if I try to write one bit of
file handling stuff that had been both
secure and robust and fast I would have
ended up not not achieving either so I
let both sides evolve differently and
ended up in different places so don't be
afraid to copy and paste
oh no don't tweet that dan said it's ok
to copy and paste no it's ok to coffee
and pay
if you designed the cake in the first
place
you are intimate with that recipe taking
something you found on stackoverflow and
shoving it in your code is not ginger
cake it's plagiarism okay especially if
you don't reference it with a URL so
okay deployment finally deployment the
trade-offs what are we what are we
trading off with deployment let's see if
you're let's see if you're getting the
hang of it yet automated or manual
deployments he thinks automated
deployment is best still like a third of
you put your hands up whereas pull stack
he will tell you I hope he will tell you
right if you don't know what your path
to production looks like you have no
right automating it okay so my my my
golden rule with automation I used to be
able to mate all the things I used to be
automation was my middle name but it and
I'm running out of space on passport so
I changed it but automation sells big
into automation here's my rules for
automation or at least my guidelines for
automation automate something when it is
boring okay that's it well to my son
it's boring boring means there's boring
means you've done it lots of times okay
which means you understand it okay you
don't get to automate it until you
understand it you don't understand it
until you've done lots of times
boring also means that it keeps on being
the same every time okay if each time
you do it it's a little bit different
there's new surprises it's not boring
yet it's surprising okay and if we try
and automate something as surprising it
will fail because it doesn't know how to
handle surprises in those how to handle
boring
so only bored so once something becomes
boring are you've done it a load of
times manually and it hasn't changed
it's a candidate it might be worth
automating now still not go ahead and
automate it says it might be worth
automating because again opportunity
cost well all the other things you could
have been doing while you're automating
that I had a team I was working with
once back in Salt Works and they're
working for a client and I got brought
in after about I know five weeks or
something and this is a really good team
I knew them and
very small development developers and
the client was really unhappy and so
that's really odd I thought works pretty
good at this stuff nobody very happy
clients and so a bunch of weeks in and
as I said what's going on and they said
that they haven't done anything as I
find that hard to believe right a super
smart guy event baby and so I went to
meet them and spent time and and so they
said what they showed me was a board
production line right I was you know I
was a guy that wrote the more co-wrote
the bill production line paper so I'm
like the build guys so yeah sure sure
and they showed me this thing it was a
thing of beauty
Oh Manny had dashboards it was
instrumented it was automated I had Ryuu
main it and so I asked the question
what's been through this what do you
mean well what have you put through this
pipeline so what have you actually
delivered to the client or nothing yet
no we've been building this I was like
sorry because what that looks like is
week one delivered nothing week to
deliver nothing week three week week for
week five get someone in the end of it
cross now yeah and and they didn't
realize that what the client was seeing
was zero throughput and they were going
for that satchel is it hmm I think I
preferred the other thing at least we
had meetings with the other thing
right and so and so this happens and so
ship something always be shipping
something yeah and so what I would like
to start it with is just manually
there's a lovely more they call the
concierge model so imagine you're gonna
manually kind of take these things
forward so you're gonna be okay so I'm
gonna take this building I'm gonna
Shepherd it into production either okay
great lovely and that's gonna get boring
pretty fast but once it gets boring I
get to automate it okay so vertical or
horizontal scaling what do we think is
horizontal scaling better who thinks
horizontal scaling is better who thinks
it depends yes okay
they solve very different purposes yeah
they're designed for very different
purposes if I have very high
localization if the problem I'm solving
is very very localized
having so horizontal scaling is probably
not going to be the most enormous e
useful thing
if I necessarily have state all
different parts of my architecture and
some problems necessarily have state
smeared all over the place then again
horizontal scaling introduces all kinds
of locality problems stickiness problems
all that kind of nonsense it becomes
really really hard to manage state and
to manage routing vertical scaling and
again if I have a full stack and I've
got lots and lots of those things that
can get really expensive if I have
asymmetric compute needs so if I've got
like lots of memory needs and hardly any
i/o needs and I'm getting lots and lots
of those I end up with massive wasted
resources so again this trade offs in
both managed to I want to unmanaged or
in-house cloud or on Prem has a court
now which is better which is better who
thinks they should put all this stuff in
the cloud no hands
so that means the sorry Amazon or I know
no customers here right who thinks they
should have all this stuff on Prem one
bank right he thinks maybe it depends
Hey right because the game is so
beautiful purposes and I can have cloud
cloud just means that I've commoditized
my infrastructure it doesn't mean it
doesn't necessarily say where or how or
with whom so I can commoditize my
internal infrastructure that's kind of
cool I can have my own as a service
internally I can use someone else's as a
service but then I may be so that the
entire Amazon pricing model is based on
bursts it's based on you shouldn't
really be using them all the time you
should be bursting into them for elastic
that's why it's called elastic all of
their things start with elastic if only
a digitalocean are great for just a
bunch of VMs or black space on someone
well we don't think that's Amazon let's
give Amazon some money and so and so we
don't think about where we're going to
play stuff where we're going to where
we're going to deploy our applications
how we're going to deploy them in-house
of course gives me a lot more control
over locality of data if I have customer
sensitive data or if I have legal
obligations or regulatory obligations to
not have data outside of my premises
where outside of my direct control that
can be a big deal
and so now we're also seeing hybrid
snacks where I use some and so virtual
or physical which is better ask anyone
doing low latency trading if there are K
on VMs right what you want is a server
that is connected that is physically
co-located at the trading exchange and
you want the cable the wire network okay
we're connecting it to the exchange to
be as short as possible you pay more for
racks that are physically closer to the
exchange then for racks that are further
away because speed of light because
that's how high-frequency trading works
yeah you cannot you'd be mad to run
high-frequency trading
algorithmic software on virtual
infrastructure no one does it is just as
it'd be a crazy thing to do but likewise
that requires a lot of detailed
knowledge of how you deploy and manage
on tin okay which is a itself a hard
problem I've got loads of good tooling
around that which is a hard problem
so finally last pattern then um
balancing skeleton so this is a direct
nod to Alistair Coburn and say he talked
about a walking skeleton and walking
skeletons like I saw a pattern that says
this it says when you first start
building something build out your entire
architecture but very very thin so you
can prove your architecture just prove
that the whole thing hangs together
sketch it out but it's just a skeleton
it's the backbone it's the thing you're
going to build the application on so a
dancing skeleton is similar but it says
this it says get something anything into
production or I get a hallow word into
production but a hollow word that looks
like the thing you're going to build
okay because that tells you two things
it tells you what the path to production
looks like and for a lot of people
that's always a surprise and it also
tells you how this thing acts and
behaves in a production environment and
you know what it won't be like on your
machine okay even if you're using docker
I refer you to an earlier comment about
networking right so you know if you're
deploying stuff there's something
anything into production
okay it needs to be full stack I want
the whole
occasion there well the whole all of the
pieces you're going to use even if
they're very thin and the point about it
is it has to have an interface and has
to have an API it has to have a ripple
that has to have a some kind of way I
can make it dance because if I can't
make it dance I can't see how it dances
in production so it's a dance let's go
to that when they put a little rubber
skeleton puppet things that does this
and so I want to see what it does
because if I do this and the arm falls
off right that's useful yeah or if I
start pressing the dance button and it
goes on this which it usually does
that's useful well if I press the dance
button on something else in production
goes oh hang on what happen there but
that again is a useful data point right
so get something anything into
production and so your motive here is
fire aim ready right it's the opposite
of what you'd think normally we go ready
aim fire ready is make sure it's done
aim yeah and then fire no fire get it
into production and then the aim use the
feedback from production to tell you
what you need to change and you iterate
on fire aim fire aim fire aim fire aim
fire and you get really good at that and
so that's now your iterative it's like
test-driven development but right the
way down the path yeah until eventually
you say yep we're going to declare
victory we're ready we're good so as
they say theory is only like practice in
theory okay in theory theory practice
the same thing in practice not so much
so what am I trying to say I mean let me
wrap up because I'm probably standing
between you guys and beer that seems to
be more a default position at the moment
when you know what you're trading off
you can make informed decisions every
time you make a decision you're making a
trade-off if you aren't aware that
you're making a trade-off you're still
making a trade-off but now you're making
it unaware of the trade-off you're
making if you are aware you can now
understand what it is you're trading off
there are no best practices there is no
right thing to do there are only ever a
portfolio of options of things you can
do and choices you can make and as
you're making those choices be a
you're making choices and you're saying
no to other choices when you automate
something you are choosing to lock in
your ignorance at that point when are
you going to review that if the answer
is I haven't thought about it yet think
about it yet yeah if I'm going to
replace human beings with machines
anywhere okay yes I'm gaining efficiency
and cost savings and time and reduced
errors and all that good stuff right
there's a lot on the plus side on the
negative side what am I losing from
having a human being involved in that
and how am I going to compensate for
that or how am i comfortable carrying
the cost of not compensating for that so
with that I say thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>