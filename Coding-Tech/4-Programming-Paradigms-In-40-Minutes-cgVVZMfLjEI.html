<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>4 Programming Paradigms In 40 Minutes | Coder Coacher - Coaching Coders</title><meta content="4 Programming Paradigms In 40 Minutes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>4 Programming Paradigms In 40 Minutes</b></h2><h5 class="post__date">2018-03-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cgVVZMfLjEI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this talk is based on a class I took
my freshman year of college we called it
CS 60 although the actual title was the
introduction to principles of computer
science and unlike a lot of CS majors
this course was very earlier the major
and it was a survey of all of computing
we did finite state automata we did
grammars we did prove ability and
complexity theory we did formal logic
but about 10 ish 12 ish weeks of the
course was dedicated to learning four
different programming languages each of
which represented a different paradigm
and solving the same problem in all of
them and solving some problems that were
designed for that language and I learned
a lot of stuff from this course more
than any other class I took in my major
this one made me the computer scientist
that I am and the biggest thing I took
through this class was abstraction when
I started this class I knew Java I knew
some visual basic and some basic but my
concepts of things like arrays and
conditionals was attached to the syntax
for those things I thought about them in
terms of their syntax and by forcing for
completely new languages three
completely new languages for languages
all in a very short period of time I was
able to move those concepts from being
attached to the syntax to actual
abstractions in my mind if you're a
philosophy person you know Plato's
allegory of the cave you kind of have an
idea of what I'm trying to get at here
the other thing I took was that I too
could be a polyglot I was always
impressed with people who knew a lot of
computer languages but when you learn
three new languages and nine weeks and
you're able to be productive with them
you realize that once you have the
concepts and the abstractions down the
syntax isn't really that hard and when
you're a polyglot you can point out the
similarities between languages concepts
like conditions and collections and
arithmetic and loading and storing
things from memory they show up over and
over again in different languages in
different ways and so understanding
those kind of conceptual level as
opposed to I use this syntax for arrays
is really hopeful and the other thing it
taught me was there are big differences
between programming languages and
different languages are good for
different things and I'm hoping that you
guys will take some of that out of this
45-minute crash course or I try to cover
what I learned in 18 weeks in 45 minutes
I hope but don't worry if you can't keep
up this is supposed to talk
ideas even though there's a lot of good
so when I took the class our primary
example was solving the puzzle towers of
Hanoi with the little rings and the pegs
you have to move the pile the tower from
one peg to the other explaining the
algorithm to do that and then explaining
it out in four different languages is
going to take more time than I have so
we're going to use something much
simpler I'm going to talk about change
hmm and by change I mean this kind of
change in each language I'm going to
show you how you would calculate the
amount of change you would get you could
give if you were a cashier working a
cash register
so everyone following let's dive
straight in we're gonna start with uh
where who'd be comps so we're gonna use
a broomie I color-coded in my slides
Ruby is of course right and we're gonna
start with something easy the code gets
harder as we go along it's just how it
is today so let's talk a little bit
about oo everything in Ruby is an object
everything false is an object false is a
singleton an instance of an object know
is an object your classes themselves are
instances of the object class not all
languages are this pure but the general
idea in oo is that most things I would
prefer all things are objects well
what's an object an object is a way of
encapsulating state and behavior state
is things like fields attributes
instance variables what you call them
varies a little depending on the
language and your particular background
and behavior is what you do with that
state things like methods most of our
languages the object is responsible for
modifying its own internal state in Ruby
we call this self so if I was an object
I could say self dot pets equals the
array Emma Nick and shy because those
are the names of my cats objects have to
interact with each other because you
know an object just sitting there by
itself is rather boring and the way they
do that in Ruby is their message passing
if I want to find out the length of an
array I send the message length to an
instance of an array object that object
calculates the length of its internal
state and then returns that length to me
so when I'm teaching stuff I normally
try to use my own examples but since
we're going super
today I'm going to try to use examples
that are canonical or commonplace in the
literature so that hopefully you can
kind of attach this to something you may
have seen before hopefully and one of
the most common examples 400 is the idea
of a bank account so I'm gonna build up
a bank account object
well objects are instances of classes so
class bank account bank accounts need to
have a balance of some sort and for a
lot of reasons it's a bad idea to allow
folks to monkey with my balance which is
my internal state so I'm gonna store
balance as an instance variable and I'm
gonna set it to zero when I initialize
the class or initialize the object note
I'm going to talk about money a lot
today and I'm always going to represent
money as an integer number of cents if
you are representing money as float in
any of your code come talk to me later
and I will teach you about why that is a
horrible idea so I'm gonna take a break
for IRB I can go bank account dot new
and get an account object back now I
know since I wrote the code that my
balance is zero but I can't actually see
it so let's write an Access err so I'm
gonna have an outer reader because I
don't want anyone outside to be able to
set the balance and that's gonna return
balance back to IRB now I can see my
balance it's zero so a bank account with
a balance of zero is pretty much useless
so I'm gonna add some ways to withdrawal
and deposit money so deposits going to
increase the balance deposit is a
message
it takes an amount and it adds that to
the balance withdraw is the opposite it
takes an amount and subtract that from
the balance and you can see from my IRB
break here that it works so I talked
about an object having both data and
methods before in this case the data is
the balance and the methods or the
behavior are the deposit withdrawal and
initialized and all of these methods
modify the internal state of the object
and my IRB process is communicating with
them by passing a message like deposit
with an amount and trusting that the
object will do the right thing with that
data in that message so some of the
strengths of oh it's really good at
modeling what we do in real life so I
have a chair
I can have a cure object it could have
an attribute color you could have
behavior hold me up those kinds of
things we think about the world through
concepts and ideas they're very closely
aligned with objects we don't think
about the world as the chairs color is
fundamentally separate from what it does
objects are also reusable a good way to
see this is think about the standard
library arrays are objects hashes are
object strings are objects and we all
were use them in all different ways
because the same types of concepts and
objects show up again and again and
again and the problems we're trying to
solve and this means I don't have to
implement a radon length over and over
and over
I think objects are easier to test I can
test an object in isolation and test
that it modifies its own behavior
correctly and then I can test the seams
between the objects when I'm testing my
holes my system as a whole so on to the
motivating example so I'm gonna do the
making change algorithm oo style
here's the code so this is like 28 point
font and I don't expect you to be able
to read it so we're gonna build this up
piece by piece so I have a class I'm
gonna make a class called cash register
because that's what I use to make change
my cash register has a cash drawer
that's the thing that slides out that
contains the money the drawer contains a
bunch of different denominations of
bills and coins
I have 20s tens fives and ones and then
I have quarters dimes nickels and
pennies if I was doing a more thorough
implementation I could have the amounts
of each that I have in addition to the
denomination here is the method that
makes the change and it's still kind of
small so let's build that up piece by
piece to here's the method signature
make change takes in amount owed this is
the amount that the customer owes the
store and it takes the amount the
customer gave the cashier which you'll
see frequently referred to as tendered
not tenderlove Aaron
uh so the first thing I need to do is I
need to figure out how much change I
have to give the customer and this is
gonna be the difference and to do that I
suggest ender and then I'm gonna
represent the bills and coins I need to
give the customer in the change array
this is gonna be the thing that tells
the cashier five fives three ones blah
blah blah the next thing is I need to
figure out which part of the drawer I'm
working in when I've seen people make
change a fair number of people start at
one end either the smallest or the
largest and move down the drawer and
grab the Crow period and then move to
the next slot in the next slot in the
next slide so I'm gonna do that exact
process with my array that is my drawer
and I'm gonna use I to index where I am
in that process
and you know it's a loop while I still
have changed to give the customer while
difference is greater than zero I'm
gonna loop through this thing so
expanding on the loop a little bit
here's the first part if the difference
the amount I still need to give the
customer is less than the current
denomination I'm looking at the current
slot in the drawer I'm looking at so
that would be the case where I have to
give the customer four dollars and fifty
cents and change and I'm currently
looking at the 20s I can't give them a
twenty so I need to increase my index
and set my denomination to the next
smallest thing now I'm making an
assumption throughout the entire talk
today that my change drawer is always
sorted largest to smallest if it isn't
none of these algorithms work and once
I've done that I can go back to the
start of a loop and try again so the
next part is now this is the case where
I'm giving 450 and change but the
current thing I'm looking at is a dollar
I'm going to say well that's not bigger
so I can use that one so I'm going to
add it to the list of change I'm giving
and then I'm going to subtract that
amount from the amount still owed to the
client or the customer and then I go
back to the top of loop and I keep going
through this and eventually I'm going to
have the change I need and this ends up
with this method so those of you who
really like Euro or like this is not
oh-oh and you are totally right this is
a really really bad problem for
demonstrating go up and that brings up
the point that different programming
languages are good for different things
but this is a fine problem for
demonstrating the other three paradigms
I'm going to talk about today so that's
why I used it this actually looks much
better as a functional program on to our
second burden I'm gonna use racket which
is a general-purpose programming
language in the Lisp family Lisp intern
if you have never heard of it is the
second-oldest multi-purpose high level
programming language lisp stands for
list processor the only language that is
older than Lisp is Fortran and racket
and lists are well suited to demonstrate
functional languages although both of
them are not limited to that paradigm
you can also use Ruby for functional
languages but I'm four languages 45
minutes that's what that was the promise
of the talk so an overview functional
languages are built of functions who
would have thought functions taken data
and output data I'm gonna focus today
entirely on pure functional programming
which means that my functions don't ever
store state and they don't ever mutate
the incoming data so if you give me an
array I will give you back a new array
it will not modify the one you gave me
so no bang methods if you're still in a
ruby mindset a nice thing about pure
functional style is the input only
depends the output only depends on the
input it doesn't depend on what came
before so I can do a bunch of stuff and
then give the same input and it will
always be the same thing history doesn't
matter at all and the really fundamental
thing of functional languages is that
data and procedures state and behavior
are separate unlike oo where they're
encapsulated together I'm hand waving a
bit here it's not actually entirely true
but for the purposes of this talk it is
true so for all the languages that
aren't Ruby I get to teach you syntax
the biggest thing you need to know about
this family languages and racket in
particular is that we're used to things
like in Ruby that use infix notation but
Lisp languages and racket use prefix
notation so to add 3 and 5 I use plus 3
5 and you're like well that's weird but
it's actually super useful because I can
do 1 times 2 times 3 using a new
one-time symbol which I couldn't do in
Ruby times 1 2 3 that multiplies all
those together I'm not limited to just
two arguments which you are within fix
notation and you're like well that's
completely impractical how can you do
multiple levels of it well the answer is
on the last line there
I'm multiplying three and five and
subtracting 6 from 10 and then I'm
adding the two results together and you
just use multiple levels of parentheses
and I really like this because the order
of operations is very very explicit so
math is not particularly interesting on
its own I need to be able to write my
own functions you declare a function by
putting the word define and then in
parenthesis the name of the function in
its argument lists the square function
takes one argument and I'm calling it N
and then after that I have the body of
the function in this case I'm
multiplying n times itself to call that
function I go parenthesis function name
argument square of 5 is 25
I of course need some way of doing
conditionals and I'm gonna use the
conditional from racket called cond
which is short for conditional and it
acts like Ruby's case statement so I
have a cond and then the first thing is
on the first line is I have a test and
then there's some stuff to do if that
test it's true and then I have a
different test and there's different
stuff and then there's an else and
there's more stuff very similar to the
case statement and here's a concrete
example this is calculating absolute
value of x if X is greater than zero
well the absolute value of that is going
to be itself so I return itself if X is
equal to zero well the absolute value of
zero is zero so I return zero in all
other cases I now know that X is a
negative number so I'm going to return
the negation of X to give me the
positive x okay the only other thing you
need to know is the lists as I said Lisp
lists processor lists this is a list I
represent it as a set of items separated
by spaces inside parentheses with a
little tick in front the tick is there
because otherwise I wouldn't know if
this is applying the function 1 to 2 or
3 or if this is a list 1 to 3 because
remember prefix notation this is not a
function call when you have lists I can
access the first thing in the list by
calling the car these names will come
back later I promise that gives me the
first thing in the list or I can get
quarter which gives me the rest of the
list you might also hear me to say to
say today head and tail I mean first and
rest in those cases or car and cutter
and I can make list by using cons in
this case I am causing the item 1 on to
the list 2 3 which gives me the list 1 2
3 some cigs ampuls here's factorial we
use recursion a lot in functional
languages so I have a cond if the item
I'm trying to get the factorial of is 1
or less I return one because the
factorial of 1 in the factorial of zero
are both 1 otherwise I multiply n by the
factorial of n minus 1 which recursively
will gives me the factorial Fibonacci
this will give me the nth Fibonacci
number so if n is less than or equal to
0 I return 0 if n is equal to 1 I return
1 otherwise I sum the N minus 1
Fibonacci number and the N minus tooth
Fibonacci number that's the definition
of Fibonacci so some of the strengths of
functional programming if I'm doing pure
functional programming and I'm not
modifying state at all I don't have to
worry about all of the stuff you have to
worry about with concurrency and
threading because we're not sharing
memory we're not having to lock tables
none of that stuff is even important
because nobody's modifying state
everything is just a read operation
that's really handy a lot of the time I
think that functional programs are
easier to test them some of the other
ones because state doesn't matter data
in data out especially pure functional
programs which means that the set up for
automated tests is just misses the data
I'm going to run it on I don't have to
set the state of an underlying object
first and because there's no state you
can also reuse this I can take code that
works in one program and throw it in
another program and I don't have to
worry about there being context around
in it that's required and I really like
that they're short functional programs
tend to be really short especially in
lisps a lot of people hate this but it
makes me happy so onto our motivating an
example here's the Chone code that makes
change in racket and I'm going to
actually slow down a little bit here
because I want to make sure that you
sort of understand this so here's the
function signature it is a function of
two arguments X is the amount of money I
need to make change for and de noms
denominations is the denominations of
bills and coins that are available in my
cash drawer
so now I have a conditional the first
case I want to check is if the amount
I'm trying to make is zero I don't owe
any change so I can return a list it is
empty because the list I'm returning is
what bills I need to pull out of the
cash drawer and what coins so how do you
make change for zero you give someone
nothing empty list the next thing I'm
gonna check is do I have any money in my
cash drawer if there are no
denominations
there's no bills or coins in my cash
drawer I can't make change so I'm gonna
return false so these last two cases are
the tricky ones so this is the case
where the amount I'm trying to make is
less than that first domination so this
is card octonaut card to Nam's is
getting the first element of the de noms
list which is the highest bill in the
cash drawer that I'm currently looking
at right now if that amount is less
sorry is greater than the amount of
money I'm trying to make I need to use
the rest of my cash drawer so if I'm
trying to make change for 450 with a 5
dollar bill I can't do that I need to
use the rest of my denominations to make
change for X so I do a recursive call
finally and this is the case where I
actually used that first bill so
remember I'm trying to return a list and
I make lists with cons so I'm causing
the first element of my denominations
thing which might be my five dollar bill
on to the recursive call to make change
for the rest of the amount and I
calculate the rest of the amount would
that subtraction there that's like that
difference equals line in the Ruby and
then the same set of denominations I'm
working with because you know I might
need two or three pennies you know I I
might need to use the same denomination
more than once so this is the case where
I don't use the current thing I'm
looking at this is the case where I do
there's really only two cases beyond the
base so I really really like this it's
much shorter than the Ruby I think it's
very very logical and if you've got some
background in number theory or
mathematical theory and you're used to
proofs by induction
I think the recursion looks very
familiar
very comforting but this is not actually
the shortest solution to this problem
that we will see today that is given to
my friend Prolog we're gonna do logic
and constraint programming and this is
going to most likely be by far the most
brain breaking part of the talk so I
will try to take it slow and you can
come up and talk to me about Prolog
later I'm happy to demonstrate all this
code so I'm gonna give an overview of
Prolog Prague is based on formal logic
things like Socrates is a man all men
are mortal therefore Socrates is mortal
that it so ands ORS implications nots
that kind of stuff
very very basic formal logic that's used
in philosophy and mathematics and also
is the basis of a lot of computer
science Prolog programs aren't made up
of instructions they're made up of facts
and clauses yes that's weird and the
weirdest thing about Prolog is that
instead of describing the how we're used
to in programming telling the computer
how to solve the problem Prolog works
different you describe the you describe
the what of the situation it's one of
the common examples is a logic program
so I would say ok the logic program says
that the guy in the yellow house does
not own the fish and I would encode that
or I would say that the guy who really
likes to drink rum the live has gotten
it was next to the man who owns the cat
and I can encode all of those facts in
the system and then what Prolog does is
it uses everything that it knows and it
tries to come up with a world where all
of those are true and it fills in any
blanks that are remaining once it comes
up with the world where all of those
facts and clauses are true so a syntax
to do this is a little weird the biggest
thing is that we have variables and
constants variables start with a capital
letter constants don't use our lowercase
letter and then we have facts and facts
end with a period so I can say that
Washington is a state or that Washington
borders Oregon and Washington borders
Idaho and Oregon borders California and
using this I can define a rule and rule
specify relationships between facts so
here I'm defining the rule adjacent and
that colon minus sign is out
so a logical implication if you know
what that means that might help you
understand this but all this is saying
is that x and y know those are variables
capital letters are adjacent if there is
a fact where border x and y is true and
what Rob was gonna do with those
variables is it's gonna try to pattern
match it's gonna go through all of the
facts that has and figure out if there's
some constant and can put in for X and
another constant it can put in for Y or
the same constant where there's a rule
that matches or a fact that matches and
this is called pattern matching and
pattern matching languages are awesome
and so here's my adjacent rule again now
here are the facts I have some of them
and here's the adjacent world and I can
go into an interactive prologue terminal
and say hey prologue is Washington
adjacent to Oregon and it will say yes
and then I can go hey prologue is Oregon
adjacent to Washington and probably
gonna say no because prologue is
incredibly literal and since I only have
a fact that says that Washington and
Oregon share a border not that Oregon
and Washington share a border problem
doesn't know that the reflexive case is
true for this particular rule so I have
to teach prologue that by saying that
adjacent X Y implies that there's a
border between X Y but adjacent X Y I
can also imply that there is a border
between y and X no tricky there and then
if I go in and say hey prologue is
Oregon adjacent to Washington prologue
will correctly say yes and I have a
couple minutes I'm gonna go over my
favorite prologue joke how many problem
programmers does it take to change a
light bulb
anyone know know the answer to that is
no
so I'm gonna need some basic examples in
the canonical example in prologue is
ancestors building your own family tree
so I'm using the Simpsons and one of my
first rules is that first facts is that
father Homer Bart so that's saying that
Homer is Bart's father you have to
change the word order around a little
bit to make it work in English not true
in other languages that aren't that have
different word order than English I can
also say that Homer is Lisa's father I
can say that marge is Bart's mother and
Marge is Lisa's mother so that I can go
into my interactive prologue term and I
can start asking questions I can say hey
prologue who is Bart's mother and that's
that first line there and what I'm
actually saying is a prologue what do I
need to shove in for X what can I what
value of x makes this statement true in
prologues like Marge's Bart's mother
which is correct and then I can say the
opposite hey prologue who is Marge the
mother of by putting the variable in a
different location and Prolog says Bart
and then I can use the semicolon to say
you got anything else and Prolog will
say Lisa and this is the real strength
of prologue is that I can run programs
backwards and forwards and I can put
variables wherever I want and it is
crazy the first time you do this but
it's also super duper powerful and I've
showed you simple examples thus far but
you can build rules that are much more
complicated so let's build the rule
sibling so x and y are siblings if there
is some Z such that Z is the mother of X
Z is the mother of Y and X and y are not
the same person because you can't be
your own sibling and that slash equals
equals is not equal in Prolog but
there's another way that you can be
siblings x and y are siblings if there
is some Z such that Z is the father of X
Z is the father of Y and again x and y
are not the same person and Prague's
going to try to figure out whatever
values it has to put into each of those
capital letter variables to make this
true so I can go into the interactive
Prolog terminal and say hey Prolog who
are siblings and it says Bart and Lisa
are siblings awesome so
I'm gonna go into the last bit and this
is one of the most complicated bits of
prologue that we're gonna talk about
today prologue has lists like racket
like Ruby have an empty list at blissed
one two three have a list apples and
bananas so I can have lists that are
heterogeneous I can have lists that have
numbers or constants in them and I can
also have nested lists so which is what
I'm showing on that last line but in
order to pattern match on lists I have
to have crazy some crazy notation this
is called bar notation I'm gonna say
this aloud is f bar R you can think of
the F as first and the R is rest and
this is just like the car in the cutter
we saw in racket F is the car it is the
first element of the list the bar
separates the first element from the
rest of the list which is the cutter and
if that didn't make any sense if I have
the list 1 2 3 and I pattern match that
against f bar our F is going to match
the 1 and R is going to match the list 2
3 so car encoder same thing crazy
notation the last little bit is this is
an underscore so I might break some of
your brains I hope not but did you all
know that you can use the underscore to
say I don't care about this variable
it's unused in Ruby and then the code
and good people are noting this is
fantastic
I've broken people's brain with that one
before racket has the same thing and
under underscore and racket is called
met I like that they're mad they're not
from Ryan Davis last night and then in
Prolog test texts we refer to this
underscore as don't care which is this
variable isn't actually used for any of
the logic so put whatever you want there
I don't care so we're gonna do a quick
list function list rule not a function
not in a functional language so this is
member
it's like include question mark and Ruby
so X is a member of the list first
argument is is the thing I'm looking for
the second argument is the list X is a
member of this list if X is the first
thing in that list makes sense right
that's one case I forgot to change the
bold the second line X is a member of
this list if I don't care about the
first thing it doesn't match but X is a
member of the rest of the list so X is
X's member of this list implies that X
must be a member of the rest of the list
so recursion it's handy that way so
strengths what are the awesome pro
things about Prolog isn't that thing I
mentioned about running programs
backwards and forwards this is true of
logic programming in general there's a
great talk about Mini Cameron where they
actually run their program on check
system backwards to generate the code
for factorial because why not you can
run it backwards and forwards as long as
you set up the constraints correctly one
of the early use cases of frogs that
I've read about was actually scheduling
time to use limited resources in a
resource lap
research lab I believe the research
resource was a dolphin and they needed
to figure out how do you work everyone's
schedules around like this experiments
gonna take 45 minutes and we need to
repeat it every three days for a month
and I have class at this time and all
that these Prolog to put all those
constraints in and solve the problem so
that they had a reasonable shift
schedule so time to make some change so
we're in Prolog the weirdest thing and
the thing that always gets me when I
have to context switch into this
language is I don't have a return there
is no concept of a return everything is
encoded in the method method signature
and you have to have that so you can run
it backwards so we're gonna have a
change rule it has three arguments the
first is the amount the second is a list
of coins or bills we have and the third
is how you make change for that amount
using those bills but that list of coins
first one is an integer the second two
are lists so this is going to be true
only if change that last argument is how
you make change for the first amount
using the coins in the middle I think so
thinking man just napped for a couple
people this is weird so here's the code
for the change function it's actually
shorter than the racket will go through
it I promise I promise
so first case the easy case how do I
make change for the amount zero
well change for the amount zero is the
empty list and I don't care what's in my
cash drawer jizz why I'm using the
underscore because don't need to know
don't really need to use anything from
the cash drawer if I'm making change for
zero that's the easy one here's the
second one focus just on the first line
right now this is where we use pattern
matching so I've got an amount a and
this is saying that I make change for
the amount a by using the first thing
from my cash drawer and that is the
first thing in the way I make change
so this is the case where I use that
first biller coin in the cash drawer and
I can only do that if the amount is
greater than the denomination of that
first thing and if those two things are
true I need to calculate B such that
that is the difference between the
amount that is what's left over after I
use that bill and the other thing that
has to be true in that case is that I
can make change for B using the same
stuff in my cash drawer and the way I do
that is X which matches that X on the
very top there so is what a is greater
than F I can use this because they did
the bill is smaller than the amount of
making B is equal to that difference the
remaining amount of change and beat the
may where I make change for B is X which
matches on that top part I remember poor
ol DS gonna make all of the instances of
each variable the same thing so that's
the second Clause third Clause this is
the case where we don't use the first
coin erbil so I used a don't care again
I only want to apply this one if I'm
actually making more than zero in change
because if I'm making just zero I can
use the first one above the very first
one and in this case I'm gonna say hey
the way you make change for a is you use
the rest of the stuff in your cash
drawer and the way you do that is X so
this is the other recursive case and I
promise it works and you're probably
going out of my brain right now this I
love Prolog and this was the hardest of
the examples for this talk to write I
actually had to break into the debugger
to do it and I didn't have to do that
for even what's coming next which is
procedural and we're gonna do that
assembly
so the fact that I was able to write the
assembly without the debugger and I
needed the debugger for the prologue the
prologue is hard so assembly is
old-school programming we have a limited
vocabulary a limited standard library a
limited number of functions we can call
and buy Limited I mean very limited for
the assembly I'm using I think there are
less than 30 I think there's like 22 and
there are tons of assemblies that exist
I am using the assembly from a book
called well it's commonly referred to as
nan to Tetris I have a link to have a
bibliography entry for it and man so you
can grab it and look check it out
yourself the reason I'm using this is
that it is less ugly than most
assemblies it looks more like the
programming you're used to and it's very
very simple so here's the syntax so the
big thing about the assembly is that I
have two registers a and D and those are
the only two things that I can do
operations on D is d because it is the
data register a is a because it could be
a data register or it can be the address
register and when it's the address
register I use whatever value is in a
and I go pull that cell out of memory so
in the cases where I'm using a to access
memory I'm gonna actually just call it m
so I'm gonna use ad and M but I only
have two it's just when I'm using M I'm
using what a is pointing to and when I'm
using a I'm using the actual value of a
answer going back to wreck it we had car
and cutter car stands for the contents
of the a register
cooter stands for the contents of the D
register that's where the names came
from so we got some computations I can
do a plus T I can do D minus a I can do
a minus D I can do a plus one or D plus
one we can do a minus 1 or D minus 1 I
have a bitwise not a bitwise and in a
bitwise or and I can negate a or D in
any place I use a I can also use app so
like M plus 1 or D plus M and that's it
that is the contents to list the things
I can do and important to note I don't
have multiplication don't have division
don't have anything that you were
looks like a list very very limited but
I can actually assign the things I
calculate to values so I can assign to
any of the registers or to memory so I
can say D equals n plus 1 or D equals D
minus 1 and I can also do multiple
assignments so I can say m and D both
get the value of a plus 1 which is crazy
because then I'm incrementing the memory
register it's yeah that's about idea I
need to be able to get constants into my
program and the way I do that with this
accent X and constants only can go into
the a register that's why it's at so if
I want to load a hundred I do at 100 if
I want to have I can have a label and I
use this label somewhere in the program
to access the line of my program that
this label is on and again since this an
hat goes into the a register and I use
this for jumps jumps are this format
there's a value a semicolon and then the
type of jump and so I'm like the value
in this case in this example is deep jgt
is jump greater then and I will jump to
whatever line of the program is in the a
register if d is greater than zero I
don't get to have any other greater than
so it's always been reference to zero so
i have je q jump if equal and so this
will always jump because i'm jumping if
i'm jumping if zero is equal to zero
jump greater than jump less then jump
greater than or equal to jump less than
or equal to i also have a non
conditional jump which is JMP
so those are the jumps I have those are
the only form of branching logic I have
in this entire language so here's how we
add this loads it to into the a register
I then move the contents of the a
register to the d register this loads a
3 into the a register and I add what's
in my d register to my a register and
assign it to myself and then I take
whatever is there and I assign it to the
contents of memory cells 0 and its
memory cells 0 because I put a 0 into
the a register and then I'm using an M
which means it refers to memory not to
the value in a see it's easy
here's how I sum the digits from one to
five I'm actually doing it backwards so
the first thing I do is I'm gonna store
them in a store might result in memory
cell 0
so I want to zero out memories L zero
and then I'm gonna store five in memory
cell 1
so I load it into a assign it to D and
then load address 1 into a and then
assign whatever is in D which is 5 to
memory cell that's referenced by the
address and a which is 1 so putting in
the memory cell 1 here's my loop the
parenthesis notation is a label first
thing I do is I pull whatever is in
memory cell 1 which is 5 in this case
and I put that in D and then I'm going
to take whatever I have in D and add it
to the contents of memory cell 0 which
is my accumulator so now it's memory
cell 0 is 5 in memory cell 1 is 5 and
then I'm going to take the contents of
memory cell one and I'm gonna subtract 1
from that so now I've decremented to 4
and I'm gonna store that in both back in
my memory so 1 and in D and then I'm
gonna do my logic and here's my loop so
I'm gonna load end into my a register
this is where I want to go in and it's
the end of my program if my program is
over and I know my program is over when
my counter has gone from 5 to 4 - 3 - 2
- 1 - 0 and so D is less than or equal
to 0 I'm gonna jump to the end otherwise
I fall through - my loop label and I
mean go back to the top of my loop in
all other cases because I have an
unconditional jump there awesome so
strikes there are d'arnot's drinks I
don't have use for assembly on a daily
basis I'm really hoping that none of you
do - but procedural style in a Cell can
be useful and you can write procedural
style in any language most of us our
very first program was procedural hello
world is totally procedural all of the
scripting stuff we write is generally
procedural do this thing then do this
thing then do this last thing and
writing procedural code is are generally
pretty easy for most of us our brains
instinctively think this way so here's
making a change in the assembly
so I don't have lists so I'm gonna use
memory zero for the amount to make and
when you use memories one through four
for my coin denominations twenty five
ten five and one and I'm gonna use
memories five through eight for the
number of each coin D is because I have
memory will turn it into a list the
Assembly I'm using doesn't understand
this M syntax it uses R instead so
you'll see this in the code so this load
sixty into your memory register zero and
then yes and then this loads the
denominations and then this is the code
for quarters so I load in my core I load
on the amount I want to make I loaded in
the amount of the quarter is I subtract
the amount that a quarter is from the
amount I want to make if the result is
negative I don't need any quarters so I
go on two times if the result isn't
negative I saved the amount I have left
increment the number of quarters I've
used and go back to the top so I didn't
cover anything in detail and I've got
four minutes left according to my timer
so let's do this thing so here's where
you can learn more about functional
toxis by Jim why rick including is why
not adventures in functional programming
keynote from Ruby conf 2012 again I
tweeted the slide so you don't to take
pictures of this the slides are online
and then Freesat and freed minute lesson
have the little schemer the reason
schemer and the seasoned schemer those
are fantastic books they're written in
Socratic dialogue don't awesome and the
structure interpretation of computer
programs is a very large textbook on the
fundamentals of computer science from
the functional perspective I gave a talk
at Cascadia Ruby 2012 on Prolog
it's the 45 minute version and much
easier to follow than this talk there's
also the art of Prolog cause-and-effect
the Prolog programming for the working
programmer and Prolog programming for
artificial intelligence and then I
mentioned of the assembly I users from a
book called manda Tetris the actual
title of the book is the elements of
computing system building and modern
computer from first principles I highly
recommend if you don't understand how
your wizard box works you follow this
book you start with logic gates and you
end up writing a very small version of
Java including the assembler the machine
code and the vm underneath it's awesome
and if you just like languages several
languages in several weeks with the
classic and then I also have it it's
actually on my back
but cold exercises in programming style
which is basically this talk but in book
form and better it goes over lots of
different styles and how to do the same
program in lots of different languages I
have it with me come find me you can
even flip through it so I'm supposed to
have a thoughtful closing here but I'm
out of time cuz I used every last second
I had available and I also kind of told
you what the whole purpose of this talk
was up front you can learn other
programming languages other paradigms
are not that different
everything has conditionals accessing
memory integers mathematics it's all
similar
so go learn down in the languages
because it's me I have dinosaurs you can
come get one later there's a bunch on a
chair up front and I have special
edition Mardi Gras dinosaurs for
rubyconf in New Orleans I also have
Google Cloud stickers and I'm done</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>