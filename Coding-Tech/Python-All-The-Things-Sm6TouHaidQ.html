<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python All The Things | Coder Coacher - Coaching Coders</title><meta content="Python All The Things - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python All The Things</b></h2><h5 class="post__date">2017-11-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Sm6TouHaidQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">for those who haven't met me before hi
I'm Russell I've been a member of the
Django core team for almost 11 years now
and I was a president of the Django
Software Foundation from 2010 to to into
2015 Django is a big part of the broader
Python ecosystem but it is by no means
the only part there are other web
frameworks there are great tools for
data analysis there are projects for
using Python in education and on
embedded devices none of this has
happened overnight Python as a language
is 25 years old it took maybe ten years
for Python to gain significant traction
in our industry and another ten before
it really started to gather a widespread
support what we see today as the Python
community is the result of thousands of
hours of mostly volunteered effort but
despite all this effort Python has
really only been available on server and
desktop platforms devices that fit a
very traditional concept of what a
computer is but over the last 10 years
we've seen the emergence of a whole new
class of devices much smaller and
usually portable things like phones
tablets watches set-top boxes my reading
of the tea leaves is what has led me to
change the focus of my open source
contributions over the last couple of
years these days I'm spending most of my
time not on Django I do still involve
myself with Django but I've spent a lot
more time on the be ware project for
those who haven't come across it before
beware is an open source collection of
tools and libraries for creating native
user interfaces in Python for desktop
but also for iOS for Android single page
web apps and for other new hardware
platforms now as Richard pointed out
yesterday Guiteau draw attention to
micro Python and the fact that you can
run Python on embedded devices and
Damien talked about this yesterday but
what Guido didn't point out is that we
can also fill the other box too for
mobile devices and that's what beware is
all about you'll also notice that this
makes Python the first language to tick
all four boxes which means that it is
entirely possible to Python all the
things
if it isn't already clear I like Python
I think it's an elegant it's got an
elegant expressive most importantly
readable language it's I've got a great
standard library and a really rich
ecosystem of tools around the outside of
that I love the minimalist syntax and
the significant whitespace to me that's
just enforcing at a language level code
starred guy lock code style guidelines
that are just good engineering practice
I'm not for a second gonna claim that
Python is perfect it's not but it's as
close to perfect as I've ever come
across and I'm very happy living my life
as a Python Easter and because of that I
want to be out of run Python on all my
devices not just some token notion of
running Python either I want to be able
to use Python to deliver a full
developer experience I want to be able
to develop and deliver applications for
these platforms not in some Python
sandbox but as a fully fledged
first-class citizen of their device
ecosystems now if you're here today at
PyCon I probably don't have to convince
you of the benefits of Python as a
language what I might need to convince
you of is that it is indeed plausible or
even desirable to run Python on
non-traditional devices and assuming
that it is possible that it's even worth
the effort to try and that's what I'm
going to talk about today the how and
the why of Python in all the things okay
so first off let's deal with the how
there's absolutely no point in getting
all philosophical about why you should
do something if you can't actually do it
so let's play a game
you have been given some brand-new fancy
hardware device that's been dropped into
your lap what options do you have
forgetting Python to run on it well to
answer that question you actually need
to start a little bit higher up and ask
a slightly different question you have
to start with what what is Python well
it's a programming language right except
that it isn't depending upon who's
talking Python could be one of two
things
Python the language is an abstract thing
it's a specification of syntax and
semantics that describes how a
particular sequence of human readable
bytes will be interpreted to make a
computer do something interesting
then there's the Python interpreter that
you actually install and run when you
tell someone to go to the Python web
site and download the Installer you're
not strictly talking about Python you're
probably talking about C Python
which is the de-facto reference
implementation of the Python language
standard this separation between
implementation and specification is
valuable because it means that see
Python isn't the only way that Python
can be interpreted there are features of
Python that are experienced by end users
that are features of C Python not the
language itself the Gil for example the
global interpreter lock the perpetual
bane of of Python performance
discussions is not an inherent feature
of Python it's a feature of C Python a
specific reference implementation of the
Python language specification C Python
because of the way it's implemented has
a Gil other implementations of Python of
the Python language specification Jathan
pi pius tacklers don't have a gil this
separation means that when we're talking
about getting python running on fancy
new hardware devices there are a couple
of different approaches depending upon
the capabilities of the device that
you're targeting the easiest approach of
course is just use C Python when you
start a Python shell or you run a Python
script on your laptop or on your server
chances are this is what you're doing
you're running C Python effectively the
reference implementation of the Python
language standard written in C and one
of the side effects of being written in
C is that it's really easy to port to
new platforms in this regard
C Python follows the tradition that's
laid down by Unix
one of the major reasons for the
proliferation of Unix as an operating
system is that in the early days of
computing dozens of manufacturers were
producing computers IBM Dec univac NCR
Honeywell General Electric Siemens
Fujitsu Hitachi NEC and technology was
advancing so quickly that there would be
major shifts in architecture between
versions of a device even between the
same manufacturer then Ken Thompson
Dennis Ritchie Brian Kernighan and a
bunch of other people working at Bell
Labs worked something out if you could
define a minimal kernel that could be
ported to any machine providing a common
API for basic operations like memory
management process invocation IO then
you could use that kernel to bootstrap
the rest of an operating system they
then developed an entire programming
language C to make this even easier the
original versions of C were developed to
make it easy to
port eunuchs to other platforms the
colonel the very very base of the
colonel was written in assembly language
for a specific machine and a specific
architecture and that got even smaller
and smaller as the operating parts of
the operating system could be written in
C and therefore easily ported to a new
kernel and that's essentially what C
Python looks like when you want to
Porter it's just at a slightly higher
level of abstraction it assumes the
existence of a C compiler but as long as
you've got a C compiler which is a
pretty safe assumption for a lot of
platforms the C Python core can be
compiled and give you a Python
interpreter you can run and a Lib Python
that can be embedded into any process
that runs on that machine and that is a
basic threshold that most modern devices
can support if you look in the Lib
directory of the Python 2.7 source tree
this is what you'll find a list of all
the platforms that have explicit support
in the Python source tree Python 3 has
pruned a lot of these out
os/2 emx for example any-any always to
veterans here represents there we go
what about B Oz any B Box owners yeah
your B Box owner here there we go all
right unfortunately they're no longer
supported but hopefully the point is
clear as long as you can compile the
kernel the core C Python implementation
you get the rest of the Python standard
library and the Python ecosystem for
free but even this compilation process
gives you some options if you're using a
compiled language like C the usual
approach is to write some code and use
the compiler on the same machine that
you intend to run that code if you're on
a desktop or a server machine that works
great because you almost certainly have
a C compiler
after all you had to have one deport
UNIX but on some devices this isn't
portable either because a compiler
hasn't been ported to that platform or
because compilation on device just isn't
feasible consider do you really want to
be running a compiler on your watch
compilation is a CPU intensive process
do you really want your watch to turn
into a molten ball of slag burn and hole
into the center of the earth while it's
attached to your wrist I don't think so
so you really do need to have a way to
compile somewhere else and get the
compiled product on to your watch
that's what cross-compilation is a
compiler remember at the end of the day
is just a magic box that takes human
readable input and makes machine
readable output but there's nothing that
says that the machine readable output
has to be read by the same machine that
is doing the compilation
it's just bytes at the end of the day
and yeah okay it is more difficult to
set up and there are plenty of
opportunities for things to go wrong
but these are resolvable problems and
again python has this ability to cross
compile built into its build system this
is something you almost get for free
when you use the Ganu auto con toolchain
i say almost because well you know Auto
conf is a very special snowflake but at
least in principle the glue tool chain
has been designed to support platform
cost compilation remember this is the
reason C compilers exist in the first
place to make it easy to port a binary
to a new machine okay
so as long as you have a C compiler that
runs on your new hardware device so you
have a C compiler that can target that
device you said you can compile the
stock C Python sources and you get the
same C Python that you use on a server
that doesn't necessarily mean that you
have the same Python experience though
if you're running on a watch you can't
just open a shell prompt and start
typing in a new command so you have a
problem how do you interact with Python
when you don't have standard in and
standard out are you stuck the good news
is no you're not see python is written
in c and while it's certainly designed
to be invoked from a command-line and
provide a prompt it doesn't require that
the command line experience is
essentially just a wrapper around a very
specific set of test setup and teardown
tooling the code for the Python
executable itself a Python exe is
remarkably simple it really is just a
pipeline for getting key put in keyboard
input and file input and passing it to
the real engine an embedded library
that's called on surprisingly Lib Python
this library is what implements the
actual let's run all the Python code
part of the puzzle so as long as you can
build a binary any binary that
initializes and invokes some key methods
in Lib Python you can have Python
running on any device you want and then
it's just up to the device to determine
how you pipe the Python script into the
Python interpreter running on that
device
once you've got a running interpreter
you're going to want to access the
system native library so you can
actually interact with the capabilities
of the device that you're running on now
you've got this far it's got this far
it's because you have a C compiler which
generally means you've got a C library
under the hood providing those services
this means you can use one of the
features of the Python standard library
C types to access those services C types
is a library that exploits the fact that
at the assembly language level the way
you invoke a function what's known as
the calling convention the calling
convention used by C compilers is well
defined since its well defined it means
you don't actually have to use a c
compiler to generate code that will be
interpreted as a function call any tool
that can generate a compatible sequence
of assembly language commands can invoke
any function in a library that claims to
be C regardless of what language is
doing the calling what language the
library was actually written in and
there's a helper library called F fi the
foreign function interface that makes
this easy to do and C types is then
pythons built-in wrapper around FFI
using c types all you have to do is
reference to the c library then describe
the prototype of a c method that you
believe to be in that library and then
you can invoke that method directly from
raw Python without the need to compile
anything on the Python side for example
we could use C types to load Lib C the
standard c library on POSIX boxes the
utility library and we can tell that
library that there is a function called
structure there is it takes a character
pointer a C sharp E and a C character a
C char and it returns a C character
pointer C char P then you can invoke
that method directly there's no need to
compile anything you just have to open
up a prompt and start running that code
so whatever system libraries your
platform performs you can access them
from Python if you want you can then
write a wrapper library to provide a
nicer API and then it's just up to you
to what interface you want to provide at
that point you have a fully functioning
Python on your new hardware device with
full access to the entire system
libraries now when this approach works
it's pretty straightforward to get going
it's the approach that makes Python
available on pretty much every desktop
and server machine that ever
manufactured it's also the approach that
I've used to get python working on
iPhones iPads Apple TV set-top boxes and
in principle Apple watches that I
haven't actually had a chance to test it
with an actual watch although Apple
hides a lot of the details between Xcode
and objective-c and more recently Swift
the core of what Apple is doing in all
its devices is plain old UNIX in C and
so compiling C Python for iOS the TV OS
for watch OS is relatively simple and
you can access all the system native
libraries even though iOS is advertising
them as being objective-c using C types
but what about what it doesn't work what
happens when you don't have a C compiler
or C isn't the native system language
like for example on Android well then
you have to take a different approach if
you read the advertising copy for
Android it sells itself as a Linux and
then prompt her then promotes Java as
its user space programming language the
catch is it's not really either of those
things yes at a some level it is
notionally a Linux but not at any level
that is actually interesting to n
developers the kernel is written in C
and you can use a C compiler that will
target that kernel but the C level
really only has access to bare level
system services you can't actually do
anything interesting from the Android as
a portable computing device perspective
all of androids user space libraries are
exposed using Java API s and Android
isn't the only platform that does this
Sun now Oracle has spent a lot of money
developing the Java ecosystem an entire
ecosystem based around the java virtual
machine as a runtime platform
abstracting away Hardware differences
both these platforms do a head feint
into the significance of native
libraries Android provides NDK the
native developer kit both Android and
JVM provides something called J&amp;amp;I the
Java native interface but the focus of
all the tooling on both on these
platforms is heavily directed at the use
of Java for user space code so yes you
can just port C Python to Android using
C Python as a starting point but it's
also not the natural interface to that
platform your life will be a lot easier
if you
do what the platform actually wants you
to do there are also platforms where it
just isn't practical to use cpython
micro Python you had about yesterday is
a really good example of this see Python
is a fantastic implementation of Python
as a language specification but in
better devices as we heard yesterday
have some really extreme constraints by
comparison to servers and laptops and
see python is just too big to use it an
unmodified state on an embedded
microcontroller so you have to look at
other ways of providing an
implementation of the Python language
spec if you want to use it so if you've
got one of these platforms and you want
to use Python on it you effectively need
to provide a new implementation of
Python one that is native to the
capabilities of that platform so how do
you do that well okay there are a couple
of ways to tackle this problem one
option is to use a different compiler
see python is obviously in designed to
be compiled using AC compiler but there
are c compilers out there that don't
target traditional system executables
one really notable example is in script
n' it's a compiler strictly a compiler
back-end because it still uses the c
part of the puzzle but rather than
outputting a binary that can be executed
as a dot exe file on some platform it
outputs javascript specifically a subset
of JavaScript called a SMGs that is
known to run fast on certain JavaScript
implementations now remember a compiler
is just a black box for turning human
readable bits into machine readable bits
nothing said those machine readable bits
had to be machine language so turn them
into its own tournament into JavaScript
and if you take this approach what you
get is pipe ijs the project by Ryan
Kelly's Ryan here hiding somewhere right
ok and for you what you get is pipe ijs
it takes the pipe I source code rather
than C Python but what you get at the
end of the day is a block of JavaScript
that will run Python code and for
suitably selected benchmarks it does so
faster than C Python native on the same
machine I'll let Ryan deal with the
details of those potential in particular
particular benchmarks
but if you're not going to just
recompile existing sources you'll need
to re-implement cpython
the good news is that you don't have to
implement all of cpython what do i mean
by that well if you pull apart a Python
implementation there are a couple of
different pieces the full stack of
Python consists of a parser which takes
human input and turns it into an
in-memory representation of code a
compiler which takes that in memory
representation and turns it into
something that can be executed in C
Python that's byte code an eval loop
which can be read to run the output of
the compiler this is what you experience
as the Python executable and then
there's the standard library which can
which is used by the code running
through the eval loop the standard
library comes in two pieces there are
pieces that are written in native native
language and bits that are written in
Python the bits in native language
driver system specific for example
hitting raw POSIX system calls or
they're done natively per for for
performance reasons the simple approach
re-implement the lot rewrite the whole
thing in Java or C sharp or whatever
other language you want to target those
parts of the standard library that are
written in Python don't need to be
re-implemented but the rest needs to be
ported over to your new language or to a
new platform and this is what Mike
replies in Jason ironpython sculpt
Brighton a bunch of others do wholesale
reimplementation z' of all the c python
except for the bits of the standard
library that are already written in
Python and can be used as is but that's
not the only approach you can take you
don't have to throw out the entire C
Python stack and start from scratch
C Python provides not surprisingly a
really good part of a Python code that
outputs a data structure that is a
paused ready to manipulate version of
the code that has been entered by a
human this data structure is called the
ast or the abstract syntax tree and it's
represent it's a representation that has
been designed to be manipulated and
converted the normal C Python compiler
takes that ast and converts it into byte
code that can then be executed by C
patents either event loop however you
can just as easily take that ast and
turn it into any other representation
that would be helpful for example Java
bytecode ought net CLR bytecode
approach is what vaak does vaak is
effectively a cross compiler for Python
code
it's a compiler written in Python so it
can be executed by C Python but it
outputs Java bytecode that can run on
any JVM instance when the Java bytecode
runs it's indistinguishable from code
that has come from Java source code
compiled by the Java compiler it but it
just refers to line numbers from the
Python source code okay so we can reuse
C pythons parser to make our life a
little easier do we have to stop there
is there any more of C Python that we
can reuse in our quest to get Python on
a different platform well yeah if you
want to you can even reuse C pythons
compiler to when you run some Python
codes it's in a pic py file through the
C Python compiler it outputs a dot py c
file that py c file is the compiled
version of the code it's a binary
representation but not a system binary
not an executable by itself it's a
bytecode representation bytecode is a
bit like us at a high level assembly
language it's an encoded set of
instructions for a stack based virtual
machine that has basic primitives like
pushing and popping on to a stack
setting attributes and an object
handling exceptions and so on there's
nothing about Python the language that
specifies bytecode it's entirely a
runtime format used by the C Python
interpreter the C Python interpreter is
what provides the virtual machine that
can actually execute that bytecode but
there's nothing to say that we couldn't
create an independent implementation of
the C Python virtual machine capable of
running C Python bytecode and that's
what potatoe does battaglia is an
implementation of the C Python virtual
machine written in JavaScript and
because it's written in JavaScript it
can run in the browser now while that
might seem a little bit daunting it's
actually not that hard after all C
Python bytecode is only a hundred or so
operations it's sort of a pseudo
assembler at the end of the day and a
good chunk of those operations of those
hundred operations are basic
mathematical primitives plus minus
multiply and divide
so reimplemented those doesn't take a
whole lot of code the biggest
complication in that process
see Python because black code is not
part of the specification si Pathan
makes no guarantees of compatibility in
byte code versions and between Python
3.4 3.5 and 3.6 there have been several
major changes in byte code format in
interpretation but you can stay on top
of those if you want to it's not a major
problem just kind of an annoyance from
someone who's sitting there trying to
re-implement a bytecode machine now
whenever I tell anybody about Batavia
the first reaction I hear is normally
well why don't you just compile Python
code into JavaScript and yeah okay that
is actually an option on the surface it
even seems relatively easy there sure
there are sort of syntactic differences
between Python and JavaScript but a lot
of those are cosmetic now using braces
and different looping constructs the
catch is though if you dig a little bit
deeper it's a lot more complex than that
you don't just want a language that
looks like Python you want it to run
like Python as well and pythons scoping
rules are very different to Java scripts
let's take this really simple example
these two code snippets are cosmetically
the same modulo a language translation
the only thing that's a little bit hairy
is the change in the arguments to the
print statement one takes a sequence of
arguments the others using concatenation
with a plus operator okay what gets
output when you run them when you run
the JavaScript code at the top you call
scope test 3 and then you output the
value of X what you get prints 30 what
about the Python unbound local error
because X has been referenced before
assignment Y because JavaScript scoping
rules put X in global scope Python
scoping rules mean that X can be
accessed for reading but not for writing
now ok for the pedant yes if you used
es6 let's instead of var or use global
and the Python version you'd get output
that would be comparable here this is an
intentionally simple example to
illustrate the point the problem gets a
whole lot more complex than this if you
start talking about things like closures
so if you want to preserve Python
semantics in JavaScript you can't just
do a syntax conversion or at least not a
simple syntax conversion you actually
have to pause the code and generate
JavaScript constructs that expose the
same lexical scoping that Python expects
which means you're basically there for
three choices you can either
re-implement pythons scoping rules in
JavaScript you can treat your resulting
compiler as a Python like language that
looks like Python but has lots of subtle
differences or something in between the
two and it turns out it actually ends up
being a lot employees e'er to implement
the bytecode machine because all you
have to deal with is the values that are
in a single stack okay so what's the
downside of reusing see pythons parser
or compiler well it means that you've
made a decision that parts of your stack
won't be running on your new platform if
you're you reusing see pythons parser
and compiler then that obviously means
that part of the stack will only run
where see Python will run you're
effectively cross compiling your Python
code using one platform to produce a
binary that will run somewhere else that
means your Python platform or your
target platform won't have the ability
to parse and compile code on its own
this means the one thing you don't get
on your new platform is a wrapper a read
eval print loop that is the Python
prompt where you can interactively type
an execute Python code having a ripple
relies on the ability to compile code
locally if you don't have a native
compilation capability you can't have a
ripple now that might seem like a really
bigger mission but the platform's we're
targeting here aren't natural matches
for a ripple nobody really wants to be
typing Python coding to their watch so
on these devices pi Thea is really about
being a high productivity programming
language not an interactive programming
language and you also have to think
about the entire development cycle
remember one of the reasons that we're
porting to Python is so that the same
code can run on multiple multiple
devices you could develop code on a
desktop machine using C Python and a
ripple use some mocking and stubbing
system native parts and then once the
core like all logic of your app is
working ship it to the device for final
testing okay so at this point either by
re-implementing or borrowing from c
python you've got a parser you've got a
compiler and you've got some mechanism
for executing that code so you can run
Python code on that machine but only the
code there's still a big piece missing
the standard library
the C Python standard library is made up
of true parts there's a pure Python part
and a part that's written in C the bit
that's written in pure Python is easy
you can just take it and compile it
wholesales it's Python code it compiles
this python code the same as everything
else we can compile it to bytecode run
it through a new virtual machine or we
can cross compile it to our new target
platform or just REO run it on our
reimplemented Python whatever you need
to do but the bits written in C are a
little bit more complicated there's a
couple of reasons why our module might
be written in C firstly there are
occasions where what you're doing is
talking directly to system services if
you're going to make a POSIX exit call
well you're gonna need to call the C
method that implements a POSIX exag
there are also modules that are
implemented in C because they're just a
wrapper around some library whose
implementation is in C be zipped to for
example as a compression library the
reference implementation for B zip 2 is
in C sure you could rewrite it but why
would you you just use Lib bz2
lastly there are parts of the standard
library that are implemented in C for
performance reasons for example the
decimal module used to be implemented in
pure Python for performance reasons it
was ported to C in Python 3.5 and that's
great the C Python is a link as an
implementation of Python nobody's going
to complain about high performance but
if you're looking at C Python is a
reference implementation it's a bit more
annoying because it means that that's
now something you have to implement
natively what we really need here is a
reference standard library as well an
implementation of the Python standard
library that is written entirely in pure
Python except for a clearly delineated
minimal interface to system services and
that's what a row Burress is for those
that up in your Greek mythology that's
the oberus is the symbol of a snake
eating its own tail tail a robe roast is
very much a work in progress but it's an
important part of the whole puzzle if
we're going to make it easy to bring
python to as many platforms as possible
the last piece of the puzzle is
deployment now this is an area where
python historically has not had a very
good story even in the web world which
is considered one of pythons strengths
pythons deployment story lags a long way
behind other languages like PHP a PHP
developer just needs a directory where
they can FTP coding to maybe some
details about the host where they're
going to be where the database is going
to be connected
I make a deploy a site a Python web
developer need to know about whiskey web
server configuration mechanisms for
activating virtual environments it's not
too daunting once you know how all the
pieces work but it's certainly a long
way from one-click deployment and it's a
lot more daunting than first time
developers are generally ready for and
as hard as it is to believe the
situation is worse for desktop you want
someone with a Windows computer to run
your Python script good luck with that
better hope they've got admin access and
know how to find the dialogue hidden
three levels deep in the control panel
that lets them set their path
environment variable the good news is
that this problem can be solved and
moving to platforms like phones and
watches will force us as a community to
address these problems these devices
don't have a control panel if you want
to distribute apps for a phone you need
to package them as standalone tools with
a simple entry point and we have to
develop the tooling for these new
platforms so why not take a look at our
existing platforms while we're at it and
this is what I've been trying to do with
a tool called briefcase it's a dis utils
extension that will convert any Python
project with a setup dot PI file into a
deployable unit now again it's also
early days for briefcase but it works on
Mac OS it works on iOS it works on TV OS
it has preliminary support for Android
if anybody here has an interest in in
Windows I've got some ideas about how
this the approach that's used for my
course could be used to make the windows
deployment story easy as well so come
talk to me
now a lot of the specific tools and
libraries that I've spoken about so far
have been you know are in very early
stages of development the flip side of
this is that there's a lot of very
fertile ground for contributions if you
want to get involved I'm here to the end
of the sprints
no matter your level of expertise and I
do mean no matter your level of
expertise come grab me during the
sprints and we can find something for
you to work on and if you do thanks to
Maxie and I've actually got shiny
beware contributors challenge coin that
everyone will get so that's the how
that's how you introduce Python to a new
hardware platform but why why is this
important why have I spent so much time
and effort trying to get Python to run
in places where it doesn't currently run
for me it's about evaluating our
existential threats as a programming
community Python is on the bit of a
crest of a bit of a wave at the moment
over the last 25 years we have built up
a significant community and resources
and expertise and as a result most
surveys including that one from O Triple
E before put Python in the top 4 or 5
programming languages you should know
usually only behind Java and C C++ in
some variation in order the growth of
events like Python are a great
indication of that success so in the
midst of this success it behooves us to
look to the future and consider whether
the light at the end of the tunnel is
the dawning of a bright tomorrow or a
train coming straight for us
we need to ask quaver Dimas where are we
going
Python has been around for 25 years it
was originally found a foothold as a
systems integration language on servers
over time it found another niche as web
server resulting in soap and Django and
pyramid and plone and others the era of
Python is a major web platform is maybe
10 years old
since that time Python has found
footholds there's an education language
as a data analysis language it's found
footholds because it's an easy and
straightforward language to teach while
retaining the power of a hardcore
computer science language we've
developed a reputation we've developed a
community we've developed a rich
ecosystem of tools and libraries around
the core of the language so what changes
are coming that pose a potential
existential threat to all of this well
the most obvious one
is the one that I've been addressing
directly so far the last ten years have
seen an explosion in the platforms that
people are using for computing and the
types of people that are using those
platforms computers aren't just for
geeks anymore
these devices have rapidly become an
indispensable part of everyone's lives
and this means that these new platforms
are becoming an increasingly important
part of the development landscape if
Python doesn't have a good story for
mobile we run the risk of being left
behind servers aren't going anywhere but
they've only ever been used by a very
small portion of the community and the
growth of services like serverless
computing is part of a larger trend to
hide even more server details as for
desktop machines sales trends of desktop
machines versus phones and tablets
they're certainly pointing towards a
time where desktop machines as we
currently think of them at least either
won't exist will exist in a radically
different form to what we what we think
of them today so if using a
general-purpose language that can only
be used in a tiny portion of computing
devices what hope does that language
community as a whole have I'd say not
much but the threat is also a huge
opportunity many of the areas where
Python has gained traction in it in
science in education these are areas
where the new where new devices have the
potential to make a huge impact imagine
a world where a scientist can knock
together a quick user interface to put
in the hands of experimenters to gather
information or provide an app so that
citizen scientists can log local flora
fauna environmental conditions imagine a
world where you can get kids excited in
programming because they can build
something that runs on their phone that
they can show to their friends imagine a
django girl-style event where students
leave the tutorial after a day having
come in knowing very little about about
programming but leave with a mobile
phone app that they use to upload photos
to their blog Python is a
general-purpose programming language
there's no reason it has to be tied to
historical platforms we just have to pay
attention to the new platforms that are
emerging
so what are we competing against here
and what advantages does Python bring to
that struggle well we're competing
against a background environment where
poly lingual ism is required at present
there is not a
single programming language that can be
used on every platform as a native
offering Apple pushes Objective C and
Swift as their preferred languages
Android pushes Java the web requires
JavaScript so today if you're a
scientist or a student and you wanted to
write an app that was available on
multiple platforms you would have to
learn several different programming
languages three maybe four poly lingual
ism be it in computer languages or human
languages is a good thing there are
countless studies out there that
reinforced the benefits of learning a
second spoken language improvements in
perception memory decision making
problem solving this is also true of
programming languages learning a second
or third or fourth programming language
especially when it's a completely
different programming paradigm is a
great way to encourage your brain to
think about problems in a different
creative way and if you're a
compressional computer scientist or
software engineer I'd absolutely
encourage you to learn as many
programming languages as you can but
that's not the market we're talking
about here unlike spoken languages there
isn't an obvious first-contact
programming language if you're born in
Melbourne your first spoken language
will almost certainly be English if
you're born in bitching it's almost
certainly going to be Mandarin but in
computer languages there isn't an
obvious first-contact language there
isn't a programming language that
everyone in a community speaks by virtue
of just existing in that community that
means there is ground to be one it's
this first contact status that is to my
mind critical consider the world 20
years ago visual basic was one of the
most widespread programming languages in
common usage not because it was an
especially powerful programming language
but because it was present on every
Windows computer was accessible to
non-expert users and enabled people to
do really powerful things with the
office suite of apps Visual Basic was
their first contact programming language
many users never moved beyond it neither
should they have had to there is immense
power in being the language that people
use to discover programming and python
has repeatedly demonstrated that it's a
great candidate to be the first contact
programming language from django girls
to university level computer science
Python has been used as an introductory
programming language and yet unlike
Visual Basic it's a programming language
that is able to support very
sophisticated computer science concepts
like generators and asynchronous
processing and so on when marketing
people talk about selling a product they
often talk about conversion funnels
conversion funnels the idea that there
is an entire world of people out there
but they have to move through your sales
process to buy your product and each
step they have to go through that
process some loss is probably inevitable
and the funnel narrows but the goal is
that at the end of the day they're going
to end at the bottom of your funnel as a
user of your product a consumer of your
product a purchaser of your product the
the goal of marketing is to minimize the
loss between each step and end up with a
viable output of the funnel at the end
of the day it can help to think about
the adoption of software projects in a
very similar set of terms there is our
world of potential users out there some
of them will actually use your product
some of them will continue to use your
product some of them will become members
of your community some of them will
become contributors to your community
some of them become members of the core
team and eventually lead the community
now there are two ways to hack a
conversion funnel you can work on the
funnel itself and try to minimize losses
as people move down the funnel or you
can put more people into the funnel to
start with ideally you do both and
that's the opportunity the opportunity
that's on the table here we have a world
of people out there that look at their
computers and phones and tablets and
watches and set-top boxes as devices
they use to passively consume content
through apps that are developed by some
sweaty white male boffin in the dark
room we have an opportunity to break
that mold not only make it easier for
experts to develop apps but introduce a
whole new audience to the idea that
computing devices can be transformed to
do what they want them to do to meet
their specific needs there will always
be a place for experts but this new X
induce new audience isn't looking to do
a three-year degree in software
engineering before they get started they
want to learn one language and have that
language be useful wherever they need to
use it but if we're putting more people
into the top of pythons conversion
funnel we're also going to get more
people filtering down to the bottom and
that means more experts and if we play
our cards right a more diverse audience
of experts not just sweaty male boffin
sitting in dark
rooms people from a wide range of social
racial economic backgrounds with rich
diverse experiences to bring to the
discussion and shape the evolution of
the world around us so why do I think
python has a compelling case to be this
first contact language well it would be
really easy for me to launch into a
blistering technical critique of
JavaScript or Swift or Java and a
defense of pythons technological
superiority but I'm not going to do that
firstly I don't think it adds anything
to the discussion like it or not
JavaScript Swift Java they all exists
they're all in widespread use and their
implementations are battle tested no
amount of wailing about watts are going
to make JavaScript go away it's here
it's going to stay
and it's also pointless to have those
arguments history has repeatedly shown
us that technical superiority of a
technology is very rarely enough to
guarantee victory Betamax of VHS windows
and os/2 AC and DC electricity as long
as there are two options that meet basic
requirements the social structures and
power relationships around a technology
are much more important than the
technology itself for ensuring success
thank you
the good news here is that python has a
compelling story when it comes to these
network effects firstly there is a huge
breadth of domain knowledge that's
encoded in Python through projects like
numpy side pipe Jupiter biopython Astro
PI there is a wealth of scientific
expertise in our community raspberry Pi
grukk Learning are leaders in the world
of computing education this isn't just a
web community or a browser community the
attendance of this this conference the
mini conferences on Friday are clear
demonstrations of that and it will take
but it will take a long time for other
language communities to develop
analogous tooling the Python community
also has very strong social credentials
the Python community has been an
industry leader in improving the
participation of women and people of
color different ethnic backgrounds into
our tech communities Python and Django
were amongst the first communities to
offer first programming communities to
adopt codes of conduct as standard
operating procedure initiatives like pi
ladies and generals has made have made
amazing contributions to the
participation of women in our industry
in web design circles it's taken a very
long time to convince people that
accessibility is something that's worth
paying attention to
but it turned out that if you focus on
accessibility not only can the Deaf and
Blind a neuro atypical access your
website it improves the experience for
everybody else as well there's a direct
analog here with a social leadership
position that Python has taken yes we
have adopted codes of conduct because
there is a it is a clear signal to women
and minorities that we want our
communities to be welcoming and friendly
but as a side effect
it means the community is nicer for
everyone a code of conduct isn't there
so that women can punish men it's there
to make sure that everyone including the
men have a pleasant experience in a
welcoming and friendly community
but before I give myself a sprain from
patting us on the back quite so
vigorously don't get me wrong there is
still a long way to go if you compare
where we were where we are today to
where we were 10 or 15 years ago we've
made some great strides I'd like to draw
some attention though to two closely
related areas that I think we need to
pay a lot closer attention to the first
is the specter of burnout in our
community I started this talk Richard
started this morning talking about the
fact of the bulk of work on Python and
Django with a result of volunteer
efforts I've almost lost count of the
number of talented developers around me
who have burned out or come dangerously
close under the load that's been imposed
by this volunteer effort I've made no
secret that I myself went through a
major depressive episode last year
brought on in part by the load imposed
by volunteering I'm a lot better now but
I still got a long way to go this isn't
a problem with an easy solution it isn't
as simple as just telling someone they
don't have to volunteer anymore because
if they're the maintainer of an even
moderately successful project I
guarantee you their inbox is filled with
why haven't you fixed my bug emails
sometimes from people who should know a
lot better the greatest shocks in
society occur when something we assume
is plentiful and ubiquitous disappear
petrol electricity clean water if your
open source project isn't planning for
the day when your biggest contributor
steps down or is unable to continue your
project has a clock on it as a community
we need to institutionalize the
minimization of the expectation of free
labor if you've got a project role that
is going to take resources be it
material labor emotional energy don't
assume those resources will be available
forever in boundless quantities and if
you're a free consumer of those
resources be aware of what you're
consuming if you're a commercial
organization that depends on a product
then and you aren't taking steps to
contribute to contribute to the projects
you use I would argue you're being
criminally negligent to your investors
because you haven't secured your supply
chain
you haven't mitigated a key risk
associated with your technology stack
but it's not just about pointing
pointing fingers at bad projects or bad
users or bad companies as a community we
have established their conditions where
companies are readily able to mitigate
those risks the free software community
has spent a lot of time and effort
discussing the importance of use of
freedoms however they've been almost
silent on the unintended consequences of
that position but when free software is
free as in freedom it is almost
certainly free as in beer as well which
means the task of making an income off
of that software is much higher I don't
want to understand for a moment the
importance of user freedom but to focus
on user freedom to the detriment of the
mental and physical health of the
developers of that software is in my
opinion incredibly negligent how to make
money from free software is a question
that unfortunately doesn't have any good
answers at the moment as a community we
need to have a very serious discussion
about the economic consequences of our
decisions and how to harness the
not-insignificant resources that the
software community has at its disposal
the good news is that there's a possibly
unexpected benefit to facing this
problem head-on finding a way to pay for
the resources we consume we're consuming
certainly helps to stave off burnout but
it has the added benefit that it
broadens the list of people who can do
the work volunteers by definition are
made up by those who have the time to
volunteer if you've got a family or
you've got children or you've got a
loved one who needs care those
commitments take priority as well they
should and they limit your ability to
volunteer you want to address diversity
make sure that you're not just taking
from the pool of people who have copious
free time which broadly speaking means
white middle doing middle to upper-class
anglo-saxon men aged sixteen to thirty
if you're someone who uses open-source
don't just take give back in tangible
ways either with hard commitments of
time or with cash that organizations
like the Python Software Foundation or
the Django Software Foundation can use
and this is incredibly important if you
are a large organization with
extraordinary resources at your disposal
who derive immense benefit from open
source and Volant
projects now you'll notice that in this
talk I've spent almost as much time
talking about the soft for one of a much
better word aspects of the problem we
face rather versus the hard technical
problems the technical aspects of a
computing problem almost always get the
most attention but they're also the
easiest ones to solve they either have
an answer or they don't but open source
projects are ultimately about
communities of people with aligned
interests acting collectively this means
issues of communication collaboration
identity social justice inclusivity
funding these are all intertwined with
the technical aspects because without
those soft aspects the technical aspects
can't be solved and these challenges
don't have simple answers who would have
thought humans are difficult this is
something that has taken the tech
community a long time to learn we've
still got plenty we have to learn and
it's going to take a long time to
institutionalize best practices the key
though is to pay attention to it
whatever software community or
communities you have to participate in
keep your ears open your mouth shut and
look for ways to improve the social
aspects of your project and part of that
means acknowledging any kind of
privilege you have when I say that I
don't just mean white men either
women can have privilege too so can
people of color if you don't believe me
go have a look on YouTube for saranya
barracks keynote talk from django con
u.s.a a black woman from the united
states she gives a much better
explanation than I could ever provide
about what privilege truly is so what
does the future hold for Python well I
don't know I've outlined what I see to
be the threats and opportunities but I
am only one voice but I do know that if
we want Python to continue to be a force
in the world of computing we can't stand
still we need to prepare for the future
whatever we perceive that future to be
personally I'm intending to keep working
on Beware the umbrella project that
covers Vulcan Batavia row be a robust
briefcase and many other tools that are
necessary to get Python working in the
hands of end users and to enable those
users to get involved in writing their
own apps any of those projects sound
interesting you'd like to get involved I
appreciate any help there's plenty to do
and I've got an open offer to mentor
anybody who wants to get in
even if this is your first time
contributing to open source projects and
again the challenge coin for anybody who
does get involved a call to action
without funding this is going to
continue to be a hobby project I'd like
to see it to become a whole lot more I'd
like to see beware become a model for a
new style of financially viable but also
socially responsible open source
organization
I am currently exploring options to make
this happen one of those options is to
crowdfund if you'd like to be notified
as those plans evolve I'd encourage you
to visit this URL sign up for the
announcement list there if you're a
company with an interest in
cross-platform mobile sign up the
mailing list or contact me directly I'm
certainly open to the idea of commercial
sponsorship various arrangement so come
talk to me all of this ultimately comes
down to the old quote from Pascal
fortune favors the prepared mind if you
want any project to be successful or
remain successful you need to plan for
that success it took years for Python to
become an overnight success django
certainly benefited from some early
momentum being in the right place at the
right time but true success took years I
have personally benefited from being
part of a large successful project like
Django I'm at the early stages of what I
hope will be a similar journey with
beware and both of those projects
wouldn't have been possible or at least
would have been significantly different
if it wasn't for the groundwork that was
laid out by Python and the Python
community I'm very keen to make sure
that groundwork doesn't go away it's
taken 25 years to develop it and it
would be a shame if we had to develop it
all over again simply because we didn't
pay attention to the way the world was
changing around us and with that thank
you very much
I'd like to thank Richard</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>