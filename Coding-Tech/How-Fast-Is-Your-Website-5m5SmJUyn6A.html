<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How Fast Is Your Website? | Coder Coacher - Coaching Coders</title><meta content="How Fast Is Your Website? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How Fast Is Your Website?</b></h2><h5 class="post__date">2017-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5m5SmJUyn6A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">but start with I want to ask you a
question of how fast is your website
there may be the website that you're
building today for a customer or for
your company that you work for what does
being fast even mean is it how long it
takes to load but in what context is
that may probably our users all have
different context when loading in it
this fast being fast probably means many
different things in many different
contexts and how do you go about
measuring that performance for years
we've been searching for the golden
performance metric the one that we need
to optimize our websites for but does
that even exist
should we have a single metric to
ascertain how fast our website loads of
course but loads should just be an
experience it's not a single point in
time and so I would argue that there
shouldn't be a golden performance
metrics and there definitely isn't one
of them at least that we should be
optimizing for but reality the most of
the traditional metrics have almost
nothing to do with user experience the
first bites the document complete how
many requests I send out the why or how
large my files are and we start to
optimize our website just for the sake
of optimizing our stack but none of
these correlate to the load experience
or actually what the user came there to
do you know on a news article a website
that might be the article that I came to
look for an e-commerce it might be the
thing that I want to buy or and search
results it might be the thing that I was
actually looking for that is the user
experience and we should be thinking
about how long it takes for that to
happen rather than how long we actually
built our page load is an experience
there is no single load metric but
luckily times are changing and we're
seeing a new rise of metrics folk coming
out that focus on human-centered metrics
focus on user experience the thing that
the user actually came to your website
to do and the great thing about these is
as we start to optimize them for them
every optimization we make to a human
centric metric is ultimately going to
improve the user experience of your
website so things like the speed index
the first meaningful paint which we're
going to look at today time to
interaction and I can't stress this last
one enough custom metrics specific to
your own KPIs and your business needs
and that context of why the user
actually came to your site in the first
place so what is TT FMP or the first
meaningful paint and what does that even
mean so but simply first meaningful
paint is the time when a page is primary
content
I either think the user actually came
here for appeared on the screen not when
we started painting pixels to the screen
the thing that they came here for so
maybe it's the headline of the news
article put more detailed is the first
paint after which the biggest above the
fold so if you imagine a mobile phone
this is the fold the viewport the first
viewport because highly likely that the
thing became the user came here for is
going to be in that above the fold
layout change we will talk about layout
in a bit and Eric did a really good
intro to layout for us as well and most
importantly when web fonts has also
loaded because I could paint lots of
things to the top of the screen and
cause lots of layout but if the web
fonts haven't loaded and they here we
all like to add lots of web fonts to our
pages these days much to my disgruntle
meant when they've also loaded because
there's no point if the user came here
probably to read something we also have
to wait for them and so this is probably
represented originally and first
meaningful paint was coined by some much
smarter folk than I at Google last year
and they outlined their methodology
about how you can go about ascertaining
this metric in a white paper I will
share the slides later but visually this
is taken from the white paper and the
graph at the top you can see on the
y-axis its the amount of layouts objects
performed layouts so as Eric explained
to us that's the x and y-coordinate of
the element and its width in it height
when we're creating that layout tree and
the amount of those objects that
happened correlate it to time on the
Google search results page here so as
you can see at one point five seconds
Google do something very clever that
they flush the head of their document
for the search results before they've
even sent your search query back to the
database so you get a very fast
perception of loading but actually the
the user came here for wasn't till one
point nine seconds when the search
results came in and you can see how that
direct directly correlates to the amount
of layout objects that are actually
painted to the screen and it's at this
point is our first meaningful paint and
that's a much more meaningful metric to
our users and their experience then say
the start render about 1.5 seconds again
it might be better rigidly represented
like this this is the ft.com home page
let's play a little game here now that
we have an understanding of the first
meaningful paint metric where do we
think it is is it 3.5 seconds four
seconds come on shouts about five
seconds put your hands up with where do
you where do people think put your hands
up four four four point five five five
point five so I think most people
thought is for they're on this it's
actually five seconds on a 3G
emerging-market device and we'll find
out how we can go about getting our own
metrics and unfortunately we haven't yet
exposed these new human centric metrics
yet as JavaScript API is although
there's a lot of work to do that so at
the moment the only way that you can
measure your own first meaningful paint
is using Google's lighthouse tool which
they've kindly open sourced and
originally lighthouse was built as a way
of testing your website I get out your
progressive web app against best
practices for progressive web apps but
then we soon realize that the audits
underneath the hood that it was doing
are actually very good for any web site
so I urge you if you want to then work
out what your first meaningful paint is
now you can either download it as a
browser extension or use it as a CLI
tool so you could integrate it as part
of your CI builds and there's a there's
a whole suite of audits that it runs
they're actually very good at
ascertaining how fast your your and your
per state perceived speed is if you're
interested specifically in this metric
and the rise of its sister metric such
as time to interaction and hero elements
I strongly urge you to watch this video
from Google i/o this year it's all about
how we the rise of user centric
performance metrics and how the roadmaps
for these are changing in
we are going to try and integrate these
types of metrics into our browser
JavaScript API okay so now we know what
the metric is let's have a dive in and
think about how we can optimize for this
metric and to do this we're going to
apply a suite of optimizations in
experiments to a real website I think
it's very easy to break your budgets and
prove things using a to do MVC
application but that's not the type of
application that we all build on a daily
basis does anyone actually builder to do
and we see your website for their their
day job no so to do this we're going to
use a real-life website which we're
going to use the Financial Times home
page and a disclaimer here they have a
very very good and talented team that
focus a lot on care a lot about the
performance of their website and and I
again at this game art I used to work
there so they've given me permission to
use their website as an example and most
probably I'm really sorry for the
tourism a photo bomb here so you
definitely desert doesn't deserve to be
on this stage although she does look
like she is a real-life emoji caricature
like and it's just a disgrace to my
nation so I'm very sorry for that
so each test that we run we're going to
run through web page test who here has
used web page test awesome it's like the
number one tool in the performance
ninjas toolbox but the reason why I've
chosen to run our test through this is
two very important things is the first
one is that there is a real device at
the end of this form and contrary to
popular belief the shiny iPhone or
Google pixel that you have in your
pocket right now is not the average
phone in the world in fact the average
phone in the world is a very low powered
to mid end Android device so here a moto
G we actually have Moto G's running
physical devices running at the end of
this so you can run your websites
through them and it allows us to shape
our networks to real network conditions
the LTE that you get here in New York is
again not the average mobile connection
the average mobile connection in 3G
emerging markets it's a half of four
100 milliseconds round-trip time for a
packet so that takes 400 milliseconds to
travel between the client and the server
and back again just for one bit of the
request so imagine your request is made
up of lots of round trips we're going
straight into the seconds there so we
need I can't stress this enough to be
testing on real devices with very poor
memory and CPU performance such as a
moto G and real Network conditions or
that life I that we will actually do
experience on it on a daily basis but
you need to be asking yourselves these
questions not just the budgets that I'm
going to set today
where are your users based what is their
device landscape for the website that
you're building today no one website
that you build is going to have the same
characteristics or answers to these
questions in what context are they using
your website a lot of people sometimes
tell me oh no but I build a desktop
application and therefore they've only
got a single context and over that that
is a complete there are
multiple contexts for every website that
we build I use the FT calm on the train
going through in and out of network on
the tube in London on my on my mobile
device but then I use my highly powered
MacBook Pro on my t1 connection in the
office at lunchtime these are multiple
connect contexts for the same user and
again this comes up all the time here
what did they actually come here for
what is the user experience that you
need to be optimizing for and delivering
your site as fast as possible so in the
case of the ft.com homepage we're going
to aim for a budget of a first
meaningful paint of three seconds on a
3G emerging-market Network condition two
seconds on 3G and one second on cable
using a moto G to do this but again
can't stress this enough
you must be creating your own budgets
and setting them and testing your
websites against your own budgets not
just taking mine as a lion in the sand
so let's so that we can measure the
impact of every optimization we take to
try and improve our first meaningful
paint we first need to set a baseline
and so to do this we're literally going
to have a template like this this is
doesn't get as simple as this is a
vanilla website as we've all been
building since 2006 we have a HTML
humans that in the head element we have
a link and I went to a relative
attribute of stylesheet to a main CSS
file just one CSS file reference
normally in the head of your document
and a document containing all the text I
don't care how your CSS was authored
whether or not it was CSS in j/s like I
hear lots people want to do these days
or if you use webpack to bundle it all
as long it's a single concatenated file
and all of my content in the document
that is our baseline so if we were to
run that through webpagetest it would
produce a network waterfall like this
but how W use network waterfalls on a
daily basis or have you ever seen one
before don't worry if you haven't so
just a quick explanation on the y-axis
we have the requests that the browser
makes in the order in which they
requested therefore probably the
priority and on the x-axis is time and
webpagetest unlike some of the browser
developer tools gives us a nice
breakdown of mind type here using color
so we've got HTML blue CSS is green
purple is images JavaScript is orange
and font is red and for each one of
these Network requests it gives us two
color so if you look at the HTML it's a
light blue that was when the request was
sent and the time that we were waiting
until we got the first byte and then the
download time as we received all those
bytes and it gives us some markers such
as the start render event it's not the
first meaningful paint but it's a good
indication of when we start painting as
this green line so that's how we read a
waterfall for Noah paint so if we were
to run our baseline test in webpagetest
against our budgets we'll see that we
have an 8000 milliseconds first
meaningful paint on cable or natori on a
3G emerging-market on a moto G which is
way past the budget we set so let's try
and break that budget our first
experiment is going to be to inline our
critical styles required for that above
the forward rendering and some of you
may have heard of this technique before
I've been speaking and advocating about
the technique since about 2014 at this
very conference actually but for those
of you that don't know let's have a
quick recap and to do that we have to
look
critical rendering path of the page
which is the single path a browser must
do to be able to paint to our screen
again Eric did a very good job
explaining what the DOM is the CSS on
and the render tree just beforehand so
first from the point at which I use and
navigate so when they click on that link
maybe on a Google search result page to
it loading we have to perform the
network request so as a get request for
our index.html of ft.com
we then get we start to receive the
bytes now HTML has an amazing part of
the specification that allows it to be
parsed incrementally we don't have to
wait for all of the bytes to come in
down the wire before we can construct
our document object model what can
happen incrementally as the bytes come
through so we build a Dom we find that
link element that we have in the head of
the document so we now have to stop and
go back back to the network and perform
the networking request for the CSS file
now unlike HTML CSS can't be paused
incrementally because if you were to
paint at the beginning as you are you
were still bytes were coming down the
wire there made because of the nature of
the Cascade there may be a star
declaration at the bottom the father
overrides one at the top and you'll have
some horrible stuff like this going
around your page for that nature CSS is
render blocking and so we have to wait
to do we've created some idle time on
our browser main thread here waiting for
that networking to happen so let's note
that also imagine that I'm on a train
and I'm on Twitter and I follow a link
to the after comm and then I go into a
tunnel or my trains Wi-Fi cutouts now
I've been given all of the content I
needed as because I've downloaded all
the HTML file but my network requests
for my CSS has failed and so even though
we've got all the content where's it
blocking waiting on this white screen of
Doom that you've probably all used to
and they're a little thing down the
bottom saying waiting we've created a
single point of failure by separating
our CSS from our content this goes
against everything that we've been
taught of styles in style sheets and
separations of concerns and now we don't
have enough information so what if we
were to inline the critical Styles to
required for our first meaningful paint
in that viewport into our HTML document
and declare the rest of the CSS as
asynchronous
tell the browser you don't need this yet
and here we now have a critical
rendering path that looks like this
there's no longer a single point of
failure on our CSS so that's what it
looks like in back to our experiments on
ft.com now we have a style element in
the head of our document we've declared
the rest of our CSS is asynchronous in a
separate file to do this I'm using the
filament group's load CSS now the
implementation details don't really
matter here it's more about the concept
of inlining and declaring the rest as
acing hopefully browsers are going to
allow us to have linked elements during
actually in the body of the page so we
don't need to do this anymore but people
like chrome Jake still need to sort
themselves out when it comes to this so
we're left having to use a technique
like this at the moment but again don't
stress about the implementation details
so if we were to look at our baseline
waterfall again notes where to start
render line is because we've had to wait
pause the HTML document we found the CSS
file we have to wait for all of that to
come in before we can construct the CSS
object model and the render tree and the
layout box and then we can paint by
inlining our Styles note the difference
here of we've been able to paint
instantly and we have declared the CSS
as asynchronous we've tricked the
browser into thinking you don't need
this and I've given you all the styles
now we have a much faster paint so you
can imagine what this is probably going
to do to our first meaningful paint so
we've managed to improve or fast
meaningful paint for that nice user
experience by 63% now and that's one
thousand three hundred milliseconds on
cable on a moto g and three thousand two
hundred milliseconds so we're getting
closer to our budgets already and with
all good things in life there are some
pros and cons to this obviously the cons
is that we can't it's not cashable every
time we update our critical CSS because
it's embedded within our HTML we're
going to be in validating the cache of
every single article on the ft.com and
that's in the hundreds of thousands
every time we do that with sending the
bikes down even though we could the
browser could cash it in there HTTP
cache but because it's not a separate
object we're not benefiting from that
and it's very hard to maintain I've
worked on some very large websites and
automating this process
is not a solve problem something I'm
really interested in so do come and talk
to me of that if you're looking into how
to do that but we no longer have any
blocking resources and we've eliminated
that single point of failure that CSS
brings so now that we've been able to
get our styles down and paint as fast as
possible and let's have a look at how we
can prioritize that other resources that
are required to let our users interact
with our pages and do that thing that
they came here for are you your critical
resources now I want to have an exercise
if you can think about now is what are
for the website that you're building
today what is the critical resources
required if you could get rid of all the
other resources but for that one thing
that the context that the user came here
for can you think about the two or three
resources you need
I think it's actually much harder than
you think probably to go about that
exercise so let's do it together let's
identify the critical resources for the
st.com homepage do we think it's the
logo yes no is it the font yes if we
remember the the definition of the first
meaningful paint is we have to wait for
web fonts is it the hero image of of
Theresa May emoji face no okay
so fortunately again lighthouse has got
our back here we don't need to do that
exercise at all we can automate the
process of it and they have an audit
called the critical request chains so I
can run ftom home home page through
lighthouse and here it's telling me that
we have a critical question of five
assets so it was actually the logo for
the editor for our navigation it was a
lot of our custom web fonts as many of
them and it's our main CSS file so we
can automate this process of identifying
what our critical resources are and then
try and prioritize and if you take away
one thing solely one thing from my talk
today please let it be this that you
need to identify your critical resources
try and eliminate as many of them as
possible if they do they really need to
be there and for the ones that are left
prioritize their delivery and optimize
those files so they are small as
and that is it that is the secret to
having a very fast first meaningful
paint as you prioritize your critical
resources eliminate the ones that aren't
there and optimize and prioritize the
delivery of the ones that must be there
so if we were to remember the
methodology for first meaningful paint
its that web font we have to wait
blocking for the web fonts to load ie
before we have any text on the screen
before we get that metric but view to
look at the waterfall here font a
prioritize very low down in our
waterfall much lower than some of the
images that are below default and why is
that if there's such a critical
important resource for our user
experience why are they prioritized so
low and to do that we have to go back to
our critical question and understand how
the browser's work again so we go and
fetch the HTML then we go and fetch our
CSS and as Eric explained the CSS object
model that's a tree like structure just
like the Dom get combined together so
the CSS object model will look something
like this it will say oh we have the
root body then we have a div then we
have a paragraph and the paragraph has a
font custom font above one and a color
of red too but the CSS object model will
also say oh but that paragraph is
displaying none so when the CSS object
model is combined with the Dom that
paragraph will not be left in the render
tree the render tree is only the
elements that are going to be painted to
the screen and why did I go on this
digression here is is at that point and
only that point during the render tree
construction that the browser will
initiate the fetch request for a font
because by their pure nature fonts are
very large and expensive files and if I
was going to not show my paragraph with
red texts of custom font 1 then why
should I go and perform the networking
for it that could waste a lot of
resources and so front unknown as a
hidden critical resource and the reason
why they're hidden is the browser will
not find out about them until the render
tree so we've wasted thousands of
milliseconds waiting because the browser
doesn't know about won't dispatch the
font requests then even though there's
such a critical reader
to our user experience so fortunately
the web performance working group I've
got our back here again
and they've defined a new API called
preload and what pre lays allows us as
authors to do is to indicate to the
browser what are the critical or hidden
sub resources especially like fonts that
may be hidden from the browser into a
much later point so that the browser can
then go and prioritize the networking
for those requests so to put simply it
provides a declarative fetch primitive
that initiate an early fetch was kind of
up to the browser if it does initiate
that request and it separates most
importantly it separates the fetching of
that resource from its execution so this
is also very very powerful for things
like JavaScript if you wanted to load a
secondary async webpack chunk or bundle
or your react vendor file this is
amazing because it allows us to go and
fetch that but the JavaScript won't be
executed which will help us with our
first meaningful paint in terms of
interaction so this is what it looks
like we now have three new primitives
one is the link element in our HTML we
have JavaScript we can dynamically
create these and I think this is really
powerful that's often overlooked in the
industry at the moment with preloader so
if you can imagine that once my page is
loaded and the app has booted in I have
a user that's hovering over a carousel
and when they click on that carousel
it's going to open up loads of images in
a carousel so you can imagine as the
user hovers over the button before they
even click it you can dynamically inject
lots of preload elements to go and fetch
the JavaScript or the images required
for that so when they do click it it's
going to be an instant lightning
experience so no we're not enough people
are using the dynamic version here and
my favorite is obviously the
often-overlooked link el header that we
can have on a response of our HTML
response so when I perform the get
request for the st.com home page the
HTTP response of that can be decorated
with link headers saying here are my
critical resources and so that's a
technique that I've chosen to use for
our example of vestido comm here the
five or four critical resources that
lighthouse identified as my critical
question I'm now decorating my HTML HTTP
hurry response with them and using the
link header and there's two important
points to note here's first remember
always that fonts need to be declared as
cross-origin because the browser still
deems them to be which is a bit of a
crazy thing but it's the truth
and the no push attribute I just want
you to remember that for later on but
this is how I can decorate my HTTP
response of my HTML file to say here are
the critical resources so again if we
look back at our previous example you
can see where the fonts are they're
sewed low down in the priority here and
if we just by applying our link preload
headers look at what that does to the
prioritization of the fonts and so
hopefully you'll start to realize what
this is also going to do to improving
our first meaningful paint metric we've
been able to prioritize the delivery of
those resources and so now using our
preload technique we've hit our budget
of 1,000 milliseconds on cable and we're
very close on 3d on emerging markets of
3,100 milliseconds that's a 65 percent
improvement from our baseline but again
it has some pros and cons it allows us
to indicate those hidden resources that
browsers might not know about but it's
really easy to create contention and
congestion on the network you can
imagine a developer will just go okay
I'll decorate all of the images that I
have on this page in my link headers and
the browser's going to go and try and
request them all at the same time and if
you're going to do it either by the HTTP
or the HTML version it requires some
custom server logic to do that
decorating of your resources so we could
just stop there we've improved our first
meaningful paint now by 65% from our
baseline but surely we can do more and
one such technique is HTTP twos server
push for the first time now in over 20
years that's how amazingly hates TTP
specification is that they didn't really
need an update for 20 years we have a
new version of the underlying transfer
protocol of the Internet and I could do
a whole talk on this subject and I have
and I urge you more to to go and check
it out who's interested again you just
put
hands off again that lead at the
beginning how many people using h2 in
production here so yeah he was really
right it is only about eight to ten
percent of you so I urge you to go and
have a look so let's go and look at our
traditional request and response flow
again for that web page first the
browser performs a get request the
server then probably has to process that
request it has the work go and do some
templating and go and make some database
lookups to generate the HTML response it
then sends that back for the 200 we then
start to parse that document build up we
find a CSS or JavaScript being
referenced and we have to go and perform
the networking for that again so but all
during this time when the server was
processing there was a lot of idle time
on the connection we weren't using the
connection at all we where we could have
been sending bytes back and forward so
what if the server could predict that
the next resource that you're probably
going to request is that main dot CSS
file and then push or flush those bytes
down the wire Weist
the server is doing is think time and
hates me to cause that a push promise so
now HB two instead of having multiple
TCP connections open we now only
maintain one stateful TCP connection
between the client the server and we can
multiplex we have a new duck binary data
framing layer that allows us to
interleave different frames and so hates
to call this a push promise frame so all
it is is a very small data frame that
gets sent down the wire saying I am
going to send you the main dot CSS file
don't request it so you're making a
contract between the client and server a
promise we're saying I'm probably going
to send you all these bytes don't
request it and so we can now
programmatically do this but the
semantics that we've chosen in the
industry is to use our friend the link
preload header to decorate all of those
resources that we want to be pushed and
note remember I told you earlier on
about that no push if we remove that
declaration any HTTP to a server that's
enabled with server pushed potential
we'll think all of them now the ones
that do will use the link preload header
as that indicator of I want you to push
this resource along with my HTML
and so going back to our sta upcoming
zone example now because we don't we no
longer need to inline our style so we're
going to get that benefit of it being
cached so we have actually replaced the
inline style declaration with a critical
CSS file that we are pushing along with
the document and then we've made again
made our non-critical styles acing so
let's take a closer look at what's
actually happening on the network
connection before we apply this
optimization so we make the request
we've got some idle time at the
beginning drinks to have a think time we
then get our index.html file because
we've inlined
this is before we apply the optimization
we have a very fast start rendering a
first meaningful paint and first
meaningful paint is way whilst we're
still waiting for the non-critical
styles to come in this is great but you
may be surprised what happens when we
apply our technique and push the
critical styles and don't inline them
we've actually pushed back our start
render in our first meaningful paint by
quite a dramatic amount and why is this
so we haven't used up that idle time we
got to the h-index that HTML and then we
got our critical Styles even though they
were pushed and why is this we're not
using that server think time that server
push was being the holy grail that we've
been promised that it would be and to do
this we have a bit have to look at a bit
of an understanding of how HTTP to
servers work they use something called a
prioritization tree to determine which
the order in which it will flush bites
down the connection and even though we
told the server to push our critical CSS
because we did so doing a link header on
the response of our HTML file the HTML
had already come we're not using that
server think time so now the takes me to
server has all of the HTML and all of
the CSS and the prioritize a and the
spec of the prioritization the theme is
that HTML should but I quite rightly
have a higher priority than CSS so it's
known to flush all of the HTML bytes
down before it does the CSS which is why
we got them in the wrong order and just
distress this behavior may be different
depending on your HT to server
implementation but the majority of them
work like this and we we don't have any
yet apart from Firefox that are actually
doing correct prioritization in the
opposite direction so let's look at our
waterfall here now because we even
though it's pushed the you can see that
we had note we don't have a light screen
on our critical CSS file because it came
asked I hope smell bytes and previously
our HTML bytes contained all of our
Styles we've actually delayed our first
meaningful paint and so that's only a
43% improvement on I ft.com homepage so
we've actually had a negative effect by
using hex ep2 server push now it's part
of my job is I have to do research of
things like this and I was very happy
that two weeks ago Jake wrote over an
amazing blog post detailing all the
research that I was meant to do myself
on how browsers are interacting with h2
so I urge you if you're interested in
this to go and read this is extremely
detailed blog post going into all the
intricacies on most of the how browsers
are behaving with server push at the
moment such as things like there's weird
things that they're not correctly
sharing the server push cache in between
requests or sessions and so you actually
get a much worse effect there than you
were hoping for but the question that I
want to pose here though is the problem
here is that is indicating which
resources to push via a HTML response
that with the HTTP response sorry
using decorating it with a link preload
header in fact much too late because
then the browser would the Katori the
server will have all the information it
already needed so we're not utilizing
that idle connection time so this how
can we really achieve that holy grail
that push has has been promised to us at
and this is what I firstly were calling
async push so let's take a look at our
network utilization again and remember
that server think time whilst it was
generating the templates that is the
holy grail of where we really really
want to be pushing and so a much more
common architecture these days is that
your HTTP server will be decoupled from
your application server so think about
say if you have a node server that's
actually generating your templates it's
highly likely that you'll have something
like n Genet or Apache
or CDN or load balancer sitting in front
of your application service and it
because of this architecture it allows
us to decouple the HTTP to server
pushing from the application generation
and so let's have a look here now if we
have programmatic access to our network
connection that's how we'll be able to
flush bites down the way and again and
my stress the implementation it doesn't
really matter here it's more about the
concepts of what we're doing so here
we're using knows HC b2 module and you
hit imagine this is an express like
middleware Handler the first thing we're
doing at the top of the request handler
is on our open connection is we're
pushing the CSS down way before we fetch
data from a database or render any
templates we're using that idle
connection type so if we apply to this a
we're to apply this technique to the
ft.com you can see that we've reached
our holy grail here that our critical
CSS is during the light blue phase the
think time the idle time of our HTML so
now the browser has all of the
information that it needs before it's
received a single HTML byte and we can
have that instant fast user experience
that we've been hoping for
and so with async push we've been able
to have our best improvement of 66
percent of our first meaningful paint
now again it comes of some very Pro some
pros and cons is we the pros are we
using that idle time but it's really
easy to create content in our network we
only should be pushing for that to be
our CSS or our core javascript bundles
of window only we're not doing
server-side rendering there's limited
availability for this your architecture
depends on it you have to do some custom
server logic so it's hard but I think
this is an area that I'm really
interested in seeing both clients and
servers improve on over the coming years
and H do push is very very hard to debug
if you want to find out more about async
push exactly we've released a blog post
last week about how how we're doing
async push again the implementation
doesn't matter it is the concept of of
using async push but what about the
repeat view we've talked here a lot
about that first
load experience we haven't talked about
how we can optimize for the repeat view
and some of the major problems here is
like the client will already have most
of these assets that we're pre loading
or trying to push to in their HTTP cache
and so I want to show you how new
technologies such as service workers and
the purple pattern is going to solve
this but I have time but fortunately
both liza and jake liza today is going
to be talking about service workers in
jake about how we can use them to
optimize loading for repeat view at this
very conference so they hopefully
they're going to go hand-in-hand with
this talk and we talked a lot about CSS
and fonts and other critical resources
we haven't talked about javascript and
we've talked about that first meaningful
paint but a lot of people are starting
to use react and not do server-side
rendering but the interesting thing here
is that all of these techniques even if
you're using something like react can be
applied to optimize the delivery of your
javascript so if you if that is your
core resource then yes you should be
using a link preload or push to deliver
those assets going back to my point of
the one thing to take aways in this talk
is identify what your critical resources
are it might be your react vendor bundle
and prioritize the delivery of that also
first meaningful paint has got a sisters
and brothers of many other metrics
specifically something like time to
interaction what we're measuring how
long it takes for our JavaScript to boot
up and the user can actually interact
with and again tools like lighthouse
expose that data for us so using a
combination of techniques that we've
learnt today and we've applied to the
ft.com we've been able to achieve our
goals and so let's briefly compare
actually what that feels like as a user
experience again this is a human
centered metric so we have the baseline
at the top all the way down to a sink
push here but that's probably better it
represented as how the user actually
experienced it so see this is on a free
g emerging market on a moto g again feel
how fast the push a sink with preload
was compared to our baseline and whilst
we've got a strong toolbox of API is
emerging that we've seen today there's
definitely a plethora of api's that are
coming out that i really
sytze me and we still got a lot of
problems to come but fortunately the
future is looking bright in this area
the first one being is that we outlined
the biggest weakness of server push was
that we're using the link preload header
to decorate what we wanted to push and
this is far too late in the connection
state and this is where my colleague
Kazuo has suggested the 103 status code
that's now in IETF working draft
specification and 103 allows a server to
flush an early HTTP response whilst it's
still generating your actual file that
any intermediaries or a browser can then
use that information so such as a
preload header to go and warm up any
caches that in these two will go and get
that before the server responds it so
it's a secondary response one if 100 is
the information status range if none of
you knew that I definitely didn't know
that until a couple of months ago and I
think this is going to be amazing that
making much more use of idle times and
most importantly intermediaries like
CDNs that enabling us to take advantage
of this type of state and the second one
that really excites me even more than
that is amp cache digest we mentioned in
the push example again that is very easy
to waste bind with once I've pushed a
resource to the client on the second
request they've already got it in their
HTTP cache so there'll be no point in me
pushing it again but as I hate to server
I have no knowledge of what the client
has actually got in its HTTP cache and
this is what the client digest
specification is going to solve so it's
a new data framing again over HTTP to of
as the client initiates the request with
the server it also sends along another
payload containing a digest of all of
the resources that it has in its cache
for that origin obviously because of
security it needs to be for that origin
then the server can choose to use that
information okay all right I'm not going
to push that CSS file because the
clients already got it in this cat and
these two new specifications combined
together is going to be really really
powerful and allow us to be much more
efficient in how we utilize the
bandwidth and deliver assets to our
users
so it's just truly been a whirlwind tour
of asset loading in the browser and I've
only kind of spatula the reset the
surface sorry on some of the techniques
but I hope I've given you a suite of
toolbox and techniques to apply to your
websites when you go home and please
please do get in contact with me on
Twitter if you've applied some of them
and they're working out well for you but
I just wanted to leave you with some
points that resource loading in the
browser is hard it's much harder than we
probably thought it was bandwidth is
definitely underutilized on the network
with wasting loads of time in the way
that both browsers and services
architected and we're not using our
network utilization as much as possible
especially on mobile so identify your
critical resources in your request range
use tools like lighthouse to do that
once you have identified them use API
such as preload to indicate the critical
resources and hidden resources to the to
the browser push things like critical
CSS or your critical JavaScript but only
on that first view and only we're an
idle time to use tiny news techniques
such as async push to do that but most
importantly always be testing there is
no single context as I hope I've got
that point across to you today every
website is different every critical
question is different you need to be
doing these testing on real devices on
your own websites thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>