<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Turbolinks: I Can't Believe It Is Not NATIVE | Coder Coacher - Coaching Coders</title><meta content="Turbolinks: I Can't Believe It Is Not NATIVE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Turbolinks: I Can't Believe It Is Not NATIVE</b></h2><h5 class="post__date">2017-11-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Xkjo7iKkQlY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Sam Stevenson you might know me from
some of my open source contributions I
work on a lot of projects are bein pal
and tricks most recently that was one of
the original rails core members back in
the day though I think nearly all of my
code has been deleted or at least by now
I hope I work for base camp and last
year we launched an all new version of
base camp cloud base camp 3 we created
it in 18 months from the initial concept
through dozens of designs and iterations
it changes and it's a it's a big app
that's over 200 screens and we shipped
it in 18 months on five different
platforms simultaneously so desktop web
browser mobile web browser an Android
Native Client an iOS Native Client and
email and we did all this with a tiny
team but basically we have six rails
developers to Android developers and to
iOS developers and we also built three
open source frameworks during that time
period tricks which is our rich text
editor action cable which I'm sure
you're familiar with in rails 5 and also
turbolinks 5 and this all sounds kind of
unbelievable when I say it then we
managed to do all of this but really
turbolinks 5 was a secret weapon that
led us to it and it's an entirely new
version of turbo tanks and it's one of
the banner features of rails 5 and
that's what I'm here to talk about today
so how many of you are familiar with
turbo links anyone right it's
thing you have to disable every time you
started no but seriously it's it's that
thing that breaks all your jQuery
plugins no turbo links is misunderstood
and to understand it you need some
context and that's what I hope to give
you today because I think it represents
a philosophy of web development that
deserves our attention I've been a base
camp for ten and a half years now which
is a small eternity in tech years and
being at the same place for a decade has
been really interesting I've had the
opportunity to go deep on a lot of
interesting problems and see the effects
play out over many years every once in a
while I think he can help to take a step
back in and look at where you're going
and where you've been and things were
really different when I started do you
guys remember what web development was
like before rails the only way to make
real software was with j2ee I found this
this diagram of 2004 era best practices
this is j2ee
it's beautiful when its simplicity
really and then of course on the other
end of the spectrum you had PHP but
rails came along and changed all this
for the j2ee developers it throughout
all that ceremony that said hey look
this can be a lot simpler and for the
PHP folks it said here's some structure
that makes sense and it helps you avoid
writing the same thing over and over
again in slightly different ways and I
think in some ways this period was the
Golden Age of web development if you
ignore the browser situation at the time
because we could embrace the
statelessness of HTTP and we could
deliver a fully rendered UI on each
request and response cycle so this is
the full request response cycle I think
it's one of the best one of the best
features of rails and then web apps got
more ambitious we weren't happy with the
performance of the UI built on full page
loads so we started building single page
apps and instead of each request
returning a full HTML response now he
started booting the app with an empty
page and the page had some JavaScript
others JavaScript made JSON API requests
so we made the server-side accept and
return JSON when we move the traditional
responsibilities of rendering the UI
completely into the client and everybody
agrees this is a good idea right we've
got rails 5 with rails api and you need
an api anyway in your application so why
not consume that yourself plus we want a
decoupled presentation from data and
decoupling is good right but eventually
we weren't happy with the performance of
client-side MVC so we introduced a
virtual Dom to minimize the number of
Dom operations we make which is a great
idea the DOM is slow so we should make
as few changes to the Dom as possible
but you know what all that JavaScript
and all those API requests really make
the initial page load take a long time
and all the content on the page is
inaccessible to search engines so we
decided to get rid of the bhoot page and
render HTML instead which means now we
need a JavaScript runtime on the server
we need to make our client-side code run
on both sides and we need the virtual
Dom there too because we don't have a
real dog and now we've come full-circle
and we've really reinvented
we had in 2004 but the complexity is
increased exponentially and we've
introduced literally hundreds of new
dependencies to our applications and the
whole system is now too much for any
single person to reasonably keep in
their head at once you need entire teams
dedicated to managing these subsystems
which honestly is not a surprise how
many of you are familiar with Conway's
law Conway's law says that the structure
of the software system necessarily
mirrors the structure of the
organization that created it
and these client-side patterns and
frameworks that we're using now we came
from Google and Facebook which are huge
companies with thousands of developers
across dozens of teams well guess what
your team probably doesn't have the same
problems as confluent facebook so how
did we get to this point well we were
chasing performance and each one of
these changes that I went over makes
sense incrementally each one made sense
at the time but looking back with into
the compound effects we traded small
performance benefits for a massive
regression in developer ergonomics and
the further we go down the rabbit hole
the more we constrain our future choices
and in 2016 this only tells part of the
picture because you need it native apps
on Android and iOS too so you can
multiply the complexity on that slide by
three and you'll be re-implemented each
one of your app screens natively of
course because you want the best
performance so you're gonna have to
multiply your headcount by three - well
fuck that but if we accept that we need
performant web and mobile apps
how do we reconcile this complexity with
the rails philosophy which says you know
we want to empower small teams to do big
things well what if I told you it didn't
have to be so complex that we could
return to the golden era of the request
and full response model to rendering
HTML views from rails without an
intermediate API layer and then we could
use those same HTML view these as a
baseline for your iOS and Android apps
in a way that still feels native this is
what turbo links 5 gives you all right
it turns your traditional web
application into a single page app at a
high level it intercepts link clicks on
your page and it turns them into e
Jack's requests your server renders a
full HTML response and turbo links loads
that response pulls out the head merges
it in with the current pages head pulls
out the body and outright replaces it
and from the server's perspective
nothing changes but the client adopts
this single process model which means
that it doesn't incur the expense of
reloading and reprocessing assets on
each page change or re-establishing
WebSocket connections which are very
expensive and this gives you a
significant performance boost so how
significant this is a side-by-side
comparison we recorded last night on the
hotel Wi-Fi so it's turbolinks on the
left and full-page reload on the right
oops I'm sorry you guys see it
so this is what we call good enough
performance if you can transition from a
click to the next screen in about 300
milliseconds you're gonna perceive it as
instantaneous anything longer feels slow
but anything shorter is nearly
imperceptible for full page changes but
chasing that kind of performance
requires an inordinate amount of effort
and resources so here's my highly
scientific graph but I think it's I
think it's mostly accurate right we know
from experience that it takes a lot of
work to get on the left side of that
graph but 300 milliseconds actually
getting your rails request to complete
and say 100 milliseconds is totally
achievable and there's a wide array of
tools and strategies to help you get
there like Russian doll caching etags
lazy loading content after the page
loads and all that's for a different
talk but the point I want to make here
is in most cases getting faster than 300
milliseconds just doesn't matter and
what you gain with turbolinks approach
is a dramatically simpler model if you
understand this line of code you
understand the core turbolinks concept
it's understandable because it's just
HTML hTML is easy to generate from rails
it's easy to cache designers already
know how to work with it they can work
directly with your views instead of
making Photoshop comps or instead of
waiting on an API team to expose the
data that they need and when you combine
this approach with responsive design
techniques your design team can create a
single set of views that power desktop
web mobile web and hybrid native apps
and this is incredibly powerful and mr.
Billings v we made it incredibly easy
we've created these iOS and Android
frameworks that let you build native
hybrid outs around her turbolinks but
that and they're designed for what we
call the hybrid sweet spot which means
that in your native app your view
content is mostly HTML but the
surrounding navigation controls are
native and when you want to go fully
native you can do so on a per URL basis
you get to decide and you get all the
performance benefits of turbo like turbo
links in your hybrid app but it's even
more efficient because in a native app
we use a single shared web view that we
automatically move around from screen to
screen so not only do you avoid
reloading assets reestablishing
WebSocket connections and so on on every
page change you also lose use less
memory and by the way the native
animation transition from one view
controller to another is about 350
milliseconds so I'd like to show you how
easy it is to build my OS app using
turbo looks so I'm gonna do it live but
actually it's not really live they're
recording videos but it's not edited so
okay this is base camp 3 it's running on
my development machine so it's not as
fast as it would be in production but
I'm just gonna click around for a bit
you'll see turbo links in action here
and as I mentioned before we use we have
fully responsive views and base game 3
so when I resize the window you'll see
what eventually becomes the phone view
and this lets us share all of our views
across all of our platforms alright so
now let's open Xcode and we'll create a
new project
sorry I need some music okay we're gonna
take everything out of this file I'm
gonna start with a totally bare-bones
iOS app the only thing will happen here
is the application did finish launching
callback alright so we're gonna set it
up as a UI navigation controller app and
for those of you who aren't familiar
with iOS building iOS apps and UI
navigation controller is basically the
stack of views that you are probably
familiar with from Indian iOS app right
so I'm going to create one and assign it
to the Windows room controller and I'm
going to build and run the app just to
make sure that it works it's not going
to look like much of anything there it
is
alright so I need to change the setting
now and that's because iOS 9 ships with
a feature called
application Transport Security and this
is a setting that's on by default and it
prevents you from accessing any non HTTP
web sites basically so for development
we want to flip that off so I'll just
run this command will do that and
obviously you don't want that in
production and now I'm gonna go and just
drop the turbo links framework in the
app and in a real app you're probably
gonna want to use cocoapods
or Carthage or some other package
manager to get turbo links in there but
for now this is the simplest way
and finally I'll import the turbolinks
framework okay
and we'll compile and run okay it still
works now we're going to point
turbolinks to our web application and so
to do that we're going to create a
session and the session is a turbo is
session comes from the turbo links
framework and it were constraints moving
that webview around from controller to
controller we're going to define a
function called visit it accepts the URL
and what this is going to do is create a
view controller it's going to push it on
to the navigation controller stack and
it's going to tell turbolinks
to visit which means load the web page
and now we're going to need to make an
initial visit when we start the app
right it's got to load something to
begin with so I'm gonna grab Basecamp
development URL and we'll visit that
all right now moment of truth here we go
you can see we have native controls
around the webview but now tapping on a
link doesn't do anything and that's
because we need to handle a visit
proposal so in order to do that we need
to set ourselves as the turbolinks
session delegate and then we need to
implement a method and this method just
tells the application what to do when
turbolinks receives a link click event
so we're going to implement that method
now session did propose a visit to URL
and we're just going to tell it to call
our visit method that we argue robe and
we're going to compile and run but we
forgot sin to implement our error
handling method this is very important
to implement but I'm just going to stub
it out for now
and let's try tapping a link oh there it
is so we had a native transition we have
two actual native view controllers looks
and behaves like a real iOS app but the
content of the view controller is
rendered as HTML you can see it's very
fast navigating backwards you can even
perform the interactive pop gesture here
so you're seeing the webview on front
and the screenshot in the back we manage
all of that for you you get pulled to
refresh but you can see that this
doesn't quite look like we really wanted
to right we've got all that
administrative different view left over
from the web app but we want native
navigation and so what we do at Basecamp
is we check we check for a custom user
region in the web app and we use that to
selectively disable some UI elements and
it's very easy to do so I'm just going
to go and import the WebKit framework
here and make a change the way I create
this session I'm going to create a
configuration object
assign this property pass it to the what
to the session initializer and now we'll
run the app and now you can see it's
looking more native we've lost the
navigation bar at the top some some
buttons when I now when I navigate
through some of these news look like
they could be real table view
controllers but of course we're doing
this with much less effort and so this
is the core of our strategy right I just
built a fully functioning iOS app
wrapper for base can in under 10 minutes
it has native navigation and I think the
most impressive part of this is that I
have full coverage of the app all 200
plus screens are accessible from this
wrapper in 30 lines of code and when we
roll out a new feature in the web app in
many cases we don't have to make any
changes to the native apps and we don't
need to wait on App Store approval
because when we make a hybrid app with
turbolinks we're essentially making a
custom browser we get baseline coverage
for all the apps functionality and we
can progressively enhance the native
controls surrounding the webview right
this is how the web is built progressive
enhancement
now we're extending that from the
browser to native apps and what that
means is we can spend our time building
high fidelity UI where it's most
valuable instead of going through the
grunt work of recreating screen native
looking on every platform we can even go
fully native on a per screen basis and
this is what we do in the in the
official Basecamp iOS app
it has a native homescreen so I'll show
you here instead of taking you directly
to the activity page we have a native
jumping-off point and this is just using
API requests to populate the table view
but as soon as you click something then
you're taken into a turbolinks web view
everything for seats from there you can
see also we have native navigation
controls in the title bar we've
implemented we extract some metadata
from the page in order to generate this
title we have custom navigation buttons
so all this is native what the actual
application is in HTML very fast we even
support 3d touch using turbolinks
so yes you can do all those things that
you expect and we have native menus and
again we extract this content from
metadata on the page it's very easy to
do so that's a look at what turbolinks 5
gives you new rails 5 projects have it
enabled by default it's also now
available on NPM as a standalone
JavaScript library so if you're not me
using the asset pipeline and you want to
use it it's available to you there and
it has no dependencies and it's not for
real not just for rails apps anymore
it's open to everyone we have all new
documentation on the github project page
which we're very proud of the iOS and
Android adapters are exhaustively
documented as well and so if any of this
speaks to you I encourage you to check
it out and there's one final note I want
to make before I go it's important to
note that turbolinks is not about
avoiding having to write any JavaScript
ok your application will need to have a
script
nor is it about having to avoid learning
native development any more than active
record is about avoiding how to write
sequel you're still going to have to
know how to do these things but what
turbolinks does is it gives you a
baseline for good performance with
minimal effort which lets you spend your
time choosing what to optimize instead
of going all in
and recreating everything from scratch
so that's if you if you take home one
point from this talk that's what I hope
it is choose what you optimize thank you
for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>