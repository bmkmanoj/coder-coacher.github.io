<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>10 Core Guidelines You Need to Start Using Now | Coder Coacher - Coaching Coders</title><meta content="10 Core Guidelines You Need to Start Using Now - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>10 Core Guidelines You Need to Start Using Now</b></h2><h5 class="post__date">2017-11-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RKQ7FDmyesE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Kate Gregory and I was trying
to figure out exactly when I started
writing in C++ but I didn't know it was
gonna be like a momentous occasion and
but I'm gonna declare that it was 1987
because then I can say I've been doing
it for thirty years and in that time
I've learned an awful lot and I like to
tell my children the only thing better
than learning from your mistakes is
learning from someone else's and that's
kind of what this is all about so let's
start with a show of hands
not counting the title of this talk the
abstract of this talk or Mondays keynote
how many of you had heard of the C++
core guidelines that's pretty good
that's about three-quarters I'm happy
about that
how many of you have been to github to
this URL just once and looked at it at
least once so that's less hands by
dramatic factor like about a third of
you how many of you have again once
changed the way you code something or
persuaded someone else to change the way
they were gonna do something drawing on
a guideline and as I've really what I'd
call a smattering of hands okay so my
purpose for this hour is to change that
last hand okay and I understand it's
daunting right there's like over 500
guidelines and memorizing them all seems
impossible starting at the top and
reading also seems impossible so what I
thought I'd do is I'd pick out a
collection of guidelines and talk to you
about them they look like this there's a
bit of a categorization this is
functions this is classes this is
expressions blah blah blah and there's
all links and they have letters and
numbers in their names so when I talk to
specific guidelines I'm going to call
them out by their letters and numbers
and you can find them that way in the
markdown who's on slack the cpp slack
okay that's not enough hands you should
all be on the cpp slack you know you can
ignore it if you're not interested right
now think of it the way you think about
Twitter like just step in for a moment
see what's happening and step out don't
try to catch up but one of the things
that happens a lot in slack so people
say should I a or B and so one of my
hobbies is when I see that I'll say well
the guide
say you should be because reasons and
then people say things like but there's
no speed difference it's like um
what so so let's be clear about what the
guidelines are supposed to help you to
achieve some of them really are because
a is faster than B or vice-versa but
many of them are for completely non
performance related reasons like
readability or preventing bugs or
whatever and I picked up five reasons
that I think are pretty prevalent
reasons and then I chose a couple of
guidelines for each reason so I'm not
going to show you my top ten guidelines
or the ten most applicable or the ten
easiest or anything I just came up with
these five reasons and found two
guidelines for each reason so that you
understand the motivations of the people
who are writing these things up for you
okay so let's start ah with the bike
shed for those who are unfamiliar with
the metaphor
you know I'm an engineer by trade and
when engineers design nuclear reactors
or bridges or incredibly complicated
things submarines or whatnot and then
they bring their plans for approval by
and large all the non-technical people
are like oh that looks good but as soon
as you have something that has very low
stakes like a shed to keep bikes out of
the rain suddenly everyone has an
opinion everybody knows everything about
it and we argue about that for six hours
and so there's a couple of guidelines
that are really just about Oh for
heaven's sake make a decision and move
on so let's start with this one I need
to write a constructor and some of my
member variables have sensible default
values how should I make this happen I
could write a default constructor don't
take the parameters and it gives about
default values to all the parameters or
I could use semi-new in class member
initializers and there's also the matter
of whether or not you and you construct
in general an initializer list for
constructors so here's a class it's made
up but it's made up based on reality
right when things grow over time and
other people come in and do things
especially when they don't fit on a
slide and these constructors are
actually several hundred lines apart in
the same file
get this kind of behavior so the default
constructor for simple here gives see a
value of 3 so that's obviously the
default value for C right except that
the 3 argument constructor if you don't
pass a value for C it'll initialize C to
minus 1 and the 1 argument constructor
will initialize C to 0 so three
different ways to make a simple without
specifying what you want for C and three
different possible values for C and you
can tell that wildly different people
did this because whoever did the one
argument constructor doesn't even know
about initializer lists right that's a
different guideline instead you using
class member initializers now you're
writing less code yay always good and
you're consistent a lot of the
guidelines are booked taking away
opportunities to be inconsistent right
so if you're a disciplined person and
you have a wonderful test suite and you
have code review and everything else you
would have caught that inconsistency on
the previous slide now there's no chance
to be inconsistent the defaults are in
the in class member initializers and I
like to go one step further and instead
of empty brace brackets use default for
that constructor if I had no other
constructors this would put me back in
the know user-defined constructors world
and according to the guidelines anyway
there's apparently a perf benefit to
this as well to me the big benefit is we
don't argue anymore yes they are
equivalent yes you are disciplined and
wonderful and would never become
inconsistent I get it
we can just stop arguing and just do it
this way okay some other people argued
for a long time let's just do this and
it may prevent some bugs and it may make
your code faster similar argument I got
two versions of the same function one's
going to use two numbers one's gonna use
three should I write two different
overloads or should I write one function
with a default argument so here's the
two overloads version what am i
simulating a nuclear reactor apparently
and I've got I can take a pair of
doubles a and B and a fudge factor or
just a and B and it turns out that
because I am a consistent and lovely
person I've implemented the three are
the two argument one by calling the
three we
hard-coded value okay you can read that
you can see the difference between the
two right it's very clear when I call
the two version two argument version
fudge factors one that's great but not
everybody writes it like this especially
when they start out small like they
start out like five lines of code and
one of them multiplies something by the
fudge factor and then we feel sorry for
the poor little computer and we're like
why should I have a line of code that's
multiplying it by one like that's dumb
so I'll just take that line away we also
take away things that add zero and that
kind of stuff and then that causes the
two versions of functions to diverge and
even if you're absolutely disciplined
and they never do diverge can anyone
else really be sure that they have not
so this is fine but the I have two
different 700 line versions of the
functions and it's up to you to figure
out where they differ not so fine when
you do it this way it's very visibly
obvious right you can't always do this
not all two versus three argument
overload situations can be resolved with
a wave of a default argument but if you
always do it where they can then when
you don't do it you're also
communicating right again this is mostly
about not arguing it's mostly about
skipping the bike shed okay you could
argue long and hard about how
disciplined and consistent you are or
you could just do it this way it makes
the difference clear and you can't get
inconsistent later so let's get to the
parts of C++ that could hurt you these
exist we try to tell you you'll be sorry
so who's met this this is define
initialize member variables in the order
of member declaration
yeah that's bringing some pain back for
a handful of people and I bet it was
quite a long time ago you know this
particular pain sticks with you for a
long time so here's a class you probably
would never write I am taking an integer
parameter and I'm incrementing it as I
initialize each variable and it's sort
of an interview question you know what
would the value of X be after this
constructor runs and we assume that code
runs in the order that it's written so
we figure why little initialize
passing in zero I'll increment the zero
up to one and that I'll initialize a to
that and then I'll increment it again to
two and initialize B to that and then
I'll in commit it again to three and
analyze X to that and that's not correct
now some people want it to be undefined
behavior because they memorize that if
you ever see two plus plus is on the
same line that's undefined behavior it's
not this is beautifully defined very
clear well if you've read standardise
will initialize a then X then B because
that's the order they're declared in the
class okay so the guideline says don't
lie write your initializers in the order
they will execute since you can't
control it but there is a side effect
which is what you mean if people
rearrange my variables my code might
break yes and the plus plus thing is
totally fake but in the wild I have seen
pointers being initialized new fits on
the slide but using a smart pointer
would change nothing and then something
being initialized by calling something
on the pointer and again if there's a
change order that's a very bad miss and
I have seen first name and last name
being used to initialize full name some
of you may know a piece of lore called
never use member variables in
initializer lists only ever reuse the
parameters over and over again and if
that's a piece of wisdom that's been
handed to you it's for this reason there
are tools out there that will put your
variables in alphabetical order there
are newbies who are learning a way
around the code base who will decide to
put related things with related things
there are an awful lot of reasons why
your variable declarations might change
order and ideally just knowing that this
exists will cause you to write stuff in
a way that you're not vulnerable to it
but if you have to at least you will
have done it right the first time the
order will match reality not the order
you happen to think of writing them down
in and it may be a clue to the other
people in your life don't rearrange the
variables without rearranging your
initializers
this guideline is a vague one I
mentioned my original training was in
chemical engineering and we passed
around jokes in those days before the
internet on literally mimeograph pieces
of paper and there was this big long
thing about pipe which is hilarious it
starts a pipe is a long hole surrounded
by metal and among other things it said
that long pipe should be labeled as long
pipe if it's over a mile long but any
pipe over two miles long should also be
labeled not just to both ends but also
in the middle so you didn't have to walk
all the way the end to find out it was a
long pipe so in the same spirit what
does it mean to keep the number of
function arguments low right like 27 is
probably not low you probably shouldn't
have to walk all the way the end of 27
to find out there was a lot of arguments
for the sake of the slide I'm gonna make
for a lot of arguments and I understand
that it might not be you might not need
to be quite this strict but you can even
see the effect with a relatively small
definition of law it's a function called
area that takes four integers and you
can guess by their names that is sort of
an X Y followed by another X Y but when
you see them being called out in space 1
1 11 21 it's easy to forget is that the
top left corner and the height and the
width there's at the top left and the
bottom right or is at the top right in
the bottom left because people are
strange or what's happening maybe it's
both X's followed by both Y's if you
make up an abstraction like point which
is hardly a difficult abstraction to
invent now you can have your area
function take two points and that tiny
change that's super tiny because I don't
even have to type the word point
anywhere right it's being initialized
from this initializer list of integers
it's the grouping is obvious you're not
going to think maybe it's a point full
of buying it a height followed by a
width it's clearly two points and these
abstractions may have value elsewhere in
your life or not imagine that I have
this class and for the purpose of our
discussion does it really matter whether
details and rap are solid objects or
pointers or references it's not
important I need to make a customer you
know which of these two ways of making
customer would you prefer the one where
you pass in the person part and the
sales rep part or the one where
pass in seven strings right so it's just
about reducing that cognitive burden
maybe you'll invent a useful abstraction
like point that'd be cool
and it's possible you can even make your
code more maintainable so our area code
was taking obviously two 2-dimensional
points if we move to three dimensional
points we'd have to take x1 y1 z1 x2 y2
z2 and we can't fix that up with default
arguments because that Zed's in the
middle or z for those of you with local
locales but if I made it points and my
constructor for point has a default
value for the Zed that I actually
wouldn't need to go and change the code
right that's a minor one that rarely
happens the big deal is really about not
making people remember which of your 13
parameters is which especially if
they're all in switch often seems to
happen for those people who do this now
that's no one's gonna say don't write
functions anymore I'm just saying don't
have a whole ton of arguments to them no
one's gonna say don't use constructor
initializers anymore just saying be
careful about the order but there are
parts of the language where we really
want to say don't do that okay so I love
this guideline first of all because it's
four words long you know a lot of things
in guideline land and standard land are
a little hung over both side and the
other thing it doesn't say prefer it
doesn't say avoid it doesn't say when
there is a choice like we did with the
default arguments it says don't let's
take a look at this class this is a
made-up thing what if I got I've got two
private numbers and a calculation which
doesn't change either number calls me
some kind of integer results I have a
constructor I have two non constants and
a Const get value and you can guess
because it's been written in a way
that's constant the things that need to
be Const that service one and service to
change number one or number two or both
in fact it's not outrageous to expect
that service one changes number one in
service two changes number two right and
I'll tell you that I'll get value does
is call long complicated calculation so
this class is minding its own business
this class is constant okay but somebody
notices that this class is causing
performance problems because of good old
long complicated calculation and so they
decide to add some caching so now we
have the cached value and we'll
initialize that to zero and in this
universe the only thing that can change
our cached value is to change the values
of number one and number two if you want
you could have the constructor actually
also figure out the cached value instead
of just making it zero so this code is
still telling the truth all right
service one which is non Const is
changing number one and it's also
changing cached value so it was two
which is non constant changing number
two and it's also changing cached value
and get value is still being good this
is a pattern that works if you have more
reads than writes so for example to
choose something that's not a
complicated calculation what day is it
today needs to be updated on your
display like all the time but it only
changes every 24 hours but of course the
world is full of things that are the
other way around they change all the
time and you only look at them once in a
while so if you have a group of people
who are all updating their time sheets
every half hour or so
throughout the working day and their
manager maybe only looks at their
timesheets
once or twice a week so you have you
know orders of match
to choose more updates than you do reads
so in that case what you do is you add a
signal that weather out your cache is
valid and you just invalidate the cache
on a right so if you want to change
number 1 that means the cached value is
no good anymore you want to change
number 2 that also means the cached
value is no good anymore but we're not
going to do the calculation then when
somebody wants the value well do I have
a good cache no ok I'll do the
calculation that's fine it's good code
small problem with it anyone see the
small problem in this code it doesn't
compile yeah so I think there's no
runtime errors though like you got a
given points for that we've said the get
value is constant it's clearly changing
some member variables of the class and
this is where people are like I know
will cast away Const actually there's a
solution people try before that let's
just throw away const correctness right
let's just say get value isn't constant
after all what the heck it's not
apparently the Pilar says you know when
I was teaching intro to C++ there's this
whole thing where people stop doing
anything at all and just try to make the
compiler happy just add stars and
ampersands until the compiler shuts up
and and they don't really think about
what they're trying to achieve and
that's sort of the deal with taken off
the Const like Oh am I not allowed
Kant's there ok I'll take it off and
then I'm you think you made your code
good but of course you made your code
bad right because we had this design
that said get value doesn't really
change anything ok so the old solution
then would be to cast away Const and I'm
not showing you code because you're not
supposed to cast away Const but
basically you make a thing called
capital T this that's the tradition and
you you Const cast so that it's a
non-constant what's our class called
stuff so non Kant's stuff and then you
could say this points to number one
number two or whatever prom with this a
it's ugly as all get-out right you have
to write all kinds extra stuff you have
to have in directions blah blah it's
hard to read hard to write your header
file is now lying your header file says
get value doesn't change any member
variables of the class but it does and
it actually has the power to change any
of them right like you can write number
one
well zero in the middle of get value and
it would compile so you have an ugly oh
and slower approach that makes sure how
to file a lie and could cause weird bugs
that no one's ever gonna look for yeah I
don't know why would I want to do this
oh I know why because we can't think of
anything else to do so let me tell you
some other things you could do you can
take advantage of the fact that in C++
we have pointers not just only
references and you could have a pointer
in your class that pointed to the cache
and the pointer is Const you can follow
it and change the numbers that live at
the end of the pointer all you like that
does not violate consequences okay
that's an okay thing to do I'm not crazy
about it I'm especially not crazy about
it in our new world of if you're typing
new and delete you're doing it wrong cuz
where did I get a pointer from all right
clearly it's not the address of
something because whatever is the
address of I would also be Const so it
has to be something that I got from
there free store so who's calling new on
it who's calling the lead on it what
happens when you copy a stuff ah she's a
shared pointer let's use a unique
pointer Oh a unique pointer huh what
happens when you try to copy a stuff and
a lot of this complication you actually
should think about like what does it
mean to copy one of these things around
and do you copy its cache with it and
all that if they're actually valid
questions but they add complexity so my
favorite just go back into your header
and make it tell the truth again make
these two variables mutable so mutable
means I'm exempt from Const and now only
those two guys are exempt from Const so
get value is still marked Const
correctly and get value cannot change
number one or number two
nobody needs to read your code to
understand where you're telling the
truth and where you're lying the whole
story is here in the header file and we
could just live happily ever after and
that's why they're able to say don't
cast away a Const find another way
around your problem
I never liked reading Const casted code
because of all the capital this points
to stuff it's harder to maintain and
then you have to explain to whoever's
gonna take over for you why you're lying
here and I never felt good about that
either so you want to stay constant
especially in the world of now right
we've got all kinds of performance
issues and threading issues and things
like that
we're being constant has real everyday
value in your code
do not say oh I'll just make the
compiler happy and take the con stuff
don't do that never transfer ownership
by a raw pointer can I show you what
this doesn't say it doesn't say never
use a raw pointer people ask me how to
do things and sometimes there's a really
obvious use case for a pointer and they
say but I was told we don't do pointers
anymore and they're like trying to
decide between a shared pointer and a
unique pointer for something that very
obviously needs a raw pointer guideline
does not say never use a raw pointer
what it doesn't want you to do is this
and I think we've all met this code in
our life right this thing news up a
policy whatever that is and returns the
pointer and then it's own local copy of
the pointer obviously goes out of scope
so this guy's not cleaning this up and
whoever calls it has to know that it's
their job to clean it up sometimes if
you are lucky the person who wrote this
function has put words like Alec or
create write or new in the name of the
function so it might be called Alec
policy and price it something like that
but very often not and so you find out
by the dreaded comments which no one
reads or by a person writing you a note
on page 72 of a hundred page document
both of which kind of suck
in this universe in the 2017 universe
probably the best thing to do is just
return it by value just create it on the
stack and return it there's a really
good chance that'll be elite 'add and if
it isn't maybe you don't even care about
the copy so much I keep meeting people
who are all worked up about saving the
copy and their string as they their
classes got like a string and two intz
it's gonna be exhausting when we copy
those gonna kill us you know there are
places where copies are really expensive
I did some things with simulating oil
refineries and collections of numbers
representing the chemical composition of
a piece of semi refined petroleum we met
have a couple of hundred doubles or
floating points representing the
fractions of different things but more
importantly you had to do something
called flashing the stream which is a
very expensive calculation about vapor
and liquid and you don't just randomly
copy those but your employee with a
first name and last name in a salary and
a higher date we can copy that it'll be
okay
and anyway the compilers are getting
better and better and better at not
copying that so that should be your
first thought why am i putting that on
the FreeStore at all now a thing about
me and it's also a thing about the
guidelines why am i X does not mean
don't X right it means tell me why
you're doing that and you may have a
reason like it needs to have a longer
scope and I live in blah blah and that's
fine if you want the caller to
explicitly allocate it you could take it
by a nonce con stress and then change it
I don't like it when it's not an in-out
though like if it really were to be a
peer out I don't I don't like pure outs
so let's use a smart pointer so now the
function will still be causing something
to be allocated out on the heap but it's
gonna give you back a unique pointer or
a smart pointer a shared pointer
whatever is appropriate it's okay it's
probably the best choice if you have
control over what the function does you
now have to argue about when to use
which pointer correct answer is not
shared pointer is easier so use that by
the way there are guidelines about
choosing between unique and shared if
you can't
change the API you can annotate the API
and this is this isn't gonna change
anything behavior but it's gonna change
your head okay so it's a template called
owner I will show you the entirety of
the code for owner it's not exactly
computationally intensive right you can
only make an owner of a pointer that's
what that enable if stuff is don't worry
about being so you can't make an owner
of an int or an owner of stuff but you
can make an owner of stuff star or
policy star or employee star and then
it's just an alias so if you're calling
something in someone else's API and you
need to declare that it returns what
will be a policy star you can declare
that it returns an owner of policy star
and that will collapse down to being a
policy start so you're fine your
declarations will match but this tells
the person who's making the call you own
what you get back from that and it also
sets up the possibility for checkers to
say you have an owner of policy star
here on line 73 of this file and you
never ever delete that and you let it go
out of scope and then the checker can
tell you that you've messed up where as
an ordinary raw pointer the checker has
no way of distinguishing false positives
of telling you hey you never deleted
that it's like I don't need to delete
that and I don't own it for a lifetime
I'm just looking at it so this way
you're marking everything that you
actually own for lifetime
when Java first came out we used to say
Java people think that memory management
is too important to be left to the
people and we think it's too important
to be left to the computer hahaha I
think it's too important to be left to
people it's too hard okay so when you
are calling a function that gives you a
pointer and you have to remember to
clean it up that is too hard let's not
go shopping though let's don't return a
pointer or turn a smart pointer or at
the very least leave yourself an actual
encode compile real note that you have
to clean it up
those parts of the language we don't go
there anymore that's great is anybody
getting new standard fatigue well I see
you're slow too for your hands okay so
like do I want to admit that come when
11:00 came out it was so exciting oh
look at the toys we get this is great
and for teens like what's a bug-fix 211
that's good we forgot some stuff that's
fantastic 70 is like wait I have to
learn more new things ma sure have
completely learned all the old things
yet so so some of the guidelines are
telling you to use some things you maybe
didn't know were there or are you heard
of them but you don't know what they're
for so I picked up a couple of those and
this one I'm gonna slightly disagree
with the guideline guideline says to
return multiple out values prefer
returning a tuple or struct now I
totally agree that you shouldn't have
multiple out values it's just the order
I don't want to say tuple first okay so
here is something with an out value okay
it takes one real parameter and one for
writing an answer into and it returns
one and it writes one out it's not I'm
gonna have to fit my code on the slide
so it's not exciting insert whatever
legacy nightmare you currently live with
I'm sure you all have one so you know if
I want to call it I have to allocate the
out per ampere stand I've given it a
value because otherwise my tools will
yell at me and say oh it's not
initialized blah blah so the value
doesn't really mean anything and then I
call the function
oh there's a design issue here right who
decides when they're not called one and
to which things really are the out value
in which are the return value or which
seven things are out values and which is
the return value so as prepping these
slides I went and asked a few people
three different answers and all three
answers started with it's simple it's
obvious you just so that's good okay so
for future reference not that I ever
want you to have out params it's simple
it's obvious you must if you have a
success fail if you have a bool that's
what you got a return so that you can
say if foo and then inside the if you
can unpack the outs or it's simple it's
obvious you just got or whatever the
name of the function is like if it's
called price it must return the price
and everything else the success fail the
error message whatever has just baggage
that should just be out params
and then presumably from the people who
had multiple children and didn't want to
pick a favorite return void and
everything is an out parameter will
forget to unpack anything I hate them
all so my number one choice would be
your own struct right you can only
return one thing from a function that's
true it doesn't mean there's only one
value you can return return of struct
how hard is this so here's a fascinating
and useful struct which you can see took
me hours to write and and that's the
only flaw in this okay if the structure
you're gonna return could be called
employee or purchase order or nuclear
reactor condition then this is a great
solution but when it's gonna be called
two numbers or three incent a string
it's not so good come on who's written
some call three incent a string I'm not
the only one right yeah thank you anyway
the way you call it you you can you can
construct it on the return line if you
want and the only downside is having to
have these things to pull the struct
back apart into afterwards or else you
have to go around saying dot like when
you're using pair and yet say dot first
in that second right so you have to know
the names of the pieces of the struct
again it's it's pretty easy to know the
names of the pieces of the struct when
it's an employee or a nuclear reactor
condition and it's harder when it's
called two numbers someone's having more
fun than me so I want to take a side
trip to stood optional because very very
common pattern is that the two values
you want to return are a bull success
fail and a thingy right and the real
purpose is to return the thingy but you
also need to indicate whether that thing
is usable or not and a lot of people
that's why they want to return a pointer
because pointers can be null not for
anything related to lifetime stood
optional is a great drop-in for that
people who are not me and are not you
have slavishly created all of the things
that you would have eventually gotten
around to adding to your own structure
for this so if you just cast it to a
bull like you say if foo at stuff that's
gonna cast it right the bool that you
get is that usable or not true or false
part of the optional if you try to cast
it - what were we dealing with
originally I think a policy maybe or a
stuff for a nuclear reactor the operator
equals will go get the value out of the
OP the value part and put it in the
right place and you can even talk to it
as though it were a pointer and
dereference it it is not a pointer okay
it is not on the FreeStore it's not the
address of anything but you can call
star on it or points - on it and you'll
get things out of the value as opposed
to out of the optional and probably my
favorite value or right I call some
function that might give you a string if
it gave me a string I want the string if
it didn't give me the string I want
quote quote that's what value Moore does
or it might give me an integer and if it
didn't give me an integer I'm 1 0 or
minus 1 or something that's what value
or does so for that particular pattern
where the two things you want or a
boolean and a thingy go with stood
optional and if you really want to in
sore three strings in an int or whatever
then tuple is your
friend if there's no value to destruct
afterwards and if you can't come up with
better names for its pieces than indexes
then you want to go to pool because it's
been done right why do it so I know that
a tuple with two things would be a pair
but I decided I would do a tuple with
two things anyways so here is our
version of food that returns a tuple and
it uses make tuple to well make a tuple
I'm sorry that the language has become
easy to understand and sensible like
that takes away some of my value you
know it should be called push back so
that I could explain where historically
that name came from but anyway so we
make a tuple and that's what we return
life is good now once upon a time there
was this thing with get an angle
brackets where you put numbers in the
ink I'm not even showing it to you it's
horrible you can use tie to tie two
local variables in this case answer a
number the tuple will get unpacked into
those parts life is good okay if you
live in seventeen land you can use
structured bindings now you don't even
have to declare them before the call and
this is really sweet right answer and
number will have the correct type in
this case they'll both be int and
they're declared right then and there
when I make that call and I think this
beauty is partly why the guideline says
prefer a tuple or a struct because this
is so sweet you want to tell people to
use it okay but I still I'm gonna say
prefer a struct or a tuple because if
you have a real name for your struct and
real names for your fields and it's an
actual useful abstraction that should be
your first choice but if it's called
three instant a string then go ahead and
make it a tuple I made a tuple of int
int but for those of you who haven't met
this before it's any and all types right
no no restriction so it could be int
string int or what have you doesn't
matter
one of the problems with out params is
knowing when the function is done so
it's all very well on slides but in the
real world I think my record is a 15,000
line function
I met something with a thousand line
catch block once when you have a
multi-page function and somewhere 17 or
18 lines in it says x equals 3 it's like
is that it is that the answer are we
touching X ever again you don't really
know when you have a return statement it
kind of stands out even if you have many
return statements in the function they
all kind of stand out so if you have a
return make tuple at whatever that's
when the values are being sent back and
you know that and I find that has a huge
benefit just for Ruiz ability it also
makes your signature now carry different
meaning so now when I see a non Const
ref parameter
I know it's an in-out I know it's not an
out when I see a Const ref parameter I
know it's an int by taking out params
out of the maybe I can be confident
about what I'm seeing in the code so
this is a lovely guideline and also a
reason if you wanted one for why you
should be using some 17 features who's
used class names yet more than I've used
an actual guideline that's good for
everyone else here is Ana pneumix is act
like an anemic set that has the word
class in it until I define another one
and then we pull off this miracle trick
of having two values with the same name
you know most of the unreadable 'ti of
our old code is that all our OK's are
called like s okay F okay D okay and so
on to distinguish them from all the
other okay's and then it would look
weird if I had terrible R okay terrific
so they're called are terrible R okay
are terrific and so on and then people
complain our code is hard to read you
can mix and match with old-style enews
these are for those of you like me who
are not American America
states that happened to start with all
and you use them with their full names
so that's why I've called them out in
red with the old-style neumes you now
can use them with their full names if
you want to it used to be an error to do
that if you weren't on visual studio if
used to confuse the life out of me when
I would take my code to another compiler
and go why can't I say what it's part of
well now you can if you want and the
most interesting thing about these guys
is kind of hidden here in the last line
of this slide you know most functions
that took E neumes
didn't take in news at all right they
took ins and I don't know why it just
became a habit of ours and so the
compiler would be like oh that function
wants an int and you're passing it a ok
terrific except that it was actually
expecting a ratings okay and you just
had a mine slip and you passed it a very
different numerical value than what it
was expecting so you think you know
you're passing down one and you're
actually passing 17 because you use a
different a new and then the function
goes often does whatever it does for
that wobbly different indium value so
with the new class you can get it to an
int if you want by static casting which
is the it is my foot and I'm pointing
this gun here on purpose operator but
you can't do it accidentally as you can
on that last line as arguing with
someone the other night we're saying the
problem with C++ is our early defaults
are mostly wrong like what's public and
what's private and implicit conversions
and that kind of thing you have to say
explicit if you don't want it to be used
for conversions and implicit conversions
back and forth between a Nunes and intz
may have saved us some time occasionally
but if we add up all of the bugs that
we've chased over our lifetimes not so
much right so that's to me the big deal
of DM class but the immediate benefit is
you don't have to call things are ok s
ok ok and whatever you can just have the
names you want oh and and in theory well
I mean I know it's true I just never
done it you can have a different backing
type like especially you can have a
smaller type I've never had need for
that but should you that is also a
choice
I briefly mentioned the guidelines
support library when I showed you owner
this is not the guidelines support
library this is a librarian Dublin
it's gorgeous though in writing the
guidelines they got to places where they
wanted to show you little snippets like
say owner one to three lines long but
rather than putting that textually in
the guideline and say consider writing a
template like this they went off and
design the guideline support library
anybody used anything from the guideline
support library wow that's really now my
record that's five hands out of this
whole room what can I tell you you are
not the first developer with this
problem so I thought I would pick out
two guidelines related to the GSL so
that you understand that it's a library
that maybe you want to go look at a
pointer that must not be now have any of
us ever met a pointer that must not be
null she does that ever happen imagine
some service s I'm going to take its
address and then call use that to call
do something sort of code that only ever
appears on slides because why wouldn't
you just have said s dot do something I
know but you know this is safe code
right there's no way that PS is null
unless of course I were to set it to
null pointer and then immediately try to
call do something and what will happen I
will get a null pointer exception and if
all our null pointer exceptions look
like this my hair would not have any
granite so you need to call if the
pointer isn't null blah blah and that's
really boring so you write like a little
helper function right ask the service to
do something which is all fine till you
get to the part after the if like if I
can't return P points to do something
what can I return should I throw an
exception well that's kind of stupid I'm
doing this so I won't get a null pointer
exception if I was ok with catching an
exception I could have caught the null
pointer exception so that's that's not
okay
well we remember we were talking about
value or for stood optional so maybe
it's like
if the service can't help me then the
answer is zero or quote quote or false
or something and if you have a legit
signal value and you don't care that
this pointer somehow got null then
that's an OK pattern but usually that's
not the case and when that's not the
case the pointer can not be null
so this ask pointer to do something is
fine if it's OK for the pointer to be
null and we can deal with that and we'll
just say 0 but what about when you can't
so you include the GSL header and the
GSL is a spec right there is an
implementation by Microsoft under
Microsoft's github instead of under the
ISO cpp github and there can be plenty
of other implementations as well and
it's header only so you can just
download it and put it in your code and
carry on with your life so now I'm
declaring PS to be a GSL not null of
service star everything else about PS is
utterly unchanged I'm still initializing
it by taking the address of s for
example I'm still dereferencing it with
the exact same operator everything you
think's gonna happen it's gonna happen
but it is not just an annotation like
owner this last line of code on the
slide PS equals null pointer it's a
compile error do you know how much I
love that it is I mean I I tell people
the compiler is your friend there is no
better time for the compiler to be my
friend that on this line of code here is
a pointer that should never be null and
I'm setting it to null
what is wrong with me right so the
compiler will actually because they've
suppressed various constructors you get
a compile error you can't do this that's
great but you know you can lie to
compilers you can hide things in
different translation units so I wrote a
function called get pointer which could
be doing something super clever but
which in fact just returns whatever it's
given and then back in my place where I
declared my not null service pointer PS
ICPs is equal to get pointer at null
pointer and then we all know what
happens the program carries on about its
merry way
and a year or two later somebody happens
to click some button and you still
haven't put a decent value into PS and
then we go boom right no I mean you
would accept then you went boom on the
line that's set PS to null pointer so if
it can't be a compiler it's a runtime
error not when you use it but when you
foolishly set it to null and that's the
line you wanted to find all right people
are phoning you and sending you
screenshots that their null pointer
exceptions and you're like okay I get it
it's null but how did it get null who
did that and you're like searching your
codebase and setting weird memory based
breakpoints and everything else it's a
really hard thing to find so here you'll
you'll get a runtime error when it gets
set to no and you will know what line
got you there and if and if you're the
one who's running it you can maybe look
at the call stack and see what happened
to blah blah so you can actually solve
the problem and that's all it takes if
the pointer is not supposed to be null
mark that it's not supposed to be known
this will actually make your application
faster do you know what all those if the
pointer isn't null are costing and
you're doing them every single time
because you know in your bones that if
you leave one out you will get got so
you can take them all away
and of course you're being expressive
you're saying this is a pointer that is
never know so you don't go boom you're
faster and everybody knows what you're
saying
most of the guidelines are like this
it's not a trade-off it's not like hmm
do I want this or this it's like good
good good good good versus what we have
now I'm gonna go with good good good
good good
now this guideline is more generic than
what I'm going to talk to you about the
guideline in general says try not to do
narrowing conversions and you notice
unlike don't cast away Const it's like a
void we're back to the you might want to
consider if it's possible and convenient
right but within there there's a little
piece of the description that mentions
narrow and narrow cast first I want to
show you this to some of my own code I
wrote it a very very long time ago but I
was able to find it in a heartbeat some
of you will recognize some of these
types to be like oh the poor dear thing
she's on Windows she's on visual C++
because you can tell by the warning
number that I have to disable and I got
no control over any of this I'm being a
funking layer I'm getting the pieces of
time out of am of an input time which
keeps its bits and pieces in signed int
because if you need to represent a
number between 0 and 59 a signed int is
the obvious choice and I'm putting them
into system time which wants everything
in words and it is possible that some
intz won't fit in some words but it's
not possible to 0 to 59 0 to 23 and some
will not right so these are narrowing
conversions which we are urged to avoid
but which we often cannot I have Prag
meant away the warning because I live
with warnings and errors and I want zero
warnings so I have to pragma away them
and then it's my personal convention
that i tell you what i'm pragma away in
this case is the possible loss of data
and then i'm obviously in real life the
line doesn't wrap seconds and what not
cannot be too large for a word and they
will always be positive but compiler
doesn't read comments so narrow cast and
narrow which are not in the standard
there in the GSL they're just like say
static cast all right I'm going to
narrow cast to a word just seeing the
name tells the person who reads your
line of code that this is a narrowing
conversion as opposed to any other kind
of randomly chosen conversion that
you're doing so that's good
the one that's easier to type is a
little slower cuz it does a little more
say I have the number 200 and I want to
put it in a type that can hold minus 127
to plus 128 a case you may have found
yourself in by mistake I can do that
cast but when I am done it doesn't have
the value 200 over here right has minus
70 something right narrow checks after
the cast if the new value in the old
value are equal so if I'm trying to put
200 into something that can hold 0 to
255 afterwards it's still 200 they're
equal we're fine but if I'm trying to
put it into something that holds minus
127 through 128 afterwards they're not
equal and it either terminates or throws
you can control it with I'm sorry a
macro but I'm gonna say it throws so you
got a runtime error you have attempted a
narrowing conversion that didn't succeed
it wasn't ok all your assertions that
this will be a number between 0 and 59
and will totally fit in an unsigned
short are not so true after all haha you
narrow underscore cast is more work to
type it just trusts you ok it just
happens you might lose data when you
type narrow underscore cast you are
saying I might lose data and I don't
care do not come to me if I lose data
I'll do that for the times because if we
ever come to second number 73 of a
minute I got bigger problems than
whether or not my code is working but
the default one the one that's easier to
type will check for you and look after
you so again you're expressing your
intent and you may even get looked after
and be told
actually your reasoning is wrong it's
probably a good idea
so here are my 10 they're not the top 10
they're not the best 10 they're not the
easiest 10 but they're the 10 that I
chose to illustrate these 5 reasons
don't argue about the bike shed don't
spend your entire code review about
whether or not to use default parameters
don't hurt yourself with the spiky bits
and the dangerous dark corners of the
language forget certain things entirely
just because we did them in 1990 does
not mean it's okay to do them now please
do learn the new things we're adding new
things for a reason they're elegant and
they are beautiful and they solve real
problems use them and then take a look
at the guideline support library it has
other things in it besides this there's
there's span there's all kinds of fun
things happening in there that have real
value and that will I am sure bubble up
eventually what I would like you to do
I'm not asking you to read the
guidelines I'm asking you only to
bookmark the markdown document in your
browser okay that is 10 seconds out of
your life then some days soon you have a
decision to make someone asks you a
question and you're like hmm should I a
or B I wonder if the guidelines has an
opinion and go and look and see if it
has an opinion you know I like search
within the browser or follow the headers
or whatever and if it has an opinion
consider following it that's all I
believe if you do that two or three
times you're gonna say you know what I
wonder what's in here that I didn't
search for yet and at that point maybe
you will read it top to bottom because
by that time you will know there is
something in it for you that's really my
take on the guidelines they are going to
help you make decisions more quickly and
make better decisions which again
usually you have to trade-off between
those two but if you say okay I'm gonna
go home and read the whole thing don't
do that
get your benefit first okay then once
it's a proven proven situation to you
try reading the rest of it now the other
thing is there are slowly coming out
checkers so you just point them at your
codebase
they'll go blah and they'll give you
guideline numbers and say this is
breaking F 21 and this is breaking III
and so on if you're up to it consider
that but again maybe after you've had a
chance to see that a few of these things
really are advocating for what you think
is the right thing to advocate for and
with that yes indeed I have some time
for questions thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>