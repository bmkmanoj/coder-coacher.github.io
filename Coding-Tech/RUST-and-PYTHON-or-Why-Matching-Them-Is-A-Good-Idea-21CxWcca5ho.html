<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RUST and PYTHON (or Why 'Matching' Them Is A Good Idea) | Coder Coacher - Coaching Coders</title><meta content="RUST and PYTHON (or Why 'Matching' Them Is A Good Idea) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RUST and PYTHON (or Why 'Matching' Them Is A Good Idea)</b></h2><h5 class="post__date">2017-12-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/21CxWcca5ho" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Amin hor-aha I built Python
software for a very long time at this
point and I started working a little bit
with so I originally worked a lot of
libraries like flask and other things
and then about 2 years ago I worked or I
started working on a software project
called century which is a software
service
crash reporting service and one of the
nice things about this is it gives you
the opportunity to optimize like process
that we have to do and I started playing
around with rust in this context a
little bit and so this is my experience
report about how would it rust that
century and how maybe you can utilize
rust in in your own projects if you want
to find me on the internet these are
some of the locations that you can do so
I mentioned built this thing now work at
century and the lot of people have
talked to me recently over the last
couple of years whenever they talk to me
in person
I heard that you're doing rust now do
you still do Python and the answer is
that yes I still do Python in fact I
love Python century loves Python and
there are a lot of reasons for a loving
Python that didn't change or the last
couple of years the biggest one is that
the ecosystem is really strong and this
is something that for instance if you
compare to rust the rust ecosystem is
very specific in some areas it's very
good they happen to overlap a little bit
with the work that we're doing but it's
different the the the ecosystem is very
hard to get rid of so for instance if
you need mud mathematical plotting
libraries like mad fat lip or statistic
libraries there is a lot of stuff
already there that's really good to use
a lot of there's already written in C
for instance behind the scenes so you
actually get performance out of this as
well so there's no reason for dropping
that because one of the arguments
factory using rust is performance so we
use rust to augment Python we don't use
it to replace it it's particularly true
because Python is very good at fast
iteration something that rust is not
good at the compile times and rust are
not particularly great
and it's a compiled language so
iteration speeds are not nearly as close
as you have as Python and this is I
think the biggest redeeming quality of
Python compared to many of the other
systems that were using is that the
ecosystem is very stable there is very
little breakage that comes with package
updates it's very rare that deployments
fail because of something there's one
famous case that was recently where I
think setup tools got an update that
broke but it's very rare in comparison
for instance to our front-end JavaScript
applications where stuff moves so
quickly that sometimes it just doesn't
work for us also one of the good
features in five myths that has very
powerful meta programming which makes it
very possible for us to build API is
that are really nice to build internally
we can instrument a lot of the code so
that we can see what it's doing at
runtime and we have fast interpreter
introspection which means that we can
actually see variables when a crash
happens we can look at the frets that
are running so it's for building
software so service applications is
really great and this doesn't at all
apply to rest so all of the rest code
that we have runs very efficiently in a
little box and but when it breaks we
have no way to introspect this and we
don't have a lot of meta programming
capabilities in rust eater so they're
very different and one would not replace
the other but the arguments for rust are
speed that force is a big one and the
second argument for us is that rust
alone has a lot of functionality which
we don't find him in Python so in
particular we essentially need to deal
with crashes that are coming in from
users applications and those crashes
involve in some cases dealing with raw
binary data and and Russ is actually
really good at this because rust is at
least partially written in rust and
since the compiled language it has
bindings to LLVM it has lots of people
that wrote libraries for parsing Markel
files which are Whiston binaries so
there's a lot of functionality in which
we can use in rust that would also exist
in C++ which doesn't exist in Python so
for us preaching this works very well
reliability is also for rust it's it's a
good argument for us
I'm the code that we write and rust
doesn't really break its it's a strongly
typed it's very easy to test and then
once it run once it runs it kind of
keeps running so what we use it for is I
don't know if you ever heard of dwarf
files but it's it's a debug format and
the libraries for rust that can parse
this format and the only other libraries
and no that do this everything in C in
C++ and it's a lot more fun to work in
rust and it's in C++ so that was a big
argument for picking us ma who is some
is a binary format for Mac binaries and
iOS binaries so there's also really good
support for this
we also parse JavaScript source maps
that was the first thing we did with it
with huge chasing dumps and actually
turned out that that was from a
performance perspective doing that in -
earlier was not a good idea
recently we started doing ProGuard files
which also like huge text files that we
parsed and then we've built a
command-line utility in it the first way
of those things are actually written as
peyten modules so there this is a rest
library the run is available from the
pipe interpreter whereas the
command-line tools is a full replication
but has no pipe in it
so if you use Python then it makes a lot
of sense to see like how - compared to
rest as far as the basic sort of tooling
goes um I think we have a lot of tools
that we have to work with I think the
majority of us are probably using
virtual and PIP digital's and setup
tools and in rust that comes out of the
box in form of - utility is one of them
called rust up Rasta is a way for you to
manage multiple rust installations so
instead of installing rust you install
rest up and then rest up manages here
rest installations so for instance you
can track stable or beta releases at the
same time and you can switch from
approach of a perfect basis between them
the nice thing about rust up is also
that unlike most other managed like
multiple Python or Ruby mattress it also
comes with the full documentation so if
you have rust up
on your machine you can run rust up doc
and it will open the documentation for
the version of rust that you actually
have in the browser it's even if you
don't have internet it's pretty good for
this cargo is a second tool it replaces
hip cargo can install dependencies for
your rust project and it can also build
a rust project so if you have a project
I can we don't ever have to interface
with the rest compiler you can do it
directly so cargo so it runs like it
functions very much like a combination
of people in valve length the the second
set of tools that is quite useful for
this is it's called Rostock and Rostock
can build documentation out of your us
projects so if you have a library or an
executable and there's functions and
structs and all kinds of other stuff in
there you can just run a cargo dock and
it will build the documentation for it
with the help of Rostock and it opens up
in the browser and you can read it it's
a little bit like pi dock it's less like
sphinx so it will open it will build
documentation looks a little bit like
like every object in your API and then
the documentation string for it right
it's very convenient that it's built in
and it also means that if you have
dependencies in the application if you
do cargo dock it will also build a
documentation for all your dependencies
which means that you don't have to go to
the internet to consult the
documentation it's always there and it
is the documentation the correct version
which is very good so this is Wrestler
the documentation builder so I have a
lot of code on the slides and I think
for the most part you can kind of ignore
it it's just sort of a way as a taste to
see how the language looks like so this
is the obvious one I hope it's big
enough it's it's hello world it's a
function called main prints hello world
but he already shows one thing which I
think is interesting for rust there is
an exclamation mark after sort of the
function name right it's not the
function is a it's a macro so it's some
it expands at compile time into more
complex function calls the reason it's
doing that is because it can
variables in there in a way and then
these variables will be type checked
individually so if you would print for
instance hello world but the world would
be a second argument it would make sure
that the format string matches the
variables so it very efficiently
generates the correct codes and it type
checks it um and the reason mentioning
this is because micros are actually very
powerful and you can build them you own
you can also write compiler plugins for
the language so a lot of the more
involved libraries for rust will have
some of this meta programming code in it
this is a second slide I want to fill
which is it should show two things I
don't know how well I will do that but
the first part is there is some it will
show you a little bit how input syntax
looks like it's more or less similar to
how you do it - you have modules you can
import stuff from it but there are two
differences the first one is in line -
you can see there's a hash map being
imported and it's a type and it's a type
that's generic over the stuff that's in
the hash map so it's like a dictionary
but unlike a Python dictionary which can
store arbitrary objects this hash map
when created will be restricted to a
certain set of types and the biggest one
the biggest restriction you will see
here is that we are actually reading
strings from the from the coma from the
stem at input and these strings because
they're read here and sort of this in
the middle of the screen there will be
stored in the hash map as a string so
this is the hash table format moment be
restricted to strings only and the
reason why you don't ever see that this
is a hash map of type string is because
rust will actually infer the types for
you so you don't have to write this a
hash map of string to string string to
integer because we're counting up it's a
it's a hash map that will automatically
get this this type information and the
second thing I want to point out is that
there's an employee up there for a thing
called efreet but if you actually look
through the slides there is no Ezra Kota
is no buffer in any way here and what
this does is it's a trait and traits are
a little bit like in Python this special
underscore
that's so friends if you want to add a
plus a a plus B in five maybe a under
under under under B traits are similar
to this so traits are waste at special
behavior to objects even if the objects
are not yours so for instance puff read
is the behavior for for all the methods
for doing buffered reading on something
so when I create a buffer puff reader in
the middle of the screen the lines
method will magically appear just
because buffer it is in context so I can
add methods on to other things this way
the the interesting thing about rust is
that it tracks ownership so if you for
instance here change my visitors this
used to be a conversion of items into an
iterator and it only takes the first 10
items if I change it to counts which is
an object from up there it'll actually
not compile and the reason for that is
that it will tell you that this object
has been moved into something else so
rust follows a very strict ownership
idea that any object can only have one
owner and that owner can borrow it out
to some limited degree but it will stop
you at compile time from doing all kinds
of stuff that would be perfectly fine in
another programming language so that's
how this looks like for the most part um
but I want to show you that rust is
actually very close to PI for me in many
ways it follows the same of - yeah I
think it's a beautiful language and one
of the ways in which is beautiful in my
mind is that it has a lot of support in
the language for effectively
automatically doing things that are very
boring and so friends if you have a
written a Web API in Python or you
consume the Web API a lot of the things
that you will do is manually pile some
trees and stuff drag it in break it out
with rust you have this automatic
ability to derive things instance by
saying this the right materializer it
will automatically make this struct into
something that can serialize into
chasing and I don't have to do that and
then this is from actually more or less
copy pasted from one of our tools this
does an HTTP request and an automatic
converts it into a
list of deployments so it's like the
entirety of serialize and deserialize is
completely hidden for you
it follows pythons general rules of
being explicit rather than implicit
biggest one is there is no none in the
language so everything has to be
explicitly set as optional then it's
finally you think follows the idea that
simplicity is better than complexity I
want to just generally show you that
this looks more or less like Python code
I mean obviously it's different but it
definitely doesn't look like C code or
C++ code even though it's at this very
low level and this is an example from
Redis library where you can do very
complex operations with it and it
doesn't really look very complex it's
just not nice to call it strange calls
and this I think is the best part of the
language is it gives you a lot of it
gives you a lot of information about
what you're doing wrong through linters
and warnings and compiler errors so for
instance here I'm opening a file but I'm
never handling the error that being
returned from it in in C that would be
like not a warning at all because it
wouldn't even know if you have to do
something return value in rust you can
explicitly define what just happened
so just side by side a little bit
special methods in Python will become
traits in rust so they are individual
you can make more of them you can
implement them for any objects it can
take other objects and add your personal
traits to it errors are very different
and I think that's the part that's
really relevant if you want to use rust
with Python by often you want to build
extension modules and errors you have to
make sure that they are being caught
within rust and then translated over to
the Python world in some way there are
two mechanisms for errors and rust one
of them is called panics kind of like
exceptions and the second one is is
explicitly returning results and that's
basically like returning a special value
that indicates failure that's I think an
interesting part that here's a rest
program we have very quickly seen but
it's a concept doesn't really exist in
Python as much if you raise an exception
in Python it bubbles up to whoever
decides to call it down I catch it down
it's very
can use for instance a library like
let's take requests for an example a
meeting HTTP requests instead of getting
a requests exception you might get the
socket IO error and the reason for that
is that nothing in in accepting requests
caches down the IO error and converts
into something else so you can have this
errors bubble up and there might be
errors in it which you don't really
expect from the API in rust you come to
that when you propagate an error you
have to convert the error into a common
type or you have to handle it internally
so there's an idiom in rust called the
question mark operator which will try to
execute an operation and when it fails
will convert the error into the common
area of a library so a user of your code
only sees one error type and that might
have sub error types so if you want to
try it the way to do it I would
recommend is to build extension modules
and I had this argument with a bunch of
people that said like the future is
service oriented architecture if you
build like individual rust services
individual goals services and this will
speak Network calls to each other that's
a lot of complexity and I don't actually
think it's a good idea and there is
definitely more to the world than a
monolithic application and service
oriented architecture I think it's
absurd the solution for this is modular
code have individual bits and pieces
that can be individually deployed and
then just live in the same interpreter
so extension modules is a very good way
so how do you marry 5mn rust and this is
the part where I find a little bit of
frustration in it because I I think I
found a really good way in which it
could theoretically work but in practice
it involves a lot of pain and sweat and
tears because of setup tools and I don't
know if you ever used setup tools like
internally tried to make it work in ways
in which was not originally intended to
be used so the way I would recommend or
way I would like it to work and I can
give you an indication of how way that
actually works at this point is you
build rust library you make a C API for
it which is more or less means the rest
of it can be consumed through CF Fi or C
types if you want and then you import it
in Python
the tools for this is cargo CFI set of
tools and and the wheel thing and this
is sort of what I want to achieve it's
not you sleep - because I I will skip
ahead a little bit because I want to
show you this part here it's terrible
this here if you ever went to the PIP
page of pillow it's a library written in
C it's images and whenever these people
making you release their heroes because
just for Python 2 and PI 3 not counting
I think Windows is not on there so just
always 10 plus Linux requires a total of
21 builds which means to have to make 21
individual releases for one release
because of the binary dependencies and
the only reason for that is because the
link against the Python so my goal is
not linked against the Python and that
is currently really hard so that would
require and we achieve that century but
the tooling is very very custom and I
would like to actually raise awareness a
little bit that this is something that
would be nice to build because it would
also help people that use C and C++ so
the path of success is not linked to lip
- but you see FFI because then this is
what we do you end up with just package
name in the wheel format just the
version it works with python - and
python 3 it doesn't have it doesn't
think as a python so there's no ABI
and the only thing you have to do is add
a platform tag and theoretically you can
build get away with rebuilds ignoring
windows windows would be for bills and
you can do this so there's a catch to
this and this is where it's good
absolutely absurd you need to basically
build version of your library if you
want to have it running under next with
a very very very old version of Linux so
you can install these docker images it's
called many Linux one I don't have
anyone ever built binary wheels for
Linux No
so the way it works is these locker
images if you install them in your
locker they are very old they have an
ancient version of
in it and I think so it Stephanie not
supported anymore I think at this point
it's eight years old it doesn't do is it
busy country when he has a cell requests
to any modern server because it doesn't
support sni and is really super painful
there are some modern tools in it but
more or less not really so for instance
days an ancient version of tech new
compiler collection there and all kinds
of stuff and this is sort of the best
way to build binary extensions for
Python and this super manual process so
this is sort of my points to raise
awareness is it would be really cool if
people that have an interest in either s
extensions or C++ or C and that feel a
pain in maintaining this to bundle
together and don't work on a way to
actually bridge between Python and rust
or between Python and C++ that doesn't
require lip - so what critic show you
roughly how this looks like the bridge
between rust and Python is you have an
error handler this error handler is more
or less set up that when you actually
erase and a panic and exception in rust
nothing happens then you need to make a
function that you execute which will
indicate an error to the Python library
so when you fail in rust you the pipe
inside can know that if an error
happened could look more or less like
this you have an error that you indicate
on that never happened and then in
Python you look at this then you do all
kinds of metric to actually set up a
common way to catch the sound I you
don't have to look at the code it's just
important this is actually a lot of
tooling that goes on before you have one
function then you need to actually build
every useable thing that sets up the
landing pad and only then you can
actually call define one function and we
are doing this right now manually all
the time then we have to actually bridge
this library header in C because the
common interface between rust and Python
sadly C then we can finally call this
and it's a lot of work I did this for
three or four libraries at this point
it's
kind of frustrating but the problem is
like a lot of reusable tooling doesn't
exist so what is missing we need a
better way to build wheels reusable
darker images and an arrest of a sci-fi
so a way to not go through a sea layer
ideally but what are the results and I
think this is the part where I want to
like despite the pain that you might see
in this the results are pretty good so
this is total CPU usage for all of our
servers on the before the deployment
where we introduced a source map
handling in rust and an empty part after
we not only basically kills the entire
like the server's basically were idle at
this point we could like his through a
bunch of servers away that we didn't
have to pay any more for so it obviously
was saving money and they were saving
CPU time and it just made it better but
it also made us realize that we don't
have to ditch the entire Python runtime
we only have to put individual problems
into faster solution so for instance
source map handling for us was 30
percent of what we did in total by just
putting this little piece of code into
rust gave us a lot of room that we can
use the Python runtime effectively in
other ways the problem is when things
goes wrong this is a bug I introduced
two days ago after deployment all the
servers run out of memory reason for
that was that there was about not in the
Python codes there was not a bug in the
rest code there was a bug in this trim
between them that caused the destructors
never to run so memory was just never
freed so I think it's great but we need
better tooling and if anyone has an
interest in rust as a language or in C++
as a language that we want to use with
Python maybe talk to me afterwards
because I did this so many times now
that it really wants to actually build a
reusable thing so that instead of this
becoming I could talk about all the
complexities involved in it it becomes
small affair hey this is like one thing
you install and it's awesome you're
right the rust function becomes call
over in Python because I actually think
that as a language it's one of the most
innovative things that happened in the
last couple of years and the fact that
we can use it in Python is really
valuable and I think it would be great
if this sort of mindset starts to
develop a little bit that you can
actually combine Python verse rust for
very good effect and with that I take
questions if anyone has any or
suggestions about how to improve our
setup thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>