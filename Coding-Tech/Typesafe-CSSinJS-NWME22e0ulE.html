<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Typesafe CSS-in-JS | Coder Coacher - Coaching Coders</title><meta content="Typesafe CSS-in-JS - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Typesafe CSS-in-JS</b></h2><h5 class="post__date">2018-04-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NWME22e0ulE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so as you just heard i'm here today to
talk about type safety and CSS and j/s
both of which are very shiny
quite new and a really fun to work with
so just to be the background around how
we got to type safety and CSS and
jeaious we've had this massive rise of
j/s everywhere
we've got frameworks like react and
angular and as those frameworks got
bigger and more mature we've started to
see type systems from the likes of
Facebook and Microsoft where you'll have
some level of type safety with your
JavaScript and that language will just
compile to JavaScript and it helps make
those large code bases a bit more
maintainable and flexible for future
usage so on the CSS nsj side of things
we should probably start with what CSS
outside JSS with these modern frameworks
where you're doing component based
development your markup is a function of
state it's quite easy to understand
based on this URL and flowing through
your JSX if you're using react exactly
what markup you're going to be getting
when it comes to styling side of things
it's a bit more of an unknown a lot of
frameworks we'll be having will be
important
perhaps for different CSS external files
then they might be using webpack loaders
for sass to have some level of component
based styling but the CSS is not
necessarily determinable based on just
state CSS in jeaious both your markup
and your styling is a function of your
state and so based on a URL or a user
being logged in you can work out exactly
what styles and only those styles are
actually created for the page so it
enables pattern things like critical CSS
and really helps out if you're doing
server-side rendering to only shoot down
the
CSS which is needed for any particular
page so it's really awesome so as we
started there before a lot of this talk
is going to be using react however CSS
in jeaious exists with a bunch of the
other frameworks now but when you add
type safety to something like react and
CSS nsj you start to live in the happily
ever after where things are really shiny
and you won't enjoy coding all the
things and so we'll just start with
where CSS and J's started the term was
first popularized by inline styles in
react where as you're doing your
templating inside your JSX there there's
a style property available which you can
just add some inline Styles those will
get added in line in your resulting HTML
markup but then later on other
frameworks saw that pattern thought this
is really awesome and they created some
other handy helpers that would extract
all of that and put it into your head or
do other things but the basic pattern
was very similar and this example here
is actually got it turned on with
typescript we'll just have a look at the
Taipings for where we started with type
safety in CSS and j/s they just typed a
subset of CSS properties for some of
them they had pretty strong type
safeties so this aligned content
property here you'll get autocomplete on
the key and the value and if you do a
misspelling which is quite common in CSS
you'll get immediate feedback about that
unfortunately there's a lot of CSS
properties that allow quite flexible
values border 10px solid red
you can't give types a key for that sort
of thing just using this pattern so
they're just type two strings so this
was the inline styles
popularized by react what was happening
in j/s about the same time is the
language was getting new features one
particular new features were template
literals of which the more advanced
version was the tagged template literals
and these would allow you to pass
template literals with function that's
at bottom one that's just grad from MD
NN MD and the examples and so people who
were doing a lot of react development
who had traditionally been putting a lot
of work into other solutions for CSS at
scale saw this and thought wow we could
do some really awesome stuff with this
that slide is far too small to see on
apologize but essentially you've got a
function up the top there that you've
set up which would allow users to use a
string as an API for writing their CSS
within JavaScript and then have
expressions within that of course this
is a bit of a back step when it comes to
type safety for CSS and jeaious because
we've gone back to a string interface
and you're not going to get a lot of
safety there however really popularized
the props based styling pattern where
you could have functions which you could
pass props to so when you're doing
component based development could pass
props into what was ever creating your
CSS and rather than having three
different class names that you're going
to select from based on those props you
could just write the exact CSS in each
case which was really handy and here's
just an example using styled components
you get auto complete on the Dom tags of
the interface but then once you're
inside that tag template you have no
real safety but then down below there
what you can see is using so that then
returns a react component which you can
just use inside your JSX
inside your templating and it has the
props flowing through quite nicely so
then we had glamorous came out early ish
last year I think about a call and it
followed on from some of the api's that
had been pioneered by the styled
components people but they quite liked
the CSS object interface for writing
your CSS so they mixed that pattern of
having component factories with CSS
objects and this was really exciting for
where I was working at the time we had
been using processes peer-review
conventions such as been to protect our
code base from bad things happening and
this was working for most of the time
for our front-end devs with strong CSS
knowledge however that wasn't all of us
we had people with a range of experience
across domains and so bad things were
still happening CSS and jas with
something quite glamorous which we would
be able to type look like it offered
some technical solutions to the problems
we were having
so the initial Taipings somebody was
obviously using it on a project they'd
ridden some Taipings internally and they
went to contribute that back to the
community what had been happening a lot
of that time was people would put the
Taipings on definitely typed in Joseph
which is a it's a repo set up by
Microsoft which makes all the types of
ailable to install but about this time
people were starting to bundle
definitions with the frameworks so
somebody thought I'll try and get those
landed there the person who'd led the
development of it wasn't quite sure
about it but the feedback he got and
it's quite surely is that it's a lot
better for consumers when you have
bundle typed it implies that the project
is type friendly be those bundle types
flow or typescript and when you change
or add something you can expect a PR
shortly to add type support for that and
a bunch of other things it does however
lead to a bit of extra contributor
overhead because you've got more
activity going on so those initial
definitions they just covered a small
subset about the of the API of glamorous
and there was also a clear expectation
set around how those types would be
maintained it would be up to typescript
users to maintain those which was
everybody accepted and was great what
was also very helpful was the project
had very clear contribution guidelines
this provided clear guidance for the
initial PR to add them but also for
anybody who wanted to extend the
Taipings or add additional features it
was very clear how they could add those
features and get them landed so if
you're adding types to a framework
highly recommend having contribution
guidelines well laid out so initially it
was set up with the types separated out
into a toppings folder which is a fairly
standard thing with in typescript
definitions and also flow ones and then
there's just a field you put in your
package JSON with a the location of
where the toppings are for when
typescript does type acquisition on
usage and it also just had a simple test
file the way testing works for a lot of
typescript
definitions is that they just have a
single file that just goes through all
the uses that the types provide and make
sure that the compiler doesn't generate
any error output and as you can imagine
there's some problems with that but
we'll touch on that in a bit and so
sorry is that showing up there fantastic
so this is just some of the API is that
glamorous had to give an idea as we jump
into the Tri Keynes that it has what
sort of support it needed and the range
of types so we just start with some
glamorous Dom and built in component
factories the second signature their
glamorous talk gives just a shortcut to
the first one it also had built-in
components so you could just import a
div from glamorous name name sized
exports and also glamour Steve would
work as well
this actually presented a bit of
challenge with typescript because
there's no easy way to share named
exports with interfaces for typing so
there was a fair bit of type duplication
also with the glamorous octave for the
other built-in component factories then
glamorous could also take components
when you setup a component factory so
that needed to be typed and it also had
options which would then change the
behavior of the resulting component so
if you set that props are CSS overrides
this equal to true when you finally use
that component you then have available
all of the CSS properties as props on
that component which will get added up
into the CSS and then there's also with
component API which you can change what
component the eventuated clamorous
component factory returns so a huge api
service with things at the top level
impacting things a few levels down which
was quite interesting so in terms of
type coverage we'll just touch on
initially the CSS and SVG properties so
we'll start with the these were very
similar to the react typings
initially we just used to react CSS
property typings then we had a great PR
from a contributor who vented those but
then went through property by property
and checking the MDM documentation and
tidying up the types so for some things
such as display or float i think where
the react ripens for would just accept
any string it was tightened up a bit so
for the autocomplete it was really
helpful and for misspellings it would
avoid that then we just also need to
support the pseudo properties so that's
how you would use that and then when
you're using that anywhere where it's
being typed you're going to get type
safety which is really handy you also
get autocomplete it's quite wonderful
then we had a lossy version of the CS
properties the way that a lot of the CSS
and Jas frameworks work with their CSS
objects is they support something
similar to sass and other things where
you can have contextual selectors but
also just for media queries where you
have another object underneath it
because of this particular type index
that would be getting added onto it it
meant that for the previous CSS objects
you actually lose type safety so whilst
if you've typed float correctly get type
safety on the properties in order to
complete if you accidentally type flat
it's going to pass which is a bit sad
there are some other alternative CSS and
J's frameworks that have alternative
syntax for this sort of stuff they're
not quite as widely adopted or and but
should be interesting in the future and
so then just using it all together it's
kind of like CSS it's just using an
object J object syntax it all fits
together quite well so those are just
some examples so style arguments these
are the things that when we saw earlier
on the glamorous API you would set up a
component factory with either a Dom tag
or a component these are the arguments
that you then pass through that to
create your CSS it can take a function
which would return some properties or a
string or also an array of properties
and strings it would also accept a style
array so an array of all of those things
and then a star arguments sort of a
combination of those plus a couple of
other signatures that I've just taken
out of that for brevity's sake but then
for the style arguments that's for
dynamic styles and you can see their
props are getting passed to as a generic
so that they're available in the style
functions
a lot of the time when you do in CSS in
JSU won't actually use props flowing
through and so there's also a simpler
static style argument which option also
helps out with the compiler output if
something goes wrong it's a bit simpler
in those cases it's been easier to read
and so here's an example of how those
types are then checked on a component so
here that will pass because it's a CSS
properties object and the values are
correct here this would pass because
it's a function
I haven't actually typed this but it the
props if I had a type on the example
component would be typed to something
and then you can use that in determining
the output of their display here it
would pass because it's going to return
a string here would pass because it's
going to return an array of all those
things so quite a lot of different
things you could do with star arguments
or with support and so next look at just
a single one of the glamorous API shapes
that we saw earlier where you pass a
component factory to the glamorous
function which will return you a
glamorous component factory so this is a
heavily trimmed down version of the
types so we start with the main export
from the definitions which is this
glamorous interface then the glamorous
interface
this looks really noisy and messy
essentially it's just a object which
takes a component with some optional
objects and returns a glamorous
component factories we've had to use a
lot of generics here because of all the
different changes that happen downstream
in dark Lammers component factory and
then the resulting glamorous component
that is created from that in order to
get type safety there but you don't
actually have to pass any of those
generics all the time most of the time
if you're doing something dynamic with
that component you'll just pass the
props and the rest will just all match
together
if you've typed it on that component
which is really nice we use overloading
with this signature because depending on
the options that you pass in again the
signature of the also dish the API of
the resulting glamorous component is
quite different it will
that if you've set the props or css
overrides options to true a bit down you
can just use those props and so they
need to be typed as well so that's the
initial creation then we get into the
actual component factory so that returns
the component factory component
factories just take those generic crops
and initially we start with a over load
for the static styles we put that at the
top because even though it should match
down the bottom as well so the next two
we'll see there was a bit of a memory
leak issue with typescript and this just
has CSS properties as arguments pretty
much you can't do any functions or
anything in there then we have an
overload for if your props have got a
theme so there's a concept of a theme
provider and clamorous which I won't go
into but essentially there's some
magical props that can end up on that
component and be available for whilst
you do in your styling and we also use
as part of this so we say that when they
set up the props for the component
factory so for those functions that we
turn the styles the themes going to be
available but then when they we actually
return the glamorous component from this
all those props that are there they need
to be set up
but the theme doesn't type script
doesn't have subtraction type submit'
kind of gives something similar but it
does actually pollute the intellisense
and compiler output so I would recommend
avoiding where possible and then finally
we just have a overload for the
component factory where there is just
the props no theme which is quite handy
and just keeps the types of it's simpler
and then finally the component factory
each returns a clamorous component which
is just a react component factory with
various external props and extra
glamorous props so the external props in
some case will just be the props
sometimes it will be the CSS properties
if we had offset that props or CSS
overrides earlier on and then it also
has
some methods available on it such as
with component which we saw earlier
which will let you have all the props
and all the type in but for a slightly
different component which is this one
here and there's a couple of other ones
there so what was getting type in typed
initially it started off with just a
very small subset of what was available
in glamorous
it was quite understandable easy to use
but there was a lot of stuff that you
couldn't do then we started to add
overloads and generics to provide
support for both the alternative
interfaces but also the generics to get
better type safety on some things that
initially that were essentially such as
pops just a any so you didn't have that
much safety then we introduced the emit
type to support the theme being excluded
it seems like a really good idea at the
time there was probably an alternative
syntax that we could have used using an
additional generic but this less magical
type and had we have used that it would
have led to much cleaner compiler output
and when users are having errors easier
to understand what's going on and then
eventually we started having to use
overloads coupled with generics which
would extend the extend from things so
that we could limit this particular
generic to match this shape and then
we'll do this thing and it all got very
complicated very fast that was a very
small subset in some places there were
extra overloads for things like CSS
properties versus SVG properties
unfortunately a limitation of the
compiler typescript compiler at this
point in time meant that also the
intellisense
at this point in time meant that if you
try and union that there you would just
lose autocomplete it would still type
but the developer experience would get
worse and so pretty massive amount of
types
as you can imagine things go wrong when
you've got such large types and the
standard definition strategy of just
testing what is meant to work and making
sure that the compiler succeeds wasn't
really sufficient to allow additional
contributors to easily add things and
not have to worry about accidentally
breaking something else so we introduced
some additional testing we just set up a
should fail file adjacent to the test
file and then we just used just
snapshotting to run the compiler on that
file as well make sure that everything
that we'd set up to fail was ending up
in that snapshot and that did pick up
quite regularly where people would sort
of think oh I can just make this change
here and not realize that that would
actually knock out something else with
one of the other glamorous interfaces so
really handy pattern there's some other
strategies there now that a little less
sort of hacky here we're just using
spawn to run the compiler and snapshot
it but definitely recommend testing both
sides and also just on the testing side
of things you'll often find that if
you're using glamorous as part of
something that else which you're
generating definitions from it has
subtly different behavior with the
compiler so recommend testing in
definitions of declarations bode with
your tests another thing that we did
with the types in some places was we did
things that weren't strictly necessary
but they improved the developer
experience in one case if we used a
union for type the you would get type
safety but when you're using vs code or
another editor that's using Intel a
sense you would lose autocomplete which
was a really handy feature and people
who aren't using typescript are also
getting benefits off it so we would do
some sort of happy things it's
worthwhile commenting when you do that
make sure that in a couple of months
time both flow and typescript moving
really rapidly a lot of things this one
we found after about two months we could
actually just move to a spread under
Union and it all worked nicely so worth
commenting those things sometimes you
need to get a bit creative when you're
setting up types as well or using it
with the type system we had a fun one
where the rollout compilation for
glamorous was incompatible with height
how typescript was doing the importing
so we actually added this this to the
main glamorous source file just to allow
usage with typescript but where you do
get creative with things like this again
it's really worthwhile adding some
comments so that the next person knows
what's going on and it's a pretty
massive top mount type in their large
surface area with the API there were
some pretty massive mistakes that were
made which were in most cases quite
avoidable a couple of those one we had
this issue opened up was quite an
interesting one so there was a memory
leak with the Taipings which meant that
when you were using that with a project
with a lot of glamorous components
pretty quickly the compiler would bath
and you would get out of memory that was
it was interesting because the compiler
would find with tests and depending on
project size and also usage of the types
it would just never show up and the way
that it part of why it happened was
there a bunch of changes to the types
getting added to a v-necks branch so
nobody was testing them in production
all of a sudden v next launched there
were all these new types that landed and
how they interacted led to this memory
like so it took a few days to sort of
work out where that was and get an
update going another one was the
definitions can sometimes get quite
overwhelming this was a very politely
worded issue from somebody where they
had gone to use the
glamorous with typescript and the
autocomplete was just out of control as
you start to type in the arguments you
would get this enormous window pop up
with all the different options and it
would hijack your arrow keys as to go
through the different options so this
one was quite well in some ways easily
solved went back in and we structured
some of the Taipings so that the output
for things like Intel he sense but also
just compiler output if there's an error
was more readable and more clear bit
more concise and yeah so definitely
recommend limiting type coverage when
you're typing the framework like this if
the framework doesn't intend a usage
don't type it there were a couple of PRS
landed early on that were landed purely
to supports and some stuff that had
started happening by mistake and was
never really intended by the framework
or the lead contributors and because
that got typed early it's hard to remove
type coverage for anything that you've
added because people will complain when
they do a update and things break for a
non major also try to ensure types don't
make workflows difficult like you
intellisense as you just saw and should
always use comments to help consumers
this will win you a lot of love for both
typescript and flow and just Jas
developers because in things like Intel
assents for api's that are immediately
clear just off the name of that property
they get a little bit of extra
information about how to use it it's
also really important with this sort of
thing to enable contributors something
really awesome that's happened in the
last year is that there's now online
play boxes where you can set up a full
typescript and flow project and
import glamorous and have the sort of
definitions being used as you're typing
online and getting error output in
browser so setting up a sandbox for
people who are having issues to be able
to quickly set up a reproduction along
with the issue rather than having us set
up a whole repo it's really handy and
also just obvious things like asking for
the version of typescript they're using
if they are having an issue with the
bundle declarations is really handy so
well now just have a quick look at how
you use the CSS nsj which I've scoped
and so here we have a glamorous
component factory with styles where
we're getting autocomplete on both the
property name and then the values that
it accepts really handy really useful
we'll jump straight from that to this is
something we're going to now create with
CSS nsj and typescript so it's a
reproduction of the LCA schedule where
the it starts at a calendar then just
collapse down to a talk by talk by talk
and gives us some really clean HTML
without lots of wrapping divs or reused
CSS or anything like that so we'll start
with a timetable react component which
if we jump into that and have a look at
that's just a glamorous emotion
component Factory another CSS nsj
framework we've got our CSS being
returned from this we're going to use
the CSS grid we're able to use the props
and that that's being taught with which
has a number of active rooms to set up
the amount of columns that we want on
that so then if we jump back to the time
table inside of that time table we're
going to have time starts which are just
going to show up on the left-hand side
as we saw and pass that through the
information it needs to do that and it's
just another react component which then
has the time start
a ch3 and then that's going to use the
props to set up the CSS to put it in the
collect correct row which is nice and
handy there and the correct column as
well then we'll jump onto the slot so
that's the actual talks as we go through
they're going to have a use another
component we'll just have a look at the
star slot we won't go through all of it
that takes a bunch of props which go
into the styling again I've collapsed
this so it doesn't include all the
stylings required but it's going to grab
the using the room index it's going to
run another method which gets moon
colored that just takes a CSS color
value and adjusts the hue left and right
so that we get the nice colors going
along and we can have sort of infinite
amount of rooms or just a few and then
it's going to select the column and the
amount of rows that torque should span
based on its time start and it's time
offset so as we've been going through
here only the CSS that is absolutely
required for each of these slots is
being generated in cases where the CSS
is in common
it will dedupe those Styles
automatically for you so there's no need
for by handy chipping it will be
producing a really nice clean markup
there's no need for wrapping divs to
sort of enable this kind of nice visual
structure and it's really really easy
and fast so this whole thing took about
20 minutes to get running which normally
with CSS would take an enormous what
might take a bit longer to get all of
those grids and calls if you weren't
doing it inside of j/s and being able to
use those patterns so just have a look
at the future of CSS MJS and some of the
things that type script and flow are
enabling and the first one this is very
limited to typescript in particular
there's this really cool thing called
typescript server
plugins which gives you that string API
for CSS that we talked about earlier on
when that first came around
there's no way to type the string these
server plugins actually allow you to
create your own sort of type safety for
certain things and give autocomplete in
editors using intellisense and whatnot
so here we're actually getting type safe
CSS strings in j/s which is really
powerful and I think very exciting for
the future there's also some plays
around how you generate types at the
moment for glamorous as you saw there
was the glamorous dev kool glamorous
with the div string there was the export
so import diva on glamorous there was
the clamorous dot uppercase div which
are all doing fairly similar stuff and
using the same sets of types but they
have to be typed separately and so we've
generated try pings you can sort of
automate some of that which both makes
it a bit easier for contributors when
they want to make a change to some of
those big files they can just make it in
one place but also gives you a bit more
confidence in the definitions because as
it is there's a fair bit of copy pasting
these are just for the different files
each of which are a couple of hundred
lines long another really exciting thing
regex tripes
there's a PR open on the typescript
repository at the moment it's probably
not going to land for a couple of major
couple of versions but it's been
actively discussed by the typescript
team and looks really exciting
not just for CSS and J's but a whole
range of other applications and so this
isn't actually necessary this isn't
anything to do with typescript and CSS
and J's this is just really cool things
you can do with CSS and jus because it's
so shiny you can do CSS snapshotting
alongside
your markup for your components so if
you have things go wrong it's easier to
pick up in peer review and also just
whilst we're developing traditionally
your us snapshots might contain a couple
of class names which you may or may not
have set and really no information about
the style rules but this sort of opens
up a lot more confidence it does
generate very noisy tests however which
brings us to visual snapshots we're on a
unit level it's really easy when you're
using something like CSS in GIS to test
that that component is pixel perfect for
changes so what you can see here and
isn't working is actually you'd never
see that if you were just looking at it
in PR by running the code but here on
the bottom one something it's just a
couple of pixels off and you pick that
stuff up immediately it's really really
amazing
so just summarize some of the points
we've touched on type systems really
help keep code maintainable and really
help enable growth of applications when
you think about CSS and is a really nice
way to think about it is it's turning
it's adding the styling to be a function
of the state in addition to your markup
you can do inline Styles you can have
styles thrown up into your head you can
do both string an object as an API and
you've now got type safety with both of
them thanks to things like the server
plugins the component factories really
enable you as a developer with component
based dev to have props impact to your
styling in terms of when you're actually
setting up definitions and declarations
for frameworks developers love them it's
useful if you keep the type simple it
both helps the users and also helps
people who want to contribute be able to
contribute and should test types well as
well as
it sounds really obvious but within the
typescript and also flow communities the
way that testing is happening currently
that is not as common as it should be
you can type a lot more than you think
but you probably shouldn't it'll just
make it harder for people to use the
types and contribute to them in the
future
compilers aren't perfect but there's
lots of ways to work around them and
yeah types should enable users and not
over-well them if you're interested in
CSS MJS there's a excellent repo on
github CSS nsj 101 I highly recommend
checking it out
it has a thorough overview of all the
different options that are out there
currently how you would use them and the
advantages of the various options these
are also some great people to follow on
Twitter Vasiliy in particular when it
comes to typescript he wrote a CSS and
J's framework with just typescript and
is really excellent and all of the other
ones
Kent Dodds is the creator of glamorous
and the other people out there have
created other CSS and J's frameworks
really awesome people and thank you very
much that is CSS nsj and type safety</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>