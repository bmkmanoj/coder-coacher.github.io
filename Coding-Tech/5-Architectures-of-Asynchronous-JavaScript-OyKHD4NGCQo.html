<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>5 Architectures of Asynchronous JavaScript | Coder Coacher - Coaching Coders</title><meta content="5 Architectures of Asynchronous JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>5 Architectures of Asynchronous JavaScript</b></h2><h5 class="post__date">2018-03-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OyKHD4NGCQo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so welcome everyone thanks for
joining this session I'm not sure if
it's not too loud but okay we're gonna
discuss different ways to deal with
asynchronous operations in JavaScript so
let me introduce myself my name is tamas
du chien I'm a software architect and
developer for a few years I've been
concentrating on delivering complex
enterprise scale interfaces and apart
from my daily work I do trainings on
JavaScript typescript JavaScript
frameworks and last but not least
asynchronous JavaScript programming so
what we are going to discuss today is
very briefly recall what is the
difference between synchronous and
asynchronous execution in JavaScript
then we'll go to asynchronous mechanics
in JavaScript since the fundamentals is
freedom right we need to understand what
is the mechanics of event loop of the
run to completion in order to get back
get into the main topic which is the
five different architectures so if you
want to draw like visualize how to get
all these things in order let's draw a
landscape of what we have so the first
and most important thing in JavaScript
is a function right in languages like
Java the an object object-oriented
programming a class is the most
important thing we focus on right and in
JavaScript a function function execution
function scope this is the most
important part we need to understand so
first we need to know which function is
going to be involved synchronously and
which is going to be asynchronously this
is pretty deterministic we just need to
know it which one is which then we'll
get to event loop and the run to
completion which is just the execution
model and now we've got callbacks which
is just plainly
executing a function with let's say no
architecture at all
we've got event-driven design finally
we've got the promise pattern promise is
just a single operation that is going to
be
completed in the future now when we
combine promises with generators
generator is a new feature released in
ACMA script 6 the new version of
JavaScript we get a amazing combination
which is called co-routines which is
some kind of a breakthrough in thinking
of asynchronous programming in
JavaScript combining multiple
co-routines which are talking to each
other
remember javascript is single threaded
right so we will have let's say blocking
sequences of operations that are talking
to each other right within one thread
and finally the co-routines have found
their natural evolution which is called
async await something that is going to
be released in upcoming version of Atma
script probably this year and finally
something a little different than the
rest is reactive streams which I guess
at least some of you are familiar from
rx Java exactly if you want to do photos
this is the one of the best sliced to do
that ok
so often there are many people who do
JavaScript without actually
understanding JavaScript right and this
is how it ends especially when it comes
to asynchronous stuff right because we
are used to from languages like Java or
C sharp we are used to code that is
written linear right and is executed in
a linear manner right and in JavaScript
the code is written like this but it's
executed in completely different order
right so we need to in order to avoid
that situation we need to understand
what is synchronous and what is
asynchronous right so basically we
should know this from any kind of any
kind of language that we've been working
like synchronous is blocking
asynchronous is non blocking so
basically the difference is important
when we want to perform an operation
that we don't have under control and we
have to wait for something so either we
do something in the meantime or we need
to stop right in synchronous the code is
executed in a linear way whether in
asynchronous were just registering now
we're registering something to be
executed later so we can
and at some later point in time we will
get back to the function this is why
it's not executed linear and a good
example to visualize this situation is
doing let's say making a cup of tea
right so we need to get water into the
this boiling thing right and if I was
doing it normal like we we the humans
are various synchronous right we are
postponing things right so I will set
the water to boil right and when this
thing is being awaited right to be
finished then I'm picking a bag of tea
right and now I've got no task that I
could do forward so I'm just waiting
until the water is already boiling and
I'm just pouring the water into the mug
right this is a synchronous weather if I
was doing this in a synchronous manner
if I set up the water and I was waiting
for the water I would just stop I would
just freeze right doing nothing waiting
for this thing to be finished and then I
could just take this tea back right to
finish the job so this would be a huge
loss of time obviously in server-side
languages we've got multi-threaded right
parallel programming in JavaScript
except for web workers we don't have it
especially that web workers don't have
access to everything that is available
in the browser right so we need to cope
with things in asynchronous manner
everything is asynchronous right in
JavaScript right so we need to really
understand it very well so we've got
basically two fundamental concurrency
models
the first one is cooperative which means
that different tasks are the same let's
say are equal to each other are the same
important right whether it is in
pre-emptive some tasks are more
important and other tasks are less
important than the others right so in
cooperative if somebody has started
doing his job
there is no way to kick him out of the
queue right to say all these guys more
important wait until he's done right
whether in pre-emptive there can be a
situation that a more important guy will
come
and do here's task immediately and the
rest will have to just spread and wait
right so an example of pre-emptive
concurrency is just an operating system
right some processes are more important
and some other processes are less
important javascript is cooperative
concurrency so it's just a cue to
wherever right so this explains why set
interval and set timeout functions they
guarantee at least the time
not exactly the time you should maybe
maybe you heard about that if we do a
set timeout with 1000 milliseconds it
doesn't mean that it will be executed
after one second right and this is
because if there is another task that
had been scheduled and it's running
right JavaScript is in a concur
employment cooperative concurrency model
that's why there is no way to kick the
actual task away right so if we do a set
timeout or a set interval this works
in the same way in this context we have
to wait right until the queue is just
emptied and our task can be done right
and another situation when we can use
this knowledge is let's say we fetch 100
items from a server right and we want to
display a list of 100 items and if we do
it this way
the interface freezes basically right
because there is a lot of Dom operations
that we need to do and if this was just
one task that had to do 100 items and it
was purely synchronous right there is no
way that the mouse can interact with the
user interface or that we can basically
do anything with the interface right
that's why it freezes because purely
synchronous
a very simple solution to this problem
is to to split it right and then either
to do a recursive set timeout or to do a
set interval and just do the things one
by one so so that it just split between
different like let's say pieces of the
code to be executed right okay so we
need to understand we need to remember
which callbacks are going to be a
secured in a synchronous and
asynchronous way an example of
asynchronous execution is for each map
feels refined reduce and all these kind
of functional programming high order
functions whether a synchronous example
is set timeouts that interval
Ajax callbacks right yes if something is
synchronous it means that basically it
will be executed immediately whether in
asynchronous there are two things right
one has to register and set timeout
itself is executed synchronously right
now it's registering the thing to be
done later and this thing is going to be
executed later right so in asynchronous
from JavaScript point of view it's
always two things we need to register
now right immediately and then the thing
will be executed asynchronously so in
this simple code snippet we've got a
list of elements 1 2 3 we've got a
console.log before the for each
console.log inside for each item and
finally console.log after what is going
to be the output here 3 yeah before 1 2
3 and after so it goes like this
it goes here executes the list line
execute the console.log then it goes
inside immediately right and goes to the
console log and now this piece of code
is finished right so we need to also
understand in terms of run to completion
which we'll talk about in later in a
second that javascript can always
execute a piece of code right this is
going to be a single what we call a
message and such message will be put
onto the message queue and asynchronous
example we've got a console log then
we've got a set timeout and we've got a
console log after the order is going to
be before after inside exactly so what
is going to be executed is console log
then we are executing set timeout which
is basically taking this function
putting it into a Web API this is
waiting right and Web API is often a
different thread right JavaScript is
single threaded which means that the
code we are executing is under our and
which is under our control the
single-threaded right but things like
timers and Ajax WebSockets and this
thing this has to be something separate
right so this guy is going with his own
timer right and after zero milliseconds
it has already been put into the message
queue right but this guy has done
console.log set timeout synchronously
and now console.log after synchronously
right and this piece of code has been
finished it's considered finished so
just thrown out right and the event loop
is asking do you have anything for me to
execute right and there is this message
of this console log function here right
and it's just going to get it execute it
and throw it away so if we know what is
going to be synchronous and what is
going to be asynchronous we can always
take a look at the code trying to cut
right the pieces that are going to be
executed later right it's good to
visualize this in a way so that we
basically know what is the order of the
execution right so such function is
going to become a a message on the queue
the order of the messages appearing in
the queue is exactly the order which the
messages are going to be executed within
the event loop now timers like set
timeout set interval is one kind of web
api and web services such as HTTP and
WebSockets are another kind of API and
so on so basically each of them can have
a message that is let's say pending
waiting to be to be ready to be executed
right so each of these guys will have a
condition whether a message is ready a
timeout timeout condition to be ready is
basically whether the time has passed or
not yet right and for Ajax call the
condition would be whether the response
from the server has arrived yet or not
yet right so basically when this
condition is met then the web api is
putting the message on to the queue and
from this point there is no way to
cancel it right so when we are waiting
for a web
for a set time allowed or set interval
and this condition is not met yet
meaning the time has not passed yet we
can cancel it right but once this time
has already passed and the message is
put onto the queue and it has not been
executed yet because it's waiting in the
queue but whatever comes to the message
queue it's not possible to cancel it
anyway right
so there is another thing - - to keep in
mind and basically event loop can always
do one message at anti at a time so
basically if it's not doing anything at
this moment it just basically taking one
message like putting it on the table
right doing the stuff once it's done
it's just throwing it away
getting the next one so it's pretty
simple mechanism obviously this message
queue is a very big simplification
because there are many more queues and
in order to optimize it can be a lot
more complex so keep in mind this is
just a simplified model and even loop
and message queue are separate things
which we'll see in a while so if we've
got such code like this one the question
again is what is going to be the order
of the council locks appearing here this
function is called like this funny
function expression is called IIF e
immediately invoked function expression
which means that it's called
synchronously right so what is going to
be the order of execution of this
snippet
yes exactly it's going to be one four
five three two for each map filter find
reduce blah blah blah this is
synchronous this guy is also synchronous
a promise constructor in es6 is also
synchronous because it's greedy right so
it's going into it's finding that this
is an expression right but it's also
already invoked so it's going inside it
right doing console.log one registering
the function onto the web api
registering another function into the
web api doing console.log right it's
reaching the in ending curly brace so
it's basically return undefined going
out going here to execute console.log
five so we've got already one four five
now this message this piece of code is
finished so it's basically thrown out
right and this is called run to
completion that if this piece has
already started right synchronous peace
there is no way to interrupt it right
either it can finish successfully or
there might be an error which will just
interrupt the execution right but there
is no way to to suspend it or to cancel
it and this is the first message right
this is the second message which will
appear because basically in this Web API
time in this timer web api this is going
to being to be the first one which will
be ready right he will be the first to
read the queue and this guy will be the
second one to reach the queue right as
this is going to be the console.log
three and finally console.log two and
that's basically all okay so I guess
most of you are familiar with jQuery or
at least have seen it at least one once
in the lifetime
so given this kind of code let's analyze
what is the order order of execution of
this code right so we've got documents
ready then we are assigning a click even
handler on this pull me element whatever
this is and
when this click is going to be clicked
then we are slide toggle like we all be
we're going to move things right so this
is pretty obvious so what is the order
here okay so first of all how many
messages are there going to be here to
at least three right it depends on how
many times we'll click so the first one
is that JavaScript will come here it
will execute what is the document jQuery
thing and it will register the ready
event handler right so this will this
line and this line is going to be
executed and it's finished right now
it's waiting until the ready event is
going to be fired when ready event is
going to be fired this callback function
from this point is going to be executed
right so then it's trying to find where
is this pull me element right and it's
registering click handler on this
element right which is going to be this
line and this line and it's finished the
second the second message is finished
right and now it's waiting for user
interaction
so basically me clicking here right so
whenever I click this function is going
to be executed right so we can see that
the function calls are being nested
right this is a callback hell which will
this can lead to callback hell which
we'll see in a while but basically each
function that is going to be
asynchronous is a different message that
is going to be executed invoke later
okay one more important thing is that
the order of asynchronous operations is
always unreliable uncertain unstable
unpredictable and so on right if we make
any assumptions on what the order is
going to be we are introducing race
conditions right so this is a very
simple example we've got a customer
variable here in this code and we are
shooting an ajax HTTP call on to the
customers when it's finished we are
going to store
the data inside this variable and always
when you do it on our local house it
just takes half a second right and now
we know that if you want to fetch
products it takes a lot more time so we
are assuming what the order is going to
be right so when this products when
these products are going to be are going
to arrive we want to use the customers
from the variable from the first call
right this is the assumption and we want
to use the products and do something
with it this works as long as the order
here is right right so and this is a
very simple way to mess up the code if
we do any kind of assumptions what the
order is going to be so again at this
level there is the first message that we
will do for assignments then we are
initializing the Ajax call synchronously
right here right now
it's basically shooting the HTTP request
outside the browser then it's going to
this line it's shooting this out of the
browser so that the two requests are
being executed parallely right and now
we are making the assumption which is
basically I race conditions something we
should never do so this was just
callbacks and in order to make interface
elements communicate to each other
something that is built in to JavaScript
is obviously browser events so it's
every every event like click focus on
mouse move Mouse mouse out and this kind
of events change right we can attach an
even handler right to an element that
will trigger the event and basically
this is going to be another message on
the message queue once this even has
been triggered apart from the UI events
we can do some kind of logic application
logic events right so we are creating
our own our own implementation so that
if something happens let's say again
this is a click we are going to trigger
a custom element that represents
something in our application right we
can do it on a component level or we can
do it on a global level like here in
backbone
on so we can have multiple channels that
are going to trigger this events and we
can listen on any of these events right
so this basically depends on a browser
on a framework right but the problem
with both callbacks and events is that
it very very soon it can lead to
something that is called callback hell
basically if we need to execute
something after this async operation is
done then we need to get inside the
function right so here we are creating a
a simple script to execute table
creation in nodejs
so we're doing a connection Kure that
when this thing is done a function will
be invoked then create a table database
that if it doesn't exist then use the
table then finally create the table and
probably there is some error that might
appear at this point right so we are
going deeper and deeper and deeper right
this is what we call callback hell
flying the pyramid of Doom or whatever
kind of name right but basically the
problem is that this code is becoming
very difficult to maintain right it does
not scale very well this is a simple
example quite simple and this is more
hardcore example and believe me this is
what happens if you go with pure
callbacks or pure events right so
basically javascript community finds
these two solutions not to scale very
well and this is also one of the reasons
that rxjs is taking JavaScript by storm
right because reactive approach is a lot
easier to maintain once you have
understood it okay so let's get let's
get to the next approach we've got a
promise how many of you have been using
promises okay so it's I would say
roughly half of a room so just to remind
it very remind the recall the basics
very quickly I promise is a single
operation that is being like running by
the way we have created it and we are
awaiting it to either fail or succeed in
future right but we don't know the the
result of it so far right so we can
fetch some data and we can attach a
callback function right if it executes
in a positive if it completes in a
positive way or if any of these like
fetch data or if this callback if any of
them fail then it will just jump it will
fall to the first appearance of the
catch right and this is going to to
handle any errors right so we can have
some kind of built into the browser
mechanisms or we can create our own
domain operations or any kind of
application operations and represent it
as a promise basically a promise is a
single thing this is very important that
it's just a single it's not repetitive
right so this is a very big limitation a
promise can have three states and at the
moment a promise is created it's in a
state pending right it can settle it
means that it will finally set down it
its state and then it becomes immutable
right so it cannot change if we want to
change the state of a promise that has
already been settled is just going to
ignore it right so it can it can either
fulfill right and then all the positive
then callbacks will be finished or if
it's rejected then it's just finding for
the first catch statement right to
execute the negative scenario so the
limitations of the promises promises is
a promise as a single item so if there
is anything that is going to be repeated
in our application I promise it's not a
good thing right it just doesn't match
because we would have to recreate
another promise right so if we want to
have some events rx streams would be a
lot better idea
a promise is greedy meaning that when I
create a promise it's already running
the operation is already trying to
complete right it's it's it's somewhere
in the way and we cannot cancel it right
the different for instance reactive
streams are cancelable meaning that if I
unsubscribe at some point and there will
be new items being triggered
I'm not going to react to them right
whether in promises if I have a promise
that have already resolved and this
promise has already resolved then it
will execute the the funk of the
function call back right so there is
basically no way to roll back the
function execution right this is pretty
obvious there is no mechanism to do that
sorry but if we have a promise that is
still pending right and we would like to
cancel it there is no function that has
been already invoked so there is nothing
to rollback but anyway there is no way
to cancel it even if it was not invoked
and this is not a stupid thing this is
actually a design to make the promises
as simple and as small as possible
actually if you think about it using the
fact that a promise represents a single
thing whatever you would like to do it
makes sense that the promises are greedy
and there is no way to cancel them
another limitation is that when we
chained promises the value of a promise
right I promise resolves with a single
value right it's always a single value
it can be a list it can be an object it
can be a primitive right but it's always
a single item the value is always in
available inside the chain right there
is no way to access the value outside
the chain why because of run to
completion loop because the scope that
has started the promise will
synchronously start the promise register
the next steps don't wait until they're
finished and it will probably execute
the code that you wanted to use the
value before the functions the function
called the callbacks could be executed
right so this is the reason that you can
access the value only within the promise
chain right and finally we have only in
a promise chain we have only the
previous step available so if there is
any situation that I would like to reuse
a value not from the previous step
directory via step but from two steps
before or three steps before or five
steps before in a promise train in a
normal promise chain there is no way to
do it we can only cut the promise chain
and wrap the things in two functions so
the
we pass a single parameter into the
function right so we can access the
previous step which we always can access
and we can always reuse the parameter
from the function from the function
signature right but this is a dirty hack
right basically promises are pretty
limited so we're starting with a single
promise then after this promise results
we are going to execute the second step
so the result of operation 1 becomes the
input for operation 2 the output of
operation 2 becomes input for operation
3 and so on and so on
right and basically this is how we
create a promise chain which is
sequential processing right when the
operation 1 is pending it has to wait
until it's finished right
once operation 2 is finished then async
up 2 is going to be invoked basically
each of these functions is going to be a
message on the message queue right once
it's completed the event it's put onto
the message queue and at some point even
he will just grab the message and
execute it right so we have a sequence
of operations like this we can always
wrap it with a function so that we
create a reusable piece of code and we
can use this sequential stuff either
with parameters or without parameters
and just reuse it outside this is how we
can do application layers right so we
can have let's say repository design
pattern to implement the communication
with a REST API we can have a layer to
open a model window and to execute step
one of our own operation step two of an
operation step three we can design all
these things using promises and
encapsulate them with functions if you
want to do parallel processing we are
basically studying all these promises
right we know that the promise is
started synchronously right and only the
next steps are going to be executed
later right so basically in this code
I'm starting one promise second the
third and the fourth promise and the
fact that I'm having few promises in my
hands it already means that they are
running in parallel right so at some
point I would like to aggregate them
somehow
right because sometimes I would like to
have let's say two or three resources
before I can start my application the
most known promised aggregate is
basically promised all right so we are
waiting for all promises to resolve and
once all promises are resolved I can
execute the callback and I'm having all
the values from all the promises in the
same position that I executed this
promise all right the same way I can
wrap it with a function I can make it
reusable within another let's say a
higher layer of my app right but promise
all is something that everybody like I
guess knows but there are other
aggregate functions so promise all is
waiting for the condition all the
aggregates have their own conditions
right the condition of promise all is
that all promises have to resolve the
condition of race which is also an
element of the ACMA script sixth
standard is that the at least one has to
settle right and settle is either
fulfill or reject so if the fp3 fulfills
then the whole thing fulfills with the
value of p3 if in another scenario p2
fails then the whole thing fail right if
we think about it
it's pretty tricky to find a real life
situation of a promise race in a real
life not in a computer system right in a
real life but I'll be very happy to
discuss these things during a break with
you okay we've got another aggregate
which is not a part of the standard it's
part of the Bluebird library so it says
that at least one has to resolve so when
any of these resolve then the whole
thing the whole aggregate with will
resolve with this value right and when
is this thing going to reject sorry
yes if all if all fail then the
condition that at least one will resolve
is not possible anymore like so this is
pretty illogical and finally we have
promised some which is a generalization
over any so promised some is at least
and at least two promises have to
resolve right so if any of these two
resolve then the whole thing resolve
with their respective values if three
promises in this case because we need to
have at least two and we have four
promises in total so in this case if
three promises resolve then the
condition that at least to resolve is
not possible anymore right so these are
the aggregates that we have we can do
parallel processing using them okay so
these were promises and now we proceed
to some more advanced stuff there is
yield road sign right which basically
means that if there is any vehicle going
on the other side of the road right we
have to let's say stop and let him pass
right so in other words we are giving
the control to the other party to the
other side right and in es6 the
JavaScript has released generators it's
a completely different is a completely
new type of function which has different
execution model it does not conform to
the run to completion
remember run to completion says that if
a function is started there is no way or
if a block of code is started there is
no way to interrupt it right either it
can finish or it can be interrupted by
an error right and a yield keyword will
basically omit one item right and give
the execution control back to the parent
scope right and the generator is not
finished yet
it's basically suspended right so this
is the yield keyword so let's compare
we've got a function that returns a list
and we've got a generator that is going
to yield an item-by-item lazily both are
a synchronous and the big difference is
that something if you ever do no js'
processing like server-side JavaScript
processing this can be pretty useful our
out of the box because if we create an
array this means that we have to
allocate
entire array right entire thing in our
memory if this is just three elements
it's not a problem but if this is let's
say five hundred thousand elements or
three million elements right this is
going to consume pretty a lot of RAM so
basically in order to make it lazily we
should emit item by item or just chunk
by chunk so that a lot less memory is
allocated at one time right so
generators have been added to JavaScript
in es6 you can note this asterisk sign
that follows the function keyword this
is how we define that a function is a
generator and then we have the yield
keyword available inside another thing
that was added to JavaScript is this for
off loop not for in which iterates over
keys in an object but for off which
basically is a common abstraction to
iterate right we've had iterators in
Java since the beginning right and now
this is the time like to 2015 when
finally iterators came into javascript
so javascript is is is becoming a mature
language at this point right so a an
array is something that is iterable we
can just iterate it over it the
generator is invoking a generator is
returning an iterator right so we can
also iterate on it we can iterate over
map sets and we can also make custom
objects and iterable basically is just a
common abstraction right so let's take a
look at this code snippet right here
we've got this generator here we are
so basically when JavaScript goes
through this it just remembers that
there is a generate generator it doesn't
execute this at this point we are
calling this generator which we are
storing in this ater right it's not
started yet
right and we will see what is going on
we just want to see how that's run to
completion that we know from the
asynchronous programming how does this
apply to generators so what we're doing
here is we are starting with the console
log out site right so we've got this one
outside then we're calling iterator for
the next item so this is the moment
that generator wakes up right I'm asked
to return an item so basically I am
executing all my code doing whatever is
there there might be a of statements for
statements whatever I can do there right
until I finally and I do this
console.log inside which is here and I
yield an element this yield a is
basically the result of this expression
Here I am ignoring it right so at this
point that I'm yielding the generator
suspends goes to sleep right and it's
just waiting so basically this is a
memory frame that is awaiting to be
resumed at some later point right I'm
doing then console.log to outside then
asking for the next thing and the the
resume is starting here at this at this
Colin right so I'm trying to assign it
to a value right because I can using the
next if I called and next with a
parameter I could inject a value into
the generator right this will be very
important in just a while right so
basically here I'm not assigning the
value like there is two-way
communication right so I'm not assigning
this anywhere I'm calling console.log to
outside then I'm yielding the value
which is being returned by this
expression it's not used and finally I'm
going to the console log 3 as we can see
this is purely synchronous right there
is no event loop at this point used and
we can also see that this generator is
not finished yet
right it's not finished because there
was no return keyword at this point and
the curly brace which is implicit return
was not reached right so this is
generators generators are very important
when we try to combine them with
promises and this is a really cool and
interesting combination because a
promise is something that is awaiting
for this operation to finish right and
on the other hand a generator is
something that we can suspend and resume
and when we combine two things we get
something that is called co-routine
right and this is let's say I would say
a breakthrough in thinking of
asynchronous programming in JavaScript
so basically a core routine
is going to be a generator right so it
will have the yield keyword it will
start immediately
right and when I yield I yield a promise
right when I yield a promise I will
suspend the generator and I will be
waiting for this promise to resolve
right when this promise resolved the
general the generator will be asked for
the next value so it will arise again
right so it will pause on a promise when
this promise resolves or rejects the
generator will be resumed when saddle so
basically either it will carry on or if
the promise has failed then the
generator will just throw an error which
we can either trigger up or try catch it
depends on us and basically the resolve
of the promise calls next right so there
is let's say some kind of infinite loop
then then we'll call next which we'll
call then which we'll call next which
we'll call then and this is how a
co-routine is it's just going on right
so what a KO routine is trying to
achieve is just a natural evolution of a
promise chain it's trying to write a
synchronous code in a synchronous manner
so basically we will not be jumping
between functions right going through
this but we will have just lines of code
that we will execute and we will see
that on this slide so we are going back
to a sequential processing so note that
this generator is this Co routine it's
just a generator so it has this function
asterisk thing at the top so what i'm
doing here is i'm doing VAR a v1 assign
yield async up one and now here comes
the magic because let's say that this
yield keyword is a bad character as in a
movie a bad character in a movie is
taking his victim right and is like
pulling out his heart to kill him right
now fatality thing right so what yield
keyword is doing is that it's grabbing a
promise and pulling out the value of the
promise right so we don't have to change
this anymore right a promise results
with a value which used to be available
only the promise chain right and here we
can just take it off so if I have shot
httprequest this v1 is going to be the
JSON right and no callbacks which is
pretty cool right
so I'm starting this operation and this
yield is the moment that the generator
will suspend until this guy resolves
right so basically I'm doing the if I
have any kind of assign operations then
first I have to calculate the thing on
the right hand side right so this is the
moment that I suspend when this
operation becomes resolved right when
this operation finishes then this will
return this value out a pulled out of
the promise it's going to be assigned to
v1 then we can do any kind of
synchronous things we would like to do
with v1 doesn't matter let me go to the
next step v2 which can access v1 right
here we are also suspended right when
the promise of this icing up to results
then we are resuming the generator we're
going to the next one and so on and so
on and take a look that here we don't do
any van calls right and we have access
this is just a function scope right it's
a generator it can be paused and resumed
but this is just a function scope and we
have access to all variables there is no
limitation to only the previous step
right so this is another problem that
co-routines solve for us right so we
have all these this is basically a Co
routine is a just try to imagine this is
a story right so first I have to let's
say access a resource then I have to
process it then I would like to use a
piece of this resource to do a different
thing right then I'm waiting for it and
then I can complete right so this is a
story of sequential steps right but at
different steps this is important this
is just a story of different steps that
I can basically encapsulate and reuse
and note that this magic two lines here
is that let async sequential equals
async of sequential right from a
syntactic point of view this is just a
generator so there is no way that a
generator could ask the promised like do
this then
then next it's not built into the
language right so we have to simulate
this environment and basically this
environment is simulated within this
async function which we have to provide
to the browser right we have to load a
rival library that implements it and
this library will just do this next then
next then which will make yield suspend
on the promise and which will call next
on this generator once the promise is
resolved so basically this async is a
closure is something that will return
closures right it will just wrap the
this thing right and async sequential so
we've got sequential processing blah
blah blah we are encapsulating it with a
function and echo routine is always
returning a promise right so basically
it doesn't matter it's finally
JavaScript is being more standardized
right so from the outside the consumer
needs to know that this is a van right
available right and it doesn't matter
what is the internal implementation so
javascript is getting more and more
advanced in this context at least so
this is sequential processing and we've
got parallel processing on the other
hand so the the first lines look exactly
the same so we are starting the first
operation the second the third the
fourth one they're running in parallel
and finally in turn instead of doing
promise that all we can yield a promise
right and it works exactly the same way
the yield keyword is taking a promise
pulling the value out and the value is
the result of this expression
so basically yield p1 will return let's
say a JSON this will return another JSON
this will return an outer adjacent and
another right so I can do any kind of
operations I would like to do here with
promise all I would have to wrap it with
a function return and blah blah blah
does all this boilerplate right and here
I can just use it with an expression
it's important to note that here if I'm
yielding a promise I will get the value
right if I don't do the yield I'm having
a promise that I will have to yield
later right and again I'm wrapping this
with a function so that I have a
reusable piece of code if you are
wondering how
Ising looks like this is just a a couple
of lines that do the right thing right
but it doesn't matter what the
implementation is basically we can use
either this or a bluebird curl routine
or there is another library called Co Co
right so there are multiple vendors that
implement this pattern and it doesn't
really matter what this async function
is doing so you might be thinking like
why should I care about implementing
this thing this looks so useful that it
should be built into the platform right
and somebody has thought about that and
we have a finished proposal that is
going to be released this year in ACMA
script 8 and that is called async
functions so basically this is exactly
the same pattern I say called async
await that is just a new name for a Co
routine so basically instead of having
this asterisk we are giving this async
keyword before the function keyword and
we're replacing the yield with a weight
and basically it's exactly the same
weight so what a weight is going to do
is to take a promise pull out the value
out of it and it's just a KO routine is
just another name right so if you hear
async await then this is just a
replacement for a promise chain it's
natural evolution of a promise chain
right and basically it's just combining
promises and generators and the parallel
processing is looking exactly the same
just the two key words are we are
replacing the old ones and we can also
use a weight to pull the value out to do
any kind of expression we want and the
return of a core routine is a promise
the return value of SN Kuwait of a sinc
function is a promise and the return
value of a promise chain is also a
promise right this is basically the same
thing but here with co-routines and I
think await we don't have this
limitation right what is cool and what
we can see here already that we can add
a difference at a whatever step we can
access all the variables that we have
al-qaeda already we have assigned right
and if you wanted to do this using a
promise chain right if I wanted to do
exactly the same so that in the last
step I would access all this
stats before right I can do I sync up
one then I succumb to and then I sync up
three and then I know basically way to
do it right and so once we have
async/await available either through
types ripped or babel there is basically
not much reason to go with to continue
with promise change right but nothing is
perfect
and also co-routines and a single way to
have the real limitations so we cannot
nest functions in order to yield or to
await let's say we have a book that we
all have different a list of URLs to
each of the chapters right we want to
fetch these chapters and to display them
sequentially right so that the first
chapter is the first the second then the
third then the fourth so that we want to
have this order under control so what we
would like to do is to render these
chapters with the list of URLs we are
mapping a string into a promise right
and for each promise which is here P we
would like to await it so suspend at
this point right pull the value out with
a weight from this JSON access this HTML
string and just add it to a page right
so note that here we've got a function
this is the async function right and
here we've got an arrow function which
is a nested function from which we want
to await this makes sense because if I
have lists of promises and I would await
for each is executed synchronously this
is also important if I wanted to away
the first promise right then I need to
wait until the first chapter is ready
then when I have it I display it I go to
the second promise right then I await
and so on and so on
so this makes perfect sense the problem
is that it throws a syntax error right
it's not possible and actually it makes
a lot sense that it throws a syntax
error because if we have this rendered
chapter function then it's put on the
call stack right when I go into the
forage there is another function that is
going to be put on the call stack right
this render chapter
is a essing function this top function
this arrow function is not an async
function right if I'm trying to yield or
away from this one
should it suspend the the nested one the
the outer one like right this should not
be possible right because I can access
only the function that is on the top of
the stack right so there is no
possibility to suspend a function that
has been like previously right so it
would it would make a complete
inconsistency right so this is the
reason that we can only await within the
functions that we are in like I could do
I could do for each just not with a
weight or yield so what I would try to
do is to turn this arrow function into
an async arrow function right so
basically it's the same just as we have
traditional functions turned into async
functions we have the same arrow
functions turn into async arrow
functions right this is just as long as
we're not using this keyword this is
just a different syntax right so if I
want to turn this into a a sync function
so I can await it what is going to
happen now at this point I've got a list
of promises and I am executing for each
on this promises so that at the first
promise I am registering what to do on
the second I am registering what to do
on the third I am registering what to do
right because I have just registered and
now synchronously and they are running
in parallel right so now the order in
which they will come back this
determines the order that they will be
displayed on the page right so this is
not sequential this is parallel right so
if we wanted to do it sequentially we
would have to fall back to promises and
there is another pattern having a list
of promises to force sequential
execution right so to understand
Cortines and azekah weight we need to
understand promises as well this this
animation demonstrates how we can turn
callback hell into a promise chain and
finally an async await I'm going to
share the slides but basically you can
see that this is just a natural
evolution one of
of another right so an interesting use
case of an async await I think I'll need
to hurry up a little bit so is you
imagine we have I let's say banking
interface everybody has a banking
account with internet access we need we
want to create a new transfer right so
that we wait until a new pop-up opens
right and we now we are used as expected
to give the input here after we do this
we click on the go on right and now it
waits for any kind of server
communication now we get the second step
right is this what you want to transfer
right so we are expected to submit we
submit the thing right we are waiting
for the server communication then we get
the final step the third step which is
basically success you have finished you
have successfully finished sending the
transfer right and we are waiting for
this operation to close and now we have
also made that this list of transfer
should reload so that we have more
things available and this is a this
chain of of steps is a perfect use case
for an async await or for a co-routine
and let's look at this within the next
slides so we've got this is also of
course a simplification we've got a
model that will be able to begin a
transfer right so we are just doing HTTP
POST to start and let's say a transfer
that will return a promise this function
is going to return a promise that with
will resolve with a transfer ID this is
a typescript code just to better
visualize what a function is going to
return we can set the transfer details
so for a given transfer we want to set
up the detail so we're posting the
transfer with the transfer ID again it's
a simplification and you want to send
the details with the payload and finally
the last step is to confirm right so
what the server already has this pending
transfer just to submit it that the user
wants this transfer to be actually sent
right so this is just the model layer
we're going to use and here comes the
icing function to actually implement
this case so we are starting with a
component because we will have to
interact with the UI so where's
with doing the let's transfer ID equals
a weight model begin transfer right so
this is when we are waiting for this
page to open right when this page opens
then we are waiting for the user to
complete the step one again this is a
simplification but it shows she was the
intent we are waiting for the user to
input the data and we are also waiting
until the user completes the step a step
completion is is the same as user just
clicks and the validation passes right
so we are awaiting it right so basically
when we are awaiting for the user this
generator is just suspended right once
the user has has confirmed the step then
we are sending the transfer details
right at this point so we are waiting
for the server interaction once the step
two has been displayed we are again
waiting for the user to complete step
two which is basically the submit button
right we are awaiting here so the
generator is suspended then we are
waiting for the server to confirm the
transfer right again we are waiting and
finally there is the step three which is
displayed and again we are waiting for
the user to complete step three write
the transfer has been scheduled and
finally let's say we would like to know
what the transfer was so that we can use
it outside if needed right in promised
change we should not break the chain so
that the last element of the promised
change should return a value and the
same way here so that this scheduled
transfer async/await
async function is returning a promise
with this value as well right if we
wanted to do it with a promise chain
this would be pretty difficult because
we wanted to access this transfer ID
right within pretty all the steps when
we wanted to post something to the
server right so we had to do in order to
achieve that we would have to do a
nested promise which is a complete
anti-pattern right so this is something
we should never do but this is the only
way to achieve it with a promise chain
the next thing you can see that this is
then-then-then we need to care we need
to care not to pass component complete
step 2 but we have to wrap it with an
arrow function so that we don't cut out
this the context of a JavaScript
function so this is really difficult and
it's a lot let's say less maintainable
then we would like to write and the last
step that I'll need to hurry up I'll try
to just do it in 3 minutes is a
different approach which is basically
reactive streams just as you have rx
Java which is which we also have a lot
of talks about during this conference
and so we have the same pretty the same
implementation in JavaScript so if we
have if we want to map an element right
we can have an array right but it means
that we have entire array right now in
the memory whether if we have a stream
we do exactly the same processing right
we are using the same high order
function but in this in in the first
case we have everything available and in
streams not necessarily we don't have it
right now right in array everything is
in memory so we can get a whole
collection and turn it into another
collection whether in streams well this
can be not necessarily here it can be
sync or icing actually it doesn't matter
right how how are these elements are
going to be triggered and we don't know
when they arrive right and also we're
not thinking of asking somebody for the
data right this is an inversion of
control we are using a different let's
say mind step right we are pushing the
elements into the stream like and the
other party is just subscribing to it
and reacting to each item being
available the most important thing is
that promise is a single item thing
right and rx
a stream is basically a multiple item
like so in order to finish this talk a
little prematurely when to use what just
to do a quick summarize if I have
something that is just a single time use
a promise if I have a sequence of
different items
use a core routine or as in Kuwait right
just as we have seen with this scenario
with with bank transfer and finally if I
have repetitive things right
Rx is is the way to go and angular 2 is
using rxjs there is a binding also for
Redux and rxjs is taking JavaScript
landscape by by storm and well rx is a
common abstraction for everything that
we could that we could process right
everything that is iterable we could do
we could use rx the cases when this
would make sense in a frontal
application there are actually two types
of applications either it's a real-time
application so changes will appear very
frequently an example of such
application would be currency exchange
or a stock exchange or displaying let's
say where are my trucks if I have a
transport company on the map right or I
want to see the trains in the subway
right so the changes are very frequent
and I need to display them immediately
right so this is one type of application
that rx would suit really great and
another type of application is an
application where there are many there
is no real-time communication but the UI
is as we call it rich so that user can
do many things let's say this could be
just a chart that have like 20
checkboxes and many select items right
select select dropdowns that we can just
choose and do any kind of mixture right
if I wanted to do it in an imperative
way this would be really difficult if
I'm using each item change each click a
checkbox being checked or unchecked
right I can compose the streams right
and then just to subscribe at the very
end and just shoot right Ajax requests
to fetch the right data right but if I
have very big enterprise crude
applications create read update delete
Rx is going to be complete overkill and
the interface
so thank you very much this is not all
I've got for you but I'm out of time
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>