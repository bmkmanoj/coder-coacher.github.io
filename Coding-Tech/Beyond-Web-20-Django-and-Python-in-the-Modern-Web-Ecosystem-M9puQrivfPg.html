<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Beyond Web 2.0: Django and Python in the Modern Web Ecosystem | Coder Coacher - Coaching Coders</title><meta content="Beyond Web 2.0: Django and Python in the Modern Web Ecosystem - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Beyond Web 2.0: Django and Python in the Modern Web Ecosystem</b></h2><h5 class="post__date">2018-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/M9puQrivfPg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you very much Chris so as Chris
said my name's Russell Keith McGee if
you've heard my name previously it's
probably because of my work on the
Django project I'm a 12 year veteran of
the Django core team I was president of
the Django Software Foundation from 2011
to 2015 so as you can imagine I have a
slightly vested interest in Python and
Django and their continued success as
platform but while the web is still
important both generally and to myself
personally for the last couple of years
I've been looking at a different part at
the part of an ecosystem over the 12
years that I've been involved with
Django the computing world has changed
quite significantly most notably we've
seen the emergence of a whole new class
of computing devices devices where you
can't really run Python the beware
project is the umbrella under which I've
been doing all this work beware is a
collection of tools and libraries for
expanding the reach of Python for
developing software both developer tools
and libraries to enable Python
development on new platforms like mobile
devices and iPads what I'm going to talk
about today is an overview of where
Django has come from as a platform where
we are and where we're going
does Django and Python have any future
at all in this sort of new world of
mobile technology now in this talk I'm
going to be talking some very high-level
concepts and looking at a couple of ways
those high-level concepts can be
addressed using Django and Python in
some cases I'm going to be talking about
tools and techniques that I'm actually
using in production other cases there's
just experimental and speculative but
although that examples that I'm going to
be presenting today are driven by my
experience in my background in Django
community in the Python community the
solutions that I'm going to present our
solutions from the Python space there's
nothing inherently Python specific about
the problems and the ideas or the
approaches that I'm going to be
discussing it's only the specific
solutions that our Python specific sorry
start things off cast your mind back to
the halcyon days of 2005 when Django was
first released what did the web look
like back then well most web sites were
fairly simple affairs you put a URL into
the address bar of your browser you hit
load you've got a page back you clicked
on a link there you've got a page back
the technical requirements to deliver
that were by today's standards pretty
simple and those requirements are
reflected in the major design decisions
of
Django and other web frameworks of that
era you have a models dot pie file
defining a data model you have a views
dot pie file defining a function for
each page on your site that you want to
return content you have a forms dot pie
for defining input handling and data
validation you have a URLs dot pie for
defining your URL structure and how the
URLs that come in are going to be routed
to the various views in your site you
have templates for each view to control
how each page looks the most exotic
thing you're likely to have in your snow
tech stack in 2005 is something like
memcache and even that's optional is
really just there as a performance kick
now that's not to say that's all the web
was in 2005 websites like Google Maps
existed and they showed you could do all
sorts of really sophisticated things
with the basic tools that a browser
provided at that time but Google Maps
was the exception not the rule
if you were building a website for a
client most clients weren't going to
expect you to deliver Google Maps they
were going to expect flat pages and
forms so let's wind the clock forward to
the present day over the last 13 years
things have changed quite a bit we've
now got other more exotic data stores
user expectations of the web interfaces
changed users now want a rich client
experience that means we now have some
non-trivial amount of logic happening on
the client side some of which will
potentially be duplicating logic that
exists on the server there is pressure
to expose an API that third parties can
then use for integration which
introduces even more potential for
duplication of logic and this is all
assuming that you are still just using
the classic web to deliver your could
deliver your content increasingly users
are demanding native apps to consume
their online content which puts even
more pressure on websites to have good
api's because that's how the native app
is going to interact with the service
and potentially even more duplication of
validation logic users also want live
updates so we need to introduce
real-time channels running in parallel
to the main web server so our beautiful
django architecture from 2005 is now
starting to burst at the seams with all
sorts of potential for duplication and
complexity this changing set of
requirements is one of the reasons why
we've seen such a growth in JavaScript
and Java JavaScript frameworks over the
last 10 years
initially javascript was just used for
simple Dom manipulation then things
jQuery came around to make that Dom
manipulation easier nowadays we've got
react angular and ember dozens of others
and each of these frameworks is a
response to the increased complexity
that users are demanding on the
client-side user interface but unless
you're going to throw away the
server-side code and replace it with
nodejs adding a client-side JavaScript
framework to the mix doesn't fix any of
the underlying architectural problems
that our website has if anything it
makes them worse because now you've got
complex client-side code base and a
complex core server-side code base that
both need to be maintained it might make
the client-side code base easier to
manage but it's still a duplicated code
base and at least some aspects and
that's the driving force behind the
approach that's partially known known in
some circles as isomorphic JavaScript
development isomorphic javascript is the
idea that to avoid the duplication of
logic client-side you use the same same
code on both the client and the server
and because the client-side only has one
implementation option javascript that
means the push has been to take the
client logic and migrate it back to the
server now of course this is simple if
you're using javac on the server but it
doesn't help you if your server is
Django and Python now there are
integration libraries that will provide
various levels to support you react to
ember angular they all have their Django
plugins or platform support libraries
it'll help you but these libraries tend
to do one of two things they either
duplicate the rendering logic of reactor
ember or whatever on the server side so
you end up with a server-side
implementation of parts of reactant J
and Ember in a second language or they
run J react to ember or angular in a
separate local web service the Python
implementation then goes off and calls
this local JavaScript web service gets a
response and then passes that response
on to the client which yeah works but
it's not exactly elegant or efficient if
you want to extend your isomorphism to
include validation rules or model logic
then it gets even harder I don't know
that I've seen any particularly good
answers there but let's back this up a
bit why is isomorphic JavaScript
development being proposed at all is it
about JavaScript or is it about plus
morphism are these approaches being
proposed because of some inherent
superiority of JavaScript as a language
well some people certainly think so and
they're totally entitled that opinion I
personally would challenge the
to my mind the only significant
advantage of the JavaScript offers is
that it is available natively in the
browser and if that's not the very
definition if all you have is if all you
have is a hammer everything looks like a
nail then I don't know what is being
native in the browser is a huge
advantage for web apps but remember
we're not just looking at the web
anymore we're also looking at mobile as
well and you can't use JavaScript on
mobile to write mobile apps natively at
least not without additional tooling so
we're already having a discussion about
what language are we going to use
there's also expertise and knowledge
outside the JavaScript community that
can't be easily migrated the Python
community for example has huge stores of
scientific and numerical analysis
libraries and that's before you get to
any personal taste issues about the
strengths or floors of JavaScript as a
language don't get me wrong
there are very talented people in the
JavaScript world and there are great
resources in the JavaScript community
generally but the computing world has
never survived and sustained a language
monoculture any grand future of future
development that is based on a language
monoculture is to my mind doomed to
failure but if we're going to make our
lives easier as developers we need to
have our own internal consistency across
platforms
so can we do isomorphic development but
without the JavaScript pub can we take a
Python everywhere approach or any other
language for that matter and find some
way to bridge the one place where your
language of choice isn't available in
the browser well ok let's analyze our
actual requirements here ignoring the
implementation concerns for a moment
what does our modern web development
environment look like well once we've
got that sorted maybe we can look at
what we need to do to get there and
evaluate where the JavaScript really is
the best approach we have a server on
that server is the canonical version of
the data that we're storing and we need
to expose a way to manipulate that data
and we need to be able to deliver that
data to the client the client has to be
able to request a page of content or a
block of content in some way receive an
initially rendered version of that
content if it can't hold the rendering
instructions note natively and then
respond to user inputs potentially
modifying service state now that means
we need to have something in between the
browser and the server coordinating that
interaction those modifications that
we've all validated server-side to but
the same validation needs to have it on
the client side and then
we have mobile platforms these platforms
will also be requesting content but they
already have the rendering instructions
in the form of a native app so but at
the Mobile Apple buy mobile device we'll
want to modify the server as well so it
needs a way in now for those of you who
are old enough you will have seen this
dance a couple of times before for me
this is at least the second time last
time around it was the early 90s and we
were going to achieve isomorphism using
Java which was a response to the bad old
days when you had a VT 150 100 mm and
all or x windows terminals connected to
a mainframe as an interesting historical
footnote the very first django project
that I worked on commercially was
effectively a replacement for a Java
based rich client customer was willing
to give up the traditional user
interface that they were expecting in
favor of the development speed that a
django web app was able to give them the
good news is because we've been here
before we can learn from the design
patterns that worked really well the
last time as well and what pattern
worked really well well we've got a data
model that persists data it used to be
some custom in-memory thing now it's a
relational database we've got a
presentation layer where the user can
view the data it used to be a graphical
tool kit now the browser is our
graphical toolkit or on the mobile
device it's just a different graphical
toolkit and we've got our layer in
between controlling the interaction of
the two the business logic coordinating
between the model and the view that's
right after years of thinking of the web
in terms of documents and pages we're
right back where we were 30 years ago
with model view controller so how does
this change our view of Django as a web
project well the thing we need to do is
make sure we have a clean separation
between each layer the easiest way to
ensure this is to adopt API first
development and use that API as the
controller previously we would have used
views with forms to manipulate server
State now we can be effectively
jettisoning the entire forms framework
and doing everything through an API you
want to submit to a submit data in a
form sure by all means go ahead and use
an input type equals text in your HTML
to do that but it should be submitted
through an API endpoint not by posting a
multi-part form HTML content to a
traditional if request method equals
post view now this has a couple of
consequences firstly it means our
project becomes a lot easier to test our
testing surface is now the API not
multiple possible views each of which we
has its own independent in the end of
into the into the user model secondly it
means you elevate integration to a
first-class use case if you want to make
sure you have a public API that is rich
and has feature PAC apparantly feature
parity with everything that your web
user interface can do force the web user
interface to do everything through the
API lastly it means the user interface
layer becomes simpler views are now
literally just the process of describing
what URLs your site will have and how to
render content onto those pages but it's
not quite just as simple as dropping a
REST API framework into your project
your server connection can be unreliable
if you're going to have cut if you're
going to contact the server to do
validation then your user experience is
going to be awful and if your you have
to use your at all if your offline which
you know happens all the time if you're
in Australia for example so how do you
deal with this problem well at the very
least you're going to need to replicate
part of the controller on the client
side and this probably means devote
validation logic and possibly a version
of the models as well this then raises
one fundamental problem we can't avoid
we need to have the ability to replicate
some or all the controller logic on the
client side and if we're planning to use
Python on the server side then we're
going to need to have a way to get
Python running on the client so what
options do we have
well we actually have a couple and we
have a couple more on the horizon
brighten and sculpt our two full
implementations of Python written in
JavaScript pipe yjs is also an
implementation of Python in the browser
but it gets there through a slightly
different route it uses inscription
which is a Claim compiler back-end that
outputs instead of outputting system
native binaries it outputs a restricted
subset of JavaScript called ASM Jas pipe
ajs is the C source code of pi PI the
JIT optimized Python implementation
compiled to ASM Jas rifle and sculpt
both shake out to about 500 kilobytes of
JavaScript code once they've been
minified pipe ijs is about 15 megabytes
but they all let you use Python in the
browser and they access the Dom as if it
was a native set of api's so you can
have your snippet of HTML on a page with
an input and a button and then a script
tag describing how to respond but
instead of the script being in
JavaScript is written in Python and you
can read the Dom manipulate Dom elements
install handlers
would with any other platform and just
to be clear yet this isn't like
CoffeeScript this isn't a Python like
language that is interpreted into
JavaScript at runtime it is Python that
is running does it work yeah
you go to the bright firmance cult pages
right now you can see examples of sites
written entirely in Python in the case
of scope they even give you an
interactive prompt to play around with
now there are two significant problems
with this approach the first to notice
is if you jump on to Brian's website
right now before any of the Python on
the page will execute at all the entire
500 kilobyte payload of the runtime
needs to download first on mobile
that's definitely noticeable in a room
like this with a bunch of gigs all
hitting the server at the same time you
can guess how well that goes it's even
worse for pipe ajs where it's a 20 or 15
20 megabyte download there's also some
inefficiency here what you end up with
is a full Python interpreter this
includes a full Python parser and
compiler which is something you're going
to have to do if you're shipping Python
code to the web browser now the upside
for pipe ijs is that because it's a JIT
compiler it actually ends up running
faster in the browser than C Python does
on the same machine asterisk for
suitably selected benchmarks but the
fact that I can say that even
tongue-in-cheek is pretty remarkable now
again we need to go back to our
requirements here and analyze what we
actually need do we actually need a full
- interpreter in the browser do we
actually need to be at a park imply land
run Python code no we just need to be
able to run so why not just ship the
runnable version of the code when you
execute Python my script by the Python
compiler does a couple of things firstly
it parses the code into an abstract
syntax tree or an AST then that passed
ast is compiled into an intermediate
representation it's called the bytecode
representation
Python bytecode is a little bit like
assembler it's a limited number of basic
instructions about a hundred all up and
at runtime the Python interpreter
doesn't use the source code at all it
runs the bytecode because it's faster to
pars and a small target to implement so
if all we need to do is run by code can
we take that capability to the browser
well yes and that's what behavior is
batavia is a JavaScript implementation
of the C Python virtual machine and
because it doesn't need to carry around
the full weight of a compiler and a
parser it weighs in at a little
over ten kilobyte ones has been
compressed and zipped
that might not sound like much but then
it also doesn't need to do much either
it only needs to implement the hundred
basic Python objects a good chunk of
which are basic basic mathematical
operations or basic attribute access
descriptions and once you've got those
you can run any Python code you want how
does it work well okay see this working
we need to scrape back the surface of
our Python works at runtime let's say
you've got some code you want to run in
the browser say a validation layer for
an API endpoint on the server side you
have a native C Python interpreter you
can define import any Python Python
methods you want to use and from that
method you can get what's called the
code object that code object contains
the compiled definition of the method
itself the arguments it expects the
three variables it has and so on and it
also contains the bytecode for that
method so if you take that payload
encoded in base64 you get a string you
can send to the browser and then on the
client side in the browser as long as
you've got that 10 kilobyte batavia
script to start with you can decode the
base64 back into a byte string run it
through the bytecode interpreter and
you've got running Python in the browser
and as weird bryson and sculpt you can
even access a manipulate the Dom so you
can manipulate the visual appearance of
the page as much as you want okay so
what's the downside
well it's not fast it's a couple of
orders of magnitude slower than C
pattern on the same machine but does
that matter now remember what do we need
to get out of Python here we're not
mining bitcoins
we just need Python to implement
validation logic and some UI control
logic it certainly can't be slow you
want a responsive user interface but it
doesn't need to be lightning-fast either
just fast enough and more importantly
the part that is slow and complex is on
the client side not the server side so
as long as it's fast enough for one user
it will scale as wide as you need it's
also an area where performance is on the
cusp of being dramatically improved I
mentioned pi PI J's previously it's a it
uses a subset of JavaScript called a s
MJS a s MJ s is really just a first
salvo in a much bigger battle the next
piece of the puzzle is where's of
webassembly wasm is under the hood the
same just JavaScript that is MJ s is but
it's a pre parsed ready to use in memory
binary
representation of Jack JavaScript the
features it exposes are very much like
the old-school assembly language
programming pushes values under stacks
popping the invoking primitive
operations popping the values offers
results but began because it's assembly
we can use the last 70 years of research
into building optimized compilers to
generate some very interesting results
for example Dan Callahan from Mozilla
they recently did demo where he was
taking live video from his webcam and
doing edge detection filtering on the
image at 60 frames a second in his brows
unity has the games engine has been
compiled to wesam so you can run full
full full OpenGL games in the browser
and ok short there is a performance here
you know you're twitching gamers aren't
gonna be particularly satisfied with its
but you're running an OpenGL
first-person shooter in the browser what
more do you want and rust recently
announced the addition of a compiler
flag that will take any rust code that
you have and output a wowza module as
output so we're getting to the point
where almost any language can be
compiled and executed in the browser and
produce that output in a in a format
that is performance comparable with a c
implementation compiled to run natively
yeah there are some limitations where
them is only available in the most
recent browsers so it isn't available
everywhere it doesn't have garbage
collection which makes it difficult to
use on dynamic languages like like
Python and while OpenGL bindings exist
Dom bindings don't so you can't
manipulate the view of your of your web
page but all those features are yet
they're all active areas our development
in the ways in project at the moment
okay so we've redesigned our entire web
app to be MVC we've got a good API on
the server side with shipping parts of
that API to the rich web client to be
used for validation and display now okay
we're doing this refactoring primarily
to make or originally to make our web
interface easier develop along the way
we've actually made web development
easier as well because once you've got
this separation the rich web client
operates exactly the same way as your
mobile native app the only difference is
that you use the Dom to draw widgets on
the screen instead of a native API layer
so as long as we can write our mobile
applications in pipes and we're actually
pretty close to having a genuine single
source cross-platform architecture can
it be done well yeah and that's what
potentially what the big waste
is all about it gives you the tools to
do just that the URL here is a talk I
gave at PyCon Australia last year in
which starting from scratch I developed
the Fahrenheit to Celsius convertor
deployed it as a Django single page web
app a native iOS application a native
Android application and maca SAP a
Windows app and a gtk app all with
installers ready to go on the simulators
or relevant irrelevant devices in 17
minutes it's a single Python code based
about 40 lines of code plus a small
collection of command line tools to have
the app package ready for distribution
on those platforms let's be clear though
all this is possible right now
even without be where's help any number
of people in this room are already
building responsive websites with api's
of live streams and supporting mobile
applications and all the fruit I'm not
saying it isn't possible I'm saying
there's a better way in 2005 it was
possible to build websites but Django
and other web frameworks from that era
showed that there was a better way to do
it a way to build better web apps with
less code beware is about doing the same
thing for the apps that we do today
building a web or a web poll in 15
minutes is no longer the challenge from
for me success is when a tech boot camp
isn't just building a blog as their
1-day web activity they're building a
live chat website with a cross-platform
mobile app to go with it and that might
seem optimistic but I don't think we're
actually that far away from the being
possible details on all these projects
and more can be found at play beta org
beware is an open source project we're
actively looking for contributors all
levels of experience we have challenged
coins for anybody who does contribute
and stickers if you're into that sort of
thing as well
come see me afterwards or I'm here for
the rest of the week so a bit of chat we
also actively looking for sponsors to
help the rest of those support this work
beware at the present is entirely a
volunteer effort that obviously
constrains our rate of development
financial support means faster progress
best of all we can get great tools
without having to give up a ribbon
source to source ideals with that I'm
done thank you much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>