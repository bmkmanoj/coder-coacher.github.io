<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Should You Rewrite In Rust? | Coder Coacher - Coaching Coders</title><meta content="Should You Rewrite In Rust? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Should You Rewrite In Rust?</b></h2><h5 class="post__date">2018-02-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IkBTlgPnntM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so before we get going I just like to
know a bit more about who's here in the
room who here by a show of hands thinks
that you know the answer that I'm here
to tell you for this question should you
rewrite and rest yeah hardly anyone you
don't make any assumptions that's great
so who here thinks that I will tell you
yes rewrite your code and rest by a show
of hands surprisingly few maybe maybe a
dozen and who here thinks I'll tell you
no no no don't rewrite your code about
the same well congratulations you're
right so I am Emily Dunham
I'm from the middle of nowhere in Oregon
and I work as the DevOps engineer for
Mozilla research which means that I wear
quite a few hats at the same time I work
on a bit on rusts infrastructure quite a
bit on servos infrastructure and now on
the virtual reality teams infrastructure
that's part of research as well so while
I'm involvement and engaged with the
rest community I'm a member of the rest
community team I do a bit of rest
programming but I'm more of a compiler
groupie than a compiler hacker but
that's okay because I know a bunch of
very smart people and I have combined my
own experiences and asking them a whole
lot of hard questions about what do you
ask when someone says they want to
rewrite how can you tell when you should
rewrite something to come to the
conclusions that I'm going to share with
you in this talk so I'm going to talk
about whether you should rewrite your
code at all whether you should rewrite
in rust and how to do that if it turns
out to be the right thing for you
so should you rewrite should is a value
judgment and all value judgments are
based on certain assumptions the
assumptions that I'm going to make here
for us to even be remotely on the same
page are that I'm assuming that you're
working on some code I'm assuming that
you're working with some other people on
that project probably some of them help
you with the code some of them help you
with non code as
of that project but you're not just
going it alone and you probably have
someone who uses that code that you're
writing who isn't just yourself so the
other basic assumption that I'm going to
have to make in order to call things
good or bad is that people's time and
Happiness are ultimately what you're
optimizing for you're going to basically
try to do the things that make your code
save people's time and make the people
happy so those people is not only yours
it's also the colleagues that you're
working with both technical and
non-technical and the people who use
your product so anytime we're going to
call something good or bad it's striking
a balance between what it does for all
of these different groups so now that
I've got that out of the way let's talk
about rewriting code rewriting has a
bunch of different definitions some
people are like rewriting is when you
don't look at the old source but now I'm
just gonna say that rewriting is when
you had some code that tried to solve
the problem but you're gonna say no I'm
gonna I'm not going to use that code I'm
going to start with start new and do
something different for that portion of
the code I'll also talk about
refactoring differentiated from
rewriting as trying to modify what you
already had in order to get to where you
want to be so you can categorize
rewrites by how big they are how much of
your code base are you tossing out and
starting over on a smaller rewrite like
I'm just going to rewrite the body of
this function for some reason is highly
constrained but it gives you less
opportunity to introduce new bugs and it
can get done quite a lot faster whereas
the extremely large rewrite that some
people online will often suggest in a
debatably satirical manner just get rid
of it just rewrite the whole thing and
rest is can be enormous has a much more
greenfield start a new fewer constraints
implication to it but you also get to
reintroduce every bug that the old code
intrinsically encoded a solution for and
the larger a rewrite is pretty obviously
the more time it's going to be tape
to be taking that you could have spent
doing anything else on your project so
you can also categorize desires to
rewrite code by what someone hopes to
get out of it
so the main motivations to do to try to
start tackle a project again tackle a
problem again from scratch that I've
identified our first you want to learn
the tool that you're tackling it in
you're like I want to learn this new
language so I'm going to write fizzbuzz
in that language so I know how it works
then there's the motor of understanding
a task
there's wow managing this memory is
really hard maybe I should try writing a
similar piece of code in a language that
helps me with memory to see how it works
when it's working correctly and finally
the one that's the only really hear
about in popular conversations about
rewriting is rewriting because you want
to ship different production code to
your users than you're shipping right
now so a rewrite in order to understand
either the tool or the task is going to
be somewhat costly you're going to spend
a bunch of time researching how to do it
writing that code and debugging the code
until it works in the way that you
expected but rewriting with the motive
of deploying that rewritten code is
immensely more expensive more people
have to do research coding and debugging
and you have the communication overhead
of explaining it to everyone else who
interacts with that code you have an
obligation of backwards compatibility if
you're writing a thing that you claim
will fit in and replace something that's
kind of sort of working already and you
have whatever tooling was previously
deploying the code is probably going to
need some minor or major changes for the
rewritten code to work with it plus you
get the opportunity to introduce a lot
of new bugs and you're going to have to
fix them and again everyone involved not
just you but your colleagues both
technical and non-technical and the
users of the product are going to have
to learn about the new system that's
starting to sound like we should never
rewrite anything so why does anyone
because in addition to those major
drawbacks you can get some
huge benefits you can get improved
performance especially a few had
previously been using a language or tool
where performance is not really its
first priority or if you're using
tooling where performance is the first
priority you can get radically improved
maintainability by switching to a tool
that prioritizes the ease of reading and
writing the code in it and sometimes you
just need to increase your contributor
base it can be really hard to find
people who know and want to use some
languages or some tools so in some
circumstances switching can actually get
you those people that you needed to keep
the project alive at all so when you're
thinking oh yeah okay it looks like I
might want to rewrite this start by
thinking about how you'll communicate
about it this is true not just of
rewrites but of any major code change
and the first step to communicating what
the problem is is figuring out what it
is you have to answer as they probably
taught you in a software engineering 101
if you happen to find yourself in a
class like that at some point you've got
to ask what does the code do what is the
code supposed to be doing what will be
the consequences if I just leave it be
and if I'm going to change it how will I
know when I've changed it enough how
will I know when the problem is solved
and so once you've pinned down that
difference between what you think is
happening and what you think should be
happening you then need to track down
its source so sometimes that disparity
can come from
you misunderstanding one or the other
maybe you misread a document maybe you
misunderstood someone's explanation and
you're defining it in a way that means
there's obviously going to be a bug like
you're asking it to do something it
can't or maybe there is a problem that's
intrinsic to a system not to your
assumptions about it and it's just the
system's architecture or the problem
it's trying to solve is just not the
problem that you have anymore maybe
lower level you've got a tools problem
one of your dependencies is doing the
wrong thing you're gonna have to go
upstream and fix that in order to bring
what it does
into line with what you want maybe it's
the business logic this is where
everyone tends to assume that a bug is
coming from but there are many other
options because you can have your logic
right and a tools problem and get a bug
you can have your logic right and just
have the wrong architecture and get bad
behaviors and you can have your logic
right and you can be getting an
unintended side effect just based on
some bug or flaw in your program or the
ecosystem and that could be introducing
an unexpected behavior so once you have
pinned down exactly where the problem is
that you're trying to solve and where
that problem is coming from start
thinking about who will fixing it affect
it'll affect you because you're gonna
spend a bunch of time on this it'll
affect the other coders because they'll
have to learn what you changed it'll
affect whoever writes the docs
whoever advertises your product and
whoever uses the product so in the theme
of history repeating it's super
important to talk about what you're
planning to do in order that people
who've seen others attempt similar
things and fail for various reasons can
volunteer you that information and keep
you from making the same mistakes so ask
people about the solution that you're
trying to do research what others on
your particular project have done and
research what others on other projects
have done and how it's worked what's
worked well what's work poorly and see
whether you can get buy-in from that
project when you say hey I would like to
make this major refactor I would like to
rewrite this section of the code in that
language if people just reflexively go
oh no no don't do that
ask why or if people go oh yeah I don't
even know what you're proposing but that
sounds great
ask why and one thing that stood out
time and time again when I've talked
with people about the refactor is that
they've succeeded at compared to the
ones that they've failed at has been
that the the rewrites Andry factors that
prefer small changes are the most
successful so that can mean if you're
doing a very big change to break the big
change up into small incremental
measurable one
a small change you could define it as
the cheapest or quickest solution to get
the impact that you need it's the least
effort that you can put in and still get
what you wanted
which if what you want is a major
speed-up let's say then that could be a
whole lot of effort but still don't do
more than you have to and introducing
extra complexity just for the fun of it
or just for the fun of using some cool
tool will cause you a lot of grief on
down the line as you have to live with
that
so basically risks multiplied if you it
was described as innovation tokens in
the previous rewriting and rest talk
today where you have a certain amount of
risk you can take if you take more than
that if you take a bunch of Gamble's at
once and any one of them failing will
keep your project from succeeding then
the more Gamble's you add on the less
likely you are to succeed
so since risks compound make the
smallest change with the least risk that
you can for the best odds of success and
I would like to stand on a small soapbox
here to talk about what happens when
somebody comes into some other project
some other community that they might not
be super involved with and just says I
think you should rewrite your code I
think you should go rewrite that and
rust I think you should rewrite that and
go whatever it might be what is this
actually saying it's saying I think all
those hours you've put in I think you
should just throw them out there regard
it's saying well I think that the work
that you've been doing would be super
easy to replace it can't be that hard
right it why why do you even spend so
much time on it it's saying you don't
understand the engineering decisions
that you're making because I know them
so much better than you and
fundamentally to somebody knowledgeable
you're seeing something about yourself
you're saying I have no idea what you're
trying to solve
I just I'm wandering in and saying this
one tool will fix everything so please
don't do that rest kind of has a problem
with this kind of people I'm not sure I
hope none of you are in the none of them
are in the room
or watching if you have done that in the
past and you're hearing this please
think about what it's saying both about
you and the language and consider not
doing it in the future so what should
you do instead if you're like wow these
people need a different tool take it
look at things from their perspective
start by figuring out where their
problems are and how you're going to
bring them more good stuff than the
inconvenience that you're you'd be
introducing by suggesting a change look
at where their actual pain points are
respect the amount of time that people
have put into their project and the
amount of understanding the complicated
problem that their code is trying to
solve that is encoded by every bug fix
that makes their code look a bit messy
and ask whether they would be interested
in a solution if you offered it to them
ask what they've done before whether
it's succeeded and what you can learn
from that and basically try not to write
code but a product project just doesn't
want because that's a huge waste of time
unless you're writing it for your own
enjoyment so let's talk in a bit more
detail about rewriting for the sake of
understanding the code because I feel
like in my upbringing as an engineer it
wasn't explained to me nearly as well as
I would have liked that you don't always
have to push the code you've rewritten
to get benefits from having rewritten it
so a couple of cases that are the I'm
going to show you a couple of case
studies but from them I'd like you to
see what these people are doing right
they're picking either a familiar task
or a familiar tool they're not
introducing a bunch of new risks like
both an unfamiliar task and an
unfamiliar tool at once and it sets them
up for success to change a small thing
at a time they've documented what
they've learned which is what makes them
so good for citing in a talk and makes
it easier for them to look back on their
own experiences and continue leveraging
the knowledge that they gained and they
really take the lessons that they learn
back into their other projects so one
instance of rewriting in order to
understand the codebase is Carol nickels
is a pretty expert rust programmer and
she was encountered this compression
algorithm that she thought wow that's
kind of slow
I wonder if thrust could make it faster
so she assessed it took it away on her
own just wrote a rest implementation by
studying the C code and then has offered
that as something that people can choose
to use doesn't try to force anyone else
to use it but basically picked the the
smallest component which in her case was
the the library for compression and then
just rewrote that learning from the
knowledge that was encoded in the old
version another instance of rewriting to
understand code is a project the BART
gave a talk about at the Portland rest
meet up which was advent of code and he
had some familiar problems problems that
were algorithmically pretty
straightforward to him but one did the
practices rest and so he resolved the
problems in rust and published them and
that's fine he's not going to anyone and
telling them hey you should you should
ship these rust solutions he's just
rewriting to understand and can take
that knowledge about how to handle
memory and how to handle safety that he
learned from rust back to his other
project so with that out of the way a
lot of the time when you talk about a
rewrite you are talking about the
problem where production code isn't
where you want it and you need new
production code for some reason so the
first thing to ask is always can we
solve the problem in the current
language the perks of your current
language you already know it you don't
need to drag in a lot of new
dependencies and new tooling and you can
potentially go off rewrite for
understanding in a language whose
strengths match up with your present
languages weaknesses and bring that
understanding back to write the
algorithm in the way that you've learned
is good without dragging in a bunch of
new tools to your build process and a
huge perk is that the existing code
describes a lot of bugs that
been fixed over the years it pretty much
encodes your project knowledge about the
problem so the better you can leverage
that the fewer reintroductions of bugs
that you'll have so there are times when
you think no we've just gotta toss it
and rewrite it when you could actually
refactor it in your current language and
be fine here's a few common excuses like
oh but it's slow my language is slow and
I want my code to go fast can you find
and refactor the hot code so that it
doesn't trip on those problematic edge
cases of your current language and
tooling and can you find a faster
implementation of your current language
or your current runtime or whatever bit
is slowing it down if your current code
is confusing then writing the state a
similar thing with similar processes in
a different language is just going to
end up confusing again unless you figure
out how it got that way and fix it so
learning how to document better pruning
out dead code simplifying and
refactoring are essential first steps
when your code is confusing and then if
you think you're going to have to change
change languages eventually you can
start by documenting that boundary where
you're going to interface with the new
language and often by singling out for
the problem pieces of code that you wish
were in a different language and
documenting extremely clearly everything
around them you can reduce a lot of the
ambiguity that was causing you problems
to begin with and another unfortunately
common reason that some projects will
consider just rewriting in some other
language is that people are bored of the
existing one if you have a group of
people who are going to get bored with
one language what's to say they're not
going to get bored with the next one so
a rewrite is not going to solve your
problems there some ways that can
sometimes make people get less bored or
give more recognition and kudos for the
contributions that people are making
communicate better about the costs of
making changes you don't need have
people speculate or research what those
costs would be and potentially make it
more
to fix the things that you wish they'd
be spending time on instead through
whatever means that might take so
sometimes though a refactor won't
suffice sometimes you have just hit the
wall on what your tooling can do or
you're looking forward and you're seeing
well I can get up to this local maximum
but that's that's the best we're gonna
be able to do and I need a long-term
plan to set me up to get even further
than that with potentially different
tooling so can rust solve your problem
who here knows a little bit about rest
by a show of hands so about half the
room who here has light worked on rust
code in some capacity so about maybe 10
or 20 people so I will go through the
what rust is and when you'd want to use
it for both the benefit of those who
haven't had the chance to work with it
yet and anybody on the stream and the
future recording who will be a little
bit curious
so rust goals include memory safety
basically in any language that lets you
manage memory there's a bunch of rules
that the program is suppose or that
you're supposed to follow as a
programmer in order to avoid making
mistakes and with rust you have the
option of having the computer check that
you followed those rules instead of just
hoping you did it right rust shoots to
be as performant as C and we do this
with what's called zero cost abstraction
which means basically you can get the
same code to run on the machine
regardless of a few write it in the way
that makes the most sense to a machine
or in the way that makes more sense to a
person so the higher level abstractions
won't slow your code down and it has a
minimal runtime it has no interpreter no
virtual machine that you rely on no
garbage collection or any of that you
get similar guarantees to what you would
from garbage collection about memory use
but those are calculated at compile time
instead of at runtime so you trade a
slightly slower compile in rust where
you might have a faster compile but the
occasional garbage collect
hiccough in a GC language and rust
prioritizes making it easy to integrate
with other languages through the tooling
that those languages already have meant
for integrating with C and C++ which
have traditionally been the system's
languages to connect with when you need
finer grained control than your present
than a higher-level language is giving
you so when you get started with rest
you'll hear things that sound kind of
contradictory they'll be like oh yeah
you have guaranteed memory safety except
sometimes you don't and this kind of
thing and that's because rest covers a
lot of space by offering you a lot of
different choices the first choice
you'll get is do you want stable rest or
nightly rest the stable rest is always
backwards compatible with the other
stable rests and so it moves more slowly
it's not exactly a long-term support
which if you need a language that will
remain identical for five or ten years
at a time for your application rest is
probably not going to be the best choice
for you yet unless you don't mind being
on a pretty old stable nightly rest on
the other hand is all of the bleeding
edge features that we're trying out
we're not sure if these are going to
work we're not sure if the nightly is
gonna work but you'll know let's go try
things so all the stable code should run
on nightly if it doesn't if it's a
nightly but it's a nightly bug but
there's a lot of features in nightly
that won't necessarily run on stable
basically right and stable rest for as
long as you can but you may find a
dependency that requires you to use
nightly and it's very easy to use both
of them at the same time on your
computer with some tooling I'll tell you
about in a minute rust will give the you
the option of safe or unsafe code most
rest code is safe as in we check all of
the memory usage to prove that there is
no there's no errors being made that
you're not let's say letting to
different parts of the code read the
same memory when they shouldn't that
kind of thing whereas unsafe says this
is a circumstance that
we can't prove that I'll prove it myself
instead
so if you see rust code with some unsafe
blocks that unsafe is a hint that you
should stare harder at that to make sure
it doesn't have it's not doing anything
you wouldn't want it to when you're
starting to make your own crate when
you're starting a new project you'll
have the choice of making a library or a
binary if you're going to be integrating
your rest code with some other language
you probably want to make a library
because it can just be called into
through that languages FFI which I'll
talk about in a minute so you also have
a choice between dynamic and static
linking for the code that you produce
which dynamic linking says so with
either your depending on some libraries
that other people have written with
dynamic linking you say I'll just point
at the libraries elsewhere on my system
and with static linking you say please
bring in a copy of the bits of the
library I need to my program so dynamic
linking will give you a smaller program
that's a bit less portable across
machines and cross systems static
linking will give you a bigger program
that's a lot more portable and rest also
gives you the option to cross compile to
quite a few different target platforms
so if Boop's we added a new platform and
our current language just can't target
it but rest can is your problem
statement then a rewrite and rest might
be a great idea
so rust will also offer you a really
good tooling ecosystem or a tooling
ecosystem whose quality really surprises
people coming from a systems programming
background and feels very familiar to
people coming from a an application
programming background with where the
languages tend to have a higher priority
on user experience so when you're first
getting rest currently you'll get rest
through and choose which version of rust
you want to use at any point in time
through a tool called rest up bear in
mind if you're listening to this later
on that rest up is nearer to the end
than the beginning of its lifecycle at
this point so it's worth
doing a quick search to see whether the
features have been integrated into cargo
which brings us to cargo rests package
manager and buy package manager I mean
it's the thing that builds your project
makes sure you have all your
dependencies builds all your
dependencies if you need it to and will
let you publish your project to a public
registry if you'd like to share it with
others cargo can handle multiple
versions of various dependencies when
you want it to as well and then in terms
of actually writing your code you've got
rust format which basically codifies a
lot of recommended style guidelines for
rust code and will rewrite your code to
conform to those style guidelines if you
want it to and we have the linter Clippy
who just like the Microsoft paper clip
will make all kinds of helpful
suggestions except clip these are
actually usually pretty helpful to make
your rest look good so if you're writing
some rest you're a little bit worried
about sharing it with more expert people
you're like oh no I wonder if it looks
bad run it through rest format and
Clippy and they'll tell you how it looks
and help you fix it before anyone has to
look so if you're learning rest check
out the docs dot rest line org there's
more resources on community ORS slash
resources and tomorrow go to nick's talk
on Russ programming techniques hein mmm
so with that that's the super high-level
view of what rest is and I'd like to
dive into some places in the industry
that have rewritten pieces of their code
in rust and what they've learned from it
and I'm gonna show you two case studies
and they have a lot in common
first they isolated a very specific
problem that they wanted to solve and
they avoided rewriting code that they
didn't have to to basically minimize
risk they identified that problem based
on the risk that it was posing them
essentially and they made sure that at
the end of the rewrite they would be
exposed to less risk first the first
thing they did was it
stablish a workflow for having rest as
part of the project for testing the rest
code as well as the other code and for
shipping that rest code that went with
the other code that they were working on
so that that workflow has to come first
because without it you can't really
iterate on rest code that does complex
things and remember the goal is to make
the small changes one at a time to get
where you want to be they had a small
expert team of people doing the rest
part at first because the communication
overhead when you're iterating and
trying new things and trying to explain
well we tried that and it didn't quite
work so we modified it to try that to a
particularly large group can really slow
you down and they performed their
rewrites incrementally they made the
first small changes to make sure they
could ship rest and then a slightly
larger change to make sure that all
worked and see how rest really performs
in the wild and then once they have that
pipeline for adding rest to pain points
in their code they can proceed to add it
wherever they think that it's the right
solution with pretty little additional
overhead so and they left they do
educate the larger teams working on the
product about the rest work that they've
done but they put that off until the
rest is succeeding they don't try to
keep them up to date or with every
little detail unless they want to opt in
and watch because again that
communication overhead can be huge so
the first case study I'd like to look at
is NPM the node package manager so you
can see those several talks that I'll
link because I only have about 45
minutes here and I'd like to give you
guys some time for stories at the end
there first rest service was a load
balancer that would let them send some
requests to arrest micro service and
others to be existing micro service you
can watch Ashley's talk there that
youtube link of how they once they had
that load balancer in place and they
could send some of their requests off to
the
rest they then rewrote some of their
performance bottleneck code as a rust
microservice and so they wrote their
proxy which is figuring out how to get
rust into their ecosystem they ran the
rest in parallel more or less as I
understand it with their existing micro
service for that for a while to make
sure it was okay and then they switched
over to the rest one which really
mirrors what Mozilla did shipping rust
in Firefox through a project quantum the
several excellent blog posts about the
scope which is a huge scope of
engineering work that went into this but
I like the summary that Lynn Clark gave
of it they were rebuilding a jet engine
while the plane is flying because the
top priority was don't break Firefox
don't break Firefox for the users so
there's that's the huge difference I
think between rewriting anything versus
just building something new and that's
why a lot of of the companies have
adopted rust have chosen to start new on
something instead of rewriting something
existing you can check out the friends
page and if you look at the way that the
various companies use rust relatively
few of them are rewriting existing code
compared to building the new things as
they need them Dropbox habitat and
Coursera are instances of companies that
are building a fresh instead because the
rewriting requires a huge amount of
backwards compatibility so to talk a bit
more about about quantum though they
they first had to figure out how the
heck are we going to ship any rest code
in the Firefox build process and that
question was answered by attempting to
ship a tiny URL parser in rust to run
alongside the C++ one just behind a
feature flag turned off the users will
never see
but there's any rest code in their
browser but we can test our build system
changes to make sure that it will build
and then once they've made that tiny
first change to verify that they could
ship rest they proceeded to port
components of an experimental browser
engine servo that's written and rust to
they're analogous portions of the gecko
engine and basically wire it all
together so they they made small changes
a little at a time and only once they
were really succeeding did they bring in
the rest of the engineering team and say
okay now you need to start learning some
rest if you'd like to hack on these
components now we'd really encourage you
to start learning rest as opposed to
trying to work together on it the whole
time so what's the techniques for
rewriting your arrest code basically if
you're rewriting you're not throwing the
whole thing out and starting over which
I would sincerely recommend not to do in
almost all cases you're rewriting a
function or a micro service you probably
are going to need to use foreign
function interface which is a tool
that's been around for just about as
long as C has for calling some language
which we call the guest in your case
that would probably be rest from the
language we call the host that's the
language that your project's written in
and there's a bunch of examples of FFI
from rust out there and it's also you
can check the first edition and second
edition of the rest book for more on
this so I'm going to show you a super
tiny example of FFI to do some math from
Perl to rust there's gonna be four files
the kogo tamil configures how the rest
gets built and what metadata the rest
has main dot RS contains your rest code
main duck PL contains your Perl code
that will call the rests function and
the make file builds the Perl code and
runs runs cargo to compile the rest so
your cargo duck Tom will you say what
your package is and you give it a
library name this is going to be a
dinette
linked library because we don't really
care about portability across platforms
for a small example you're going to have
a main function you need the Nome angle
directive here because you need to make
sure your function has the same name as
it has here to make sure that it can be
called from your other code and you're
just gonna take an integer and return
twice that integer so in your Perl code
you will use pearls FFI mechanism which
there will be something similar in
pretty much any language to bring in
that function and make it available to
your code and then you will call that
fo5 function with your input and when
you call that function with your input
it will run the rest function that you
called in the rest function will double
it and then you can do whatever you want
with it in this case output it so it's
really not as much boilerplate as you
might be afraid of to just call a little
bit of rest when you want to the
makefile works on Apple and Linux and
will just run cargo build to create the
rest and then run the curl when you need
to so that's F Fi and a tiny nutshell
and the other thing you might need if
you're building portable code is static
linking and to statically linked breasts
you can check the docks you can make a
crate of the type static lib and you can
use the muscle library in lieu of Lib C
because muscle is designed for for
static linking so it's easier for the
compiler to stick whatever function it
was you needed into your into your code
that you're emitting and you may need if
you have a bunch of dependencies to also
recompile them with muscle because your
dependencies will be included when you
compile as well so if you can fi from
your host language to your to your
target language and if you can
statically link that rust that your FF
Iying into so it doesn't drag any extra
dependencies along you've pretty much
got it made for basic rewriting sections
of your code and rust however a bunch of
other
people have done partial rewrites and
have produced tools that you might find
fun and interesting if you're using
these languages if you're working with
Ruby check out helix which lets you
write Ruby and your rest rest in your
Ruby and various combinations thereof if
you're working with node.js check out
neon and if you need to if your
basically if you are Mozilla and you
need to procedurally generate a lot of C
bindings to work with rest code bind gen
exists
so that's rewriting and rust in a very
small 45 minute nutshell if you have
questions about rewriting in rust first
about rewriting parts of your code
rewriting and rust check with your
project in your mentors first because
it's often as much a cultural decision
as a technical one whether you're going
to rewrite check in your host languages
documentation for how you can integrate
with other languages and when you get to
your rest questions ask on IRC or ask on
the rest users forum or contact the
particular rust team that you have a
very high-level question for directly if
you need to if you'd like to talk to me
if you'd like to ask me questions
personally I'd recommend LCA at a denim
net and I would like to take the last
five minutes to be a little unusual for
this conference
I'm not going to encourage questions
though if you have something you'd like
for the recording you may ask but I
would like to hear your short stories of
rewrites and of rewriting code or the
impact that other's rewrites have had on
you or fun that you've had with rust
just as a bit of a chance to share so it
looks like we've got about five more
minutes till the cutoff time so would
anyone like to share anything first of
all me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>