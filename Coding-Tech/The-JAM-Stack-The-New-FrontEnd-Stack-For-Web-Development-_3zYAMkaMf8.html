<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The JAM Stack: The New Front-End Stack For Web Development | Coder Coacher - Coaching Coders</title><meta content="The JAM Stack: The New Front-End Stack For Web Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The JAM Stack: The New Front-End Stack For Web Development</b></h2><h5 class="post__date">2018-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_3zYAMkaMf8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today I'm going to talk about the gem
stick basically when Phil talks about
some of these concepts around static
roasting and so on like we we've been at
the forefront of sort of looking at
what's happening in front-end
development and where it's where is it
going the concept of static can be very
misleading because it sounds like stuff
that doesn't do anything and we started
talking more about like JavaScript API
sand markup as an new architecture
that's that's changing how websites are
being built but before I get to that
just a little bit about myself here as
Phil mentioned I'm the CEO of company
called net Levi and identify where we're
trying to build a publishing platform
for the modern web based on decoupling
the front end and the back end very
clearly and giving developers all the
tools they they need to publish and
deploy and maintain their projects in a
really efficient fashion a little bit of
background so before all of this I spent
seven years in Spain where I worked as
the CTO for companies that built
websites for small to medium businesses
but at a very large scale so we would
build around a hundred websites a week
tens of thousands of websites in total
we had a network of freelance designers
that would do the actual design work and
then in our sales team project
management team at Direction team and 20
plus people tech team that built that
whole platform that the designers would
do the design with the clients would use
for content management and that would
run the whole project from brief to
production him then in Spain I started
this company Phil mentioned webpop which
was really an attempt of taking all of
the experience of building a platform
like that and then building a fully
managed constant management system that
other agencies and professionals could
use to get some of the same efficiencies
when they went building websites for
clients I moved to the Bay Area with
that product and and worked at that but
then what happened was this as I was
working on on on web pop I started
noticing the world of friend of
development
lately change so when I started WebP up
the number one feature request we got
without any comparison was FTP access
and today that's like barely a thing
anymore like how many remembers the days
when you would FTP into a production
server and edit stuff as really normal
part of your workflow me too and then
how many work by FTP enter production
server and editing stuff directly today
okay that was true that admitted it at
least but in how many work with get
today yeah so this was one of the
massive changes that happened get became
like a massive phenomena not just for
version control but also as the way as
developers that we collaborate and work
together see our code publish our
projects and and just expect the world
to work in a way microservices and api's
was another thing that really emerged
that happened as the browser's became
more powerful than changed from being
essentially just document viewers that
could read the document and show some
links to us to being full-blown
application frameworks suddenly we have
all these services we can talk to you
straight for the browser and the logic
of where the logic on a website needs to
live started to shift so my approach of
building this big monolithic application
that web pop was started to being really
backwards and feeling like a legacy
approach modern JavaScript has also
completely changed the way that most
front end developers work today today
front-end developers compile stuff they
didn't compile so five years ago at
least not a lot of them in and together
these are really starting to to lead to
an approach where we can decouple the
front end and a back end in a very
different way than we used to at the
same time we're also seeing that the
approach to building for the web that
we've sort of taken the last 15 years is
starting to be really really
full of ever-increasing problems right
so this is the approach of having a
large more list server that runs your
program every time someone visits talks
to a database and sent back a new
version of the site and that has led to
like ever-increasing problems around
security performance and scalability
when we look just that at some of the
last months like this is sort of the
state of security on the web in general
if you take a normal WordPress site with
a few plugins and you put it on the web
server and you don't update it it used
to last for maybe six months today it
will last for maybe 14 days on average
until someone has infected it a metal if
I even though we don't support any kind
of sites like WordPress we we get around
sixty million requests every month to
our CDN from but looking for WP admin
just as automated attack traffic that
that monitors all sites to see if they
can find outdated plugins or anything
like that
performance has become a larger problem
as as mobile have become a thing there's
like one of my favorite statistics and
performance that 4% of people have
thrown their phone while using a slow
mobile side to make people really angry
and and the last thing is that the scale
of the web just keeps getting larger
right so the amount of traffic you can
get through your site if you suddenly
get popular on social media it's just
larger than it's ever been and everybody
has tried like seeing a new link go live
on hecka news already the Facebook
following it and getting something like
this right it's it's very common now
this leads me to sort of what what is
the next step and and how can we how can
we solve this so if we think back to
sort of the really old days when we
started doing connecting to servers and
so and we had the classical UNIX model
where you would have a client that
connected to some big mainframe server
and they would talk back and forth right
then with the web we got this in this
new version of that system that has
powered the weapon been extremely
important the last 15 years where we had
a client that would connect your web
server they would talk to an application
server they would talk to a database
that would send back data which the
application would use to dynamically
generate a bunch of HTML and then sent
back to the client
in what we think is happening now is
this shift where we have a client that
fetches the actual client directly from
a CDN and then talks not to one server
but to many different services that
looks something like this where you
start having a built tool that builds
your client and your client can either
be like a content driven site built by a
static site generator with thousands of
pages that you built and pushed to a CDN
or it can be something like a single
page chef where you build out a react
application you push it to a CDN and
then it gets loaded by the browser very
often it can also be a mixture of the
two where you have a lot of content and
you have a few dynamic pieces but where
you shift that dynamic layer through the
browser and talk to many different
services and then you get this get
centric workflow where instead of 50
paying interest off for thinking very
explicitly about deploys we just work
with our git repository whenever we make
a change we have some continuous
deployment framework that take that
change push it to the CDN and our new
version goes live that means that the
approach to building websites like the
stack has sort of moved up a little and
we can talk about JavaScript API s and
markup s the main web stack the gem
stack instead of before we had terms
like the lamp stack that really referred
to much lower level of the stack around
lineups Apache and MySQL PHP and today
we can say that that that that's that
whole layer at the server it's not as
important to us as developers anymore
and we can build with these abstractions
that they're actually closer to the
browser layer now
a couple of years ago in San Francisco I
gave this talk about the new front-end
stack after I had written an article in
Smashing Magazine about steak site
generators and this stack I maybe go
more in depth around the architecture
itself than he'll do today and they'll
talk a little more about a specific
project because after I gave that whole
talk and talked about like this new way
of building sites for steak site
generators Swift and with single page
applications and hybrid approaches
once I got out backstage markers from
from Smashing Magazine came over to me
and said so what would it take to make
that happen with Smashing Magazine and
that was like a really interesting
question because people here might at
first just think about Smashing Magazine
this is a block with some articles but
smashing magazine is actually pretty a
pretty complex project him they have a
they have a block of course in WordPress
with ten years of articles and around
two hundred thousand comments they have
a shop built with Shopify well they sell
their ebooks and printed books and
conference tickets and workshops they
have a job board that's a Ruby on Rails
application and then the conference size
is built with Kirby and they have to
maintain the same theme across all of
these platforms in which can be really
tricky when you want to do any kind of
design changes and then they wanted to
introduce a concept of memberships that
I'm sure we'll see more to in the future
and it's a question each of those are
really big monolithic applications they
don't actually have any way to talk to
each other right so where would
something like membership actually live
right where would the members be and how
do you actually take that from one side
of the other and I I took a look at that
whole stack and then sort of the whole
gem stack ecosystem at the time and I
had to say like I couldn't just tell
macros and literally like go use these
five tools and build
and put it on Nedley fie and you'll be
fine because the ecosystem wasn't really
there right so one of the things we
decided to do a little if I was to serve
offered Smashing Magazine to help out
with that and say let's start building
an open source ecosystem that's powerful
enough for this kind of project so we
started building out a series of open
source projects like knit leaf ICMS for
constant management go true go coomer's
and so on and we started imagining in an
architecture something like this where
you have your browser it loads a
front-end straight from a CDN talks to
these different micro services content
editors work in that leaf ICMS that
makes changes in the git repository
every time there's a change in the git
repository we've run a built which is
built with a stay exciting arena called
who go and web pack for building for
long post CSS and modern JavaScript and
so on
Portia's that to our CDN and now a new
version of the of the site is live who
go is a really special tool in this
regard it's it's a new static site
generator in ways they excite generators
generally work is that you have all the
content for the site in plain text files
like markdown or yellow or JSON files
then you run this de-excite generation
tool and we'll take your set of
templates and your set of content and
then spit out all of the HTML for your
website and who goes special simply
because it's it's very fast so Hoover
can take all our Smashing Magazine and
build it in around 30 seconds in with
thousands of pages so this is what we've
been working on literally publish the
blog post about it back in March and you
can see the public beta version of this
next that Smashing Magazine calm him
and I'm gonna dive in a little in like
what tools we actually use to build this
and how we've we've put it all together
the first part I'm going to talk about
is is the authentication pad so part of
this new site is is the membership
concept and a membership section and
that covers both like logging in as a
member but also logging into the shop to
see your orders and so on and that was
one of the initial questions when we
have this kind of micro service based
architecture with a front-end and many
small services how should our household
authentication really work we build out
a small open source library called go
through him it's a little authentication
API in go in and it comes with a
corresponding JavaScript library that
makes it easy to it to develop again and
the principle of it with which it's
built is worth just talking a little
about so when we go back to this like
evolution of the web step by step and
look at the client-server model then
obvious indication was very
straightforward right you would just
have a client that would send a username
and a password to the server the server
would look that up in an e-2c password
file and if it was well user then open
up a connection and now you have a
connection and you can keep talking over
that connection until you get locked out
very simple now in the current like sort
of traditional web architecture how many
here has tried building like a session
based login system for for traditional
web application scott'll let's build
their own mostly probably just used
library for it or a ready-made system
you will have like a browser that since
this user and password to your web
server the web server will do a lookup
of your user in the database and it will
vary verify that the password is correct
and then it creates a session
in the database and since back session
IDE in a cookie and now your browser
uses that cookie and keeps sending that
cookie on every single request that
makes to the server and on every request
the server can look up the session from
the cookie find the user and decide
whether you're locked in a locked out
and respond so how does this work when
we no longer have one
like when we no longer have this web
server that responds to every request
there the first simpler approach is this
initial step where we start building
single page applications and where we
really often just have a client and one
API instead of a client and many small
services and typically the system here
works very similarly to traditional
applications except that instead of a
cookie we do chase Ajax based web
requests and we add like an
authorization header with a token but
it's still a question of like where do
we get that access token from in a safe
way today the major solution to that is
really well - which is a specification
exactly for like when you have this
access token then you have an API you
want to talk to how do we actually get
that token there's a couple of different
flows you can use to get it but in the
end the approach is somewhat similar
right like you do one of those floats
you make a request with the token the
serve like your API will look up your
session in the database and it will
response with some JSON instead of some
HTML but it's it's it's fairly similar
right like your depend on this database
where once the token is created the
database know what the session is and
and and you it works like normal again
how does it work when we no longer have
that central database and we no longer
have like when we have many small
services that that needs to talk to each
other so we're smashing we have all
these different little services that
needs to know who is this user right
when you write a comment we need to know
is this
locked in users not logged in user when
you buy a product we need to know like
are you of doing an anonymous check out
or buying a product as a user do you
have a membership discount how does it
work right the the naive approach would
be to still have sort of this single
point of failure where you always talk
to the same database now you have like a
very tight coupling between all these
small services and it's not we haven't
really actually made a micro service
architecture where we can break up
different parts of the sites we we've
just like taking our traditional API and
then split it into some parts that all
talk to the same single point of failure
and it'll also slow down performance
right because now we've added in an
extra API call to every single API call
to somewhere else now one of the
standards that that's emerged to solve
this problem is it JSON web tokens JWT
s-- it's a the smart guy set off zero
let's sort of started pirating this and
turned it into an internet standard and
it's really aimed at solving this
problem of stateless authentication so
what is it Jason web token it's a string
that has freed like two dots in it that
separates a header a payload and a
signature it's signed with a secret so
it can be verified so what that means is
that when you have these three parts of
the string you take the header you take
the payload you encode them and then you
make a cryptographic hash based on a
secret you have and that in that payload
and then you attach that so this is this
is like an example JSON web token where
you have like an encoded header and
encoded payload and a signature of those
two and the payload is really just it is
an object it can be anything you can put
in a JSON object now the interesting
part with this is that if I'm an API and
I get one of these case and web tokens I
can't
and then I can look at that payload and
in this case I can see that I have a
subscription like an unique ID I have a
name of the user and it says that that
uses an admin if I have the same secret
that the identity service used to sign
this JSON web token with then I can
generate the same signature and I can
verify that the information and that
payload is true so now I don't need to
ask a database do we have a locked end
user or not is this user and admin what
roles does she have I can just look at
the payload and know that this user is
actually an admin and now this API
action is based on an authenticated user
with with an action there's some
specific claims like the sub claim is
that a is included in the JSON web token
spec so we can always need know that
when that jason element has a sub
element that indicates the unique use ID
and there's some other claims like an
expiration that can say how long is this
token valid for in and the children can
be used both to identify user and to
authorize the user and build trust and
it can even include display data so if
we need to use the user name in an email
or something like that we can also just
take it from that token and put it into
the email and we know that it's actually
the right information so this means we
can go from this single point of failure
to something that looks more like this
where we have one little authentication
API that issues our JSON web tokens we
can ask it hey can I get a token from
this username and password and then we
can use that token to talk to all the
other api's without any coupling between
them now the model of authentication
starts looking like this to a request or
the JSON web token the ABI just verifies
that signature without talking to
anybody else and since back a response
in Jason now some time
we'll have a little middle way of called
an API Kate way this comes in imagine
that you need to talk to an API that
don't know your secret from your
authentication service well they just
don't know about it Jason Webb
children's or anything like that then
the approach we can have is that we can
chalk from our of indications we like
from from our browser with a JSON web
token xx API gateway and that gateway
can then verify the claims see if if
that's a valid token and then it can
translate through the other API so it
can either take that token and it can
sign it with a new key or it can change
it into an another kind of choking
specific to the API it's talking to and
then set back the response jason so this
this is like a technique that means that
we can suddenly stitch together all
these different services that don't need
to know about each other in any way and
the potential of that is that we can
start really building very reusable
micro services like these small
open-source projects we've been working
on and on identifiers as part of the
Smashing Magazine project one of these
we just launched that's a menstruation
of as as metal if I identity together
with our own micro service gateway but
it's all based on go true which is
completely open source and they can be
run anywhere and all of the issues we
had to solve a Smashing Magazine was
obviously content management so when you
have a build tool like Google and it
works with Mac down and yeah Mel and
Jason in it gives developers a very very
natural flow because everything is
distant git repository there's no
external database you can just download
the repository and start running and you
have the whole side running locally you
can make commits and make pull requests
and people can view those pull requests
and see if everything looks right and so
on and and typically developers gets
very excited about that and front-end
developers too friended developers it's
very powerful
for creatives it's very powerful because
we typically get and much easier process
of implementing this
and if they have to be stuffed into a
more traditional CMS but for content
editors for marketing people or anything
like that when you come and tell them we
have this amazing get centric workflow
with pull requests and you can just edit
markdown files and frontmatter their
reaction tends to be a lot a lot less
excited so one of the one of the things
we started building to solve this is
another open source project called
notify CMS and the idea with notify CMS
is that it sits on top of your git
repository and turns your normal content
editors into into essentially developers
let's see if I can show you in action so
I set up a very little example site in
this is how the CMS looks for for
Smashing Magazine site it has like a
live preview of everything you do in and
I took like this a little super simple
documentation template also built with
Google but it could be any snake site
generator the CMS doesn't care what
built rule you use or anything it's
really just an editor for content that
you're storing a git repository so this
this is the the admin UI you'll see that
I just go to the URL of the website
itself slash admin and now I'm locked in
in in a pretty typical straightforward
content UI where I can navigate the
different documents I have I can go in
here and I can I can change the the
title of my post and let's see if I save
we have the actual github repository
over here where each post is stored in a
content folder as markdown files and
what will happen when when I save this
entry is that the CMS behind-the-scenes
created a new pull request and I can go
in and see this pull request I can see
since this is hooked up to an edifice
continuous deployment system I can go in
and see exactly how the site will look
like with this fire-breathing dragon
pull request and if I go to the main
dashboard of the CMS I get a little
editorial workflow where I can go and
decide to publish this article and that
will essentially merge in the pull
request will have a new mass and a new
version of the site will built so when I
when I worked with this as a content
editor I work entirely in the browser
with a rich text editor and a and a UI
that reminds me of of any other CMS I'm
I'm used to but when I work as a
developer with those content editors I
just see them making new pull requests
and github and editing markdown files
and doing merges and and all of those
operations that we used to in s
developers and that's really powerful
because you normally have this huge gulf
where the developers really really like
the modern snake site built tools and
likes to work and get content editors
tend to really like traditional CMS's
but as soon as they pick one of those it
determines the whole technology stick
right so if you develop if your content
marketing team comes and say we need a
wordpress site now your developer team
has to work in PHP and MySQL and all of
that right with this approach we simply
just bring the content editors into the
same get centric workflow that we are so
used to as developers and and we can
pick the technology we actually used to
build the sites with and other issues I
was really interesting with with with
with Smashing Magazine was so how do we
how do we were like what what do we do
instead of shall be fine in how how do
we solve all of their ecommerce needs
including sex issues and and and the
littlest drive to create very expressive
checkout workflow with interesting extra
checkboxes and so on so to solve that we
built another open-source project called
cocoa MERS cocoa Marisa say is a hitless
ecommerce API comes also with a
client-side library and we're working on
it
solid admitting begging for it as well
in let me just show you a little example
of how that works and how we solve that
so if I go to the books session and I
click get a new book I get sent to the
checkout pad at this stage all of this
all of what's happening here is actually
happening completely client-side it's
just a little pre act application pre
act because it's very very lightweight
that generates the the shopping cart it
puts the information from my shopping
hat into local storage and that means
that everything here can be completely
customized on the front end side of
things this there's no need to touch the
back end this point I still haven't made
any requests to to any servers anything
I'm gonna show you all my secret
breakout number don't copy it in when I
click here all it did was using stripes
JavaScript API to take that credit card
number and exchange it for chokin and
now again all of this is rendered
client-side there hasn't been any actual
back encoding sofa
and we see if I can find the network tip
make it a little bigger so when I click
finish
check out this is where we talk with two
requests through the API and imagine if
if we had to build she'll be fine that's
like a huge system you need to build
Shopify you need to build a routing
layer you have to build a template
engine you have to figure out how does
the whole catalog get generated you have
to implement categories and search and
all of that and when you build a Shopify
site you're completely reliable of what
is inside this monolithic application
right like if she'll be fight doesn't do
something or doesn't have a plugin for
it you can't really do anything about it
but in this case this is really a micro
service a it almost boils down to true
API endpoint where the first one is this
post request to create an order where we
sent some information on billing address
and then a list of line items that's
included in the order so the client
mainly says that what we're buying is on
this path of the website and has this
SKU and then if I go to this path on the
website and I go to view source I'll see
that the the source code has a bit of
metadata about the product so the
e-commerce API will take that path it'll
look it up on the side it will extract
this metadata and then it'll use it to
calculate all the pricing and texting
and verify that all of that is correct
so you can't so you can't see it and
just change the the pricing client-side
and that means that the product catalog
is the website right like the the
e-commerce API doesn't need any specific
database for that and since all of this
is based on JSON web tokens it also
doesn't need a user database it just
needs to know that it can rely on the
JSON web token to know if you're logged
in or not and then once you've created
the order object you sent the one other
API acree request
with it's basically just a a request to
pay for that order just saying sending
or whether stripe token we just
generated and telling the ecommerce API
now I want to pay for this order with
this stripe token then the e-commerce
table API creates a new order object
sent off the relevant emails it can
trigger web hooks to to to endpoint so
you can do custom actions when that
happens and and this again this like
I've really true micro service right it
doesn't have a big surface area but it
means that you can build essentially any
kind of checkout you want and you can
completely customize the flow and its
meshing we have now like several
different flows a different flow when
you buy a ticket a different flow when
you buy a job board posting a different
flow when you buy a book and all of
those flows can just be implemented
client-side however we want it as long
as they just end up sending these
through these two requests to the micro
service at the island
another tool that I won't go as much in
depth with him was the little tool we
need needed to build in order to handle
200,000 comments and we had this goal
when we built this project that we
wanted everything to be pre-built and
Static when you navigate the site so
anytime you do any specific action or
any time you interact with stuff like
actually buying a product or creating a
comment or signing up for membership of
course that requires like to talk to an
API but just navigating the content and
reading everything that should be
completely static so we built a tiny
little tool called go tell which has two
modes that can run in it runs in a
little API mode where it works as
another little micro service that you
can send a comment to and when you send
a comment to that micro service it runs
some spam checks if all looks good it
just pushes your comment to a github
repository if it thinks you're probably
a spammer it will push it to the
repository but that's a pull request and
then again we have the same little go
tell tool running in the opposite mode
where every time it detects a new change
in that repository it builds out a bunch
of common threads and it pushes them to
the CDN so that means that we can build
all of these 200 thousand comments fast
enough that we can have a very
reasonable slow way of going to write on
your comment and and after a little more
moderation it shows up as a new comment
on the side and everything lives
directly on the content delivery network
so this is this is our effort to build
an open-source ecosystem you can find a
lot of these projects at Natalie
five.com slash open-source and we hope
that people in general will will
contribute to build out this we we
obviously think the diss architecture of
decoupling the front end and the back
end gives us much
ruling his friend and developers to work
on the front end without having to
without having to go through all of the
trouble of integrating constantly
interlocked CMS system or complicated
bag and we also think that we can build
out an ecosystem of these very small
self standing micro services that has
small enough of a surface area to be
reusable across different projects
whereas the larger the monolithic
application you built the less reusable
it will be and we believe that the stack
has really as I said moved up a little
from this low level of thinking about
servers and programming languages to
thinking about what happens in the
browsers and essentially working in
JavaScript and markup and talking to
small api's and we're pretty excited to
to work towards wrapping up the the last
niggling issues and the new Smashing
Magazine sites and and and show you all
what we've been working on I'm very
happy to continue this talk at and
anywhere and do we we're building a very
active community around this open source
projects with lots of contributions and
I hope you'll all check out this
invitation to participate in the debate
and engage thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>