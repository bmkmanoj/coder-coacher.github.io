<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>12 Ways To Make Code Suck Less | Coder Coacher - Coaching Coders</title><meta content="12 Ways To Make Code Suck Less - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>12 Ways To Make Code Suck Less</b></h2><h5 class="post__date">2017-12-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/c-8FPZ1Amuk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm going to talk about court quality
and I want to talk about you know how
can we improve quality of code as we
develop software there are maybe about
four kinds of people there are these
what kind of people they want to know
what do you do what do you do and then
there are these how kind of people how
do you do it and then there's of course
these when kind of people may be
managers when are you done and then of
course there's the slash people who are
maybe I belong to which are the why kind
of people I always want to know why why
are we doing it that way I feel
motivated to do it or maybe there's not
enough reason I wouldn't really bother
doing it so I want to start with the
question why should we really care about
code quality what's the reason for it
and I'm gonna say probably there's one
really good reason to really care about
code quality and that is we cannot be
agile if over code sucks as simple as
that so if we this is not moving at the
pace it's supposed to move let's try
this year so so one of the biggest
challenges is we cannot be really agile
if our code sucks we are in a meeting
and remember what agile development is
agile development is about making change
based on feedback and an intimate
inviting change even late in the game
and you're sitting there in a meeting
and you realize wait a minute this is
the change they're suggesting required
means to change the XYZ module and the
last time I touch the XYZ module I
couldn't go home for the weekend I'm
gonna convince them this is not
something we should work on right so
core code quality is very important but
there I think there's another reason why
we should really care about code quality
because code quality is how we tell our
colleagues how we feel about them do we
love them or do we hate them all and
when you have the code it's usually how
by looking at the code you kind of say
what was this programmer thinking what
did we do to this person to have written
all this kind of code right it feels
that way a lot of times well it turns
out lowering quality of code lengthens
the development time as the first love
programming size so we definitely want
improve the quality of code if we want
to maintain agility and in
speed and what we do so I want to talk
about how do we you know improve the
quality of code but the first question
though is what is quality of code and
you probably will find as many
definitions for that as the number of
sources you read but I once worked with
a guy who had a really weird way of
defining code quality he said this code
is great because I wrote it I don't
think we should have a definition like
that so we should definitely not have
such biases so how do we really define
the quality of code well here's my
definition of quality of code I'm gonna
say the quality of code is inversely
proportional to the amount of time and
effort it takes to understand it if a
code is really good quality we take a
lot less time to understand it if a code
is a poor quality we spend more time
with the code to understand it so I
would say the quality is reflective of
the amount of time it takes to
understand it so we're going to talk
about 12 ways to improve the code
quality I'm gonna start counting down
some of these ways well the first one
I'll start with here is going to be
rather non-technical and that is to
schedule time to lower technical debt
well we all have heard the term
technical debt it was coined by Ward
Cunningham when he worked on financial
projects and he said just like the
financial industry has technical debt we
are asked as financial debt we accrue
technical debt well what happens if an
organization or an individual does not
take care of the financial situation it
leads to financial bankruptcy
likewise projects unfortunately end up
in technical bankruptcy whether we want
to admit it or not or whether we have
the courage to admit or not so we really
have to take the time to pay the
technical debt along the way but when it
comes to software projects one of the
things I do when I walk into client
sites and companies is I ask them you do
have technical debts but where are those
written down so one of the very first
things I want to see in the work area is
technical debts written down on the wall
in the order of highest priority to
lowest priority so I can see
every day when I come to work I can see
what my technical debts are because if
it's not written down it's not seen and
we tend to forget it too often and then
we keep brooding over it in meetings so
writing it down on the wall in the order
of priority highest to lowest will help
really well and once we write it down
then we can do something really about it
but what are the saddest things about
technical debt is you don't have to do
anything to start accruing it you have
this application you just deployed
yesterday and that's using the product
version let's say for point seven point
three and then six months goes by that
framework is seven versions ahead
whether you do anything or not that's
gonna change and if you don't keep
upgrading you come to a point where it
becomes almost impossible to upgrade in
the same way and that's a debt that
accrues on you very quickly the second
problem of course is oh that schema has
kind of been developing over time the
requirements has been changing along the
way and the schema is kind of bent and
we really need to start working on it
but we haven't really had the time to do
it so a lot of these things start
accruing technical debt however writing
poor quality code is not technical debt
it's an intentional sabotage we can't
just put terms to it and say oh it's a
technical debt we have accrued so we got
to be very careful about it so we we can
do something about these technical debt
but what can we do about it it doesn't
have to be an all-or-nothing proposition
so once we identified these technical
debt and write them down we can then
come back and say well here's the one
that is hurting us the most we need to
really pay attention to this he is going
to spend fifteen percent of his time on
this technical debt number one he is
going to spend maybe fifteen percent of
this time on the debt number two and so
will he on the third one and we can
start dividing this among the team
members to give focus on what they can
focus on reducing technical debt they
could have other people working with
them in this case but we don't ignore
but we bring it into the fold and say
we're gonna start scheduling time
towards it so when it comes to projects
what do we normally do we schedule time
for development and we do a lot of time
you schedule for development then we
schedule of course time for planning and
then we schedule time for meetings we
schedule time for vacation and so on and
sickness
some companies schedule time for
vacation some companies don't schedule
for vacation and people tend to take
more sickness time kind of works out but
the point really is we tend to put these
times together on projects but one of
the things we also should do is actively
start scheduling time to pay a technical
debt and if we don't put specific time
on our schedule maybe during sprint
planning then we really don't put a very
active
you know effort into fixing it but in
addition to technical debt I want to
also talk about one other thing and I
learned this from this wonderful lady
and and when she said something good
really shook me because she made some
really interesting things for me to open
my mind and think about it I'm talking
about Linda rising and she's used the
metaphor and the metaphor that she used
was she said that a freeway filled with
cars is a parking lot and and that is so
true when you really think about it if
you have a freeway and you start putting
cars and cars and cars on it very soon
the cars start going at maybe you know 2
or 3 km/h and it almost feels like a
packed parking lot in front of you well
that's exactly true about your own
schedule as well if you fill up your
schedule with all the work to do then
there is we all know one thing as
technical people nothing we take
actually gets done on time things always
slip and if you have packed your
schedule you never give wiggle room for
it we have already set up for failure
all righty
so we need to really have wiggle room in
our schedule when we start scheduling
but what other things you say it said
was she also said that if you never have
as an individual as a team as an
organization if you never have slack
time on your schedule you will never be
able to innovate and and that really
shook me because I'm a consultant
if
don't work at a client site or on a
client project I'm not billing somebody
so my incentive is to pack my schedule
with all the all the client projects and
work as I can and when I heard her say
that I realized that's that backed me
who's working for the client
continuously is like a candle that's
being burnt and in two years I'm gonna
be burned and I have nothing else new to
do when the world changes I need to be
ready to do that as well
so I started injecting about two weeks
on my schedule when I absolutely don't
do any client work and having the two
weeks when they don't have to do
anything is wonderful because I can then
do all those things I really wanted to
do but I never got a chance to actually
do and also to have time during the
weekend doing even a single day just
giving I call this to my time and just
having that 15 minutes of my time where
I don't do anything for anybody else but
focus on what I am curious about to
learn and investigate makes a big
difference I can tell you every single
project I work on in the past several
years have absolutely come from out of
that my time where I spent time learning
and exploring something and investing in
myself
this also is given quite a clarity with
this book which is called the Guns Germs
and Steel and Jared Diamond talks about
the time when humans were pretty much
hunter-gatherers there were savages they
had to go out and hunt every day and
when they had to go and hunt every day
the day they don't go hunting
is the day they're gonna starve and and
then humans discovered they could do
agriculture they started collecting
grains and they started domesticating
animals and this was phenomenal because
well Bernie gets up in the morning and
Bernie didn't have to go hunting
and Bernie could sit around and have a
good time and when there's time to eat
can't get some grains from the from the
store and and eat it and of course can't
spend their day playing with this little
nice lamp and when he's hungry you could
just eat it and this is amazing isn't it
so well what are you gonna do if you're
not gonna go out to hunt today and well
that's when art started being created
that's when people started creating
music and civilization and culture
started growing along the same time so
that's exactly - our work as well if you
don't have to go to work and work every
single day and you have time to invest
in other things we might be able to
really invest in tools that can make us
productive and in turn really make us
better in what we do as well that comes
in to help us a great deal so to have
the ability to schedule this time for
paying technical debt and to have slack
time becomes extremely important the
next thing I'm going to talk about is to
favor high cohesion well cohesion is
something we all talk about quite a bit
cohesion is where a piece of code is
narrow focused and does only one thing
and we want to really make the code very
cohesive but why should we really make
the code cohesive and the reason for
that is to really minimize the frequency
of change to the software and that's
what we really are trying to do is to
minimize the frequency of change so when
a software system has to change over
time if somebody tells you that they
wrote a piece of software but they never
ever changed it what they are telling
you is the project got cancelled any
relevant project has to change over time
well in this case we want to don't want
to change the software by changing a lot
of it so you want to keep the change
minimum as you go through it so you want
to minimize the frequency of change of
software well it turns out we can
understand about this by looking at the
cyclomatic complexity of code when the
complexity of code is very high the
cohesion is pretty low you want high
cohesion and you want low cyclomatic
complexity of code well when it comes to
code we we tend to ignore this quite
often this is one of those principles we
all know but unfortunately as time goes
on all these thoughts just kind of
linger in our minds but doesn't really
translate to the code I was in a client
site and one of the developers said hey
come over here I'll show you something
and and these guys has been have been
developing software for a good 30 years
it's a little overwhelming for me when I
go in and see because some of these
people wrote the very first line of the
code in the software 30 years ago and
I've been working that long the
version-control has 30 years worth of
in there and this developer drags the
timeline and puts the cursor on the
timeline 15 years ago and shows me that
day when that function was born it is
beautiful it was small group you know
red behind its ears little fingers the
cutest chubby you could see and I'm
admiring that this beauty of this little
code the day it was born and he points
me to the corner of the screen where the
cyclomatic complexity is shown and the
value is a beautiful value of five and
as I'm admiring it he says now let me
show you how the code looks today
and he drags the timeline and in front
of me I can see the score turned into a
monster and then the current day state
of the code and the only thing I can
recognize in this method is the name of
the method everything else is different
very many many number of parameters to
this method very long very complex and
then he points me to the cyclomatic
complexity a value of 864 where a value
of 10 is considered to be complex and he
looks at me and says that's what we do
the code in this country in this company
it's kind of scary when the code kind of
goes like that and becomes overly
complex over time so we know we should
really make the code cohesive but we end
up code that is actually not cohesive
and really hard to deal with so we
definitely want to make the code
cohesive and and because cohesion really
makes it easier to maintain software and
also reduce the frequency of change as
well well the next thing of course is we
want to lower coupling well sure we want
to loose coupling that's what everybody
tells us but I want to go a step forward
from that and I don't want just loose
coupling if I can I want to eliminate
coupling not just have loose coupling
now think about this for a second
tight coupling is really bad I'm going
to think of the worst keyword in Java
I'm gonna say the worst keyword in Java
is the keyword new because when you use
the word new what happens you are saying
I want to tightly coupled to that class
whose name I'm providing in fact the
entire frameworks like spring
and other things exist just to solve the
problem of not depending directly on the
classes that's a very complex problem
the slew of abstract factories come in
just to solve that problem
you don't want tight coupling well we
have learned that we can have loose
coupling by depending on an interface
rather than depending on a class so we
tend to really create interfaces to
reduce the coupling and to make it loose
coupling but I would argue we need
something a lot better than that well
this reminds me of an experience I was
in a conference where it was an open
space conference there was no talks
given by people while developers got
together selected a topic got into a
room and talked about it and one of the
topics in the conference was we loved
automated testing but the test doubles
the marks and the stubs make it really
hard for us to maintain these tests so I
was very curious about this topic so I
walked into the room stood by the door
and I was listening to this about 30
people in the room talking about how
they are so passionate they write
automated tests they write unit tests
every single day but then after a while
the project becomes really hard to
maintain because all these test doubles
really make it make their lives really
miserable after listening for about a
few minutes I interrupted and I said eh
folks I have a little comment or a
question maybe I'm just curious maybe
you're having all this trouble with your
arm ated test just maybe because your
design sucks and by saying that I made
everyone in the room really angry and
they said who are you why would you come
in and tell us of our design sucks and I
said why I write a lot of design that
sucks I thought you guys are like me
well what are the developers said let me
explain to the problem I'm dealing with
and we'll talk about how you would
probably solve it so he puts the little
problem on the table and talks about you
know this particular class has a
dependency on this other class because
it needs to get the data from it and I
realized what he is explaining I would
probably call it as an incidental
coupling an incidental coupling is where
you are you have a perceived dependency
from the problem statement but that
doesn't mean that's what it really
exists in the system and we do this
quite often and the next morning I wrote
a blog opposed where the title of the
blog post was knock out before you mark
out so the idea is I want to eliminate
dependencies rather than you know
dealing with the dependency or loosening
it because if you get rid of the
dependency the problems are a lot easier
to deal with well let's talk about you
know one of the ways we could probably
do this so here is an example of a class
on the Left R and then of course the
middle one is talking to the one on the
right which is the red one well let's
say the class on the far right is
non-deterministic and slow and maybe
really hard to work with so but I want
to write automated tests on the code in
the middle maybe I'm writing 20
different tests what if I'm gonna write
20 different tests every single one of
them most likely is gonna deal with a
mark object or a stub for the dependency
and that becomes really hard for us to
program well what we could do instead of
that is realize that this code in the
middle takes an input right there from
the left one but then it also gets some
data from the right class so we can
argue maybe rather than doing it we
could invert it so for example let's say
if I ask you could you please get me
water to fill up this class well the
immediate question is going to be well
let's see this glass it's got some weird
shape it's got a you know a smaller air
volume in the bottom a bigger volume in
the top there's a curve here and then of
course do you want it up to the brim or
do you want a little less and now you
notice we are arguing about this glass
and you're leaving me thirsty when I
wanted water so the point really is
instead of that we could simply ask I
don't care about your glass tell me how
much water you want do you want you know
twelve ounces of water or in milliliters
whatever it is we don't need to be
dependent on this information we could
really decouple from it so the idea
really here is what if we try to move
things around what if the court in the
middle which was in the middle can be
given these two arguments and then of
course the court in the far left was
able to get this data from the red class
and get that over to you so the point
really in this case is we didn't quite
removed
dependency but we moved the dependency
and that becomes a lot easier to work
with and it reduces then it makes it
easier to write the test on the far
right class now well we wouldn't need
any stubs are our mocks our test doubles
on the right one well but wait a minute
doesn't that really make the code on the
Left really more complex and hard to
test and the answer is no it doesn't
because the interaction that we had a
minute ago is very fine-grain from the
blue class to the red class on the other
hand this interaction from the gray one
to the red is more coarse-grain we don't
really need to have that many tests
around it for that interaction well the
next thing i want to talk about here is
to program with intention now we tend to
really program accidentally sometimes
reminds me of an experience of new weeks
ago I was at work and I was you know
rewriting a piece of code and as I was
rewriting this code Mike Mike I was
looping through and calling a method
with the argument from this particular
collection and the minute I called it it
didn't work so I told my colleague well
that didn't work what should I do
he said try index plus 1 and I tried
index plus 1 and the test immediately
failed and I looked at him and said that
didn't work what should I do and without
missing a beat he said try index minus 1
I kind of stared at him and said are you
serious now he said ok let's really
understand what the code is doing that
is not programming that's called coding
in desperation right we're trying to
throw stuff together and see if it's
going to work that's not going to be
helpful at all so we really need to
think about programming with intention
we have to program very deliberately and
so I came across this particular
sentiment and I think it just nails
every one of our feelings it said when I
wrote this code only God and I
understood what I was doing now god only
knows so this is so true isn't it
because you look at this code and you
are absolutely don't have a clue what
this code is actually doing sometimes
I'm sure you've gone through this you
look at a code and you are in denial
you are singing I bet you aliens came
wrote this because nobody on the team
would have written this and then you
discover your name on the version
control and you don't have a
recollection of ever writing this code
and you're like really did I write this
and you're trying to remember the day
when you actually wrote it right and and
that's what happens after a while we
can't remember writing some of the code
and it's really hard to understand what
the code is actually doing this is one
of the reasons I'm a really a big fan of
canned bags
rule of simple design he says that the
forethought to follow these four rules
he says the code passes all the tests
there is an implicit assumption right
there that they're actually tests for
the code but the code passes all the
tests then he says it reveals the
intentions no duplication in code and
finally fewer elements I'm a huge fan of
the last one which is the parsimony or
minimalistic design sometimes people
really hate me for this because I'm
always like you know can we reduce it
can we reduce it can we reduce it
because out of the opinion the code you
did not write has the fewest bugs in it
so I would rather not write a piece of
code if we don't have to write it keep
it really minimalistic so we have less
to maintain as well so but he says that
these are the order of high priority low
priority if there was a conflict between
two the one in the top takes precedence
over the bottom one in other words we
definitely want to you know reveal
intentions more so than avoiding
duplication if there was a conflict
between the two well this is one of the
reasons why I'm a huge fan of writing
tests before writing code because if I
write a test before writing code it
forces me to deliberately think about
what the code is gonna do and that can
be very helpful to think about what we
are going to code before we get a lot of
complexity into it so we want to really
program deliberately the next thing I
want to talk about here is to avoid
primitive obsession now this happens a
lot when we program primitive obsession
is where we write code at the lowest
level possible we write code in so many
ways to do things
that
be done with the higher-level code very
easily and and it's very frustrating
when this happens the I was we had
really good tests that's a good news but
I was looking at a piece of code a few
months ago and I was looking at this
function and within this function there
is 30 lines of code which is doing
string manipulation and I'm looking at
this and saying you know what this gives
me a really weird feeling why did this
programmer take the effort to write this
code 30 lines to manipulate a string and
and I was thinking and I want to
emphasize this when you sit down to
write a piece of code ask yourself this
question am i dead am I the chosen one
because if you are the chosen one
you should be writing this code and if
this code is very specific to your
application very specific to your domain
the chances are you are the chosen one
celebrate that but if the code is so
generic and common the chances are
somebody was chosen in a long time ago
and they have written this code and I
bet you they wrote the code a lot better
than what I could do with it because
they were chosen they focused all their
effort writing the piece of code I am
just writing it as part of my own
application I am NOT going to put invest
myself into that code as much as these
guys would have done so if I'm not the
chosen one
I should reuse the code and not rewrite
it and so that's the thought that went
through my mind at this point and
immediately I started searching and to
my shock I found a method right there in
the JDK that did exactly what those 30
lines were doing and all I did was I
quietly commented out the tody lines of
code put this one call to the JDK method
made sure all the tests were still
passing and I quietly checked in the
code didn't say a word about an hour
went by I saw the code change in the
version control so I was curious I did a
pull and looked at the code well the
developer who had written the code
originally saw that the file had changed
when there to look at
what what I had done in refactoring it
notice that I quietly commented out the
entire code and made this one call and
that he highlighted the commented code
bolita did and checked in the code
quietly that's a really good way to
learn sometimes is to realize all that
effort you put into right he was not
needed at all because somebody had
written the code already what I'm also
gonna say that the code we write at a
very low level can be very difficult to
maintain and and I'll say that
imperative code is packed with
accidental complexity now imagine I give
you a two five kilo little you know
stones and I ask you to tie them on your
wrist and start coding how painful it's
gonna get after a few minutes that's
kind of like imperative style of coding
you're sitting there and working too
hard the day to do this let's look at an
example of what this really means let's
consider one little example to see what
this would actually mean in reality so I
have a function that says is prime to
return a prime number
you've given a number it's prime or not
well the main is calling the compute
method but focus on the compute method
what is it doing it gets two numbers and
and K what it wants to do is to find the
total of the square root of the first K
prime numbers starting with n well I
want the square root of all the primes
but only K of them but that start with N
let's be honest about it it's a problem
that's relatively simple it's not a very
complex problem it's not a problem that
requires you know extensive research and
analysis a problem is simple a solution
should not be any more complex than the
problem well what happens if a solution
is complex when the solution becomes
complex it creates more problems for you
to deal with than the original problem
wanted you to deal with so how would you
solve this particular example let's say
we're gonna use the imperative style
that we are all used to so what am I
going to do double result is equal to
zero return result so I'm gonna return
the result right there then what do I do
int index is equal to N in count equal
to zero so what did I do so far absolute
nothing useful all I did was wrote all
these variables and then you're like
bothers a lot of work you know and today
well these variables have a special name
these variables are called garbage
variables they are garbage variables
because they're not needed by the
problem they just came here because the
solution we used in fact I'll tell you
one sign you're using garbage variables
when you're writing code you normally
don't call them as result or index or
count you will normally call them
something like temp and then F and C the
way you'd write it is because you're
showing your contempt to the variables
to say you don't deserve to live but I
have to use you and that's how we
express our emotions on the stored as
well when we write this code so once you
write this what is the next thing you do
then you say while count is less than K
and your mind comes to a screeching halt
and you asked an unnerving question you
said less than or less than or equal to
do you ever ask this questions every
single time there is only one purpose
for a code like this it is intended to
make us feel stupid because you write it
and you feel absolutely silly you're
thinking you said this or this you're
trying to put this together we're never
sure about it and and it's confusing and
then you go a little forward any pause
and say did I get this right and you're
never sure about it right well then what
do you do then you say if R is prime of
index is true then I'm gonna say result
a result a plus equal to math dot square
root of index and you compute the value
for it if this court correct no what am
I missing
I have to increment the count I heard
you say okay I will do that count plus
plus is it correct now increment the
index okay index plus plus is it correct
now no what is wrong
oh it should be outside fine is it
correct now no this should be inside
that should be out how do you feel about
this is the code correct now did you
notice you went from no to I'm still
thinking
I'll tell you one thing though
programmers are the smartest people on
earth because when you show a code like
this to a programmer and say is it
correct
they'll very smartly say it looks good
they never will say it's correct because
they know because if they ever said it's
correct three days from now when you see
that it's not correct they're in trouble
you know it only looked good so they are
very very smart about it right so you
have to score it right there so what are
we gonna do now
let's go ahead and run it and see what
it does right there is the result is it
correct it looks good
that's all I can say right so here's the
solution but if you look at the solution
this is an example of accidental
complexity it is an accidental
complexity because the torturous code
right here did not come from the problem
the torturer here came from the solution
we used and we've been doing this for a
very long time my only fear is 400 years
later humans will see this kind of code
in the museum and they will have a laugh
of their life
and they will look at us and say do you
know what these guys were doing back
then and that is the biggest you know
trouble I have he's looking down from
you know heaven or hell I don't know
where I'm gonna be but when I'm looking
down and I'm gonna look down and say
shut up we didn't know better back then
well at least we could try so what am I
going to do here let's try to write this
a little differently using the
functional style well the beauty of a
functional style is its declarative it
reduces the complexity quite a bit so I
can say return a stream dot iterate and
in this case I can say given the value N
and start incrementing from E to e plus
one and then I'm gonna say dot filter
get me all the prime numbers starting
with n but get me all the square root of
all the prime numbers starting with N
and then I'm going to ask you to do one
other operation which is dot limit K and
you could say is it less than K is it
less than or equal to K its k time it
keep moving and then of course I can
simply say sum to do the operation on it
so when you look at this the code has a
lot less complexity compared to the top
code as you can see not just your lines
of code but the sheer complexity has
been removed the moving parts are really
gone from this so rather than having to
go back and forth with these multiple
variables recently said given a
collection of all the values starting
with and give me all the prime numbers
starting with n give me the square root
of all the prime numbers starting with n
but give me only K of them and do a
total of it it becomes a lot easier to
work with so I have this theory about
these kinds of code when you look at the
imperative style code I feel there is
one thing that imperative style feel as
trial it code does it it is code like
that that prematurely turns programmers
into managers because this young
developer comes to work struggles with
this for a few maybe months to ears and
says I am done I'm going into manage
demand I will add you clowns deal with
this so the people in this room there's
a special name for you all we are the
survivors because we came back every
single day to work and said I can handle
this and you wipe your sweat and get
back to work right and not many people
it's got tears in his eyes already I
feel your pain and that is how it is
that we it's really hard for us to do
but we do it but when it comes to the
functional style code I feel this is
what I feel about functional style code
a good code should read like a story not
like a puzzle what we write shouldn't be
like a puzzle the code we've been
writing is like a puzzle and what
happens when you write a puzzle your
colleagues don't understand it sometimes
they may take a few hours sometimes they
take a few days some
even they've take a few weeks to
understand you are working quietly in
your office and suddenly hear the scream
in the next room
and you pass and say you got it finally
right and and this is not helpful for
projects because people take this
enormous amount of time to understand
the code that becomes really really hard
so we want the code to read like a story
not read like a puzzle well it turns out
the imperative style code is where we
tell what to do and how to do it well in
the declaration style code we tell what
to do and not how to do it what are the
reasons why functional programming is so
exciting is not just because it's
functional it's because it's decorative
well declare any program every piece of
functional code is declarative but not
all declarative code is actually
functional so that is one of the biggest
trends we are enjoying these functional
style is actually that already plus the
higher-order functions well the next
thing I'll talk about here is to avoid
clever code and write clear code we all
have this desire to write clever code
now why do we write clever code honestly
we write clever code because it feels
really good you write the piece of code
which is clever that proverbial hand
comes and Pat's you in your back and
says oh you are so awesome and then we
are like this is great I'm gonna do more
of this tomorrow and and this only
chemic becomes a vicious cycle over time
right so it just becomes very very you
know exciting to keep writing this
clever code well I have a experience
where a client wanted me to solve a
particular problem and they described
what the issue were and I looked at the
problem and I said oh you know what it's
gonna take me 10 minutes to solve this
problem but no I don't want to solve
this problem I want to solve the meta
problem because it's so much more fun to
solve not just a problem but any such
problem from ever happening again I'm
gonna put an end to those things and
that's how smart I am how cool I am
right and I spent an hour doing this
when I finished it I had an outer-body
experience when kid got up from the
chair and came and hugged me and said
you are awesome it felt that good and I
checked in the cord and I walked so
happily I didn't solve problems today I
saw made our problems today right well a
couple of weeks went by I got this email
from the client saying something
terrible has happened in production I
looked at what happened in miracle pull
back saying I got this I can fix it they
said oh we know you'll fix it because
you're that good
I replied saying no I can fix it not
because I'm good I can fix it because
I'm the one who caused it and what was
the problem well the clever code I wrote
had totally backfired in ways I never
actually imagined so what did I do
I quietly rolled back the code I put in
and did that ten minutes of work that I
should have done in the first place
fix the problem that actually we know
about and I never heard about it after
that and and I listened really learned
these days when I sit down write code
the minute I realized this code is
clever I delete it and start over
because I don't want clever code I want
clear code that is something that we
should strive for what a beautiful code
this one is from Ableton and Sussman
programs must be written for people to
read and only incidentally for machines
to execute so we really want to think
about readability of code not the effort
we take to write it so sometimes we try
to innovate and come up with very smart
ways to implement code but machines may
really you know be able to deal with it
but when a fellow developer comes to
maintain it they have a really hard time
and way they waste a lot of time this is
one of the things I'm becoming more and
more sensitive I always ask the question
not how much time and money it took for
me to write it how much time and money
it's gonna take for another developer to
touch it if it's gonna take more money
for them to touch it and change it I'm
not doing a good service writing this
code so that becomes very critical to
deal with I'm gonna say 10% of the time
you write ugly code for performance
reasons the other 90% of the time we
write ugly code just to stay consistent
and that way we don't feel guilty about
this and I was at work a couple of weeks
ago when a very young
came and sat on the chair with a big
tart and a big sigh and I said having a
rough day at work R&amp;amp;P you said let me
ask you this question to you venket I
was in this other meeting other room
within a meeting and this developer had
written a horrible horrible horrible
code and I asked him why this code is so
horrible and ugly and he said he had to
write it so horrible and ugly for
getting good performance so I want to
know what you think about it I said I
will answer that question to you but
before I answer the question let me ask
you a question does that ugly code have
good performance and he said that's the
problem it doesn't and and that is where
we end up a lot of times in encode be
right so those who sacrifice quality to
get performance may actually end up
getting neither so when you realize the
code doesn't perform very well you're
pretty much stuck because nobody wants
to touch it and and becomes extremely
hard to improve the performance of such
a piece of code that becomes really hard
to work with so we want a really write
clear code not clever code Tony Hoare
says this really well he says there are
two ways of constructing a software
design one way is to make it so simple
that there are no obvious there are
obviously no deficiencies and the other
is to make it so complicated there are
no obvious deficiencies so we want to
really focus on making the code very
simple and clear that that's very
critical for us to do the next one I
want to talk about here is quite a bit
of a hard one because this came from
rather a non-technical book and I was
reading this book and as I was reading
the book I kept screaming my gosh
everything he says in this book is not
about English it's about writing code
and and this this author absolutely did
not you know talk about coding in any
stretch of imagination but I got this
book as a gift actually originally I I
start I started speaking English when I
was about 18 or 19 years old and and I
really had a lot of trouble writing
English the people who had to
read my English in the beginning they
were not called editors they were called
as victims and they had to read what I
wrote and one such victim took pity in
me and said you really need some help
here's a book read it and that's one
that's how I got this book and and when
I read this book I was so impressed
about this book it's a very old book
it's 13 30 years ago by this gentleman
called Williams answer mr. Center passed
away a few years ago but he left
something really wonderful of the
humankind it's a book about writing
English about writing nonfiction if you
want to write an article or a book or a
technical you know blog what are the
things you should consider in writing
better English that's what he is talking
about in this book and as he is and when
I'm looking at this particular book what
I noticed was he had some really
beautiful recommendations in this book
and one of his good quotes in the book
is he says hard writing makes easy
reading easy writing makes hard reading
and so if you put a lot more effort in
writing people find it very easy to read
it if you don't put much effort and
write writing people put a lot of effort
reading it and becomes really hard to
read it so the point really in this case
is I liked a lot of things and I liked
it so much that I kept talking about
this book all the time and at that time
my son was 10 years old who is 14 now
and and he has usually a summer reading
where he would write down the names of
maybe 20 to 40 books that he wants to
read during his long summer holidays and
and when he was 10 he said hey Dad I
keep hearing you talk about this book I
want to include this book in my reading
list and then he said can I borrow that
book from you I said no don't touch my
book it's my little precious and I went
in guard him oh his own copy and said
it's yours you keep it and and and he
came back and he said something really
interesting he said it's not a book to
be read it's a book to be reread and he
has read this book almost every summer
since then and I know because he would
quote things from this book without even
looking at it that's how much he has
actually read the book and and so I'm
very convinced about this this book it's
really good but it was written for
writing English
but he lays out four principles for
writing good English and it came
striking to me because those very four
principles that he says are good for
writing English are also good for
writing code and he would absolutely
agree the minute you see at least a few
of them the very first principle he
talks about in this book for writing
good English he says is simplicity and
can't we all agree that that's one of
the things we strive for when writing
code as well
he says when writing English you have to
keep things very simple because if what
you're writing is very complex you're
gonna lose the interest of the reader of
your book and so he says simplicity is
very important and of course what causes
you know a lack of centralina our code
well when you have a lot of mutability
when you have low cohesion we have high
coupling the syste code becomes not so
simple and very difficult to deal with
the next thing he talks about is clarity
he says when you write something got to
make it very clear now I have written a
books I've written thesis I've written
articles I've also read other people's
writing these days I read more books
before publication publishers contact me
and say would you review this book and
give us feedback so I'm pretty much
taking the brunt of the author like I
had given it to other people and when I
read these authors writing I noticed
something they do which is a common
mistake I have done myself and that is
this author knows the content in their
head in their mind but when they start
writing it they talk something here and
then suddenly talk something over there
and suddenly start talk something over
here and there is no flow through the
logic and becomes really hard for us to
understand so in writing for clarity
there's got to be really good flow in
writing same thing in code as well when
writing code you are looking at this
piece of code and you're not sure what
this author the programmer is trying to
do because there is no flow through the
logic in the code becomes really
frustrating so we definitely want to
really have good clarity in code the
next thing he talks about is gravity
he says shorter sentences are better
than law
longer sentences shorter paragraphs
better than longer paragraphs shorter
chapters better than longer chapters he
says shorter books better than longer
books I do have to admit to you
I have more open books than the books
I've actually read I would I'm very
eager to read books but when I start
reading a book in all honesty I lose
interest in about the fifth page or the
tenth page I'm a man of impatience and
if the penta page by the tenth page I'm
not excited it doesn't matter how
wonderful the technical content is if
the author has not helped me to read it
I leave the book on dread and I have
these books in my office or at home
still open on that page unless the wind
has blown the pages up and I don't even
go ever back to them because I just
don't like to read them then one day I
was acting the question there are a few
books I've read cover to cover I would
not put them down I would take them on
the trips when I travel I would read
them continuously and I would not put
them down until I was done with the book
cover to cover and I asked myself the
question what really makes it
interesting for me to read books and I
noticed one reason I read books and that
is the books I really enjoy they when I
look at a page there are almost never
they have a page with one big paragraph
in it what they have a lot of times is
maybe three four if not five paragraphs
in a page and I realized something
you know normally when I go on a client
visit I mean in a more tongue all the
time I would finish my client word I'd
go to dinner and oftentimes I would
carry a book with me to dinner and I
would order food I'd open the book and I
would start reading and I'm usually
there until the restaurant closes and
everybody is gone and and what I would
notice is I would read a paragraph and I
have to read the paragraph I will be
looking out the window while my eyes are
looking out the window my brain is very
far from the window it's analyzing what
I have read I'm thinking about it I'm
building a story about it I am you know
experiencing what the author said and
then I would move on to read the next
paragraph
and I realized when the when the
pedicles are small the author is
respecting the reader the author is
singing I give you a piece of
information but I'm gonna give you some
time to think about it and then come
back and reflect on and move on to the
next thing it's exactly the same thing I
tell my developers when I do code
reviews I tell them if you write a
function where everything is like this
you are not caring about the reader but
even one blank line just one blank line
you are sending us such a very important
message to the reader I did one action
now I am transitioning to the next
action now and that one line is a gold
when it comes to code so often in my
code abuse I keep telling developers put
a blank line here please put a blank
line here please and that's one of the
reasons to really do that
the last thing he talks about his
humanity I first rejected this I said
humanity we don't care about humanity we
are programmers we write code and the
compiled compiler can deal with it right
and I realize how wrong we are when we
work with developers if we think of a
manatee the design in the code is
actually much better and that is
something we have to really work towards
I remember an experience where I was at
the optometrist and she was looking in
my eyes and examining and she said what
do you do for a living I said oh I'm a
programmer a few minutes goes by and
then she is talking about other things
and suddenly she said what do you do for
a living I said I'm sorry
I think I told you that I'm a programmer
she said yes you did I heard you but I
just wanted to make sure because you
look almost normal and and some way we
are giving this impression to people
that somehow if your programmers we
should really be you know antisocial and
we shouldn't really talk to people well
in all honesty I'll be honest about it I
travel a lot
which means I'm stuck in an airplane for
you know about nine to 15 hours at a
stretch 9 to 15 hours is beautiful time
to do a lot of work so I would get into
the airplane and the minute I sit down
my laptop is open and work
on either writing some code writing an
article maybe writing a chapter in a
book easily you can finish a chapter at
least the first draft in a in a flight
like that so I don't want to even talk
to the person next to me so I'll be the
most antisocial person in airplanes I'll
sit down I'm by focused on coding I'm
not gonna turn around and look at this
person
don't even bother speaking to me but
then I would get a little wind that the
dude next to me is a programmer and she
has been coding and I'm like well I
realize you're a programmer we turn into
a riot at this point because we got so
much to talk about right from garbage
collection to exception handling and you
cannot just have enough of the flight
time to do it
and that is one of the most interesting
things this truly happened actually I
was on a flight this is one rare
occasion I was in a business class but
this entire business class was vacant
and I sit in my seat this lady sits in
the seat next to me and then she says
well it looks like the business class is
totally empty I'll wait for others to
come in but if no other seat is occupied
I'll move and I thought that's kind of
rude but that's fine and now I know why
she was rude but anyways but I said you
know what that's fine you can move
anywhere you want to but if in every
seat is filled and if you still have to
sit here I'll be more happy if you sit
here that's fine
and I kind of pretend that it's all cool
and and then of course I went back to
work and then a few minutes later she
kind of looks at me and says I was
actually writing Scala code I can
imagine why she said this but she looked
at it and said I can't imagine humans
are still doing this and I kind of
select do treaties speak to me I kind of
like excuse me and she said I can't
believe humans are still doing it I said
I'm sorry are you talking about me
writing code and she's like yeah I can't
believe that we have to keep writing
code like this and I was very surprised
she said this because she thought I was
human but anyways but but then I said
yeah what do you know about programming
and she's like oh I used to code when I
was when they're punch cards I'm like
points cards let's talk about it I'm not
kidding with you in this flight in eight
hours the flight attendant came several
times and said could you please be quiet
you're making too much noise here there
are people who want to sleep and you
guys keep talking and that's the beauty
right the minute you find this other
person is a geek you cannot just resist
it so the point really is
I have this theory that we are not
anti-social we're just social among the
right kind of people that's the way it
is so so that is the beautiful beautiful
absolutely were to think about humanity
we cannot ignore it the next thing I
want to talk about is something that
really hit nerves on people because some
people feel that they have to come and
comment every single line of code there
right I want to emphasize comment why
and not what I want to write comment to
tell me why the code exists not what the
code is doing and I really really really
hate comments that tell me what the code
is doing I want the court to be you know
some documenting in self describing if
somebody comes to me and says I don't
understand this code commented I say
timeout I don't understand in this code
refactor it so I want the court to be
refactored not to be comment commented
and so I want the code to be self
described documenting and easy to read
easy to understand and and that is
something very important for us to do
and I'm gonna say a good code is like a
good joke and when you tell somebody a
joke what if they don't understand the
joke the worst thing you can ever do
when people don't understand your joke
you start explaining it because this
doesn't go well at all because when you
finish explaining it those people look
at you and say oh yeah so what's that
what's funny about it and you're like
let me explain it it's gonna be a very
long evening so there's only one right
response when you tell a joke you say a
joke and people don't get it you
immediately say nevermind just don't go
any further just never mind so they tell
you a joke you say never mind and then
you go home sit in a corner and you
think about how their day went
and then you refactor your joke and then
you try this with a new group of people
and see how it goes so a good code is
like a good joke commenting a piece of
code is like explaining a bad joke so we
really want to focus on making the code
self descriptive self explanatory but
unfortunately though a lot of times
people want to write comments do you
explain code as to what the code is
doing the other day I see a piece I see
I saw a piece of code which did
something beautiful it said increment
right next to it I was so thankful I
said you know
as I'm getting older my eyesight is not
really good and when I look at this
there are times I don't know whether
it's plus plus or something else so it's
so wonderful for these people to take
care of me
they said grandpa I know you don't see
this very well
I'll put an increment comment for you
they're very kind of them but the point
is you know what I can zoom in and find
it too they don't need to put this
comment and also the other day I saw
this beautiful code where it said X and
then too with the beautiful shift next
to it you know what I get it it's a
shift but what I don't know is what is X
I don't know why that is - I don't know
why are you shifting I don't know so a
lot of times these things are really
left out and it becomes really
frustrating so what if the code can be
self documenting so that we don't have
to really keep documenting and telling
what the code is doing so I came across
this I was in Washington DC to speak in
a conference and I wanted to take a
shower before I went to give a talk
which is usually a good thing so I got
into the shower and the minute I got
into the shower I was about to open the
shower and I saw this and I got so angry
well we live in a world where when you
are very angry
you don't take a shower you tweet about
it so I jumped out of the shower right
away
grabbed my smartphone and took a photo
and tweeted it and my tweet said the
following and and because the reason I
had to tweet was I felt intellectually
insulted in all honesty because I looked
at this and said you Rascals why can't
it give me a shower I can actually use
you have to document it so my tweet said
those who cannot design are condemned to
document and this has just gone
overboard in my opinion you go to the
shower and they have to tell you in
words how to use it you go to a door and
they put in words pull and you don't
know what to do about it because you
keep pushing it still right and to make
things worse the other day I had common
cold and I wanted to really take some
tablets to cure my cold or hockey's
helped with my cold so what did I do
I took this bar I was about to pop two
tablets in my two tablets but I saw
something
on the bottle so I was kind of curious
alit said let me read it so I strained
my eyes to read and it said take two
tablets by mouth and I'm like what other
ideas are you giving me right now so
this is like ridiculous right so why do
you have to tell me take their two
tablets by mouth I think that should be
obvious unless otherwise intended and so
the point is I think the lawyers are at
it they try to really you know put all
these things into the documentation so
too they can frustrate us so a or two
three what in the world is three well
let me comment it oh no why don't we use
a more descriptive enum maybe so it
becomes self-documenting so document why
the code exists tell me the purpose of
this code tell me the preconditions and
postconditions tell me the exceptions
but don't tell me what every single line
of code is doing I can figure out what
the code is doing tell me why the code
exists and the constraints around it
well the next thing I want to talk about
here is the so called you know about
long methods long methods are evil well
let me ask you this question who hear
things long methods are a good idea not
a single person raised their hand let me
ask you a different question who here
has seen long methods at work in their
own code a hands start going up other
people are very reluctant they're like
doing this side they are they're like so
painful they don't want to do this yeah
so we this is called cognitive
dissonance right everybody knows not to
do it and yet there is code that works
I'll tell you why you have long methods
at work I know the reason for it you
didn't write it because you just told me
you don't believe in it right you didn't
write it well the sad part is the people
who believe long with us are a good idea
they're not here today they're at work
right now making those methods longer as
we speak and that's the sad part about
it right so they are writing those long
methods so long with these are bad but
why there are several reasons why long
methods are bad idea
long methods are hard to understand
long methods are hard to maintain long
with its are hard to debug long with the
so hard to test
methods are lack cohesion long methods
have too much coupling the diagonal
opposite of what a good design as the
other day somebody said to me in a very
grim why's he came to a realization he
said do you under long methods become
longer that is so painful to think about
it right I travel a lot so when I go
home I always look at my kids and say
hey you are taller than I saw you last
time I don't want to come to work and
say hey you method you're bigger than I
saw you last time that's not a good sign
so the point really is the along methods
become longer the long methods lead to
duplication of code long methods are
hard to reuse I mean we could keep going
with this right but yet people keep
writing long methods so the question is
why are we writing long methods let me
ask you this question if I tell you I
have a method which is 10,000 lines long
would you agree it's long yeah okay
absolutely thousand lines what do you
think still yes hundred lines still yes
okay fifty there are a few yes and
others are like a bouquet for fine you
should be the fifty lines okay or are
not okay are usually these Ruby
programmers in the rooms right and then
I'm gonna say ten and the Ruby
programmers like okay close you know
guys are like what ten it's too much
well there's something we know we cannot
put two programs in a room and come up
with a consistent value for what a long
method sizes because the industry has no
agreement on it the other day somebody
said in a very nice way he said hey I
know how to define a long way that I
said go for it
he said method is not long if you can
fit the entire method in a window and
immediately somebody said what's your
font size this doesn't work out all
right so we can lower the font size and
get more things into it why bother
well okay well it turns out we've been
looking at it wrong so I'm gonna explain
it in a slightly different way let's say
you have this collie who writes long
methods you have told this collie don't
write long methods please the colleague
doesn't listen to you so there's one
last effort you can help to help this
person to realize so you go back to work
on my
morning don't say a word just sit down
and start working you're calling the one
who writes long methods comes to her and
says hi you were a late work how was
your weekend you could tell your
colleague how your weekend was like this
you could say oh the weekend was great
on Saturday I went to the park with a
park on Sunday I went to the movies but
don't say it like that instead you say
all the week and I'll tell you at seven
o'clock on Saturday I took the car out
of the garage took a left turn rode for
about seven kilometers took a right turn
and went for another 20 kilometers took
a left turn and then drove for another
seven kilometers but missed my exit how
down it is had to turn around and had to
wait in the traffic light for 15 minutes
to ten can you believe this and then I
went for around the 17 kilometers and
took a right turn and just keep going
like this at some point your colleague
would say have you gone mad you said no
I've not gone mad
I thought I'll tell you how my weekend
was like the way you write code and the
point really is when we talk to people
we don't talk to people like that how do
we talk to people we say I went to the
park on Saturday and went to the movie
on Sunday oh really what part did you go
to or the one by the Main Street I've
heard about it is that family-friendly
oh yes I took the kids what kind of
activities do they have for the kids
over there notice we are drilling down
into this abstraction one level at a
time leaving the movie aside we don't
care about it that's exactly what we
want to do when we write code and that's
called the slap principal the slap
principal says single level of
abstraction principle so it turns out we
really need to focus on the levels of
abstraction and not on the length of the
method I've often heard people tell me
the reason they don't like to a shorter
methods is there are way too many short
methods they cannot remember that's a
sign we have taken the methods and
broken them into small chunks without
considering abstraction we want to
really think of abstraction and level of
abstraction this actually helps I do a
lot of code reviews and invariably one
of the recommendations I've had for one
developer particularly was to break this
method into smaller methods break this
madness smaller method break this method
in smaller methods this went on for like
many months and one day my review was
murdered these two
into a single method he or came right
back and said I don't get this you
always tell me to break methods into
smaller methods I thought I figured you
out and now you take a u-turn and you
tell me merge these two methods into one
I don't get it I said oh I'm really
sorry because I've been telling you what
to do
I haven't told you why to do it well the
reason I asked you to split these
methods often as they are to different
levels of abstraction they don't belong
together but today in the code I asked
you to merge these two methods really
are in the same level of abstraction
they don't actually belong separately
they can be together so what I'm looking
for is not the length of the method what
I'm looking for is the abstraction and
the methods that really are the
boundaries to think about so that is
something we should really strive for
the third one I want to talk about here
is give good meaningful names to
variables and methods they say one of
the most difficult things for
programmers to do is name variables
right I have a definition of what a
programmer is a programmer one who can
name their children quite easily but has
a hard time naming their variables you
can pick children names very easily but
these variable names they seem to be
haunting us we got to spend way too much
time thinking about it right so we have
to really struggle hard but variable
names are very important I was working
at a client site and this particular
product by the way a single license to
this product is a million dollars it's a
very intensive engineering application a
lot of science involved in it a lot of
engineering involved in it and I was at
the site and I said we were going
through code and they flipped through
one code and they jumped over to another
file said oh can you go back to that
file and they did I said can I please
take a photo of this and they said as
long as you don't tell who we are and
don't show anything else absolutely go
for it
so I took a photo I'm very thankful they
let me take a photo of the code and here
it is oh sorry this is not what I took a
photo of what I really took a photo of
was the line below this it said god help
you have no idea what this means
these are developers writing the code
and somebody had left this I feel like
this is what I see you see a comment
like this and then you look down there's
dry bone in the bottom this is the last
call from the program before they died
right and they couldn't handle this
anymore and and so when people ask me
what do you do for a living I don't tell
them I'm a programmer anymore I tell
them I'm a software archaeologist
because I think what the word and I try
to figure out what this code means and
then when we talk about it we
hypothesize I think this what the code
means and one of the doubler says but
remember it was Victor 10 when they
wrote it
okay let's think about it so we couldn't
figure out what the code is doing and
that's really really hard to work with
label names represent abstraction so we
have to really think about them well if
we cannot name a variable or a function
appropriately the next thing I want to
talk about here is to do tactical code
reviews I know a lot of people they're
thinking are you out of your mind
you are asking us to do quadrants well
unfortunately code reviews have become a
very political and emotional fashions in
some companies they bring the team
together in a room they project the code
on the screen and they start talking
about it this is called bad idea because
Sara says I'm already behind schedule on
my code the last thing I want to do is
complicit to the sticking are humans you
guys have all day I'm gonna skeptic Joe
in the meantime says you know what you
guys are gonna look at my code I'm gonna
call in sick that day I don't want to
take this in the meantime the boss says
whenever this Court have you thinking is
that this kind of thing that you did
last one on the Thursday oh yeah no
because the last time you guys did it
there was a fight there to call the cops
of who people quit no more authority for
you right so people don't like recorders
but I found extreme value in this and if
you ask me if there's one thing I do
very very thoroughly that is code review
on my own projects actually I invite
people to review my code as well and one
of the reasons I do that
well one clear reason is the benefit I
get out of it
but keep in mind one a few things though
you are never reviewing code you are
always reviewing the person whether you
like it or not it is very emotional it
is very difficult to separate the person
from the code however sinful we can all
be so the minute you start talking about
the code they're gonna get really
agitated so one of the things I
recommend is never say what's wrong in
the code don't say things like gosh I'm
looking at this code I could not see
where it begins and where it ends how
horrible this code is what do you go to
school by the way you don't want to be
really insulting people like this right
so you don't got emotional on them and
personal on them instead always make
recommendations I'm looking at this code
do you think we should split this into
two functions maybe three maybe these
could be the functions always suggest
what to change rather than what's wrong
with the code and one of the other
things I do very thoroughly these days
as I not only review the code in fact I
don't review the code until I finish
reviewing the test so by reviewing the
test you can ensure they've actually
written the test as well and also
there's one thing I did about seven
years ago that I've made it as a
practice ever since about seven years
ago what I used to do is I would review
code and I would find bugs in code and
when I find bugs in code I would write a
paragraph I would say hey looking at
this function if you send a value
between 200 and 300 it'll give you this
result which is not right right bla bla
bla bla and that date occurred to me you
know I could write this paragraph and
walk away but it would be a lot more fun
if I wrote a automated test that fails
because of this bug it took me about 10
to 15 minutes that day to write this
test and I wrote this test that test
failed and I just checked in the test
quietly didn't say a word the automated
build condition decoration server PE
goes out and says test failed and it
broke the bill by the way I'm perfectly
fine with breaking balls and so when the
bill broke the
who wrote the code gets a notification
and I got the notification to which I
very summarily deleted and the other
developer looks at this email and says
oh look there's a notification that test
failed
it's the code I wrote I know bank it was
reviewing it but it's broken let me see
what happened an hour goes by and he
comes to me and says oh I see what you
did there you found a bug and you wrote
a test uh-huh but did you know there
were three more bugs in that code and so
when I found what you have done I wrote
three more tests now so if you look at
it there's three more tests than the one
you wrote and I pulled up in this issue
and enough there are four tests sitting
there which were not there before and I
said to myself my job here is done
because when people get into the habit
of writing tests before fixing bugs and
then fix the bugs that's the right thing
to do so we can promote these kinds of
behavior during during code reviews as
well and I started doing that ever since
but as a twist about six months ago I
learned yet another lesson I saw a bug
in the code so I started writing a test
for it I spent 30 minutes on it and I
still could not make the test to fail
and that's when I figured out it was not
a bug the code was so poorly written
I had misunderstood it so now my
recommendation was not go fix this bug
here's a test here are ways to refactor
read so that becomes easier to
understand the code so that can be very
helpful as well
so how do we do the tactical code
reviews I have write a piece of code I'm
going to give it to him for reviewing
and then the next piece of code I'm
going to write I'm gonna give it to him
for review the third piece of code I'm
gonna write I'm gonna give it to her for
review and I rotate among these people
just one person reviews the code not
everybody gets together in the meantime
the code he writes maybe I would review
it or he will review it we don't have
any senior developer junior developer
kind of mentality anybody writes code it
gets reviewed it doesn't matter whose
code it is it'll get reviewed by
somebody else so the carrot tactical
review has been extremely beneficial
overall the last thing I want to talk
about here
East reduce state and state mutability
so if you ask me there's one thing I do
differently today than I did maybe you
know ten years ago I will clearly tell
you that one thing is dealing with fewer
states
I used to write code which is bloated in
state objects with a lot of fields and
mutations and stuff like that and maybe
it's my you know learning of functional
programming over the past few years that
got me excited into this slow transition
away from it bless you so essentially
these days when I sit down to write code
I noticed this among developers quite a
bit they would sit down and say public
class and the very next thing they do is
private something and putting a variable
into it I immediately ask them the
question and why are we putting a state
right now I don't want the state to be
self-serving I never want the state to
be there just for itself
I want the state always to serve a
behavior so what I tell me developers
now is when you start writing don't put
a field start writing methods and when
you start writing methods let a method
force you to have a field and only then
reluctantly bring the field over so I
want to minimize the state as much as we
can so my recommendation is to think
more kite let's aim for minimalistic
fewer state less mutability and just
enough code for the known relevant parts
of the problem a little more you know
philosophically I would say messing with
the state is the root of many problems
both in software and in politics this is
why we go to war with other countries
right we always want to mess with
somebody else's state which is not a
good thing so generally it's better to
leave the state alone and of course
mutability often needs company it hangs
around with bugs so the more the
mutability we have in code the more bugs
we often end up seeing as well so we
want to definitely reduce it so we
talked about 12 ways to make the code
suck less so here is the list of the 12
ways we talked about a schedule time to
lower technical debt favored high
cohesion favor loose coupling and reduce
Andrew
coupling where you can a program with
intention
a white primitive obsession prefer clear
code / clever code apply the sensor
principle aren't writing to programming
comment why not what
avoid long methods apply the slat
principle single level up abstraction
principle give good meaningful names for
variables and functions are do technical
code reviews and reduce state and state
mutation one department art I'll leave
with you we all write code we all enjoy
writing code but one of the things we
often deal with unfortunately is we
often deal with teams where developers
managers business analysts disappear
everybody comes to us and says are you
done yet and they want us to start
coding and be done right away which is
insane I was in Madrid a few weeks ago
and one thing that really attracted me
in the museum's was one peripheral wall
where they had Picasso's paintings in
this particular wall what's special
about this is they didn't have a lot of
his paintings they had his masterpiece
on the far right side and everything to
the left where the prototypes he had
created for that masterpiece it was like
ah hard to see this because we have
always seen this masterpiece and we
celebrated but you can see these 16
other things he had drawn the four left
one doesn't even look anything like what
he wanted to really do along the way he
shapes his you know his thoughts and
then comes towards this masterpiece that
we all you know celebrate and the point
really is we need to really write the
code but we have to work on refactoring
it so my departing thought here is the
first step in becoming a better
programmer is to let go of the
conviction that we can code it once and
get it right on the first right and I
have the belief now that code is never
written it's always we written so it's
very important for us to get to
rewriting very quickly hope that was
useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>