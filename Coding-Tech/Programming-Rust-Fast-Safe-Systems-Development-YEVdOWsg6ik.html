<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Programming Rust: Fast, Safe Systems Development | Coder Coacher - Coaching Coders</title><meta content="Programming Rust: Fast, Safe Systems Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Programming Rust: Fast, Safe Systems Development</b></h2><h5 class="post__date">2018-04-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YEVdOWsg6ik" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">to start off I want to give you a bit of
an idea about what rust is and what rust
has to offer so the first thing you'll
find in rust is the fact that it has
very strong safety guarantees this is no
seg faults no data races and a very
expressive type system to kind of add on
to these safety guarantees with your own
extra logic with your own extra
validation and so this is kind of giving
you that sense of security that sense of
comfortableness you'll find from Java or
Ruby or JavaScript kind of these
languages that manage all this for you
and you very do you very rarely deal
with gdb or seg faults or weird
production things that are difficult to
debug but on the other side rust also
gives you this uncompromising
performance this performance you expect
from C and C++ and we do this by not
giving you a garbage collector there is
no runtime when you're writing Russ code
it's kind of at the lowest layer it's
kind of running directly on the machine
we generate machine code we generate
normal executables as you see in C and
C++ and so you're kind of putting these
both together which is giving us this
aspect of a confident productive
assistance programming language
now the system's s bacteria is very much
the C and C++ and very low-level but the
things to focus on are kind of this
confidence in this productiveness where
this confidence is stemming from this
lack of seg faults these lack of data
races kind of all these guarantees that
rust is giving you and then this
productiveness is not only kind of the
security you feel from this is now
enabling you to do so much more but
there's this active very active
community very active ecosystem and I'll
be talking a little bit more about that
later which is kind of adding the effect
of being very productive in rust and
it's kind of a core tenets of what we
focus on which is not just the language
but also how you feel when you're
working in the language it's spanning
all the way from your build system to
the actual when you're running code on
the machine so some people will kind of
listen to this and like oh I don't
really need safety it just seems like
eat your spinach it just seems like this
kind of chastising you and your mom
saying oh you should do that every
morning you should make sure you're safe
every morning but we like to think of
this not so much as the kind of
canonical eat your spinach for it's not
a great thing to think about but rather
this Popeye superpower where you eat
spinach and become super strong you have
this new superpower to work with and one
of the best ways that I find to
articulate this is through an actual
real story of discovering a bug in the
Russ compiler of the Ross compiler is
written in Russ but now getting that
later so I imagine you're kind of just
this generic program you have
there's a threat of computation where
some are lessons somewhere along the way
you'll kind of do some work and then
after that work is done you'll update
the shared data structure that's kind of
big right red rectangle with just some
data structure on the side you'll do
some more work and then you'll send some
more updates to that and finally you'll
kind of get some result and you'll print
print this out so this is kind of just a
general abstract program but eventually
you're like ok this is not actually fast
enough I want to shorten this run time
and I want to add some threads that's
kind of one of the easiest ways to make
my program faster so well add a separate
thread here and then to actually
communicate between this we're going to
be doing message passing so we do a tiny
bit of work we send this message to the
other thread which will actually do some
work and then one thing we've noticed is
that this data structure is now entirely
owned by this separate thread it's kind
of this nice well contained data
structure we'll do that again a couple
times will kind of X expand some more
work will share the load between these
two threads and overall we got this
great benefit by now when we actually
receive the result our run time has now
shortened and we have a much faster
program at this point and so this
actually happened in the compiler where
were you add two threads at some point
kind of shorten the execution here and
everything was great so now we have a
faster program we're using threads it's
safe everything works and we kind of
move along now so we come down the road
we're six months later we've forgot this
point we've forgotten we had threads
we've forgotten we had this internal
factor and all we know is our program is
fast and we want to add a feature to it
so we'll come here we have our current
program we have our message that we're
going to send and right now it's not
quite good enough so we have this struct
event which just has some data members
it currently has a key and a count or
just kind of some other various bits and
pieces but we want to add this field
called in turns string we kind of want
to add some more rich data to go across
these threads and this is when it gets
scary I don't know about you but the
scariest thing you can do as a
programmer is to read code you wrote six
months ago so what's actually happening
here is that we have this event that
we're trying to send across strings
native notably this in turn string field
and if we go deep enough and we actually
look at the internals of this in turn
string what we're gonna realize is that
internally there's this reference
counted string this RC of string type
and the notable thing about this is that
it's non atomically reference counted
which effectively means that if we were
to allow this we're now going to have a
data race we're now going to have double
freeze we're going to have
Crash's or it might not even crash it
all we're not really quite even sure
what would happen at that point and so
this is kind of a really embodying the
fact that you as a programmer forget
what you've done before you forgetting
the current architecture of the program
or you're brand new and you had no idea
that there were threads behind here and
so when you actually try and do this in
rust when you actually try and write
down this this intern string and then
send it across a thread but the rusts
compiler will immediately tell you this
type can not be sent across threads it
is not safe to send this across threads
and this program is rejected at compile
time and you can immediately start
working around this you can say oh well
I don't actually need to send an intern
string and it's not the length of it or
kind of some other aspect of that so
that's kind of a story of the safety
aspect of rust but I want to give you a
bit of an idea as well about the kind of
low-level zero-cost extractions we have
this is the kind of performance at the
CD c++ layer so one of the greatest ways
to show this in rust is this abstraction
of iterators which is somewhat different
than the c++ iterators are kind of a
little more specific to rust or so here
we have a list of certain we have a list
of integers we're gonna call this zip
function on the iterator so we'll take
two iterators and make one iterator of
pairs well then just take each one and
we'll multiply it together and the very
end will actually sum it all up so this
is pretty readable this is relatively
easy to kind of see we can kind of tack
on some more iterator up to adapters
here that we would like but the key
thing here is that rust is kind of
compiling all of this away when you
actually look at the exodus because x86
assembly generated you can see this nice
compact piece of code which is actually
even vector ax is this is using Cindy
instructions under the hood which you
didn't even explicitly asked for and so
this is kind of the elevator is what we
actually use as a back-end and has very
very advanced optimizations and so this
is showing how even though you're
writing kind of this high level very
closure based iterator base all these
extra abstractions they're all compiling
away and melting away to the kind of the
fastest machine code you would have
otherwise written by hand and not only
are we enabling you to actually have
kind of like in one compact code or one
compact piece you can have kind of
readable code for sequential Cindy based
execution but we can also just change
one line there from itter to par error
with some crates on in the ecosystem and
immediately now we have a multi-core
program which is in parallel on
Fred's using work-stealing using Cindi
guaranteeing thread safety in all these
aspects kind of like with one tiny
change and this is kind of the
expressive power of rust where we're
enabling you to have these very small
changes with zero cost overhead giving
you all these great benefits and at the
same time you don't have to worry about
data races you don't have to worry about
these site faults you don't have to
worry about kind of all these problems
you might other otherwise we were
running into if you didn't have total
knowledge of the entire program and so
the last thing I want to talk about here
was the the productive aspect and this
is probably best embodied with the
kraits i/o application and so this is a
website very similar to NPM JSTOR or Roo
gemstone org or papaya found like the
Python package index all this is where
you put rust libraries to publish and
for others to download as well so at
rust 1.0 with the original release of
the rust project we gave you a package
manager called cargo which is kind of
allowing you to very easily download
from others rust crates and publish your
own and so this is a very effective way
for growing that your SD code system and
for kind of immediately getting up and
running with whatever packages you need
for using HTTP for you having this
parallel iteration for whatever aspect
you need you'll probably find a crate on
crates i/o today all right that's kind
of a brief introduction to some of the
benefits some of the niceties and kind
of what you can expect from rust and so
now I'm going to talk a little bit more
about the language itself kind of how we
get this memory safety how we actually
build that up I'll show you another
feature of Ross called traits which is
kind of another aspect we start building
a lot of safety on show you a little bit
how that parallelism works and kind of
how it leverages these two things not
quite as much as in-depth as yesterday
and then finally talked a little bit
about this unsafe aspect how I'm saying
safe rust but it's a little there's an
asterisk next to it it's not quite it's
a little bit of a live but we'll see how
it doesn't matter too too much or I'll
explain it and then finally we'll talk
about the the community around rust
specifically rust and Firefox which
actually was exciting because it was
just released yesterday and then also
some of the community processes of kind
of how rust is developed and how we can
expect to see that all right to start
off let's let's dive into this memory
safety aspect and so this is where we're
going to be talking about not only are
we getting this zero cost abstractions
from rust but we're also getting this
memory safety and data race freedom and
kind of these is this is how we're
building up in this confident productive
systems programming and so
dive into both of these at the same time
to explain some of the pitfalls of how
they work or kind of how they could work
and then how they actually work in rust
so to start off let's talk about some
zero cost abstractions kind of what you
would expect from C++ so this is an
example written in C++ where we'll start
out with a vector strings on the stack
and we're just going to get a pointer to
it first thing we'll notice is that the
vector itself is stored directly inline
on the stack this data this length the
capacitor so those fields are stored
directly there no layers of indirection
or whatnot the actual values on the heap
are then stored sequentially as well we
have the first string the second string
the third string no extra stuff in there
and we'll notice that the strings
themselves are just then containers of
bytes and then recursively have data
length capacity and kind of just keeps
on going around and around
next up that will find that these
element pointers kind of these
lightweight references in C++ or just
raw pointers they're just kind of
straight pointers in memory there's no
extra metadata there's no extra layers
of abstraction here so it's kind of
pointing directly raw into memory and
the final thing we'll notice here about
this zero cosmas is this aspect of
deterministic destruction kind of where
when we exit this function we know
precisely that we can deallocate this
vector free all the memory behind it and
we don't have to worry about any
explicit free calls or leaking memory at
that point now so when I saw one memory
safety as well I also like to show this
with C++ this is very similar to the
example yesterday where we'll start here
again with our vector strings on the
stack we have our data or length on our
capacity and we'll start out by having a
pointer into that but then we're going
to come down here we're going to try and
push some data on to this vector we're
kind of pushed some extra pieces here
but the problem is that we might have to
reallocate this vector if this length is
equal to the capacity we make some new
data we update our data pointer and then
crucially we start forgetting this data
we start actually deallocating that we
start d allocating the previous chunk of
memory which then invalidates this
pointer we now have this dangling
pointer pointing into freed memory which
means once we actually come around so I
try and print it that's undefined
behavior we can get a seg fault we could
work and discover two year later we
could have effectively anything
happening at this point and so what I
like to do here is to dig into what was
actually happening and then why we
actually want to prevent how do we can
print this bug but also many other bugs
at the same time and so the first
ingredient we'll find here is this
aspect of aliasing where we have both
the vector pointer and the settlement
pointer a porn
the same piece of data but they didn't
really quite know about each other but
in isolation this is just fine it's only
when we add in this mutation when we
have this simultaneous act of updating
one of the pointers what we forgot to
update the other one as well
we just had mutation now the vector
vector itself was always internally
consistent and if we just had a liasing
everything nothing's actually changing
this was totally fine and so it's purely
when we have this simultaneous act of
both aliasing and mutation which is when
we start running into trouble and this
these two these two ingredients are not
just related to this bug but actually
most memory safety bugs start diving
into one of these two factors happening
at the same time so most of rust and all
the safety aspects I'm about to show you
are fundamentally driven at preventing
this preventing simultaneous aliasing
and mutation so we'll start by having
this kind of tabular category of kind of
classifying these two concepts in rust
called ownership and borrowing which
we'll be talking about a lot more detail
and we'll be seeing how the either allow
aliasing or they allow mutation but
never both and so the first thing we'll
be talking about is this ownership value
kind of this this own type where we'll
be seeing that it does allow mutation
it's a signified with the kind of this
bear type T and then has this ownership
passing and so ownership and rust is
very similar to the English word account
just the natural language word of
ownership where you yourself can own
some value so I personally own this book
I now have a copy of this and I can do
whatever I like to it notably if I have
this book I can actually decide to
transfer it to someone else so I can
kind of pass off my book to someone else
and now they are the owner of this book
I have relinquished ownership I can no
longer touch it I can no longer read it
I can't even modify it so let's take a
look at some code and kind of see how
this actually works in rest itself first
thing we'll do is we'll have this book
which we'll just say is a vector of
strings in the stack as well first thing
we'll notice is just like C++ rust will
store these fields directly on the stack
at this state of this length in the
capacity now we've also declared this
with this mute keyword which means that
we're allowing this kind of edit
permission we can actually modify this
book and we're allowed to kind of touch
that and do extra things with it so we
can actually come here and we can push
some pages on this book and now I have
some hey date on the heap saying oh we
got our first page of the book we're our
first string we have second page or a
book and we can yeah we can keep moving
from there
so now is when things get interesting
where we start saying alright we want to
publish our book now we're going to
transfer ownership from the main
function to the publish function you'll
see here on the right-hand side that
this vector there's no much sure of
fluff here there's no extra ampersands
or symbols or anything and so what that
means is the published function is
taking the book by value it's taking it
by ownership similarly on the collar
side we're not passing an extra fluff
here and so we're passed we're passing
this by value the main function is
relinquishing ownership it's passing
ownership of the book over the publish
function at runtime the way this is
implemented is we're gonna push the book
on the stack which kind of makes a copy
of each of each of its fuels locally
onto the stack for the published
function and then we're gonna forget
about the copy in the main function it
has past ownership so it no longer has
access to it and no longer can access
its fields it's kind of is now someone
else's problem at this point well come
over to the publish function and we'll
start executing and just like C++ before
once we get to the end we now know that
because publish is the sole owner of
this piece of data we can destroy it so
we can light the cell on fire and free
all the memory and kind of free all
resources associated with that this is
the deterministic destruction aspect of
rust end of C++ and I might be wondering
what happens if we try and republish our
book this is a move value at this point
so if we try to actually touch it again
this would be a use after free and so
what the compiler does is it gives you a
nice error saying this is a use after
move you are statically forbidden from
touching variables which have been moved
from using any value which has been
moved at that point and you can only
move it with your if you're actually
actually the original owner so this kind
of builds up a story for memory
management in rust which might seem like
it could be a little manual at first
where you have any value when you create
it you'll kind of you were the original
owner
now as the owner repeat of a piece of a
value you can actually move it to
someone else so you can assign it to a
new value you can pass it to a new
function and then when the final owner
actually returns you'll then free it all
so you can say this is the final owner
says no one else has references to this
and what kind of deal I get all that
well that was something I forgot to
mention which is again that mutation and
aliasing is what we're preventing and as
we're seeing with ownership we're
allowing mutation we do not have any
aliasing only we all know have one owner
at any one point in time the key thing
though is that most of this ends up
feeling invisible in rust
you actually explicitly create a
resource but then movement is just
assignment the allocation is just
forgetting about it and letting it go
out of scope you never actually do
anything manual here a lot of this is
kind of feels invisible and kind of just
ends up becoming very net very natural
in rust itself so the next thing I want
to talk about is the second pillar of
rust which is borrowing borrowing is
also very similar to kind of the natural
language phrase of this where you as the
owner of a piece of data can kind of
temporarily loan it out to someone else
but any point in time you can pull that
back you know you still have access to
the book you are still the owner of the
book and you can still then have
exclusive access at that point there are
two kinds of borrows but I'm going to
talk about each one in succession the
first one which is a shared reference
this is denoted with this ampersand
sigil out in front and one notice that
this will allow aliasing but it will not
allow mutation so start off let's have a
similar example from before where we
have our book on the stack we push some
pages onto it we're going to start here
with this ampersand so we have this
ampersand Veck on the right hand side
and we have this ampersand on the left
hand side as well or we're denoting that
the caller kind of the function public
is taking a borrowed reference to the
vector and I'm calling side we're also
creating a borrowed reference with this
ampersand here this is making this
function there this pointer P here now
one key aspect we were saying is that
this allows me Tate this allows aliasing
but not mutation oh sorry it's the the
pointer P here just like C++ is kind of
this lightweight reference just kind of
pointing directly on the stack just
pointing initially at the kind of data
member here but because I was saying we
allow aliasing and not mutation while we
have this shared reference we have lost
our edit permission we no longer can
actually mutate this book through the
original value so we'll come along here
well then call our published function
we'll push a new pointer on the stack as
the argument to this function which is
kind of as function book and this is
showing how we can have multiple aliases
at any one point in time this is kind of
we can create multiple shared references
and that's all fine we don't have to
reputation or anything like that I'll
come along to publish and when that
finishes we'll just pop the values back
off the stack and now we'll keep on
executing this will execute it or this
will actually compiling and continue
running so the interesting part here is
to kind of dig into some cases of where
this can go wrong and well and what is
actually disallowed while you have a
shared reference
here we have a book we have because we
declared it mutable we can actually
mutate it push some pages onto it do
whatever we like to them but here's when
we start it starts good interesting so
we're creating this bar oh we're having
this local variable called R which is a
shared reference to this book and what's
actually happening is this has a
lifetime associated with it so it's
valid for this kind of curly brace block
it's valid for this one block right here
so if we try to actually mutate the
original book the compiler will give us
an error saying we cannot mutate while
this book is borrowed so because there
is n active shared reference we cannot
mutate the original binding or mutate
through the shared reference as well so
if we try and actually mutate the
original shared reference that's also
disallowed saying the compiler cannot
access or you haven't do not have access
to this notably though when we do reach
the end of this block once we've reached
the final of the final instruction we
say that okay the scope now ends this R
has gone out of scope so the book is no
longer borrowed we kind of have this
scoped access where we know that there's
no no active borrows here meaning this
final call to push this is actually
allowed the book is not mutable again
there are no active borrows and as the
owner of the book you declared it
mutable and you can do whatever you want
to that so this is also a little bit of
asterisk where we say that you typically
can't mutate while your share and most
of rust is around preventing this
aliasing and this mutation at the same
time but those are some controlled
circumstances we do allow that but I
won't go into too much detail here
because it's a little a little bit more
of the advanced trust side of things so
the next thing I want to talk about is
we we saw shared references but now the
second kind of borrow and rust is a
mutable reference which as you might
imagine is allowing mutation but not
aliasing and we'll see was denoted with
this ampersand a mute so when the caller
side of things in this edit function
we're going to have this ampersand mute
Veck of string which says that I would
like a mutable reference and that would
like to be able to mutate that as well
similarly on the caller side we're going
to pass in an ampersand mute saying oh
you can't actually add this function you
can't actually then now have an
immutable reference so just like we
shared references a mutable reference at
one time is represented with just this
nice thin pointer just pointing directly
on the stack but like with shared
references we're going to kind of limit
our access in the original book variable
itself so with a share reference you
couldn't mutate it but also with a
mutable reference you can
mutate through the original binding so
the variable book here while the while
the mule reference is created is not
mutable but you can mutate through the
book itself so when we call the Edit
function we will actually be allowed to
call the push function which will give
us a second page of the book I mean once
we edit once we return again we have the
reference that has gone out of scope so
there are no active references and so
the state of the own value has actually
returned the original state which means
we have the Edit permission and we can
grab whatever borrows we like so we can
run this function again and actually
will successfully push a new 3/4 page on
to this book and now have a nice book to
work with so again I want to go into a
little bit more detail about how these
references are working and what's kind
of the the error cases are it's like
before we have a book we can push it
because we could declare it immutable
and here we declare a mutable reference
to this book and this is kind of the
starting point for which we are
gathering a mutable borrow on this book
now I'm saying that you are completely
disallowed access not only can you not
read it you cannot mutate it you can't
do anything to the original binding of
this book so this is going to be an
error saying that there is a mutable
reference active so you no longer have
access to this you no longer can
actually mutate the original binding or
even read it however we can mutate
through the Sharri binding as we saw
this will actually be allowed but we can
mutate the original book which will end
of go through our reference to actually
mutate the final value now again just
like shared references once this returns
or kind of goes out of the scope we know
that the lifetime here has fallen out of
scope which means that we actually can't
edit the book here at the very end we
can kind of do whatever we like and get
them or we can push more pages we can
take more shared references we could
take more mutable references kind of all
that good stuff so I've been kind of
saying this word lifetime here which I
want to kind of go in a little bit more
detail but what that actually is and it
turns out that the compiler is
automatically inferring a lifetime for
every borrow that you create both shared
and mutable and we this is kind of like
in this example at the very beginning of
when you first have this ampersand book
of 0 from that point on to the where
than the actual variable R goes out of
scope is the lifetime here that's kind
of had the lifetime the duration for
which that is valid
right now this is mostly syntactically
but you can kind of think of
this overtime as well kind of while this
code is executing that is the lifetime
of this reference and so we actually
give these things names it's kind of
this tick L which is just notation in
rust for this is a lifetime let's
typically find one letter name throw a
lowercase we can make them much longer
as well the compiler again is the one
that's actually inferring this so in
this case you can't actually name it you
can't write down tick L but it's kind of
what the compiler is doing internally is
figuring out some lifetime theory
figuring out some name and then
rationalizing that with all other shared
references or mutable references in your
program so and this is a case where you
can use lifetimes to start connecting
borrows together so we can say that this
same variable that's kind of the same
tick a is both on the input this vector
V and the output this reference to a
string and what that saying is that
given a borrowed contents or given
borrowed contents to a list of strings
I'm not going to give you a borrowed
content to the first string with the
same lifetime and so this is saying that
this will actually compile because the
these end up all having the same
lifetimes and everything remains
borrowed here as well look kind of this
derive from like we will derive your
reference from V to actually return this
it turns out that's a little wordy so we
don't actually require you to do that
all the time we have this thing called
lifetime elision in rust which basically
says that the first definition here and
the second one are exactly the same the
compiler will infer this one without
lifetimes is the exact same as the one
with lifetimes got if you had otherwise
written that so one of the great things
I always love to talk about with
lifetimes kind of the benefits of
lifetimes is in contrast with an example
of a C API so this is an API you'll find
in the Lib get to library which is a C
library written for managing git
repositories kind of like dealing with
git commits to histories merges as all I
could stuff and so the first thing we'll
notice here is we have okay let's try
and figure out what this memory
management story is we have a lot of
pointers going on here and we'll read
the documentation and it'll say that
okay what turns a tree entry that is
owned by the tree but you don't have to
free it and you just have to make sure
you stop using it before you freed the
tree and this is kind of this key aspect
of we didn't actually know how to use
this we didn't know if we passed in a
tree if we had to free that reference so
if we have to oh I don't know I still
don't know where file name is coming
from this lossy information kind of
sometimes as in documentation now this
not a a bad part about Liggett - look it
- is excellent has excellent
documentation but it's more of a
limitation of see where you have to go
out of your way to actually learn about
the lifetimes here to actually learn
about how you're supposed to free and
manage this memory high who supposed to
free this memory when you supposed to
stop using this memory where as in rust
you would typically have a signature
that looks like this we have this ticky
again which says that I am taking a
borrow of myself and I'm going to return
to you a borrowed entry which has the
same lifetime as myself and so notably
this is kind of implying all this
information that we had to read from see
so we're seeing that not only do we not
have to free the tree entry being
returned but the compiler will
automatically verify that I can't use
the tree entry beyond the lifetime of
the tree itself because it's borrowed
because you've borrowed you can't move
it you can't modify it you can't mutate
it but the other great thing about the
rust signature is it's actually more
expressive than the C signature or the C
documentation because we still have the
question about what is this file name is
are you storing this file name do I need
to reallocate it is this this this
declared as read-only but is there some
other alias in the program which is
being mutated we're not actually quite
sure what's happening is is are you
starting a thread do I need to keep it
actually alive for all that for much
longer when all of this information is
given for free in rust so we have here
this there's no lifetime annotation on
this ampersand ster so it's kind of this
anonymous lifetime that you can't work
with which notably means that it's
borrowed so no one can mutate it kind of
rust guarantees that while you have a
borrow no one will be modifying the
underlying contents you know that
because it's this anonymous lifetime or
I didn't name it it doesn't escape so
this function cannot store a reference
to this variable it cannot kind of
squirrel this away and you have to worry
about that later
and while it's running no one's want to
fly again kind of all that good stuff so
this is a great example of how these
questions you haven't see these
questions you have all these typical API
is where you have to really dig in the
documentation or sometimes read the
source code just to figure out what's
going on and rust you just get that by
reading the signature and just just by
looking at the signature you know
exactly what's going on
we know that it's either mutable or not
we know the life times of what's being
returned how to manage these resources
it's kind of just all they are given for
you automatically
all right that's enough about ownership
and borrowing and so on a transition now
to a second language feature which we
also use a lot for safety called traits
now traits and rust are very similar to
interfaces you'll find in languages like
Java or type classes in Haskell if
you're familiar with it it's basically a
group of function a little bit of
functionality that can be attached to a
type and so I want to show you an
example here of actually implementing a
trait for one of the standard types and
this is kind of actually a nice aspect
of rust which is you can create a trait
for yourself and then implement it for
existing types kind of like types in
standard library or integers or
primitives so we'll start out like
having this trait called clone and this
is actually the standard library but
we'll pretend that we have a nice local
copy of this that we're working with so
the traits themselves will be
implemented on particular types which
we'll see you in a second and this is
kind of the collection of functionality
wherein this trait will have one method
called clone it takes a reference to
myself which is the receiver of this of
this actual method call and then returns
this capital s self value which is
saying I will return a new version of
myself kind of the type this being this
is being implemented for it's this
placeholder so we take a look at this
effect type we've been looking at with
this is kind of the list of the girl
will list the girl with vectors you'll
find in rust and we'll start off by
saying okay well have we're implementing
this for vectors notably with this t :
clone here which is showing that for any
list which has cloneable items I can now
also clone that list and create a new
copy of it and this is typically when
you find traits like this they're kind
of implemented recursively where I'll
start on though I'll kind of implement
the treat for the outer type if all my
generic type parameters internally also
have them at that type so the first
thing we'll do in the civil notation is
we'll create a vector will kind of just
make a new vector on the stack well then
iterate over it with this for loop and
this Elden type will have just kind of a
pointer into the vector for each element
that we're iterating over well will
cursive Lee call the clone method which
we've given by this trait bound at the
top this kind of T colon clone means
that now this type is colorable so given
ampersand T we can create a new T and
then finally we'll actually return this
value at the very end so another thing
that's important to know about traits is
that they're not quite or they have them
so the different than C++ in the sense
the
check this definition only once so we're
type checking this as you wrote it and
kind of as you compile this one piece of
code will say that okay we know you can
actually call LM clone very importantly
because you gave it a clone bound
there's nothing else you can do with
that other than move the value around
and drop it that's pretty much it kind
of like basically let it go out of scope
differently or similarly to C++ though
we also have a mono more fiest aspect
here where for every time you call this
clone function you're going to create a
new copy in the machine code so if you
have a vector strings and call clone if
you have a vector of integers in call
clone those are two separate copies of
machine code kind of hand optimized for
just that one particular type so
naturally this gives us save it's kind
of that that zero cost performance kind
of as if you wrote it for just those
types but this of course has the similar
problems to C++ in terms of code bloat
if you write that too much and so
there's this some ways to work around
that and some knobs to tweak there but I
won't go too much into the into those
here so the other aspect of traits which
we tend to use are these things called
marker traits where a marker trait
doesn't actually have any functionality
inside of it it just kind of represents
a property of a type so here we have
this traits end and this trait copying
which in rust they mean that this is
safe to send across threads or it's safe
to mem copy it's kind of safe to just
create new versions of this all over the
place and I already talked about send in
terms of being safe and that RC type was
not safe but we will see that things
like strings things like integers these
are all safe to send across threads it's
totally fine the string type has is
backed by a heap allocation but it's
safe to allocate memory on one thread
and D allocated on the thread that's
that's kind of how about here's work we
also saw that our C of string because
it's not atomically reference counted is
not safe to send across threads so this
is this type will not be able over the
century and we'll say that we cannot
actually send this across threads so
earlier when we had this error coming
out of the compiler we know that there
was a function somewhere along the way
which actually dealt with sending data
across threads and that would say I only
work with types that if want send that
was the one point that says I need send
to actually send us across a thread and
so that's where this trait bound is
coming into play and kind of internally
once you have that rco string you'll get
forbidden at that point but we also have
this type called arc which stands for
atomic reference counting kind of the
dual of our see only the katana covers
this is indeed safe to send across
threads because the reference count has
managed atomically and then the
internals the actual string itself is
also thread safe it's it's fine to send
across threads so this mem copy aspect
is a little different than the send a
spectra it's kind of more of a property
of kind of what you can do in moving the
type and kind of how you create new
versions of it where integers is sort of
float so kind of these primitives are
just a bag of bits it's totally fine to
kind of create new versions of that and
kind of mem copy that all over the place
types like string though or RC of string
if we're creating a new version of this
that we actually need to run some code
if we're creating a new string we
actually need to make a new heap
allocation and kind of copy all the data
onto there if we're creating a new RC we
actually have to bump the reference
count I have to actually run some code
to do that and so this is where you
can't necessarily mem copy all types in
rust because that's kind of creating
multiple pieces of data that would be
aliasing kind of new owners but that's
kind of violating this aspect of no
aliasing when you have ownership which
only allows mutation alright that's a
little bit about traits and now I want
to talk about parallelism and kind of
how we're putting traits and borrowing
and all this together to build up these
parallelism aspects of rust and kind of
how we're freeing ourselves in these
data races and the key thing to know
about rust is that Russ did used to have
actually channels baked in the language
and kind of these various paradigms
baked directly in here but today in rust
all the concurrency and parallelism
libraries are external to the load
language kind of in the crates ecosystem
in the standard library itself and this
is how these are all built on these
fundamental tenets of ownership and
borrowing and leveraging these along
with traits for safety but and we're
only ever actually using these at the
library layer we can kind of define them
in rust itself we don't have to worry
about the language providing intrinsics
or promotive is necessary there for that
and so the key thing to know about data
races which we're kind of all about
preventing is it has these three
ingredients this sharing this mutation
and no ordering and two of these sounds
very familiar at this plant where rust
is all about preventing aliasing
preventing mutations were happening at
the same time and so for free we're
effectively getting no data races in
rust by hat by preventing both of these
from happening we're forbidding one of
these two ingredients from a data race
happening and so kind of we never have
any data races in rust and this is kind
of one of the things that kind of gives
you the sense of empowerment of
concurrent code and resting
how it almost always works in the first
try so when I go through a quick example
here of quicksort and kind of how you
want and a parallel quicksort in rest
using a crate called rayon and the
ecosystem so I'll kind of skip the base
cases but right so we have this bracket
which you haven't seen before and that's
a slice kind of a list this is a
borrowed reference to a slice of
integers so someone else own it's
someone else owns it but we know that we
have a chunk of memory that we can
actually mutate and kind of modify all
the internals of well skip the base
cases because that's kind of just - like
quicksort but the first time it gets
interesting is this split add mute where
if we take a look at a standard library
what this is going to do is give us two
halves we have this pivot which we're
gonna split the array on and we want to
make sure that we get two halves here
and kind of work on them in parallel
it's kind of our overall goal and
overall how quicksort is implemented if
we take a look at a standard library
this is the actual signature of the
split up mute function and so we'll
notice okay we have these lifetime
parameters we're kind of connecting the
lifetime of the first slice to the outer
two slices is kind of the left on the
right and we'll kind of make sure the
lifetimes are ending here so the vet it
self is transferring itself the back of
the lifetime of the vecas can be
transferred to the pair being returned
and then that lifetime is going to go
out of scope when the function actually
returns but one of the key aspects for
safety here is that we're transferring
this kind of we're transferring the
usability of this vet cut of this input
vector to these two sub slices because
we'll notice here if we actually had
access to Veck less and greater then we
now we have this aliasing they're all
mutable but the Veck is aliasing both
less and greater and so what's actually
happening here is that I know you're
effectively moving this value you are
moving the borrow the mutable reference
of Veck into the split-up mute function
which is then giving you back ownership
but in two halves can I give you to a
lien on a critical thing here is that
when we use this crate which is actually
going to do this in parallel and kind of
run these on two separate threads or
kind of an efficient aspect we know that
this is safe to do because both this
less and this greater are not aliasing
kind of although they are mutable
they're not actually aliasing and so
there's no possible data raise to come
up here because each of these recursive
calls to quicksort will kind of be
touching the internals but only in the
one contained slice that it has kind of
in two disjoint locations and
this joint function in the rayon crate
that's defined in the ecosystem it's not
in a standard library has various knobs
for kind of dealing with how you do a
thread pools and how you deal with work
stealing and whatnot but effectively
it's going to take these two closures
that's kind of this this like double bar
here up there is the closure syntax
saying we're not introducing a closure
in rust and so one closure is Q sort of
the less one closure is Q star on the
right I'll be executing these in
parallel and then waiting until they
actually both finished and so this
function will only return once the less
and the right have been sorted at this
point all right so the next thing we saw
on the rayon crate from earlier was this
parallel iterator aspect which is saying
that we can not only iterate a repair
iterate over a list sequentially but we
can also do it in parallel on a bunch of
threads at the same time now I noticed
that once we create a parallel iterator
it's giving us all these nice things we
saw before like with the zip this map
and this is some kind of all these
aspects just expect from a standard
iterator trade is also been given to you
by the rayon crate and kind of happening
all parallel at that point and the way
this is actually implemented is there's
this trait kind of representing all
parallel iterators which is very similar
to the iterator trade itself but it's
all built internally on this one join
function we have this kind of one
fundamental primitive which is kind of
doing both things in parallel but on
maybe on separate threads and so that's
that's the fact of what's happening here
is rayon is using this one primitive to
kind of build up all these extra
primitives and you'll see that this is
kind of a very common pattern in rust
well we kind of use one core primitive
to start building up all these extra
abstractions on top of it and so this is
not the same tables before we have kind
of concurrency paradigms here as opposed
to the aliasing mutation but you'll find
we've been talking about 4qn parallelism
which is kind of leveraging this
borrowing leveraging this aspect of
making sure the lifetimes work out to
have make sure you have disjoint slice
slices you're not using them after the
wrong time and kind of everything is
safe to send across threads and whatnot
but you find a bunch of other paradigms
which I was talking a lot about
yesterday as well such as message
passing locking lock free data
structures futures kind of all these
aspects which end up leveraging the
ownership and the borrowing and the
various traits here to kind of make sure
this all builds up into one nice usable
and safe package sorry the next last
thing about the language that I want to
talk about is
unsafe this is kind of the dark
underbelly of rust kind of how you
actually end up implementing a lot of
these aspects and so when we originally
created rest we wanted to make sure that
it was an extensible language that you
can kind of go outside of the language
we're not decreeing that you can only do
a particular kind of subset of
functionality but you can kind of do
whatever you like as long as it
eventually fits into a nice subset so
with the core languages we've been
seeing has ownership and borrowing and
libraries are also going to be adding
things like reference counting or files
or parallel execution and it's not clear
how we're gonna map reference counting
onto just ownership and borrowing I was
saying that we only allow either
aliasing or mutation but reference
counting is kind of this owned value but
also shared so it's both ownership and
kind of some aliasing going on there and
files are having to interoperate with
the OS threads the competitors even know
about and so I want to show you how
these are both implemented and then how
I end up making them safe a little bit
later on kind of how these will
internally be using the ownership and
borrowing at the outer layers but
internally they're using this thing
called unsafe and rust we have these
blocks called unsafe blocks which kind
of give you extra powers once you're
inside of them so the type checker is
still turned on you still have Baro
checking you still hot kind of all the
other safety checks in rust but you can
do a few extra things which are normally
very very unsafe to do and so the reason
that the safety and rust doesn't break
down and everything isn't terrible at
this point is that you're kind of
telling the compiler trust me I know
what I'm doing I'm actually putting this
in a safe interface I'm actually giving
you a safe abstraction on top of this
and that that's the one that's actually
gonna do some validation so for example
the split mute function we were looking
at that took this index and a slice to
kind of split the slice on what's
actually happening is that's asserting
that it's in actually in balance
actually within the range of that slice
and then after we've passed that assert
we now know that this is a valid actual
function call and then internally we're
gonna have to do some little unsafe
pieces to actually split that mutable
slice into two disjoint different slices
and so some of you might be thinking
well that all sounds great you can have
a nice safe interface whenever but what
if everyone just tries and uses unsafe
everywhere like what's actually stopping
you from using unsafe and then kind of
putting this unsafe boundary everywhere
in your codebase and so this is a tweet
by one of the servo developers this is a
web web browsers are written in rust
which did an analysis of the rest code
that was actually released today in
Firefox 57 and they found that their 35
percent of their code was indeed unsafe
which is actually quite worrisome so
when you actually look into it they have
about 70,000 code 70 thousand lines of
code they wrote and then 70 thousand
lines of code that's kind of mundane
talking to C++ generated code various
stuff that's kind of very
straightforward and the key thing to
notice here is that of the code they
actually wrote less than 2% was unsafe
and this is kind of showing off that
even in large code bases even in very
very large Russ code bases you have a
vanishingly small fraction of actually
unsafe pieces of code this greatly
limits the code that you need to audit
the code that you need to be very
careful about when you're editing it
kind of gives it a nice little container
and now talking to the actual system
talking to C++ talking to the OAS comp
talking to all suspects that is indeed
unsafe but it tends to be relatively
straightforward and verified via other
means and so this is you do have to
worry at that point but even this this
35 percent number is not as worrisome as
it I think as it originally looks and so
the last thing that I want to talk about
with unsafety is that the reason this
ends up not being a problem for everyone
is what kind of this aspect of layering
the sacrificed of building on existing
abstractions so when the rain crate we
saw we have parallel iterators and it
turns out that's all almost entirely
safe there's no one safe blocks anywhere
internally and that's all built entirely
on this joint function which itself is
safe and then we're just using a
standard ownership and borrowing and
never using the unsafe keyword anywhere
inside these iterators now join function
however does have this safe interface
and you cannot call it incorrectly we're
kind of you will always get a compile
time error otherwise it does have unsafe
internals to actually execute those two
closures on both on both threads and
kind of fork that out there and kind of
make sure that it doesn't return until
both of them have actually finished
that's a little bit unsafe and we have
you have to have some unsafe blocks to
actually delegate that out and finally
the literal thread pool which is running
all these closures that have borrows all
over the place and have to be scheduled
just right that's almost entirely unsafe
but we can see here that the kind of
this body of code is getting smaller and
smaller and so the thread pool is where
focus all your attention in terms of
reviewing and auditing and looking very
closely when you modify and kind of is a
warning for new contributors a warning
for someone just coming in you've got to
be really careful looking at this and
kind of have some extra scrutiny later
on oh and the final thing I'd like to
talk about is the cross being crepe
which is another crate on crates io4
kind of dealing with concurrent data
structures kind of giving you this
scheme for luck kind of like GC but not
quite for for writing some data
structures and rust and it's quoted as
being partially safe or almost safe
where it has this one API that is indeed
unsafe but the reason it's not it's
actually used quite a bit and it doesn't
all just fall down and have no safety
guarantees at all is that it's clearly
documented why it's unsafe you clearly
know what the criterion are to actually
make this safe how do I actually call
this function and make it safe and so
this is very similar to C and C++ where
in theory every function is documented
with how to actually make it safe but in
rust you tend to also have because
unsafe is used so rarely you have very
clear contracts here you're saying oh we
have to make sure to call this function
at the right time or you can't call this
function before you call this function
and then it's relatively easy to
actually adhere to those guidelines and
actually productively use crates like
crossbeam yeah the library wind of
handing a lot of the extra extra stuff
for us sorry that's a little bit about
rust and a little bit about the kind of
parallelism and trade aspects before I
go on does anyone have any questions
yeah I'm going to repeat it so it's fine
right so the question is kind of how do
we do with control flow branches and
ownership so if you have an if statement
a new initial eyes it on one what
happens on the other and stuff like that
and the answer is that what we do
actually have control flow analysis and
all this and so if you have a local
variable and you initialize it and one
branch of an if you still can't use that
local variable afterwards if you didn't
initialize it any other branch and so
every single path of code has to have an
initialized value has to actually
initialize that and continue using that
at that point and similarly if you move
on one branch of an if so I have a local
vary and I say like if something move it
else blah blah you can't use it after
the if because it may have been moved
and so you can no longer have access to
that so it's one we're like the
effectively you will statically make
sure that on certain branches you can or
cannot be using these these these own
values so to to reword this kind of like
if you have an existing structure and
then you modify some fields what
prevents it from to still be working at
that point or it may be switches from
copy to not copy right so the question
is can you implement copy for string for
example or some type that cannot be
copied and that's an answer's no the
copy trade is a little bit special in
rust where there is an assertion saying
that if you're an aggregate like a thing
that has two strings in it then you
cannot implement copy for that because
the strings themselves do not even want
copy so you have a compiler verified
implementation saying oh I cannot copy
this because there are some fields that
can't be copied and kind of if it were
only integers internally then you could
actually point copy that's actually
valid to do at that point yeah and your
question ah sounds excellent all right
so I'll have some more time with you
again but I want to get to this as well
so I'll well we'll get to this so the
next thing I want to talk about is a bit
of a success story for rust which
actually culminated literally today with
Firefox 57 being shipped and so this was
kind of rust being shipped in a
production code base
giant C and C++ code base and so the the
problem here stems from this fact that
we have this giant style system which if
you don't know much about this I also
don't know much about this but in any
case we have this kind of this is what
the browser is doing kind your web
browser when you download web page
you'll kind of parse the HTML page
you'll make this giant tree if you have
your HTML node your body node your div
know it's kind of everything internally
and what's going to happen is that the
read this the browser now needs to have
compute some list of styles for every
single node here so every single one of
these nodes is going to need this kind
of computed styles of how big is this
what color is this how much how much
padding do I have my margin and this is
kind of the CSS aspect where what we're
gonna be doing is kind of filling in
this giant table for every single node
but to actually calculate this value
we're gonna be traveling traveling up
the trees so if I don't list what my
color is than my parent might list that
or my eye will inherit that from their
parent it kind of like traveling all the
trees to actually calculate every single
one of these application or every single
one of these properties but the key
thing here is that this is kind of
inherently what you have to do but
there's no reason that this needs to be
done sequentially this is actually
relatively parallel but kind of have
this left-hand side of the tree and this
right-hand side at a tree here kind of
tons of leaves the very bottom and
there's no reason for that to all be
done on one thread so I have a bugs like
this in which I showed yesterday and
started off with with which is we need
to parallelize CSS selector matching and
this was opened seven years ago this bug
opened on a C++ code base just kind of
sat there saying we have all these
performance gains to get but we can't
actually quite do that because it's I
don't know I'm sure many of you I'm sure
is aware it's very very difficult to add
threads to a C++ code base to actually
go and retro actively make sure that you
don't have seg faults you don't have
databases you free everything correctly
and all that but what rust really did is
it kind of they were using that
superpower they were using that extra
spinach that Popeye spinach then getting
these nice graphs saying that we now
have a parallel CSS rendering engine
written in rust and it's all kind of
using all the cores you have available
and we're immediately getting these
great speed ups on certain websites so
we have the page layout aspect is
actually decreased quite dramatically in
some cases and kind of is only limited
by on those law at this point now
internally we have a bunch of other
stuff to optimize to get your page
rendering time
literally zero but that'll take a while
so this is kind of a great example of
how this actually shipped today like
literally today and is now available in
Firefox in production and as an example
of taking rust into an existing C and
C++ code base kind of that whole idea of
gradual adoption kind of like you don't
have to rewrite overnight and rust you
can kind of get the benefits in a very
localized fashion so this is one of the
cartoons which has been using to
describe this aspect of what we call
quantum which is kind of this release of
Firefox right now and you'll notice that
two of these components are currently
written or being written in rust the
kind of this CSS engine engine we were
talking about
and soon the renderer kind of what
actually puts bytes on the earth sorry
pixels on the page and touches the GPU
and all that is going to be written in
rust and kind of taking advantage of
that parallelism aspect in using all
those safety guarantees but at the same
time all the extra stuff being written
in Firefox kind of these new components
are also being rewritten in C++ or
freshly written in C++ and all these
aspects of the system are kind of inter
operating together and kind of working
seamlessly together and this is kind of
where rust as a systems language works
very well and embedding into existing
applications there's no runtime you
don't have to worry about a garbage
collector and all that aspect so the
last thing I want to talk about before I
get to a few more questions is the
community aspect of rusting how this is
one which is easy to overlook but ends
up being one of the most important
aspects of rusting have the most
important ways of how we have gotten to
where we are today and the first thing
you'll notice about the rust communities
it's incredibly open and welcoming this
is an excellent author Julie Evans who
had a blog post where she was talking
about how she just wanted to kind of
play around with some kernel aspects in
rosslyn kind of she wants to write a
keyboard driver and it turns out that
the pound rust IRC channel that was
already tons of people even though it's
going like tangentially related to rust
we're there and ready to help her room
and this is kind of not only Russ
questions but kind of any various coding
related questions to find this very open
and inclusive and welcoming community
you'll find on IRC channels on forums on
our subreddit kind of all these places
you if you feel the sense of rust and it
kind of makes you feel comfortable at
least in kind of in terms of working
with rust and working in the community
and kind of feeling a part of all feel
it feel like being a part of all that
and the other thing we thought we have
right now is we're
we kind of did this planning process at
the end of 2016 and created this 2017
roadmap for rust which is kind of
mapping out the community's goals for
where we want rust to go in 2017 what
are the high line items that we have to
finish by the end of 2017 and during the
last three months here we kind of deal
out planning the first nine months the
last three months of this year we've
created this ample period this idea that
we're kind of splitting up into 40
different teams across the ecosystem and
these are all kind of working
independently on various aspects of this
roadmap kind of all the same time
working towards the same goal which is
the 2017 roadmap in rust and so this is
a great embodiment of how community
participation and kind of engaging the
community and leveraging the resources
we have in the entire Russ community is
a core tenant of rust and something that
we're constantly trying to capitalize on
and so if you if you're someone who's
getting your students this is actually a
perfect time to jump in and to actually
kind of work with rust and kind of see
what's going on and to start
contributing to the compiler or the
libraries the ecosystem kind of all of
these various aspects have some working
group related to them and the last thing
I want to talk about is the RFC process
and this is kind of the process by which
we actually change rust RFC here stands
for request for comment and as a way
through which people can actually
propose changes to the language now this
is not only kind of contributors but we
as Corp team members or we as members of
the project we also grew to go through
this process this is the only way by
which you can actually change the rust
language is proposing an RFC and one of
the great examples of this is these two
rfcs were actually proposed by a
community contributor or we took a look
at these from like means we don't need
those we have we have all the stuff and
it can work around different our
competitor or very otic functions
there's no need for that we're going to
do that later but the community here
ended up convincing us that this
actually is very high priority and we do
actually need to tackle these kinds of
problems and so these are two RFC's
which we have since merged and actually
implemented in stabilize unions and
purely driven by the community and
purely driven and brought to our
attention and kind of and went through
like that
alright that's all I have for rust
there's a couple of links here the book
is kind of one of the best places to get
started if you're brand new to rust we
have forums that uses our bustling the
door we have a couple of IRC channels as
well
and some the into rust comm is also some
videos if you want to see some more
introductory videos in rust or a similar
to this talk but also some more in-depth
talks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>