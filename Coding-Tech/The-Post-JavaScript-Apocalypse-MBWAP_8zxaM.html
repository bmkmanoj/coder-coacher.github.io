<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Post JavaScript Apocalypse | Coder Coacher - Coaching Coders</title><meta content="The Post JavaScript Apocalypse - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Post JavaScript Apocalypse</b></h2><h5 class="post__date">2018-01-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MBWAP_8zxaM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and it's time now for the post
JavaScript apocalypse
so I think a lot about what happens
after JavaScript no JavaScript
unexpectedly has become the most
important programming language in the
world nobody expected that nobody wanted
that it just happened and so javascript
is everywhere right it's the language of
the browser it's now taking over the
server's it's getting into embedded
systems it's getting it's everywhere and
I've been thinking about how we're gonna
get rid of it you know what what's gonna
happen next because if it turns out that
javascript is the last programming
language that would be really sad we
need to do better than that for the kids
right we can't we can't leave with
JavaScript here kids that doesn't make
any sense
right so there's gonna have to be a
language that comes after JavaScript and
I spent a lot of time thinking about
what that's going to be now there are
some experts who are upset at the title
of this talk they think it should be the
put JavaScript apocalypse and there are
other experts who say no no you're an
idiot
it's the patched JavaScript apocalypse
in this confusion between post put and
patch is due to HTTP the hypertext
transport protocol it contains three
methods or three commands for moving a
document from one end of the network to
the other which are almost identical
that they all kind of do the same thing
but there are a few edge cases or corner
cases where they do something different
but it's really confusing to use them
because it's not clear what those
special conditions are and there are
some authorities who say that if you use
the wrong one at the wrong time disaster
can occur I don't know if that's true
but it sounds pretty scurrying maybe we
should pay attention to that so it seems
to me that in a well-designed system it
should be obvious what the right thing
to do is and so we don't have to have
discussions and arguments and write
essays about what the right one to use
is there should be just one and not
three and then it'll be clear what we do
so having this extra stuff I perceive as
clutter and having clutter in our
systems makes our systems more difficult
to use more differ
to learn makes it more difficult for us
to work together well and so I'm in
thinking about the next language I'm
also thinking about how do we get the
clutter out of our languages so that we
can be more effective you know because
we often think of life as the
accumulation of stuff you know you live
you work you make money and you buy
stuff and so you're accumulating stuff
and you think of the value of your stuff
as the cost of acquisition or maybe the
cost of replacement but that's not
really the value to it and it turns out
if you accumulate enough stuff your
stuff starts to have negative value that
you can't find the stuff you really want
because it's hidden behind something
that you don't care about at the moment
and sometimes you've got stuff which is
destroying other stuff because it's on
top of it and the weight of it's
crushing that are it's leaking on to it
and so it's actually itself not very
valuable but it's destroying the value
of the stuff which maybe you do value
and so eventually you get too much stuff
and you should get rid of it because
some of this stuff has negative value
and you want to you know put it on eBay
or recycle it or gifted or something
that there may be a better way of having
it provide value to the world than by
holding it on yourself so thinking about
how we remove clutter from our
programming languages and how we remove
clutter from our lives you know is there
anything we can learn from that process
and it turns out the world's greatest
authority on this is Marie Kondo
or Kumari she's a brilliant Japanese
woman who's the world's greatest expert
on organizing households she's
authoritative on how to put things away
and how to organize and how to fold and
stack and all that stuff she is really
good at this and she has this amazing
practice in which she helps people to
shed their stuff and what she teaches is
that you go into a room and you take
everything out of the drawers off the
shelves of the closets and you put it in
the middle of the floor and then you
pick up each item and you ask it a
question in Japanese you could ask
tokima coo deska which means are you
throbbing do you vibrate yeah and that's
the thing you know communicating to you
telling you that yes I have value saved
me
you know don't put me on eBay you need
to keep me but when she teaches in
English she doesn't say throb or vibrate
because people giggle like that guy so
instead she says does it spark joy which
is just lovely
yeah and that lovely you know does it
spark joy you hold it up if it sparks
joy then that means it's meaningful to
you you want to keep it if it doesn't
spark joy then why do you even have it
you should probably get rid of it and I
would like to apply that disciplined
programming except it doesn't work
because every work we're hoarders
basically in our programming systems we
love the clutter everything sparks joy
so we have no practice at getting rid of
this stuff so I want to take us through
an exercise in which we'll look at some
things and try to determine is this
really necessary and can we get rid of
it because unless we approach it in a
particular way we'll never understand it
so we'll start with a ski the American
Standard Code for information get her
changed this was an early standard for
connecting Telegraph's together and
eventually became the standard character
set for programming languages and in
computers it still survives today is the
first hundred twenty-eight characters of
the Unicode and it's brilliant
it was a really important step forward
it contains two characters that were
adopted from the mechanical typewriter
if you remember the old style you know
you push a button and he goes up there
are two codes that were inspired by that
typewriter the tab character and the
space character and the tab of the space
character was inspired by the space bar
you press the space bar and
would release a ratchet which would
allow the carriage to move one character
position and the tab button was inspired
by the tabulate button on the typewriter
which would release the carriage and
allow to swing freely until it was
halted by a mechanical obstruction
called a tab stop the purpose for the
tab key was to make it easier to enter
columns of numbers or tables of numbers
and these two characters survived today
and unfortunately the specification of
the tab character in ASCII didn't
provide any way of indicating what a tab
stop was and there was no suggestion for
what a default tab spacing would be and
so we argue about it because there is no
standard and we even argue about should
we have them at all and it's a thing
that goes on and on and on and it wastes
a huge amount of time and provides no
value so who's seen Silicon Valley there
should be more hands going up so
everybody by HBO right don't steal it I
do you still cable here I don't know if
that's a thing but where I come from
they steal cable but you shouldn't do
that you should be buying HBO because
HBO deserves to be compensated for
making the best programme ever about
programming it's about the adventures of
Richard Hendricks who was a brilliant
programmer living in Silicon Valley and
his adventures in trying to start a
software company and he's a guy who
works really hard he's spending all of
his time writing software in trying to
start his company doesn't have time to
find a girlfriend you you probably know
the type or are the type
but in season three he finally finds
someone and she's great she is smart and
she's nice and she's a programmer and
she seems to like him for some reason
but she uses spaces instead of tabs
and Richard Kemp it turns out that his
affection for an invisible control
character is deeper than anything he
could ever feel for another human being
so he destroys the relationship over
tabs so looking at all the human misery
that tab in space that that conflict
creates and it turns out there's no
value in it there are people who don't
use tab who manage to do stuff
successfully so we have a large amount
of evidence which shows that the tab is
unnecessary and does it add enough value
to justify all of the misery that it
causes and I think objectively it
doesn't so I propose that from this
point on no more tabs tab so don't
misunderstand this the argument is not
which way is better
the argument is which one can we get rid
of and we can't get rid of space so the
one that has to go is tab tab does not
spark joy
a ski had two characters for quoting and
JavaScript and other languages used them
both JavaScript uses them
interchangeably so you can use single
quotes to wrap a string or double quotes
to wrap a string either works and for a
long time I tried to make sense out of
that so I tried to develop rules for in
these situations you use that one in
other situations use that one but I saw
other people had different sets of rules
and their rules seemed to make as much
sense as mine did and so there's all
this clutter in two different ways of
doing things no value for having two
different ways of doing things so I
recommend that we get rid of one of them
and the one we should get rid of is the
single quote because it is overloaded it
is also used as the apostrophe so if we
stop using it as a single quote then we
can just say it's the apostrophe
everything is cleaner and less cluttered
that's good any s6 JavaScript got a let
statement which is similar to the VAR
statement except it respects block scope
and so I've seen people trying to figure
out when to use lat and when to use var
and trying to use them together at the
same time which doesn't make any sense
we should just use one of them so the
one I proposed that we use is let let
has the advantage that it doesn't
confuse the GABAA Java guys so much so
we should stop using var and we should
use that unless you have to support ie6
because it's a syntax error there is
seven or ie8 ie9 or IE ten ten but let's
just stop doing IE what would you say
Edge's pretty good and all the other
browsers are great so let's just stop
doing i'il
entering that Explorer does not spark
joy so we get rid of the VAR statement
es6 also introduced the constant which
is similar to that except you can't
assign to that variable that's even
better given a choice I'd rather use
Const than let so JavaScript has to
bottom values let are null and undefined
now there's an argument among language
designers should a language have any
bottom values but there's nobody who
thinks you should have two of them the
JavaScript has these two bottom values
and it doesn't make any sense
so I recommend get rid of one of them we
shouldn't use both of them and usually
if there's a choice between a longer
thing and a shorter thing I'll take the
shorter thing but this time I'm going
with the longer thing I'm saying we
should get rid of null as it's currently
practiced in JavaScript because typeof
null is broken anyway so let's just stop
doing null and do everything with
undefined now the idea of null as a
special kind of pointer as a feature of
a programming language was due to Tony
Hoare a brilliant British programmer who
has since recognized that the null
pointer was a billion dollar mistake and
he came to that by totaling the cost of
all null pointer exceptions and he
figures he's at least into billions now
so the idea of a special kind of pointer
to know a pointer to nowhere doesn't
make sense but a special object
representing something which is not
something else is an important idea and
I think that's what we should have so in
the next language I think we should have
null as an immutable empty object and
it's possible to make such a thing today
in JavaScript so null would be a Const
meaning you can't assign to null and it
is an object which contains nothing
which inherits nothing which is
immutable
and that's how you would write that in
es6 the thing that we can't do in es6
right now is if you try to extract
something from that object it should
return null itself it shouldn't return
undefined as it does now if we had such
a thing then you could have a long
dotted expression food apart up blah
blah blah blah if anything along that
line doesn't resolve to an object
instead of throwing an exception you'll
just get null at the end which is what
it should have always done so I'd like
to see that in the next language there's
a lot of talk today about pure
functional programming functional
programming is after a long long delay
is suddenly becoming really important
and it's because functions are the key
to solving a lot of our most important
problems then there's this idea of going
even further of adopting some of the
conventions of mathematical functions
mathematical functions are quite
different than software functions
because they're not about computation
they're about mapping of one set of
values to another set and there are
interesting properties of such functions
for example a given input will always
yield exactly the same output that's not
generally true of software functions but
it is true of mathematical functions the
idea is let's write software functions
that have the same property it also
means that functions can have caused no
mutation can cause no side effects the
only thing they do is return values so
why would we want this well it turns out
you get some interesting things one is
greatly improved testability because if
you can demonstrate that given a certain
input a function will always return that
output you don't have to test it again
you don't have to worry about what else
is happening in the environment which
could cause this thing to eventually
fail that can't happen if your functions
are pure you get composability it turns
out pure functions can be composed in
really interesting ways and that
provides a much more effective way of
doing higher-order programming and maybe
the best advantage is you get
parallelism because if you're trying to
make things go faster in multiple core
with multiple threads with shared memory
bad things happen called races and
deadlocks but if your functions are pure
they do not read modify write because
they're not causing mutation which means
that they don't cause races and they
never need to synchronize they don't
block and so everything can be running
full speed everywhere and so we can
potentially get the fastest possible
programs from such a model so it turns
out we can turn JavaScript into a pure
functional language simply by removing
the impurities that we don't even need
to change the standard to do that we can
do that ourselves we can use a pure
subset of JavaScript and just program in
that we just have to remove some things
for example we have to remove the date
function because every time you call the
date function you get a new date which
is a different time than any a date that
came before that's not pure so we have
to get rid of that
similarly math dot random every time you
call random you get a different random
number that's not pure so that's got to
go we have to get rid of the delete
operator because it will mute or modify
an object and we can't cause mutation
anymore object dot - saw a sign and
other object methods which similarly
would change the content of an object we
have to get rid of those array dot
splice and all of the other methods that
modify an array we can't use those
either array dot sort could have been a
pure function
had it been designed properly it would
have returned a new array which was like
the original array except sorted but it
doesn't do that it sorts in place its
mutating that has to go regular
expression exact function it keeps some
state so that's got to go
assignment you can't use assignment
anymore that's actually good because we
can get the Equality operator back we
should never have use the equal sign for
assignment so since we're not assigning
that becomes free we have to get rid of
the VAR statement because we're not
gonna have variables because you mutate
variables and we're not going to
mutation we're gonna get rid of let as
well we can keep Const constants
actually okay so you can because you
only assign to something once so it's
not causing a mutation you have to get
rid of the four statement because it
wants to be modifying an induction
variable and we don't modify things
anymore
users it turns out every time you talk
to a user they're gonna tell you
something different users are not pure
so they have to go and the network every
time you talk to the network it's liable
to tell you something else so there's no
purity there as well
so the difficulty with doing pure
functional programming is that well if
all you're doing is computation then
it's great it's brilliant it works
really well but if your programs have to
interact with the universe in any way it
becomes really difficult because the
universe is mutating and if it's going
to interact in any way with the universe
you need to mutate so I recommend a
style in which you're as pure as much as
you can try to get as much of your
system into pure functions because then
you get the performance and the
testability and all of that but you're
still going to need mutation for dealing
with the universe you know an account
balance cannot be a constant right we
need to to deal with that somehow ef6
added a feature called generators which
i think was a mistake
it's weird syntax and and it really
changes the way that the language works
and I think an unproductive way and more
than that is completely unnecessary so
it was like a gift that was being
offered to us but I recommend you don't
want to hoard that just pass it on that
what you really need is just to
understand how in JavaScript we can have
one function that returns another
function so here's a pattern for a
generator we start with a factory
function which is the thing that will
return a generator function and it will
initialize the generator and provided
state variables then we'll return a
generator function
and each time the generator function
gets called it will compute the next
value and update the strip state
variables and return the value so it's a
really simple thing just a function that
returns a function so here's an example
this is the element function the element
function takes an array and returns a
generator which will return each element
of the array that's a useful thing to
have in certain compositional patterns
and it's it's really straightforward
and it doesn't need loops really nice
callbacks have become a really important
feature of our languages because they
are the primitive mechanism by which we
deal with a synchronicity and a
synchronicity is really important
because the universe is asynchronous and
so being able to deal with that is
important and it turns out there are two
ways you can specify a callback in a
calling sequence you can have it be the
first argument the function that will
return the result of or receive the
result of the computation or it could be
the last one and JavaScript didn't care
so you could do it first to do it last
so some people would do it first some
people would do it last and then they'd
argue about it you know who's right
who's wrong and for a long time we had
no way of resolving this argument and
it's a problem in having these two
conventions because it makes it
difficult to have systems work together
so it turns out though es6 teaches us
finally what the right answer is and
that is the callback argument should be
first and the reason is we can now have
functions with a variable number of
arguments using the ellipsis operator
and the ellipsis has to come at the end
so that means the callback has to be
first
so anybody is putting them at the wrong
end you're on notice you got some code
to fix one of the places where we get
really emotional about our languages is
in the syntax syntax is all about
fashion it's not about functionality but
we get really upset about syntax we love
the syntax we're completely irrational
about sin
so let me show you a little bit of
syntax through the ages
we'll start with Fortran for this was my
first language Fortran was developed
before lowercase was discovered
the Fortran had an interesting parsing
rule in that spaces were not significant
so the compiler effectively deletes all
the spaces before it starts parsing so
in order to distinguish a variable
called Aoife versus if a in required
parentheses around the condition so it
could break those things and Fortran
made the mistake it wasn't the first
language to make this mistake but it was
an influential one of using the Equality
symbol to mean assignment and because it
did that it came up with this wacky got
equ dot thing to do equality BCPL was
the first good parts language it was the
good parts of a bigger language called
Cpl and BCPL was this really small
elegant portable wonderful brilliant
little language it was the first
curly-brace language and this is its if
statement I think it's a pretty
nice-looking if statement and it got a
lot of things right for example it's
using the equal sign for equality which
is it gets big points for that the
parentheses around the condition are now
optional and the curly braces around the
consequence are now required which is
exactly right it got that exactly right
and it used the pascal assignment
operator for assignment which is okay
BCPL was the model for b unfortunately b
went backwards and adopted the Fortran
conventions so today when we look at
JavaScript we see that the parentheses
around the condition are now required
again and the curly braces around the
consequence are now optional which is
awful so I recommend you should always
put the curly braces in on every if and
every else every time no matter what
because it makes your code more agile it
means that it's more likely that someone
else including future you might come
along someday and
this code even better without stumbling
over an unnecessary error I hear from
people all the time we don't I can't you
have to go just do it I just put the
curly braces in for crying out loud so
you've probably heard of El Valle 60
Algol 60 was the best language designed
by committee in history maybe the only
good language design by committee in
history they advanced the state of the
art tremendously it was a great piece of
work and it was so successful they
thought let's do it again so a few years
later they convened another committee of
very bright people and they developed
Algol 68 Algol 68 is huge and messy and
weird and didn't work out very well but
I really liked their if statement there
there was an elegance that they came up
with in the if statement which i think
is quite attractive so they got rid of
the block so the curly braces the
beginning and all of the blocks are gone
instead they've got balanced pairs of
letters so they've got if to start the
thing and fight to end it and the nice
thing about that is that you could be
looking at a piece of program and we use
end curly brace to mean the end of an
object literal the end of a function the
end of a block and so scanning down the
page you're seeing a lot of curly braces
and it's hard to know what does that
match up with and if a bunch of them are
Phi's instead then parsing the program
mentally becomes much much easier we buy
a lot of legibility in our programs
which i think is a very valuable thing
but I think we can improve on this a
little bit more so here's a suggestion
something that we might see in the next
language we take advantage of what we've
learned from Python to make whitespace
significant so we require a line break
after the condition and that means we
can now get rid of the then we can get
rid of the semicolon we're getting kind
of minimal there was a brilliant
language called rebel which used the
as the assignment statement which I
think looks really really nice so maybe
we can get down to that just a
suggestion so um what language is this
any guesses anyone Java yeah obviously
right who else would write crap like
that so what this is is it's a it's not
a language feature it's a symptom and
it's a symptom of problems in the type
system of the language so for example
Java originally did not have functions
so instead it needed finally because
there are lots of ways of moving through
this code and they wanted some place of
putting clean up code that they only had
to specify at once and the correct way
to do that would be to write a function
and then you could call the function
from all those places but they didn't
have functions that was a major error in
the design of Java so instead they have
this finally thing which is strange and
weird and it turns out ultimately is
unnecessary if you look at how finally
is implemented in the JVM they
introduced a call return a pair of codes
just for finally then there are all
these catch clauses so why are there so
many catch clauses it's because often
there are multiple things that a
function might want to return there's
the normal thing but sometimes you want
to signal and that's all folks we
reached the end of it or here's
something that's a little out of the
ordinary but you know that had to happen
and the java type system didn't allow
for all of those other things it only
allows one type of object to be returned
but there are other things which
normally need to be returned also so
they overloaded the exception system to
do that so they're using the exception
system as a workaround for the type
system since the type system doesn't
allow you to do the correct thing
instead we
take normal things and call them
exceptions which is a problem because
they're not exceptions they're things
that happen all the time
exceptions should only be that for the
things that never happen so as a result
of that we get very very complicated
control flows where some other piece of
software someplace else is determining
which of these things going to execute
this is the thing this most reminds me
of is the Fortran assigned to go to in
Fortran you could put a line number in a
variable and say go to that variable and
end up someplace and that's what this is
like
so in well written JavaScript we don't
do this instead in JavaScript we'll try
something if it doesn't work then we'll
try something else and then we'll clean
up if we have to so we don't even care
why it failed the children have failed
so it didn't matter but it did so we
have to do something but that's it so we
don't need to have all these complicated
control flows because we can have
functions return all of the things that
are meaningful for that function to
return but as a result of Java having
this broken type system we get
weirdnesses in some of the api's for
example the index of method where you
search for a substring in a string and
if you find it you return the position
at which you found it and if it fails it
returns minus one which is at least
confusing because minus one is an INT
and so if you want to take this result
and put it into a computation it could
go really bad and there's no warning
there's no exception there's no nothing
so the type system supposed to be
preventing errors it's actually inviting
errors in this case and javascript did
not need to repeat this error but it did
JavaScript had a say a better type
system so it could have returned null
and undefined if you tried to search for
something and it wasn't there and then
if you tried to add with it then it'll
be much easier to detect
so um here's a problem you're gonna add
to int 32 s together what is the type of
the Sun any guesses in 32 Oh close it's
in 233 though the correct answer is in
33 because it turns out if you add 2 and
32 s and if they're big the result is
going to overflow if you try to put it
in 32 and so you need an F 33 to contain
that result let's try another one in 32
times into 32
what's this type any guesses I in 64
close it's in 63 but close but you are
much closer than Java Java said it's in
32 which is wildly off so can the the
theory in these type systems is that the
types are protecting us from errors but
in in this case the types are actually
inducing errors that there are things
that can go horribly wrong in our
program which the types are not
preventing which are actually causing
but there's an even bigger problem so
0.1 plus 0.2 equal to 0.3 is false which
i think is shocking this is quite awful
and this is true in almost all modern
programming languages everything
designed over the last 20 years or so
contains this horrible horrible error
and and it's due to the I Triple E 754
format which is a binary floating-point
specification and it turns out binary
floating-point cannot accurately
represent decimal fractions which is
only a problem if you're on a planet
that uses a decimal system
but it causes problems for us if you're
adding up people's money they have a
reasonable expectation you're gonna get
the right sum and that's not guaranteed
by our type system even worse than that
it breaks associativity so associativity
works in computer arithmetic only if the
two inputs are represented exactly and
if the output can be represented exactly
otherwise associativity breaks which
means the order in which you add things
will change the result which again is
shocking we shouldn't have this we're in
the 21st century now we should have
figured this out by now but we haven't
so I propose to fix this so I'm
proposing a new number type which should
be the only number type in the next
language it does arithmetic in the way
that you were trained to do arithmetic
so you're not going to be surprised by
the results it'll just do it much faster
and more accurately than you can but
it's not going to do things it's not
going to get point one plus point two
wrong it fits in a 64-bit value the
coefficient is 56 bits which gets us a
lot of precision the exponent is eight
bits and I put it at the bottom end
because on Intel architecture we can
unpack that for free so it allows us
down very fast emulators of this format
and the key thing here is that a number
is the coefficient times 10 raised to
the exponent so that's it there are no
other tricks in this it's really really
simple and straightforward so there is a
reference implementation available on
github for x64 assembly language if
you're designing the next language I
recommend you take a look at this and
incorporate it in your design it it can
do an ad of two integers in five
instructions which might say well that's
five more than adding intz except those
five instructions also give you overflow
protection and now
which are useful things to have and in a
hardware implementation that should be
able to add integers or any two numbers
with equal exponents in one cycle which
should eliminate the performance
argument for why we should still have
intz because we shouldn't have hints
anymore so what is 0/0 any guesses so
mathematicians will say it's undefined
and they don't mean that in the silly
way that javascript means undefined they
mean it doesn't make sense to ask the
question it you shouldn't be saying that
and that makes sense except that
computers have to compute and it's
inevitable somebody's going to do it so
what should happen if someone tries to
do this thing which is undefined that
should never ever happen there's one
theory that says the machine should
catch fire
because no one's ever going to do it so
it doesn't matter right
yeah probably not going to get to five
9s that way
so there's another argument that says if
she returned nan or some other Sentinel
value which says this isn't the number
you're looking for and that that's a
reasonable thing there's another
argument that says it should be zero
because anything zero of anything ought
to be zero there's some mathematicians
who actually like this there're more
that don't in business processing this
actually makes sense you know if we
didn't sell anything this month but we
want to know what the average profit for
a thing we didn't sell was its you know
zero divided by zero is gonna be zero
and that's fine right nothing's going to
catch fire and no one's gonna get upset
that's no but that's something to find
no it's just yeah we didn't sell
anything
so for business purposes zero is
actually the right answer there is one
argument that says what's one right
because n over N is 1 right I once
worked in a mainframe where it was - it
was exactly - this was a mainframe that
was designed by Seymour Cray the best
computer designer in history and I can
imagine a conversation that happened at
control data someone said hey Seymour
there's a problem with the divided
circuit that 0 divided by 0 is 2 he says
yeah so what
but it shouldn't catch fire or do
something else and I think he said look
if I if I had to fix this it's gonna add
more complexity to the thing it's gonna
raise the cost of the machine and it's
already one of the world's most
expensive machines and it's going to add
a cycle to every divide and divide is
already the slowest instruction in the
instruction set so I'm going to slow
everybody's program down just for the
one idiot is gonna go and divide
something that he shouldn't divide I'm
not going to do it and as far as anybody
knows I'm the only person who ever did
it and it was fine
so why do I care about 0/0 I'm actually
more concerned with 0 times n so what is
0 times in any guesses 0 seems an
obvious answer shouldn't it
and there were compiler writers who
understood like you did that if they can
determine that if one of the operands of
a multiplication is known at compile
time to be 0 and if the thing on the
other side is pure has no side effects
we don't have to generate that code we
can just plug in a constant we're done
so not only does the program get faster
the compilation gets faster this is a
huge win but when the I Triple E
floating point standard was published
those programs were now in error those
compilers were in error because it says
if n is NaN then the result has to be
man that there are values that we can
multiply by 0 that do not produce 0
which means that you now have to
evaluate both sides even if you know
it's useless to look for the chance
where this thing is a man so that we can
punish the wicked
right because this is not something that
good programs do this is something you
know just weirdness we're slowing
everything down for moral reasons not
for mathematical reasons so who would
write code like that often humans don't
but machines do for example code
generators macro processors partial
evaluators they can all make really good
use of multiplication by zero also it
turns out modern CPU is one of the
slowest things they do is conditional
jump so they're idiots in which we can
avoid conditional jump by multiplying
one thing by something which might be 0
or 1 and then we subtract that thing
from 1 and multiply another thing by it
and then add them together you know
doing two multiplications where you want
to do an assignment can actually be
faster than doing conditional jumps so
but only if the hardware allows it to be
faster so I propose that all of these
forms should produce 0 because why not
they allow things to go faster and their
idioms that that benefit from this and I
think we would all actually benefit from
that in fact the Dec 64 standard
requires this so next language I think
that's how math should work foreign
languages have reserved words in them
and reserved words are a problem they
make things harder for programmers
because you have to be aware of the list
of reserved words if you get it if you
forget something that's on the list then
your program won't compile it's a
problem for language maintainer z'
because they can't add new features
easily because it might be that somebody
has already used that word as a variable
for example exceptions use throw instead
of raised raised was the ideal word for
for causing an exception but the word
raised had already been used for other
purposes and so they you know what's a
word no one would ever use and they came
up with throw and most of you have never
seen anything but throw so you're used
to seeing that but that was not an ideal
consequence and the reason for that was
because compilers used to be have to be
written in
machines that had just a few K in them
and by not having them have to figure
out what the meaning of a word was they
didn't need to use quite as much memory
but we now have gigabytes sooo maybe
we'll have terabytes of memory in our
machines those concerns don't exist
anymore so I recommend a new reserved
word policy which is actually easy to
implement any function a word may be
used as a language keyword such as if or
as the name of the variable but not both
and the programmer decides how it's
going to be used and it turns out that's
easy to implement so we should do that
and it makes everything better when are
the one other argument camelcase or
underbar do we need two of these you
know again that causes endless argument
and and incompatibility and all this
weird stuff and this is one of these
arguments that goes on and on because
everybody's wrong turns out the right
answer is names with spaces names with
spaces so why didn't we always have
names with spaces what Fortran actually
had them but we stopped doing that again
it was because we had machines with not
enough memory in them and it made it
hard so here's an algorithm for doing
that it's pretty simple with names with
spaces in the next language one of the
really good ideas in language design was
contracts programming by contract that
was in the Eifel language contract
allowed you and a function to specify
preconditions and postconditions which
were sets of Williams which would be
true if everything is good for calling
this function and if everything is good
after having called the function these
contracts can give you much better
information than type systems can and
they're in the program so they act
itself documentation and they - for some
purposes they work better than unit
testing because it's built in there and
if you're smart you'll leave them
enabled during production but you don't
have to you can turn them off
unfortunately that language got lost and
the object waited thing but we should
try to get the idea of contracts back I
think that should be in the next
language security is a vitally important
topic because so much of our lives are
now online and everything's connected
and our programming systems are not up
to it our programming systems are
failing us so I'm hoping that a the the
first requirement in the next language
is security that they will look at that
stuff in the beginning not try to tack
it on later because that has never
worked and finally distribution all of
our languages since Fortran have been
dealing with trying to do sequential
things doing one thing after another
but now we've got multicores we've got
lots of processors we that want to have
lots of things happening at the same
time and our sequential programming
languages are really bad at that and
we've got the network so we want to put
stuff out on the cloud distribute our
program over thousands millions of
machines potentially and our languages
are not good at that either so I'm
hoping that the next language will have
actors or maybe some other maybe better
way of dealing with it some way of not
having just one thing after another it'd
be really disappointing if it turns out
that the next language is just Fortran
with new syntax again because we've done
that so many times the next language
should be a new paradigm so that that's
the end of my speculation about the next
language I'd like to leave you with a
warning be careful out there because the
web is cluttered and full of errors
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>