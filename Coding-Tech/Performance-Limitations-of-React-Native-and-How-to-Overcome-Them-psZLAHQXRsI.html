<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Performance Limitations of React Native and How to Overcome Them | Coder Coacher - Coaching Coders</title><meta content="Performance Limitations of React Native and How to Overcome Them - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Performance Limitations of React Native and How to Overcome Them</b></h2><h5 class="post__date">2017-10-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/psZLAHQXRsI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now react native is exciting and we all
want to use it because it lets us use
let us share things there are many
benefits but people always ask one
question how does the performance
compare to purely native apps if I
create my apps with react native will
they measure up to the top apps in the
App Store so this is a very important
question and the purpose of today's talk
is to give you some insights to this
question okay we're gonna discuss a
little bit how react native itself works
under the hood we're going to discuss
some of its limitations inherent
limitations of performance and of course
we can talk about what you're gonna do
about it
okay how we can resolve them so first
let me introduce myself my name is Thao
I work at wix.com if you're not familiar
with Wix Wix is a platform for small
businesses to manage themselves all
starting by creating a beautiful website
and it's not a small platform we've
recently crossed 100 million users which
is pretty exciting so we are big
believers in react native at wix.com
we've switched all of our mobile app
efforts to react native about a year ago
okay previously we had two stacks one
native for iOS and one ADA for Android
and we pretty much ditched them both
about a little bit more than a year ago
and moved over to react native and the
Wix app which you can see here on the
right is implemented from scratch in
react native we have over 40 developers
working on it in the day to day this
number is rising every quarter and being
with react native in production for over
a year in a purely react native app
teaches you a lot which is partly the
reason I'm talking to you today so the
promise for cross-platform from the dawn
of mobile we've been hearing about
cross-platform okay there are many many
benefits to doing cross-platform we want
to share our skill sets we want to share
our knowledge we want to share our code
between iOS and Android between mobile
and the web we want to be more
productive I think we want to develop
faster so there are many many benefits
to cross-platform and JavaScript of
course among also
Solutions is the holy grail of that and
why is that because javascript is the
only language that will let you conquer
both iOS Android and the web but this
isn't really new concepts okay we've
been hearing about it for quite a while
okay we've been hearing about it since
the edge since the days of Cordova and
PhoneGap which Mike mentioned that was
2009 we've been hearing about it since
up celery or titanium that is also has
existed since 2009 so the concept is not
new at all okay but it didn't catch on
none of these technologies has because
become mainstream okay
I am a native developer you don't see
native developers lined up to switch
from native code to them and why is that
so the skeptics would say shitty apps
but I would say that performance is the
underlying reason okay if you take the
performance of those frameworks that try
to use JavaScript as a means to do
cross-platform development you would see
that the performance did not measure up
to purely native apps it is that simple
so the apps that you created with them
did not feel as good as the native ones
okay and then we have a relatively new
player in the field react native learn
once right anywhere with react in
JavaScript lots of productivity coming
from that space so the pedigree is
promising ok it's coming from Facebook
and Facebook since 2012 is a mobile
first company ok most of the revenue
that Facebook makes actually is for
mobile today so this is interesting but
the question still remains does it
measure up to purely native apps so
let's take a look at one screen from our
app ok this is a purely react native app
and let's ask ourselves what is the UI
that we see here is this an HTML is this
a webview like other implementations
like PhoneGap or cordova and many of
your react native developers so you know
that the answer is no ok the views in
react native are purely native views so
from our app are the navigation
controller that you see here the top bar
is UI navigation controller now if you
are an iOS developer you would know that
when you write an objective-c or Swift
to use UI navigation controller so these
are the same UI views that you use in
your native apps and button here is UI
bar button item the image view is
actually uiimageview under the hood the
switches you I switch the tab or
controllers UI table a controller and if
I had shown you the same screen on
Android you would see that the
implementation is completely different
okay it renders to the native views okay
so if the UI is completely native with
react native where is the JavaScript so
the JavaScript is what is running under
the hood is where you are as a developer
are do you specify the business logic
you specify which components you want
and then the framework renders it for
you so let's dive into react native a
little deeper and see the architecture
from the inside so the architecture for
react native okay to understand the main
point is you have to understand that
there are two rooms running side by side
in your app you have the JavaScript
realm and you have the native room the
JavaScript realm is where you program in
JavaScript naturally the code there is
running on a JavaScript engine okay
specifically in react native it uses a
score that is the open source JavaScript
engine for WebKit you are probably
familiar with other engines like v8 okay
there pretty much they do the same
things and this engine is running inside
your app on one of the threads okay your
app is a process it has several threads
in it so JavaScript is just one of them
so what about the native roam in the
native roam you still develop an
objective seen Swift if you are an iOS
or with Java if you are an Android you
use the native platform specific
languages that you use before and you
have the main UI thread as usual in all
platforms okay you can usually change UI
only from the main UI thread and you can
create as many background threads as you
want so these two realms are different
and connecting these two realms is the
bridge the react native bridge which is
a very important construct here in this
entire thing now an interesting story
have ever did you ever try to debug a
react native application using Chrome
for example so when you do that then you
have the two realms actually running on
different computers okay you can run the
JavaScript role entirely inside Chrome
itself so you can debug it inside the
chrome debugger and you have the native
Rome still running on your phone and
then instead of going inside your app
you would
through a WebSocket so the bridge which
is just a communication protocol can
travel over WebSocket as well so this is
the concept now let's talk about
performance okay this is the main topic
for today so code that you write in the
native realm what performance do you
expect of it so naturally we would say
that we expect performance to be good
because that's like the regular way to
develop in mobile so performance in the
native Rome is excellent now what about
JavaScript do we expect JavaScript code
to be slower
well we think in modern JavaScript
engines the answer is No javascript is a
blazingly fast language okay code that
you write in JavaScript is not very much
slower than code that you write anywhere
else so performance in JavaScript realm
is actually pretty good so where is the
problem what about the bridge so let's
talk a little bit but more about the
bridge let's say you have a variable in
one of those real realms okay one our
realm cannot access directly the
variables the data inside the other
realm okay it's a completely different
heap it's a completely different address
space if you want to send data between
the realms you have to serialize it you
have to serialize it just like when you
send data from a client to a server and
this realization is expensive it comes
with an overhead and this is something
that is important to understand the
serialization takes place every time you
send stuff between realms inside your
app and this brings us to the first
conclusion of today if you take
something one thing out of this talk I
hope that this would be it the key to
writing performant react native apps
the key to architecting them is to keep
passes over the bridge to a minimum and
we're gonna see practical example in a
minute ok so take away this and always
think about what is going over your
bridge so let's talk about the obvious
pitfalls or most of the competition that
we talked about since 2009 lost a battle
and the main performance pitfall is to
having synchronous updates between
realms what are synchronous updates
imagine that the JavaScript thread is
trying to change something in the in
natives then the JavaScript thread would
be stuck until the native thread would
handle it and then it would continue and
you understand that making
the entire system stuck until the whole
process completes is a performance
pitfall but it seems that we have to
have that right we need that for
consensus consistency don't we because
let's say that we have a JavaScript line
that changes the color of the button to
blue and the next JavaScript line checks
what is the color of the button now if
the update was a synchronous okay if the
native side did not handle it yet then
the response that we would get in the
second line would not be correct and
this is something that we need to take
care of so how is it working so in react
native actually this is handled out of
the box and is surprisingly in a
surprisingly impressive way and who do
we have to thank for that we actually
have to thank reacts for that reaction
yes actually solves a very similar
problem on the web because on the web
you have essentially the same thing
going on you have the JavaScript realm
which is your JavaScript thread and you
have the DOM and the Dom is a native
construct and every time you try to
update the Dom the update is synchronous
on the web and the way react try to
overcome this performance limitation is
by introducing the shadow Dom you have
JavaScript up the updating JavaScript
and then react batch has those updates
and sends them together at once kind of
like double buffering and gaming so this
optimization is aimed at minimizing
passes over the bridge okay instead of
updating every time you update every
once in a while and you wrapped it
together so this is an idea and this
idea works remarkably well in react
native and achieve the same goal that we
said minimize the passes over the bridge
so this makes updates in react native
updates between rooms are synchronous so
this is one of the secrets for react
native performance out of the box but I
want to show you a more interesting
example okay talking about the happy
flow is happy I want to show you a very
trivial example that you would develop
in your own apps that is completely
immune to the out-of-the-box
optimizations that react native does and
this is surprising so let's dig in so
the screen I'm gonna show you is
actually the main screen of the Wix app
ok I just updated the example from this
talk it's a few weeks ago and in this
screen we have a very simple screen
going on we have
list of cards that we see here on the
bottom and the user can scroll that list
of cards and on the top we have an image
this image is welcoming the user to the
app and we're gonna have two cool
effects here on this image okay
notice the first effect as the user is
scrolling the list of cars the image
dissolves to the background and the
second effect is an over scroll effect
if the user is scrolling downwards when
it is already at the top he can scroll
anymore and the way to give kind of a
good feel is to change the zoom of the
top image accordingly just to make it
feel continuous so these effects may
seem minor to you but they are actually
part of the last mile the last mile is
what makes a user experience magical
it's what makes is what separates the
mediocre apps from the great ones so you
want to invest in those little things
and these things have to run at 60fps or
else you're missing the whole point
the point is immersion so these two
effects will see how to implement them
okay the dissolve and the scale so the
layout for this screen is very simple
okay if we want to lay the screen out
with wood flex or with j6 we're gonna
have two components side by side the
image component on the background and
the ListView that's it very simple so
let's start implementing that now these
effects are tied to the scroll position
okay as the scroll position changes we
want to dissolve accordingly and at the
scroll position changes upwards we want
to change the scale so how would you
implement that in a naive approach so
you want to go with JavaScript and we
want to hook up to the on scroll event
of the scroll view inside the ListView
that would be the natural implementation
so how would that go so first of all we
have the list view and I wanted to show
you that the list if you actually hold a
scroll view you can actually supply the
scroll view by yourself to ListView with
a prop called render scroll component so
here I'm doing just that and on this
scroll view that I'm supplying I'm
hooking up the own scroll event very
simple and the implementation for this
event would just implement our effect
okay our own scroll event handler will
run every time the scroll position
changes and it simply takes the scroll
position and it calculates it checks if
the scroll position is positive that
means that the user is scrolling
downwards and then we want to dissolve
so we will change the opacity from one
to zero
if the scroll position is negative this
is this means that the user is scrolling
upwards in an over scroll so we'll
change the scale from 1 to 1.4 very
simple and once we calculated the new
values we will just set state and
re-render damage so let's analyze
performance let's analyze the number of
passes over the bridge in this example
so the left side here in purple is the
JavaScript realm and the right side in
black will be the native roam so on the
JavaScript realm we start by setting on
scroll now the scroll component as I
told you every component is a native
component at the end of the day so when
we set the own stroll event we actually
have to go over the bridge and set down
scrolling native because the native the
view underneath is a native view so we
set the scroll and then the user starts
scrolling and we have a scroll event now
the scroll event is a native event
because all views are native the events
emerged from the native side so we have
the scroll event but our logic that
calculates own scroll is in JavaScript
we have to change and go over the bridge
again we calculate opacity and scale in
their own scroll function in JavaScript
as I showed you before and then we
rerender now when we render the views
the properties have changed have to go
over the bridge again because the view
itself the image is a native view so we
have to go once again and update the
view itself and on the next frame is the
user Scrolls a little bit more we're
gonna have the same thing going on so
what can we see from this very simple
analysis we can see that data is
crossing the bridge on every frame now
if your app is doing other things on the
JavaScript thread if your app is using
the bridge for other purposes okay and
you expect this effect to run at 60fps
then this is not what not what you'll
get okay this is important to understand
so what can we do okay so first we're
gonna try to implement this several
times so our second attempt we're gonna
pull out the big guns
and the big guns are native okay we're
running on a native platform we have a
problem let's just run there okay it's a
trick we can always use and react native
is actually very flexible for this task
the architecture of react native allows
us to take any component that we want
imported to native we can switch
anywhere this is because a JavaScript
component can contain a native component
and a native component can contain a
JavaScript component so you're free to
design your tree as you like and port
components from one site to another so
how can we reduce bridge traffic using
this flexibility okay so we're going to
do the following
we're going to take one of our
components we're not actually going to
pour it but we're gonna wrap it we're
gonna take our image and we're gonna
wrap it with another component so you
can see it here I call this component
just to be clear native wrapper because
unlike the other components this one
we're gonna implement not in JavaScript
but natively in Objective C in a minute
so the idea here is what what was the
problem with the previous implementation
the problem was that on scroll was a
JavaScript function and we had to go
with the bridge with the event to run it
and then go after we update the
properties go over the bridge again so
if we move on scroll to run in Objective
C we could circumvent all of that
problem so that is the idea so we will
right on scroll in Objective C in a
minute and the the on scroll will be
implemented as part of the native
wrapper now why did I put it there
because the best thing is for the native
view to update its own properties it
will calculate the opacity and the scale
for its own by itself and it will change
its own opacity in scale and because it
is a container if you change opacity and
scale the container the effect also
influences its children and this would
work very well with image so let's try
it out so we're gonna wrap the image
with a native view and gonna listen to
scroll events there this will be our
second attempt now I won't go into the
entire implementation I'll just want to
show you some key things one of the key
things which is a bit like the only
challenging thing here is actually to
hook up the scroll event this is a bit
difficult because you you need a pointer
you need some way to reference the
scroll view inside the native code the
way to do that in general will just give
you the hint of the approach is to get
some reference to it and the way it
works in react native is by using
something called react tag or a node
handle this is pretty much just a number
the way it's a number that you can it's
uniquely identifies every component
instance so you can use this number to
translate and get instances of
components so we can calculate the
instance the number the react tag of the
scroll with the function react native
fine note handle and then we're gonna
pass this number as prop to our native
component now the key thing in our
native component after we have hooked up
our own scroll event is to implement the
on scroll function in Objective C now
this code is an objective-c so if you're
not a native developer it may seem
confusing but it's actually pretty much
identical try to compare it to the
implementation that we had before it's
doing the exact same thing we're taking
the scroll content offset and we're
checking if the scroll position is
positive we're gonna change opacity from
1 to 0 if the scroll position is
negative this means it's an over scroll
effect at the top then we're gonna
change scale from 1 to 1.4 that's it and
instead of setting States we can just
change the view properties directly
because we're running in the native
realm
okay there's no need for the whole set
State thing will react it's it's just
direct view manipulation in native every
native developer knows that's like the
regular way to do it on the native
platform so the limitation is fairly
simple in that regard so let's analyze
we render the whole thing in JavaScript
the left side I remember I remind you is
the JavaScript realm and on the right
side will be the native Rome and we
render so it has to go over the bridge
and this time we set the own scroll
event directly native the scroll event
is a native event as before but this
time instead of running the opacity and
scale logic in JavaScript we're running
it in objective-c native on the native
Rome so no we don't pass over the bridge
once again and the update vugt can take
place in the native realm as well
because we're changing our own opacity
and scale and this happens on the next
frames so what can you see here we've
completely eliminated all passes over
the bridge except for the initialization
so this will run at 60fps and it's a
great solution it will fix the
performance issue and this is good ok
but this is not ideal we can probably do
better now why isn't this good
it's not good because you need native
skillsets to fix this you even need to
write it twice if you were to implement
this for Android you will need to write
it in Java as well and this is annoying
okay you would needed a native developer
with native expertise and if you don't
know how to write a native code you can
reliably be an open source maybe find
somebody who already wrote a similar
component and published it so this could
work what we actually do it wicks is we
follow the 10% rule in our teams we have
about 200 front-end engineers all over
Wix
and among these 200 we maintain about
10% as native engineers so about 20 I
would say would be like the goal if all
native engine if all front-end engineers
worked on mobile so 10% of our engineers
are Native engineers and we keep them
exactly for these purposes okay to take
problematic areas in our app and port
them to native so this brings us to
another conclusion react native doesn't
mean the end of native ok native
developers will still have jobs even
when reacts and if react native takes
over the world so this brings us to the
million dollar question ok the most
interesting part of this talk ok or I
would leave you with you know like a
problem and no real actual actionable
solution so for the framework for react
native to be truly useful we need to do
the same from JavaScript we need to be
able to solve these things we need to be
able to resolve these performance issues
without resorting to native code now how
can we do that how can we design the
framework to solve those problems so
we're gonna do a third and last
implementation of the same exact same
thing but we're gonna do it in
JavaScript and we're gonna take a
concept of declarative programming and
we're gonna implement the whole thing
declaratively we're gonna use the
animated library you probably heard
about it and the concept of declarative
API is the following ok it allows us to
declare in JavaScript the complete
behavior in advance okay that's the idea
behind the Clara you can declare the
entire behavior from your code during
the initialization phase then we can
take this declaration and serialize it
and send the declaration all at once
over the bridge to a native driver now
the native driver is a general-purpose
native driver you're not gonna write
yourself somebody wrote it for you an
objective-c or in Java and this native
driver will understand the declaration
and it will execute the frame-by-frame
for us so this is the concept between
declarative programming and how we use
it to solve performance issues so let's
see what the implementation looks like
and I'm gonna run over it because we're
going to dig into it in detail in AZ in
the next few slides and animated the
animated which is the animations library
the excellent animations library that is
part of react native core it works by
using animated values and what we will
do is we will supply to the ListView
this time not a regular scroll view but
we're gonna supply an animated scroll
view and the animated scroll view is
special because it allows us to hook up
the scroll position to the animated
value we're gonna go over this in detail
in a minute so don't worry about the
code too much the image will also have
to change we're gonna change the image
into animated image okay an animated
image is just the same as it's like a
higher-order component the crab's image
and it will allow us to change the
opacity nuk up the opacity in the scale
to the animated value as well
so Before we jump into the
implementation itself I want to analyze
it with you I want you to see where the
performance benefits come from so the
first thing that runs on the left is the
JavaScript Rome is the Declaration it's
runs in JavaScript I'm going to take you
back to the slide you can see that the
code here is completely declarative it's
all in j6 we no longer have their own
scroll function which was imperative in
the previous two implementations we've
had an imperative function on scroll
that does the calculation not here here
the entire thing is completely
declarative and this declaration is
serialized and sent over the bridge and
this configures a generic driver on the
native realm and this native driver is
the native driver supplied by animated
we didn't write it ourselves we're just
using it's part of the framework and
once there are scroll events emerging
the native driver by itself is going to
do that the calculation of the opacity
and the scale according to what we
declared that we wanted to do and then
it will update the views and it will do
that on every frame so you would see
that the analysis shows that it's
exactly the same as the native
impatiens but what's the big difference
I grayed out all the part that is not
under the direct responsibility of our
code because the native driver does that
for us so this is the concept so now
let's dig deeper into the different
parts of the code because this is the
most interesting part to understand so
the first part was the animated scroll
view itself it does very simple as the
declaration is very simple okay it says
pretty much for any scroll event that
the scroll view has okay you can see
that it's shows own scroll Tech take a
field from that event and event that we
want to take the field that we want to
take from the event is the field called
content offset that's what the
declaration says once you take that
content offset just save it inside an
animated value that I provide
okay you can see it on the far right you
see the underscore scroll why okay this
is our animated value that's it that's
all the declaration what the declaration
says now the second interesting part is
how we change the opacity in a
declarative way okay so this is also
very simple we're going to take the
animated value that we have and at any
given time this animated value will hold
the scroll position because of the
previous declaration and we're going to
interpolate it we're going to tell how
to take any given any given scroll
position value and get the appropriate
opacity value from it okay so it works
by giving an input and an output ranges
so if the input is 0 to 250 and this is
250 logical pixels in scroll position
the opacity will translate to 1 to 0
okay so as you scroll it will get to 0
and the second part is exactly the same
it's the same interpolation of the
animated value that we have and it will
take the input input range which is
different negative 200 to 0 this is the
over scroll that we had and it will
translate it to one point four to one
okay this is this will give us the scale
change that we wanted and this brings us
to the future of react native the future
of react native is to solve more and
more scenarios like I showed you
without native code JavaScript API that
reduces passes over the bridge ok this
is the future
and the declarative native of react in
general is going to be a big help for us
in this process I know if any of you
watched react conf just like a few weeks
ago I demonstrated there and in a
library called interactable the TAS
pretty much the same approach and does
like physical interactions so it's a
very similar declarative approach to
performance issues with react native now
you have access to the full code of the
three implementations just to see them
side-by-side the code is here in github
RN perf experiments - one was like the
old example I changed it up to show the
new API like animated scroll view so you
have that available on github and you
have a small demo app and the cool thing
about this demo app that it lets you run
the three implementations side by side
and it has a little switch because it's
just a small demo app you will not see
performance issues there so what the
switch does is it simulates a busy app
like our big app ok
it just takes and it sends tons of stuff
it makes the app really busy over the
bridge and the JavaScript thread and
I'll show you a small video of what it
looks like so if you if you turn it on
and you try the JavaScript
implementation you can actually see with
your own eyes in a stress condition how
the performance behaves it is not smooth
at all so it has been stressed just too
into to show you how it behaves and the
native implementation is of course silky
smooth and 60fps under the same stress
conditions and the animated example
using use native driver ok native as
well the native performance so this is
how it works you can follow me on medium
I actually wrote a few days ago a post
detailing this entire talk in much more
detail going over the code examples with
more detail you can see there under my
medium account you can also follow me on
Twitter I have a lot of tweets about
what Wix is doing in this space and how
we bring native performance to the react
native space so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>