<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why Elixir Matters: A Genealogy of Functional Programming | Coder Coacher - Coaching Coders</title><meta content="Why Elixir Matters: A Genealogy of Functional Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why Elixir Matters: A Genealogy of Functional Programming</b></h2><h5 class="post__date">2018-04-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cWAHpvkh8Vs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so today I will be talking to you about
why elixir matters or given you rather a
genealogy of function of programming by
way of introductions my my name is OSA
Gaius I work at a company called
MailChimp in Atlanta that's a marketing
automation platform for small businesses
the general outline for this talk with
you as follows first we'll have a short
introduction following that we'll
discuss what I mean by genealogy then we
explore the history of function of hurry
I mean before of course discussing why
elixir matters will then wrap up with
some thoughts on how we can move forward
so a few months ago I walked into the
elixir meetup that I run in Atlanta and
and sort of ran the meetup and had the
event as usual and afterwards a young
man walked up to me and asked me a
simple question why should I learn a
lick sir as I began to talk through the
features of the language I polished I
realized at that point that I knew
nothing about this guy so I stopped and
I got his name and I began to ask him
questions and realized over the next few
minutes that his question was a bit more
nuanced you see he was attending a
full-time program boot camp and a
general assembly and learning to program
while working a regular job at nights he
rephrased this question a bit he said
why this functional programming matter
you see he was learning nodejs Ruby on
Rails react Jes angularjs and a whole
slew of other languages and frameworks
and planes in just 12 weeks he was
deeply deeply interested in how to learn
programming how to get a job and I could
tell from his eyes and he was sleeping
very little on the nights when he wasn't
working his regular job he was attending
meetups like mine to learn more about
programming as I looked in his eyes I
could see the bags for me I could see
that he was like blinking really hard to
stay awake and I realized that his
question was a bit more nuanced his
question was why should I spend the
little amount of waking hours that I
have left to learn about this functional
programming thing I wanted to admonish
him to understand how come
currency affects modern distributed
systems I wanted to tell him to run home
and watch every rich Hickey closure
video he could find because those
lectures changed my perspective they
changed my life in some way I want to
tell him about recursion and how
beautiful it was but I realized at that
point that this guy was hoping praying
just to graduate boot camp and get a job
in a few weeks a June developer at some
local company to stop his bartending job
more importantly I realized that none of
my answers to him were non theoretical I
fumble through an introduction to
distributed systems briefly sketched out
the cat theorem and then told him to go
on learning Rails because when he was
done with school bootcamp that was the
best way that he could find a job in
Atlanta Georgia
I went home exhausted and rather tired
and sad because I realized I'd failed to
defend my language of choice to defend
functional programming tired I reflected
on on that event at home that night and
I realized that I had a hard time
explaining functional programming and
why it mattered to someone so new to
programming because I forgotten why I
fell in love with functional programming
like many of you have spent most of my
career working in functional programming
languages using these techniques
starting my career writing function or
react on the front end it's a building
back-end systems enclosure and then
finally landing in the world of elixir
I've had the privilege to be exposed to
you and being enamored by functional
programming and for that reason I often
struggle to provide a credible and
non-circular explanation for why
functional programming matters
especially on Twitter but more
importantly it's tough to answer the
question why does functional programming
matter today a sizable portion of the
folks at my Meetup currently a 10-buck
camp and they have a finite amount of
time and so for them there's sort of
this this challenge where they're trying
to get a job as quickly as possible and
just as I fail to defend elixir I
realize that a fundamental
presupposition of this talk is that
functional program in itself has failed
which is to say that we the
function of programming community of
filled fill you I suppose stings it
hurts
by definition and declaration however
when we look at the top function of
programming languages today as you can
see on the top programming languages
rather as we can see on this graph
none of them are functional whether we
examine language popularity using
something like the Tybee index here
functional programming languages
consistently do not rank at all we
observe instead that languages like
Python Java and even Ruby languages we
often make fun of as a community they
continue to flourish as you can see on
the graph even more alarmingly if we
define success as the availability of
jobs we come to the conclusion the
functional programming languages have
felt as you can see here in the last two
years functional languages do not offer
the same number of jobs as even Perl or
a sort of often lauded language PHP so
how can we in good conscience how can i
in good conscience tell bootcamp
students who come to my meet-up every
week that they should go study
functional languages now I'm sure that
we could you know however describe and
define successes you know breaking new
research ground inventing new concepts
however that strikes me as somewhat
dubious because it hides the hard work
of answering the question of why
functional languages continue to lag
behind in fact the prevalent argument of
this talk rests on the claim that
functional programming fails precisely
because around incapacity to be attuned
to the real world performance of the
functional languages we build and use
our capacity to reverse the tide will be
determined by how we learned from the
mistakes historically made by the
functional programming community
more to the point in order for elixir to
develop a large and diverse community we
must assume the function of programming
has failed because that pain is
precisely what will generate a different
approach so with that in mind let us
begin then to discuss the history of
function of programming most
commentaries on programming language
adoption in
in both research and industry failed to
account for power as a constituent
element in other words these
commentaries assume that function of
programming languages are chosen in the
vacuum there is a tendency to focus on
language features ie
static typing versus dynamic typing
while important this fails to get to the
heart of why certain languages gained
significant popularity and while others
don't
moreover in the case of commentaries on
functional programming we especially
fail to discuss why Erlang or Lisp or ml
or scheme failed to take hold and
instead we get muddled in discussions in
person on Twitter everywhere you know
about features like Korean or pattern
matching and an even worse turn of
events we as a community you get
sidetracked into discussions where we
simply make fun of or malign other
languages like Ruby or Java and we make
fun of their founders like DHH and we
say that they're very strange people
right and and and that that's fun and
that's interesting and true in many
cases but it misses the point right it
misses the point of why precisely
functional programming lags behind what
these diatribes miss is what I refer to
as a proper analysis of the past a
proper analysis of failure I argued then
that genealogy is a methodology to which
we should analyze the past to which we
should analyze functional programming
genealogy takes on two forms first and
foremost it is an account of the
ancestry and descent of a person family
or group genealogy allows us to
understand a group of individuals or
species that have a common origin put
simply genealogy is the story of how you
came to be from your grandparents to
your parents and so forth secondarily
genealogy can be traced back to this man
Michel Foucault Foucault is a French
philosopher a very smart guy who thought
of genealogy as an analysis of the
development of ideas or truth through
history now that's a lot so it's son
packet for Foucault understanding why
one thing becomes more popular or takes
precedence over another
allows us to analyze or rather forces us
to analyze power in a sort of social
political sense for instance take this
question why do the JVM
the java virtual machine become more
popular than the airline VM in today's
commentary the messy details of power
and knowledge are left unanswered
instead we begin we begin to discuss
things like just-in-time compilation or
whether or not you know the airline's
virtual machine is indeed the savior of
all but from a geological perspective we
must delve into the gray into the
politics of Industry adoption into the
undocumented conversations and code
bases so here I will treat function of
programming as a family of languages
with different species and I believe
that this will help us deconstruct the
accepted precepts that we have about the
development of functional programming
and its adoption with that in mind let's
turn then to a history of functional
programming we'll look at the issue of
functional programming from the 1930s up
until this point and then we will stare
a little bit into the future and think
about what could happen so it all begins
and what we think of as the early period
what I call the early period the early
period of functional programming begins
in the early 1930s and lasts until the
late 1960s we see that lambda calculus
emerges in the 1930s led by Alonzo
church's work it's a system of
mathematical logic for describing
computation based on functions using
variable binding and substitution it is
a model of computation that can be used
to build a Turing machine it becomes a
common ancestor for all functional
programming languages to this day in
1958 list was invented by John McCarthy
building upon lambda calculus which we
think of as this sort of very sort of
complex and strange mathematical form
Lisp emerges as a way to make lambda
calculus more useful and more
interesting so in 1958 we see lists for
merge it's important to note that list
was not truly based on lambda calculus
despite using the word lambda to denote
functions and instead was based on first
order functions equations or first or
the recursion equations with dynamic
binding and Essex
however it is considered the first
practical application of functional
programming into language design to
borrow CKD ewtn's phrasing lisp is
basically lambda calculus with a
user-friendly appearance or syntactic
sugar n' we enter the next period of
functional programming in the early
1970s appeared that I refer to as the
pre Renaissance or we can think of it
just as making functional programming
more practical scheme emerges in 1970
marketing the beginning of this period
while still academically research
focused we see an overall dedication to
taking the early ideas from Lisp and
lambda calculus and making them more
useful for programming period this
overall sort of time lasts lasts rather
on to the early 2000 scheme is one of
the main dialects or of Lisp to quote
david turner the author of Sasol it is
not until this version or until scheme
that we see that list begins to actually
adopt all of lambda calculus put synced
li scheme took Lisp and made it adhere
to lambda calculus well interestingly
scheme led to development of something
that will look further at later called
Common Lisp in 1973 and mal continues
the process of building upon lists by
adding static typing it also introduces
the novel concepts of pattern matching
for function arguments pattern matching
would thereafter become a de facto
standard in most functional languages in
1986 era lanky mergers as you know it
starts at Ericsson as an RnB project to
create a language to build a better type
of telephone switch interestingly during
the early phase of the project attempts
were made to modify small talk and
Prolog for concurrent programming so
what's interesting is that Erlang begins
not as a sort of functional language
rather as a concurrent programming
language based on logic programming
Erlang also is notable because it's the
first time in what we think of as
function of programming where these
basic functional idioms are merged very
strongly with a concurrent program model
this innovation of merging concurrent
and function of programming with an
emphasis of concurrency will permeate
function of program moving for
and will be something that highly highly
differentiates Erlang from the rest of
the functional programming community so
with that in mind we then move on to
Miranda Miranda is a descendent of ml
the ML language it emerges in 1988 and
it popularizes laziness within the
functional programming community
Haskell then closes out the century in
1997 it borrows heavily from M from
Miranda especially with these ideas of
lazy evaluation that ml introduced and
Miranda introduces however it also
introduces static typing which we can
then see as a move constantly to to
modify the existing lineage the next
phase of functional programming that
we'll discuss is what I call the
Renaissance following the late 1990s we
see a resurgence of interest in
functional programming in a period that
although I call the Renaissance we can
sort of term something different more
generally this period is characterized
by attempts to make functional
programming useful within industry so we
go from making functional programming
practical as an academic process and we
go to sort of Industry focus function of
programming communities we see the
development of languages being led not
by university researchers or industry
labs but by industry practitioners we
see people building languages to solve
problems by compiling into other
languages or compiling to other
frameworks it all begins in 2004 with
Scala a functional programming language
that runs in the JVM or the Java Virtual
Machine
although object-oriented it borrows
heavily from scheme and Haskell as well
as from ml f sharp a direct descendant
of the ML family of languages was
introduced in 2005 and built on
Microsoft's net platform in 2007
enclosure emerges as another functional
language on the JVM however although it
leverages the power of the g8 JBM like
Scala does it does not borrow any of the
sort of object-oriented features from
Java it instead adopts Common Lisp which
we discussed before as as a sort of main
dialect it adheres to the syntax of
Common Lisp as well as the overall
program model in 2008 2009 rather acha
mergers although not a functional
language akka is important in the
history of functional programming
because it symbolizes the renewed
interest in the intersection of
functional and concurrent programming as
we mentioned in the case of Erlang it
was an idea that Erlang opened and sort
of you know popularized and by the point
that akka emerges it's better become the
industry standard now what's interesting
that is when we leave the sort of phase
in which akka becomes popular we see
rust emerge as sort of another language
that sort of takes the core ideas around
functional programming that are
developing and in reintroduces static
typing and some type safety so we then
again see that this sort of emphasis
within the function of programming
community on safety as the sort of
consistent element in language design
following this we see our our language
of choice here elixir emerge in 2011 as
a language built from Jose Valens
experience in the Ruby community and the
rails community but rather on the Erlang
virtual machine again we see this sort
of move to take function of programming
ideas and simplify them and make them
more useful for industry purposes and
lastly we see Elm emerge in 2012 as sort
of the first instance where we see
functional programming really begin to
take hold in the functional sort of
front-end community we can see this then
begin to develop with react and redux
and closure script moving forward but
Elm sort of closes off the century or
closes off the Renaissance period and we
then see that function program has taken
hold we see popularization elsewhere but
then the question is why does it look so
matter right elixir happens in 2011 why
does this stand out in the Renaissance
period and then what does this mean for
us so with that in mind I think when
thinking about why elixir matters it's
important to contextualize why Erlang
matters this quote from Joe Armstrong
the founder of Erlang in 2007 as he
reflects upon the history of Erlang it's
quite apropos
he says the rise and the popularity of
the Internet and the need for the non
interrupted availability of services has
extended the class of problems that
Erlang can solve now I think this is
interesting and I think it's quite
apropos giving sort of erlangs place in
the in the in the
community however I think that in order
to answer the question why elixir
matters we have to sort of take issue
with or dive into you this quote in a
bit more detail for one it is true that
today industry is focused on building
resilient services and systems to solve
particular problems
so the question perhaps then is why are
we not seeing a rapid rise in the
popularity of Erlang right why are we
not seeing Erlang rise to the top of
that sort of top 10 list that we looked
at earlier in other words why is Erlang
not the most popular language right if
it's designed to solve these particular
kinds of problems I think to answer that
we also have to answer the question why
why does elixir matter right why is it
look sir not on that list and I believe
that there are three axes for how we can
think about this the first is around
syntax just as Lisp is sort of syntactic
sugar een on lambda calculus we can say
that elixir and Phoenix are web focused
sugar a non Erlang although our liquor
is a language on its own a crowning
reason for its ability to take and you
know become popular is because it
represents Erlang to a new generation we
can then say that Erlang you know in
some way fails or misses opportunities
because its syntax wasn't designed for
general purpose use whereas languages
like Java JavaScript et cetera modify
themselves and shape themselves to be
either similar to each other or to be
similar to languages the developers were
used to using whereas Erlang was such a
large deviation given a sort of
background and prologue and small talk
so I think syntax is sort of one axes
that we can think of as why elixir
matters precisely because it is a
syntactic sugar rain on Erlang that you
know represent Erlang to the new
community
I think the second axes we can think
about is the web I think we and I when I
say the Erlang community I use the term
weave because I think we are all part of
the Erlang community although we are
part of the elixir community as well I
think we missed the opportunity in the
context of Erlang to help shape the web
in other words all those technologies
like rabbitmq and a jeopardy are built
on Orland the language itself does not
hold as a general-purpose language for
building web server programming language
well web servers now it's true that you
can use Erlang for doing these things
but it is not popular for doing those
things precisely because Erlang as a
community failed to adopt the web and
fail to popularize itself in the Casas
as we can see in the case of Java and
JavaScript or even Ruby so if we look
sort of historically we can see that
Erlang emerges in 1986 Java then emerges
in the late 90s followed by JavaScript
Ruby and then finally rails so while all
this is happening we're seeing sort of
err lang sort of stay in the background
while these new languages sort of take
hold and begin to shape how the web sort
of forms now by contrast elixir was
built from the beginning with the web in
mind due to Jose's background as a rails
core team member he aimed to solve a
problem that he had in the same way as
other participants in the Renaissance
period aimed to solve problems that they
were having at their jobs the
development of Phoenix and the emphasis
on rails like simplicity while some
folks like Rob Connor you might take
sort of offense with that is actually
very useful with regards to web
development because it actually helps us
sort of take Erlang from being the sort
of background language just sort of
telephone switch language to being a
sort of general-purpose web language so
I think again that's sort of a reason
why elixir matters precisely in the case
where Erlang fails or misses the boat on
the third axis I think of as evangelism
if we examine Java JavaScript rails and
even a modern language like go we see an
emphasis by companies and their steward
and organizations on promoting the
language the reality is that Ericsson in
the case of Erlang did not emphasize
this at least not in the extent that
let's say Sun Microsystems or Oracle did
with regards to Java in the case of
JavaScript Netscape who of course wrote
the language in 10 days and the Mozilla
Foundation were very very aggressive in
promoting JavaScript and ensuring the
use of a language on all web browsers it
is somewhat ironic to note that
javascript was originally based on
scheme a functional language before it
sort of you know took a different path
however if we revisit Joe's quote I'd
argue that it is more accurate to say
that elixir
the class of problems that Erlang can
solve in the age of Internet services
but how do we the elixir community which
is to save the Erlang community ensure
that this actually happens how do we
ensure that elixir in Erlang rise to the
top tier of programming languages and
next decade well that brings me to the
next section so there's this quote from
meyerovich and Rabkin they perform sort
of this large analysis of you know
github of SourceForge of languages that
are popular and they and they make this
sort of last statement that I think is
apropos they say that unpopular
languages are niche languages right and
so by definition we can also say that
niche languages are on popular languages
so I think for us is sort of thing to
take note of and to sort of take Cree to
which i think is that breadth versus
depth is sort of an important context to
think of when moving forward is a
programming language and as a community
we have to sort of make a choice right
do we go deeper into functional
programming do we like begin to
implement monads and go all the way down
that path or do we sort of become you
know more encompassing and wider do we
begin to build libraries from a
practical things I think when thinking
about breadth I think there are two axes
for us that matter I think when trying
to become a wider more encompassing
language I think the first is libraries
libraries libraries so you think of Ruby
as being you know sort of very very much
popularized by the fact that you could
have a gem for anything you wanted to
build on Rails you know if there's a
problem you had there was a gem for that
we can go back and forth on whether
that's the best approach to programming
but more generally the idea that
whenever you have a problem as a
programmer on your job but there's a gem
or a library in your language community
to solve that problem that generally
helps you convince your boss it
generally helps you convince your
co-workers that we should indeed use
this so I think for us as a community
sort of the challenge is over the next
couple of years to make sure that
whenever there is a library or sort of a
problem to be solved in a business
context industry context that we have
the tools already built in our community
so you think of basic things like
database drivers for you know things
like cockroach DB like it might not be
exciting and great and functional in
computer science work but it's work that
has to be done for us to actually become
sort of a large and
accomplishing community I think the
second is around domains I think you
know niche languages are not just niche
languages because they go deep
there are also niche languages because
they're only concentrated in one domain
so whether that be the web or that be
sort of sir particular tasks when it
comes to things like Python or regards
to scientific computing I think for us
as a community we have to you know widen
the domains are in whether that's going
into scientific computing whether that
means you know things like nerves going
into embedded systems I think widens the
domain is something we have to do in
order to you know prevent the challenge
with all functional languages tend to
have which is that they become very
domain-specific they almost become dsls
so the second sort of axes that I think
matters in forward is evangelism and I
think evangelism is particularly tough
because we're all engineers we're all
builders we think of ourselves as
thinkers not as like speakers but I
think it's a challenge right because
when we look at sort of Java and look at
JavaScript there's sort of a massive
marketing push in the 90s and the 2000s
for these kinds of languages to become
the de facto standard and they did
indeed become the de facto standard
right so I think there's work to be done
in our communities to market our
language this might not mean having an
extensive marketing budget like Sun
Microsystems or Mozilla or Netscape but
it does mean that we have to think about
how do we market our language to
programmers how do we sell our language
to programmers in a way that's not just
based on well these are the features and
here's why it's better but maybe these
are the things that can do for you and
here's how you talk to your boss about
it I think the second is around
consultation I think that you know
there's great work being done by erlang
solutions and other folks like that to
take Erlang into you know sort of
industry practitioners and say let me
help you solve your problems and I think
that's something we have to do as a
community I see this in my meet-up where
I go give people sort of free
consultation and here's how you could
use a lecturer regardless of whether or
not they actually use it that work is
necessary because it is actually how you
get folks who don't already buy into
functional programming to begin to think
about these things I think the last axis
is around fanning out right fanning out
stuff you know I think we as elixir
folks like to come to elixir conferences
but the hard work is actually in going
to conferences that are not elixir based
so going to the JavaScript meetups going
to the Java conferences and maybe
sneaked in a talk or two
in there about elixir that folks might
not expect right I think that's where
the hard work comes because that's about
convincing folks who aren't already
convinced to use the language I've
already done this I go to react meetups
and I you know give a talk about react
but then like halfway through I actually
talked about elixir and like give a 101
to elixir
it's a great strategy just don't really
tell people that that's your strategy
you just tell them you can't talk about
react and then you know dovetail things
into a functional programming
introduction
and what I found is that folks actually
appreciate that because they learn a lot
more than what they learn by just coming
to a react conference so with that in
mind let's conclude for me I think the
history of functional programming is not
static it is always already political we
the folks in this room that we being the
airline community we being the elixir
community we are responsible for
determining what the future of
functional programming will be I think
this quote from friends when on the
Martinique and philosopher is quite
instructive he says I do not have the
duty to be this or that I am NOT a
prisoner of history I think for us is
true we are not a prisoner of the
history of erlang all the history of
functional programming we have the
ability to make history anew and if we
return to the story that I began with
I'd like to you know couch
my hope for elixir in the context of
that story my hope is that a decade from
now my answer to that boot camp student
of why should I learn elixir will be you
should only lick sir because it would
get you a job in fact you can't get a
job if you don't know it like sir that'd
be even better right in the same ways
you need to know Java nowadays or Rails
to get a job even more so my hope and my
prayers the developer is like my niece
will grow up in a world where she does
not even have to ask the question why
does elixir matter because why elixir
matters is already self-evident thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>