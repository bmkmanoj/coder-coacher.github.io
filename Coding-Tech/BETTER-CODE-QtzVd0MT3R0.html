<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>BETTER CODE | Coder Coacher - Coaching Coders</title><meta content="BETTER CODE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>BETTER CODE</b></h2><h5 class="post__date">2017-09-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QtzVd0MT3R0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this talk I first prepared for ICPC
which is the international conference
for program comprehension and for people
who don't know what program
comprehension is it's basically the
study of how we understand software and
tools for building software it is not my
field of study it's not my field of
expertise but in putting this talk
together I thought it would take some
time and ask friends about how how they
learn about a new software system when
they jump into it to give you a little
background on my talks I've been slowly
working on a book called better code
this came out of some two talks that I
gave at going native a few years back
and they were very well received and so
a lot of people asked me to write a book
so this talk is is somewhat an overview
of all of these talks so this would be
the the preface and tomorrow we're going
to be talking about concurrency which is
kind of jumping to the end of the book
so we'll cover both of those how many
people know what the knowledge is
anybody one person one person knows what
the knowledge is somebody who's been to
London so the knowledge is a test given
to to the London black cab drivers
before you can become a London black cab
driver you have to pass the knowledge
test and that means that you need to
understand the City of London very well
and what the routes are from A to B
within the city very well and I think
the way that people learn about anything
of scale has a lot of similarities so
when I will go and I ask my friends how
they learn about software systems these
are some of the answers I got they say
well I find some piece in the code and I
traced through from that point to some
other point in the code and so I follow
along a road and I see what happens
along that road ok and that gives me
some insight into what
going on in the code and other people
said no don't don't trace through it
just take a subsystem of the code and
study it and kind of see all the ways
that you can come in and out of this one
location and that will give you insight
into the code so you'll get a little
glimpse and some people said no just
take a file write and learn everything
that file and then work through all the
files and that's like taking you know a
burro here with very sharp edges and
understanding that piece but when I
thought about you know I think all of
these are valuable ways and valuable
tools for how you learn about a piece of
code but when I thought about how I do
it
I thought none of those answers are
right this is kind of how I learn a
piece of software which is to say I
study the system from the outside and I
build up a set of abstract rules about
how that system would have to work to
satisfy those behaviors okay and if you
look this is the the London tube system
a map of the tube system if you overlaid
the tube system onto an actual map of
London you would get that right there's
not a strong direct one-to-one
correlation between your map of the tube
system and where those tubes actually go
it's an abstraction that lets you stand
back and understand the system as a
whole so let's take a look at how we
apply these things to software the first
thing to understand about software is
there are rules
okay there are rules that govern the
behavior of software systems and the
rules sometimes exist
outside of our code this is an
implementation of STD lower bound okay
how many people know what lower bound
does the rest of you you have to go read
lower bound is one of the most important
functions in the in the standard
template library so a lower bound is a
binary search it will give you the
lowest
point in a a non decreasing sequence
where a new element could be inserted to
keep the ordering right so if you wanted
to if you had 1 1 2 2 2 2 3 3 3 and you
wanted to insert a 2 it would tell you
the first point where that could go
between the first one and the first 2
right so this is that that binary search
okay but the code doesn't tell you
everything about this
there's requirements on these types okay
so we have forward iterators here which
are just template arguments and those
come along with both a set of syntax
that needs to go with that in a set of
semantic requirements that go with a
forward in orator so we know that first
to last here has to be a valid range
that means that if I start at first if
first doesn't already equal last and
every time I increment first I will
progress until eventually I hit last I
will never end up in a cycle and keep
cycling infinitely there has to be some
path from first to last for this
algorithm to work the comparison
function for this algorithm to work has
to implement a strict weak ordering okay
how many people know what a strict weak
ordering is far fewer far fewer ok so
strict record rains are very important
in almost all of stl if you look at the
requirements of sort or lower bounds
these requires strict weak ordering what
we mean by a strict weak ordering is
that it is it is strict in the sense
that it is not a partial ordering that
an element is either is either greater
than less than or equal to the element
being compared to and I should say say
equivalent to because the weak part is
that it's not a total necessarily a
total ordering right if I'm sorting a
bunch of records by last name then I
then all of the Smiths are equivalent
John Smith is equivalent to Bob
Smith okay so that's how its weak okay
so a strict weak ordering is very
similar to a total ordering but it's not
quite the equal there is equivalence and
not equality okay so that has to be true
okay so so in that comparison has to be
a strict weak ordering for all of the
values within that sequence and there's
no good way to verify that there's no
assert that you could write on that
comparison to double-check that it's a
strict weak ordering you would have to
compare every element against every
other element and then check those
results right so so you would end up
with a huge number of permutations if
you wanted to try to validate that okay
and then value our value type has to be
the same type as the dereferenced
forward iterator type okay or it has to
be one I can have an asynchronous
compare an asymmetric compare function
in which case my value type has to be
comparable to the items in my list and
still maintain that structure recording
so you have this whole set of
requirements in just a simple piece of
code like this that stand outside of the
code so how does this relate to software
understanding well I do a lot of desktop
software working at Adobe I've worked on
Photoshop and Lightroom a number of
products when I approach a piece of
software I always start from the outside
if I need to understand a piece of
software so this is a menu taken
straight out of Microsoft Word not an
Adobe product okay so looking at this
menu one of the first things that I see
are that some of the items are disabled
right so I have some items that are
enabled and some items that are disabled
okay so anybody know what the rule would
be for disabling a menu item I have one
person
right right so the answer was maybe this
menu item doesn't satisfy some of the
conditions or requirements okay so a
little more formally we can think of
each of these things as representing a
function right some command some
function that's going to be executed and
that function has a set of preconditions
in a set of arguments okay and those
arguments are coming from someplace
they're coming from the state of the
application so whether or not one of
these menu items is enabled or disabled
is whether or not the arguments to the
function are satisfied okay whether or
not the preconditions of that argument a
the precondition of that function
whether or not the arguments being
supplied satisfy that precondition okay
so we can think about it this way right
we've got some function that the menu
item is going to invoke and we've got a
predicate P that's telling us whether or
not the preconditions for that function
are satisfied and that's telling our
menu whether or not to be enabled or
disabled but these things have to be
evaluating and executing something so my
application has some state somewhere
right which is feeding in to this
precondition and that state is also
feeding into my function right so if the
state if the state satisfies the
precondition of my function then P will
be true my menu item will just be be
enabled and I can invoke my function
okay people following so far now with
this little diagram I have a problem a
small problem here right all right any
time you start to layout dependencies
and you have two arrows feeding into one
place that originated at one place in
this place I have my state that goes
through my predicate that goes to my
menu item that goes to my function and
my state also goes directly to my
function okay so that's called a join
right let's a join in my graph where
these two pieces are coming coming
together okay
now for that join to be correct that
means that the information that comes
along both of those paths has to match
if I'm coding in an asynchronous system
okay if my state can be changing
asynchronously or my menu items are
getting evaluated on a loop in my main
UI thread or something like that I need
some way to ensure that those match okay
and more importantly I need some way to
think about this system to know that
every time I look at that I have to make
sure that those match the other thing
that I have is my function is coming
back and modifying my state okay and
that's creating what maybe isn't an
infinite cycle okay and so that's a bad
way to think about it so I'm going to
refine my diagram a little bit here and
I'm gonna say no I've got my state okay
which feeds in to what is partially my
predicate now okay but I'm going to use
a trick from category theory how many
people have done any functional
programming a couple people have done
functional programming okay so you might
want to read some of the blog posts from
Bartos and I'm gonna butcher his last
name Milewski yes Bartos is blog post on
category theory but this is a an
instance of a class leaked at aghori so
what we're going to do is we're going to
take our state and instead of just
evaluating it with a predicate in our
predicate returning a boolean okay our
predicate now is changing into a
function which is going to to take the
state and augment it by attaching a
boolean to the state to the arguments to
our function and so now what we have
going up into our menu item is all of
the arguments to the function plus a
boolean that says whether or not they
satisfy the precondition and so now I
can think of my menu item as being a
latch in the gate okay and it can say oh
okay
the predicate says that these things are
good so I can open the latch and when
the user picks the item I can let that
flow through and go and execute the
function and because those now
originated from the same place I know
everything here is going to be
consistent and execute correctly and
then finally I'm going to think about my
function as not going down and modifying
my initial state but return you in a new
state my state prime ok and so now what
I've got going on here with my hard
lines is I've untangled this cyclic
thing with joins into something that's a
nice simple dag that's going to progress
forward ok in a very predictable way now
I'm going through this mental exercise
what I'm doing is I'm understanding how
this piece of software must work what
are the rules that govern this piece of
software I know perfectly well that
Microsoft Word is not written this way
ok I know perfectly well that it's
probably following some
model-view-controller pattern in in how
it works or if it's Microsoft maybe it's
mvvm ok but all of these components have
to exist within that system for it to be
correct so now if I'm plopped into the
code and I'm looking at a bug maybe in
the code and the bug says this menu item
isn't enabled when it's supposed to be
under these conditions I'm not just
going to go blindly and change add an
extra if statement and say Oh fine I'll
make it enabled then you know whatever
the bug report says right whatever QE
said now I can think about ok this
predicate that's being evaluated has to
correspond to the preconditions for my
function let me go look at what are the
actual preconditions for my function
maybe it's the bug report that's wrong
and that the menu item actually
shouldn't be enabled ok
so I know what the correspondents are
and I know what has to work and if
things are getting out of sync or
previously I had the joy and I know oh I
see what's happening I've got this
information coming along to pass and
this information is no longer consistent
and that's what the what the information
is
it's the bug wasn't that the menu item
was it was disabled when it should have
been enabled it's that it's still
disabled but it should be enabled now
because my state has changed and these
things have become out of sync okay so
by understanding what the rules are that
actually govern the system helps me
reason about the code and as I'm in
there reading the code I can start to
see oh I see this piece of code plays
this role in this diagram okay so that's
the menu item that's how I think about
it now this talk is titled better code
in order to write better code I think
it's very important that we understand
what good code is okay and there's kind
of a classical definition which is that
good code correct code is code that
matches the specification all right how
many people learn that in school how
many people had an instructor say you
know your code has to match the
specification nobody you guys went to
different schools than I went to it was
like everybody in any case if you even
look online you'll find that that's the
classical definition good code is
correct correct code means the code
matches the specification it's somewhat
true but it's not the whole story
okay so what do we mean by correct I
mean correct in a mathematical sense
consistent without contradiction
so let's take a look at a piece of code
here with a very simple bug I hope
everybody can spot the bug here right
all right what happens if I execute this
anybody yeah yeah yeah
bad XS sig abort okay that's the actual
error error I get okay why I've got
print string that's gonna print a spray
string and I passed it a null pointer
and it didn't check for a null pointer
okay so there's a bug but what's the bug
okay should I be checking before I
dereference my null pointer should I be
checking before I pass a null pointer
what's that so the while loop should be
changed to check that's yep so one that
one vote is to change the while loop to
change print string to check okay so
yeah so what should you do when you it
when you ask to print a null pointer
okay here's my fix okay
so all I did was I changed my intention
right I changed the specification I said
I want to crash force crash okay there's
still a bug though
but now the bugs much more subtle
anybody want to hazard a guess as to
what the bug is here what's that
incrementing s no it's actually it's a
pointer to a constant character s itself
is not constant what's that it's not
crashing unconditionally that's the
right answer
this standard doesn't guarantee that
this will crash okay it might launch
missiles somewhere it's undefined
behavior okay so so now I've got a
contradiction but my contradiction is
with the standard not within the code
defects can get very subtle in a piece
of code consistency requires context
consistency within a system means that
you're looking at the system as a whole
okay it's very easy to write a little
function a little piece of code and
think about okay I believe that this
little piece of code is correct okay but
consistency requires that you're looking
at everything now even the standard and
even Aleks Stepanov don't always get
things like this correct so this is an
abbreviated version of STD min out of
the standard library okay so there's the
definition of STD min and here's the
definition of STD max okay now who would
believe me if I said the definition of
STD Max is wrong one person two people
Oh a few people what's the problem with
the definition of STD max
it's not consistent with men it's very
consistent they both returned the first
argument when the arguments are
equivalent okay
STD max should return the second
argument right if I called min and Max
with the same argument a and B
potentially they would both return the
same thing right so so that's a bit
disconcerting and it starts to affect
other code right you don't know how much
code I've seen that has a clamp function
now clamp is actually going to be part
of the standard and it's defined
correctly in the standard but how much
code I've seen that implements clamp
like this okay this is a bad
implementation of clamp okay so clamp
for people who don't know is effectively
a median of three right right it's
supposed to say given three values
giving me the middle one right so it's
clamping a value between a high and a
low and it looks like that's how you
should write it max low a against min
with high okay and if you got a custom
comparator it would look like that and
here's how that fails okay we talked a
little bit about strict weak ordering
before right so here I've got a low
value and a high value which are sorted
one and two was the second guy and I
want to clamp okay between those two
okay so okay is between those two right
so it should return a but it doesn't it
returns low okay so because of the
asymmetry between min and Max right
people write bugs like this now the fix
is you can rewrite clamp like this but
that's a pretty non-intuitive way to do
it to say oh I see what I have to do is
I have to put my argument that I want
between the two first instead of in the
middle
okay so this is what the definition of
max should say in the standard now one
problem is the one something like this
is wrong in the standard it's very
difficult to fix right you you're not
changing the signature of Max and so if
we go and change the definition of Max
and everybody who had a correct clamp we
just broke okay so the once you get more
and more arguments in here you can start
to see why this is true right if I have
max of three arguments or max with with
variable number of arguments I want it
to be the last thing the greatest thing
in the list and the other problem that
we come in that we come to with rules
right rules can be subtle they can be
hard to spot rules can be contentious I
was mentioned in my bio I worked for a
little over a year at Google well I was
at Google I had this long-running
argument with Craig Silverstein who at
the time had ownership of the C++ coding
guidelines for Google and this was from
a message that Craig wrote wrote to me
okay and I have lots of disagreements
with Craig I do have a lot of respect
for the man's I don't think that I'm
slamming them too hard here but I'm
gonna let you read that for a moment
okay so what he's saying is because
everybody comes up with their own
definitions for words we shouldn't have
any standard definitions for words right
because everybody uses language a little
bit differently we shouldn't define what
the language means I view that as a big
problem but I see this a lot people want
things to mean what they want them to
mean within the context within which
they're using them and that's a problem
when you're working on a large software
system
so there is no spoon one area where this
comes up over and over and over again is
dealing with zero okay I'm pretty
certain that the first person who went
without a meal for a day understood the
concept of zero of nothingness right
but as mathematicians it took people an
incredibly long time to come to grips
with zero right if you look at the
history you start to see c0 appear first
in in the Hindu tradition and then in
the Arabic tradition and it's not until
Fibonacci in 1202 where a zero starts to
appear in western writing on mathematics
okay and it's not until the sixteenth
century that zero becomes part of common
everyday experience so from the first
guy who went hungry in a cave to the
16th century is a long time to come to
grips with a zero right
why is zero so hard well as computer
scientists we still struggle with it we
still despise zero what do I mean by
that
int X okay what's the value of x here
that's right
indeterminate value undefined int x
equals one over zero what's this louder
it's a crash
now undefined behavior maybe it's a
crash 1.0 over 0.0 anybody
I heard a nan nan anybody could argue
with nan may crash it's infinity it's
not nan okay zero point zero over zero
point zero you were just a little too
early
that's a nan okay I can declare an empty
struct the size of my empty struct is
one defined by the standard not zero can
I do that an array with zero elements
yeah this guy got the answer right he
said he said in the standard you can't
do it but in most compilers you can
which is true that should be an error
but it's a common extension so clang and
GCC will actually accept that by default
which means that I can do this
I can create an empty type okay with
just a type def two in zero now the
whole argument around making empty
classes be zero is that every type
should have a unique address but the
ones I can have an empty type I can
create an array of two empty types and
they both have the same address okay and
the world doesn't unravel I can write a
function okay that returns void and I
can actually say now in the language
returns void that's okay what about that
can I do that
anybody know that's an error okay the
void star well that's a pointer to
anything as opposed to nothing okay
let's say that I take a vector and in
the middle of inserting something into
my vector I throw an exception can i
output the size of the vector when I
catch it what does the standard say yes
no nice yes yeah basically
exception guarantee valid but
unspecified okay is what the standard
says so I can output the size but I have
no idea what that will print okay
I move an object into y I move from
object X is also valid but unspecified
okay all of these places where we're
looking at these things have a similar
thing we're uncomfortable dealing with a
zero so we tend to patch around it we
disallow it we make up answers okay
maybe it's infinity okay we create a new
value for our doubles called an an to
hold it we continually try to sidestep
it this is because good code has meaning
so what is meaning meaning is a
correspondence to an entity specified
defined okay that's what the definition
of meaning is okay so the meaning that
something has is imbued upon that object
by how it connects to other things right
it's the correspondence so when I put up
this diagram the meaning of my predicate
is that dashed line okay
that predicate represents the
preconditions to my function that's the
meaning of that predicate okay and
there's no place where that dashed line
is going to appear in a piece of code
but that's the meaning of it so these
things the absence of something we've
come to grips with pretty well like I
said the first caveman understood this
right we know what zero is we know what
the empty said is we know what an empty
range is we know what the empty type is
void okay the problem that we have with
these things is that they tend to lead
to the absence of meaning right nann is
the absence of meaning it's nonsense
okay man is is no longer a value it's
this thing no longer represents
something else okay undefined is another
word for has no meaning indeterminant is
another word for has no meaning okay an
object that's in an undefined or
indeterminate state has lost its
correspondence to its value so if we
think about those things in mind if we
keep those things in mind we can start
to think about how do we deal with zero
consistent consistently right
you can't just brush it under the under
the rug right you can't take and say an
empty struct I'm going to call it one
and think that that's somehow sidesteps
zero all it does is pushes the problem
down to the next guy to deal with right
now you get things like compressed pair
how do you get that one back out of the
because you know it doesn't really take
up any space right so index right Alex
stepping off coined this term ages ago
but it's written down in elements of
programming if you've seen the book
which is a partially form type right the
idea with a partially formed type is I
can assign a new value into it or I can
destruct it okay
those are the only two things that I can
do why because those are the two things
that restore meaning to the type so when
I have a type
that's in an indeterminate state which
is what X's is down here another way to
say that is it's partially formed before
I can deal with that type okay I need to
assign a value to it or destruct it okay
compilers understand that pretty well
most compilers if I try to use X okay if
I said y equals x plus five they would
at least give me a warning if not an
error that said you were using X and
it's in an indeterminate state okay
which means that X plus five doesn't
mean anything so stop it okay one over
zero right undefined behavior right
why okay well one over zero itself
creates a temporary that's partially
formed okay and so what I'm doing is I'm
reading from that and the compiler
should ideally give me an error x equals
1.0 over zero point zero how do I feel
about that right it was infinity I'm
actually going to agree with the
standard on this one I think infinity is
the right answer actually I should say
it's an approximation for for overflow
right I couldn't error in my slide there
zero point zero
is an an it's okay
okay but I would prefer that I get an
error for my compiler if I then attempt
to read from it right catch it
statically now what can we do with an
empty struct right one of my
recommendations has been that we
introduce a little bit of new syntax
that says let let us to inherit from
void okay if I want to say something
that's really empty okay any type should
be able to inherit from void which
basically means that I have a zero size
base at my root the reason why I can't
just change the definition of him empty
is because I would break a whole bunch
of code okay that would give me size of
empty is zero
what about it into a of zero well it's a
standard compiler extension and I
actually think they're rights that
should be okay it should not be an error
in the language and especially since the
standard should follow along with common
practice and given that we have two of
the most major compilers that have been
doing this for ages and the universe
didn't unravel in response for us having
empty types I think that's the correct
answer okay that should continue to be
okay but this should also be okay if
you've ever written template code that
has to specialize on zero or it has to
specialize on type void it's really a
pain in the butt it's really a pain that
I can't deal with something that returns
an integer and something that returns
void consistently a void star that's
okay here
so I disagree with the standard on this
one I think X should be declared as
partially formed and reeving should be
undefined behavior and preferably
catchable from the compiler the problem
that I have it being being valid but
unspecified is that means that reading
from it potentially has no meaning and
what I'm doing is I'm pushing to run
time something that is not easily
checked something that could be checked
at compile time same thing here
here I think the standard actually does
more harm okay by saying that the value
within X is valid but unspecified means
that the value X has to satisfy all the
preconditions that are on that that
class all the invariants for the class
type so so the problem with that is is
in real cases that requires that you do
an allocation at the time that you move
from which means that move becomes a
potentially throwing operation and if
you look at all the back flips that the
the standard Committee went through
trying to define what's the state of a a
variant if I throw an exception trying
to put something into it right you end
up with a variant being it can be of
type A or B or neither because I have no
way to get an object back into it okay
that's just one sign of the damage
caused by a wrong definition of what
move means makes you wonder take chicken
for example these are all movie quotes
if you haven't seen that so this issue
came to me recently jonathan co-wrote a
proposal for the standards committee and
this is a very simplified version of it
and this was the meeting of the Oslo
meeting just before the Issaquah meeting
here and this is a very heavily
shortened version of the specification
okay but he proposed that we had a new
pointer type called clone pointer okay
which is like unique pointer but with
two additional operations okay one is
that when I copy the clone pointer write
a unique pointer is not copyable but a
clone pointer would be copyable and when
I copy a clone point clone pointer what
that means is I'm going to copy the
thing the clone pointer points to and so
my new pointer will point to a new
instance of that thing okay and when I
assign to it same thing to be consistent
with my copy now I will copy it and and
end up reassigning my pointer to point
to a new thing Jonathan took this to the
Standards Committee I was not at the
Standards Committee meeting but my
understanding from Jonathan was he took
it he presented it people in the room
said this makes us feel very
uncomfortable when he asked why they
said well we're not sure what the
semantics means and when he said said
what does that mean the answer was go
talk to Sean so jonathan sent me an
email and said what's wrong with this
anybody know what my answer was anybody
does this look like a good definition
for a type two you okay it's not so
there's a lot of things wrong with just
this little definition right well that's
just a note saying what my copy
assignment is here's the problem what
does it mean to copy something right
what it means when we create a copy of
something right and this is an English
word right not a computer science word
what it means when we copy something is
that we create something which is equal
to but disjoint from the original okay
so if I copy my bottle of water I end up
with two bottles of water and if I drink
this one this one doesn't get drunk okay
so that's what copy means that's the
meaning of copy okay
your compiler relies on this meaning of
copy because your compiler can ally to
copy write your compiler can come along
and say oh hey he said to put this
function and result into X I don't have
to copy the object into X I can just
elide that copy and construct it
directly in place because I know that
that's going to give me an equal object
to the original ok so that's the
definition of copy well what happened
with this clone pointer right clone
pointer was just like a unique pointer
and unique pointers I can compare for
equivalency and what that does is it
compares the two pointers but now my
clone pointer when I copy my clone
pointer copies the object it points to
and so if my comparison just compares
the two pointers now I have an instance
where copies are not equal to each other
so could we fix it we could we can be a
little sneaky here okay we can say that
what we want are the copy should be
equal and that would imply that we were
actually comparing for equivalency the
two objects that were pointed to but
those two objects may not implement
equality and so what we're going to do
is we're going to define copy to say
that the copies are equal but on our
clone pointer now we're going to modify
it and remove the Equality operation
we're going to get rid of quality right
so we're gonna cheat the next issue that
I have with this type what does it mean
for something to be a pointer to
something else right okay so what it
means is that the primary purpose of
that object is to be a reference an
indicator of something else okay which
means that if I have two pointers which
are equal what that means is that they
point to exactly the same object but I
just said that a clone pointer because
when I make a copy of a clone pointer
into another clone pointer that
equivalency has to be deep equality okay
otherwise it's not a copy okay then that
also means this is
longer a pointer okay
I've lost the semantics of being a
pointer okay that's what happens right
so I make a copy it implies that they're
equal but the addresses of the things
they point to is not equal which means
they're not referencing the same object
so it no longer has pointer semantics
okay so what am I gonna do now well the
only place I had pointer in here was in
the name so I'm gonna rename the thing
right the name that Jonathan and I came
up with was indirect in this akua's
Committee meet thinks that polymorphic
value is a better name so I think
they're okay on that one I somewhat
disagree because I think this is a
useful type even in the absence of
polymorphism okay here is a subtle issue
with the item I didn't see this one
right away so this came up in
conversations if I've got this thing
that was a clone pointer now it's an
indirect and it points still kind of
refers indirectly to another object okay
if I have a constant instance of one of
those what does that mean does that mean
that Const propagates to the remote part
as it does like with an STD vector if I
have an STD vector even though the the
element in the vector R heap-allocated I
if I have a constant vector I can't
change the elements right it's not just
a little local vector piece okay but a
unique point or I could if I had a
constant unique pointer I could still
change the object pointed to okay well
to understand that we have to define
what constantine's
is that constant only allows read access
to an object and if all I do is read
from an object then I can't modify it
okay so if I read from an object if I
make a copy of an object and then I read
from one of those two copies then
they're still equal okay and further
that if I had a function that was
modifying a that that would not be
allowed by the compiler
that's what Const means okay well with
our indirect as it's currently defined
right we could write an indirect here
called read and it's constant direct and
we could modify star X right because
this thing was defined in terms of
unique pointer so so which means that I
could end up where they're not equal I
can contradict myself so to fix that I
have to do constant propagation right so
I can overload get on Const and my
dereference operator on constant my
arrow operator on Const okay and so
that's called prop constants prop
constant propagation I will get that
right so that's conch propagation now
which just basically means that if I
can't modify the local part of my object
I also can't modify the remote part of
my object so these are the three changes
that we came up with and Jonathan took
these back and this is now making
progress this new type through the
through the standards committee meeting
but at least one person on the Standards
Committee meeting was like hey wait a
minute this isn't what I wanted at all
right what I wanted was the type you
originally defined right which is one of
these things that allows me to that's
very similar to to a unique pointer but
allows me to make copies of the thing
that's pointed to right well there's an
alternative approach here right anybody
guess what the alternative approach is
function maybe something along those
lines so it gets a little more
complicated with polymorphism because
the copy has to be type erased the
alternative specification is to say that
I have clone pointer which is like
unique pointer but with one additional
operation clone okay that works by
copying the object pointed to example
implementation of clone operation is
right there okay so I ran into this hole
because I called it copy okay because
words have meaning words have meaning to
us words have meaning to the compiler
they have semantics okay so I once had
an engineer walk into my office and say
I am writing a function for my class a
member function for my class to copy my
class what should I call that member
function and I said it should be the
copy constructor and he said no I
already have a copy constructor that I'm
using for something else
true story it's a good way to get kicked
out of my office don't do that don't do
that because people reading your code
are going to get confused by what it
means okay and don't do that because the
compiler reading your code is going to
get confused by what that means so
what's in the box a lot of times people
say right especially when we were
looking at the zero and lack of meaning
and unspecified value can't we create a
system where something has meaning all
of the time where we never have a state
where an object has lost its meaning
okay we can do better than C++ does
right but there's a fundamental tension
there the tension is between safety and
efficiency
right first thing it's important to
understand what we mean by safe okay a
safe operation is an operation that
preserves meaning okay an unsafe
operation is one that potentially leaves
an object in a meaningless state right
that is the definition of a safe in an
unsafe operation okay
STD move people hate me for this STD
move is an unsafe operation okay the
moved from object object is left in an
unspecified state unsafe doesn't mean
bad okay
so that's the definition of it so what
happens here if you're doing a
permutation okay any permutation STD
sort is a permutation STD rotate is a
permutation STD reverse is a permutation
stable partition partition these are all
permutations okay they permute a
collection of objects rearrange them you
end up with the same objects you had
before but in a different order okay so
every permutation decomposes to a set of
cycles what does that mean it means I
move some object out wherever that
object is going the object that was in
that place goes someplace else and so on
and so on okay so I can have have one or
more cycles in my permutation now if I
want to do a permutation that means I
have to pull an object out to leave a
hole into which I'm putting another
object and there's the fundamental
tension what's in the box what do I
leave in the hole okay and what do I
mean by that well if I leave nothing in
there okay then this sequence of things
right has lost its meaning and now my
permutation is unsafe okay
but if I put something in there okay in
the hole I can regain my safety but now
that requires a right back and it's
inefficient
okay so STD move letting me move an
object out attempts some level of safety
by saying valid okay but valid in this
sense doesn't give us safety because the
value is still unspecified so it's lost
its meaning okay so STD move is an
unsafe operation STD move is also an
efficient because it requires that I
write to back something into that state
to ensure it's valid
okay so STD move is an unsafe
inefficient operation okay people hear
me say this and they say Shawn parents
had STD move is bad I didn't say STD
move is bad okay goodness and badness
are not the same as unsafe efficient
inefficient okay okay it is what it is
now there's a duality okay between
transformations and corresponding
actions okay a transformation this
functional programming right I transform
one type or one value into another value
an action is an in situation operating
that on something in place okay so for
any action I can write it in terms of a
functional form and vice versa for any
functional form I can write it in terms
of an action okay
so for all the functional programmers
who think that functional programming
provides this tremendous amount of
safety well kind of okay I can always
transform one into the other both of
these are turing-complete systems right
right in a turing-complete functional
language in haskell i can write a c
machine and write all the stupid same
mistakes in the c machine that i would
write in c okay i can always do this
transformation okay why does it matter
because one form or the other may be
more efficient it's not always true that
the Institute in sich you form is more
efficient than the other but it might be
the most common example is STD sort the
most efficient way to sort is to sort
Institute to sort in place okay that is
more efficient than doing sort by making
a copy okay
functional programmers cannot write
quicksort so it's not that I'm lazy it's
that I just don't care good code is
efficient now efficiency can be in time
in memory in power or in any other
resource and oftentimes as engineers
that means we have to make trade-offs
efficiency means maximum effort with
minimum resources
so efficiency of a system is determined
largely by its choice of data data
structures and algorithms and his choice
of what to optimize for right if you
optimize for size resources over
performance resources that changes your
efficiency the operations that you have
available right will determine the
efficiency of things that you can do
with it
so this is how if I have have
bi-directional iterators so those are
supposed to be two iterators pointing
into a sequence and I want to reverse it
in STL this is how SUV reverse does it
just does pairwise swap all the way down
okay and so long as I have
bi-directional iterators right even if I
have additional capabilities for random
access iterators there's really no
better way to swap but what if I only
had forward iterators okay
okay so what if I want to reverse the
elements within a linked list but I
don't want to Reese place my linked list
right I want to reverse them in place
can I do that anybody so everybody
should say of course you can do that
more important question is can I do that
with some reasonable efficiency yeah so
you can kind of see that see the see the
problem there as far as like okay if I
can only go one direction through I can
make multiple passes through through the
sequence how many passes do I have to
make in order to reverse the whole thing
right if I use that algorithm it would
be very bad right I'd be scanning all
the way down to the end doing a swap
scanning down to one short of the end
doing a swap and so on and so forth
but you can actually do it do it
relatively efficiently okay so here's
the algorithm this is mostly cribbed
from alex Stepanov elements of
programming book
this is not in the STL should be in the
STL so this is how we do it right
basically we're going to do a divide and
conquer and and the way to think about
it is if we did pairwise swaps okay of
of all the things and then we built up
and swapped a larger section all the way
down and if you kept doing that you
would end up reversing the entire
sequence writing in graphics there's a
very common trick that if you want to
rotate something 90 degrees and it
happens to be square you can treat them
as like tiles on a board and shift all
the big squares like cut it into four
squares and rotate them around by one
knotch and then within each square do
the same thing and go all the way down
to a pixel level and that will rotate
your entire image 90 degrees this is the
same idea it's just a long along one
dimension so here's how it looks here I
didn't show n of the count I just showed
how the pointers move right so if you
execute that code we come along and we
do a reverse of a section like that and
now we're going to reverse that section
because it's a recursive subdivide and
then we're going to swap ranges all the
way down and we end up with things in a
reverse order okay so it's it's oh and
log N and efficiency so most every place
that I know of an STL where we have
something that's defined for the
algorithms that cut off at either random
access or bi-directional iterators we
could actually provide implementations
all the way to forward iterators that at
least had o n log n okay and I think
most people think about efficiency in in
wrong terms
especially young engineers I will ask
them to plot like order n order n log an
order N squared things like that and
they tend to put like n log n like right
between an and N squared okay that's not
how it works and log an is is log n is
effectively constant right you're never
going to end up with a log n that's a
bigger than 64 right for any size data
set that you're ever going to encounter
right so log n is effectively K it might
be a bigger K than you would like with
just an order n but it's a K for all for
all purposes it's a K it's a constant
okay so this is Microsoft Word again
right so how do we think about the
efficiency of something like this right
well if I'm looking at something like
Microsoft Word and I'm looking at the
operations I'm looking at okay well I
can type characters into the sequence I
can be inserting characters into the
sequence I can make selections and I can
modify those selections okay so I might
think in my head of a very simple thing
where oh I've just got a sequence of
characters it's a vector and I met this
very simplified view and a selection
into that vector okay and it might
actually sketch that out if I were
trying to study a study a system and say
yep I've got a sequence and I've got
these things but I also need to know
what the complexity are of the
operations that are needed for this to
be a reasonable running application
because in reality I probably need a
data structure that's something more
like a rope right and the reason for
that is I need something that resembles
constant time time insert into the the
middle of my thing but I also need
constant time indexing okay which means
a vector would give me constant time
indexing but not constant time insert so
a list would give me constant time
insert but not constant time indexing a
rope would give me login operations for
both of those
okay so it will not be as efficient as
either but because I require both I need
a more sophisticated data structure we
haven't talked much about we've been
talking about efficiency of operations
but we haven't talked too much about
efficiency of types perfectly can a lot
of people don't think about types in
this form but we say a type is complete
if it has sufficient basis operations so
that I can get to any other value within
that type okay strictly through the
basis operations right through the
public public member functions for that
type that's a complete type okay a type
is efficient if I can do any
transformation to get to any other value
as efficiently as possible through those
basis operations okay so if I have an
efficient basis then I say I have an
efficient type now the easiest way to
get an efficient type is to make
everything public because then by
definition you can get to any other
value as efficiently as possible
however you're going to fail to protect
the invariance and this would be a very
unsafe type okay so the idea is to
figure out how you strike the balance on
both of those and again my comment about
STD move being both unsafe and
inefficient and the very last thing that
I wanted to say about good types is that
they're reusable okay so
reusable types they can be concrete a
lot of people say oh Sean's a big
template guy so he wants everything to
be generic not true at all okay so a
good algorithm it's very concrete can be
very reusable numeric algorithms are a
concrete example same with UTF
conversions okay so they should be
generic when the algorithm is useful
with different models okay but sometimes
it's faster to convert from one
representation into another and perform
the operation and to go back than it is
to provide a generic implementation I
see people in graphics all the time
coming to me and say well why don't we
have like a you know template to define
a pixel type right it could be eight
bits it could be sixteen bits it could
be 16-bit float there's different forms
of 16-bit scalars it could be 32-bit
right right why don't we have have some
type like that well most of what you'll
find out is is a lot of times it's more
efficient to actually convert your image
into a canonical form perform the
operation in the canonical form and then
convert back then it is try to try to
deal with it in place okay runtime
dispatch is when the types are not known
at compile time that's the only time
that you should be thinking about
runtime polymorphism is when you do not
know the types of compile time so you
want to minimize the client dependencies
and intrusive requirements separate your
data structures from your algorithms
right too often I find classes where
they've got a beautiful algorithm that's
built in as a member function of the
class and I want to use that algorithm
but I want to use it with my own data
type the worst offenders of these are
all the string classes right how many
string classes do you see with built-in
operations that have nothing to do with
that representation of a string but
they're still useful ops along those
lines this is what a UTF conversion
function is I don't want a string class
that's got a convert me to utf-8 which I
see an
almost every codebase I ever pick up
everybody has their own string classes
and their own and their own member
functions I just want a standalone
generic function that can convert
between UTF representations this is why
I hope that this talk isn't going to
waste but I think it probably is so this
is my dark side here John Bentley wrote
this in programming paroles okay in
programming Perls John Bentley went out
and assigned two classrooms of senior
developers and major corporations IBM
Xerox PARC really first-class people and
gave them a programming problem and the
programming problem was a binary search
ok and what he found was 90% of the
programmers given any amount of time
couldn't write a correct binary search
that didn't have bugs and in many of the
cases of the remaining 10% he wasn't a
hundred percent convinced of the
solutions they provided this is what
we're talking about right very concrete
version but it's effectively the same
algorithm that I showed at the very
start of this talk now if you interview
for the Photoshop team you will be given
a take-home test and the take-home test
is John's from programming pearls it is
to go home in a write a binary search
surprisingly very few people pass it
even though I stand up in front of a
huge number of people at conferences
like this and I tell them that's what to
expect a very few people pass it and I
find it very disheartening but there are
some signs of hope for years I worked
with Alec stepping off on the book
elements of programming which is out
which i think is a wonderful book it's a
very difficult book but I recommend you
all get a copy and struggle your way
working through it I think concepts are
in it are a critical addition to C++ I
was disappointed that they didn't make
them into C++ 17 I think this the
current approach that was going into C++
17 is the correct approach
but they're not dead yet so they're
coming wrong I like the fact that
there's renewed interest in new
languages and new formalisms for a while
I thought language design was getting
kind of stale and dead
there's languages like rust and go and
systems like react and angular and
Haskell which is both in the whole LLVM
work and all the JavaScript transpiler
work so there's just a huge renewed
interest in not looking at things the
same old Java ish reference semantic
language style of solving problems and
finally there's renewed there's a rise
in a reactive programming and functional
reactive programming and if you want to
find out more about why I think that's
important you need to attend my next
talk tomorrow
so my work continues I published a paper
recently with Yakov a with a very long
title there on reactive systems we put
out another paper here on one way to
select many which is about how to deal
with selections within user interfaces
effectively and efficiently okay you can
always find my presentations at the link
there and there's a link to my github
repository which has some ongoing
research work there my conclusion is I
want you all to go off after listening
to this talk and write better code
before I open it up to questions which I
will do in just one second
I do want to let you know that I'm
staying here for the entire conference
so I'm not buzzing out and I'm here for
you even though I enjoy attending talks
and listening to talks that's not why
I'm here
so if you want to corner me and go pick
my brain or talk to me or go get a beer
or sorry to my wonderful hosts I will
even blow off a speaker lunch if I'm
engaged in the conversation with one of
the
attendees here please do that's why I'm
here
I got my breaks in the industry because
I had the nerve to go up and ask people
who were very much more senior than I
difficult questions and that led to
conversations and that led to jobs and
opportunities and new work and so that's
why I'm here to play that rule and to
help you guys so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>