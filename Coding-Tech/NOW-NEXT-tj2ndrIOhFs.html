<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>NOW &amp; NEXT | Coder Coacher - Coaching Coders</title><meta content="NOW &amp; NEXT - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>NOW &amp; NEXT</b></h2><h5 class="post__date">2018-01-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tj2ndrIOhFs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Roush G on twitter facebook
instagram every social network i'm the
CEO and founder of site a company
specialized in cloud deployment scaling
that's very developer friendly as we
will see today and sometimes that right
very long essay so it takes many hour
take many hours to read on Rajee calm
and today i'm gonna focus on two that i
wrote many years ago that are sort of
the inspiration for a lot of the
projects that we're creating nowadays
and a lot of those principles that we
talked about are the ones that are new
software like next make it really easy
to apply to your projects so we start
off earlier this year with this project
called now focusing on nodejs deployment
with ever since scaled it to do many
things the easiest way to think about
this is i like to explain projects in
terms of functions nowadays i'm inspired
by this really need to tweet if you
can't read it it says react is UI as a
function of props in state reacts allows
you to manage your state as a function
of the existing state and a new incoming
action and our developer happiness or
productivity is determined by combining
coffee and the aforementioned two
technologies so the way that I like to
describe now is you give us a source
code and we take it to the cloud so all
it takes is one command take your source
code deployed we give you a URL
every time you deploy you get a new URL
that's why we call it immutable
deployment and the directory in which
you run and now can contain different
manifest files that sort of declare how
your project works we synchronize those
we run a build process and then we give
you back the link so I'll give you a
quick demo of that as you can see the
command there and I'm gonna try to bump
up my font to make this really clear so
I'm gonna go to projects November and
I'm going to create first a static
project when a centered is because I'm a
little OCD
and I always go for the one and only
Marquis with a nested h1 that's how
every project starts so typically what
we do when you're we're on in
development mode is we run everything on
localhost so in this case since I'm not
gonna go for localhost I'm just gonna
open it with a browser so this is what I
see in my local host then Marquis
glitched so how do I take this to the
cloud very easy right now so we give you
a URL right away even before the build
process is done we initialize the
deployment we run a build process in
this case as you can see it says NPM
because what we do for static projects
is we've wrapped them with a package
adjacent so it's a static project to us
is a dynamic project just that you'd
only serve static files so if I go to
that URL that it copies to my clipboard
automatically I should see my glorious
high November Marquis so as you can see
we generate this random nonce so every
time it would deploy and you change
something we'll give you a new one so hi
new one actually for a greater kinetic
effect and see if this works
so I run now again what it does is it
dips my directory it doesn't even
require again so you can sort of as you
can see this is the minimum viable
deployment because I started with a
directory with not even a good directory
so let's see so an asset blink inside
marquee let's call the web platform guys
something went really wrong here anyways
what we could do now is we can declare a
CSS animation that goes from opacity
zero to a hundred to simulate the blink
tag but I digress so we're gonna go
ahead with that
NPM project so as I said earlier you
have a package adjacent or not simple
project and here the only requirement
when I have a package isn't file as I
said a starred script so I'm gonna I'm
gonna declare the most simple API I can
think of so this module is gonna expose
an HTTP API that returns its object so
I'm gonna go ahead and add micro it's a
little framework we use for micro
services as the name implies the
internet here is so fast I'm so glad and
I add my starter script so micro
requires that you just run micro in the
directory and then we should see our API
in action so as you can see it is the
most simple JSON API I could think of so
how do I take this to the cloud again
very simple I run now and it should take
my package Jason install the
dependencies and so on if I if I took
this link right away and say it to you
what do you would see is it terminal on
your browser the same thing I'm saying
here sort of initializing the project
and so on so now I have my cloud
deployment
and it's many JSON API so everything we
serve automatically over HTTP - and SSL
that's a one constraint we have it's
completely spec open spec open standards
oriented there's no especial API you
have to use other than NPM simple HTML
static hosting thing or dockerfile if
you want to use other programming
languages so we take this approach of
trying to find solutions that involve a
very simple unix-style one command
that's one thing approach so what I'm
going to talk about today is the thing
that follows now which we cleverly
called
next and it's a very simple framework
very minimalistic for creating universal
JavaScript applications so because
sometimes the internet doesn't work well
or dongles on work well I typically
start showing this gif of how it works
but since things are going well today
I'm gonna show you how this works
the it's a very simple API that involves
declaring a page and then executing next
the only constraint we've introduced is
that we use react components we use
react components and I'm going to talk
about why because they give us the
ability to serve a render automatically
that's why we call it Universal Java
applications and then we have lifecycle
hooks with which we can sort of
resuscitate that server rendered page
and do really interesting stuff later on
so I'm gonna show you the basic way to
get it started with next I'm gonna call
next high next time
I see how long it takes shouldn't be
quick
10,000 dependencies Wow
all right so 20 seconds not too bad and
like I said earlier the other thing that
we're going for is that you can start
your project with just one command so
I'm gonna say here that next so let's
see what happens when I run next
actually I'm gonna first create that
pages directory I'm gonna run that next
command what it's gonna do is it's gonna
initialize a very simple HTTP server and
it's gonna initialize automatically
webpack and babel transformations on my
behalf so that all I have to do really
to get features like hot code reloading
and so on is just go to my project so as
you can see here I get a 404 by default
I'm gonna go with a split here and let
me know if you can't read well at any
time and I'll just keep increasing the
font until only one character fits on
the screen at a time so the first
decision that we made with next is that
performing code splitting should be very
very simple and built-in because the
problem with most single page
applications is that you end up with
this gigantic bundles of JavaScript code
that load for every URL and every single
section of your website whether you need
them or not so we start with this idea
that every everything that goes
underneath pages becomes the top-level
components or entry points to your
different bundles and all these pages
have to do is export a react stateless
component or a react stateful class
component so let's see what happens when
I save this file as I said earlier we
have this notion of sorry here man I
have to run and BM run dev because they
have a different global next-day belief
so here I have my react stateless
component and whenever I save or make a
change to this file it automatically
reloads including with errors so here
I'm gonna make JSX
barf and it's gonna tell me that I have
a syntax error I can
directed and then one one second yeah
okay so the next thing I'm going to do
is I'm going to create a new page just
to show you how the writing system works
so I'm gonna go to and define routing so
now I have my routing page and my index
page the neat thing about next is that
when I curl this page you're gonna see
that in addition to the component code
the first thing that we actually send
out of the wire is the static CSS that
is generated for that page and the HTML
for that one page so really what this
gives us is a very easy way to even
create server and applications that
don't involve any client-side JavaScript
at all
and we have a very simple way of
managing data dependencies and so on so
I'm gonna go over some of the features
that we built into next so the first
thing I mention is that every app that
you create with next is out-of-the-box
Universal when you run next to get in
development hot code reloading built in
we have a mechanism for loading pages as
you go with that with something we call
the link tag which is similar to other
like the react router link higher-order
component and then we have a very easy
way of taking a new production so
typically you have to set up different
development and production of pipelines
when it comes to the build process and
something we set out to do with necks is
that we wanted it to be very simple for
development so involving just one
command but also when it's time to for
example minified the code and compress
it and then embed it on your pages and
for example creating also the routing
Maps that are like super optimized for
production you only have to use two
commands so next build and next start
the ideas of next come from this one
essay that I wrote that I was telling
you about that basically give you seven
principles that we think are critical
for creating a really great experience
what we call at the end of that article
a unicorn web application so explaining
it in the terms of now earlier on next
is a framework that takes your code and
gives you this unicorn application the
first principle that we talked about is
that server rendering is not optional
and I say this not because primarily for
SEO reasons for example that if you set
render you're gonna have an easier time
with spiders crawling your content so
that's one neat thing but really it's
about performance because as I mentioned
earlier when we start when I started
consuming your site or application
within the first packets of what I
download I get stuff that it can render
so I get HTML and CSS and later on I can
asynchronously parse compile execute and
download more JavaScript so there are
three main reasons for this one is the
URL is already telling the server what
the user is interested in so if you
return the same single page application
for every URL you're missing out in a
potential big surface for optimization
so if I load for example slash users or
any patent ID the server should already
return or push the data that this
request is gonna need the second one and
it's very tightly associated with that
first one is the server already knows
the capabilities of the client so it
might turn out that that user profile is
only accessible for example to a subset
of users or it might be that it's an
authenticated page so what the server
returns is also user capability
dependent and one very important point
is that the majority of applications
that you already use in browse everyday
to different degrees already do server
rendering whether you might be not
noticing it or not so one of them is
obviously hacker news hacker news is the
system on which we announce every single
new JavaScript framework yet it's
created with technologies in 20 years
ago so that sort of dichotomy or paradox
I'm gonna try to answer today and try to
answer when do I go sir
serve rendered what is the motivation
for really adding more JavaScript and
under which scenarios should you
consider something like next if for
example this is working really well
already another example would be github
so what I did here if you notice that
icon in the top right of Chrome it I
disable JavaScript just to get an idea
of what this mainstream sites and
applications are returning with some
requests so for example github has
complete sort of synchronicity between
server and what it does later on the
client similarly the next when you make
transitions between pages they load them
on the client-side and they also extend
the resulting HTML with for example a
changes when you make a new commit or
you make a new comment it's a very nice
example of a convergent site and
application reddit and what will write
it have certain different degrees of
server rendering in this case this is
returning the layout of the page that
I'm interested in and Facebook has a
very simple approach to sort of
returning the authenticated layout or
the non authenticated layout so this one
is really interesting because it might
not appear that there is server
rendering involved but even just a
slight amount like even just returning
the layout can have very dramatic
effects on perceived performance or user
experience so I have two examples of
what I consider unacceptable in this
regard so one is Gmail because what it
gives us a great page on which it loads
the progress bar so Jeanne already knows
what the eventual Lea is going to look
like Gmail could already cache a lot of
stuff on the client side they could
certainly give you a much better
experience than a progress bar or even
worse a lot of applications just give
you nothing and then they load
script with something else this is a
theoretical website doesn't exist
apologies I didn't go to the website
apologies a creative him to our website
calm maybe he created a terrific server
rendered mega react web application
application so the other five principles
sorry from two to five I spent some time
making the case for okay if it works
greater with just the server rendering
why would I add any JavaScript at all so
like I sort of even ditched the
assumption that we wanted to use
JavaScript and try to re understand why
we're adding it to begin with so what I
ended up with is for example the
critical UX I experienced of optimistic
rendering so if I click on something I
don't have to make a hop to the network
to make some change in the UI and the
only way to do this is obviously with
JavaScript and using stateful caches on
the client-side
similarly offline and changing the data
after it's been sort of rendered are
things that it can only do if I load
more JavaScript and then I sort of
presented two new ideas for things that
are obviously again JavaScript only that
are very interested very interesting
research sort of areas for the future
one of them is hard code reloading in
production and the other one is
prediction and anticipation of user
behavior and what data can be retrieved
ahead of time as a result of that so an
example that I gave is predicting the
trajectory of user input so this is a
jQuery plug-in that uses collision
detection to understand where the user
is likely to click in this case it
toggles a UI elements but similarly you
could for example fetch data on the
background as the input moves so the big
question one once I established this
requirements was if I start with a
snapshot of HTML and CSS how do we
resume how do we can create a
continuation of that rendering once the
client-side page loads
and that's something that react answered
for us and I explained it in this I
explained its advantages on this other
as they called pure UI and there are two
critical things that react Ava so one is
the idea that render is a synchronous
function that takes props and state and
always returns a snapshot of my UI at
any given point in time the render
function is not concerned with data
fetching and this is the interesting
part because data fetching on the client
and data fetching on the server might be
different as I mentioned earlier
sometimes you want to sort of render
less data sometimes you want a server
and they're the same amount of data so
it's very important in a render function
can always examine what that what that
combination of props and States looks
like and then return a certain
representation of HTML so all we have to
do to continue 8 that server rendering
code is re-execute the render function
with the available props and data the
problem state but the second one that's
really critical is this idea of
lifecycle hooks I'm sure I mentioned
primarily how you can expose a function
as a next page but you can also expose a
react component and that react component
will have lifecycle hooks such as
component did amount so we can make we
can have two distinct now code paths for
what's happening on the server and
what's happening on the client because
component did mounds is only going to
execute in the client side and something
we can manage there is for example
subscriptions so you can connect to a
source of real-time data there and then
upon component will and mount you tear
down this description so those are
things again that only make sense on the
client because setting up a real-time
subscription of data on the server would
be meaningless if we just have to give
the user a static representation but
there was one critical missing piece
which was the server needed a way of
understanding what the starting point of
that data is and we thought really long
and hard for weeks perhaps months
perhaps years in this state
and what we came up with is if you
remember the initial class API for react
it had to get initial State and that was
a way of saying okay my component starts
with let's say a user ID of some kind or
at certain date you can repopulate the
state so what we added is a counter part
of this which is how do we pre populate
State on the server or pre populate
props in this case and this is what a
page that retrieves data universally on
the client and server looks like
provided that fetch is exposing the
server which we do with isomorphic fetch
now you can expose a simple function
that makes an API request as you can see
here I use async and await this also
solves a very interesting problem that
we had in node for many many years which
was how do i express the business logic
for retrieving data for a certain page
first of all it is really involved not
having promises in the beginning and
then obviously not having this in tactic
sugar on top
but then error handling was very
difficult because if any of those lines
throw in the case of a callback oriented
approach it would crash our entire
server so what next does instead if it's
if an error occurs within get initial
props it automatically handles 500
errors on your behalf so this is sort of
reminiscent of how PHP pages work with
the difference that here we have this
symmetry between client and server and
the ability to add more code on the
client even prior approaches in no js'
or PHP what they required was you would
implement some sort of template language
on the server and then you would have a
completely separate code base for your
client-side code so you would invoke
jQuery you would invoke different build
pipelines for like sort of your
client-side code it was very difficult
to share the logic for templates and
partials and so on and this is a general
solution for all those problems and what
this sort of who starts answering is
what is the difference between a website
and web application because earlier I
showed you the example of pattern news
it would be very hard to make the
argument
News made the wrong decision by just
server entering everything but similarly
it would be hard to say that Gmail
should go all silver rendered because we
want all these features like offline
support and so on so I ended up with a
very interesting definition for what I
think defines the application type
features and what those things that are
unique to applications are so the first
one is global state which is the having
the ability to cache data on the client
side and then persisted across page
transitions when we use redux were we're
doing effectively is we're retrieving
data and we're having this other new
step for sort of transforming it and
caching it manually and this is critical
for our user experience because as I
mentioned earlier if you want to perform
for example an optimistic change in the
data you first have to perform it on the
local cache of the data that you have
you have to perform it on your local
redux store and then when the data is
for example act by the server you might
update it as a result but the other
really interesting I think principle
that we sort of automatically assume
when we talk about applications is that
they typically have everything pre
downloaded so and this is a critical
features for offline support because we
want to have every single section of
your application pre-downloaded if we
want to have great offline support an
example that it like 2% here is why does
white do native applications typically
get associated with great offline
support and the reason is that the
process of installing an application is
I pay a very big price ahead of time
when I first go to the App Store and I
download everything I done with things
that I might never actually ever use so
I use this example because someone
performed a dump of the debug symbols of
the Facebook iOS application and they
put it up on a gist so these are all the
header files of all the classes that are
already pre compiled in that bundle that
you download when you get a new
phone so as you can see there are things
that you might never ever ever actually
even use but they're there so because I
was curious I did this on your behalf I
downloaded the gist and I sorted it and
that's the longest class
it's a profile set events calendar
subscription status annotation of
domestic payload factor II protocol
protocol so this is why we decided to
introduce this idea that we had to
provide a way of declaring the links
between pages because we wanted to have
this ability to maintain state across
transitions this is where server
rendering alone falls short because if
you click on a link go to another pages
serve rendered you lose that global
state so the first thing we introduced
was this link component and all is all
it is is a higher-order component that
when you supply the aged ref to another
page if it's clicked on the client side
it tries to simulate to the best of our
ability what the browser would do so it
gets a page it doesn't get the data
which is a very interesting idea here
because getting chilled props is what
gets the data and this is what allows us
as I'll show later to precache this
links very aggressively because we can
download the component without
downloading the data so as I said
earlier if we didn't have link we
wouldn't have this ability to perform
client-side transitions and prefetching
allows us to when we render a page
analyse future paths and pre download
them so this sort of merges but at the
best of both worlds because we get the
website type approach where you download
only what you need but we have the app
style download classes that you might
never ever go to on the background and
we have a module coming up that this is
automatically on the serviceworker and
again I'm gonna show you how it works
for our application so when I first
render our homepage this is all I
downloaded is this one home page as you
can see if I click now world
it's it seems like it's a single-page
application because it was already there
i clicked and the code was already there
but what we're doing behind the scenes
is we're analyzing what those link
components are and we're prefetching
them and sure we are at the risk here of
downloading things that you might not
need but since it's happening on a
different thread on the backgrounds
because we use e tax and HTTP caching
we're paying a very very small penalty
for a really great experience because
everything is downloaded except for
images so i encode splitting in
particular comes really handy here
because when i'm first downloading that
page i'm only downloading the imports
associated with it
so an example from our application as
well is code mirror is as big as an
entire website pretty much so we use it
on the api page because we want to show
you how you can deploy even from the
browser so you can even edit here
whatever but imagine if I had downloaded
code mirror every time someone wants to
go to the about page it would be really
silly
so next automatically creates this
bundle and link is in charge of sort of
downloading all the code and it's
dependencies on your behalf on the
background and this has a tremendous
kind of scalability benefit not just on
the perception of performance and so on
but for your teams because when you are
working in a team you don't know that
the other person might add jQuery and
ember and react and pre-act and inferno
and another page and it's gonna ruin the
performance of your page so this sort of
creates a very scalable development
effort as well there are two other
critical pieces that we want wanted to
include that are we consider obviously
needed for every single website one is
you have to be able to introduce effects
on the global page on the head of the
page so we have this high order
component on which you can specify
everything I would go in
side the head of the page so this is
useful for for example the meta tag for
a mobile viewport title and so on and
this is very important that we provide
out of the box because the behavior on
this on the client side and the behavior
on this on the server side is slightly
different as you perform transitions
between pages were able to append to the
head of the page but when you serve a
runner you want to have that of course
come in in the first and the way we use
this is for for example Global CSS
effects a global CSS effect is having
the font configuration for example you
typically want to have that as a global
setting or the font face definitions and
so on
but even for example the body background
the body background we use as an effect
on the head and that's how we can have
pages that have a dramatically different
makeup of some sort so in this case
we're changing the body background using
the head component and then we have a
built-in approach for CSS nsj and the
main reason for this is that we want to
incorporate this idea of encapsulation
of styles so every component must have
only styles that effect that one
component our longer term vision as I'll
show later is that we can use actual CSS
here but shadow DOM and shadow CSS
cannot be server rendered so we sort of
had to provide a realistic solution for
today of how we can have the full power
of CSS but in a way that we can make it
work really well with encapsulation and
server rendering so we chose glamour
because it gives you it has no
trade-offs in what you can use what CSS
features you can use so you can in this
case I show how you can use however you
can use media queries you can use font
definitions you get anything you can do
it CSS you can do with this the demo
that I prepared for today is the one
where we started earlier and it's what I
called next news so you can again you
probably know where this is
tagging is Oh address already yes we
should production Iser error if the port
is being used file an issue so I mean
I'm gonna first walk you through the
structure of this application and the
structure itself is really interesting
because this is an application that is
very easy to understand what it does
with that without ever having seen it
before so I'm gonna open it with finder
so we have this Lib directory where I
have all the files that have to do with
data fetching and this of course is
something is a structure that I created
for myself for this project but it turns
out it's really nice on the components
directory what I did is I populated and
this is what I talked about in the
period is a is all pure components that
perform no data fetching whatsoever so
these are all the building blocks of
this application the header the logo the
buttons the story the list of stories
and so on and I'll go and I'm going to
show you the code in a bit and then the
pages are all the routes which
interestingly for cloning this
application I was able to clone the
exact say your L structure I try to
perform the most exact clone I could of
hacker news and I introduced one
distinction for the purpose of Education
as I'll show you later but the idea here
is that every single this URLs match the
URLs that you're used to and you might
have noticed there I had a real-time
update I'm gonna talk about how that
works
so all these URLs are the URLs that
Hydra News asked the one I couldn't
clone was comments because they didn't
give me the API so this is using the
firebase API for sort of retrieving the
data so let's start with this newest
page as I mentioned earlier we have that
static async
get initial props function which
receives some contacts which can be the
context of the server like the request
object incoming requests or it can be on
the client side the event that triggered
it in this case I'm invoking that
component from lib yet stories I'm gonna
show you what that looks like
essentially calls firebase gets me the
data returns it as a series of objects
and that's something really interesting
about next is that unlike other
solutions that try to try to set out to
do this
there is no opinions here about how you
should retrieve your data so in get
initial props as then who's on the
audience showed for example you could
initialize that Redux store if it hasn't
been initialized yet and then return it
as a prop and then you can use redux as
a global state store or you can use
fetch or other type of api's and make
RESTful API calls and return an object
or it could use relay in graph QL and so
on so the only contract here is that
gadget props
either returns an object or returns the
promise the results an object and then
the render method gets those properties
so page and stories that I returned
there and notice here that again I went
ahead and returned a stateless component
a pure component there because that
gives me a flexibility to edit my
components without the real data you can
imagine that you could create a page
called style guide and then you could
include all your components that are
pure this is sort of why I recommend
that sort of approach and you have
built-in style guides or built-in
showcases of what components make up
your application without actually
retrieving the data so I mentioned
earlier that there is a slight
distinction between next news and hacker
news and what that is is that when I
click and if I saw it there when I click
an item I showed that loading little
text and the way that I did that is by
inspecting that contact
in get additional props if I have a
request I get the comments if I don't
have a request I don't get the comments
so this is an example of how again you
could achieve those different levels or
different degrees of server rendering if
you were writing a next Facebook what
you would have done is you would have
looked at the request went acade the
user and sort of returned a different
layout the newsfeed layout or the
unauthenticated layout and then upon
component did mount you would subscribe
to graph QL queries for getting the
actual data for example and then what
this gives you as well as for example by
examining requests that headers that
user agent you could return more for
mobile for example because latency is a
silent killer of mobile so like you
would have if you go back and forth on
mobile a lot it might hurt you so it
gives you a lot of flexibility on how
you want to structure that and the other
really interesting thing and this sort
of answers why would you write this and
next instead of writing it with some
Lisp server that outputs HTML twenty
years ago and one of the examples is
that I have a component called this is
the only one component in here that it's
not pure which is the updating story
component so what the updating story
component does is it invokes this
observer on gate item it's here at the
bottom observe and the only difference
is that when we first get the data for
the server we use once if you have ever
used firebase is it only gets the data
once and when we subscribe without serve
we get it more about and I created here
what I create is very similar to an
observable because what I return is a
thunk that tears down the subscription
so here on component did mount I
observed that ID that I get when the
component is mounted which I'll show you
it's on stories I think
so you see here I'm there's very little
real estate so I get that story
component with from updating story and
then down here I embedded and that story
object is passing it the ID with which I
subscribe and then when the component
gets unmounted when is what is an
example of a component getting amounted
I go to submit if I go to submit all
this firebase the scripts I'm getting
torn off if I go back they become again
and so if comments occurred like it
happened in earlier hasn't happened in a
while yet or if I want to even update
how much time elapsed since the last
story I'm able to make those changes
upon component that mount so this
answers the question of okay sure server
rendering worked really well but if I
really wanted to for example render and
update the data faithfully as it changes
over time next gives you that life cycle
hook for doing that out-of-the-box so I
couldn't come up with another clever
thing here but so what's next for next
I'm gonna talk about we have this
foundation in place the API is not going
to change but what we're gonna give you
is some hooks for more flexibility and
some change some of the underlying
pieces that make up next the first one
is custom routing through the server
yesterday or actually today we sort of
agreed on what that API is going to look
like essentially you're going to get
you're gonna you're going to have the
ability to instead of running next start
you're gonna be able to run node your
own server yes and we can sort of
initialize next programmatically and
here is an example of how you're going
to be able to render a custom route in
this case if the request URL is called a
I rendered a component B which is sort
of the non default behavior because a is
going to look for a and their pages so
here you can do
how to matching you can do fancy routing
and so on and also you can attach your
own sort of for example web web sockets
or you can sort of go crazy here I
certainly don't advocate for that
because the neat thing about next is
that it's only a server for the front
end at getify who's here call this a
middle end I think a few years ago he
was talking about this server days only
sort of in charge of rendering your
front end code but anticipating that
you're also going to need some server
features so this is where you sort of
programmatically declare your middle and
server the second one that I would like
to see moving forward is agnostic JSX as
you saw earlier I had to sort of import
react for every page even though react
is mentioned nowhere on the page because
we're sort of making the assumption that
JSX gets compiled to react dot create
components but JSX is a amazing feature
that could even be built into the
language if it's done in a very general
functional oriented way in the future so
what we would like to see is that we can
get rid of that line and this actually
we might be able to do sooner rather
than later because we might be able to
depending on what renderer use react
pre-act inferno we're gonna compile it
to the right thing but we're not gonna
impose the burden of having to write
import react on every source file even
though react appears nowhere on source
file the second one would be very nice
when react I think this is gonna come
later on when they ship
react fiber is fragment support nowadays
when you declare a next page you have to
always wrap it in a top-level element
and also when you return a render
function as well so we would like to see
that you can return many elements and
that would be really nice for here I'm
missing the fragment syntax or you may
you might have to return an array and so
on but the idea is that we would get rid
of that extra wrapper a component this
one I don't know if it's ever gonna
happen but it would be nice to get rid
of name as well
for classname to prevent carpal tunnel
syndrome the next one would be actual
CSS and the reason for this is that
first of all to a newcomer CSS in JS
might seem intimidating or they're just
simply not used to it and they're not
gonna be very productive and the other
reason is that ideally CSS isolation
should be a feature that the web
platform has regardless of anything we
do so we have different ideas for what
the API would look like here maybe you
have to wrap the component with a shadow
Dom decorator of sort but the idea would
be that you just include a style element
that has CSS that only applies to the
markup defined within that component and
not nested components so there are some
ways of approximating to this today but
they require for example having the
discipline of always using the direct
descendant selector and so on but if we
were able to wrap every component as a
web component that we can serve rendered
with CSS we would be able to sort of
have this complete CSS syntax that only
impacts your component which is I think
very nice and the code becomes very
small so as I mentioned earlier
introducing effects on the head of the
page is something we're always gonna
need so this is what the most
minimalistic page would end up looking
like pluggable renders is something that
I'm very interested in just because
there are different sets of trade-offs
for different applications that might
make you for example in some case save
the initial bundle size or maybe you
need more sophistication for the
rendering pipeline and you might want
something more so the bottom line is
that we can take that JSX and this basic
API and just render it with different
things we're also introducing just like
weapon has web.config yes we're giving
you next configured rjs and you can say
these are my Babel settings and these
are my web pack settings
as far as translation and this is the
reason that we don't expose babble out
of the boxes we would like to see us
tracking whatever
both latest node and latest v8 support
so that we can actually save a lot of
work while you're developing and to
actually not transpile anything if we
track v8 and now node is very tracking
it very closely we can have this really
great out-of-the-box experience and you
only pay the penalty of transformations
when you have to run next build to build
a bundle that works everywhere or JSX so
that's why I would like to see us at
some point in the future making JSX
extender because our words were always
going to be in this sort of situation
that you always have to set up a
combination pipeline to do this tree of
elements the if you want to learn more I
introduced the framework with the
with that blog post and you can go to
site slash next Jas to learn more about
it and the most important takeaway here
is even though I said next take source
and returns unicorn obviously there are
no silver bullets
there are many justifiable scenarios for
for example renderings to static files
as opposed to running servers so there's
no silver bullets trade-offs our goal is
to sort of support the entire spectrum
of applications and frameworks with
ideally if you have very if you have a
lot of JavaScript we want to make that
process a lot faster so we want to make
it feel like you're sort of doing always
a static hosting even though you might
be running very sophisticated servers
and also improve the web platform as a
result so if we continue to examine all
this interesting requirements and ideas
we can always go back to web platform
make it better and that would be thank
you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>