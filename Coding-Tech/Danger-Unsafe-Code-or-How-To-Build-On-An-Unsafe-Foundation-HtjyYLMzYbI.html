<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Danger: Unsafe Code (or How To Build On An Unsafe Foundation) | Coder Coacher - Coaching Coders</title><meta content="Danger: Unsafe Code (or How To Build On An Unsafe Foundation) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Danger: Unsafe Code (or How To Build On An Unsafe Foundation)</b></h2><h5 class="post__date">2018-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HtjyYLMzYbI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thank you for laughing I got the
impression that that there might be some
people in this room who have you C++ so
if you've used C or C++ professionally
you could you just raise your hand all
right cool
so the rest of you just look around like
the people that raised their hands
they're like these people have seen some
stuff they know how the sausage gets
made they know that all of software is
built on this giant pile of sausages and
that knowledge haunts them so for the
rest of you I just want to give like a
quick impression of like you know what
C++ has done to these poor people thread
so like say you're writing some C++ you
have a very well nice integer here and
you want to print the value of that
integer which for some reason and C++
looks like this well this is terrible
this is a calamity you forgot to
initialize the variable so so you're
probably thinking like
[Laughter]
you're probably thinking like well C++
is going to like throw an exception
that's very sad
or maybe it'll print zero or something
or maybe we'll print like if you're
really thinking you're thinking like
okay so it's putting the value of a
variable we never assigned anything to
that variable so maybe we'll just print
whatever random bits it finds in memory
well it might C++ might do any of those
things or all of them because this is
what's called undefined behavior using
an initialized value undefined behavior
is something that is talked about a lot
in the C++ standard and what it means is
basically your program might do whatever
all right but this isn't the only way to
get undefined behavior it's actually the
several things that can happen there's a
couple more I'm just going to talk about
like one or two so say you've got a nice
variable an integer here I initialize it
this time right but I'm about to do
something very stupid about to add up
some numbers right this is what a loop
looks like and in C++ and I'm like
adding up numbers and this will work
fine until the total gets too big to fit
in like 32 or 64 bits whatever an
integer is and then guess what I'm
defined to here so don't do that
one more real quick since I've got 30
minutes to fill so math is tough let's
do something really simple this time
let's just like pass an argument to a
function so this code right here this is
fine this is this is this is safe like
because this is clearly crazy right but
this is totally fine and will always
work unless unless you're passing this
unless this function takes its argument
by reference because then what could
happen is it could be like storing the
reference somewhere to use it later
right now in a language with garbage
collection that would be fine because
you know you have a reference to
something and the system basically just
keeps it alive as long as you need it
and C++ once this code is done running
this and the the string lief scope that
string is dismantled and the parts are
taken away so it's like it's for real
gone so what happens the next time your
program tries to print a prompt
undefined behavior so don't do this
there's a couple more things haha I'm
just gonna go through them quickly
because life is short I had to make the
font size smaller accessing off the end
of an array nobody ever does that right
undefined behavior don't assign the
assigning things is some of these things
they're like yeah don't don't modify a
container while you're iterating over it
you'll get undefined behavior oh and if
you try and use threads in C++ that
comes with its own whole set of rules
and there it's actually like really kind
of the hardest thing to get right and
C++ so
so don't do undefined behavior kids but
how bad is it really well I had two pins
there they're like several things that
could help me well anything could happen
right but in practice usually one of
three things either your program just
crashes and dies and this is the good
case because you're like it's kind of
like an exception you notice it right
and there's actually tools a good tools
to help you like debug that the slightly
worse thing is like your program read
some uninitialized memory and treats it
as data right or it like writes some
information and then we in club or
something and then your programs just
gonna be flaky from then on or it you
know maybe right maybe maybe nothing bad
will happen and if a book if it doesn't
bite is it really a bug so then there's
the other case like the other bad thing
that can happen is that your program
could turn against you this really
happens because the thing is like the
reason there's such a thing as undefined
behaviors what's going on is the
compiler takes your program you know it
looks at this like integer addition or
whatever and its job is to think real
hard and like work on that code and then
spit out a sequence of machine
instructions that carries out what you
want it to do right so with undefined
behavior the deal is the compiler sees
your code it think it works really hard
on that code and it just assumes that
you would never do something so stupid
as to leave a variable initialized right
because the compiler thinks very highly
of you
but then when you run the program what's
going to happen is like obviously the
behavior of compiled code that assumes
something false is going to be
unpredictable not predict not useful in
practice right not good for us as
programmers but it's still a program
right and unscrupulous persons could
like look at that sequence of machine
instructions and figure out what your
program is going to do after it goes off
the rails and this happens in practice
so so rust right this concludes our
crash course in C++ see what I did there
so we know rust this is a safe language
because it says so on the label right
here
I thank you for the slide you know it's
funny like in other contexts the word
safe like the meaning is pretty obvious
like if you're a young hero and there's
an old guy and he says to you it's
dangerous to go alone I want you to take
this you don't ask like what dangerous
what do you mean dangerous because the
fact that he's giving you a sword kind
of answers that question right hit like
it's not the roads the monsters
but if someone says like it's dangerous
to go low and take this and gives you
like moves and ownership and references
and a borrow checker and really long
error messages you might be a little
perplexed so so the first thing I want
to tell you here is to like resolve that
in history for you
Rus notion of safety is best understood
I think as a response to C++ and I
define behavior right so what it's
protecting you from is undefined
behavior and some other stuff but mainly
it's the monster right we've always
known that writing a bunch of C++ is
risky it's the consequences are bad if
you screw up and programmers make
mistakes but it's starting to look like
now that we're a couple decades into
this internet thing now that we're
seeing the consequences starting to look
like we're writing a bunch of C++ code
is just a bad idea and we need a better
way right we need a language that's as
fast as C++ without the monsters would
that be great without undefined behavior
well funny story so has anybody used
unsafe code and rust I know at least one
person who gave a lightning talk all
right okay okay good cool so for the
rest of you what is unsafe code and rust
well unsafe code is code where you screw
up and then mmm thank you you get
undefined behavior and like the saving
grace is well we put a label on it and
as it's unsafe but this you know brings
up a question which I'm sure a lot of
you have which is like why do we even
have that lever hike you know language
designed from scratch for reliability
like why why would you ever include
undefined behavior and for that matter
why does C++ allow it like what what
what is the purpose so then I say I want
to talk about is like is why we do that
and it's gone it's got to take a while
when I get around to it first I want to
show you some code so this is actual
real live code from the standard library
except with the comments removed so it
found a slide and this is from the vex
Ibis is the generic type it's a vector
that holds values you call this push
method to push a value of type T on to
the end of the array right so what does
this actually do how does this work well
the way the way of vector works is
you've got some memory set-aside and
you've got some existing elements in
there and then you've got some extra
room right and push is going to use that
extra room to store the next element but
the first thing this function does is
check to see if actually your memories
full because then it has to allocate
some more memory right and it needs to
basically it works by doubling the size
of the buffer okay and then every time
every time you put you push a value into
array this code runs and it gets a raw
pointer into the like to the vector and
then it does some pointer arithmetic
like C++ style uses an unsafe method
right to like write data to an arbitrary
address in memory and then just for good
measure it bumps this private field like
the correctness of which is absolutely
critical to Beck not crashing so is this
way is this sort of thing going on
anywhere else in a standard library
what do you think that's not going oh
boy well Russ is in good company think
about it like what's a safe programming
language Java what language do you think
the JVM is written in quarter million
lines of C++ Python half a million lines
of C right here's here's the Ruby
documentation for the the their push
method was something I love that Ruby is
you can you can view the source of
anything and their documentation is
pretty neat
oh wait rust has that too so let's look
oh it's see ya so what about like what
about a language designed by smart
people right like what about Haskell
right has yeah yeah so Haskell yeah it's
a little special it has like a the
Haskell runtime is actually written in
Haskell psych it's fifty thousand eighty
thousand let's see it's a coverage
collector you can write that in Haskell
and that's not even all of it right just
like all these languages all these
programs right they run on top of an
operating system it's Linux Mac OS right
it's millions of lines of C when we
think of like a safe language is being
like this cozy secure experience we're
like ignoring all of the supporting code
that has to go underneath that right
it's a little bit of a fairy tale the
truth is more like like Saruman tower
and Lord of the Rings where you're like
okay that's a nice tower like that's
clearly designed to be robust but then
like underneath it you got like this
maze of goblin Warren's and like there's
building code violations everywhere
oops so so what like why is it like this
is unsafe code under every rock like and
if there is like how safe are we really
is there any point in using a so-called
safe language should we all give up and
go be goatherds that's the real question
here and if not then how do we engineer
safety in unsafe environments and unsafe
code that's what it's talks about you
you made it to the title slide
congratulations okay so that's a lot of
questions that you just asked I'll try
and answer them first I'll start with
like why unsafe codes a thing so there's
like two basic reasons one of them is
you know speed it's like just kind of
the fact that that sometimes the safe
thing to do sometimes the safest thing
is you check again right like you check
the array access you make sure it's in
balance you redo the lookup to make sure
the table hasn't changed right and in
cases where you the programmer know that
that's extra work that's not necessary
it's just gonna make things slow you use
a little bit unsafe code and it goes
faster so that's one reason but then
there's another reason is that there's a
lot of code that like there's a whole
kind of code that you may need to write
that isn't a very good fit for rust
safety system because that safety system
the like the moves in ownership and the
borrows and all that it makes some
assumptions right and the assumptions
are things like well all your code is
rust then then we're okay right because
obviously rust can't verify anything
that's going on once you call in to see
and there's a whole bunch of C code
that's loaded into every rust program as
soon as it starts to run ran so so so
that's why the interface between rust
and other languages is always going to
be on safe functions the other big
assumption is that there's no such thing
as uninitialized memory like this is
actually a really great thing about the
rust programming language it protects
you from having that right
but remember the vector remember how the
vectors work is by having a little bit
of extra memory a little extra room to
use to put in more elements
that's uninitialized memory how do we
implement vectors in a language where
you're forbidden from seeing that see
there's a like there's a comfort zone of
like normal code that's the bulk of what
we do
we're Russ safety system is a perfect
fit right and then there are these there
are these parts sometimes you just have
to say like what I need to write code
that's gonna cross some lines here right
and I just need you compiler to trust me
I'm gonna use some unsafe code to do
that when you run the Russ compiler on
your program what that what all that
what all that safety checking is doing
well the type system is doing with the
with the borrowed checker is doing the
reason you have arguments with the
borrow checker is that rust is building
a proof of the soundness of your code
right and all those all those elements
the language they're parts of that proof
and you're convincing rust that your
code really is safe that's what it is
unsafe code makes a gap in the proof as
a as a part where like the russ compiler
just can't be sure it's right it doesn't
know right you were responsible for the
correctness of that
this unsafe block and rust it really
should be called trust me right because
like that's what you're saying you're
saying like here you know I've I have
looked at this code and I've looked at
this pointer right and I've thought
about it and it's correct trust me
now I know what you're thinking I don't
trust that guy which is fair a little
hurtful but I mean it's it's it's
telling that it's in rust that we have
this conversation right up and right in
C++ for years I never had to type trust
me like I'm just gonna XOR these
pointers together the compiler trusts me
it's crazy and rust is not quite so
trusting right rust checks even in an
unsafe block the type system is still
there right like types are still checked
lifetimes are still checked the only
thing that's unlocked for you in this
mode is you can call unsafe methods and
you can dereference raw pointers so now
you know how to shoot yourself in the
foot and rust my last few slides here
are about how not to shoot yourself in
the foot with unsafe good these
techniques by the way they're all
classics oh yeah well there's nothing
new from here on out in like in good
rust tradition this is like
well-established stuff so the first
thing to keep in mind is don't do it
but you know we already talked about
reasons you might have to and the things
you need are you like you need to know
what contracts are and you know what
like what the contract is just the
requirements on a function that you have
to fulfill as the caller to use it
correctly you need to know how to use
invariants in the types that you create
to make sure that what needs to be true
for that unsafe code to work stays true
and you need right you need this thing
that comes from small
functional programming languages called
be like make invalid states
unrepresentable these are like the
common thread here is simply like you've
got to be able to reason about your code
because you know you're playing in
territory where the compiler is not
doing that for you now these four
techniques I think contracts could could
use a little more explanation so let's
go into detail about that when I was
getting started in rust I liked one of
the things I couldn't I didn't couldn't
figure out immediately was whether or
not a function I'm writing ought to be
unsafe because like here's the here's
the push method here's two versions of
it one on the right is the one I showed
you earlier the real one but another way
to write that is the one on the left
where you just like put the unsafe
keyword at the top there and then the
whole body of the function is covered
and this bit like this the language is
basically just letting me choose whether
my functions safe or unsafe right which
is kind of surprising for us it lets you
just pick like I'm gonna be safe today
like and and the rest of language then
trust you right so this is this is how
this is why that matters right because
the function signatures are different
right the one on the Left everybody who
uses it would have to know whoa that's
unsafe now I need to decide like how you
know am I do I really want to call this
and if so I've got a stick a trust me
block in my code so what's the right
choice here and like how much does it
really matter
so again when I started out my thinking
was well if this code on the left is
dangerous we're calling this a dangerous
pointer right then obviously calling
this function is going to be dangerous
so the answer is you use the one on the
left right but of course the one on the
right is the one that's actually in a
standard library so what gives now what
I think is that like the one on the
right is kind of like a key thing and
rust like rust is a toolkit for making
game
stuff safe right rapping carefully
written unsafe code and a safe API is
the underappreciated cornerstone of rust
the contract of a function is simply the
set of requirements you have to use in
order to in order to use that function
correctly and every function has this in
every way it's not just for us right you
call a function you're supposed to pass
a certain number of arguments of
particular types right and sometimes
there's extra things that you have to
keep in mind in order to use it
correctly right and if you don't do that
if you misuse the function then what
well you know on a good day like you're
using push and you pass the wrong number
of arguments right the compiler stops
you and in fact that's enough for push
the the set of rules that the compiler
actually enforces based on the types and
the borrow checker and this the type
signature the function signatures that's
enough like that's those are the only
requirements to use this function
correctly but then there are other
functions like pointer right that are
dangerous and they have a contract
that's pretty complicated actually if
you look at the at the documentation for
this function right sure enough it's got
five paragraphs of stuff that you need
to read in order to operate this thing
successfully right the fine print of the
contract and talks about things like the
last paragraph is the pointer must be
aligned which is like like a thesis like
you have to you have to go and look up
with that where it means pointers are
tough but then if you look at if you
look at vector push no safety rules in
the contract right there's this rule
about panicking it like this is some
bizarre corner case that happens when
you have zero size times but panic is
safe
panic is actually kind of a bad name for
it it should be called like orderly
emergency procedure
that's catchy
yeah but panic is safe and it leaves the
elisha program in a good state
afterwards even if one thread panics
others keep going and you can even catch
it if you really need to but there's
nothing you can do with this function
that's gonna cause undefined behavior
therefore it should be safe what that
means though is dangerous safe it's on
the implementer of this method then to
make sure that they're using that
dangerous piece in a safe way all right
and you can do it what you need to do as
the implementer of this method is you
need to make sure that like when you get
to the pointer right on this line that
the data you're passing to it is correct
and that your color no matter what they
do cannot cause you to violate the
contract on that function right so this
is this is the basic idea right so how
do you do it well you're passing this
pointer end it comes from here and that
comes from this offset and that's
computation right where you'd like to
take the pointer to the beginning of the
array and then you add some number of
elements and get to the end that in turn
is valid if the length argument you pass
it is actually less than the capacity of
the buffer and there's an invariant in
the vector class that the length is
always less than the capacity or less
than or equal to the capacity of the
buffer less than or equal to equal to
would actually be a problem here and
therefore we have this other code to
make sure that if they're equal then we
double the capacity to make it to make
room all the parts of this function are
working together to make sure that one
line of unsafe code goes smoothly that's
basically what we what I wanted to say
there there so what have we learned
we've learned that while you're in
Columbus you need to make a stop at
Jennie's ice creams get the Brambleberry
crisps
we learn what can cause undefined
behavior in C++ we learn what that means
we all know what safe means in rust and
why we have unsafe code and we learned a
little bit about how to use it wisely
so what well notice that in certain
times and in certain places engineers
get this idea in their heads that they
can like build a safer world it's funny
it's happened in lots of different
fields at different times it's happened
in you know medical equipment airplanes
space travel industrial machines used to
be incredibly dangerous highways and
when when that happens we do safety
engineering we study failures right like
we get inside then we figure out why we
have these failures and we design
systems to prevent them so where are we
right now with software are we safe
enough like is is the code we write is
that safe not as a good enough and if
not do we think we can fix it but what
do we think nothing will help I think we
can do better right and if you go away
with one thing out of this talk once you
understand kind of at a technical level
like how rust fits into that effort
right sure rust prevents some bugs out
right and that is great right but is
there's actually more to it than that
rust will help you understand the rules
that good C++ programmers have in their
heads that they got the hard way right
Russ gives you the ability to put a safe
API on top of unsafe code and have
reason to believe that it's actually
correct that's a great like that's a
software engineering tool right a safety
engineering tool russ has expressive
types so like the types can cover more
of the contract so that humor
brains don't have to and maybe best of
all like rust is economically viable so
you can actually choose it and use it
and it can be your competitive advantage
unsafe code isn't going away alright if
you were using unsafe code if you have
to write unsafe code for your job you
should be using rust it's ready today
it's the right tool for the job let's do
it thank you
I got one more things so my finishing
bladdy and I we wrote a book it's you
can it's in early access right now you
can buy it and it will be in print
probably in January you can you can you
can get even absolutely get a PDF with
like almost the entire book in it ah
it's out it really is I'm so sorry
okay oh you're wrong okay I'm sorry to
hear it okay well you can pre-order it
okay well thank you anyway</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>