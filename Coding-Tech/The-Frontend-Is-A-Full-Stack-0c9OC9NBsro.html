<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Frontend Is A Full Stack | Coder Coacher - Coaching Coders</title><meta content="The Frontend Is A Full Stack - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Frontend Is A Full Stack</b></h2><h5 class="post__date">2017-09-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0c9OC9NBsro" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">people tell me look at you work on the
front end you're a bunch of hipsters you
have things coming up all the time lots
of libraries solution languages trying
to revolutionize the whole industry all
the time everything you can start using
today is going to be or out-of-date
tomorrow just within a month or two or
three and although you may disagree with
that we have to recognize that that's
something going on in our industry
I mean JavaScript fatigue I've been
feeling it so I I've been thinking about
it so why is that so why why are we
getting all this complexity and things
going on
my name is luca marques inian I used to
be a full-stack developers now I work at
castle and I make memes and to answer
that question
I've had to ask myself another question
which is what was the first problem we
were trying to solve from from the very
beginning what what are we trying to do
in the first place so my interpretation
of the facts is that since the early 90s
were actually what pages were thing we
are trying to make something which
combines the advantage of a native
application in terms of snappy UI and
fully interactive experience which
actually enables the user to solve
complex tasks and at the same time we
want it to be easily accessible like a
web page everybody knows that to give
someone access to a web page you just
handed a URL or a link just click on it
and it works everywhere on every browser
on every device so if we take a look
at the stack of native application we
see we know oh no this UI layer that
sits on top of you logic which works
with a business logic which interacts
with a persistent layer sometimes with
an ORM
and what is this work okay so the
difference with between the two is that
the web page has a static UI at least at
the beginning the you I was really
static it was pure HTML and between the
UI layer and the view logic we had the
network introducing the latency that we
always have to deal with so I think that
what we are consciously or not trying to
do since the very first years of the
early 90s is just make pages fully
interactive in order to do that we first
need to be able to change the appearance
of the page without reloading the page
because reloading the page is not
instant we have this very ugly blank
screen that bothered the user so in 1995
we were just trying to figure out how to
make HTML pages and then BOOM javascript
drafts on landed on the browser and the
first thing that we thought we could use
JavaScript for was make snowflakes fall
on the page that's why I say that we may
not be really conscious about the really
the opportunities of JavaScript at that
moment but then things went on and we
really wanted to be able to load new
content on the page without reloading
the page but then we had to wait 10
years and have Ajax requests and then we
were technically done
we were able at that point technically
to build fully interactive application
within the webpage but we didn't go
straight to the point right we all know
that we had a really big problem of
separation of concerns because at that
time we still sent chunks of HTML
through the wire in response to Ajax
calls so both the front end and the back
end were concerned by page compositions
so and also we didn't have no js' so we
were writing on in JSON the front end
and then in on the back end in Ruby PHP
you Java whatever so in 2010 first
generation of UI libraries came out I'm
talking about backbone angular ember and
many more but those are the most famous
and what happened at that moment is that
we were able to pull the view logic out
of the backend and just leave that
concern to the front-end
and make the server just expose a REST
API and make JSON pure JSON data flow
through the wire so we were able at that
point to split concerns and teams which
was great we just had to make a contract
between the front end team and the back
end him and that was a human problem
very easy to solve and then we were done
we it's ok come down Steve look at how
the native application engineer did the
UI's and look at how we do UI that's the
code that we needed to write in order to
nest the view in another backbone view
and when I realized that I felt pretty
much like this we definitely needed to
do something and at this point it's
really a concern of developer experience
and it's very interesting for me what
drives those innovation at a certain
moment it was just user experience now
it's developer experience be more
productive 2013
second generation of UI libraries react
angular UJS polymer cycle Jaya's many
more which introduced a lot of new
things but here what I'm interested
about is the concept of component
components as we all know are the basic
breaks that we build our web page with
and the interesting thing of a component
is that we can really describe every
aspect of that chunk event of interface
in the same place what I show you here
is a view jes component that I really
like because it's very clear you have
two three tags style template and script
and that's all you need to define a
component the beauty of this is that
each aspect is defined in a different
language and the language is very
specialized for that precise thing also
a component exposes a clear API of input
and output props and actions or events
which allows the developer to exchange
and distribute the component to other
developers so that you don't have to
bother what's inside a component that
you install from NPM for example and
this will allow us to create tools like
this the polymer designer which today is
just a prototype
but I'm sure that in the future we will
use more and more rad UI Composition
tools the great thing about the polymer
designer it really generates real
polymer code that you then can work on
so we've got a big a long way so far so
what do we still need today if we are
offline even if all our X assets are
stored in the browser in the browser
cache we want to access a website we've
we've been there yesterday now we are
flying we see the dinosaur
native applications don't do that you
open a web a native application and you
have some content and you've been
visiting before you can see it too we
have the dinosaur why let's kill the
dinosaur let's provide the user with
some real compelling offline experience
and then what we are doing today is
first-class applications web application
and why shouldn't we wouldn't be present
among the other application of the user
why don't we have an application icon
within the application menu of the user
and then native application can bother
the user with push notification why
shouldn't we do that actually all these
things are possible today and they are
known in this terms progressive web
application is like a it's like
technology bundle that Google pushed
forward a lot and which really to me is
the last step that we need to make in
order to provide a real fully
interactive application like experience
to the user but unfortunately it's not
supported by all the browsers guess who
is supporting that Chrome and Firefox
let's see what happens my dream is
actually to be able to leverage all that
technology and really you know make real
application in the web with web
technologies data I want to talk about
data because we've been talking about
you eyes and that's one thing that we
DLR deal with and then the other thing
is data we always have to manage how the
data flows through our application and
the main problem is what what happens
when data changes the main promise that
all the UI libraries we use is to keep
the data in sync with the UI or the
opposite DUI in sync with the data
um okay this is a piece of junk code
that I show you
so please children don't do that at home
okay here where's the data because we
check the DOM and then if the menu is
closed we put the class and if the menu
is open we remove the class so where's
the data here where's the state the
state my point is the state has always
been there in the previous slide what we
did is just check the Dom for the
application state and we basically use
the Dom as the representation of the
application state here which happens to
be a very bad idea
so yeah the state has always been there
what the only shift we've been doing is
to choose to describe the application
state in another way to separate it from
the Dom and were they in global
variables like here again Junko don't do
that at home children here we just we
represent the state of the menu with the
global boolean and then we keep the
boolean in sync with the state of the
Dom node that we used to represent the
menu so that variable is a state the
data and the great thing about react
when he came out the great revolution to
me is not only that he they abstracted
the Dom through the virtual Dom but the
Iranian forced this idea that we should
manage a state somewhere which is
completely independent from the UI state
and then we just use the components the
react components to map that state to
the Dom but never
ever access directly the dawn or yeah
sometimes it's you don't have the choice
but it's commonly known as a bad
practice so I suddenly became aware of
this concept of state so you have this
state and you have to do something about
it but the question that react doesn't
answer is where should the state live
you have all these JavaScript objects
and what do you whether you put them so
if you use vanilla vanilla react
you can scatter your state across
component and let every component manage
its own state like we did in backbone
like we didn't you know all the time and
as long as the application grows big and
complex we understood that it's a very
good idea to gather all the state within
a store which is what reduction forces
what flux enforces this is not an
invention of redux but I think that when
Redux came out and when flux came out
that this idea was really you know
blatantly shown to the community so we
suddenly were conscious about this so
when the store is there what happens is
that we introduced a new layer to the
front-end which stores the state but the
state of the application contains two
sets of data one set comes from the user
which is basically issue calculated from
the interactions of the user with the UI
like some clicks here and there or some
forms that are failed and then the other
set is the data coming from the server
and if we use a store to keep the data
that comes from the server we are
actually talking about a local cache and
the local cache is always something that
we somehow want to keep in sync with the
thing that is being cached by the local
cache
so in this case we are facing a new data
binding problem the binding between the
state of the store in the front end and
the state of the back end that they are
in the back end and how do we implement
this data binding mechanism by calling
the REST API I really don't like REST
API so I think they really don't fit our
needs and I think I'm the third person
in this conference talking about the
problem of over fetching and under
fetching so I think that it's useless to
talk about it right now so I I think we
can take the time that I've used to this
to do something more fun like having a
chat with the captioner with the
captioner hello are you enjoying the
conference
I wanted to thank you for fixing all my
English errors and I also wanted to
really compliment you for the job you've
made during Jafar's conference because
actually Jafar talks faster than my
brain can think and all that other
things that Jafar said were actually
written down there so it means that this
person's can type faster than I can
think so you guys are doing an awesome
job so thank you very much please
over fetching and under fetching say
this is we always say who are we are who
are our friends so the API the REST API
doesn't fit our needs we do round trip
requests to get a lot of useless data
and we bloat the network and then we
have this first world problem of tight
coupling we don't really like so how do
they do in the back end they query
basically they send a query to the
persistent so why don't we do the same
thing this is the purpose of graph QL
and Falkor we've been we've seen graph
QL before and Falkor is another tool
that basically resolved the same problem
on the server and there's another one
which is called on next which I don't I
won't talk about because you don't
understand anything
Roger script but the next talk is about
this so what happens on the server you
just have one API endpoint and you send
a query and then you're you have exactly
the same data that you want nothing less
nothing more and now we are over with
over fetching and under fetching but
still we don't have a clear way to
leverage the fact that we can cache that
data the data that comes from the server
we can keep that on the client and then
use it to optimize the further requests
that we want to make to the server and
that's where the file core client and
relay come into play these are the new
kids on the block and basically the
Farquaad client interacts with the
Falkor server and relay interacts with
graph QL and what they do is in the same
way that we act introduced this
abstraction layer between the developer
and the dawn saying don't worry about
the dawn just give me the state and I
will patch the Dom in the best way as
possible Falkor and relay do the same
thing with the network they are saying
to
the developer don't worry about the
network stop curing the network stop
sending requests just ask me the data I
will provide you the data as soon as
possible in the best way as possible so
they are managing all the data question
for us they are managing all the
requests optimization for us and we'll
see that in a moment and they just let
us specify what data we need and just
wait for the data to arrive in this case
we are introducing a new OGM layer to
the front-end I say OGM because while
current relay work with graph because
actually the best way to model our data
and the interesting thing here is that
we are starting to consider the backend
as some sort of persistence layer that
we don't want to know about we just know
there's some sort of latency and that we
don't bother about it demo time that's
when things become interesting ok what
are you seeing here doc ok this is
what I have in my back-end
let me just resize the window this is a
list of products that my REST API just
responds when I ask to search for the
products I have this these are Italian
food that I sell to my colleagues at
castle and we have all these useful and
less useful fields ok this especially
this one and this one and now I wanna be
able to query those those fields so what
I make here ok I'm here I'm
demonstrating Falkor ok it doesn't mean
that I think that far is the best
solution ever it's just that Falkor
isn't coupled with react since I'm not a
react developer I use VJ as it was just
the best solution for me to to show you
the idea behind the thing so here is we
are curing we have this model variable
that I have exposed to the global and I
just say get value and then here I
specify my query in the the query the
nice thing about Falcor queries they are
really similar to the json syntax so i
have this set which is products by ID
and this is the ID of the Parmesan
cheese that i wanna see and this is the
title ok and then get value returns up
promise the real type is actually
unobservable but it really behaves like
a promise so I said then when the data
is available
I wanna show it so here's the data ok
let's take a look at this is the
query am i right yeah yes this is the
and this is the response of Falkor okay
it just sent me the title what happened
on server side let's see this is my
Falkor code on the server side Falkor on
the server is just an express middleware
that you just plug a router to and then
specify what your routes do so
okay this is my router create class and
then I define a route this is the
matching pattern so that's how I tell
Falkor what do you have to match in
order to enter this route and then I
specify the method which in this case is
get because I just want to get data
methods can be get set and call so in
this case is a gate which always returns
a promise and then here this is my code
just I make a call to castle to get some
data and then when the data is available
I just resolve the initial promise with
the day today I format in the Falkor
syntax okay is that clear is that okay
for you it does it make sense okay
can you read do you want me to it's okay
okay so basically when the data come
back I have my title so now let's try to
ask another field here say I want to get
the description of my product okay I
have an arrow oh yes it's always the
same because I can always get caught by
this in fault
when you want a value you use get value
so you just have the value and when you
want multiple value values you just get
which actually returns a JSON graph
object so here you can see I have my
title and my description but look at the
response of the second request
Falkor knows that I have the title in
cache so even if my query was asking to
fields it tells the server okay Justin
send me just the description field
because I already have the title and
what I really like about it is that
Falkor tries to make this metaphor this
to create this allusion to the developer
which is just code as if the data was
present on the local machine just like
it was if it was synchronous okay like
don't worry about where's the date where
comes the data from I just manage it and
so what if we could code like really
everything was here and we could
synchronously get the data while we
actually seen a very interesting tool by
Jaffar today and we've seen all this
async await thing so take a look at this
function I am writing here load model so
as Clifford call model three fields but
we use async await so we don't have to
put the then here just like synchronous
code and then right after the
model get with J log we lock the value
like if it was synchronous and the great
thing is that it works
this is the response of you know you
have the three fields here so it worked
like it was synchronous I'm pretty
shocked about it I have to see to watch
twice all Jafar's talk to understand but
I I was happy about it so another great
thing about this kind of approach is
that we can collocate data request
collocation means that within our
components we can specify the data we
need until today I used to do Buicks
with a which is a flux implementation
for VJ yes so the place where I
specified the data than my component
needed was in a synchronous action so it
was completely separated from the
component here I'm in this product list
component which is actually let me just
go to the home page of my website okay
so this is a product list with all the
products and my list this is the code of
my of my component the list component
and here I specify exactly the data that
I want for my component which doesn't
mean that the component is in charge of
fetching the data because this would
imply would imply tight coupling in this
case the the component just expresses
the need for data and then Falco's in
charge of it which Falkor is actually
completely separated but hey it misses
something now this is not a proper
ecommerce platform you know we have the
name of the okay it's in French my
colleagues are French not their fault
I'm sorry
we are not showing the price oh my god
let's get the price to get the price I
think you already know it we just have
to add a field to our query and don't
touch a single thing on the back end
any horse reloads what what can we ask
for more great so this is the power to
me of Falkor and it's something we can
do of obviously with graph QL as well
this is not the same approach but hey it
kind of works where's the doc and bam it
works so we don't know what we have make
have made a big a lot of progress
actually but I think that today we are
kind of concerned with speed okay most
many people are complaining about speed
especially on the mobile web and this is
not good I think one thing that we can
do is just drop forests api's and just
go query and use solutions like Falkor
and relay and graph QL and save a lot of
round trips and use this data over
fetching of course these solutions are
pretty new and there's still a little
bit of friction to adopt them it's not
very easy to set up a graph QL or Falkor
server you wiII have to grasp things but
I'm you know we are especially concerned
by these kind of problems
we tried to work to provide a a one
common running back end that just
provides you a Falkor model or a graph
QL query endpoint and I mean I hope that
in the future we'll be able to have all
these things out of the box HT be too
many people in this room have seen the
talk that we've seen on Tuesday about
HTTP 2 ATP 2 is here it's gonna
dramatically speed up our things and
network around sip round trips are not
going to be such an issue
so let's adopt it it's my dream to see a
fully worldwide HTTP through web and
then I wanted to talk about data binding
data mining comes down to observing
we've seen that that keeping things in
sync is a common pattern we have this
panel sees the seventies we know that
observation is the best way to keep
things in sync in our UIs we use the
components as observers that then map
the state to the Dom but all the
frameworks that we use implement this in
different way
events the rechecking virtual Dom
reactivity I think that data binding
should be embedded into the language and
this is what your first talk was about I
think that observables are really the
key solution the most elegant solution
to this problem and actually all the
error XJS implementation are going
through this direction I hope that the
rxjs implementation will be embedded
into javascript soon this is one of my
dreams and I also want to talk about
virtual Dom virtual Dom is great because
you know it introduces this abstraction
which actually works very well but it's
also good for performance
because imagine we have a dumb change we
trigger it and then the browser goes on
Andrey Stiles relay out and repaint
everything this is very costly another
dumb change and a round of wrist I'll
reroute and repaint and so on what the
virtual Dom does is buffering the Dom
changes and then trigger them flush them
all at once and save a lot of
calculation of restyling relay outing
and repainting I was asking myself why
don't we make virtual Dom native why
don't we make rousers expose some kind
of virtual Dom API something that would
allows us to say hey look I have this
change just buffer it then this one and
this one and this one and then just
flush it and then you do all the
calculations obviously virtual Dom also
computes diffs so it doesn't mean that
virtual Dom is completely would be
completely useless but I think that
virtual Dom libraries would be lighter
so it would speed up page loads because
we would have to load less JavaScript in
this way so let's go back to the
beginning of the toolkit and just why
are you do are we doing all this what
was the problem since the beginning we
are spending 20 years and more trying to
provide the user with a fully
application like interactive experience
and we try to do it through some kind of
software that executes in a distributed
environment which is instantly
accessible with just a URL and this
application has to be executable in all
the existing browsers and there's a
whole bunch of them on all the existing
OS running on all the existing devices
in all the possible Network conditions
and these are all factors that we don't
control and this is just in order to
achieve the largest amount of users and
in the end make them happy I think that
we have a lot of things going on in our
community because the problem is complex
and it's not solve and you know we are
finding solutions that are just awesome
think about the the network abstraction
introduced by relay in Falkor this can
benefit all the industries that work
that work with with distributed
application and now us developer if an
Android developer would benefit from
having you know the network abstracted
and don't have to bother about it
anymore so from our community we are
really introducing this great innovation
that we can spread around and if you
take a look at how the front-end
environment evolved we can see that the
stack is not very different from the
native application stack especially if
we consider that the backend is like a
persistence layer that we abstract today
we have a front-end that embraces the
full stack and I think this is possible
because the language that we use has
evolved a lot and it's now a first-class
application programming languages and
I'm obviously talking about JavaScript
which is the language of our community
the language that we use every day to
express the problem that has on us every
day when we wake up we are people that
work a lot that are really concerned by
this problem we spend a lot of time
working on free open-source project we
spend a lot of time on on the social
network
trying to
with other people and find solution
maybe our greens sometimes a lot because
this problem matter for us because the
users matter for us I think we are an
awesome community my friend Steve would
say I have four words for you I love
this community that's the way he would
do it I think we are not a community
made of hipsters we're a community of
dreamers and let me say that I think
that our dreams are close to come true
thank you very much I hope you enjoyed
the</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>