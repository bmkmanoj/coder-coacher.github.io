<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Future Of ES6 | Coder Coacher - Coaching Coders</title><meta content="The Future Of ES6 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Future Of ES6</b></h2><h5 class="post__date">2017-08-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ilRnq7BBWGY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">a lot of you out there probably familiar
with es6 which is the most recent
version of javascript and today we
actually have a really good browser
support at least for the major desktop
browsers for es6 so things are looking
good and the time is right to talk about
the future of JavaScript now this is the
last time going to hear me talk about
versions of JavaScript would used to be
titled es6 is now called yes 2015 and
going forward we're going to be
releasing a new version of javascript
every single year so yes 2015 16 17 now
the reality is these versions don't
really matter
in fact what matter because what's
basically going to happen is at the end
of every year whatever features are
ready and mature enough we're going to
put in the spec and they're going to
make it into the language so it actually
matters with regard to the maturity of
future JavaScript features is this
maturity stages so in order for me to
responsibly talk with you about future
versions of things coming down the pipe
in JavaScript giving them they're not
really done yet given that they're not
really baked is to talk about maturity
stages so as features make their way
through these maturity stages we sort of
say to the community
hey these these features are getting
more and more mature and are getting
more and more baked and by the end of
the year
whatever has made it to stage 4 makes it
into the language spec and gets shipped
now the reason why versions don't really
matter so much from my from a
perspective of you JavaScript developers
is that you can start using some of the
features I'm going to be talking you
about today just by using babel for
example which does compilation from new
javascript features and future versions
to the existing versions of javascript
supported by your browser's so some of
the features I'm gonna be talking today
you can actually go away and use right
away by using something like babel as
you can see babel actually has this
little piece here where it supports
multiple stages so you can just say hey
look i want to use this stage 4 feature
or this stage 3 feature and you as
developers are accepting the risk that
if you use a stage 4 or stage 3 feature
it might change by the time it actually
makes another standard so later the
version the more mature it is and the
more likely it is to not change now
today I'm going to be talking about a
very specific question that is very
important to me as a developer I think a
lot of JavaScript
people on like JavaScript committee stay
up at night thinking about and that's
how we can make asynchronous programming
easier for you now obviously javascript
is a single threaded programming
language right and we do a lot of UI
programming in JavaScript and in order
to make sure that our UIs are responsive
we need to make sure that we write
asynchronous code right because if we
write code but synchronous and
synchronously makes a network request it
blocks in them our applications are not
responsive to users so starting in es
2015 es6 now titled yes 2015 we
introduced this notion of promises to
make asynchronous programming easier for
you as developers so promises are very
simple promises are an object that
represents a value that you'll
eventually get a synchronism and to
consume them you simply call the then
method and you pass two callbacks one
callback the first Paul back gets called
if the promise succeeds with the value
and the second callback gets called
instead if the promise errors and then
you get that error so promises have a
very simple API and in es5 you could
take your functions that were
synchronous and rewrite them
asynchronously using promises so here we
see we have two sequential operations
one to get the symbol for a particular
stock and then once we've got the symbol
for that stock we make a follow-up
request to get the price now if we were
doing this synchronously things would
block so we don't want to do it
synchronously we instead in the new
version in es6 we have these functions
return promises and then we chain these
sequential operations using them so
that's great if all you're doing is do
this then do that then do that but some
functions well they're a little more
complicated than that so here's an
example of a function it's a little more
complicated what if we might try one
service to get this stoop the price for
a stock but then if that fails we want
to try another service and we want to
retry at multiple times this particular
function is a little bit more
complicated than the one we saw before
and it's not immediately obvious it's
possible it's not immediately obvious
how we would take it and we would
convert it over to use promises right so
we're not entirely clear how that would
work with promises would take some
thinking probably some recursion in
there so what we on the JavaScript
Committee have been asking ourselves is
look why do slightest synchronous
programming an asynchronous programming
have to look so different right I mean
there's no difference if a function
returns a value or it delivers it to you
in a callback why should you as a
developer have to mangle your code just
in order to change in which direction
data is flowing so that's why we have a
very big feature coming in a future
version of JavaScript called
asynchronous functions and these are
staged for maturity level which means
they're very mature and it's probably
okay for you to go and start using them
right away so here we have that original
function get stock price with its loop
and its try/catch and here is how you
would write this same function
asynchronously in an upcoming version of
JavaScript so here I'm introducing the
async function concept in JavaScript so
notice that this code is nearly
identical the first thing you'll notice
that's changed is we have this async
keyword and then we take all of these
functions that now return promises and
all we have to do is put the await
keyword in front of them now what
happens is although this code looks
synchronous at run time javascript is
going to suspend at the exit the operate
the execution of this function until
this promise resolves and then resumed
at that point what that means is that we
don't have to worry about callbacks and
then notice that this function now has
no callbacks whatsoever and javascript
worries about executing our code
essentially after the async function
results so that means we get to use all
of the control flow constructs that we
know and love while loops try catch
loops inside of asynchronous functions
and we don't have to think very hard
about how to turn our code inside out so
what that means is coming up in a future
version of JavaScript I think it's a big
story for future versions of JavaScript
is symmetrical support for synchronous
and asynchronous programming and that's
a beautiful thing so that's great and
it's great that we can do all the same
things with async functions as we can do
with regular synchronous functions but
you know what we have an additional
concern
when we're worrying about asynchronous
functions and that's cancellation
asynchronous functions unlike
synchronous functions tend to run for
long periods of time and for those of
you developing user interfaces we know
that sometimes users are fickle right
they open up the form and then they see
a loading bar and they get bored and
they at the stop button and if they
decide to cancel the operation we want
to just stop doing anything like whether
it's make future asynchronous requests
we don't want to do that anymore
we want to be able to cancel and stop
just like the user is told us they want
to do so starting in a future version of
JavaScript were going to have a new
notion called cancellation tokens a
canceled token is actually a very simple
concept it's really easy to understand
so you can create a canceled token using
this method canceled token dot source
and it actually hands you back a pair of
two things one is the actual
cancellation token but then the other is
a cancel function so let's pass this
cancellation token to our asynchronous
function the one that we just saw get
stock price so as we see we just pass it
as another parameter to the function now
it's later on while get stock price is
doing its work right making a request to
resolve the stock price the stock name
to assemble then making a follow-up
request to get the price if we decide
you know what I don't want to do that
anymore and we cancel we just invoke the
cancel function and what that does is it
causes the token to cancel and then our
get stock price function whenever it
finishes some asynchronous operation
before going forward it's going to check
that cancellation token and if it sees
that the cancellation token is cancelled
it's just going to throw and but because
it's growing it's never actually going
to invoke our callback here and it's
effectively going to cancel and that's
how cancellation tokens work so now
let's see what this is like for the
person actually writing the get stock
price function because they have to
accept this cancellation token so let's
take a look at what gets stock price now
looks like so here's the async function
we saw earlier using the new async
keyword and here's what it's going to
look like to write an asynchronous
function that supports cancellation so
as you can see we accept the
cancellation token and
and after every await statement we just
go cancel token throw if requested in
other words if somebody called that
canceled function that we saw earlier
this is going to throw at this point
right here and effectively that toss is
the rest of this code notice that get
symbol price will never get executed
then ever we save a whole network
request that we need to make because
they want to cancel that function now so
that's a lot of boilerplate as you can
see right at every single time we have
to write away we have to write canceled
token dot throw it for queston and it
can add up it's a little bit of extra
boilerplate I think most of us wouldn't
want to write that boilerplate part of
the promise of asynchronous functions is
you don't have to write much more code
than if you were writing synchronous
functions so how do we accomplish that
well we add a special contextual keyword
called await cancel token and this
effectively replaces the code that you
saw earlier so these two pieces of code
are actually equivalent and so now with
that done we can see that we can
actually support cancellation and our
asynchronous functions by adding only
one extra line of code so hopefully
that's clear to you cancellation tokens
are pretty simple right there just a
shared object that you pass around
between your asynchronous functions and
if you cancel one it's the
responsibility of that a certain
synchronous function to throw and stop
executing so any service functions I
think I hope a lot of you are excited
about it because they're pretty great
right for those of us writing a lot of
async code and probably a lot of us
using promises already I'd like and I
see a quick show of hands who's using
promises out there a lot of people right
so this is this is pretty powerful
syntax that you can just use out of the
gate now that's great but there's also
other types of functions in JavaScript
some of these other types of functions
were introduced as well in es6 or yes
2015 one of those is the generator
function now just click show hands I'm
curious how many people use generator
functions or it may be indirectly some
of you use them in libraries right so
fewer hands but it's a very powerful
type of function so a generator function
basically it's a function that returns
multiple values so a generator function
can return multiple values and when it's
finished it'll just tell you hey I'm
done
so here's an example of a generator
function in es2015 so in the old version
of JavaScript if you wanted to return
multiple numbers you'd probably just
create an array of numbers in returning
so notice here this is a little bit
different we see this yield keyword and
this yield keyword looks a little bit
like a return and that's a good mental
model for thinking about how yield works
is sort of like a function with multiple
return statements and what it does is it
allows you to return multiple numbers
but instead of collecting them all up in
an array and then returning them you can
return them progressively on demand as
the consumer requests them and that
turns out to be a pretty powerful thing
so here's an example of how you use a
generator function so the first thing
you do when you call a generator
function you actually get out this
object called an iterator and I think
some of you were probably familiar with
the concept of iteration spin-around in
computer science for a long long time
20 years possibly longer so you get an
iterator and then you call next and then
you get back this pair this pair of
values one is the value that you the
next number that you requested and the
other is a boolean saying whether or not
there's any more data and so it turns
out yes we have more data so I'm going
to call neck again and once again we get
another double a little pair that says
yes here's your number and yes we do
have more data so we call next again
until finally we get a pair of the value
and then the done property is now true
so we know we're done and that's how a
generator function works it allows the
consumer to pull values out
progressively of a function and
effectively lazily evaluates that
function so under the hood for those you
curious about how yield works one way of
sort of figuring out in two itting how
yield works is to imagine how you would
write that iterator yourself if you had
to well you'd probably have to set up a
state machine so as you can see here the
first thing is this little example the
fibonacci sequence which is a horse the
ubiquitous programming example we return
a iterator so you can see here that's
that outer object with the next method
and then if you keep calling it each
time you call it this function checks
what state it's in so it effectively
figures out every possible state that
the function can be in and then it just
keeps moving through those states
every single time we call next it moves
to the next state and then it returns
one of these pairs so that's all it's
doing it's building a state machine but
integrators are really powerful because
you don't have to build that state
machine you just write your code top to
bottom it's a little like async
functions because you just write your
code top to bottom as if that code is
executing and every single time the
yield keyword comes up the program might
suspend but then it will resume from
that yield point the next time you call
next so if we were to sort of like get a
mental picture for how iteration works
what you do is you have a consumer and a
producer the consumer requests the
iterator and then begin sort of pulling
values out and so we get 42 we pull out
39 and finally we make our last request
we pull out that and we get a pair back
that says okay 19 and done and that's
how we know we're never supposed to call
next again so generator functions are
great but they have to produce value
synchronously and that doesn't make them
very useful for some of our asynchronous
streams that we have to deal with so
what are some examples of asynchronous
streams of data that we have to deal
with in the browser well I can't think
of one but probably a lot of us had to
work with which is WebSockets now one of
the reasons I can't use generator
functions for WebSockets is because but
when you get a value from WebSocket it's
asynchronous right it calls you and when
you call next on a generator it blocks
until it delivers you that value and so
it's kind of unfortunate that we have
this nice function in JavaScript for
requesting values streams of values but
we can't use it for WebSockets so what's
the solution so what if we want to
create an asynchronous stream of values
starting in a future version of
JavaScript we are going to have the
asynchronous equivalent of generator
functions and this is going to allow you
to do things like work with streams i/o
streams of data like WebSockets in a
much more elegant and fluent way so
here's an example of how we can consume
iterator so earlier I showed calling
next calling next well thankfully in
es2015 we have a nice syntax for that
it's like a little for loop and you'll
see that we have a similar syntax for
consuming asynchronous iterator soon but
here's how the producer looks so if I
want to create a generator function
right now I want to read data from the
file now I can actually implement this
in node today because node actually
supports synchronous i/o
I don't recommend you do that because if
you use synchronous i/o and your web
server you're not going to be able to
serve other multiple concurrent requests
while you're reading data from a file so
while this is possible you probably
shouldn't do it right so here's what
it's going to look like to do the
asynchronous equivalent of this in a
future version of JavaScript so I'll do
that again just in case anybody missed
it right not too shabby right so all we
did once again we added the async
keyword and we just go await in front of
any asynchronous operation so in know
you could do something like this in the
future to write code that consumes data
from files and it's not going to block
now that's great for the producer what a
hold on I'll just go through this little
consumption side so if we want to
consume this just like the previous
example it's pretty much the same we
request an asynchronous iterator and
then we call next but now notice when we
call a secret asynchronous iterator next
we're actually instead of getting back a
pair of the value and a boolean
indicating whether we're done we're
going to get it back a promise of a pair
of a value and a boolean indicating
we're done so I just call then and I
love the results I call next again
because I'm not done and we see that the
the code on the left-hand side
resumes from where it left off and
finally I keep calling it until I get my
final value so just an iterator of
promises of pairs is kind of the right
way to think about a synchronous
iterator so once again we'll visualize
this process with an asynchronous
iterator we've got a consumer you've got
a producer the consumer requests and
asynchronous iterator from the producer
and requests value but this time the
producer gives a promise to the consumer
and then the consumer resolves that
promise and gets back a value and we
keep going like that now notice at the
end we just go ahead and we return this
last value but it always gets wrapped in
a promise so even though we're just
returning 19 it's still going to get
wrapped in a promise so the consumer
doesn't have to worry about getting a
value or a promise and that's similar to
the way that the promise then method
works right if you remember from your
function inside of then you can either
return another problem
or raw value and it all gets wrapped up
into a promise so we see a synchronous
iterator works the same way and so we
thought we're finally done you stop so
we saw what it's like to produce an
asynchronous stream but what about
consuming in a synchronous stream how do
we consume it well in es6 we added this
nice sugary syntax for of so we don't
have to write that nack snacks next and
that while loop right so it's a lot
nicer to consume data this way from a
stream starting in a future version of
JavaScript we are going to see this so
as you can see we've got four oh wait
all right and everything else is pretty
much the same just sprinkle await
through keywords throughout your
function and it pretty much just works
so you don't have to think very hard
once again the focus is on symmetrical
support for asynchronous and synchronous
programming so where are we going to use
this well pretty much this is really
appropriate type for any kind of push IO
right whenever we've got IO that's being
asynchronously handled one on one such
case is obviously WebSockets but another
case could be nodes streams and it's
quite possible in the future
both of these types could implement the
asynchronous iterable contract which
means you can use for await on them
inside of asynchronous functions make
sense so there are some streams that are
not very patient they will not wait for
you to be ready and request another
value from them now perhaps the most
notable example of such a stream in the
browser is event target the event target
API which I think a lot of us in the
room know better as add event listener
remove event Lister the thing about Dom
events is they don't particularly care
whether we're ready for them or not
whenever somebody moves that Mouse or
whatever the Dom loads it's going to
call our callback right away and we have
to react to those callbacks
so asynchronous iterator isn't really an
appropriate API for that type of thing
right asynchronous iterator is for women
consumers in control right when you want
to decide when to pull the next value so
we need another type for these push
streams so here's an example of some
push streams Dom events set interval
right which calls a callback every every
few seconds right set timeouts actually
probably not as good an example that's
probably something better for a promise
because it always calls you once
so the interesting
think about the web is that there's no
standard observable interface we have an
iterable interface which is now standard
in the latest version of JavaScript but
we have no standard way of observing
data so you have a lot of different
api's which can push you and call
callbacks but there's no one interface
to capture all of them in a consistent
way so here we have another proposal for
an observable interface in the upcoming
version of JavaScript and that's
currently at stage 1 so I'll tell you a
little bit how it works but I think
you're going to start to recognize a
pattern as we go through it first of all
here's what the interface looks like
it's actually two interfaces we have the
observable interface which accepts an
observer and an observer is really like
a batch of three different callbacks it
can push you a value it can push you an
error or it can push you a completion
message and the idea behind an
observable is it's really to take the
iterator contract that we showed you
earlier and kind of flip it inside out
write an iterator which we saw earlier
you can keep pulling values out until
finally you get that little pair that
says you're done right and another
possibility is that when you call next
on that iterator just like when you
execute any JavaScript function it could
throw and so there's really three
semantics that that iterator supports
which is give me a value tell me whether
I'm done or not and possibly throw an
error and so what we're doing on the
committee's we're trying to take all the
same semantics that you have in the
iterator contract and we're turning them
inside out for the observer contract and
so instead of you calling next on an
iterator you provide the observable with
an observer and it calls next on that
observer and pushes the data to you so
the difference is really about pulling
data out which you do with an iterator
or pushing data at you which is what's
done with an observer so let's see what
that looks like so we actually have as I
said these two interfaces that work
together so let's visualize it so let's
pick up where we left off at iteration
so we have we still have a consumer and
we still have a producer but now the
producer is going to be the observable
and instead of a consumer requesting an
iterator from the producer it's going to
provide an observer to the
servable is going to provide an observer
to that producer so we passed in the
observer and then the producer actually
pushes data at us by calling our
callback so it calls those three
callbacks observer next pushes it 42 and
then it will just keep pushing so in
this case notice the big difference here
is the producer is in control not the
consumer
I don't decide when I get the next value
the producer decides when I get a next
value and that's how Dom events work and
that's how set interval works right so
we're trying to capture an interface
trying to take one nice consistent
interface for handling this type of
interaction and so the equivalent of
giving us a pair with that done : true
on it is actually invoking our complete
callback so it's the same semantics it's
settled a little bit differently because
it's more convenient to get a special
callback for when we're done but it's
basically the same three underlying
semantics so one of the nice things
about observable is that it actually is
going to support the same mechanism of
cancellation that the asynchronous
functions we saw earlier are so
optionally you can provide subscribe
with a canceled token because let's say
you subscribe up to an event and you
decide at some point you don't want to
listen to out of it anymore right today
you would call remove event listener but
the equivalent of that in the new world
is you're just gonna be able to take
that cancellation token and then call
cancel on that camp during a cancel a
cancellation token and then the
observable is going to check that
cancellation token and if it's cancelled
it's going to unsubscribe for you so no
more add event listener remove that
listener you're basically just going to
able to use the same cancellation token
you're already using in your
asynchronous functions and thread them
right down to events so as you can see
you can call subscribe and pass in this
observer object that's what's right here
with the net complete and air functions
and then the optional cancellation token
so that's how the observer works and if
we go if we were to go ahead and run
this we might get pushed three to value
three values in a row and that last
value is going to say done so that's how
you would use an observable
so what are some of the API is on the
web the web platform API is either going
to use observables well we have dawn
events and set interval are obvious
cases of two interfaces out there that
would make sense to be able to use with
observables I think it'd be really nice
is this and any future push ap is
just all use the same interface because
then we can just think about them all
the same way now one of the big benefits
you know so you don't have to write out
eventlistener or remove that list so you
subscribe to set time out slightly
differently is this really that big a
deal well yeah it is the reason why we
should have one interface for all these
types of push api's and one interface
for all these types of async IO api's is
because of something very powerful
composition we as developers need to
build need to control complexity and
build large projects by taking small
elements and composing them together and
one of the really powerful things about
these types is that they compose so here
I'm going to show you an example of what
it might look like let's say I want to
take a length socket and I want to look
for big price spikes in a particular
stock well here's an example of how I
could use a library like underscore or
low - somebody could write a library
like underscore low - for those who
aren't familiar these are a collection
of functions used to compose types
together somebody could easily write a
library like low - or underscore over
our asynchronous iterable interface and
now all of a sudden we can create with a
just a tiny bit of code a stream that
only calls us when a price spikes on a
stock so this is an example of looking
for price spikes in the johnson and
johnson stock and just consuming it that
data only when we get a price spike
likewise you can take observables
I'll just pause for a second to let that
so notice we're here we're using the
filter method on arrays just like you
can use the filter method on arrays you
can use the filter method on
asynchronous intervals and it does the
exact same thing and this scan method
for those you aren't familiar with it it
basically behaves like reduce over
arrays except it gives you every
intermediary computation so unlike
reduce scan is just going to sort of
keep this stream open and give us every
single price spike as it arrives for the
lifetime of this WebSocket being open so
you can perform progressively more
powerful computations and for those you
out there familiar with functional
programming you know that this is a very
powerful and fluent way of writing
programs and so this is one of the big
wins out of having a single standard
interface for all of these different
data so
suddenly it becomes really easy for web
developers to compose them together so
in addition to composing a singers
intervals this is one of my favorite
little examples of what it looks like to
compose observables so imagine tomorrow
every single Dom event was suddenly
exposed as an observable so you actually
had an object that represented a Dom
event and it had these powerful methods
like map and take until and merge all I
can actually write a drag and drop event
by composing together a mouse up a mouse
down at a mousemove event with just a
few functions now you don't have to
fully understand how this code works but
there are libraries out there already to
help you compose together these
observables because observables just a
library so you don't have to wait for
this to come out in JavaScript you can
actually use libraries like rxjs or
bacon j/s which already exists think of
them as like underscore for events or
lodash for events for those who are
familiar with this and it's actually a
really powerful way of building
asynchronous programs so this is just an
example the tiny tiny little spice of
code to write a mousetrap so I'm going
to wrap up here I actually have more I
honestly I had a lot of stuff to talk
about with the s6 but I only have 30
minutes but if anybody has any questions
about future es6 features i may actually
have some slides about them but i'm
going to wrap up at this point because
i'm pretty much at the 30 minute mark
and just give you my tweet handle there
which you can follow and I talk about a
lot of tc39 stuff now if you want to
start using these features make sure to
check out babel i'm curious how many
people are using translation out there
already okay so the good news is you can
use some of these features already and
some of you may indeed already be using
them and you can also check out es-tu
stuffs org which is where the tc39 goes
to engage with community and talk about
these features if you want to use these
features and come back and express your
opinion tell us where those pain points
are that's really valuable to us on the
committee that's one of the reasons why
we on the committee love translation it
gives you the opportunity to play with
these features now and you know what if
they don't work for you or there's pain
points around them you can let us know
before they're fully based and then we
put them in the language where there's
stuff there forever</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>