<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional Programming In An Imperative World | Coder Coacher - Coaching Coders</title><meta content="Functional Programming In An Imperative World - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional Programming In An Imperative World</b></h2><h5 class="post__date">2017-12-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6j2pRS-Y_Ck" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so what I want to do is talk a little
bit about functional programming
functional programming has become sort
of the hot new buzzword right and coming
from an object-oriented language like
Python sometimes we might see functional
programming is something mysterious I
want to kind of break that up a little
bit for you and introduce you to some of
the tools that help functional
programming you know do its job and
recognize that most of these tools exist
in Python not always to the best they're
not always the best tool to use but
they're all there and so I just want to
sort of get everybody just an overview
of what functional programming is right
but let's why would we use functional
programming why would we stop talking
about object-oriented programming and
look at this new style of programming
well functional programming is very
expressive as we will see through some
of the code examples you can do a lot
with a very little bit of code it can
you can just very much you can shrink
your code base pretty considerably in
the right places it can be very
efficient things run really quickly when
your language actively supports
functional programming paradigm and
we'll see some places and in Python we
read where he does that very well some
places where it doesn't quite so well it
can be safer hyphenated that on purpose
to sort of emphasize the fact that it's
still not safe like there's still
problems but it still it it can be safer
it can't overcome a lot of the problems
a lot of the bugs that we see in day to
day object-oriented programming and it's
easier to work with concurrent and
parallel programming we won't actually
directly dig into that but that's really
the sort of the reason that functional
programming has become so popular in the
last several years as we've stopped
getting core processors that can go
faster and faster and instead using more
and more cores being able to effectively
take our code and spread that across a
couple of different cores is is the next
step in making our our applications run
faster functional programming can help
lead into that
but what is functional programming it's
really just a style of programming that
utilizes pure functions which are
functions that don't have side effects
and it uses those functions to transform
data so a functional programming
actually thinks about data in a very
different way than object-oriented
programming object-oriented programming
we hide our data away and we're very
particular about how we use it and what
ever and who can access and that sort of
thing
functional programming is a more open
data model it's like no like there's no
need to hide your data away let's you
know take it and work on it in a more
mathematical sense that's where we have
these we try to have pure functions
things that don't have these side
effects because they don't really they
don't always make sense to have side
effects like in the middle of your code
oh yeah on the ion batteries of course
you have to have side effects you have
to write to a database print to a screen
read from a database that type of thing
but in the middle of your code there's a
lot of places where we do side-effects
where we don't necessarily have to and
functional programming is a way of
thinking that helps you sort of reduce
those because a lot of times those side
effects are places where you have bugs
so what I want to do though is start
looking through some of the tools that
help you get to functional programming
there's like functional programming is
not it's like saying you know if you
were to explain object-oriented
programming you might start with okay
this is how you build an object but an
object it building an object or a class
is not the totality of object-oriented
programming in the same way there's not
one part of functional programming it's
really just a set of tools and the
mindset on how you use them so with that
let's start looking at the tools the
first one is higher-order functions if
you've never come across this phrase
before and a lot of this stuff you guys
may have seen you just may not realize
that it is sort of like hand in hand
with a with more functional thinking but
higher-order functions just means that
functions gets treated like first-class
citizens they can be passed they can be
passed to other functions as parameters
they can be returned from other
functions as values
and they can be stored in variables so
you know they're just like any other
piece of data in your application so
let's take a couple of look at a couple
of examples so here is something that
sort of real-world it should we do this
kind of thing quite a bit at work we're
we need to pack we we will make a
function that knows how to talk to our
database it knows how to make the
initialization to the database or maybe
it's just pulling a connection off a
pool or something or other but at the
end of the day we have one function that
knows how to grab a cursor to our
database then we have all these other
types of functions that need that cursor
so we may have inserts that will return
a row ID right but that's going to be
different than using a query that's
going to return you an entire result set
right so instead of trying to make some
instead of trying to make each
individual either making each individual
query like make its own connection to
the database or make some function that
connects to the database in a way that's
versatile enough to like return a row ID
in this situation that return an entire
row set and this result set in this
other what we do is we make a function
that knows how to connect to the
database grabs the cursor and then we
make other functions that use that
cursor and each individual function all
it needs to know is how to use the
cursor it doesn't need to know how to
connect to the database so what we do is
we have something along the lines of
called database which takes a function
somewhere in there it makes the cursor
and then as its returned value it calls
the function that we passed in giving it
the cursor right so one example might be
where you query a database we the query
database function takes a cursor and
then it knows how to loop over the
result set or grab a result set and pass
it back or whatever it needs to do it
just depends on your business logic but
the idea is that we're passing when we
do this we're gonna like this next line
down here we're going to take the
results
we're going to get them by calling
directly to the call a database function
and passing it in the query database
function right so we can see here call
database is doing its thing to
initialize the database then it gets a
cursor and it passes that cursor into
whatever function we called it with
which in this case is query database so
it's querying the database with our
cursor right but if we also need to do
something slightly different we can do
something like returning a new the new
row value right so we you we can reuse
this same called database function
because all it does is one thing work on
the on the cursor and it just passes a
cursory and whenever we caught whenever
we pass it a function it calls that
function passes in the cursor right so
that's something that that's the place
where we use quite often passing a
function into another function you can
also return functions so this is a
little more contrived example this is
probably not something that would
actually happen quite a bit but if for
instance let's say you were you had some
data coming in somewhere and you had it
could potentially come in from several
different sources right it could come in
from a source that needs to read off s3
or another source that needs to read out
of a single database you can create
these functions that do whatever they
need to do like you have an s3 function
that knows how to call out to s3 and
retrieve the data or another function
that like we just saw that calls out to
the database and retrieves data from the
database but you need to dynamically
choose which of those functions based on
the in the source coming in so it's this
is this essentially becomes like almost
like a poor-man's polymorphism
but it's a it's a pretty straightforward
example what we do is we have a source
that comes in in this case from s3 we
ask for a new function by calling out to
this give me a function give me a
function takes our source and says okay
well it's s3 I'm going to return this
complex s3 function to you right it
doesn't call it it doesn't do anything
with it it's just passing the function
back to us
and then it's up to us once we get this
new function it's up to us to actually
call it with whatever we need to call it
with right so we get this you know we're
essentially saying here's we're coming
in from s3 what do I do with it give me
some function that I know how to handle
that will know how to handle s3 or give
me some function that will know how to
handle sequel and because these are
actually what it's passing back our
functions we don't actually have to even
do this where we assign it to a value
and then call it you can just call it
straight away this way right so we're
calling in to sorry calling in to give
me a function passing it in our source
and whatever comes back we immediately
call it just like we would any other
function because that's all it is it's
Pat it's just passing us back a function
now anyone who's like I said you may
have seen this sort of stuff especially
this type of thing we use a lot when
we're doing JavaScript if you have to do
that but we actually use it a lot in
decorators who has worked with created
looked at decorators a lot of people
yeah oh and the entire room right so so
yeah that's all the decorator really is
you're passing in the function to a
decorator function in this case
decorated that has a nested function
which we typically call wrapper and then
it does whatever kind of work you need
to do before calling your function
whatever kind of work you need to do
after calling your function so yeah this
should be pretty straightforward to
everybody who's ever used decorators
before and that and that's all it is so
without higher-order functions Python
couldn't have decorators so we have to
be able to pass those functions around
and so you see it's not just usable in
functional programming we use it all the
time in object-oriented programming in
certain languages and that sort of the
key is like functional programming isn't
really a mystery it's really just a set
of tools that you use in a slightly
different way the next set of tools I
want to look at is our immutable data or
immutable data structures now this is
something we don't use as much in Python
because mutable data is sort of the
bread and butter of object-oriented
programming but for immutable data it's
a structure that never changes itself so
like you have a list
you don't actually add something new to
the list instead your list can't be
changed like you're sorry about that
your list is sort of set in stone and
we're looking a little bit about how you
overcome that because that seems like a
limitation right like you create a list
you can't add to it you can't delete
from it what good is it how do you make
any changes what's you have to think
about your list in a completely
different way because whenever you make
some update we're used to passing in a
list adding something to it getting that
list back with a mutable data you don't
do that you pass in a list if you add
something to it you get a brand new list
back it's a it's a completely different
data structure same is same idea if you
take something off the list you know you
pass in the list to a function it takes
something off that list what you get
back completely different list though
that's a very safe way of handling
things though that means that list isn't
gonna change out from under you right
Emme bug how many times have we all done
this track try to track down the bug
where because we've passed off a list we
don't realize that whatever function
we're passing it to is mutating that
list before it comes back to us well
with immutable data structures you don't
have to worry about that you can pass
them a list they can do whatever they
want to with it your list never changes
their list it's adjusted to a new list
now history we don't do this a lot
because historically they have been very
inefficient what you have to do is take
that list it's sitting in memory the
operate the language has to then copy
the entire list to a new part of memory
so that you essentially have to list
it's very slow to do but there have been
new data structures called persistent
data structures that make this much more
efficient if you download this I've got
a linked to persistent data structures
to the description that Wikipedia I'm
not going to dive into them but they're
much more efficient at this sort of
thing so it lets you use an immutable
data structure without paying the
additional cost of like all that
being over in memory if you're not
familiar with the problem with mutable
data structures so what happened and
probably almost all of you have seen
something like this this is like almost
every language I've ever looked at has
this sort of warning of this kind of
thing where you create a list and then
you create a second list you point a
second list of the first list any time
you change that first list you've
automatically changed that second list
right so that's not a safe way of making
sure your data your list doesn't change
you can't do that
typically you can see here list one and
list two they are the same thing they're
basically the same list because what we
have are two pointers to the same piece
of memory and this can be a problem here
in that sort of situation but you can
also create some really interesting
problems if you're not thinking about it
so this is just a quick function that
goes through takes a list of integers
and then sums up that list right and
gives you the results so if you pass in
the list 1 2 3 3 the summation of that
is 6 but if somewhere in there you
accidentally start appending to your
list what you're going to get or some
really weird results right you're in the
middle of working your way through a
list in a way that we do every day it's
just a for loop but somehow we've
appended to that list in the middle of
that loop and now our list is going to
continue to grow add to this if clause
in there because if I don't catch for a
list of a certain size this will grow
until I run out of memory so that's one
of the things that we end up having to
track down sometimes when we work with
mutable data but if you work with
immutable data a lot of those situations
disappear so right here we're doing the
same thing that we did above with a list
right we're creating a tuple instead of
we're creating a list we're creating a
tuple adding some items to it and then
creating another another tuple pointer
to the same tuple right so we've got two
pointers for the same tuple just like we
did with the list above but now when we
update the one tuple it does not update
the second one
because in Python whenever you try to
update whenever you try to concatenate
an item into a tuple you get back an
entirely new data structure right so
before we do the concatenation we look
at these two tuple 1 and tuple 2 they
are the same after we do the
concatenation they're no longer the same
because Python has created a brand new
data structure for us it's a safe way to
do it but it's slow because these were
not created as persistent data
structures and you can do you typically
if we want an immutable data structure
we go to a tuple you can do something
along the same lines with pretty much
any with lists or dictionaries you can
use a deep copy and instead of actually
just making two pointers you make a deep
copy of the the list that way when you
when you change one it does not change
the other because you start off with two
different lists but again it's slow
because it has to take that list copy it
over in memory so those are some of the
problems that we can see with immutable
data that we can hopefully solve with
more mutable data structures but working
with immutable data structures means we
have to start thinking about things
slightly differently often like we don't
want to do a for loop on an immutable
list because it doesn't look quite as
well it'll loop in in Python in a lot of
functional programming languages though
they just pull the loop out of there
because if you aren't mutating your list
you don't necessarily need loops you can
come up with other ways of looping of
getting through everything in your list
and one of those ways is recursion or
the big way is recursion if you've never
worked with recursion most of you
probably I assume seen it the recursion
is when you call a function from within
itself it takes the like I said it takes
the place of loops in many programming
languages and we'll see that here in
just a moment how we can use recursion
instead of a loop the problem with
recursion is that every time you make a
call back to the function you add a
frame to the call stack and that call
set can grow and grow and grow
in languages that embrace recursion they
often do this thing called tail call
optimization which lets you more
efficiently do recursion without adding
to the call stack but Python does not
have Cal call optimization Guido has if
you've ever looked at he's sort of
famously come out against tail call
optimization in Python because it really
does it hides your stacktrace
what telco optimization does is it
instead of building up every stack
anytime you call back if you if you do
your recursive call properly it just
overwrites the existing frame on your
stack so that you don't build you just
sort of keep reusing the same frame it's
much more memory efficient but you do
lose your call psyche if something
happens you know five or six calls deep
you don't know exactly where it happened
you don't have all the context for it
so we probably will never get tail call
optimizations
but regardless let's take a quick look
at recursion so this is a recursive
version of the summation list that we
did above so insta-buck we're giving it
the list and looping through the list
here what we're doing is we're giving it
the list and then instead of looping
from each item we send the list back
into the function itself so the function
in this case has to take a list but it
also has to take the summation because
we are recursively calling back into
itself it's harder to keep track of the
state you have to pass this you
typically end up having to pass the
state back into the function along with
whatever like well in this case we're
passing the list in we also are passing
in the cumulative sum there are ways
depending on what algorithm you're using
they're getting through there ways to do
this without having to pass the state
back in but in this case we are for
recursive functions you almost always
have to have a base case base case is
the point that tells the recursive
function
stop recursing we're done just return a
value don't call back into the function
again so in this case we're done when
the list is empty when there's no when
it's just an empty list
we have summed up everything in the list
just for
turn the summation if that's not the
case what we do is we pop the last item
off the list add it to the current sum
as the new sum return everything back
into the loop again right so it's our
sum last our function and here we're
calling it we're calling with a list one
two three we get our result of six now
we still have the same issue that we had
with the iterative approach which is if
this list gets changed while we're doing
the summation it's going to you know
mess up our recursive calls this does
not fix that problem
that's a mutable data structure problem
but if you were to try to solve you know
you know try to implement this in a more
functional language this is the kind of
thing you would do you would loop
through it using a recursive call rather
than an actual for loop now one of the
problems with recursion inside Python is
if you try to go too big if you try to
recurse too many times you can get a
recursion error now in a lot of
languages you don't have something
called a recursion error Python has
built in a limit on the number of frames
you can put in the stack which by
default is a thousand you can up that if
you need to but in its sooner or later
you're going to run out of memory if you
if your list is big enough if you
recurse deep enough you're going to run
out of memory because you know the
language has to keep track of everything
on the stack that's where you get a
stack overflow so in most other
languages if they don't limit your
recursion depth like Python does then
you'll just recur and keep going and
going until you run out of memory and
get a stack overflow
so without tail call optimization
recursion is actually really dangerous
to do so you don't see it a lot I've
never seen it in the wild in Python and
there's a really good reason so if you
don't know how deep your recursion is
going to go come up with a different
solution you can always use an iterative
solution there's there's there are no
problems you can solve with a recursion
that you can't solve with just a loop
in some capacity so in Python we
definitely tend to favor loops of a
recursion so anyway you know just some
of the ways that recursion gets used and
that's how we kind of get around some of
the problems of mutable data and I don't
think I've pointed that out well but
essentially what you're doing is you're
taking that list and sending a new
version of the list back through the
recursive loop each time in this case
we're popping the last item off but in
other situations you a lot of a lot of
function languages have this concept of
the head and the tail of the list the
head of the list is the first item the
tail is everything else and a lot of
recursive calls will use the head and
pass the tail back along so that's sort
of essentially what we're doing here so
yeah those are if you've looked into
functional programming just sort of at a
surface level those are probably the
minor players that we've gone over so
far the big three the Holy Trinity of
functional programming our map filter
and reduce and this is where the more
functional style really shines out well
and fun in program in Python if you've
never used any of these in Python if you
get nothing else out of this talk I hope
you can walk away with a sense of I need
to check in to map filter and reduce and
figure out how to use them because they
make your code once you get used to how
they work they're beautiful so a lot of
times though to really use these tools
map filter and reduce we a lot of times
end up using lambdas lambdas are
anonymous functions and that really just
means it's a function that doesn't that
we don't name right instead of saying
def you know called EB we just have we
well this is the this is how it falls
out in Python you use the keyword lambda
you pass it whatever variables you need
in this case x and y and then there's a
colon that separates the variables from
the body all right lambdas are used for
typically one-liners if your lambda gets
much more complex than you can fit on
one line your
probably better off just making a named
function and going to the typical route
there but lambdas are really good for
these in line one offs where it doesn't
even make sense to make an entire
function just to add two numbers
together right you just throw it into a
lambda in this case we're assigning that
lambda to a variable name some we call
some just like we would any other
function and it sums up whatever we give
it right you don't usually use lambdas
this particular way but you do use them
quite a bit in that filter and reduce so
let's start looking at some of those
three tools filter does exactly what you
think it would do it you pass in a
filtering function which we'll go over
in a moment and a collection to operate
on the filter the actual filter function
takes whatever filtering function you
pass in and applies it to every item in
the list one at a time so it takes the
first item runs it through your
filtering function the filtering
function needs to evaluate to either
true or false so if it evaluates to true
the filter will then take that item out
of the list and add it to your new list
if it evaluates to false that item does
not get added to your new list
technically map filter and reduce all
return iterators now in Python 2 they
would return a list but now they're
returning iterators which is much better
that way you can kind of evaluate that
as you want it doesn't build your entire
list at one time it yields back one item
at a time so you can loop through it
however you need to but essentially if
you take something like that list if we
look at our filter right here we're
going to create a new list iterator
using filter we pass it in a lambda
that's basically just saying looking to
whether or not the value that we're
looking at is it even or odd right if
it's even then we assume modulo two is
equal to zero then it gets added into
the iterator modulo two doesn't equal
zero it doesn't get added to the
iterator we're passing it list 1 as the
collection that we want to iterate over
and so it's filtered out all of our I
guess you can say it's filtered out all
the non all the odd integers it's
filtered in the even integers
I don't know semantics but any case
that's what filter does you can pass it
a lambda like this or you can do
something much more complex as long as
it the filter as long as the filtering
function ends up evaluating to true or
false so filter knows whether or not to
add that value into the new list the
same kind of thing is true for map map
takes a mapping function and a
collection to operate on and then it
applies that function to every item in
the collection one at a time
it does not filter out any items it is
not you know if you pass in a ten item
list you will get back at ten item list
or you should get back at ten item list
so but what it does is it says you know
I have this whole list of users and I
want to transform them in this
particular way you can use map and give
it whatever trance whatever a function
that's going to transform your list of
users and then give it the list and that
will go through and do the
transformation for you so you it's a
simpler way of you just don't have to
call it all in the loop right like
normally if you're not using map you
might you know just for every item in
this list call out to this function
manually map does it for you map is
actually a lot more efficient edit it
will run a lot faster so map is if you
have one of those sort of simple
situations where you just need to pass
every item in a list one at a time to a
function map is a really good
alternative to using a for loop and same
kind of thing here we're calling Matt
we're using list one we're calling map
we're passing at this lambda this
anonymous function that all it does is
take whatever item I give it and
multiply it by two and then put it back
in the new list right so there we're
taking list 1 and we've multiplied it by
2 every item in there by 2 and get back
a new list and you'll notice even though
we did of
filtering on the firt on the list one
earlier we didn't actually adjust list
one at all we got a brand new list back
again because this is happening because
these functions were built map filter
and reduce were built to work this way
they're much more efficient than if we
tried to reproduce them ourselves
so this is actually a safe efficient way
to go through a list of items and do
something with it
rather than just sort of manually
looping through it risking the
possibility of adjusting your list
inline or anything like that so this is
a really safe way of doing this type of
thing and the last of these is reduce
reduce is a little bit different than
the other two so what reduce does it
starts off the same it takes a reducing
function alright and it takes a
collection to reduce with reducing
functions a little bit different it
doesn't just act on one item in the list
it acts on two items in the list at a
time you can actually send it an
optional initial initial value so the
reducing function instead of acting on
the first and second item it'll start
off acting on the initial value that you
send it and then the first item and the
way it works is this your reducing
function takes these two items does
something to it so that the output is
one item of the same type that comes in
you know we're not strictly using type
you know like integer versus string
versus whatever but essentially what's
going to happen is it will take the
reducing function the reducing function
will take two values do something with
it spit back out a new value that new
value then becomes the first parameter
in the when it when it calls the
reducing function again and the next
item in the list becomes the second
parameter and so let's take a quick look
here and this reduced Rudess was the one
that for whatever reason was hardest for
me to wrap my head around exactly what
it's doing math and filter were pretty
straightforward for me reduced was a
little harder
overcome so I've got a couple of
examples that might help it solidify but
in any case this first one is the sort
of standard reducing example we have
we're calling reduce on this anonymous
function that just takes two variables
and adds them together right so just
like we did above when we were looking
at lambdas initially we're just taking x
and y and adding them together and
returning that value what this is going
to do though is this going to start with
one and two out of the list that's going
to be the first x and y it's going to
add them together and you're going to
get 3 3 is then passed back in as the X
and the next item in the list which is
also 3 gets passed in as Y those two get
added together just to get 6 6 gets
passed back in as the X and the next
item in the list is 4 gets passed in as
Y and at the end of the list you end up
with your sum of 10 right now this is
the same kind of thing that we saw above
right we saw into that we saw an
iterative approach and a recursive
approach to taking a list of numbers and
adding them all together this is using a
reducer just to do the same thing and it
has it's so much better if this is the
kind of thing you need to do you need to
start looking at reduce for one thing
before when we tried to use the
recursive approach and we did that we
added a thousand we blew the sack right
or you had that recursive error here
because of the way it's built behind the
scenes
it adds the first thousand numbers all
together without blowing through the
stack it knows what it's doing but it
also does it really fast that's the
first thousand numbers it's the first
10,000 numbers it's the first hundred
thousand and one numbers I mean it's
super speedy it's incredibly efficient
this is probably much faster than we
could manually go it is much faster
because when we were doing the recursive
approach above I started it off and we
had to wait for a moment for it to blow
through the stack this is going through
it just lightning-fast these things were
made to do this type of work they're
very efficient on the back end
you really need to start looking at map
filter and reduce as viable options for
whatever kind of like wherever you think
you can fight you can put them it's
probably a good place to put them
because they really do make things so
much easier and so much faster I'll go
through one more quick example there's a
couple of examples you can pull them
down and look at them if you want I like
this example essentially what this is
going to do is it's going to go through
and count
it'll sum up all of the A's in all three
of these strings right so this is
imagine this is a DNA sequence it's got
three A's here the next sequence
sequence has two and the last sequence
has none the reducing function in here
is taking a in X in this case we're
starting with initial value of zero so
the first time it goes through the a is
zero and the X is whatever the next item
is in this particular case X is that
particular string what the reducing
function does is it takes that string
does account of the A's adds that count
back in to whatever they ate whatever
the a value is and kind of sums it up
that way right so this is the same kind
of problem we were trying to solve above
more or less where we're anyway I forgot
which one knows but um in any case this
is a really efficient way of like you
can give this huge list of DNA strains
and it will go through and tell you all
these markers in it just by using and
reduce you can also mimic map and filter
inside Python using list comprehensions
we list comprehensions or something i'm
sure every one of us has done day and in
day out you can throw a lambda inside of
this comprehension the lambdas too ugly
you can pull it out you can also so a
filtering function more or less inside
the so inside
the list comprehension and anyway so
these are tools that are already built
into PI into Python that we use day in
and day out but we don't think of them
as being functional programming perhaps
but they really are there at their core
they do the same type of thing that we
would do in functional programming so
that leads us to the question of should
we bring functional programming into our
code because it is a really different
paradigm I think of course you should
function like I think I've shown in a
couple different places functional
programming can be less verbose it can
be much more efficient and it can help
you think through problems in a way that
maybe you weren't you weren't able to
think through before so maybe solutions
become more obvious when you're using a
different set of tools but there are
some very real drawbacks as we've also
seen or he with immutable data can be
slower especially in languages like
Python again we have there's a
persistent data structure library that's
in Python now that someone's building I
don't know anything about it I haven't
had a chance to look at it if it turns
out it it works well then I'm going to
start trying to use it more in my code
because it's much safer but in the but
the immutable data is still slow in
Python as it's the built in versions
recursion can blow through the stack
very quickly as we've seen so recursion
is not a good solution in most cases and
functional code looks sort of weird I
have a co-worker who loves to throw
functional code into our Python and
every time I hit it even though I like
looking at functional code every time I
hit it it's a little bit of a speed bump
when I first started hitting it was a
brick wall so it like totally slowed me
down and stopped me but now that I
understand what's going on with it
I can scan through it more easily and
understand it so if you're going to
bring functional programming into your
code probably something you need to
discuss with your team or your
management if you're working on a team
and decide as a team hey is this
something we really want to approach
because if you if you just start
throwing it in there and your teammates
don't know anything about it
they're gonna have quite a learning
curve but you can help them learn and
that's kind of funny yes I think so so
that's our speed run through functional
programming in Python
how much time to have okay all right
does anyone have any questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>