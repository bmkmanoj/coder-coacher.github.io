<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Effective Browser JavaScript Debugging | Coder Coacher - Coaching Coders</title><meta content="Effective Browser JavaScript Debugging - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Effective Browser JavaScript Debugging</b></h2><h5 class="post__date">2018-02-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/upp0xded4as" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the the goal of this talk really is
to say that your browser is your IDE so
if you're a JavaScript dev you don't
really need an ID and you probably don't
use an IDE maybe you do there's some
there's some new ones that are good vs
code and stuff might count as one and
some other things but your browser can
serve as your IDE for the purposes of
debugging profiling getting some
introspection on your code and and
everything that you need to do that is
already built in your browser so there's
there's nothing you have to download
there's no software there's no it works
on every platform already since it's
built in the browser and the cool thing
is javascript is kind of in a unique
position that the top tech companies in
the world have spent hundreds of
millions of dollars making javascript
faster and better and on these debugging
tools to make your life easier and you
don't even have to do anything to
benefit from the work because your
browser already executed javascript
faster right now than it ever has so
yeah everyone gets to benefit from you
know the expenditures of Google and
Apple and Mozilla opera and things like
that so there's really no other language
where that's necessarily the case
javascript doesn't really have an owner
it's kind of everyone fights over who
can run it fastest which is really
awesome for JavaScript developers so the
tools I'm going to show you are
available in all modern browsers I've
got some screenshots in examples in the
screenshots and examples are from Chrome
but all of these tools are also
available in Firefox and Safari
Microsoft edge even opera I didn't put
opera on this slide but it's in there
too and I wanted to give a shout out to
to the Mozilla team and Firefox
developer edition if you guys want to
check out some more bleeding edge like
dev tools and cooler stuff that's not
available in
Chrome and things like that the
developer edition has some cool stuff
and has where you can provide feedback
and stuff like that so that's cool
these I'm gonna this talk is in two
parts it's kind of slides which is gonna
be an overview of what I'm going to show
you and then the second part of this
talk is like an interactive I have it I
have it
I've actually custom made an a whole app
for this talk to show you different
things in the dev tools and we're gonna
go debug this app together so hopefully
it's gonna be super helpful super
hands-on for you so you can really see
what it's like getting in the dev tools
instead of just static screenshots it
will have some static screen choice just
for the purposes of pointing some stuff
out to you so I think in this list
probably most people have really only
had experience a lot with probably the
top two pretty much everyone has seen
the chrome console has seen errors come
up has maybe used it you know console
dot log is maybe run some basic commands
in it something like that and then the
element inspection if you right-click on
an element and go to inspect it'll bring
up the element inspector which will show
you the Dom as it is currently rendered
which is super useful for especially
JavaScript apps where if you view source
the thing might not be there but if it's
rendered with JavaScript if the element
inspector will always show what's
actually on the page and what's changing
in it but then the available tools are
actually a lot deeper than that they go
there's actually interactive debugging
with breakpoints on Dom nodes xhr and
fetch events just regular events and
even code you know lines of code and
specific statements and things like that
and it goes goes pretty deep and we'll
get into this too that there's a network
tab probably most people or many people
have seen the network tab if you get
like a 404 error
otherwise something's not loading or
something go over the network tab and
you can see you know where where that
error was just out of curiosity how many
people have used the either the console
or the element inspector just show of
hands real quick okay so that's all I
thought pretty much everyone how many
people have used the network tab
almost everyone this is great this is
awesome
how many of how many people have used
the I have dug into the timeline of
performance features or the profiler
okay about half so I'm going to show you
a lot of that here so element inspection
this is I mean everyone's use this so I
won't go to go over it too much but
right click you see the element all the
styles you can set event listeners and
breakpoints you see the tabs at the top
they're not showing up on the screen but
matter you can you can right-click and
break on subtree modifications and
things like that so this is this would
be like a Dom breakpoint so anytime this
Dom node changes it'll actually pause
execution and jump you in there console
I have this slide up here just to show
that you can do anything you want with
the console the console lets you
interact with any webpage you want
regardless of whether or not it sits on
your domain so here I just popped open
the comment to Twitter comm popped up in
the console type dollar sign to see if
jQuery was available it was and so I
right clicked on that element
I'm the tweet got the selector and then
just set the text to that and
unfortunately for me actually all of
these have the same selector so maybe a
bad screenshot there but something
similarly easy if jQuery is not
available you can actually go edit the
body tag and add a content it is
editable and just like literally type
anything you want on any web page so I
throw the screenshot up just to say
don't believe screenshots like if you
see a screenshot of something don't
believe it
get the actual tweet or get the actual
you know Facebook post or get the actual
whatever get a link to something real
the actual news article
a lot of fake stuff going around so get
the source don't believe screenshot
don't blindly retweet it as if it's fact
that kind of stuff
so debugging one of the things about
debugging is you can add does anyone use
build tools for their JavaScript so like
building bundle and package all the
JavaScript together okay a lot fewer
people so if you do this there's this
there's this feature called source maps
and source maps basically let the
browser know what what your code
actually looks like so when you compress
all your JavaScript together and minify
it and obfuscate it and stuff like that
the source maps feature produces a file
that actually tells your browser that
this line here or this bit of code from
this character to this character
actually maps to this file or this
function and it actually looks like this
and then when you debug then you're not
debugging like minified obfuscated code
you're actually debugging your your real
code I'll show you that Network so this
is the specific problem I ran and ran
into it work I work on a team that was
building a content management system on
top of an e-commerce platform we got a
bug ticket that said the site was
loading slow in a specific case for a
specific customers site that was built
and so I started looking into it and our
our code is making two xhr calls here's
here's the regex goals here's the first
one and then here's the second one and
you see this gap this huge gap here cxm
is what our CMS is called customer
experience management but so this was a
ticket that was like your stuff is slow
and I was like that's interesting why is
there a gap there I don't really think
it's us that's slow like it was like mmm
that's interesting I we've tested all
our stuff I don't think
our stuff is slow and so I looked into
it and really dug in with the profiler
and that's that's really got where I got
all the material for this talk just kind
of digging in myself to figure out this
issue so there's this huge gap here this
gap is and by the way these two Ajax
requests go out one after another
it's like bam bam but for some reason
one's going out and the other ones
delayed and this so this one is this one
that's delayed is not waiting on the
result from the second one so what could
have happened well if you know a little
bit of about how JavaScript works
basically what happens with with async
stuff any anytime you you're
experiencing a lot of slowness with
async stuff for the pages and updating
or something like that it typically
means you're doing too much work in
JavaScript so you're doing what's called
everyone just says you're blocking the
event loop you're blocking the event
loop that's what's going on right here
they're doing a lot of rendering work in
the stack that's preventing any more
work from the event loop going out and
the whole stack versus event loop thing
is a whole nother talk I have and I have
a link to it in here but but so I'm
digging in and then so the network tab
and then the timeline for myself I'm so
I'm like okay well that's what the
that's for the network tab looks like
how about the timeline so I load up the
timeline for this page and it looks like
this and this is this is actually really
really bad so if I'm gonna help you kind
of read the timeline and I'm gonna go
over it briefly here and then I'll dig
into it in the demo more in-depth but
basically what's going on you see the
pie chart at the bottom here how most of
it is how most of it is yellow that
means most of our time is spent in
scripting in JavaScript executing some
kind of script and you see this yellow
bars here at the top and then a
corresponding red bars on top of there
those yellow blocks are time spent in
scripting so this is blocking JavaScript
right here so whatever we're doing in
here
this is blocking our subsequent Ajax
requests that are going out so we have
we have a huge chunk blocking here let's
see we have a huge chunk blocking here
and then we have our other Ajax calls
going out here that are just these
little bitty ones and I dug into the
problem and it turns out they were just
rendering a bunch of they were just
appending a bunch of dom nodes or
backbone views and a loop synchronously
in a way that wasn't good there's a
bunch of other information here but it's
easy to show you the other information
in the live demo just skip that for now
profiles I'm just going to show this to
say profiles are a snapshot of what's in
memory currently so it's like what
objects are loaded in memory how much
memory are they taking up oh and then
you can inspect them live so you take a
snapshot and you stop your snapshot and
then you can see live what's in memory
the values of all the objects everything
like that so if you have a case where if
you have a case where memory is
increasing and increasing increasing and
then crashing the browser or hanging it
or something like that
memory snapshots are super helpful a
blocking example that you saw this is
basically anything that's blocking will
look like this yellow bar the red bar
means zero means you're dropping frame
rates so as we all know from playing all
those video games like 60fps is kind of
what you want you know where no
noticeable chop or lag or something same
thing in the browser when you're running
rendering a web page and updating stuff
if you're doing anything blocking your
frame rates drop and then everything
freezes to the user and it looks like
your page is not responsive have you
ever like clicked on a button and I like
does nothing and then you click on it
like 10 times and then all of a sudden
like 10 modal's pop up like 2 seconds
later that's blocking that's not
responsive this is what's going on on
that page so non-blocking a more event
based looks kind of like this you're
never going to get away from
having to update the Dom so you're
always gonna have little bits of I've
read framerate drops where you actually
update it Dom but if you look at the pie
chart the difference here in this script
is striking we see most of our time here
spent in scripting over two seconds and
scripting and most of our time here is
idle and look at the start up there it's
mostly white that means that means we're
not doing any blocking work which is
great
memory problems if you do have a memory
problem there's three classes there's
like three types there's a performance
progressively worse over time which is a
memory leak so you're not cleaning up
something this is typically caused by
event listeners being attached to dom
nodes or things like that that are not
being unbound when the dom nodes removed
because then it can't be garbage
collected there's something attached to
it if there's a significant or frequent
performance delays it could be because
you're putting a lot of stuff in memory
it's getting garbage collected a lot
especially inside functions or something
that can be garbage collected and if the
poor mints is consistently bad it's
called memory bloat which it's more of
an architecture level problem so you go
over a couple demos here okay let me
increase the size of the console here
okay so this is the demo app I made this
is a console and it resize the page
there we go that's better okay so I
wanted to show you show you this so say
you're on your webpage I put a counter
at the top by the way you see the
counter in the title I put that up there
so that when I show you the blocking
example you can see how that number
freezes and is unresponsive things like
that so let's say you're trying to debug
some error that's occurring in your app
so I'm just triggering an error let's
just assume it happened somewhere in our
app
and then you get this you get this
location where it is so I'm gonna click
on that which goes to the sources tab it
opens that file so unfortunately I've
used a package manager pretty printed
this alright not pretty printed this
I've minified this which kind of
obfuscates it you get this dialogue that
asks you if you want to pretty print the
file if you click here at the bottom the
these brackets in chrome and it's a
similarly place I believe in Firefox
other browsers but there's always an
option to pretty print you click that
and then you see the actual line where
your function was called if you click a
line number you can actually set a
breakpoint so I'm gonna set a breakpoint
I'm gonna refresh this page real fast it
keeps my breakpoint and then when I hit
this trigger error okay so now I'm pause
right here just pause my execution it
says paused in debugger here and I can
see where that error was so now I can
start debugging based on breakpoints on
lines now this is still obfuscated code
so this is kind of difficult to debug so
if you're debugging someone else's code
in production and you don't have the
source you might have to stick with this
but I have the source we develop this
locally so let's see what source Maps
can do for us ie
this line that says debug Naomi this
line that says debug I
it's basically true or false so if if my
environment is production it's gonna be
false if my environment is is local it's
gonna be true so I'm gonna run a watcher
that's gonna build all my JavaScript
into that bundle and since the watcher
is not in production that was a
production compiled code that we saw
it's gonna generate a source map and
when it does that actually I think I
have to you might have to build first
run build there we go all right run
build and then I'm gonna one watch so if
we
a lot of compile okay so I'm gonna take
up that breakpoint now this is gonna be
a different file so now let's see what's
gonna happen I'm gonna clear this or
refresh we get into you I'm gonna
trigger this error again okay so now
we've added source maps you see where
our air is now it says home Jas line 17
so I'm gonna click that and this is
actually the file now so this is a lot
more helpful already so just with source
maps mapping to the original source
files I can still use my compile bundle
a single javascript file to download but
now I can actually debug it with the
with the real stuff in chrome also so I
can see what this is now so I can set
that on line you know 15 of that file
refresh trigger and iced pause in the
same place so I'm gonna go ahead and
play through that you can step through
and and do all that stuff too and then
chrome shows me this other banner at the
top it says serving from the file system
you can add your local files to Chrome
so you can actually not only debug
inside your browser you can actually add
your local files to the browser to make
them aware of them and give them access
to them and then you can actually change
the files in the browser and save them
back so I'm gonna right click here and
I've increased the font a lot on the UI
but it doesn't seem to be increasing on
the menus so sorry if you can't read
that it says add 5 it says add folder to
workplace workspace so I'm gonna click
on that and I'm gonna add my folder and
then it says it's gonna confirm that it
has dev tools has full access to these
folders I'm gonna allow and you see it
show up here so now I've got my actual
file here so let's see it's a component
and its home so this is the file it was
showing me earlier with the with the
error triggered here so let's see
console one more time let's figure that
error and now it's taking me to
this file so now when I go in this file
I can actually I saw that the error was
there and now I can actually remove it
and I can hit save and you notice the
asterisk on the file name and then I hit
command s and it saves it goes away and
since I'm watching the files since I've
got a watcher runner and the watcher is
it recompiles automatically on file
changes so I've got the watcher running
so I have to do the rebuild manually now
let's play through that again I'm gonna
refresh that again I must have another
breakpoint somewhere and then I can I've
got that yeah that's where I got the
breakpoint okay but you see the errors
not there anymore so I'll hit that
console nothing so we've actually fixed
the problem
so we've debug did real problems
probably gonna be more complicated than
that there's a lot of other breakpoints
you can set and I will show you one on
inbox so I'm fetching these messages
from from a server as from the same
server I'm running locally here and
we're doing that async so it's not
causing any you know issues like that
but what if we had a problem on an async
call and you didn't know exactly where
it was coming from you can't go back to
sources and again the menus are not
responding to the font size increase
okay so let's let's pretend that for a
second that I don't know where those are
coming from so if typically this panel
is on the on the side but the screens so
small it it's put them at the bottom you
see these classes of breakpoints so
these are the breakpoints I've set I'm
just gonna remove all breakpoints when
you when you brake you also get
stack and I'll show you that in a minute
but I'm gonna set it X you see xhr
breakpoints so I can actually set a
breakpoint on any xhr call and then when
i refresh this and fetch it pauses right
there and you see this this fetch up in
the source now you can't see that on
screen dang it okay so I'm calling the
fetch API here so it's actually breaking
here now if I need to figure out what's
going on inside that call now that I'm
in the source I can actually set another
breakpoint wherever I want to so I'm
like okay that's fine I actually need to
break down here so I'll hit play and
then I'll break on my second breakpoint
and you notice in line already I've got
it provides you with the value of the
variables in line when you're debugging
when you're paused if you look at the
call stack you can you can see yep you
can see the call stack it's not big I
guess fee and I didn't name the function
so it says anonymous which is super
unhelpful so I apologize for that
but it does give you the you know the
place where it was called actually it's
paused inside here if I if I had shown
you the call stack at fetch you would
actually have seen a useful call stack
but another thing is this scope and
watch the scope these are the local
variables defined in this scope so you
see this JSON variable here you can
inspect it by hovering over it and then
you know expanding it these are the
messages that it's giving back to me and
locally here as well if you want to see
how a variable changes over time as you
step through code line by line execution
by execution function call by function
call you can add a watch expression so
I'm gonna add a watch expression for
JSON JSON DUP messages I get and I can
see that that's an array in this context
and then when I play that through it's
not available anymore so if there's
specific things you're looking for
you can look for those you know and then
if I were to run this again you know it
would it wouldn't be available there but
then I could play to the next one and
then and then there it is you know and
if you mutate that in a certain way with
through a series of functions you can
trace that step by step so really really
cool stuff does anyone have any
questions so far if you have a question
you can shoot up your hand and I can
answer it yeah oh hold on we got a mic
right here sorry this thing on hello
does the source mapping feature does
that work on if you're developing with
languages that translate into JavaScript
or will that just map you to the first
translation of the JavaScript um
this code actually is transpiled so this
is all es6 code I'm using import
statements which are not supported in
the browser I'm using classes and JSX
and stuff so this is actually our all
transpiled
so the source map actually points you to
the source file whatever it is so if
you're using typescript or you know
something like that
and converting it or you know closure
script or whatever it can show you the
original source files all right and
throughout throughout this like I said
if you have questions just feel free to
put your hand up would you have a mic
though for the live stream so wait till
the mic comes to you okay blocking and
non blocking I wanted to dig into this a
little bit more so notice the counter at
the top like I said I put another
counter here because that was before I
put one at the top just well I'm gonna
click this button and watch that watch
that counter this is what blocking does
to your app and why it's so bad so that
kind of just stopped and then it
continued so if your users on your page
and you do something blocking this is
this is what your user is gonna find so
I go to performance tab it was
previously called timeline now it's
called performance I got a performance
tab I'll reload
I'll hit block and then we'll take a
look at what that looks like that's
where I got that screen shot
chrome has the option is it Chrome has
this option to provide you with
screenshots so if you click screenshots
it actually takes a screenshot of the
app as it's going through and you notice
that timer notice that that timer is not
actually updating at all during this
whole block until we get until we finish
it so that's how we know it's blocking
in and up here did we get that red bar
that will show FPS let me see frames yes
yes your frames per second let's let's
look at the whole thing here so this is
your frames per second and our frames
are like okay these are single frames
but we're getting 0 fps for 2 seconds
that's what we know that's terrible
and then we can dig in so this is a
flame graph is anyone familiar with
flame graphs call they're basically call
stacks ok so it it's whatever you called
and then whatever that called and that
called and I called all the way down and
it tapers down until one person familiar
with flame graphs all right the guy who
works on Firefox dev tools ok and then
you see all these sleep calls down here
so I have do blocking thing and then all
these sleep calls and then you see all
these minor GC garbage collections
things like that you can also get a
other cost you know bottom up a flame
graph is kind of like top-down tapers
down you can get a bottom up call stack
to see what the actual problem was it
says most of our time spent is in this
sleep function obviously that's walking
it's called sleep that kind of stuff so
in the real world what can we do you oh
I wanted to show I'll run through the
inbox and
on three events so what's it actually
you know what in boxing people are
examples it's actually fetching
something I'm gonna hit fetch messages
here and that was pretty fast and this
is kind of a difference between a sink
and sink in JavaScript so you can see
where the messages came through in the
screenshots just by me moving here this
little bitty spike right here is where
the screenshots came through and I'm
still I haven't really dropped any frame
rates at all just by doing that async
instead of sink so if you ever are
tempted to do an ajax call synchronous
or something like that don't do it ever
don't it will block okay
so let's maybe a more real-world example
of of something I didn't need to have
that profile on okay there we go let's
clear that for now so this is what I ran
into it work a bunch of dom nodes were
being appended in a loop and the
question is how can we make this not
blocking how can we still do the work we
need to and make this not blocking so I
wanted to include a more real-world
example for you guys so you maybe have
something to take away from here and
some things to look at so I'm gonna
append a bunch of items to this file and
I'm gonna do it with several different
ways and then show you the difference
between those so I'm gonna refresh to
get our timeline going and then I'm
gonna append them with jQuery and you
see the items were added here after a
while but if you we're watching our
counter at the top it's actually still
blocking still not moving
so I can zoom out here oh it's acting
really slow sorry okay so after zoom out
a little bit it didn't even complete it
actually finished the time client before
it completed and appended the items to
at no point do we even see the items
come in here but the point is you see
this you see this big yellow you know
yellow bar notes the time is being spent
in building and appending the Dom node
I'll show you how we're doing that here
okay so this is what we're doing for
this example can everyone read this okay
all right we're just naively building
our items in a loop and then appending
them to a Dom node why why would this be
slow anybody yeah that's right
that's exactly right so every time we're
calling a pend here it's actually
updating the Dom so we're mutating the
Dom in a loop and I think it's like a
thousand times the items num constant I
think is a thousand so we're updating
well let's take a look at what that is
yeah it's a thousand so we're actually
mutating the Dom a thousand times in a
loop and we're also using jQuery to
parse this HTML and and build it which
is can while convenient is slow so how
can we improve this let's take a look at
moving this to vanilla j/s approach just
plain JavaScript Dom scripting vanilla
Janice is not a framework okay and we're
gonna do something a little bit
different here
we're gonna create a container node and
then we're going to we're gonna create a
container node that we're not attaching
to the Dom yet and then we're gonna loop
create our items and then append those
in the container node and then at the
end of the and at the end of this
outside the loop then we're going to
append our container node so
seems like gonna be pretty faster right
we're not mutating the Dom in a loop so
let's check it out and hit refresh and
I'm gonna click append vanilla and
alright I'm still come on what's going
on here okay there we go whoops I don't
think I clicked it there we go so
there's our items we got in our loop
there's thousand ohm I won't scroll all
the way through we still get we still
get blocking though so this is less
blocking now we're only blocking for 283
milliseconds instead of like over two
seconds so that's already a lot better
that's like it's like almost a 10x speed
up so if you went to your boss and we're
like hey I just improved the codebase by
10x you know he'd probably be really
happy with you and you can probably go
home satisfied you know job well done
that kind of stuff
but we're still locking the UI we're
still dropping frames we can see 4 FPS
here we still get the red bar so this is
kind of potentially still a problem not
as much of a problem maybe not as
noticeable of a problem but you're if
this is an operation that you're doing
you know a lot of times your visitors
are certainly gonna notice this so if
you're building a game and not
constantly adding objects to the Dom or
you know something intensive it's
definitely still gonna cause some issues
so it might depend on your use case
whether or not you want to go further
down the rabbit hole but we are going to
just because it's fun so how can we do
this then
that's synchronous so what if we just
tried to cheat and do this asynchronous
so I've got a append append this asing
so basically we're going to do the same
work as we did before only this time
we're going to use set timeout as a with
a zero value if you do set timeout zero
this is going to put it on the event
loop instead of the call stack so we're
kind of side step work
make sure we you're not blocking the
call stack that's what this does but
it's the same work okay as before so I
think this will run faster and matter at
all we're kind of making our code more
obtuse though right we're adding a set
timeout someone that comes to reads that
might not know why we're doing that so
let's check it out
that's the async Mouse there so I can
click on it and then we got the items
back already so kind of seems like maybe
faster all right so this is interesting
now you can see where we got our items
the interesting thing here is we
actually are we've improved our time
slightly but probably within margin of
error right but look at the call stack
look at the look at the flame graph here
and look at the blocking so our red bar
here we're actually only blocking for
about half of that time now instead of
the whole time and what's interesting is
we've done all of our whoops sorry I
just reset ok so we've done all of our
work here and you see the the set
timeout calls here that are called a
thousand times you know at the bottom of
this call graph and then that's where
the blocking bar kind of stops right
there and then you see all this actual
work here where the Dom nodes are
getting inserted so so we've done a
little better
we're not blocking anymore and we're
only blocking for about half the time
it's taking roughly the same time
overall but we're only blocking about
half the time so we've actually made the
page a little more responsive done a
little bit better so that's interesting
we're basically so what have we done
here we've basically said instead of
forcing you to render right now you can
render I'm gonna tell you to render at
the next tick of the event loop in
JavaScript so we're putting it all on
the event loop which does help
but what if we could what if we could
what if instead of us telling the
browser when to render our stuff what if
we could actually ask the browser when
it's ready to render and then give it
stuff to render so that is what
requestanimationframe is so we're gonna
go over requestanimationframe now so
we've replaced our set timeouts with
requestanimationframe here that
highlighted it's difficult to do that
quickly with two single freehand but
we're using requestanimationframe
instead and we're and we're providing
our function and our we're passing in
our function and basically what and then
our function is going to call
requestanimationframe again if we still
have items so this line this line here
you know if we have items left if we
haven't printed them all yet we're gonna
request another animation frame and do
another batch so we're batching this now
into a certain number of times here so
let's do this first okay so we're
batching we're gonna start at zero and
we're gonna do a hundred at a time we
can do 100 dominoes at a time and we're
gonna see what happens we're just gonna
append those all right so I'm gonna
refresh since I changed the JavaScript
there okay okay so Anahit
requestanimationframe and we see that
our items are appending they're actually
still appending now so we actually
haven't done this faster but look at our
timeline
we're not blocking we're getting 23 29
30
so maybe did it a little bit too fast
but we're not blocking at all now
so the timer will continue to run if you
saw at the top of the page I'll do it
one more time top of the page
requestanimationframe that timer up
there's continuing to run it's a little
bit jittery because we're getting about
30 FPS now instead of our 60 so what you
essentially have to do
requestanimationframe is like after is
like the browser saying it's done all
its cleanup for the next cycle and says
okay I'm ready to paint stuff and then
you give it stuff to paint so maybe we
gave it too much but you can adjust this
number you know dial it in for whatever
device you want to use so we'll go go
here so this is actually faster less so
that's interesting right so the thing
about requestanimationframe is the
answer to how many how much work you do
in it is well it depends so we actually
went from a hundred Dom nodes down to 50
and I actually did our work faster
overall which is kind of which is kind
of weird but the thing is we were doing
too much work so we were actually
running up against block in the browser
a little bit and that'll depend on your
device you know how much memory RAM you
have anything like that let's see oh
that was it okay and then if you do them
all let's whoops I had difficult to do
this one-handed
we do them all in one go and see what
happens here I will click the ok so we
actually blocked again so even using a
pressed animation frame there's an
animation frame fired thing we just did
too much work in it in a single frame
you want to complete your rendering in
about 10 milliseconds or so with
requestanimationframe this will depend
on the you know CPU speed of your device
on a mobile device will be different and
you kind of have to dial it in so the
goal of all this though is to say we can
do this non-blocking it's it does take a
little bit of work but our fastest time
through with no blocking was when we did
50 here and and then we're done already
see so all this is to say this actually
took a longer amount of time I had the
wrong part of the frame here it's over
here we're all the animation well no it
is here so it's doing all the work here
and overall it's taking us you know
about a about a second or so to get all
those items in but since it's not
blocking its so although at the time and
before when we were blocking we did it
in about 200 milliseconds ish and we
were blocking for about half of that so
like 100 150 milliseconds or so we were
blocking and we got all the items in
faster speed wise but we're still
blocking so in JavaScript really all
programming is kind of trade-offs and in
JavaScript I think especially on the
front end is about trade-offs so you
might choose a trade for a longer
overall time for a faster perceived
speed to the user so since since we're
not blocking at all this is going to
faster for the user and since the user
can't scroll down and see the thousand
nodes anyway in a second it's really not
gonna matter so it's a trade-off we're
taking over a second to do it now but
the it's not gonna make any of the rest
of the app unresponsive at all so it's a
trade-off right are there any questions
about anything I've done here okay we
have one in the back there
the profile timer to start and stop when
you click the button oh sure yeah when
you first so I'll clear this yeah yes so
you can actually start and tie and stop
it in time if you manual click the
record button or hit you know command II
I just hit command R to reload the whole
page and then clicked and command R
reloads and evaluates the whole page so
that and it tells you you know right
here if you load it up empty if you
start in the performance tab if you're
already there when you refresh it'll
start tracking immediately otherwise you
can and you're always gonna have this
initial stuff that has to download and
pars your JavaScript so you're never
gonna get away from that but if I want
to clear this and then again difficult
to do this with one hand I want to click
command E and then click a button I can
so there we go so I can start and stop
it with just come in yep okay and then
that's turns out that's really about the
fastest we can go so instead of saying
to the browser hey render this stuff
right now we're asking the browser for
the next animation frame that's the
requestanimationframe so we're so
instead of ordering the browser around
we're being nice and we saying can you
please tell me the next time you can
render stuff and then I'll give you some
stuff to render and it's this cycle so
are there any further questions anything
performance that you or anything in
there you want to see I didn't show the
memory I'll show you one more cool thing
before we're almost done here allocation
profile so if you're doing an allocation
profile I'll do this and then Oh
it's start and then all at Penn jQuery
and then it's done so I had stopped okay
so I did allocation profile and what
this shows is all of the functions that
are is actually from a plugin but it
shows you functions that have used the
most memory and you can sort by that you
can drill into them all kinds of stuff
useful stuff you can just go deep anyway
there's a bunch of stuff in there but
just already bug all the debugging tools
you need are here in your browser for
free by all the major vendors so dig in
your code start profiling it and see
much fine thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>