<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Async / Await and Asyncio In Python | Coder Coacher - Coaching Coders</title><meta content="Async / Await and Asyncio In Python - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Async / Await and Asyncio In Python</b></h2><h5 class="post__date">2018-03-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vN5eBmcAlMA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's talk about async/await and the
first question is why do we even have it
because there are so many other ways how
you can do concurrency for instance you
can do threads or you can code with
callbacks and promises or maybe you can
do G event or use event land or
stackless python or maybe you could just
use generators with yield from syntax
and the answer is readability
it's an arguably better than code books
or promises I think anybody who tried to
debug will refactor some JavaScript or
old Python code with a lot of nested
callbacks can attest that it's easier to
reason about the async await code you
just see all those explicit points in
your code when you can switch context
for i/o or for something else and it
actually promotes better patterns like
message passing and not having global
shared data structures because no matter
what you think about your ability to
write multi-threading code you will
inevitably end up having situation on
the right side any other reasons well
efficiency since we have this little
problem in Python called gill threats
aren't always the answer but even in the
languages like C sharp where there is no
gill
we still have async/await why is because
threads are a system resource you cannot
have an infinite number of threads so
with async you can have you can handle
thousands or hundreds of thousands or
sometimes millions of open long lasting
connections on the server anyways what
is async/await
well obviously is the syntax we added
them first in Python three five and
where that syntax to define coroutines
or async functions syntax for
asynchronous context managers
asynchronous iterators and obviously a
weight expression in three six
we took it even further
we now have a synchronous generators a
synchronous list comprehensions and even
a synchronous generator expressions and
I'd say that at this point we have
almost complete coverage of whatever you
can do in Python synchronous mode you
can do it with async away except one
thing
this is yield from yield from for a
synchronous generators we might add
syntax for yield from in 3:7 but this is
not a top priority I'll be honest with
you
what else is facing is async await it's
a protocol there is a common
misconception that async await was
created specifically for async i/o or
only a think I can use it and this is
not true in certainly async await based
on the iterator protocol we have a bunch
of magic methods like Dondre weight
which allows you to make an object of a
table or used in an await expression we
have magic methods to define and create
asynchronous iterators and asynchronous
context managers so it's pretty generic
you could totally write your own
framework for async await but you
probably shouldn't it's a lot of work
unless you want to experiment of course
so if we take a look at modern async
await application there is a stack and
at the bottom of the stack is operating
system of course then we have Python
interpreter and then we have a sing
framework the tornado twisted pure trio
or maybe async i/o and then we have
application framework maybe it's a HTTP
or sanic or something else
Django flask if they have ever a
synchronous versions and only then you
have your applications so what kind of
frameworks do we have the good news is
that twisted and tornado can use
async/await syntax today and twisted is
actually mother of async and Python so
much originated from twisted and I think
no one even
knows how all twisted is now but it can
use async await now and both twisted and
tornado have big ecosystems and maybe
what's even more important they have big
mind share so there are lots and lots of
questions on Stack Overflow and
sometimes answers tornado today and
twist it very soon maybe tomorrow we'll
be able to run on top of a TKO and what
it means is that you can call a tinker
libraries from your tornado code or
maybe soon from your twisted code or
maybe you'll be able to use twisted
libraries we should have which we have a
lot in your a single code so this is
this is quite good we also have Kurian
trio those are two new kids on the block
both try to explore in new approaches
both try to make async easier and maybe
sometimes safer to use and of course if
they find something you were new useful
patterns good ideas will steal them and
put them in async i/o but that I can
promise both are not mainstream yet
Curia is like year and a half years old
trio is is a few months it's really good
projects and I really encourage you to
take a look at them and to explore how
they are implemented in the inside it's
it's quite an interesting take of how
you should do a sink or can do a sink
but not mainstream yet anyways let's
talk about async IO so what is async
async' leo is first of all a foundation
it defines low-level API a high-level
async/await DPI's it is here to stay and
it has a pluggable event loop so what
others low-level api is that's of course
stuff to schedule callbacks to write
protocols with transfers to the network
sub processes handle unique signals all
callback based all very low-level
but this is actually a good thing to
have because it allows us to integrate
with other low-level code written in
languages like C C++ and others on top
of that it has async/await
to run coroutines and also to those
streams and sockets do network
programming cool sub processes use walks
if you like dead logs timeouts
consolations everything there is handled
in a scenario it has all the tools it is
mainstream
starting with Python 3.6 it's no longer
provisional it's under standard library
and this is a promise from core
development community from Python
community that Asian Caillou is a safe
foundation to bet on it has a healthy
ecosystem surprisingly we have have a
few frameworks right now to do HTTP in
Python it's a HTTP enik and there are
many others we have database libraries
like 18 PG we have support from my
sequel a or my sequel radius memcache D
pretty much all of them are covered we
have a swath of libraries and a libs
organization on github so I'd say pretty
much every major component of our
systems have has some sort of
async/await library around it and it has
a pluggable event loop and this is
something that was envisioned in the
very beginning of facing Guyo
this is something that lets async i will
be integrated with frameworks like
twisted or tornado but it also gives us
the ability to switch the event loop and
do something something fun with it like
make it faster so there is this project
called yoga loop and they it has this
promise or idea to make a single to four
times faster and it does in micro
benchmarks but it's not it's not
surprising to see 15 28 30 and sometimes
even 50% speed ups in real production
code so if you haven't seen you look
before haven't tried it definitely give
it a try
I'd say that at this point of time it's
stable and it's safe to use in
production so it's
and here is something else we call this
Python ym3 oxide this is a new github
group that we created just about months
ago and it explores a way to bring rust
to Python so let's get back to this
pluggable event loop idea what if we
could have an event loop an Asian guy
event loop written in rust so that async
i/o becomes a bridge from Python world
to rust world what if you could call a
quality and implemented in rust in
Python with the timeout and cancel it
later what if you could have an HTTP
server or some protocol implemented in
rust and then used in your high-level
code so this is the project that tries
to explore that it's not there yet I
think it implements most of the async
i/o api's right now but it's still
incomplete and still experimental it's
not as fast as usual OOP right now but
it will be there and one of the things
that we actually want to focus here is
safety because you will loop and a lot
of other accelerators are written inside
and see and it's sometimes you find
sexual sometimes sometimes you find bugs
with rust you just don't have this this
kind of problem and you have performance
and rust is this new shiny thing it's
everybody's favorite language even
though nobody knows it so it's it's
really cool and I really have high hopes
for for this new things so definitely
check it out it's on it's on github life
so let's talk about what's next for I
think what will happen with this email
we have some goals we have some goals
for Python 3 7 specifically one of the
first things that we want to make sure
of is that we can run and use twisted
code on 18k oh there were some blockers
to that but I think we kind of dressed
them all in three six and in any case
for three seven this is one of the
things that we want to do that want we
want to make sure that everything that
was developed for Twitter
there is a lot of good code that we can
use it in I think I owe another question
is maybe Curia and trio can be built
rebuilt on top of a sink IO
maybe this will let us fix bugs in a
sink IO because of the increased user
base or maybe we will be able to have a
compatibility between async IO code and
curiel called or trio code this is
something to explore so this is another
goal is to see if we have enough api's
or if our api's are flexible enough to
implement a new source of frameworks new
async/await frameworks on top of a
single and the trust loop so we have
some problems right now in Tokyo for
instance right now it's really hard to
have a task or a corrosion and rust to
be fully compatible with Python the rest
of low-level details it can be work
around it but we definitely want to make
sure that in 3:7 it's straightforward so
maybe if you're writing your next event
loop
I don't know in pure assembly you will
be able to meet the great easily with
async i/o after three seven the other
thing that we want to focus in Python 3
7 is to improve usability and
specifically to address the issue of
documentation currently documentation of
async i/o is it's huge I'd say it's
really hard to follow it is it focuses
too much on low-level details instead of
teach people how to use async I or how
to use it in an optimal way how to
maintain code bases with facing i/o how
to write frameworks and protocols for
hissing curve in an optimal way and the
original documentation by the way it was
written by victor Steiner and I think he
deserves some credit for it because he
did it single-handedly when async I
wasn't such a big thing as it is right
now he written all of it and I think we
kind of dropped the ball and we didn't
update it we didn't really maintain it
so this is one of the top priorities for
3:7 is to fix the documentation make it
easy to learn
add some tutorials to it so we'll be
focusing on that and of course if you
guys want to help you're welcome to do
so
usability now this is an interesting
topic these are the functions that you
that if you know this function these
functions you can pretty much write any
a single program this is this is also a
sink i/o there are a couple of more but
not not really important if you
understand how these functions work you
can do it but if you doesn't work
anyways if you if you look at them you
will see that some functions are
prefixed with a sink IO and some
functions are prefaced with loop and
this is another subtle problem with of
async IO and maybe it's also a
documentation issue the idea was that a
single programs try to always pass event
loop explicitly in your program so you
always carry the event loop object
around you you cannot do things without
it so a sinker itself all of a single
unit tests many of 18k up packages they
all accept loop argument they will
expect you to pass it it's kind of
really suboptimal but in Python 3.6
we've fixed get event loop method and
now it behaves deterministically
whenever you call from an async await
code it will always return you the
correct event loop so idea so the idea
is that you can have your high-level
beautiful async await API and whenever
you have to go a low-level in your
implementation you always can get this
event but you don't need the user to
pass this event loop for you around so
pretty much starting right now we start
to encourage people to design their
api's without explicit event loop in
mind but for 3:7 we'll need to fix many
of our api and add new api's to promote
this pattern so that high level ii think
i'll programs don't even care about the
event loop it's a low level detail don't
think about it don't bother with
you also need to do we also want to add
new things one of them is start CLS
there are some protocols that start as a
clear text and then they suddenly need
to upgrade and become secure and they
need start TLS there is also a very
frequently requested feature by Armin
Ron occur to add call and past context
api's perhaps he wants to reemployment
flasks or something but this is quite a
serious thing actually this is quite a
serious issue for large applications if
you have thousands of lines of code or
hundreds of hundreds of thousands of
code sometimes somewhere deep down below
you realize oh I need more context maybe
I need the current request object or
maybe I need the current host or a port
that I am connected to for logging or
for something like that and without
rewriting all of your code you pretty
much can't do it you cannot use thread
local objects because they don't work
with async async' Anna wait you cannot
use a global variable because it's a
shared state so it's really hard and one
of the last major thing is things is to
add a single rebel so that you can just
type Python - mmm async i/o or maybe
just Python and experiment and play with
async i/o with its native syntax so that
you can just write await something and
that would do it for you and overall we
need your help ask when you ask for the
new features you can use bugs Python -
torque for bug requests bug reports but
you can also use it for feature requests
we also have Python tulip mailing list -
loop is the original name of evasion
kayo
but it's still quite active Twitter is
it and helps people a lot a lot of other
Asian co-developers feeded and we also
on github c python moved to github
completely and everything now happens on
github we can issue pull requests it's
so much easier the whole idea of this
migration was to involve more people in
C Python and also in async editable
so help us guys I think I think Asian
kayo has a very bright future especially
with things like rust integration this
this this might enable us to do so much
more in the near future that's it see if
you guys have any questions I'd be happy
to address them</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>