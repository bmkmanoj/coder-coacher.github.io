<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Top To Down, Left To Right (aka What Do You Not Know You Do Not Know About Python?) | Coder Coacher - Coaching Coders</title><meta content="Top To Down, Left To Right (aka What Do You Not Know You Do Not Know About Python?) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Top To Down, Left To Right (aka What Do You Not Know You Do Not Know About Python?)</b></h2><h5 class="post__date">2018-04-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DlgbPLvBs30" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah this is a talk that I put together
called top to down left to right and
it's a little bit about Python if you
like this talk you can follow me on
Twitter I'm don't use this code on
Twitter
I'm also don't use this code on github
and a lot of other places I'm going to
sit down for the rest of this talk
there's a lot of typing involved this is
a by the way fair warning this is a
novice talk and this is a pure Python
talk so if you know everything there is
to know about Python this won't be very
interesting to you if you don't really
care about Python like you're an art
programmer this really won't matter to
you the revenue our programmers in here
who are just watching these talks out of
pure spite okay good this is part of a
series of talks that I've wanted to give
about what is it that the audience
doesn't know that they don't know about
Python so a couple of things that even
people have been using Python for a
while might be a little bit surprised
about what I want to do is I want to
start you off with a couple of questions
then I'll give you about three minutes
of theory that will explain all of the
answers to all the questions then we'll
go through all the answers as I go
through the questions I'm gonna need
your immediate feedback to get a sense
for what is it that you know and what is
it that you don't know so let's launch
into it really quickly I have two
scripts top and the bottom pane from
math import log and the import a log of
E in the bottom import math math log
math dot e what's the difference between
these two just shout it out if you have
any idea what's the difference we don't
we don't have much time so you got to
shout really loudly really energetically
one shorter ones maybe a clearer one
uses the namespace does anyone else see
any difference between the two of these
nope okay let's move on this is a very
simple exercise I want you to shout out
valid if what I show on the screen is
valid Python code invalid if what I show
on the screen is invalid Python code and
if you hear somebody say the wrong
answer shout out wrong
just so I know that there's some
disagreement Python 3 this entire talk
is in Python 3 7 just because there yeah
whatever right
valid or invalid valid or invalid valid
or invalid wrong
that one's valid valid or invalid valid
or invalid everyone thinks it's valid
anyone here any wrong answers be sure to
shout out wrong so I know there's
disagreement let's do this next one here
valid or invalid invalid valid
mmm somebody has a right or wrong answer
how about this last one here who thinks
it's valid who thinks it's invalid who
thinks it's valid but useless that's the
right answer
let's also cover a couple of let's make
sure that you have a little bit of
background information so I have X I
have Y there 2 lists is X equal to Y
true or false X is equal to Y true they
have the same contents X is y true or
false false they are different objects
very good so if I append for 2 X does it
show up in Y no they're different
objects if I pen for 2 X it will of
course not show up in Y similarly if I
look at the IDs of x and y are they the
same ID or different IDs different very
good you guys are real smart let's take
a look at a very similar problem x and y
are they equal to each other are they
the same object very good so if I pen
for 2x does it show up in Y very good
what about their IDs they're the same
okay very good so you'll you won't have
too much difficulty with the rest now
let's say I have code that looks like
this at the bottom is a script that
imports the module at the top
what gets printed does called f get
printed when I run the script below no
does defined F get printed when I run
the script below what if I add this code
does define G get printed who says yes
we got to shoot from the hip we don't
have a lot of time to think in this talk
so who says no who says only defined f
gets printed who thinks that when I add
in these two lines it's not a lot of
code here and I add in these two lines
the output of script py changes who
thinks it remains the same
nobody thinks it changes a couple people
think it's changed good a couple of you
have used flask or other tools that have
module reloading you ever wonder why it
is that when you change something on
disk you have to shut down your Python
interpreter and start it back up or even
restart your jupiter kernel just to see
those changes
why can't python be smarter why can't
Python realize the file changed on disk
just reload everything let's take a look
at an example relating to that I have
Class A and Class B I have a script
below from module import a create an
instance of that is a an instance of the
class a gotta shout it out yes you can
shout out an English polish I'll take
any language is B an instance of the
class B yes no yes of course it is
import Lib has a tool called reload that
allows you to reload modules is a still
an instance of a after I reload this
module is B still an instance of B how
about if I write the code like this the
answer might surprise you let's take a
look at the last two examples a remains
an instance of a but B is no longer an
instance of B and then in the last
snippet of code there are neither
instances of the class themselves so
we'll see we'll go over a little bit of
theory to figure out why it is that the
answers to this are
true/false for this is false and false
it might surprise you okay let's imagine
that we're writing a little bit of code
maybe we're the best Python programmer
in our company and we're at that company
in order to show people how to really
write proper Python code so we write a
class and we need to add a little bit of
data to that class maybe a little an
attribute called B except B for some
reason or other can never be negative so
if somebody tries to set B to a negative
number we need to provide some error as
quickly as possible you have a co-worker
who's a Java programmer and tells you
well that's a setter and a getter what
do you tell that co-worker it's not very
pythonic because what do we have in
Python that allows us to avoid this
pattern property very good so you say
write something like this use a property
and it'll intercept the set attribute
and the get attribute and it'll just
work you don't have to write setters and
getters and when your main code looks
like this it'll just work and if I
accidentally try and set this to a
negative number this line here will
raise an error telling me the value must
be positive everybody's in agreement
that's how you write proper Python code
let's say we have a module and that
module has a constant in it called a and
we have some script that alters that
constant maybe sets it to 1 what if that
constant can never be negative we have
to write a getter and a setter don't we
can we get around this mmm-hmm so you
see there's a break in this pattern for
a normal Python object we'd use a
property to get around having to write
getters and setters but you must have
seen this pattern on modules before
where people again have to write boring
getters and setters to intercept changes
to the module itself maybe there's a
better way let's look at another problem
and I think this is the second-to-last
problem we'll look at what gets printed
when I run the highlighted lines to list
what are the contents of that list zero
very good what if I add in this next
line here does it print the same thing
does it print something different
zero one very good some people have
heard of this problem it's cause often
called mutable default arguments what
happens when the third line gets printed
0 1 2 hmm that's kind of curious this is
a problem called mutable default
arguments when a default argument is
mutable some of the behavior might be
not be what you expect which is why if
you go under Stack Overflow and you look
up this problem you'll see somebody
propose an answer that looks like this
set X equal to none and then inside the
function check is X none and set it to
the default value if X is none here what
gets printed with the first line 0 what
gets printed when I look at all three
lines 0 0 0 probably what I expected
let's take the original code up here and
let's just nest it in one more layer of
a function what gets printed when I run
this is it 0 0 0 or is it 0 0 1 0 1 2
some people say 0 0 0 does anyone say 0
0 1 0 1 2 let's take a look okay 0 0 0
hmm that seemed to have fixed that seems
to be another way we could fix this
problem
how about here that kind of looks like a
decorator if I look at this this kind of
looks like what I do for a decorator so
if I create a decorator that looks like
that and I run the code in this fashion
what gets printed 0 0 0 or 0 0 1 0 1 2 0
1 okay very good that's exactly what's
gets printed what happens if I stick
this into a class does that change the
output which are the two outputs do I
get I don't know all zeros or 0 0 0 0 0
or 0 0 1 0 1 2 did I avoid my mutable
default arguments or not I did not avoid
this problem
what happens if I just make that our
normal instance method does that have
any effect whatsoever mm-hmm you summit
so do I get 0 0 0 or 0 0 1 0 1 2 0 0 0 0
1 0 1 2 mmm something's kind of funny
here let's look at the last problem that
we're gonna solve some of you know that
there is a built-in function called
locals and it gives you all the local
variables that you have in scope so
there's not much in this in the script
that runs you can see there's a bunch of
default variables name file package
annotations built-ins you might know
there's also a variable called Global's
in the case of a script like this
the Global's and the locals are the same
thing you can see from this line here
the locals is the same as the Global's
so that just gives me all my local and
all my global variables so if I say
here's my old locals I define X will
that show up if I look at the difference
between my locals after the definition
and before the definition will I see
anything new I should i defined a
variable well interestingly enough I
don't see anything new why might that be
well it's the case that this locals is
not a copy of all the local variables
but the actual current dictionary of all
the local variables so I might need to
make a copy just to see that change here
I capture what are my local variables
before make a copy of all those names
and then I'll print out the difference
and I can see oh this Y variable got got
created pretty pretty simple what does
this print
anybody else there's only there's home
there's only a couple options that it
doesn't print anything or prints 10 so
who thinks it doesn't print anything who
thinks it doesn't print 10 how many are
programmers here are like I have no clue
what's going on okay that prints 10
pretty easy
what is this print hopefully more than
one person can answer what this prints
what is this print 10 very good
what is this print good the confidence
level is rising what does this print
name error mmm
wrong answer wrong answer what does this
print 10 or 100 prints 10 had no effect
whatsoever that's kind of weird
so maybe it's a global what does this
print does this work it works and it
prints 100 wait a moment something's
really weird python must be incredibly
complicated for all these different
behaviors to show up like this what does
this print and give you 2 to 3 choices
10 1 and 100 this is your basic closure
which of these three does it prints 10 1
or 100 100 anyone think of prints 1
anyone think of prints 10 Prince 10
what does this print
what error very good it doesn't print
11a prints unbound local error hmm
that's kind of weird finally and this is
the last question I have we have a bunch
of statements in the Python grammar
while for with def class two of these
statements two of the things that would
show up in yellow on my screen have no
corresponding executable code does
anyone know what they are actually yeah
three of them so including pass so what
else other than pass okay we'll talk
about that okay so let's talk about the
theory it's very little theory behind
this the reason I like this talk and the
reason I like this topic is I showed you
an enormous amount of behavior what you
couldn't immediately guess the answer to
and it seemed like the model for how
Python worked must be very complicated
it seemed like all the operation of the
Python interpreter flash back to when
you were writing C++ there's no way that
you could understand how the Python
interpreter worked but you're wrong the
Python interpreter has an incredibly
simple execution model and I'm gonna
give you about five minutes of theory to
explain how that execution model works
and then the answer to every one of
those questions will be clear as day in
order to do that I need to introduce
something there is a function in a
module in the standard library called
this let's see what it does
it disassembles classes methods
functions generators or code okay so it
shows me what the byte code that runs in
a see Python interpreter for a given
piece of code so let me try and
disassemble Len oh I can't disassemble
Len so I can only disassemble Python
functions it can only give me byte code
for things that are written in Python it
can't give me byte code for functions
written in C like the built-in function
Len so let me try and disassemble this
function here well that's interesting so
there's a little bit of data on my
screen this 3 here is the line number
for the corresponding byte code it's
printing out so line 1 2 3 so this is
the bytecode for pass well you know that
a function that has no body just returns
none so what does it do it loads the
constant none and
you can kind of see what it does loads
of value and returns it the number in
this column over here is the offset for
the bike code so you can say that load
constitu bytes long you can't tell me
how long return value is but it's I
think only one or two bytes long this
value here is the actual is the actual
argument for that opcode and in
parentheses is the interpretation of
that so this load Const had an argument
0 which you can interpret as the
constant value none we'll see what that
means in a second let's disassemble this
function and see what it looks like well
it load fast so I don't know what fast
means but I know what load means it
loads the variable X it loads the
variable Y it does a binary ad well yeah
it doesn't add two things together and
it returns that value ok pretty simple
look bytecode actually is quite easy for
me to read let's take a look at
disassembling a class wait a second it
doesn't print anything at all it's kind
of weird let's wrap this in a function
and then trying to assemble it okay
hey I got something here so let's see
what it did it load build class I wonder
what that is it loaded a constant value
and that constant value was a code
object sitting at some port in memory
named a in some file standard in it
loaded a constant the name a it called
this thing called make function it load
another constant it did a bytecode
called call function it stored that to
the variable a it loaded nun and a
return it because this function returns
none so that's interesting let's do the
same thing with the function let's see
what happens here I loaded some constant
some code object I loaded some constant
which is just a string with the name F
in it I did this thing called make
function I stored it to the variable F
and I didn't return anything ok let's
take a module that looks like this it
just has a function that was defined in
a class that was defined and let's try
and disassemble that function or sorry
disassemble that module well you can see
it when it try to disassemble each of
the constituent parts so nothing too
different than what I saw before
finally let's take a closer look at what
happens when I define a function I load
some constant I call this bytecode make
function and I store the result to the
variable F let's see what happens when I
define a class I do a couple of extra
steps but I still have some code objects
somewhere I still have some store I
still have some call function somewhere
and I store the result to a what you can
see from this is when the Python
interpreter comes across a statement def
or a statement class this is actually
executable code in a language like Java
or C or C++ class and function
definitions do not exist at run time
they get turned into just a bag of bits
at the compiler and C so the C compiler
will turn a function definition to a bag
of bits and maybe if you have debugging
options either on you can actually
figure out what that function is but
otherwise there's no runtime course
there's no corresponding runtime
execution of the definition of a
function but Python is different when
you see a function definition of a class
definition Python actually does
executable runtime steps to define it so
if we go back to the very first question
about what was Val and what is involved
I can define a class in a Ford it just
defines the class over and over and over
because each of those def statements is
just some code that runs I can define a
class in a for loop it just defines the
same class over and over and over and
stores it back to the same variable name
it works but it's pretty useless let's
take action let's take a look at this a
little bit closer and let's look at
disassembling a couple of things here I
have a global variable let's disassemble
a function that uses this global
variable I see this load global of X
here okay kind of makes sense to global
variable so I should have a load global
it's not too fancy let's let's do the
same thing with the local variable I
have load fast so I guess fast must mean
local variable that's kind of
interesting let's see what happens if it
has a default argument no change
whatsoever so I again see a load fast so
if it's a d if it's a local variable
with
default argument or not they both turn
into load fast let's see what happens if
I do this kind of closure structure and
I have the X on the inner function refer
to an X defined in some outer function I
see Lodi ref so I guess D ref must mean
closure and let's see what happens if I
have a constant value
well load Const okay so I know there's
different types of loads global/local
constant and closure or d rekt let's
take a look at a function that takes two
variables x and y what are the types of
x and y anything what does a bike code
get generated from this binary ad does
Python know if these are two integers or
two strings or two objects does Python
know if these things can even be added
nope it defers all of that to runtime so
Python just sees some name X referring
to some object some name Y referring to
some object and it waits until this line
is executed to try to binary add them
and do something with that and if it
works it works if it doesn't work it
fails but you have no static knowledge
about whether that'll work or not
similarly if I call X is o or a function
let's take a look at the bytecode turns
into call function so that's what call
function was it said you had a function
and you just invoke that function does
Python know if that's a function or a
class or a type or a module or an object
or something that can't even be called
nope Python just waits until you try to
do something with it and it gives you an
error if that operation isn't supported
let's say I do an attribute look up
there's Python no let's take a look at
the disassembly for this you can see a
load adder so I'm trying to load an
attribute does Python know if the
attribute a exists on the object X does
PI don't even know what X is this Python
know if X has any attributes that I
could grab nope it just waits until
runtime and tries it and as we start to
disassemble more and more things we'll
see this pattern recur Python is a
language that defer
a lot of decision-making to the run time
it has a very small almost useless
compile time but there is a compile time
and we'll see in just one second what
happens at compile time
fundamentally Python runs code from top
to bottom left to right classes and
function definitions are just executable
code when it sees a function definition
it grabs all the stuff under that
function definition turns that into
bytecode and it every time that function
is defined turns that bytecode raps it
with a function name and creates a new
function of that type
same thing with classes that's why I can
define classes in a loop I can define
functions and loop also a lot of the
course syntax of Python is as simple as
just doing load attribute get attribute
or binary or binary operations and in
that core syntax Python has no idea
until that line is run that the object
of its operating on is a class versus a
type versus whatever in this case notice
python does not even know X could be a
module if I change this to math dot a
Python does a load adder
just as though were an object so what we
can see is that in that very first
example where the difference between the
imports in the second example I did math
log and math dot e I'm just doing an
attribute look-up on some object and
there's meaning to when you do an
attribute lookup on some object let's
take a look at the last piece of theory
that we need to talk about I'll show you
how Python actually runs code when you
say import module Python goes and it
finds module dot P Y or it finds a
folder that contains in a knit top py
but eventually it finds some dot py file
and it reads it in so it runs code that
looks something whoops
it runs code that looks something like
this and you can see this is the source
code of my module my module is just like
before it has an F and an a it just
reads it in this is just a string
then it parses it so let's take a look
at what happens in the PAR step I get an
AST so it just turns that source-code
tokenize as it turns it into an AST and
that AST has a body and you can see in
the body of this there's a function
definition of class definition let's
look at the function definition let's
look at the body of that function
definition it's got a return notice this
thing all I did was a returned one thing
let's look at the value that it returns
it's a binary operation let's look at
the left hand side of that binary
operation it's a name it's a name X
let's look at the right hand side it's
the name Y pretty simple this is just an
AST that encodes this same information
subject to checking the syntax is
correct and putting it into a structure
that can then be passed to the next step
which is the compiler Python compiler
takes this ast and it creates a code
object let's see what that looks like
just some code object here and let's see
what the code object contains well it
contains the actual byte code itself and
so you can see if I disassemble you can
see there's 24 plus order however the
size of return value in this code object
that's about 24 bytes here the code
object also contains some other other
interesting information the code code
name the name of the function itself the
names of any local variables the number
of local variables and some other
information as well some flags and so on
after it constructs the code object it
executes that code object it needs to
evaluate it and it creates a namespace
which is basically just a dictionary and
it just executes that code in the
namespace so let's look at the namespace
after executing my module well let's
look at its keys and it just contains
the function I defined F and the class
started to find a
now you know a namespace by itself isn't
very useful so we need to construct a
module and a Python module is just some
arbitrary Python object that has a name
has some lookup mechanism and has the
ability to look up the contents inside
so I simulated that by just updating the
dictionary of this object with with the
contents of the module so let's run that
and take a look so here I have my module
and if I do module dot a or module M I
get the contents of that module and then
finally somebody tries to use that
module so you might write something like
f equals ma jf we'll call that binding
and then you might call the function f
and if you remember the function f just
adds two things together okay
so that leads us to something very
interesting the import statement in
Python does not execute code the import
statement in Python brings a name into
scope when you say from module import F
that's the same thing as saying give me
access to the module in this case named
module and say F equals module F it
binds F when you say import module there
is no execution of code it brings the
name module into scope by doing
something that looks like this go to
system modules look up the module that I
want say module equals that maybe I'll
give it a slightly different name so
that this might be a little bit clearer
okay the execution of code only happens
as a side effect of when Python cannot
find the module in system modules let's
go back and let's answer every question
and think about this in very simplistic
terms everything operates top-down left
to right before we do that I want to
show you two small things this is the
Python compiler itself in the Python
compiler there is a function called
compiler named up when python code is
compiled the python compiler determines
where the variables come from so it can
emit either a load fast load global load
DRF or other load operation
it determines that by looking at the
static source text and figuring out
where was X defined and it knows X is
defined by either a statement that says
x equals class X for X in something with
something as X except something as as X
and so on there's only a finite number I
think 7 or 8 ways that a variable can
come into scope
Python can statically determine all of
those and then determine is this a local
variable a global variable a closure
variable and emit byte code when you see
a load fast variable what it does is it
loads loads it fast it loads this
variable from a tuple that's stored
attached to a frame when it loads a
constant variable it pulls that from a
tuple of all the constant variables that
are collected at parse time when it
loads a DRF it goes and finds the
closure and then pulls it from the
closure so let's go back and answer all
of our questions there is a meaningful
difference between the two of these but
it is very subtle in the top you bind
the value of log and e early which means
if some Joker went in and did this on
line 7 you'd see the same result that
you saw on line 2 because you captured
the value of log and the value of E as
of line 1 and no subsequent changes to
that module will take effect here if
some Joker tries to do the same thing
line 7 does an attribute lookup just
like any other object looks up the
current value of log looks up the
current value of E and your Joker will
have his day this is why when you're
told to append your path in Python this
works this operates on the actual sistah
and it actually fixes your system path
this does not work what you accidentally
did was you bound the value of path
early then in your local scope you just
created a new shadowed version of the
system path this works because even
though you bound the value of path early
you performed a mutating operation on
the original path so this just works and
this works because you're looking up
sorry this should be sistah path you're
looking up the current version of path
and then setting the current version of
path that's why we see this difference
let's look at
the module when this module is imported
for the very first time and by the way
you may not be able to in a very large
system deterministically you may not be
able to casually determine when a module
is first imported in a very large system
especially if your code is over here and
some bootstrap code or some
initialization code is over here your
module could have been imported at any
time in the process and it turns out
that your sister your there are certain
configuration options that can load
modules your site flags or your site
options can in some cases load a bunch
of modules that you might not even
realize are being loaded so you might
not actually know when a module is
imported so you might not actually know
when a module is executed in the script
below that module is only ever executed
once it is executed from top to bottom
left to right the very first time this
module is executed all three of those
defined statements are printed out to
the screen doesn't matter if you import
an F from the module or G from the
module or H from the module some people
when they look at this they say well if
I import just log and E from math I use
less memory because I don't pull in the
other stuff nope Python always runs
modules in their entirety from top to
bottom
why because you could always at the
bottom of the module have a for loop
that defines some function many times
Python has no way to determine
statically where a function or where a
class is defined it could be defined by
some arbitrary arbitrarily complex
executable code and as a consequence the
only option that Python interpreter ever
has is to always run modules from top to
bottom left to right every single time
they get executed however as an
optimization we only execute it the very
first time it's imported this is why you
can't execute or load only certain
portions of modules you always grab the
whole module at the same time this is
also why in this case you had different
answers here the first two are obvious
but here we reloaded the module notice
that the a here is the a that I early
bound on line 3 so the lower
a the a instance is still an instance of
the class that was early bound on line
three but on line 70 I look up the
current version of B in the current
reloaded module which will have been re
executed and it is no longer the
original be that constructed the
instance be on line 17 and on line 19 I
pull out the current version of a and B
from that module and the original a
instance and B instance are completely
different than what then we're
constructed by types completely
different than the types that sit in
that module right now this is why
arbitrary code reloading does not work
in Python you'll suddenly run into all
sorts of very weird errors where things
are no longer instances of things you
expect and it only works in very limited
domains where you can patch all of the
objects in your system to whatever the
new versions that were loaded by the
modular that's why the hot code
reloading in a tool like flask or Django
can sometimes break in very strange ways
if it's hot code reloader doesn't know
how to patch old objects to the new
definitions let's take a look at this
well here's what I know when I do
actually let's take a look at our module
when I do module a that's just a load
attribute right and so a module is just
an object that I can't easily construct
but the answer to this is quite easy
let's make be a property and say B dot
setter and then in my module I'll say if
my name is not main if i'm importing
this thing as a module what I'll do is
I'll go into system modules and I'll
grab myself I'll grab the thing that I
was supposed to be I'll grab the type of
it I'll grab the contents of it
I'll grab all of the contents that
happen to be properties and they'll
create a new class with all of the
properties I'll create a new instance of
the module type and then I'll copy
everything over it is possible to do
module level properties in Python it's
only about seven or eight lines of code
and what you're doing is you're just
understanding that module dot a is an
attribute lookup than any other
attribute lookup so that
making this work is just be able to
create your own module type let's look
at mutable default arguments this code
is executed top to bottom left to right
this line is executed this line these
two lines are parsed turned into byte
code and then store it in that code
object
so when line three is executed you
recreate one list that gets reused every
time that's why this uses the same list
as this as this because that list is
only ever constructed once however when
I do this notice the list is constructed
as part of the execution of the function
so a new list is used every time when I
wrap this in a wrap to function notice
that this function is Reax acute 'add
every time the outer function is
executed so a new list is used every
single time when I try this with the
decorator syntax it doesn't work because
this line is executed once and it
doesn't matter what happened in this
decorator what matters is how many times
do i execute that top line of that
function which is only once
so this retains the bad behavior when I
sick this into a class the body of a
class is executed and put into a
namespace and then stored on the type
and so this gets executed once under
this namespace so the bad behavior is
retained same in this case let's take a
look at our scope problem z is a local Z
as a global variable the Python
interpreter does not know where the Z in
this line comes from so it will assume
by default its global variable in a
module scope the locals and Global's are
the same object so this just works I
don't have to execute it here well that
doesn't do anything interesting here
Python sees an X variable it tries to
figure out where did that X variable
come from it can't see an x equals
anywhere here it can't arbitrarily go
into this code because you could make
this really you can make this
arbitrarily complicated right so Python
won't execute anything to figure out
I'll just look for a line that says x
equals or import X or import from Y
import X
there's only a set number of ways you
can bring a variable into scope or from
Y import Z as X or with something as X
or for X in something or accept if
you're an exception something as X
there's only a couple ways you can
create an X variable so to look for all
of those it won't find them it'll say oh
well X must be a global variable and
this change the locals won't be picked
up when we disassemble this we'll see
that Python assumed statically that this
was a global variable so the only thing
the Python compiler does that's
interesting at all it figures out where
variables come from in order to optimize
variable lookup it assumes statically X
is a global variable and the change to
locals won't have effect here we see
something interesting when we look at
that load fast it didn't read from
Global's so I didn't read from locals it
read from a special array that's
attached to the frame object so this
will have no effect whatsoever here this
works because python cannot find where
that X variable comes from it assumes
it's a global variable and the reason it
assumes things are global variables is
you could have something like this and
so by default that's the last place you
look it's probably a global variable and
if you can't find the execution it was
probably an import star operation that
occurred somewhere that made everything
very hard to find so this works
Python assumes it's a global variable
and it actually looks in the global
dictionary and finds the value you want
here Python knows this is a closure
variable because it can see it up here
so this won't work and this won't work
because that's not where pythons looking
for the variable finally in this example
what Python thinks this line says is
that Python thinks there's a local
variable X because you said X equals
when it tries to evaluate this line it
tries to use the local variable X that
it knows exists in this scope but it
doesn't exist until this line is
completed execution so Python won't even
look up to the closure to find it so the
solution for this is non-local X I told
you there are two there's actually three
non-executable Python statements they
are global non-local and of course
passed now pass isn't very interesting
but global and non-local are interesting
all they do is they tell the Python
interpreter where they variable came
from
there's no corresponding byte code for
local for non local or global they're
just hints to the Python interpreter
that hey you can't find this variable
I'll tell you where it comes from it
comes from the dereference scope it
comes from the global scope and it just
guides the Python interpreter into
emitting the correct bye-bye code and
that's the end of our questions so you
can see with a very simple model for how
Python works if you don't overthink it
if you don't reach for the complexity of
a language like C++ or Java in there in
terms of their execution models you can
end up answering every single one of
these questions many of which seems very
perplexing at the beginning of this talk
which is a very simple mental model
Python interpreter only executes modules
the first time they are imported it
executes them from top to bottom left to
right the DEF statement or the class
statement is part of the executable code
the body of that function has just
turned into a code object the DEF for
the class statement or executable code
they correspond to used to be a make
class and make function but in Python 3
it's now make function to build a
function and then to make functions to
build a class don't ask there's a
simplification that we can talk about
later and that's it and every one of
these questions which might lead you on
Stack Overflow for hours and hours to
pick up wrong or incorrect or overly
complex mental models are unnecessary
with one simple mental model every one
of these questions can be answered
immediately and with sufficient nuance
to really understand what your Python
code does so that was top-down
left-to-right</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>