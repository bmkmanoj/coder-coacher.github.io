<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hacking Nintendo Switch | Coder Coacher - Coaching Coders</title><meta content="Hacking Nintendo Switch - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hacking Nintendo Switch</b></h2><h5 class="post__date">2018-01-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FrQRRPVwTZ8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm after though this is Derrick and
they worked and yeah first off we try to
be ethical hackers so we don't really
condone piracy and we really just want
to do creative things with hardware that
we own so yeah and so the Newton switch
was released about nine months months
ago and we've been playing around with
it since so this which it's actually
quite powerful unit it's a hybrid
handheld and stationary console so it
has a quad core that's clock the one
gigahertz it's an a fifty seven arm and
it has an NVIDIA GPU Maxwell
architecture it's clocked on either 304
84 or double that if if depending on if
you're docked to a power supply or not
so if you're running off battery they
want to reduce the power consumption it
has plenty of memory like Fergie about
CD ROM and then there's the selling
point pretty much it's the toy cons and
those are detachable so you can either
play yourself or you can share one of
your accounts with a friend and you can
play two players they have all the nice
sensors accelerometer gyro NFC IR and
they have this feature called HTTP
Rumble but it's just a vibrator and
these ones don't have any security at
all so you can just unscrew them look at
the part number Google the part number
get all the data sheets and dump the
flash it's all plain text but when you
open the main unit this is what you see
you have the 2d Rams it's in the orange
section and then you have the main CPU
which is in red and then the rest is
just power management Wi-Fi boring stuff
so oh yeah and the flash they actually
made a separate daughterboard for the
flash so we can easily just unplug it
and dump it and stuff
and yeah the codename for the switch is
hat I'm not sure what they were thinking
but yeah when we look at the main CPU
its branded OD an x o2 it's like because
Nintendo is the odium this chip is
actually just got from Nvidia and NX is
the codename of the an internal switch
but it turns out that the part number is
just a lie it's just a regular Tegra x1
Nvidia chip like people D capped it and
it looks just the same and yeah we have
the reference manual online it's freely
available pretty much it's 3,000 pages
so it goes into detail
pretty much everything except the
security part but they also have provide
their own Linux drivers but yeah we can
get the security at least some of the
security registers and everything like
that
the main overview of the SOC is that you
have an arm 7 boot CPU it does power
management and it has a boot ROM they
also have some internal SRAM and then
you have the main CPU and it has 64 K of
SRAM that's for trustzone so it's secure
only the secure bus secure access only
and then you have the GPU on the same
die and then you have the security
engine that does are say yes
acceleration it can DMA and stuff
and then they have on diffuses a lot of
them actually like a thousand and then
they have the memory controller they
have a tea sack which is security CPU
it's a really weird architecture they
they were really yeah creative so and
then they have the DSP which is kind of
boring and then they have a bunch of
buses that yeah you can talk to external
devices so
then highlights for the fuses they use
it for a lot of stuff configuration
stuff but they have 32 bits dedicated to
downgrade protection so every time they
have a vulnerable firm where they can
just burn a fuse and every bootloader
reads the fuse to make sure that the
number of bits it expects is actually
set so if you try to downgrade just
rewrite the flash memory it will not
boot because there's a fuse inside of
the CPU that says we're not allowed to
boot this anymore so and then they have
the SPK which is a just normal AES 128
is key and it's the source of all the
confidentiality in system so this is
what you want to have if you want to
decrypt all the software and it's also
in the fuses and you can disable this
one later on in boots so you can only
access it during early boost time and
then they store the hash of the RSA
public key which is how they verify the
firmware binaries but they don't store
the actual e key they just store the
hash because they want to save space but
it's equally good and then they have
this cool feature that they can patch
the boot ROM so they can store patch
instructions for how to modify the boot
ROM code so if they have exploitable
bugs in the boot ROM and they do they
can actually fix them which is they can
fix that factory time so they actually
filled up all of this space just fixing
bugs and it turns out that since this is
just an off-the-shelf shipped from
Nintendo from Nvidia sorry they actually
just provide this dev board you can buy
from them it's 700 bucks or half that if
you're a student so this gives you
access to you can play with all the i/o
and discover what's undocumented about
it and if we look at the software so
there's something people just it was
this rumor concerning FreeBSD and
everyone was asking does it run no it
doesn't run it and stop asking instead
it runs the custom microkernel called
horizon that's been in development at
Nintendo for pre for the 3ds so it's
it's
like eight nine years old maybe all the
drivers are running in user space and
they call services system micro care
micro services architecture and then
they have a custom Nvidia graphics
driver that's kind of similar to the
Linux driver but they modified it a lot
and then they have the custom API to
talk to it so they have a it kind of is
like Vulcan like it's a really thin
abstraction on top of the GPU and it's
custom its undocumented for us so so if
you come from the 3s hacking scene you
can we can do a comparison so the main
difference is that all you sign
processes now have a star so all the
drivers and all the games are using a
SLR so since it's randomizing the
address space and that makes it really
hard to exploit save games because if
you just have a file format bug you
really can't do much if you don't know
where things are in memory and they
rewrote everything pretty much just
refactored and renamed everything but if
you just switch out the abbreviations
all the concepts are the same they don't
have a security processor like the 3ds
had arm9 it was a big problem 3 yes
because it was a oh sorry
so they were so three days had this arm9
processor which did a lot of stuff it
was a big attack surface and it didn't
have any memory protection so they
remove this now everything is running on
the same cpu with memory protection
proper yeah so the security model they
have is the most privileged part is
trust zone and it just is their crypto
interface pretty much it's designed in a
way that the keys never leave the trust
zone hopefully well that's sir that's
how they wanted it so it kind of works
like a hardware secret now you have the
kernel so it it's goes just to produce
to enforce process isolation and
communication between processes and all
says the iommu it controls the iommu and
then it has what we call base services
these are processes with a star and
everything and this the FS module which
is the filesystem driver and NCM which
is not really interesting and SM which
is a service manager this one is pretty
interesting it it enforces the whitelist
of which process is allowed to talk to
which process and then is p.m. loader
which just loads and creates new
processes and an SPL which is the
interface to trust zone and then they
have a bunch of micro services like the
GPU driver Wi-Fi driver bluetooth and
stuff like that and then finally we have
at lowest privilege level we have the
game or the web browser so the web so
the web browser game sandbox we only get
access to approximately half of the
syscalls and there are 40 user services
which are yeah services that you're
supposed to access as a user and it has
a concept of process file systems so a
game can really only access its own save
data and save games and it can't mount
SD card which is when we want to make a
hombro exploit for example we want to
load files of SD card like elfs but yeah
we can't do that just from the
Brow's you're alone and then the service
sandbox which is where all the drivers
are at we have like 20 more sis calls
it's mostly just for talking to DMA
devices and handling IPC communication
it has to service whitelist but it's
roughly reduced but you get access to a
few more and the services don't have any
file file access at all in general there
are a few exceptions but this is pretty
powerful because even if you were to
elevate let's say go into the GPU driver
you don't get any extra file access as a
result and they sometimes need to talk
to external devices so they have mm IO
mapped but even if a malicious driver
tries to do a DMA request outside its
own process address space the kernel is
actually the one who maintains the iommu
for all the bus masters so a malicious
driver cannot really ask the device to
do something it's not supposed to do the
base service sandbox which is those five
six processes that are special they are
bundled inside the kernel package
together with the kernel and they have
unfortunately the same sis calls as
normal services but these ones don't
have a service whitelist
because these ones are the ones that
actually enforce the whitelist
so you can't like they're they're the
ones who enforce it and also fill it in
and maintain it so they can check
themselves basically and it also because
they've maintained the file system they
have no why kissed for files making
access everything basically so yeah
we're going places and we start from the
lower like the most unprivileged part
and yeah so we start with WebKit that's
demo later and yeah
so they've had a bunch of bugs here they
fix them all but it just keeps coming
more it's used for each shop like when
you buy games online and manual and
other stuff but it's always over HTTP or
yeah well we can't control the data
accept it with this one game also
firmware 2.0 input implemented a new way
of launching the browser you can just
create a new access point and act like a
Wi-Fi and yeah you can just render
arbitrary HTML because it thinks it's a
login page for a protected Wi-Fi network
and yet we just took this a Pegasus
exploit and it just works so when we get
code when you dump the memory of the
browser the first thing we find is that
it's linking its dynamic linking with a
file called SDK and when we run strings
on it it's not enough but we convert it
enough we get pretty much all of their
function names which is really nice when
you reverse engineering stuff we get
names of all the syscalls and all the
fancy creeps it's some of the crypto
stuff yeah so yeah this is what we're
gonna demo later so the game application
yeah they knew we were gonna get this at
some point
and with WebKit is pretty easy so what
we did then is we're trying to black box
trying to elevate our privileges from
the sandbox so my my my handle is Pluto
and there's a service called clue so I I
don't believe in fate but yeah I looked
into this service and it's user
accessible service that's what EU is for
we think PL is for preload there are
three commands that take an integer sign
integer and if you feed it a big value
you know it's it's crashes and this is
just like an array out of bounds read
where we control the index completely so
we can just give it a negative index and
we can read out the entire binary of
service so this way we can dump the code
of NS which is one of the problem yeah
so we managed to get one of the micro
services for just black box poking
things and now we're gonna look into the
SM which is the service manager it's the
one that enforces the whitelist of which
services you're allowed to access so the
way you you ask it for you give it a
string and it gives back a handle to
that service that you
four and you send it up it you're using
it your pet so that it knows which
whitelist to enforce but yeah what if we
just don't call the initialize function
so we never actually give it our app it
turns out that the variable that
supposed to store the paid is
uninitialized it will just be 0 so as
some thinks we're a process with bid 0
and then we get access to everything so
but we still we can talk to everything
but we don't have the code so what we're
going to do is we want to dump all the
code in the system so we can analyze it
so if you look at how the bunnies are
launched its launch this way and all the
code comes from this FSP loader service
it has a function called mount code so
we just need to connect to it and read
out all the binaries right but when we
try to connect we get some error message
turns out the kernel enforces you can
only have one session at a time but this
session is trying to help by the loader
so the loader has a session to the file
system driver but if we crash loader the
kernel will garbage collect the
reference count will go to zero and it
will release the session so we found a
command in loader that you just give it
a thread handle and it crashes so we get
all the code binaries just can read or
not it's this really nice as well now we
can really understand the system a lot
better and finally we will look at
kernel and for that we're going to take
a little bit of detour so Derrick is
going to talk next about what happens
before the system has booted up
okay it seems like we lost some time on
the demo so I'm trying to hurry a little
bit so okay so far and this was all
achieved by just using black box black
box testing and you know like so black
box testing is fun except that it's not
because well the switch uses a
microkernel and that means the text
surface is pretty low it seems quite
unlikely that you will get some read
primitive where you can just dump the
entire kernel and also there's a SLR in
privileged processes so you might even
need two vulnerabilities in the process
to get access to like kernel system
calls that only parish process can use
so yeah like was testing on the kernel
was kind of a dead end for us and when
you think about the chain of trust
WebKit is pretty much at the end so
maybe it's a new console so maybe you
why not just start at the other end so
we're gonna have a look at the boot
sequence and very cool because it's all
documented publicly by Nvidia and yeah
you get a bunch of information just for
free and the way how it works is there's
a boot run that runs on the arm7 which
is like super old and crappy CPU that
they call the P P and P which means like
a boot and power management processor
and this this is actually not a custom
boot ROM it's written by Nvidia but as
Pluto already mentioned Nintendo has
some custom patches on it the boot from
will well Esther this acid is explained
in the documentation it will just load
BC T which is the boot configuration
Taylor and the second-stage loader from
MMC so at this point you don't really
you know what the B city is but
basically it hurts the boot from
we're the next welder we're the second
such lawyer is located in MC and also
contains the signatures so when that's
the usual boot flow on the switch it
will try to you from M and C but if that
fails because for example the Inland Sea
is missing it will enter a recovery mode
which allows you to send us B messages
to the boot ROM and if you might think
yeah this is a ultimate backdoor
well unfortunately it's not because all
messages must be signed by using in
hinders private our psyche and of course
we don't have that but what we can do is
we can dump the MMC which is like super
easy and we did that and we got a pretty
nice overview of all the boot components
that are stored on the MSE so this is a
little bit complicated but what you can
see is the boot room on the left
it loads something that is called
package one which is basically the
second-stage boot loader and next stage
in one image and the first part is
actually stored on MMC in plain text
it is not encrypted and the other part
is encrypted by using Universal
Universal encryption keys it's not
there's no console unique encryption
there so how does it work how how does
the package one loader decrypt
integrates the next stage so they have
this feature where they lower the key
plop from MMC which is console unique
and it basically contains encrypted keys
and package one loader generates a key
block key to decrypt that key blob and
then it uses the decryption keys from
that keyblob to decrypt the next stages
so we would like to get this key because
the colonel is also encrypted when it's
part of package two as you can see on
the right and well this key is only
available to this package one loader
so that means we need to get code
execution in package one loader okay so
how do you get um keys well in the past
as you might know we clicked the three
years and got the keys and released the
Wii U and got the keys
so maybe yeah maybe you can glitch the
switch and get the keys so we wanted to
try that and in order to do this you
want to get code execution package one
loader and basically you want to glitch
the component at loads a package one
order which is the boot rom but how is
this actually verified so the boot rom
uses that PCT which I've already
mentioned and this is basically a
plaintext block stored on the MMC and it
contains all the signatures of the boot
loaders and then there's an RSA PSS
signature on top or as a PSS is a really
strong signature scheme and it uses the
RSA public key which you can see on the
top to verify the signature and this
public key is hashed and this hash is
stored in the fuse of the device so you
cannot you cannot change it basically
what we want to do is when the boot ROM
verifies this public key using the hash
we want to glitch this hash check
because then we can put our own public
key and our own busy t signatures and
with that our own bootloader signatures
so we can sign our own boot loaders ok
but we don't
well we didn't
the bootrom then back there and we
didn't know when this check liked the
hashtag when when does it happen so we
have to find the timing for it and for
that we can take a look at the in MC bus
you can just sniff it so we get a really
nice dump of all the commands that are
issued by the bootrom to the MMC so you
can see the diff it's the time
difference between each command that was
issued and it's basically the time that
the Butera needed to do some operation
between those reads so when the ear when
the when the PCT is was good it took
quite some time to verify it and when
you put like an invalid public key in
the BCT the BCT validation will fail and
it will actually start reading the next
PCT and then you can see the difference
is much smaller so that means the
bootrom will see the the public key is
wrong I will not I will not try to
verify the rest of the BCT and with that
they basically leaked a time of check
when the bootrom checks the public key
hash okay so this was all in theory
basically it took like one month to
develop a glitch in setup and this is
this just uses power glitching so what I
did was I first disordered all the
capacitors on the voltage rail that was
that powers the r7 and then I've used an
FPGA
to basically control some MOSFETs and
those MOSFETs were pretty much lower the
voltage for a short time so hopefully
the public key hash check will fail and
and then when you get code execution
we are pretty lazy in with just a bit
bank the NMC clock because we actually
found some clock divider register so
basically by changing the frequency we
could encode the data of all these
secret keys
bit by bit sending it to your FPGA and
then we got all the keys and with that
all the binaries
okay so um so thanks Derek yeah you got
us all the keys which is really nice so
now we can analyze the colonel white
ball white box instead of black box
which means we can read the code and the
first thing you do when you want to
exploit something is you find out the
memory map because you want to corrupt
the memory eventually where you should
you right so it accordance map to the
higher address somewhere ffff PFC it's
read execute but this actually this is a
virtual address that maps to DRAM and
then they have a DRM mirror that's
readwrite so we can actually bypass the
read-only portion by using the other
address instead and the 3ds had the same
flaw but I think they're thinking here
is that yeah it makes the code a lot
cleaner so they just always keep this
dear a mirror inside the their outer
space all the objects are allocated
using a slab heap which is like one heap
per object type and all the allocations
are of the same size so this makes use
after free is really difficult to
exploit because you can't overlap two
different two objects of different type
which you usually want to do so you can
only overlap an object with a different
object that has the same type so some of
the fields would be different but most
of the pointers are still valid for both
objects will still be at the same
offsets so yeah and now the kernel
cannot execute each line code because
these the privilege tax you've never
built P exam which is a hurdle that you
have to get through I'm not sure if
anyone paid attention so just explain
this the string to rightist
permissions so the first three are
privileged permissions and the lower
three are user land permissions and
there's something a little bit weird
here so they accidentally mapped the
kernel into user space as executable
it's mostly useless but it means that we
can use these we can just jump into
kernel from user space and it will
execute kernel functions in use
user space context but we can use this
as an SLR bypass because the current is
always mapped at the same address so we
can use it for gadgets but this really
we haven't really owned the kernel yet
so the iommu is one of the parts of the
kernel you can attack it's yeah it's
implementing a member controller of the
SOC the idea is that all of the non CPU
bus masters are protected so you assign
it an address space identifier acid and
then you assign a page table to that
acid and every device that goes through
the IMM you can only access what's
mapped in the page table and the kernel
image maintains this page table that's
why it's secure so a malicious driver
can't violate the process isolation yeah
and so this of course is that you can
only access your own heap three DMA
there's a functionality for accessing it
for another process heap as well you can
lend the memory but yeah so how do we
bypass destiny mu so we got the official
datasheet 3,000 pages and we can just
search for bypass the smmu
forget this
so the GM mu is a memory management unit
inside the GPU and yeah
it supports bypassing the SMU so Nvidia
back towards themselves so this is a GMM
you attack you can set B 31 in the page
table entry and it's in hardware so you
can fix it
Nvidia thank you
so this is one way of doing it and they
can fix it but we also had a different
way of bypassing the same menu and it
has to do it's a trust issue
so the loader loads the permissions that
we have from FS and if we own FS or if a
vulnerability in FS we can just tell it
what we're allowed to do so we can tell
it we're allowed we should be allowed to
access the memory controller and then we
can just assign acids so we can assign
the assets 0 here to our device it just
means don't do any virtual addressing so
we can do email all over the RAM pretty
much so the answer is simple we can just
the currents in DRAM so we can just
teammate but that doesn't work because
there's a security feature in the memory
controller you can specify a contiguous
memory range that's protected from DMA
and they protect this to include all of
the kernels so we can't really touch it
but we inspected the code a little bit
more and when they allocated handle
table they are two different ways of
allocation if you have a smaller hand
table less than 40 capacity you just use
the internal struct as storage but if
you have more than 40 they allocating
the pool and this is the same pool
that's used for all the memory of all
the user processes and this pool is not
protected by the carve out but the
handle table just is trusted like it
contains kernel pointers and everything
and yeah we can just email so we can
create a shared memory object which is
just primitive that the kernel provides
and we can tell it to share the kernel -
and then we can inject it into our
handle table of our process and then we
can use the Cystic all to map it into
our own process
so then it will map the kernel into our
process thinking it's a shared memory
and then we can just patch it or insert
the backdoor or anything so this is the
way we own the kernel and here's some
code yeah
and now we're going to talk to care
now we're gonna talk a little bit about
Justin so Network
alright so trust zone is this nice
execution environment by armed and we
already seen Derek's glitching actually
gave us a method to decrypt package 1.1
and it just contains the trusts on
payload and now what I will show you in
the next 10 minutes or so is why we can
actually ignore this trust zone at all
so the army aid support stressed zone
and the code running under secure l3
which is just as soon as we call it it's
called the secure monitor this is an
official name Nintendo calls it the same
but under Nintendo switch it doesn't
monitor anything all right so the secure
monitor mmm it's the first code runs on
the arm dat main CPU so the arm seven
decrypts back at one point one it writes
the trust zone payload two TZ Ram that
is what we saw it's this small Ram in
the arm v8 that distressed zone secure
memory boots up the arm v8 jumps there
and then this is actually the first task
of the secure monitor already its
booting the horizon kernel all right so
we saw this package to at this point
package will be in main Ram then secure
monitor will start deriving some keys
decrypt package to write the kernel to
the DRAM and decrypted the packaged
modules and then just start executing
the kernel so this is the most important
task probably or one of the most
important ones and the second most
important task of the secure mentor is
actually cryptography so cryptography is
not directly done in software by the
secure monitor but they actually make
use of this nice security engine that is
provided by Nvidia the Tegra security
engine and other some not so important
task is and Trust zone or the secure
mentor is actually used to start/stop
the additional CPU cores as we've seen
we have foreseen
view course we start executing from core
3 initially so we have to have means to
start stop the other course and the last
important part is the sleep mode so the
tegra actually supports some deep sleep
mode to save some battery this is always
a nice feature of Nintendo consoles
usually very long through the sleep mode
now if you take a good look at this list
this is actually not important for
homebrew at all that's why I said we can
really just ignore the trust zone
completely but let's look at it anyways
for completeness sake so the Tegra is e
I mentioned it's hard to crypt engine it
supports AES ours Arg all the good
things and maybe you remember from the
3d s they had this key slot concept it's
apparently good concept so they kept it
for here as well so you have 16 key
slots for AES to 4 hours a you can lock
them individually this is for example
but the boot rom uses the SP k is
written to a key slot it's locked so you
can't straight it out I mean it gets
cleared once we're in this area but the
trust zone code does the same it derives
some keys into the upper key slots and
locks them so even if you get code
execution and a trust zone you wouldn't
be simply able to just read out this
case so that that's quite secure alright
and what's another interesting thing
about the legacy is that the crypt
operations actually don't just operate
on memory you can actually encrypt and
decrypt between key slots so this
actually enables you to do some secure
key derivation so you could imagine
having a key in one key slot key slot
could be locked and then you could
actually decrypt this key slot into
another one without ever having any keys
leaving into memory so this and maybe
you could think of some cool things you
could do with that so how does the
cryptography work so on the left side
you see there's a cure world this would
be the sector monitor the right side is
the non secure world or the user mode
mostly this is used in the file system
module
so what you have to do at first you have
to request a key encryption key and then
a secure world will generate this key
encryption key you pass some parameters
it'll wreck the key encryption key and
this is where the important part comes
in it will actually use a random session
key so even if you get a key encryption
key from one session once you reboot
your console your switch and the next
time it'll be invalid so even if you for
example exploit the filesystem module
and grab one key encryption key you
won't be able to use it after a reboot
so this is security sign there but on
the other hand how do you do use these
key encryption keys well you pass an
encrypted key into secure world along
with the key encryption key and this is
unwrapped the key is decrypted and then
a plaintext final key actually is passed
back to user mode so that's quite
interesting so what you actually find is
that for example the filesystem module
doesn't use the hardware crypto engine
to decrypt games or binaries whatnot at
all so this is all done by accelerated
hardware accelerated arm instruction
actually so in theory you could for
example exploit the filesystem module
get some permissions and then ask the
secure monitor to derive all the keys
for you all right
so this is another reason why it's not
really important now the last task we've
seen is the sleep mode so this is
actually a string from the secure
Monitor to call it or zoomy apparently
it means a good night or something and
on this sock
there's the small thing it's the power
management controller and this controls
to sleep and wake transitions and on
system sleep the entire system on a chip
is powered down except for APM z so
there is a small block that's always on
and the DRAM is put into some self
refresh mode so that it keeps the
contents right now if you enter sleep
mode secure monitor actually has to save
some states right so it does it spills
the secure memory into external DRAM
which is untrusted but but it's alright
it's encrypted so don't worry
and it also authenticates the duty serum
to PMC so he's encrypted and
authenticated so you can't just mess
with it right and it tells the security
engine to save its context to DRAM you
also have to retain the keys I mean you
have to use them after you wake up right
and then we signal the arm to put
everything into this lp0 mode which is
like this low-power mode then wake up
you just roll everything up from back to
the forth so this is the Ohio and the
boot ROM will restore Jersey State from
DRAM then it'll pass arm code execution
to assign warn boot bin and this bond
would be in this bit like a bootloader
for DRAM instead from an end boot a cold
boot we're doing a warm boot so from
DRAM and this one could be designed
that's all nice what this does it will
just decrypt the secure monitor from
DRAM to trust on ram verified with
authentication information that we have
left in PMC and then the main CPU will
just resume running to theory this all
sounds very good but for completeness
sake we can just remove the trust from
trust zone so as we already seen from
Pluto there are some trust issues we can
just ask the kernel to map the lower
DRAM where all these states are stored
we can map in PMC into user mode the PMC
registers etc etc and we just seen that
these are crucial in the wake up process
right we've seen that the trust zone
memory is decrypted from the RAM
entreaty serum and whatnot so if you
poke all these areas in just the right
way you get the code execution from from
user mode right
but as I said it's it's just a fun thing
to do isn't it very useful for homebrew
anyways thank you
all right so it's pretty green okay so
what we've done so far is when we put
the kernel we made a USB debugger up and
it's yeah it works you can debug use
your programs you can put breakpoints
and inspect the registers you don't get
the symbols yet but it's open source so
if anyone wants to add its you currently
requires the kernel exploit but we don't
share it but hopefully someone will make
their own by this after this talk but
yeah what we really care about is
homebrew so we've made Lib and X which
is a user mode homebrew library we have
we provide all the kernel primitives
like you can create threads you can
mutex you can talk to other processes
using IPC we'll have nice wrappers for
everything we have fully working network
file system we can act as a USB host we
have the controllers input working and
it's what's here okay so we have frame
buffer working and this took a really
long time I think our friend jealous age
works on this for like two weeks
full-time they running like Android
binder IPC interface inside their own
IPC interface it's pretty crazy but yeah
we have it working and we're pushing the
updates so anyone can just use this now
so but still there's work to be done
right we enjoy reversing for idea code a
lot it's a lot of fun at home with fun I
hope you agree and we still have work to
be done right so we don't have any GPU
acceleration right now in Libya and X so
right now everything is software
rendering and how do you support we
don't have right now so and then we want
people to make games because otherwise
the hacking is for nothing so we can't
release it today but we're working on a
homebrew launcher so there will be
homebrew soon it's in cooperation with a
double team timrie switch which actually
implemented a lot of the exploit so
we're just like
you're trying to make it a nice stable
platform for homebrew and yeah get on
firmware three if you're lower and stay
stay there so thank you to everyone
involved and especially yellow state you
couldn't make it so now we have the demo
working and I'll have it
it's also thanks to Nino is it on
oh thanks to Nintendo as well it's a
pretty nice system okay
this is just something I wrote like last
night but hopefully works thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>