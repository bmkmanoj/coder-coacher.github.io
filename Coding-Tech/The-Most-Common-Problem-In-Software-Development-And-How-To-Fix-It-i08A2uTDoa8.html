<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Most Common Problem In Software Development And How To Fix It | Coder Coacher - Coaching Coders</title><meta content="The Most Common Problem In Software Development And How To Fix It - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Most Common Problem In Software Development And How To Fix It</b></h2><h5 class="post__date">2018-02-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/i08A2uTDoa8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm here to talk to you about a
particular problem that I see a lot for
most of the last decade I've made a
living as a consultant helping people to
make better software and that's been
like working with lots of different
companies that employed lots of
different developers and this was by far
the most common problem that I had to
help people with in almost every case it
was the root cause of a lot of secondary
problems and it usually ended up costing
a lot of time and money and emotional
stress a year ago I was fortunate enough
to join an online learning company
called future learn as their CTO which
means I'm now responsible for a whole
team of brilliant developers and they're
all fantastic at their jobs but I still
see them wrestle with this problem from
time to time and that's really because
the problem affects everyone are all
levels of experience it certainly
affects me whenever I sit down to write
code and it's not even a programmer
specific problem but I'm talking to an
audience of programmers right now
so I'm going to discuss the problem from
a programmers perspective I want to talk
about it because although it's a serious
problem with serious consequences it's
one that you can actually fix partly
just by being aware of it which is half
the battle with any problem but also by
learning some tools and coping
strategies that can make it much less
likely to affect you I'm going to talk
about some of those tools and strategies
in a bit actually here's the overall
plan for what I'll be telling you I'm
gonna start by describing the problem
and then tell you about some of its
symptoms and causes I'll suggest a few
example remedies to the problem based on
my own experiences and then I'll wrap up
by explaining why I think this is an
important thing to talk about in the
first place so first here's the actual
problem trying to do a big thing all at
once all in one go and that might not
sound like a big deal but as I said it's
a surprisingly destructive tendency that
leads to all sorts of other problems I'm
sure you recognize the situation you
have a large task to do like adding a
feature to some software or
investigating a difficult bug or doing a
major upgrade or making a big change
from one library or framework
core design pattern to another one and
to make progress on it you need to think
about all the large and small details
all the moving parts all of the
interdependent problems and all of the
steps you're going to have to take to
get it done and you need to keep all
those things in your head so that you
can think about all of them are all
levels of detail while you do the actual
work doing work on this big monolithic
task can feel like a long and precarious
walk across a tightrope you start out
standing on safe ground before you begin
but once you step out and begin the work
you won't be safe again until you
complete it and reach the other end
which could be way off in the distance
and every step you take has got
increasingly high stakes if you fall off
you'll have to tear everything up and
start again you'll lose your context
your flow will be ruined
you'll forget what you were doing you'll
have to go all the way back to safety
and give it another try from the
beginning so here are some symptoms of
this problem when you're experiencing
this problem the big thing that you're
doing
feels constantly stressful it feels
difficult to get things right because so
much is resting on it you're constantly
aware of the risk of falling off and
having to start all over again
because you're expecting the problem to
be kind of large and messy it can be
hard to see where the edges of the
problem are and that makes it very easy
to accidentally get stuck investigating
some like buggy third party library or
unpicking some questionable design
decisions from three years ago and
before you know it you've spent days
down a rabbit hole chasing some dead-end
issue that wasn't even part of the job
that you're originally trying to do and
once you get past the halfway point your
energy kind of starts to wane and you
just kind of want the whole thing to be
over with and that makes you less and
less likely to be willing to revisit
your original assumptions or question
your earlier decisions like when new
information comes to light it's almost
certain that you're going to discover
more information as you do the work and
that information is very valuable and it
make you realize that some of your
earlier decisions were wrong but if
you're desperate to just get this big
project over with you're less likely to
want to go back and revisit those
decisions and then those mistakes get
baked in forever because of the stress
and the sensation of your brain being
full of connections and priorities and
things to remember your hate being
interrupted or distracted because it
blows that meticulously constructed
mental context that you've built up and
as an aside there's a particular strain
of tech industry culture that reinforces
that view by saying that programmers
shouldn't be interrupted because of how
complicated and difficult and
intellectual our work is here's a
popular comic about what happens when a
programmer gets interrupted by some kind
of tie wearing coffee drinker and all of
their hard mental work sort of
disappears into a black hole now I'm a
programmer but I'm also a manager at the
moment and I do like drinking coffee so
maybe it's me who's the problem in this
situation and you need to take
everything I'm saying here with a giant
grain of salt you might have seen this
image doing the rounds on Twitter the
accompanying caption to this was anyone
who ever schedules meetings with
developers please burn this image into
your brain so you need 45 minutes of
downtime to kind of psychologically
prepare yourself for a 30-minute meeting
and then you need another 45 minutes to
ramp up again afterwards and similarly
you might have seen this graph of how
so-called geek productivity works if
you're interrupted for five minutes then
a non geek might think that your
productivity recovers immediately but in
practice it might actually take an hour
or more and so over the course of the
day these sort of constant small
interruptions might mean that you're
hardly ever actually being productive
images like this one reinforce our
cultural belief that interruptions and
distractions are kind of objectively the
enemy of productive and useful work
another symptom is that it takes a long
time to pick up your thread again when
you get back to work if you're always in
the middle of something massive and even
if nobody interrupts you it'll still
take
ages to pick up your thread again for
example the next day or after lunch or
when you come back to work after the
weekend so if when you get to work in
the morning or get back from lunch
it takes you a really long time to ramp
up and understand what you were working
on then you might be suffering from this
problem here are a few other symptoms
that I'm not going to talk about in any
detail but you know you might feel
irritable about questions and meetings
you might be worrying that you'll forget
what to do next you might find yourself
typing get status and seeing that you've
modified 20 files and you can't quite
remember what it was that you are trying
to do or you might have a big long
branch with tons of commits from like
late at night saying like whip and fix
this and I changed my mind and I need to
redo this later so those are some of the
symptoms of this problem I'm talking
about but why does this problem happen I
think one of the reasons why people get
into this situation is just that they're
eager to make progress they've got some
big tasks in front of them and they just
want to charge right into it get the
work done so that they have the kind of
psychological reward of being finished
and that comes from a good place it's
not a bad thing for someone to won but
ultimately it might cause this problem
to happen even though the intentions are
good another way to get into this
situation is to be unsure how big a job
is going to be and when you first start
working on something you might not
realize how large the task is in which
case it's quite easy to accidentally end
up in this situation where suddenly
you've taken on way more complexity and
detail than you originally intended to
and that's happened because you didn't
have a good sense of the size of the
problem upfront a related cause of this
problem is that even if you do know how
big the job is gonna be you might be
unsure how far through it you are when
you're working on it so even if you
thought at the start that this would be
about a day or about a week's worth of
work then unless you up some kind of map
of the territory then you might end up
working on it without having any real
sense of how close you are to being
finished and that kind of lack of
visibility tends to
that anxiety and worry and fear of
having to put your work down and pick it
up again later
and as I mentioned before there's this
idea that's quite prevalent in tech
culture that programmers are somehow
special among knowledge workers in the
kind of work that we do now that idea is
very flattering to programmers in fact I
think it's successful because it's
flattering because it reassures us that
we're special our work is kind of
intricate and difficult so it requires
special attention and focus and the
people around us need to understand that
and make space for us to do that kind of
complicated intellectual work and they
have to understand that our needs are
different and accept that they can't
expect us to drop whatever we're doing
just because they have a question or
want to have a conversation with us but
that's misguided for a couple of reasons
most significantly none of this is
specific to programmers or like geeks or
whatever all knowledge workers need time
to concentrate on the job that they're
doing all humans dislike being
interrupted when they're right in the
middle of something and most rational
people myself included wish that they
could go to fewer meetings so we
probably shouldn't allow ourselves to be
sort of seduced too much by this idea
that programmers are operating on a kind
of higher mental plane and therefore
should expect special treatment from the
rest of the world the other reason that
idea is misguided is that interruptions
and distractions do have an upside they
can be opportunities for empathy and
collaboration
now I'm not arguing in favor of them
nobody likes being interrupted or
distracted and interruptions and
distractions can present a serious
obstacle to people with a learning
disability or anyone else who isn't
neurotypical so we should still try to
reduce them as much as possible but the
reality of the work we do is that
interruptions and distractions are
extremely difficult to avoid entirely
and you'll miss out on useful
information if you don't find ways to
accept them and work around them in
other words if someone wants to talk to
you it might be helpful to talk to them
if literally nobody ever interrupted or
distracted you you could end up
completely isolated from other people's
questions and priorities and
perspectives and feelings and that might
help you concentrate better today but it
probably won't help you be a good
programmer in the long run people who
are beginners at programming tend to
view the main work of programming as
kind of typing out the solution because
that's the most obvious thing they find
difficult initially but to become more
effective you have to widen your skills
to include understanding and caring
about what other people are thinking and
what their needs are so now that I've
explained the problem I'd like to tell
you about some remedies for it now like
spoilers I don't have a magic solution
that will make the whole problem go away
all together but over many years of
working with great developers I have
picked up a lot of strategies for coping
with it and so these are a few examples
of things that I've seen work for other
people and I hope that if I share them
with you you might find one or more of
them helpful too or you might be able to
think of some of your own now each of
these examples could be an entire talk
in its own right so I hope you'll
forgive me for just kind of quickly
advertising the ideas rather than
properly explaining them in any detail
the first remedy to this problem is
planning ahead it's only possible for
you to do small things as you know you
can write a method you can write a test
you can fix a bug you can create a
commit and if you want all those small
things to add up to a big thing you need
to have some kind of plan about how
that's going to happen now you don't
necessarily need to do all the small
things immediately one after another you
just need to know how they fit into the
plan so that you can work through them
steadily over time and gradually make
overall progress towards your goal story
mappings one good way to put together a
high-level plan of how lots of small
things are going to add up to make a big
thing and story mapping sounds a bit
like a thing a consultant would try to
sell you but it's really just a simple
game that you can play with post-it
notes it was invented by a guy called
Jeff pattern about ten years ago let me
show you an example quickly of how story
mapping works let's imagine you're
building a ecommerce you know shopping
website
and you want to map out a particular
story which is a customer buys a product
and you start by getting a group of
people together and asking everyone to
write out individual small tasks that
might happen over the course of that
story one task per poster as many as you
can think of and a task is just someone
doing something it doesn't matter who's
doing it it might be the customer or the
software or the company or whoever so
you might write tasks like view product
page add product to basket view basket
page enter payment details enter
shipping details
confirm order ship product cancel order
and at this point you're just trying to
get all of the ideas out of your heads
and written down so you keep going and
you think of other stuff remove product
from basket update old payment details
request refunds save product for later
update product quantity and basket
browse related products search all
products add product to wishlist so you
get the idea anything you can think of
that someone might conceivably want to
do at some point in this process get it
out of your head and onto a post-it and
once you have a load of tasks written
down like this you will try to stick
them on the wall arranged so roughly
chronologically and tasks that happen at
around the same time can stack up
vertically and where these tasks kind of
naturally form groups you can label the
groups and we usually call them
activities so an activity might be
finding a product deciding whether to
buy it actually buying it being ship the
product or whether and once you've done
that you should be able to tell the
overall story by reading through the
tasks from left to right so you should
be able to say you know a customer
searches all products and then they view
one of them and then they add the
product to their basket and then they
enter their payment details and so on a
one advantage of mapping out a story
like this is it gives you a
visualization of where the kind of
complicated tasks heavy activities are
you can see a glance that there are more
tasks that can happen at certain times
and another advantage is that putting
your brain into storytelling mode helps
you to spot holes in your story
if one task doesn't follow naturally
from another or if the story is missing
obvious important details you can go
back and add more tasks to fill in the
blanks so you might have forgotten about
actually
and refunding the credit card or sending
confirmation emails or sorting and
filtering search results or vouchers and
offers and so on so you can go back to
your story map and fill in the blanks
with the other things you've thought of
until you feel confident you've got the
complete set of tasks so that you could
ever build to satisfy this particular
story once you've filled in those blanks
you can pick a minimal set of those
tasks to form the first version of the
thing that you're gonna try to build so
you might pick for example view product
page add product to basket enter payment
details and ship product as the first
really basic set of tasks that you're
gonna try to build this is called
slicing the story map it gives you the
minimum set of tasks that lets you build
something that makes coherent sense just
to get yourself started so you go off
and build some software that does just
those few things and then once that's
done you can come back to your story map
and slice off another internally
consistent set of tasks that make sense
to add in a kind of second iteration now
this is useful because slicing the story
map in this way gives you a way of
iterating your way to the complete thing
via a series of stable intermediate
points by having this big problem broken
down into small achievable subproblems
it gives you a much better sense of how
larger the job is and also a much better
sense of how much progress you're making
towards completing it or if your
priorities change you can stop at any
point and live with the slices you've
built so far move on to building
something different so that's enough
about story mapping another remedy I
want to suggest is learning to use git
to maintain a clean and clear and
coherent history of your work now as
programmers we're lucky to have access
to tools like git that give that like
other people in other professions might
never feel comfortable working with git
give us a lot of freedom to revise and
control the history of our work and that
can really help to avoid a task becoming
overwhelmingly complicated here's one
simple thing you can do to get a better
history make small focused commits that
makes it way easier to understand what
you've done so far and why you did it so
rather than having several independent
changes or kind of smush
together into a single DIF if you commit
the smallest thing you can the smallest
self-contained change it makes it a lot
easier to understand rather than trying
to understand ten different changes and
understand like why those changes have
to go together into a single commit
small commits also make it easier to see
the causal relationship between changes
if you need to implement a so that you
can implement B so that you can
implement C you can do that in three
separate commits and then it's obvious
from the order of them which things
depend on what again if they're all
smushed together into one it's not
obvious just by looking at that change
what the relationship is between those
different parts it's also very helpful
to write commit messages that explain
your thinking at the time when you make
a change you're very likely to have the
best possible information about why
you're making that change it might be
because you're fixing a bug that a
customer complained about or it might be
because you overheard someone else
saying that it was bad to do things in a
particular way or maybe you had a
meeting where someone told you that you
have to upgrade this dependency because
in a month we're gonna need a new
feature for something and if you can put
that information into the commit message
it makes it much more likely that when
you pick this work up again you're going
to remember what you were thinking you
might be picking it up in an hour
after your lunch break or in two days
after the weekend so anything that you
can get out of your head about why you
are making this change and write it down
in the commit message is going to be
beneficial to you when you come to pick
it up again later the diff inside the
commit already explains like what change
you made but it doesn't tell you what
you were thinking when you did it
your history will be much more useful if
you invest some time to keep your branch
in good shape and while you're working
on something a branch might live for
hours or days or even weeks if you're
working on something really big you
should always set aside time to make
sure that that branch is healthy and in
good shape and as close to being ready
as it's possible for it to be at that
point in time it's rather than treating
your branch as this kind of big messy
scratch space and saving up one huge
piece of work at the end to make it you
know shippable or mirja below whatever
that means for the work that you do and
there are a few different ways of
keeping your branch healthy and exactly
what this means for you depend
salon you know your workflow and how you
like to work with weave get for example
it makes sense to try to not diverge too
much from the master branch or whatever
you call your mainline development
branch when I'm writing code I like to
avoid diverging from master by
constantly rebasing on top of it so if
I'm working with other people every hour
or two I'll make sure I fetch the
upstream master and take a minute to
rebase my work on top of it now people
will want to argue about whether
rebasing is better than merging they
might prefer to regularly merge master
back into their branch for example but
you know bad luck I'm the one with the
microphone and I'm gonna I'm going to
seize this opportunity to promote my
opinion that rebasing is a much better
way of keeping your branch small and
easy to understand and I think that's
more important than other considerations
the sort of constant rebasing does
generate more work during the life of
your branch because it spreads out the
effort of understanding how to
incorporate upstream changes into the
changes that you want to make but that's
exactly what keeps the risk low and
keeps your branch healthy and
straightforward at all times
anyway this sort of rebasing or merging
or doesn't really matter just do
whatever works for you to try and avoid
a situation where it's been hours or
days or weeks since you last got
information about what was happening on
the branch that you're ultimately gonna
try and land your work on it's also
worth looking for opportunities to
cherry-pick bits of your work back on to
the master branch to reduce your
branches size and keep it completely
focused on relevant changes it's very
common to do some like preparatory
refactoring as part of the work you're
trying to do you know make the change
easy then make the easy changes can Beck
put it so you might decide to rename a
class or tidy up some messy code before
you try to change its behavior or just
fix some white space that's been bugging
you and if you create a commit like that
one that improves the code base
independently of the overall task you're
doing that's an ideal candidate for
cherry-picking onto the master branch
getting it out there for other people to
you
and then rebasing your branch on top of
it so that it's not part of your work in
progress anymore if you're constantly
doing this and maintaining a smallest
possible amount of work that you're
holding back for merging in the future
then it's going to make it much easier
for you to keep your branch focused and
coherent it's gonna make it easier to
land that work on master when you're
done and it will allow other people to
enjoy the benefits of your refactoring
or cleaning up or renaming or whatever
much sooner you should get more
comfortable with interactive rebasing
and taking time to regularly have a look
at the list of your commits and either
reorder or split or combine them or
rewrite the commit messages to keep the
story of what you're doing is clear and
linear and natural as possible for
example if you change your mind about
something halfway through your branch
rather than just then I rather than just
leaving it that way forever you can use
interactive rebasing to fix it if you
introduce a thing called foo and then
later on rename it to bar then use
interactive rebase to reorder your
commits to put those things together in
time and then you can squash them
together and remove all evidence of your
indecision and then whoever picks that
work up whether it's you the next day or
someone else who's trying to work on it
in the future can read a shorter and
less complicated story about what you've
changed without having to pay attention
to this extra detail that's ultimately
irrelevant my final piece of get advice
is to practice improving your get
hygiene by regularly switching away from
your branch and just doing something
else for a bit rather than allowing
yourself to only have one branch checked
out for days at a time maybe do a bit of
work on it and then whenever it's
convenient for you to pause switch away
from it and do something different when
you come back to it you'll have a much
better sense of whether the work you're
doing there makes sense
and whether you can sit down and read it
in order and understand it without
sweating blood a little bit of time away
can give you a much better sense of
perspective on what you're doing and
when you switch back to it
pay attention to how easy or hard you
find it to pick up the thread again and
why that is if you realize that the
commit messages or documentation or
tests are unclear then fix that while
you still remember and it'll be way
easier for you to pick it up next time
here's another program a tool that we're
fortunate to have access to test-driven
development one way that you can lean on
test-driven development to remedy this
big problem that I'm talking about is to
become comfortable with switching
between the different mental modes of
red green refactor I'm not going to talk
too much about that now but the idea of
test-driven development is that you're
either in the red phase where you're
thinking about what do I want the code
to do then you write a failing test to
try and express that or you're in the
green phase where you're thinking about
how do I write the code to do that and
then you actually write the
implementation or you're in the refactor
phase where you're thinking about how do
I make this code better so having made
your test pass you go back and revisit
the work you've done to try and make it
more expressive or give it better names
or remove unnecessary duplication or
whatever a lot of people forget to use
this as a kind of mind hack to focus
your attention on what you're trying to
do right now it's worth being aware of
this and consciously thinking about what
am I trying to do right now I'm in the
red phase I'm trying to write a failing
test and I'm not going to allow myself
to get sucked into doing something
different until I'm done with that and
I'm convinced that my test is testing
the thing I want it to and then when you
get into the green phase try to stay
focused on what you need to do to make
the test pass and not get distracted by
kind of doing other things you haven't
written a test for a year or getting too
sucked into thinking of the you know
perfect names for things the whole point
of the green phase is just to get the
test to pass you know what Sandi Metz
calls kind of shameless green and
similarly make sure you give yourself
time to do that kind of refactoring
phase where you're not worried about
what problem you're solving and you're
not worried about how you're going to
solve it you can just focus completely
on how you're gonna do a better job of
that you know now that I've got code
that works how can I get myself to a
place where I've got good code that
works
another piece of test-driven development
advice that's relevant here is to try
working outside in with acceptance tests
and by acceptance tests I mean what
people might call end-to-end tests or
system tests or feature test or even
integration tests and that's because
outside in testing or acceptance
test-driven development or whatever you
want to call it always tells you what
the next thing to do is if you've got a
convincing acceptance test that is
trying to use your software from the
outside you know I'm gonna put a product
in my basket and then I'm gonna enter my
credit card details and I'm gonna place
my order or whatever then that gives you
a top level plan for what work you're
gonna have to do to deliver that feature
and you can always run that acceptance
test and you always know how far you are
towards your final goal because of how
far that test gets before it fails and
if it fails immediately because there's
you know no user interface for viewing a
product then that tells you that you
need to be working on that now and you
can go and work on it and put unit tests
around it and get that bit working and
then if you can't remember what you were
supposed to be doing next you can take a
step back run the acceptance test again
see the first part of it pass and then
there'll be a new failure that's telling
you what to work on next and you always
know what the next big piece of work is
and when you're doing that piece of work
you should always know what you're
currently working on because you have a
failing unit test as well so if you work
in this style where you have one big end
to end or acceptance test and you run
individual unit tests as you go and
whenever you're interrupted or you step
away from your computer when you get
back to it you should always either have
a failing unit test which means that
you're trying to get that small piece
working or all of your unit tests are
passing and you've got a failure in your
acceptance test which means that now you
have to write a new unit test to push
that acceptance test one step closer to
completely passing it's fine if you've
got no idea what I'm talking about here
with this outside in TDD stuff I'm gonna
linked some proper resources in a minute
incidentally I was talking to my friend
Murray about this and he said that he
never walks away from his computer
without a failing test and that means
when he sits down again he can always
get straight back into what he was doing
before which was making the test pass
and I think that's good advice so I'm
gonna pretend that I thought of it
thanks Marie hope you're enjoying being
in London where it's probably raining
finally on TDD right tests that really
do check what you care about rather than
paying lip service to like doing the
tests particularly after the
implementation just as a kind of box
ticking sure that isn't adding any value
tests should help to focus your
attention on what aspects of your
software's behavior you actually care
about they're a very important tool for
clarifying your thinking and
communicating it to other people and in
particular remember that code that's
hard to test will be hard to use and
hard to change later so if it's hard to
make a clear test then take the time to
improve the design of your
implementation now instead of saving up
trouble for the future the final remedy
I'm going to suggest is to use notes and
conversations and these things are super
powerful but they seem so obvious it's
really easy to forget to lean on them
while you're working you can practice
taking notes and writing down things so
like questions and mysteries and
tangential problems as you find them
rather than letting them distract you
from the primary goal that you're
working towards just get them out of
your brain and put them on a bit of
paper you can always come back to them
later once you've finished what you were
supposed to be doing this is one of the
main things that can help you to avoid
like tangents and rabbit holes so for
example and you're meant to be focusing
on the read phase of TDD then you spot
something that needs refactoring or an
unrelated bug that needs fixing if you
feel confident that you've seen a
problem out the corner of your eye
you've written it down on a bit of paper
and you've promised yourself that when
you finish this piece of work you can go
back to your notes and work through all
of those little edge cases and weird
problems it's much less likely that
you're gonna get bogged down in them as
you go
you should practice working with other
people and explaining your train of
thought
rather than keeping it all kind of
scrunched up inside your brain use
conversations with other people to
externalize your current to-do list your
current goal your plan to make progress
towards that goal the things that you're
worrying about right now and so on
airing is one way of making sure that
all of that stuff is going regularly
explained and verbalized it's important
to do that because the more you explain
the contents of your brain to other
people the more chance there is that
you're going to notice that they don't
make sense or they're too ambitious or
too risky or you're trying to take on
too much at once or you're getting too
caught up in the wrong aspect of the
problem somehow however you choose to do
it you should step away from your work
regularly to talk to other people about
what it is that you're doing and why
you're doing it and pairing is one way
to do that and another way is to have
some kind of code review process or use
pull requests or whatever and another is
just to chat to people by the coffee
machine or on slack about what you're
doing at the moment different things
work for different people and
personality types and working
preferences but whatever your
preferences are you shouldn't forget
about the value of just talking to
people and rehearsing your own
understanding of what it is that you're
doing
so to recap those are a few techniques
that you can use to avoid that kind of
dangerous tightrope walking feeling you
can make plans so you always know where
you are and can easily pick up the
thread again you can use gets more
advanced features like interactive
rebasing to keep your history
straightforward and obvious and free
from incidental complexity you can use
test-driven development to focus your
attention and you can get ideas out of
your head by writing notes and coming
back to them later if you need to you
can clarify your ideas by having
conversations speaking them out loud
seeing how they feel when you have to
concretely articulate them rather than
just sort of think them in the abstract
now these tools and strategies that I've
mentioned today are just the examples
that I could remember off the top of my
head from my own experiences working
with other people I'm not an expert in
you I don't know anything about your job
or your work style or your psychological
and physiological needs so I'm sure
you'll have other different better
strategies than the ones I've mentioned
here but more important than any of my
specific suggestions is the overall
technique the meta-level way of
approaching the way that you work on big
things and the meta-level strategy is to
notice the risk and break it down to
remember to spot the problem of
taking on too much at once when you're
working on something pay attention to
how you're feeling and notice when you
start to put yourself into a risky
situation we feel like you're stepping
out onto that long unstable tightrope
you're keeping a lot in your head there
are lots of separate things that need to
happen before you're safe again you're
getting nervous and stressed and praying
that nobody distracts you and brings it
all crashing down before you reach the
other end and then once you notice that
it's happening get off the tightrope and
figure out which of your skills to use
to break down the problem and approach
it as a series of small safe stepping
stones instead of one giant leap so here
are a few links to resources for the
ideas I briefly mentioned Jeff patterns
got a user story mapping page that links
to a book that he wrote about it and
blog posts and stuff like that one of my
colleagues at futurelearn wrote a blog
post about using your git history to
tell stories which is very useful and
the growing object-oriented software
guided by tests book is all about this
kind of outside in TDD process if you're
interested in learning how to do that
and the new aspect book that just came
out recently has got stuff in it about
writing these kind of effective high
value tests they've also been several
good talks at rubyconf on these topics
or by coincidence and you should watch
them if you haven't already seen them so
yesterday Ashley gave a great talk
called get driven refactoring where she
explained a lot better than I have and
in a lot more detail how git can help
you to spot problems in your code and
document your work as part of your
commit history and on testing earlier
this afternoon
Valerie gave a talk that's a useful
introduction to unit testing if you
haven't done it before and literally
right before this talk null gave a talk
about sort of high value tests which
goes into more detail on some of the
points I mentioned about TDD now just a
wrap-up I've just spent you know over
half an hour talking about this
tightrope-walking problem why did I
choose to come all the way here from
beautiful rainy London to tell you about
it like why is getting off the tightrope
important what I wanted to talk about
this because based on what I've seen so
far in my career I believe it's what
makes great developers great when you
first begin as a developer you need to
learn how to write code
at some point maybe years later you
start getting diminishing returns on
that skill you can learn the syntax and
behavior and standard library of your
favorite programming language and
framework but then how do you get better
once you've done that and I think that
skills and tools like the ones I've told
you about today or what makes the
difference between someone who's good at
writing code and someone who's great at
being a developer as you get more
experienced as a developer you learn
these strategies for coping with the
complexities of the problems you face
and the shortcomings of the human brain
by being determined and bloody-minded
about applying those strategies you can
make progress on problems that other
people find too intimidating to work on
other people will come to you with
questions because they think you already
know the answers when actually you're
just more persistent at breaking an
impossible question down into smaller
more answerable questions and working
patiently and methodically towards their
solutions now this might sound
blindingly obvious to you because you're
probably smarter than I am but it came
as a real surprise to me when I realized
it and I still have to keep reminding
people to stop stressing themselves out
by trying to do too much at once so
unfortunately it's not yet obvious
enough for me to shut up about it this
is one of the main differentiators of
experienced developers their ability to
cope with large problems by using lots
of different strategies and tools to
break them down into manageable pieces
these strategies and tools are learn
abour and they become second nature if
you practice them as if you were
learning to ride a bike or play the
piano and I'm here to tell you that I
believe that's worth doing like don't
wait to get better at this by accident
when you go back to work after this talk
think consciously about how to cultivate
this skill and make time to develop your
own strategies and allow them to become
second nature if you can learn some of
these strategies learn to spot when you
feel yourself walking out onto that
dangerous tightrope and practice
stepping back to a place of calm and
safety and methodical program progress
you'll create better software and be
less stressed and frustrated while
you're doing it thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>