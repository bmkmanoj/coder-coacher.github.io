<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>REACTIVE PROGRAMMING | Coder Coacher - Coaching Coders</title><meta content="REACTIVE PROGRAMMING - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Coding-Tech/">Coding Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>REACTIVE PROGRAMMING</b></h2><h5 class="post__date">2018-01-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Bs76JDSx1X4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright well let's talk about reactive
programming and I want to start out by
asking the question is this something
totally new well we work in a field
where right about every 10 years or so
we'll give a new name for what we
already do and get really excited about
it this time around we call it reactive
programming things like micro-services
and stuff like that are getting the
excitement's but one of the reasons for
really having something that's been
around is in a way reactive programming
is kind of like extreme programming if
you recollect extreme programming had
really nothing new in it except for the
emphasis it brought together 12
principles we have to really focus on in
a similar way reactive programming has
nothing new in it except it brings four
different things together with a greater
emphasis and so the question is what's
the reason for this so it's really a lot
of old concerns with a little renewed
and urgency and energy put into it but
why is this different well a few reasons
if you look around for the past about 10
years maybe 15 if you push it we are
doing a few things very different than
we used to do one of them is a Big Data
we're talking about high volume high
frequency of data that we are working
with and a lot of organizations are
working with data that is in a
proportion or
disproportion to what we are used to in
the past decades the second thing is the
Internet has changed a lot of things I'm
almost in tears when I say I when I
think of my time decades ago when in the
morning I used to wake up and you know
as the coffee part is going a brewing
coffee I'll turn on my modem and I can
hear that whoosh in my ears
it would connect and reconnect I can
call my friends and ask them what's the
BOD rate you're getting today well those
days are gone now every one of us is
carrying multiple internet enabled
devices with us and we are constantly
communicating with applications and and
and transmitting data the biggest geek
that I know personally is my son the
other day I patted him and several
devices
fell off him I don't even know how many
is carrying these days and we are
talking about other ways of
communication as well very soon you know
forget about watches we're talking about
earrings nose rings and tongue things
all internet-enabled and there's not far
from a day when you may get a call from
the doctor's office that says sit down
we are measuring a very high blood
pressure level and you can just tell the
doctor no don't worry I'm just listening
to banker talking that usually does it
to me when I listen to him and the point
really is that you can you know monitor
health and you can monitor devices you
can monitor appliances you can monitor
several things constantly and we are
living in this world of internet enabled
devices and the usage patterns have
changed a lot as well well one of the
key distinctions is only about 10 15
years ago we had companies making
applications for their employees to use
and then they made their employees
available to their customers
well employees using applications they
are called captive users nobody cares
what they think about it usually but on
the other hand when you make
applications for end-users to use and
users are not that kind we demand a lot
more from applications and also there's
a very very high volume of users when
users use directly applications then
employees use applications so to manage
these things we are rethinking about how
applications can be developed and this
is where reactive applications come in
so what is it really
well reactive programming was created in
the Microsoft world Eric Meyer
introduced this idea a long time ago but
this is not really that new in fact it
you can even trace back a reactiveness
to maybe 40 50 years ago I'll give you a
couple of different examples of reactive
applications even beyond what when we
called them as react one of them
probably the most known reactive
applications out there is Microsoft
Excel nominal tool if you really think
about it well in in Microsoft Excel you
could have thousands and thousands of
cells and you could modify a cell over
here and before you could blink your
eyes several of could be modified based
on the
you just made that's a reactor for
example a one of my uh ha moments coming
in touch with reactive applications is
Google Docs I travel a lot worldwide I'm
in different parts of the world all the
time so I live in a more offered and
nomadic digital life and a lot of times
the way I can communicate with my wife
is through electronic medium so my wife
and I share a Google Doc where we
constantly update things we have to you
know communicate about but there was one
thing I realized one morning that just
changed the way I look at it I got up
one morning in different part of the
world and I noticed when I went to
Google Doc I noticed at that very
instant
my wife was using the Google Doc as well
and this was phenomenal discovery for me
because every that I could actually
exactly click the mouse at the point
where she is editing and I could edit at
exactly the same time this gave me the
way to realize you could be miles away
and still annoy your spouse that's a
phenomenal application of reactive
programming right there so these
applications give you the ability to
communicate across the globe and you are
able to exchange these ideas really well
and interact with applications and what
is really part of this well obviously in
this case one of the key things here is
responsiveness and responsiveness is
where multiple people can collaborate
simultaneously with documents that is
reactive not only that as data changes
that can immediately respond to in the
application that is responsiveness as
well so what it really amounts to is
these four different pieces put together
the first is reactive applications are
message driven it is so 20th century to
think about a centralized database with
distributed transactions if you are
going to build serious application in
the modern world we want to be able to
communicate between different disparate
parts of the application using messaging
while messaging again is nothing new but
reactive programming greatly emphasizes
the fact that we should be using message
driven technologies the second thing is
elasticity it is it is really really
hard to imagine organizations in today's
world
maintaining a huge amount of staff to
maintain their infrastructure well I was
talking to a client recently and I asked
them on a given day how many users use
your systems and they said well about
200 people use the system I was kind of
like wow you guys are making billions of
dollars only 200 users use your system
no on a given day only 200 people use it
but on two days of a month about 50
million people use it how do you scale
between about hundred people using your
system on a given day to several
millions of people using your
applications on just a few hours in a
month well clearly we have learned a
great lesson from this from cloud
computing and the infrastructures of the
cloud elastic computing is something we
have benefited greatly from while with
the elasticity you could either be
dynamic or you could program ahead of
the time when your demand goes up you
could have more servers come to life
when the demand goes down when people
are using it less you can turn off those
servers you're not expending money on
those systems so elasticity is something
we have really learned quite a bit over
the years and reactive applications
engage elasticity to scale and that is
anything it really emphasizes and I
mentioned about responsiveness
responsiveness is probably a very
important thing to consider if your
application is it could be the best
application in the world but when a user
comes to your application if it doesn't
respond properly you're going to lose
users very quickly and and in in today's
world the applications that are going to
lose users are not applications that are
not useful but if the applications that
are not responsive however useful they
may be for example let's say you walk
into a store on a Saturday morning and
you see that this clerk is busy helping
somebody so what do you normally do you
probably look around for a few minutes
look at the wall look at the ceiling
look at the floor and you quietly walk
away because there was no response on
the other hand you walk into the store
the clerk who is busy makes an eye
contact at you and says I'll be with you
shortly and then continues to help the
other person that they have been helping
with you probably spend a good 10 to 15
minutes in the store waiting why did you
do it because you felt important even
though you know you're not and the point
really is that when there is
responsiveness you have guilty of the
user who gone to it that's one of the
biggest differences so responsiveness is
extremely important while talking about
responsiveness remember the day you
discovered the infinite scroll feature
you've been using this app for a while
but then you walked into this
application you use the application and
then you scroll down today it was a
little faster but as you scroll down
there's nothing in the bottom before you
realize that it filled up with data and
then you scroll again and then it fills
up with data and then you realize oh
wait I don't have to be loading up all
the data right now I could be getting
data and as the user is looking at the
data there could be more data being
fetched at the same time that's again an
example of how applications can be
responsive infinite scrolling becomes an
example of that the fourth component of
reactive programming is resilience now I
could ask you how many applications do
you have on your smart devices you
probably have hundreds of applications
on your smart device I may ask you how
many you normally use you probably use
about a dozen of them regularly what
about the other applications that you
don't use at all but they are still
installed well they are pure crap you
have used them a few times they don't
behave very well at all in fact you got
so angry you left the application there
to die
they don't even deserve you to click on
them to delete it that's how you feel
about applications that are not working
properly resilience is extremely
important well this brings back some sad
memory actually I was speaking in work
conferences I've been teaching at the
unity for about thirty years now I was
speaking in one of these conferences a
couple of years ago and one of my
students came to me or one of the
attendees came to me and said oh thank
God I took your distributor to object
computing course back in 1998 I said oh
my gosh I remember teaching that course
way back in the 90s he said I got a
story to tell you I said all love
stories tell me story he said well I was
in your distributor B's computing course
and I was in the middle of a final demo
of the project and as I was doing the
project you walked up to my machine
quietly disconnected the internet cable
went back inside down and said continue
and my project
thoroughly failed and I failed the
course I said I'm really sorry why would
you want to tell me a story like that
where you failed he said no no there's a
good news after this I said how could a
good news come out of a failure like
that
he said because that's the last day I
ever made that mistake
I programmed only for the happy path I
did not think of Network failure but you
taught me a really important lesson
about resilience now when I code I don't
program the happy path first I program
all these error conditions very well he
went on to say that his programming has
changed ever since he failed that course
because he went on to say that today
when he codes in his office has his
writing applications in front of him on
the wall there's a picture of evil
venket that he looks at and then when he
looks at this picture he knows he has to
quote the help you know the the errors
as well properly I don't think anyone
wants to have a picture of even venket
in front of them the core resilience but
it's important for us to really code for
resilience as well that becomes a very
important feature to consider so given
these four features
can't we just program this using what we
already do what we already have well
let's talk about multi-threading well
what are you doing multi-threading you
create threads and then the fun starts
after that we're not able to deal with
shared mutability really well and then
all these synchronization primitives
really make the application very complex
and we're not really doing very well at
all with it well ok maybe we should use
futures well what do you do when you use
a future well you call a method which is
gonna run something asynchronously or in
a different thread and what does that do
it immediately gives you a future back
you get a future what do you do you
normally get a call at get on the future
and what happens when you call get on a
future well your thread gets blocked
that's no future at all that kind of
sucks so that doesn't really give us a
good solution hey but we wait a minute
we could really do asynchronous
communication and handling by using
callbacks if you think callbacks are a
good idea here's a suggestion I have for
you just walk up quietly next to a
JavaScript programmer and the word
callback and then just watch them begin
to cry uncontrollably because they know
that callbacks really
suck call backs don't compose really
well in fact the JavaScript world has
moved away from call backs into promises
mostly and the equivalent of promises if
you won't really say it's equal it is
something like computer completable
future in Java so we are moving away
from those directions as well but what
is it really that we are looking for
what are the key things I want to
emphasize is that efficient is attained
not by doing tasks faster but by
avoiding tasks that shouldn't be done in
the first place so the real efficiency
is not to really program our way to
running things quickly because at some
point the volume is so big we cannot
just compete by speed alone we gotta be
smarter than that and so the question is
can we be lazy about evaluating things
and this understanding this particular
idea was a big change in my mind and and
one of the things to tie this back into
ears I was trying to put together what
is reactive programming really mean in
this context and and a little lightbulb
and in my head when I realized that
functional programming actually has two
interesting ideas
it has function composition and lazy
evaluation and I realized that reactive
programming is a nice logical step
fractional programming functional
programming gives us composition of
functions and laziness it says you can
evaluate a series of operations now or
you can postpone evaluating them until a
later time
reactive programming takes that idea and
runs with it so I see reactive
programming as a very nice logical
extension to the ideas espoused by
functional programming but one of the
key things here in terms of resilience
as well is to really respect failures so
in other words we treat treat errors as
first-class citizen so rather than
treating error as something that is
unnatural we will be treating errors
like it's something that's normal and
that can happen along the way and we
deal with it like we deal with data as
well and and that's basically what it
provides for us well okay so what does
this really mean from the point of view
of programming it well before we talk
about it
let's really talk about something a
little bit different what have we been
doing for the past about maybe 15 to 20
years most of the applications we've
been developing could be put into this
one acronym called the crud applications
now we've been developing crud
applications pretty extensively we've
been doing creating their reading data
updating data and occasionally deleting
data but at one point we wake up and ask
the question is everything a crud
application or have you gone overboard
with it and it turns out maybe there are
applications that don't quite fit into
the crud model maybe it's not all about
reading data from a database it's not
all about updating data into a database
what if I were to think of applications
that are very different than what we use
to create for example what if I am
interested in monitoring tweets there
are organizations that are developing
applications where they are listening to
tweets and they are trying to infer from
their tweets and looking for favorable
tweets versus unfavorable tweets and
then they do some actions based on the
tweets they receive it could be a
processing of things from the social
media it could be a processing of the
stock market data the stock market is
fluctuating all the time and as the
stock data is changing maybe one issue a
trade requests when the data is the
prices to a favorable value or you may
want to sell it when a value with
certain things in all these different
examples you could be monitoring a
flight as it is in motion and you are
getting all kinds of data from the
flight and you're monitoring the flight
status all of these don't fall squarely
into the crud way of programming but
instead we should rethink about what
these kind of model is and we are
talking about data flow computing all of
a sudden it changes the way we think
about applications so what if we are
thinking about data flow computing in
data flow computing we have data that
flows from a stream and there could be
any number of data are unknown flowing
towards us and as the data is for moving
towards us we might be interested in
taking the day
doing some operations with that
filtering transform and then if it's of
interest we take a certain action we
pass it down to a intermediary or the
next one downstream if it is not
interesting we could simply throw it
away so if we're thinking about data
flow computing how does it change the
way we would develop applications well
in the programming model if you look at
object-oriented programming it doesn't
matter what programming language you
program in we can all agree that if
you're doing or programming you're gonna
see classes and objects as the building
blocks of your application in a similar
way in reactive programming the
underlying principle are the constructs
you're gonna work with is called an
observable so what is an observable and
observable is pretty much a dataflow so
an observable is a flow of data you may
wonder how does observable differ from
Java eight streams there are some very
clear similarities and differences Java
eight streams is a flow of data
much like observable is a flow of data
Java eight streams can give you either a
fixed number of data or they could give
you an infinite number of data flowing
towards you likewise observable may give
you a fixed number of data or an
infinite number of data or unknown
number of data well that's where the
similarity ends when it comes to us Java
eight streams it doesn't really handle a
certain things for you for example how
does the stream deal with exceptions
well the short answer is it handles with
two words called good luck so it doesn't
really provide you a solution for it if
you are in a middle of a stream like a
filter and a map and a reduce if one of
your lambdas blows up with the runtime
exception it's really hard to know
what's going to happen if you're on a
parallel stream versus the sequential
operation and the reason why this is
really a not a good solution as the
exception handling is completely
orthogonal to the functional style of
programming way of thinking the
exception handling ideas are very much
in tune with you
paratis style of programming in
functional style of programming you deal
with everything from upstream to
downstream so as you are going
downstream and processing if something
were to go wrong here you don't blow up
you simply go keep going downstream and
handle the error downstream
well Java each stream doesn't handle
that at all and that's one of the
biggest challenges second is how do you
know when there is no more data well
Java eight stream has no way to clearly
tell you those details observable
differs in some very clear manner well
the very first thing is an observable
has three channels the first channel is
a data channel and through the data data
channel comes the data so an observer
will be transmitting data through a data
channel and as the data is being sent by
the observable you're gonna have the
data flow through the pipe a
transformation through the data channel
an observable also has a separate error
channel as well through which an error
would flow so it clearly gives you
different channels so it's kind of like
I have a data channel to which I'm going
to send data but I'm gonna have an error
channel through which I'll send error so
I got two distinct channel through which
I'll send the data but in addition to
this an observable also has a third
channel which is called the complete
channel and as you would imagine from
the complete channel you would get a
complete signal this is a way for the
observer to tell you I any more data for
you I am done you can do the cleanup on
your side you will expect no more data
coming from me well the way an
observable is modeled as a data channel
made transmitted through the data
Channel zero or more pieces of data but
only as long as there has not been an
error and there has not been a complete
signal but the minute something goes
wrong and error goes through an error
channel and you are guaranteed there
will never be data coming through a data
channel so in other words the data
channel is open
keeps flowing through the other channel
but something goes wrong it sends you an
error to the error channel and
immediately closes up the data channel
so you clearly know that you got an
error and there will be no more data
well other thing is it doesn't throw the
error as an exception at you
I mean how rude something is thrown at
you it's very civil it gives you an
error just like it gives you a data so
the error comes through the error
channel so you can receive the error and
deal with it on your side much like you
would receive the data so this is where
that error is treated as a first-class
citizen just like error data comes
through error is just a different form
of data it's an error data well likewise
the minute something is done the
observer can send you a complete signal
to tell you I am done I'm not going to
get you send you any more data and the
minute a complete signal is sent by an
observable the data channel closes again
as well so these are the three channels
that observable contains very explicitly
for communicating these three things so
an observer will push the data to you
unlike a regular iterator where you pull
the data there's the end signal that's
being sent to you it respectfully deal
with errors by sending the you in the
error channel and there is one other big
benefit that you get out of this now
what do we normally do when we write
applications we always care about
performance but to care about
performance how do we improve speed off
certain things in our applications one
way to improve speed is to use
multi-threading but something has
happened until this point in our
programming lives and that is the
structure of a sequential code is very
different from the structure of
concurrent code and this has been a
cause for disaster in what we do so if
you write an application sequential e
and then one fine day you come to work
and declare you're gonna use
multi-threading that day becomes the day
of disaster because your code structure
turns into a monster it doesn't look the
same anymore but not only are you
changing your code so drastically the
the part of the code that
uses your code has to change as well and
you're not going to invite friends by
doing this so what's good what have we
learned so far if you start programming
sequentially it's easy to program and
you program sequentially for most part
of the application and in the end you
realize performance is not good you
change your code to concurrency and the
code becomes unmaintainable in the end
then you realize gosh this is not going
to help we cannot change it so
drastically in the end so in the next
project what do you do you learned your
lessons you take it forward you start
using multi-threading from day one now
your application becomes unmaintainable
from the beginning itself that is no fun
either so how do we really develop an
application that actually works and come
back and improve performance well here's
the good news
both in Java eight streams we have
learned this and in reactive programming
the first time after a long time the
structure of your code is exactly the
same whether you're sequential or with
your asynchronous and this is the big
benefit because I can write this
equation late today and if performance
is adequate I can keep it sequential for
the full time or if I realize the
performance needs to be changed I can
make it asynchronous later on because
the code structure is exactly the same
I can easily interject the performance
improvement without having to change the
code structure and this is a huge
benefit so that's another big benefit we
get out of this style of programming
with observable well enough talking
let's look at some examples of this so
what I want to do is to create an
example but when creating this example I
also want to get a feel for how we are
doing things today and maybe how we can
do this a little different so to
understand this I'm gonna query for some
data but but before I do this just to
make it a little bit more easy too easy
to you know understand and illustrate I
need one volunteer with a smartphone
anyone in the audience who is willing to
help me somebody don't be shy one with a
smartphone who wants to help come on
come on come on you can help who has a
smartphone here
nobody wants to raise the hand would you
like to help oh there you go thank you
sir what's your name
Chris give a hand for Chris thank you
Chris
awesome come on up thank you Chris so
Chris I want your help I want them to
find me the stock price for Apple Google
Microsoft and Intel so are you done
Chris it's not done anyone thinks Chris
is slow Chris is very slow what do you
have Chris for us so far loading what
did you what do you have you took all
this time and you only have price for
Apple you're buried inning Chris good
press well chris is demonstrating some
really good ideas right now he is
looking for the next prize what do you
think of his performance just like web
isn't it thank you Chris you
demonstrated very well so thank you yeah
yes another one so Chris demonstrated a
field really well I couldn't have done
it better than he did he did a few
things really well the first thing he
did is when he got the request what did
he do he started really going through
and finding the data for all the four
and as he was doing it what did I do
I was not so nice I kept interrupting
him so this is typical right you go to a
website and you see that the website is
very slow so what do you do when the
website is slow you're saying gosh this
website is slow let me help it and hit
the refresh button and what is what
happens when I hit the refresh button
there is two threads running now not one
that's exactly what I did to poor Chris
when he was trying to find the stock
price I kept annoying him with more
questions he had to create more fits to
answer me while he was - looking for it
that's exactly what happened and then of
course he took the job upon himself to
find all the prices in the meantime I
made signs he never noticed I said this
time out I said don't do this he did not
notice anything at all just like a
typical web application
what do ever applications do hey
so you have a request goes around and
works on it and says what did the user
go and it doesn't really know the user
doesn't care about the result anymore
and this is exactly how web applications
work he did it really well and I've done
this talk a few times and one of these
times I had somebody like Chris come up
on stage and help me but that person
Rick did something very different I've
never seen anyone do this before I've
never seen anyone do this
after what did was kind of unusual
when I came these four stock prices
rather than going and finding these
stock prices Rick immediately turned
around and record at four people and he
said hey you find the price for
Microsoft you find the price for Intel
you find the price for Google and by
doing so Rick demonstrated not only can
a system suck a cluster of machines can
suck as well and and that is just
amazing how win this for a long time and
so we have to fundamentally rethink
about the way we build applications so
thank you for the help over there that's
kind of the way we've been building ass
but let's see how we can do this a
little different so what I want to do a
little differently here in this case is
that I want to go ahead and say well go
ahead and bring up a stock a server dart
get feed and I'm gonna pass to it the
symbols that I'm gonna provide for it
well what does this do there's a get
feed function I'm gonna create and the
get feed is gonna return a feed for me
and and let's kind of entertain this a
little further and see how this is gonna
work so in this case what I'm gonna do
here is I'm going to ask it to go to the
feed and in this case let's go ahead and
implement that little method I'm
interested in implementing so in this
case here's the get feed method well we
need some tools to implement this there
are several tools available for this I
mentioned that Microsoft Research
introduced this idea years ago and I
program with c-sharp I program with the
Microsoft languages and tools but I've
noticed one thing very different between
the Microsoft world and the Java and
JavaScript world in the Microsoft world
if you introduce a solution
they will quietly sit there and use it
and produce value so this has been in
Microsoft Word for a long time but it
really talked about it but there's one
thing very different from the Java and
JavaScript world when you go to the Java
and Java world you show a solution
people don't use it they immediately get
excited about it and create 20,000
framework around it and that's where
people got excited about this
the minute the Java and Java world came
to know about this there are so many
solutions there are several solutions in
the Java world now there are solutions
in the JavaScript world too in fact this
has been a really aha moment for me is
I've been looking at reactive
programming for a few years now tell you
in the last about maybe year and a half
or so almost any tool and any library
and framework I'm using suddenly has
turned into reactor for a group for
example spring five is reactive as they
say there are so many other tools that
are reactive as well you cannot escape
reactive programming moving forward a
lot of different tools and libraries are
already using this so in that regard I'm
gonna go ahead and use one tool here so
I'm gonna say observable and in this
case observable off stock info but where
in the world is this observable coming
from well this observable in this case
is gonna come from the RX Java
well rx Java is a tool created by
Netflix apparently they have some
streaming issues to deal with so they
decided to open source this tool you
don't have to use rx Java there are
other tools like vertex you could use as
well there is akka
also is a reactive library there are so
many solutions available on the JVM
today but this is just one example and
rx Java does a fairly good job as well
so in this case I have observable I'm
gonna return from here but when I what
I'm gonna do here is I'm gonna simply
say let's go ahead and say created
observable and then how do I create the
observable well I'm gonna say observable
dot create and this uses the same
principle in effective Java rather than
using a constructor users use a static
factory method to create it
I'm gonna say in this case embed let's
call this as emitter and and what I'm
gonna do here is I'm gonna emit data to
the emitter and I'm gonna pass the
symbols to it
let's go ahead and implement the emitter
method right here so what does the emit
method going to do well it receives the
emitter and the symbols and I'm gonna go
ahead and say in this case start
emitting well and the point I wanted to
make is the following so I'm gonna go
back over here to this sample over here
and I'm gonna go ahead and save this
away into a variable called feed and
then once I save it into feed I'm gonna
go ahead and say got observable now
remember one of the things I said
efficiency is attained not by doing
things faster but by avoiding things
that shouldn't be done in the first
place so when I go ahead and execute
this little example here what it
actually does in this case is it says
created observable and it says got
observable but quite important notice it
did not start emitting and the reason it
did not start emitting is it's pretty
darn lazy it says look you haven't
really used the data you have been
started using the data yet so why should
I bother really doing anything so it's
pretty lazy as you can see well what I'm
gonna do now is I'm gonna go to the feed
and say subscribe and now I am
subscribing to the data that's going to
come from it well remember from our
discussion a few minutes ago an
observable has three different channels
it's got the data channel the error
channel and the complete channel where
are those two three channels well those
three channels are going to appear here
as three functions we're gonna pass to
the subscribe so the subscribe already
has three channels you can subscribe to
so in this case I'm gonna say data
coming from the data Channel I'm gonna
simply output the data and you can write
it this way definitely fine or you can
say given an error I can simply output
the error and as we know we could also
write this as system dot system dot out
and then of course we could simply say
learn and this shows you the two
different ways to write it this is the
data channel you could have written this
like this also using method reference
this is the error channel you could have
also written this using the lambda like
this also and finally comes the complete
channel so in this case I'm gonna simply
output let's go ahead and say done to
say that I'm done I don't have any more
data now when I go back and run this you
can see in this case it's a start
emailing and the reason of course is
because we did subscribe to it and it
can no longer be lazy it says oh you are
really interested in the data I'm going
to send I might as well start emitting
to you and that's the subscription
that's we're going to start but of
course I really want to get some data
through here so what am I going to do
I'm gonna go back to the service right
here and instead of saying start
emitting what I want to do here is to
really do the emitting so I'm gonna say
while let's go ahead a say in this case
a count is less than oh let's say 10
let's go ahead and say count is equal to
zero and in this case of course while
count is plus plus is less than 10 I'm
gonna start emitting some data well the
way I'm gonna emit it is I'm gonna say
symbol start stream and then I will go
ahead and say dot map and in this case
given the symbol I'm gonna say stock
info and I'm gonna call a fetch method
well the fetch method is gonna take a
simple and return the stock info object
for me and the stock info contains the
price of the stock and the ticker symbol
and then I'll say for each and then I
can say in this case you have a stock
info given and I'm gonna say emitter
dart and I will say on next and then I
will send the stock info to it or as we
know where rather than writing it this
way we could write this as simply using
a method reference we could say emitter
on next as well and then we could just
pass that through so what's happening in
this case is I am receiving the data the
symbols I'm converting transforming to
the data and the minute I get the data
for the stock symbol I'm gonna go ahead
and send it across to the emitter well
this is the mouth of the data channel
where we gonna start emitting the data
going through it
so as a result now when we go back and
run this little code what we're going to
see here is that it's gonna start
emitting data from the service and right
there is the Apple stock price and the
Google price and Microsoft price just
it's fetching their data from the fetch
method and giving us the data as it goes
through and I've asked you to send it
ten times and it's sending it as many
times as I asked for so that is an
example of how this can be transmitted
to us as it goes on I just stopped it so
you can see how that's going to be
transmitted to us so this is where the
emitting is happening and of course in
this case we can see that as the
emitting is happening this is on the
receiving end and it's displaying the
data well this shows us how we are able
to receive the data but one of the
really cool things about the observable
pattern observed observable abstraction
here is it dream of data so you have an
observable that's going to emit the data
and I'm the subscriber interested in
receiving the data and handling it but
there are times when you may have
intermediaries that want to do certain
things for example let's say you're not
interested in any price that is less
than let's say over $100 well here you
can see there is some price less than
hundred some prices more than hundred as
well but what if you're not interested
in any price less than hundred well the
beauty of this is you can put these
intermediate operations these are
subjects subjects can become observable
subscribers to upstream and they become
observables to downstream so I can be in
the middle and I can say I want to only
transmit data that's meeting my
selection criteria so you can see the
function of programming concepts emerge
really well right here I can say stock
info stock info dot value is greater
than hundred and otherwise don't bother
transmitting it so now when I run this
code you can see in this case you can
see Apple and you can then see
we'll come through but you don't see
Microsoft and Intel because the values
are less than hundred dollars so that
gives you an idea about how this can be
filtered out similarly you can perform a
transformation you could say dot map and
then you could say return a new stock
info with the stock info dot ticker and
then maybe I can take the price given to
me and maybe add a commission to it and
say one point one and this is going to
transform the data and send it along the
way
and you can see the prices inflated
right now as you can see in this
particular case so the point really is
you can have these beautiful set of
observables that can transform the data
along the way and you can do variations
with it so what this tells us is you
could start laying down this pipeline of
operations data could be emerging from a
data source there could be a subscriber
on the tail end but you can start
putting any number of levels of
intermediate operations that can go
through and as the data is being emitted
it can process that but on the other
hand like this particular thing
something could go wrong and things can
start falling apart what do you do in
that case well to illustrate that little
point let's go back to this code for a
second and notice in this case I'm
transforming the data and simply sending
it that's all I'm doing so when I go
back and run this you can see it's
reporting the data as it comes through
for Apple and and so on but what if
something were to go wrong what are we
gonna do about it well to illustrate
this point let's go to the fetch method
right here and in the fetch method I'm
gonna simply right in the middle of this
with nothing else I'm gonna simply put a
random is less than point two I'm gonna
blow up with the very useful message
call oops
ran into trouble so in this case it just
blows up as you can see but we talked
about this earlier blowing up with
exceptions is a terrible thing to do
because exception is an imperative style
of programming concept it doesn't jive
well with functional style so what do we
want to do when something goes wrong
what you
really want to do is you want to cap
exception and then you want to deliver
that as like a data but you want to
deliver that as an error rather than as
a data so in other words this exception
that's happening here should be
transferred through error channel and
the data channel should close up at this
point let's see if that's going to
happen so I'm gonna uncomment that
random is less than two let's go back
here and run the code right now and as
you can see right here as it is getting
the data that data is arriving for Apple
Google Microsoft and so on but at any
time that particular thing is going to
blow up what is it gonna do well it's
gonna capture that error but it's gonna
send it to us here as oops ran into
trouble and notice that God printed
right here in fact to make it really
clear that's what really happened if I
take the error right here and I'm gonna
say you know error here and then I will
go ahead and say :
and plus error so that way we can be
sure that we really are receiving that
here on this end so that exception that
occurred on the other side has been
captured by the observable and it
transmitted to us as error through the
error channel right here and then of
course the data channel closes up we
don't get any more data from it and so
the error becomes data like error
becomes a first-class citizen like it's
data it's handed to us separately so so
you can be working with a system where
something could go wrong now of course
the question is when error happens why
are you not getting any more data well
the reason simply is it's based on the
concept of circuit breakers if something
were to go wrong you don't keep pinging
for more things from it you let it heal
well one of the things you could
potentially do here is you depending on
your application you could say on error
resume next and you could switch over to
a alternative or a backup server if
there was an error for example if I'm
looking at let's say one map let's say
google map and something was wrong I
don't want to say gosh I don't want to
go
to where I want to go today because the
map is broken well dude go use some
other map to get where you want to go so
I may switch over to a different map at
the point that's the whole point about
this is you can switch on that in the
case of an error to a backup service and
you could do that as well if that makes
sense to what you want to do so what we
saw right now he is we looked at
observable as a stream of data well one
of the beautiful things here is you can
unsubscribe from this as well so you can
see in this case we saw how the error
was handled there are several other
things you can do with it one of them is
you can unsubscribe and say hey thanks
but no thanks I don't want you to give
me any more data and you can unsubscribe
from the observable as well and you can
send a message by calling a disposed on
the observable and and so the observer
can then know it is not going to send
any more data to you likewise as I
mentioned earlier you are you are
observable can also send a piece of data
to the client saying well let's take a
look at this really quickly I'm gonna
say emitter dot on next new stock info
and in this case I'm gonna simply send
blah and 0.0 just to illustrate a silly
example here if I go back over here
let's make this less than 3 so if you
notice in this example when I run this
you can see that it goes through and
gets the prices for us and prints those
prices but there at the very end it's
gonna get the BLA which is the last
value that I'm sending out but what I'm
gonna do here is right before this point
I'm gonna say emit or dart on complete
I'm gonna send a complete signal well
notice there's the block rhyming coming
through because I've not said the
complete yet I just made the change to
the code but this time when I run this
though notice that because I have
completed this in send a complete signal
it no longer will send the data through
the data Channel because the data
channel closes up so as a result you can
see in the very end
it displays the done that is right here
and shows that it's done there's not
going to be any more
coming through and of course the blood
did not come through that is their data
channel shutting down when the complete
signal has been sent and that's already
programmed in it likewise you can do
things like skip pick and evaluate I
used a filter filter is kind of like a
valve that opens and closes per data but
I take violence and and skip or like for
example they will permanently be closed
after a certain point or they can stay
you know closed in the beginning and
open up when a certain condition is met
you could do that and last thing about a
synchrony how do we handle that well one
of the beautiful things about this is if
you ever want to run this in
asynchronous mode all you would have to
do is come in here and say subscribe on
and you can say schedulers and you can
specify what kind of thread pool you are
interested in if your job is
predominantly computation intensive you
can use a computation pool which will
create as many threads as a number of
course or you can also create for
example and i/o where it'll keep
creating threads as the requests are
coming in if threads are not available
in the pool but the beauty of this is
the stream processing can now done be
asynchronously in multiple threads
rather than having to be done in a
single thread and you can see the
structure of the code is not very
different you are able to just interject
that request for running an asynchrony
berry easily so to summarize what we
talked about so far we can use these
kind of facilities very easily to
rethink about how we build applications
predominantly we've been working with
applications that are crud modeled but
we are beginning to rethink about
dataflow computing data flow computing
has been around for a very long time
it's not new but the idea has lingered
around for a long time but usage of it
has been kind of you know if we over the
years but where it's a resurgence of the
data flow computing there is a data
source that wants to keep transmitting
data to you and you want to be able to
handle this data as and when the data
becomes available you
to be able to use the efficiency by
being lazy and you want to be there up
to be pushed towards you but only when
you're interested in the data and then
of course the error handling has to be
done fairly well so to really summarize
the four key principles of reactive
programming you want the application to
benefit from message driven systems you
want this to be scalable through
elasticity you want to handle resilience
deal with the data and error properly
and you want the application to be
responsive as well and and there are two
places where you may begin to use your
own libraries and API is you may begin
to use reactive programming and reactive
solutions that's one aspect but the
other one that you cannot probably miss
out is the libraries and frameworks you
use a lot of them are already beginning
to change into reactive api's and this
is something we cannot escape in the
long run so learning about reactive
programming and applying it is something
that I think it's going to benefit us in
the long run and besides it's also like
I mentioned seems like a very nice
logical step to with functional
programming took us to it takes us right
from there and makes turns the lazy
evaluation and function composition into
something very practical hope that was
useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>